GB2560208B - Block operations for an image processor having a two-dimensional execution lane array and a two-dimensional shift register - Google Patents
Block operations for an image processor having a two-dimensional execution lane array and a two-dimensional shift register Download PDFInfo
- Publication number
- GB2560208B GB2560208B GB1709786.6A GB201709786A GB2560208B GB 2560208 B GB2560208 B GB 2560208B GB 201709786 A GB201709786 A GB 201709786A GB 2560208 B GB2560208 B GB 2560208B
- Authority
- GB
- United Kingdom
- Prior art keywords
- array
- shift register
- processor
- data
- image
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N25/00—Circuitry of solid-state image sensors [SSIS]; Control thereof
- H04N25/70—SSIS architectures; Circuits associated therewith
- H04N25/76—Addressed sensors, e.g. MOS or CMOS sensors
- H04N25/767—Horizontal readout lines, multiplexers or registers
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T1/00—General purpose image data processing
- G06T1/20—Processor architectures; Processor configuration, e.g. pipelining
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/02—Addressing or allocation; Relocation
- G06F12/0207—Addressing or allocation; Relocation with multidimensional access, e.g. row/column, matrix
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F15/00—Digital computers in general; Data processing equipment in general
- G06F15/76—Architectures of general purpose stored program computers
- G06F15/80—Architectures of general purpose stored program computers comprising an array of processing units with common control, e.g. single instruction multiple data processors
- G06F15/8007—Architectures of general purpose stored program computers comprising an array of processing units with common control, e.g. single instruction multiple data processors single instruction multiple data [SIMD] multiprocessors
- G06F15/8023—Two dimensional arrays, e.g. mesh, torus
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F17/00—Digital computing or data processing equipment or methods, specially adapted for specific functions
- G06F17/10—Complex mathematical operations
- G06F17/16—Matrix or vector computation, e.g. matrix-matrix or matrix-vector multiplication, matrix factorization
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F5/00—Methods or arrangements for data conversion without changing the order or content of the data handled
- G06F5/01—Methods or arrangements for data conversion without changing the order or content of the data handled for shifting, e.g. justifying, scaling, normalising
- G06F5/015—Methods or arrangements for data conversion without changing the order or content of the data handled for shifting, e.g. justifying, scaling, normalising having at least two separately controlled shifting levels, e.g. using shifting matrices
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/30003—Arrangements for executing specific machine instructions
- G06F9/30007—Arrangements for executing specific machine instructions to perform operations on data operands
- G06F9/3001—Arithmetic instructions
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N25/00—Circuitry of solid-state image sensors [SSIS]; Control thereof
- H04N25/40—Extracting pixel data from image sensors by controlling scanning circuits, e.g. by modifying the number of pixels sampled or to be sampled
Description
Block Operations for an Image Processor Having a Two-Dimensional Execution Lane Array and a Two-Dimensional Shift Register
Field of Invention
The field of invention pertains generally to image processing, and, more specifically, to block operations for an image processor having a two-dimensional execution lane array and a two-dimensional shift register.
Background
Image processing typically involves the processing of pixel values that are organized into an array. Here, a spatially organized two dimensional array captures the two dimensional nature of images (additional dimensions may include time (e.g., a sequence of two dimensional images) and data type (e.g., colors). In a typical scenario, the arrayed pixel values are provided by a camera that has generated a still image or a sequence of frames to capture images of motion. Traditional image processors typically fall on either side of two extremes. A first extreme performs image processing tasks as software programs executing on a general purpose processor or general purpose-like processor (e.g., a general purpose processor with vector instruction enhancements). Although the first extreme typically provides a highly versatile application software development platform, its use of finer grained data structures combined with the associated overhead (e.g., instruction fetch and decode, handling of on-chip and off-chip data, speculative execution) ultimately results in larger amounts of energy being consumed per unit of data during execution of the program code. A second, opposite extreme applies fixed function hardwired circuitry to much larger blocks of data. The use of larger (as opposed to finer grained) blocks of data applied directly to custom designed circuits greatly reduces power consumption per unit of data. However, the use of custom designed fixed function circuitry generally results in a limited set of tasks that the processor is able to perform. As such, the widely versatile programming environment (that is associated with the first extreme) is lacking in the second extreme. A technology platform that provides for both highly versatile application software development opportunities combined with improved power efficiency per unit of data remains a desirable yet missing solution.
Summary
The invention is defined by the claims.
List of Figures
The following description and accompanying drawings are used to illustrate various embodiments of the invention. In the drawings:
Fig. 1 shows various components of a technology platform;
Fig. 2a shows an embodiment of application software built with kernels;
Fig. 2b shows an embodiment of the structure of a kernel;
Fig. 3 shows an embodiment of the operation of a kernel;
Figs. 4a, 4b and 4c depict various aspects of a virtual processor’s memory model for developing kernel threads in a higher level application software development environment;
Fig. 5a shows an embodiment of a thread written with load instructions having a position relative format;
Fig. 5b shows images having different pixel densities;
Fig. 6 shows an embodiment of an application software development and simulation environment;
Fig. 7 shows an embodiment of an image processor hardware architecture;
Figs. 8a, 8b, 8c, 8d and 8e depict the parsing of image data into a line group, the parsing of a line group into a sheet and the operation performed on a sheet with overlapping stencils;
Fig. 9a shows an embodiment of a stencil processor;
Fig. 9b shows an embodiment of a instruction word of the stencil processor;
Fig. io shows an embodiment of a data computation unit within a stencil processor;
Figs, na, nb, nc, nd, lie, lif, lig, nh, ni, nj and ilk depict an example of the use of a two-dimensional shift array and an execution lane array to determine a pair of neighboring output pixel values with overlapping stencils;
Fig. 12 shows an embodiment of a unit cell for an integrated execution lane array and two-dimensional shift array;
Fig. 13 shows a two-dimensional row/column sum operation;
Figs. 14a, 14b, 14c and I4d show low level operations for implementing a two dimensional row sum operation;
Fig. 15 pertains to a two-dimensional prefix sum operation;
Figs. 16a, 16b, 16c and i6d show low level operations for implementing a two-dimensional prefix sum operation;
Fig. 17 pertains to a two-dimensional find minimum operation;
Figs. 18a, 18b, 18c and i8d show low level operations for implementing a two-dimensional find minimum operation;
Figs. 19a and 19b show a matrix multiply operation;
Figs. 20a, 20b, 20c, 2od and 20e show low level operations for implementing a matrix multiply operation with a two dimensional shift register;
Fig. 21 shows a DFT operation;
Figs. 22a, 22b, 22c, 22d, 22e and 22f show low level operations for implementing a DFT operation with a two dimensional shift register;
Fig. 23 shows butterfly operations;
Figs. 24a, 24b and 24c show butterfly operations implemented with a two-dimensional shift register;
Fig. 25 shows a base image and an alternative image having a block image;
Figs. 26a, 26b, 26c and 26d show low level operations for performing a block matching algorithm;
Fig. 27 shows an environment for generating program code that is targeted to a hardware platform having a two-dimensional execution lane array and a two-dimensional shift register array;
Fig. 28 shows an embodiment of a computing system.
Detailed Description i. Introduction
The description below describes numerous embodiments concerning a new image processing technology platform that provides a widely versatile application software development environment that uses larger blocks of data (e.g., line groups and sheets as described further below) to provide for improved power efficiency. l.o Application So ftware Development Environment a. application and structure of kernels
Fig. 1 shows a high level view of an image processor technology platform that includes a virtual image processing environment 101, the actual image processing hardware 103 and a compiler 102 for translating higher level code written for the virtual processing environment 101 to object code that the actual hardware 103 physically executes. As described in more detail below, the virtual processing environment 101 is widely versatile in terms of the applications that can be developed and is tailored for easy visualization of an application’s constituent processes. Upon completion of the program code development effort by the developer 104, the compiler 102 translates the code that was written within the virtual processing environment 101 into object code that is targeted for the actual hardware 103.
Fig. 2a shows an example of the structure and form that application software written within the virtual environment may take. As observed in Fig. 2a, the program code may be expected to process one or more frames of input image data 201 to effect some overall transformation on the input image data 201. The transformation is realized with the operation of one or more kernels of program code 202 that operate on the input image data in an orchestrated sequence articulated by the developer.
For example, as observed in Fig. 2a, the overall transformation is effected by first processing each input image with a first kernel Ki. The output images produced by kernel Ki are then operated on by kernel K2. Each of the output images produced by kernel K2 are then operated on by kernel K3_i or K3_2. The output images produced by kernel(s) K3_i/K3_2 are then operated on by kernel K4. Kernels K31 and K32 may be identical kernels designed to speed-up the overall processing by imposing parallel processing at the K3 stage, or, maybe different kernels (e.g., kernel K31 operates on input images of a first specific type and kernel Κβ_2 operates on input images of a second, different type).
As such, the larger overall image processing sequence may take the form of a image processing pipeline or a directed acyclic graph (DAG) and the development environment may be equipped to actually present the developer with a representation of the program code being developed as such. Kernels maybe developed by a developer individually and/or may be provided by an entity that supplies any underlying technology (such as the actual signal processor hardware and/or a design thereof) and/or by a third party (e.g., a vendor of kernel software written for the development environment). As such, it is expected that a nominal development environment will include a “library” of kernels that developers are free to “hook-up” in various ways to effect the overall flow of their larger development effort. Some basic kernels that are expected to be part of such a library may include kernels to provide any one or more of the following basic image processing tasks: convolutions, denoising, color space conversions, edge and corner detection, sharpening, white balance, gamma correction, tone mapping, matrix multiply, image registration, pyramid construction, wavelet transformation, block-wise discrete cosine, and Fourier transformations.
Fig. 2b shows an exemplary depiction of the structure of a kernel 203 as may be envisioned by a developer. As observed in Fig. 2b, the kernel 203 can be viewed as a number of parallel threads of program code (“threads”) 204 that are each operating on a respective underlying processor 205 where each processor 205 is directed to a particular location in an output array 206 (such as a specific pixel location in the output image that the kernel is generating). For simplicity only three processors and corresponding threads are shown in Fig. 2b. In various embodiments, every depicted output array location would have its own dedicated processor and corresponding thread. That is, a separate processor and thread can be allocated for each pixel in the output array. In alternative approaches, a same thread may generate data for more than output pixel and/or two different threads (e.g., in certain limited cases) may collaborate on the generation of the data for a same output pixel.
As will be described in more detail below, in various embodiments, in the actual underlying hardware an array of execution lanes and corresponding threads operate in unison (e.g., in a Single Instruction Multiple Data (SIMD) like fashion) to generate output image data for a portion of a “line group” of the frame currently being processed. A line group is a contiguous, sizable section of an image frame. In various embodiments, the developer may be conscious the hardware operates on line groups, or, the development environment may present an abstraction in which there is a separate processor and thread for, e.g., every pixel in the output frame (e.g., every pixel in an output frame generated by its own dedicated processor and thread). Regardless, in various embodiments, the developer understands the kernel to include an individual thread for each output pixel (whether the output array is visualized as an entire output frame or a section thereof).
As will be described in more detail below, in an embodiment the processors 205 that are presented to the developer in the virtual environment have an instruction set architecture (ISA) that, not only supports standard (e.g., RISC) opcodes, but also includes specially formatted data access instructions that permit the developer to easily visualize the pixel by pixel processing that is being performed. The ability to easily define/visualize any input array location in combination with an entire ISA of traditional mathematical and program control opcodes allows for an extremely versatile programming environment that essentially permits an application program developer to define, ideally, any desired function to be performed on any sized image surface. For example, ideally, any mathematical operation can be readily programmed to be applied to any stencil size.
With respect to the data access instructions, in an embodiment the ISA of the virtual processors (“virtual ISA”) include a special data load instruction and a special data store instruction. The data load instruction is able to read from any location within an input array of image data. The data store instruction is able to write to any location within the output array of image data. The latter instruction allows for easily dedicating multiple instances of the same processor to different output pixel locations (each processor writes to a different pixel in the output array). As such, for example, stencil size itself (e.g., expressed as a width of pixels and a height of pixels) can be made an easily programmable feature. Visualization of the processing operations is further simplified with each of the special load and store instructions having a special instruction format whereby target array locations are specified simplistically as X and Y coordinates.
Regardless, by instantiating a separate processor for each of multiple locations in the output array, the processors can execute their respective threads in parallel so that, e.g., the respective values for all locations in the output array are produced concurrently. It is noteworthy that many image processing routines typically perform the same operations on different pixels of the same output image. As such, in one embodiment of the development environment, each processor is presumed to be identical and executes the same thread program code. Thus, the virtualized environment can be viewed as a type of two-dimensional (2D), SIMD processor composed of a 2D array of, e.g., identical processors each executing identical code in lock-step.
Fig. 3 shows a more detailed example of the processing environment for two virtual processors that are processing identical code for two different pixel locations in an output array. Fig. 3 shows an output array 304 that corresponds to an output image being generated. Here, a first virtual processor is processing the code of thread 301 to generate an output value at location Xi of the output array 304 and a second virtual processor is processing the code of thread 302 to generate an output value at location X2 of the output array 304. Again, in various embodiments, the developer would understand there is a separate processor and thread for each pixel location in the output array 304 (for simplicity Fig. 3 only shows two of them). However, the developer in various embodiments need only develop code for one processor and thread (because of the SIMD like nature of the machine).
As is known in the art, an output pixel value is often determined by processing the pixels of an input array that include and surround the corresponding output pixel location. For example, as can be seen from Fig. 3, position Xi of the output array 304 corresponds to position E of the input array 303. The stencil of input array 303 pixel values that would be processed to determine output value Xi would therefore corresponds to input values ABCDEFGHI. Similarly, the stencil of input array pixels that would be processed to determine output value X2 would corresponds to input values DEFGHIJKL.
Fig. 3 shows an example of corresponding virtual environment program code for a pair of threads 301,302 that could be used to calculate output values Xi and X2, respectively. In the example of Fig. 3 both pairs of code are identical and average a stencil of nine input array values to determine a corresponding output value. The only difference between the two threads is the variables that are called up from the input array and the location of the output array that is written to. Specifically, the thread that writes to output location Xi operates on stencil ABCDEFGHI and the thread that writes to output location X2 operates on stencil DEFGHIJKL.
As can be seen from the respective program code from the pair of threads 301,302, each virtual processor at least includes internal registers Ri and R2 and at least supports the following instructions: 1) a LOAD instruction from the input array into Ri; 2) a LOAD instruction from the input array into R2; 3) an ADD instruction that adds the contents of Ri and R2 and places the resultant in R2; 4) a DIV instruction that divides the value within R2 by immediate operand 9; and, 5) a STORE instruction the stores the contents of R2 into the output array location that the thread is dedicated to. Again, although only two output array locations and only two threads and corresponding processors are depicted in Fig. 3, conceivably, every location in the output array could be assigned a virtual processor and corresponding thread that performs these functions. In various embodiments, in keeping with the SIMD-like nature of the processing environment, the multiple threads execute in isolation of one another. That is, there is no thread-to-thread communication between virtual processors (one SIMD channel is preventing from crossing into another SIMD channel). b. virtual processor memory model
In various embodiments, a pertinent feature of the virtual processors is their memory model. As is understood in the art, a processor reads data from memory, operates on that data and writes new data back into memory. A memory model is the perspective or view that a processor has of the manner in which data is organized in memory. Figs. 4a - 4c pertain to an embodiment of the memory model for the virtual processors of the development environment. A simplistic environment involving only three virtual processors and corresponding threads 401 is used for purposes of example. As will be described in more detail below, the memory model of the virtual processors takes care to preserve SIMD semantics while, at the same time, provide for scalar operations and private intermediate value storage space for each virtual processor.
As observed in Fig. 4a, in an embodiment, the memory region 420 that each virtual processor operates out of is organized into six different partitions based on the type of information that is stored. Specifically, there exists: 1) a private scratchpad region 402; 2) a global input data array region 403; 3) a global output data array region 404; 4) a global look-up table information region 405; 5) a global atomic statistics region 406; and, 6) a global constant table information region 407.
The partitions as depicted in Fig. 4a attempt to visualize those regions of memory that are shared or “global” amongst virtual processors in keeping with the SIMD-like nature of the overall processing environment. Likewise, Fig. 4a also attempts to visualize other regions of memory that are not shared amongst virtual processors or are “private” to a particular virtual processor. Specifically, as observed in Fig. 4a, all of the memory partitions are global with the exception of a scratchpad region 402 that is private to each virtual processor. A number of the different memory regions also have different memory addressing schemes as described further below.
With respect to the scratch pad region 402, it is not uncommon to temporarily store intermediate information over the course of execution of a sophisticated image processing algorithm (e.g., and then read the information back and use it a later time). Additionally, it is not uncommon for such information to be different across threads (different input values may effect different intermediate values). The memory model therefore includes per processor private scratchpad regions 402 for the storage of such intermediate information by each virtual processor’s corresponding thread. In an embodiment, the scratch pad region for a particular processor is accessed 409 by that processor through a typical (e.g., linear) random access memory address and is a read/write region of memory (i.e., a virtual processor is able to both read information from private memory as well as write information into private memory). Embodiments of the virtual processor ISA instruction format for accessing the scratchpad region are discussed in more detail further below.
The input array portion 403 contains the set of input data that is called into 408 the set of threads in order to produce output data. In a typical situation the input array corresponds to an image (e.g., a frame) or section of an image that each thread is operating on or within. The input image may be a true input such as the pixel information provided by a camera, or, some form of intermediate image such as the information provided by a previous kernel in a larger overall image processing sequence. Virtual processors typically do not compete for same input data items because they operate on different pixel locations of the input image data during a same cycle.
In an embodiment, a novel memory addressing scheme is used to define which particular input values are to be called in from the input array 403. Specifically, a “position relative” addressing scheme is used that defines the desired input data with X, Y coordinates rather than a traditional linear memory address. As such, the load instruction of the virtual processors’ ISA includes an instruction format that identifies a specific memory location within the input array with an X component and a Y component. As such, a two-dimensional coordinate system is used to address memory for input values read from the input array 403.
The use of a position relative memory addressing approach permits the region of an image that a virtual processor is operating on to be more readily identifiable to a developer. As mentioned above, the ability to easily define/visualize any input array location in combination with an entire ISA of traditional mathematical and program control opcodes allows for an extremely versatile programming environment that essentially permits an application program developer to readily define, ideally, any desired function to be performed on any sized image surface. Various instruction format embodiments for instructions that adopt a position relative addressing scheme, as well as embodiments of other features of the supported ISA, are described in more detail further below.
The output array 404 contains the output image data that the threads are responsible for generating. The output image data may be final image data such as the actual image data that is presented on a display that follows the overall image processing sequence, or, maybe intermediate image data that a subsequent kernel of the overall image processing sequence uses as its input image data information. Again, virtual processors typically do not compete for same output data items because they write to different pixel locations of the output image data during a same cycle.
In an embodiment, the position relative addressing scheme is also used for writes to the output array. As such, the ISA for each virtual processor includes a store instruction whose instruction format defines a targeted write location in memory as a two-dimensional X, Y coordinate rather than a traditional random access memory address. More details concerning embodiments of the position relative instructions of the virtual ISA are provided further below.
Fig. 4a also shows each virtual processor performing a look-up 410 into a look-up table 411 that is kept within the look-up table memory region 405. Look-up tables are often used by image processing tasks to, e.g., obtain filter or transform coefficients for different array locations, implement complex functions (e.g., gamma curves, sine, cosine) where the look-up table provides the function output for an input index value, etc. Here, it is expected that SIMD image processing sequences will often perform a look-up into a same look-up table during a same clock cycle. As such, like the input and output array memory regions 403,404, the look-up table region 405 is globally accessible by any virtual processor. Fig. 4a likewise shows each of the three virtual processors effectively looking-up information from a same look-up table 411 kept in the look-up table memory region 405.
In an embodiment, as index values are typically used to define a desired look-up table entry, the look-up table information region is accessed using a normal linear accessing scheme. In an embodiment the look-up region of memory is read only (i.e., the processor can not change information in a look-up table and is only permitted to read information from it). For simplicity Fig. 4a suggests only one look-up table is resident within the look-up table region 405 but the virtual environment permits for multiple, different look-up tables to be resident during the simulated runtime. Embodiments of the virtual ISA instruction format for instructions that perform look-ups into the lookup table are provided further below.
Fig. 4b shows each of the three virtual processors writing 413 to the atomic statistics region 406. It is not uncommon for image processes to “update” or make a modest change to output information. The updated information may then be used for other downstream processes that make use of the updated information. Examples of such updates or modest changes include simple additions of a fixed offset to output data, simple multiplication of a multiplicand against output data, or minimum or maximum comparisons of output data against some threshold.
In these sequences, as observed in Fig. 4b, output data that has just been calculated by the individual threads 401 maybe operated upon and the resultants written 413 to the atomic statistics region 406. Depending on implementation semantics, the output data that is operated on by an atomic act may be kept internally by the processor or called up 412 from the output array, Fig. 4b shows the later. In various embodiments, the atomic acts that may be performed on the output data include add, multiply, min, and max. In an embodiment, the atomic statistics region 406 is accessed using a position relative addressing scheme (as with input and output array accesses) given that updates to output data would logically be organized in a same two dimensional array as the output data itself. Embodiments of the virtual ISA instruction format for performing an atomic act on output data and writing the resultant to the statistics region 406 are described in more detail further below.
Fig. 4c shows each of the virtual processors reading 414 a constant value from a constant look-up table 415 within the constant memory region 407. Here, e.g., it is expected that different threads 401 may need a same constant or other value on the same clock cycle (e.g., a particular multiplier to be applied against an entire image). Thus, accesses into the constant look-up table 415 return a same, scalar value to each of the virtual processors as depicted in Fig. 4c. Because look-up tables are typically accessed with an index value, in an embodiment, the constant look-up table memory region is accessed with a linear random access memory address. In an embodiment the constant region of memory is read only (i.e., the processor can not change information in a constant table and is only permitted to read information from it). For simplicity Fig. 4c only shows a single constant look-up table 415 in the constant memory region 407. As threads may make use of more than one such table memory region 407 is configured to be large enough to hold as many constant tables are needed/used.
c. virtual processor ISA
As alluded to above in multiple instances, the virtual processor ISA may include a number of pertinent features. Some of these described at length immediately below.
In various embodiment the instruction format of each virtual processor’s ISA uses a relative positioning approach to define an X, Y coordinate for each of the following: 1) a LOAD instruction that reads input image data from the input array memoiy region; 2) a STORE instruction that writes output image data to the output array; and, 3) an atomic update to the statistics region of memory.
The ability to easily define any input array location in combination with an entire ISA of traditional data access, mathematical, and program control opcodes allows for an extremely versatile programming environment that essentially permits an application program developer to define, ideally, any desired function to be performed on any sized image surface. For example, ideally, any mathematical operation can be readily programmed to be applied to any stencil size.
In an embodiment, instructions for loads/stores from/to the input/output arrays have the following format [OPCODE] LINEGROUP_(name)[(((X*XS + Xo)/XD);((Y*YS + Yo)/YD); Z] where [OPCODE] is the specific type of operation (LOAD from the input array, STORE to the output array) and LINEGROUP_(name) is the name assigned to a particular section of a particular image (e.g., a line group for a frame of image data) within the input or output array memory region. Here, because different line groups are operated on separately, the different linegroups are given different names so they can be uniquely identified/accessed (e.g., LINEGROUP_1, LINEGR0UP_2, etc.). Line groups of same name may exist in both the input array memoiy region and the output array memory region. The origin of any line group may be, e.g., its lower left hand corner within its appropriate memory region.
In the case of instructions that perform updates on the atomic statistics table, in an embodiment, the instruction format takes on the following similar structure [OPCODE] STATS_(name)[(((X*XS + Xo)/XD);((Y*YS + Yo)/YD); Z] with the notable difference being that the input operand information defines a position within a particular statistics table (STATS_(name)) rather than a particular line group within the input or output array. As with line groups, different names are given to different statistics tables so that a thread can uniquely operate on different statistics tables over the course of its operation. The [OPCODE] specifies the particular atomic act to be performed (e.g., STAT_ADD; STAT_MUL; STAT_MIN; STAT_MAX).
For either input/output array accesses or atomic statistics table accesses, the Z operand of the instruction defines which channel of a named line group or stats table is targeted by the instruction. Here, typically, a single image will have multiple channels. For example, video images typically have a red channel (R), a green channel (G), and a blue channel (B) for a same frame of the video stream. In a sense, a complete image can be viewed as separate R, G, and B channel images stacked on top of each other. The Z operand defines which one of these is targeted by the instruction (e.g., Z =o corresponds to the red channel, Z=i corresponds to the blue channel, and Z=2 corresponds to the green channel). Each line group and statistics table is therefore structured to include the content of each channel for the particular image being processed.
The (X*XS + Xo)/XD operand defines the X location within a named line group or stats table that is targeted by the instruction and the (Y*YS + Yo)/YD operand defines the Y location within a named line group or stats table that is targeted by the instruction. The XS and XD terms for the X location and the YS and YD terms for the Y location are used for scaling between input and output images having different pixel densities. Scaling is described in more detail further below.
In a simplest case, there is no scaling between input and output images and the X and Y components of the instruction format simply take the form of X + Xo and Y + Yo where Xo and Yo are positional offsets relative to the position of the thread. A thread is viewed as being assigned to the position within the output array line group that its output value is written to. A corresponding, same position is readily identifiable in the input array line group and any stats table.
As an example, if the thread is assigned a specific X, Y location in an output array LINEGROUP_1, the instruction LOAD LINEGROUP_1[(X-1);(Y-1);Z] would load from LINEGROUP_i a value that is to the left one pixel location and down one pixel location from the same X,Y position within the input array. A simple blur kernel that averages together the pixel values for the X,Y location along with its left and right neighbors may therefore be written in pseudo-code as depicted in Fig. 5a. As observed in Fig. 5a, the location ((X); (Y)) corresponds to the position of the virtual processor that is writing to the output array. In the above pseudo-code, LOAD corresponds to the opcode for a load from the input array and STORE corresponds to the opcode for the store to the output array. Note that there exists a LINEGROUP_i in the input array and a LINEGROUP_1 in the output array.
Fig. 5b depicts scaled images for purposes of explaining the scaling features of the relative positioning load and store instruction format. Down sampling refers to the transformation of a higher resolution image to a lower resolution image by providing in the output image less than all of the pixels that exist in the input image. Up sampling refers to the transformation of a lower resolution image to a higher resolution image by creating more pixels in the output image than exist in the input image.
For example, referring to Fig. 5b, if image 501 represents the input image and image 502 represents the output image, down sampling will be performed because there are less pixels in the output image than in the input image. Here, for each pixel in the output image, the pertinent pixels in the input image that determine the output value for an output pixel progress “farther away” from the output pixel location moving along either axis in the output image. For example, for a 3:1 down sampling ratio, the first pixel in the output image along either axis corresponds to the first, second, and third pixels along the same axis in the input image, the second pixel in the output image corresponds to the fourth, fifth, and sixth pixels in the input image, etc. Thus the first output pixel has a pertinent pixel in the third location while the second output pixel has a pertinent pixel in the sixth location.
As such, the XS and YS multiplicand terms in the relative positioning instruction format are used to implement down sampling. If the blur pseudo code of Fig. 5a where to be rewritten for 3:1 down sampling along both axis, the code would be rewritten as:
Ri <= LOAD LINEGROUP_i[((3X)-i);3(Y);o] R2 <= LOAD LINEGROUP_i[3(X);3(Y);o] R3 <= LOAD LINEGROUP_i[((3X)+i);3(Y);o] R2 <= ADD Rl, R2 R2 <= ADD R2, R3 R2 <= DIVR2, 3 STORE LINEGROUP_l[(X);(Y);(o)J; R2.
By contrast, in the case of 1:3 up sampling (e.g., image 502 is the input image and image 501 is the output image) the XD and YD divisors would be used to create three output pixels for every input pixel along either axis. As such, the blur code would be rewritten as:
Ri <= LOAD LINEGROUP_i[(X-i)/3;(Y)/3;o] R2 <= LOAD LINEGROUP_i[(X)/3;(Y)/3;o] R3 <= LOAD LINEGROUP_i[(X+i)/3;(Y)/3;o] R2 <= ADD Rl, R2 R2 <= ADD R2, R3 R2 <= DIVR2, 3 STORE LINEGROUP_l[(X);(Y);(o)J; R2
In various embodiments the instruction format for instructions that access the private, constant, and look-up portions of memory include an operand that also take the form of a*b + c where a is a base position, b is a scaling term and c is an offset. Here, however, a linear addressing approach is taken where the a*b + c term essentially corresponds to a linear index that is applied to the targeted table. Each of these instructions also include in the opcode and an identifier of the memory region being accessed. For example, an instruction that performs a look-up from the look-up table memory region maybe expressed as LOAD LKUP_(name)[(A*B + C)]. where LOAD is the opcode that identifies a load operation and LKUP_(name) specifies the name of the look-up table in the look-up table memory region being accessed. Again, multiple look-up tables may be used by a thread and therefore a naming scheme is used to identify the appropriate one of the more than one that exist in the look-up table memory region. A similar format with similarly minded opcode may be utilized for instructions that target the constant and the private memory regions (e.g., LOAD CNST_(name)[(A*B + C)]; LOAD PRVT_(name)[(A*B +C)]. In an embodiment, look-up table and the constant table accesses are read-only (a processor can not change the data that has been placed there). As such no STORE instructions exist for these memory regions. In an embodiment the private region of memory is read/write. As such a store instruction exists for that memory region (e.g., STORE PRVT[(A*B + C)].
In various embodiments, each virtual processor includes general purpose registers that can contain integer, floating point or fixed point values. Additionally, the general purpose registers may contain data values of configurable bit width such as 8,16 or 32 bit values. Thus, the image data at each pixel location in an input array or output array can have a data size of 8,16 or 32 bits. Here, a virtual processor can be configured for an execution mode that establishes the bit size and the numerical format of the values within the general purpose registers. Instructions may also specify immediate operands (which are input operands whose input values are expressed directly in the instruction itself rather being found in a specified register). Immediate operands can also have configurable 8,16 or 32 bit widths.
In an extended embodiment, each virtual processor is also capable of operating in a scalar mode or a SIMD mode internal to itself. That is, the data within a specific array location maybe viewed as a scalar value or as a vector having multiple elements. For example a first configuration may establish scalar operation of 8 bits where each image array position holds a scalar 8 bit value. By contrast another configuration may establish parallel/SIMD operation of 32 bits where each image array location is assumed to hold four 8 bit values for a total data size of 32 bits per array location.
In various embodiments each virtual processor also includes registers to hold predicate values. A single predicate value is often only one bit in length and expresses a resultant from an opcode that performs a true/false or greater than/less than test on existing data. Predicate values are used, e.g., to determine branch directions through the code during execution (and therefore are used as operands in conditional branch instructions). Predicate values can also be expressed as an immediate operand in an instruction.
In various embodiments each virtual processor includes registers to hold scalar values. Here, scalar values are stored into and read from the partition space of the memory model that is reserved for constants (as discussed above with respect to Fig. 4c). Here, each virtual processor of a group of virtual processors that are processing a same image uses the same scalar value from the constant memory space. In extended embodiments scalar predicates also exist. These are values kept in register space that meet the definition of both a predicate and a scalar.
In various embodiments each virtual processor is designed as a RISC-like instruction set whose supported arithmetic instruction opcodes include any workable combination of the following: 1) ADD (addition of operands A and B); 2) SUB (subtraction of operands A and B); 3) MOV (move operand from one register to another register); 4) MUL (multiple operands A and B); 5) MAD (multiply operands A and B and add C to resultant); 6) ABS (return absolute value of operand A); 7) DIV (divide operand A by operand B); 8) SHL (shift operand A to the left); 9) SHR (shift operand A to the right); 10) MIN/MAX (return which of operands A and B is greater); 11) SEL (select specified bytes of operand A); 12) AND (return the logical AND of operands A and B); 13) OR (return the logical OR of operands A and B); 14) XOR (return the logical exclusive OR of operands A and B); 15) NOT (return the logical inverse of operand A).
The instruction set also includes standard predicate operations such as: 1) SEQ (returns a 1 if A equals B); 2) SNE (returns a 1 if A does not equal B); 3) SLT (returns a 1 if A is less than B); 4) SLE (returns a 1 if A is less than or equal to B). Control flow instructions are also included such as JMP (jump) and BRANCH each of which may include nominal variables or predicates as operands. d. application software development and simulation environment
Fig. 6 depicts an application software development and simulation environment 601. As discussed above with respect to Fig. 2, a developer may develop a comprehensive image processing function (e.g., an image processing pipeline where each stage in the pipeline performs a dedicated image processing task, some other DAG prescribed set of routines, etc.) by arranging kernels in a strategic sequence that is consistent with the overall intended image transformation. Kernels may be called up from a library 602 and/or the developer may develop one or more custom kernels.
Kernels within the library 602 may be provided by a third party vendor of kernels and/or a provider of any underlying technology (e.g., a vendor of a hardware platform that includes the targeted hardware image processor or a vendor of the targeted hardware image processor (e.g., provided as a design thereof or as actual hardware)).
In the case of custom developed kernels, in many situations the developer need only write the program code for a single thread 603. That is, the developer need only write program code that determines a single output pixel value by referencing input pixel values relative to the output pixel location (e.g., with the aforementioned position relative memory access instruction format). Upon satisfaction of the operation of the single thread 603, the development environment may then automatically instantiate multiple instances of the thread code on a respective virtual processor to effect a kernel on an array of processors that operate on an image surface area. The image surface area maybe a section of an image frame (such as a line group).
In various embodiments, the custom thread program code is written in the object code of the virtual processor ISA (or a higher level language that is compiled down to the virtual processor ISA object code). Simulation of execution of the custom kernel’s program code may be performed in a simulated runtime environment that includes a virtual processor accessing a memory organized according to the memory model. Here, software models (object oriented or otherwise) of a virtual processor 604 and a memory 605 that incorporates the model are instantiated.
The virtual processor model 604 then simulates execution of the thread code 603. Upon satisfaction of the performance of a thread, its larger kernel and any larger function that the kernel belongs to, the whole is compiled into the actual object code of the underlying hardware. The entirety of the simulation environment 601 maybe implemented as software that runs on a computer system (e.g., a workstation) 606. 2.0 Hardware Architecture Embodiments a. image processor hardware architecture and operation
Fig. 7 shows an embodiment of an architecture 700 for an image processor implemented in hardware. The image processor may be targeted, for example, by a compiler that converts program code written for a virtual processor within a simulated environment into program code that is actually executed by the hardware processor. As observed in Fig. 7, the architecture 700 includes a plurality of line buffer units 7Oi_i through 7Oi_M (hereinafter “line buffers”, “line buffer units” or the like) interconnected to a plurality of stencil processor units 7O2_i through 7O2_N (hereinafter, “stencil processors”, “stencil processor units” or the like) and corresponding sheet generator units 7O3_i through 7O3_N (hereinafter “sheet generators”, “sheet generator units” or the like) through a network 704 (e.g., a network on chip (NOC) including an on chip switch network, an on chip ring network or other kind of network). In an embodiment, any line buffer unit may connect to any sheet generator and corresponding stencil processor through the network 704.
In an embodiment, program code is compiled and loaded onto a.corresponding stencil processor 702 to perform the image processing operations earlier defined by a software developer (program code may also be loaded onto the stencil processor’s associated sheet generator 703, e.g., depending on design and implementation). In at least some instances an image processing pipeline maybe realized by loading a first kernel program for a first pipeline stage into a first stencil processor 7O2_i, loading a second kernel program for a second pipeline stage into a second stencil processor 7O2_2, etc. where the first kernel performs the functions of the first stage of the pipeline, the second kernel performs the functions of the second stage of the pipeline, etc. and additional control flow methods are installed to pass output image data from one stage of the pipeline to the next stage of the pipeline.
In other configurations, the image processor may be realized as a parallel machine having two or more stencil processors 7O2_i, 7O2_2 operating the same kernel program code. For example, a highly dense and high data rate stream of image data may be processed by spreading frames across multiple stencil processors each of which perform the same function.
In yet other configurations, essentially any DAG of kernels may be loaded onto the hardware processor by configuring respective stencil processors with their own respective kernel of program code and configuring appropriate control flow hooks into the hardware to direct output images from one kernel to the input of a next kernel in the DAG design.
As a general flow, frames of image data are received by a macro I/O unit 705 and passed to one or more of the line buffer units 701 on a frame-by-frame basis. A particular line buffer unit parses its frame of image data into a smaller region of image data, referred to as a “line group”, and then passes the line group through the network 704 to a particular sheet generator. A complete or “full” singular line group maybe composed, for example, with the data of multiple contiguous complete rows or columns of a frame (for brevity the present specification will mainly refer to contiguous rows). The sheet generator further parses the line group of image data into a smaller region of image data, referred to as a “sheet”, and presents the sheet to its corresponding stencil processor.
In the case of an image processing pipeline or a DAG flow having a single input, generally, input frames are directed to the same line buffer unit 7Oi_i which parses the image data into line groups and directs the line groups to the sheet generator 7O3_i whose corresponding stencil processor 7O2_i is executing the code of the first kernel in the pipeline/DAG. Upon completion of operations by the stencil processor 7O2_i on the line groups it processes, the sheet generator 7O3_i sends output line groups to a “downstream” line buffer unit 70i_2 (in some use cases the output line group may be sent.back to the same line buffer unit 7Oi_i that earlier had sent the input line groups).
One or more “consumer” kernels that represent the next stage/operation in the pipeline/DAG executing on their own respective other sheet generator and stencil processor (e.g., sheet generator 7O3_2 and stencil processor 7O2_2) then receive from the downstream line buffer unit 70i_2 the image data generated by the first stencil processor 7O2_i. In this manner, a “producer” kernel operating on a first stencil processor has its output data forwarded to a “consumer” kernel operating on a second stencil processor where the consumer kernel performs the next set of tasks after the producer kernel consistent with the design of the overall pipeline or DAG. A stencil processor 702 is designed to simultaneously operate on multiple overlapping stencils of image data. The multiple overlapping stencils and internal hardware processing capacity of the stencil processor effectively determines the size of a sheet. Here, within a stencil processor 702, arrays of execution lanes operate in unison to simultaneously process the image data surface area covered by the multiple overlapping stencils.
As will be described in more detail below, in various embodimentSa sheets of image data are loaded into a two-dimensional register array structure within the stencil processor 702. The use of sheets and the two-dimensional register array structure is believed to effectively provide for power consumption improvements by moving a large amount of data into a large amount of register space as, e.g., a single load operation with processing tasks performed directly on the data immediately thereafter by an execution lane array. Additionally, the use of an execution lane array and corresponding register array provide for different stencil sizes that are easily programmable/configurable.
Figs. 8a through 8e illustrate at a high level embodiments of both the parsing activity of a line buffer unit 701, the finer grained parsing activity of a sheet generator unit 703, as well as the stencil processing activity of the stencil processor 702 that is coupled to the sheet generator unit 703.
Fig. 8a depicts an embodiment of an input frame of image data 801. Fig. 8a also depicts an outline of three overlapping stencils 802 (each stencil having a dimension of 3 pixels by 3 pixels) that a stencil processor is designed to operate over. The output pixel that each stencil respectively generates output image data for is highlighted in solid black. For brevity, the three overlapping stencils 802 are depicted as overlapping only in the vertical direction. It is pertinent to recognize that in actuality a stencil processor may be designed to have overlapping stencils in both the vertical and horizontal directions.
Because of the vertical overlapping stencils 802 within the stencil processor, as observed in Fig. 8a, there exists a wide band of image data within the frame that a single stencil processor can operate over. As will be discussed in more detail below, in an embodiment, the stencil processors process data within their overlapping stencils in a left to right fashion across the image data (and then repeat for the next set of lines, in top to bottom order). Thus, as the stencil processors continue forward with their operation, the number of solid black output pixel blocks will grow right-wise horizontally. As discussed above, a line buffer unit 701 is responsible for parsing a line group of input image data from an incoming frame that is sufficient for the stencil processors to operate over for an extended number of upcoming cycles. An exemplary depiction of a line group is illustrated as a shaded region 803. In an embodiment, as described further below, the line buffer unit 701 can comprehend different dynamics for sending/receiving a line group to/from a sheet generator. For example, according to one mode, referred to as “full group”, the complete full width lines of image data are passed between a line buffer unit and a sheet generator. According to a second mode, referred to as “virtually tall”, a line group is passed initially with a subset of full width rows. The remaining rows are then passed sequentially in smaller (less than full width) pieces.
With the line group 803 of the input image data having been defined by the line buffer unit and passed to the sheet generator unit, the sheet generator unit further parses the line group into finer sheets that are more precisely fitted to the hardware limitations of the stencil processor. More specifically, as will be described in more detail further below, in an embodiment, each stencil processor consists of a two dimensional shift register array. The two dimensional shift register array essentially shifts image data “beneath” an array of execution lanes where the pattern of the shifting causes each execution lane to operate on data within its own respective stencil (that is, each execution lane processes on its own stencil of information to generate an output for that stencil). In an embodiment, sheets are surface areas of input image data that “fill” or are otherwise loaded into the two dimensional shift register array.
Thus, as observed in Fig. 8b, the sheet generator parses an initial sheet 804 from the line group 803 and provides it to the stencil processor (here, the exemplary sheet of data corresponds to the five by five shaded region that is generally identified by reference number 804). As observed in Figs. 8c and 8d, the stencil processor operates on the sheet of input image data by effectively moving the overlapping stencils 802 in a left to right fashion over the sheet. As of Fig. 8d, the number of pixels for which an output value could be calculated (nine in a darkened 3 by 3 array) from the data within the sheet is exhausted (no other pixel positions can have an output value determined from the information within the sheet). For simplicity the border regions of the image have been ignored.
As observed in Fig. 8e the sheet generator then provides a next sheet 805 for the stencil processor to continue operations on. Note that the initial positions of the stencils as they begin operation on the next sheet is the next progression to the right from the point of exhaustion on the first sheet (as depicted previously in Fig. 8d). With the new sheet 805, the stencils will simply continue moving to the right as the stencil processor operates on the new sheet in the same manner as with the processing of the first sheet.
Note that there is some overlap between the data of the first sheet 804 and the data of the second sheet 805 owing to the border regions of stencils that surround an output pixel location. The overlap could be handled simply by the sheet generator retransmitting the overlapping data twice. In alternate implementations, to feed a next sheet to the stencil processor, the sheet generator may proceed to only send new data to the stencil processor and the stencil processor reuses the overlapping data from the previous sheet. b. stencil processor design and operation
Fig. 9a shows an embodiment of a stencil processor unit architecture 900. As observed in Fig. 9a, the stencil processor includes a data computation unit 901, a scalar processor 902 and associated memory 903 and an I/O unit 904. The data computation unit 901 includes an array of execution lanes 905, a two-dimensional shift array structure 906 and separate respective random access memories 907 associated with specific rows or columns of the array.
The I/O unit 904 is responsible for loading “input” sheets of data received from the sheet generator into the data computation unit 901 and storing “output” sheets of data from the stencil processor into the sheet generator. In an embodiment the loading of sheet data into the data computation unit 901 entails parsing a received sheet into rows/columns of image data and loading the rows/columns of image data into the two dimensional shift register structure 906 or respective random access memories 907 of the rows/columns of the execution lane array (described in more detail below). If the sheet is initially loaded into memories 907, the individual execution lanes within the execution lane array 905 may then load sheet data into the two-dimensional shift register structure 906 from the random access memories 907 when appropriate (e.g., as a load instruction just prior to operation on the sheet’s data). Upon completion of the loading of a sheet of data into the register structure 906 (whether directly from a sheet generator or from memories 907), the execution lanes of the execution lane array 905 operate on the data and eventually “write back” finished data as a sheet directly back to the sheet generator, or, into the random access memories 907. If the execution lanes write back to random access memories 907, the I/O unit 904 fetches the data from the random access memories 907 to form an output sheet which is then forwarded to the sheet generator.
The scalar processor 902 includes a program controller 909 that reads the instructions of the stencil processor’s program code from scalar memory 903 and issues the instructions to the execution lanes in the execution lane array 905. In an embodiment, a single same instruction is broadcast to all execution lanes within the array 905 to effect single instruction multiple data (SIMD)-like behavior from the data computation unit 901. In an embodiment^ the instruction format of the instructions read from scalar memory 903 and issued to the execution lanes of the execution lane array 905 includes a very-long-instruction-word (VLIW) type format that includes more than one opcode per instruction. In a further embodiment, the VLIW format includes both an ALU opcode that directs a mathematical function performed by each execution lane’s ALU (which, as described below, in an embodiment may specify more than one traditional ALU operation) and a memory opcode (that directs a memory operation for a specific execution lane or set of execution lanes).
The term “execution lane” refers to a set of one or more execution units capable of executing an instruction (e.g., logic circuitry that can execute an instruction). An execution lane can, in various embodiments, include more processor-like functionality beyond just execution units, however. For example, besides one or more execution units, an execution lane may also include logic circuitry that decodes a received instruction, or, in the case of more multiple instruction multiple data (MIMD)-like designs, logic circuitry that fetches and decodes an instruction. With respect to MIMD-like approaches, although a centralized program control approach has largely been described herein, a more distributed approach maybe implemented in various alternative embodiments (e.g., including program code and a program controller within each execution lane of the array 905).
The combination of an execution lane array 905, program controller 909 and two dimensional shift register structure 906 provides a widely adaptable/configurable hardware platform for a broad range of programmable functions. For example, application software developers are able to program kernels having a wide range of different functional capability as well as dimension (e.g., stencil size) given that the individual execution lanes are able to perform a wide variety of functions and are able to readily access input image data proximate to any output array location.
Apart from acting as a data store for image data being operated on by the execution lane array 905, the random access memories 907 may also keep one or more look-up tables such as any look-up tables held in the look-up table component of the virtual processing memory described above in Section 1.0. In various embodiments one or more scalar look-up tables may also be instantiated within the scalar memory 903. The one or more scalar look-up tables may be any scalar look-up tables held in the scalar look-up table component of the memory model described above in Section 1.0. A scalar look-up involves passing the same data value from the same look-up table from the same index to each of the execution lanes within the execution lane array 905. In various embodiments, the VLIW instruction format described above is expanded to also include a scalar opcode that directs a look-up operation performed by the scalar processor into a scalar look-up table. The index that is specified for use with the opcode may be an immediate operand or fetched from some other data storage location. Regardless, in an embodiment, a look up from a scalar look-up table within scalar memory essentially involves broadcasting the same data value to all execution lanes within the execution lane array 905 during the same clock cycle. Additional details concerning the use and operation of look-up tables is provided further below.
Fig. 9b summarizes the VLIW instruction word embodiments(s) discussed above. As observed in Fig. 9b, the VLIW instruction word format includes fields for three separate instructions: 1) a scalar instruction 951 that is executed by the scalar processor; 2) an ALU instruction 952 that is broadcasted and executed in SIMD fashion by the respective ALUs within the execution lane array; and, 3) a memory instruction 953 that is broadcasted and executed in a partial SIMD fashion (e.g., if execution lanes along a same row in the execution lane array share a same random access memory, then one execution lane from each of the different rows actually execute the instruction (the format of the memory instruction 953 may include an operand that identifies which execution lane from each row executes the instruction)). A field 954 for one or more immediate operands is also included. Which of the instructions 951, 952, 953 use which immediate operand information maybe identified in the instruction format. Each of instructions 951, 952, 953 also includes its own respective input operand and resultant information (e.g., local registers for ALU operations and a local register and a memory address for memory access instructions). In an embodiment, the scalar instruction 951 is executed by the scalar processor before the execution lanes within the execution lane array execute either of the other two instructions 952, 953. That is, the execution of the VLIW word includes a first cycle upon which the scalar instruction 951 is executed followed by a second cycle upon with the other instructions 952, 953 may be executed (note that in various embodiments instructions 952 and 953 maybe executed in parallel).
In an embodiment, the scalar instructions executed by the scalar processor 902 include commands issued to the sheet generator 703 to load/store sheets from/into the memories or 2D shift register 906 of the data computation unit 901. Here, the sheet generator’s operation can be dependent on the operation of the line buffer unit 701 or other variables that prevent pre-runtime comprehension of the number of cycles it will take the sheet generator 703 to complete any command issued by the scalar processor 902. As such, in an embodiment, any VLIW word whose scalar instruction 951 corresponds to or otherwise causes a command to be issued to the sheet generator 703 also includes no-operation (NOOP) instructions in the other two instruction fields 952, 953· The program code then enters a loop of NOOP instructions for instruction fields 952, 953 until the sheet generator completes its load/store to/from the data computation unit. Here, upon issuing a command to the sheet generator, the scalar processor may set a bit of an interlock register that the sheet generator resets upon completion of the command. During the NOOP loop the scalar processor monitors the bit of the interlock bit. When the scalar processor detects that the sheet generator has completed its command normal execution begins again.
Fig. to shows an embodiment of a data computation unit 1001. As observed in Fig. io, the data computation unit 1001 includes an array of execution lanes 1005 that are logically positioned “above” a two-dimensional shift register array structure 1006. As discussed above, in various embodiments, a sheet of image data provided by a sheet generator is loaded into the two-dimensional shift register 1006. The execution lanes then operate on the sheet data from the register structure 1006.
The execution lane array 1005 and shift register structure 1006 are fixed in position relative to one another. However, the data within the shift register array 1006 shifts in a strategic and coordinated fashion to cause each execution lane in the execution lane array to process a different stencil within the data. As such, each execution lane determines the output image value for a different pixel in the output sheet being generated. From the architecture of Fig. 10 it should be clear that overlapping stencils are not only arranged vertically but also horizontally as the execution lane array 1005 includes vertically adjacent execution lanes as well as horizontally adjacent execution lanes.
Some notable architectural features of the data computation unit 1001 include the shift register structure 1006 having wider dimensions than the execution lane array 1005. That is, there is a “halo” of registers 1009 outside the execution lane array 1005. Although the halo 1009 is shown to exist on two sides of the execution lane array, depending on implementation, the halo may exist on less (one) or more (three or four) sides of the execution lane array 1005. The halo 1005 serves to provide “spill-over” space for data that spills outside the bounds of the execution lane array 1005 as the data is shifting “beneath” the execution lanes 1005. As a simple case, a 5x5 stencil centered on the right edge of the execution lane array 1005 will need four halo register locations further to the right when the stencil’s leftmost pixels are processed. For ease of drawing, Fig. 10 shows the registers of the right side of the halo as only having horizontal shift connections and registers of the bottom side of the halo as only having vertical shift connections when, in a nominal embodiment, registers on either side (right, bottom) would have both horizontal and vertical connections.
Additional spill-over room is provided by random access memories 1007 that are coupled to each row and/or each column in the array, or portions thereof (e.g., a random access memory maybe assigned to a “region” of the execution lane array that spans 4 execution lanes row wise and 2 execution lanes column wise. For simplicity the remainder of the application will refer mainly to row and/or column based allocation schemes). Here, if an execution lane’s kernel operations require it to process pixel values outside of the two-dimensional shift register array 1006 (which some image processing routines may require) the plane of image data is able to further spill-over, e.g., from the halo region 1009 into random access memory 1007. For example, consider a 6X6 stencil where the hardware includes a halo region of only four storage elements to the right of an execution lane on the right edge of the execution lane array. In this case, the data would need to be shifted further to the right off the right edge of the halo 1009 to fully process the stencil. Data that is shifted outside the halo region 1009 would then spill over to random access memory 1007. Other applications of the random access memories 1007 and the stencil processor of Fig. 3 are provided further below.
Figs. 11a through 11k demonstrate a working example of the manner in which image data is shifted within the two-dimensional shift register array “beneath” the execution lane array as alluded to above. As observed in Fig. 11a, the data contents of the two-dimensional shift array are depicted in a first array 1107 and the execution lane array is depicted by a frame 1105. Also, two neighboring execution lanes 1110 within the execution lane array are simplistically depicted. In this simplistic depiction 1110, each execution lane includes a register Ri that can accept data from the shift register, accept data from an ALU output (e.g., to behave as an accumulator across cycles), or write output data into an output destination.
Each execution lane also has available, in a local register R2, the contents “beneath” it in the two-dimensional shift array. Thus, Ri is a physical register of the execution lane while R2 is a physical register of the two-dimensional shift register array. The execution lane includes an ALU that can operate on operands provided by Ri and/or R2. As will be described in more detail further below, in an embodiment the shift register is actually implemented with multiple (a “depth” of) storage/register elements per array location but the shifting activity is limited to one plane of storage elements (e.g., only one plane of storage elements can shift per cycle). Figs, na through nk depict one of these deeper register locations as being used to store the resultant X from the respective execution lanes. For illustrative ease the deeper resultant register is drawn alongside rather than beneath its counterpart register R2.
Figs. 11a through 11k focus on the calculation of two stencils whose central position is aligned with the pair of execution lane positions 1111 depicted within the execution lane array 1105. For ease of illustration, the pair of execution lanes 1110 are drawn as horizontal neighbors when in fact, according to the following example, they are vertical neighbors.
As observed initially in Fig. 11a, the execution lanes 1111 are centered on their central stencil locations. Fig. 11b shows the object code executed by both execution lanes 1111. As observed in Fig. 11b the program code of both execution lanes 1111 causes the data within the shift register array 1107 to shift down one position and shift right one position. This aligns both execution lanes 1111 to the upper left hand corner of their respective stencils. The program code then causes the data that is located (in R2) in their respective locations to be loaded into Ri.
As observed in Fig. 11c the program code next causes the pair of execution lanes 1111 to shift the data within the shift register array 1107 one unit to the left which causes the value to the right of each execution lane’s respective position to be shifted into each execution lane’ position. The value in Ri (previous value) is then added with the new value that has shifted into the execution lane’s position (in R2). The resultant is written into Ri. As observed in Fig. nd the same process as described above for Fig. 11c is repeated which causes the resultant Ri to now include the value A+B+C in the upper execution lane and F+G+H in the lower execution lane. At this point both execution lanes 1111 have processed the upper row of their respective stencils. Note the spill-over into a halo region on the left side of the execution lane array 1105 (if one exists on the left hand side) or into random access memory if a halo region does not exist on the left hand side of the execution lane array 1105.
As observed in Fig. lie, the program code next causes the data within the shift register array to shift one unit up which causes both execution lanes 1111 to be aligned with the right edge of the middle row of their respective stencils. Register Ri of both execution lanes ini currently includes the summation of the stencil’s top row and the middle row’s rightmost value. Figs, nf and ng demonstrate continued progress moving leftwise across the middle row of both execution lane’s stencils. The accumulative addition continues such that at the end of processing of Fig. ng both execution lanes nil include the summation of the values of the top row and the middle row of their respective stencils.
Fig. nh shows another shift to align each execution lane with its corresponding stencil’s lowest row. Figs, lli and llj show continued shifting to complete processing over the course of both execution lanes’ stencils. Fig. nk shows additional shifting to align each execution lane with its correct position in the data array and write the resultant thereto.
In the example of Figs na - nk note that the object code for the shift operations may include an instruction format that identifies the direction and magnitude of the shift expressed in (X, Y) coordinates. For example, the object code for a shift up by one location maybe expressed in object code as SHIFT o, +1. As another example, a shift to the right by one location maybe expressed in object code as SHIFT +1, o. In various embodiments shifts of larger magnitude may also be specified in object code (e.g., SHIFT o, +2). Here, if the 2D shift register hardware only supports shifts by one location per cycle, the instruction maybe interpreted by the machine to require multiple cycle execution, or, the 2D shift register hardware may be designed to support shifts by more than one location per cycle. Embodiments of the later are described in more detail further below.
Fig. 12 shows another, more detailed depiction of the unit cell for the array execution lane and shift register structure (registers in the halo region do not include a corresponding execution lane). The execution lane and the register space that is associated with each location in the execution lane array is, in an embodiment, implemented by instantiating the circuitry observed in Fig. 12 at each node of the execution lane array. As observed in Fig. 12, the unit cell includes an execution lane 1201 coupled to a register file 1202 consisting of four registers R2 through R5. During any cycle, the execution lane 1201 may read from or write to any of registers Ri through R5. For instructions requiring two input operands the execution lane may retrieve both of operands from any of Ri through R5.
In an embodiment, the two dimensional shift register structure is implemented by permitting, during a single cycle, the contents of any of (only) one of registers R2 through R4 to be shifted “out” to one of its neighbor’s register files through output multiplexer 1203, and, having the contents of any of (only) one of registers R2 through R4 replaced with content that is shifted “in” from a corresponding one if its neighbors through input multiplexers 1204 such that shifts between neighbors are in a same direction (e.g., all execution lanes shift left, all execution lanes shift right, etc.). Although it may be common for a same register to have its contents shifted out and replaced with content that is shifted in on a same cycle, the multiplexer arrangement 1203,1204 permits for different shift source and shift target registers within a same register file during a same cycle.
As depicted in Fig. 12 note that during a shift sequence an execution lane will shift content out from its register file 1202 to each of its left, right, top, and bottom neighbors. In conjunction with the same shift sequence, the execution lane will also shift content into its register file from a particular one of its left, right, top, and bottom neighbors. Again, the shift out target and shift in source should be consistent with a same shift direction for all execution lanes (e.g., if the shift out is to the right neighbor, the shift in should be from the left neighbor).
Although in one embodiment the content of only one register is permitted to be shifted per execution lane per cycle, other embodiments may permit the content of more than one register to be shifted in/out. For example, the content of two registers may be shifted out/in during a same cycle if a second instance of the multiplexer circuitry 1203, 1204 observed in Fig. 12 is incorporated into the design of Fig. 12. Of course, in embodiments where the content of only one register is permitted to be shifted per cycle, shifts from multiple registers may take place between mathematical operations by consuming more clock cycles for shifts between mathematical operations (e.g., the contents of two registers may be shifted between math ops by consuming two shift ops between the math ops).
If less than all the content of an execution lane’s register files are shifted out during a shift sequence note that the content of the non shifted out registers of each execution lane remain in place (do not shift). As such, any non-shifted content that is not replaced with shifted-in content persists local to the execution lane across the shifting cycle. The memory unit (“M”) observed in each execution lane is used to load/store data from/to the random access memory space that is associated with the execution lane’s row and/or column within the execution lane array. Here, the M unit acts as a standard M unit in that it is often used to load/store data that cannot be loaded/stored from/to the execution lane’s own register space. In various embodiments, the primary operation of the M unit is to write data from a local register into memory, and, read data from memory and write it into a local register.
With respect to the ISA opcodes supported by the ALU unit of the hardware execution lane 1201, in various embodiments, the mathematical opcodes supported by the hardware ALU are integrally tied with (e.g., substantially the same as) the mathematical opcodes supported by a virtual execution lane (e.g., ADD, SUB, MOV, MUL, MAD, ABS, DIV, SHL, SHR, MIN/MAX, SEL, AND, OR, XOR, NOT). As described just above, memory access instructions can be executed by the execution lane 1201 to fetch/store data from/to their associated random access memory. Additionally the hardware execution lane 1201 supports shift operation instructions (right, left, up, down) to shift data within the two-dimensional shift register structure. As described above, program control instructions are largely executed by the scalar processor of the stencil processor. .3.0 Block Operations Implemented On Image Processor a. row/column sum operation
Figs. 13 and 14a,b pertain to a row/column sum operation. Row/sum column operations are particularly useful for statistics computation, noise suppression, and large scale down-sampling. Row sum and/or column sum operations can be implemented on an image processor having a two-dimensional execution lane array and corresponding two-dimensional shift register array such as embodiments of the image processor described above in the preceding sections.
As observed in Fig. 13, a row sum operation adds all values in a same row of an array and a column sum operation adds all values in a same column of an array. Additionally, as depicted, with a row sum operation the values of all rows can be simultaneously added within their respective rows. Likewise, with a column sum operation the values of all columns can be simultaneously added within their respective columns. Because of the versatility of the shift register array, however, summing across all rows or columns is not a requirement. That is, less than all rows in an array may be simultaneously summed over or less that all columns in an array may be simultaneously summed over.
Figs. 14a through I4d show an embodiment of a machine level operation for implementing a row sum operation. For simplicity only a single row is shown. The reader will understand that the operations depicted in Figs. 14a through i4d can also be applied to a column. Additionally, for both row or column operations, the sequence of Figs. 14a through I4d can also be simultaneously performed for multiple rows or columns in the array. Additionally, the dimension of the row is only shown to be 8 locations wide (whereas in actual implementations the execution lane array and shift register array maybe 16 x 16 or even larger).
In an implementation, as observed in Fig. 14a, the two-dimensional shift register array is designed to support direct logical shifts between opposite ends of the array 1401. That is, the shift register can “roll” or “loop” or “wrap” its content between a rightmost array column and a leftmost array column when performing shifts along a row axis, and/or, roll or loop its content between a topmost array row and a bottom most array row when performing shifts along a column axis. Additionally, in various embodiments, the shift register can support multiple register location hops in a single instruction (e.g., an opcode and/or variable associated with a shift instruction specifies whether the shift amount is +/-1, +/-2, +/-3 or +/-4 register location places along horizontal and/or vertical axis). Shift distances that are not supported in the hardware can be emulated by the compiler.
As observed in Fig. 14a, initially, the row is loaded with data values Ao through A7 in the respective Ro and Ri register locations of each execution lane. As observed in Fig. 14b, in a first iteration of machine operations, the Ri register space locations are then shifted left one location and the Ri and Ro contents of each execution lane are summed with the resultant written back to Ro and Ri. This produces a first accumulated partial sum in Ri which, as will be made more clear in the following discussion, acts as an accumulator for the overall summation operation.
In a next iteration of machine operations, depicted in Fig. 14c, the Ri register space locations are shifted left by two locations and the Ri and Ro contents of each execution lane are summed. The resultant is again kept in Ro and Ri. Finally in a third iteration of machine operations, depicted in Fig. i4d, the Ri register space locations are shifted left by four locations and the results written in either or both of register locations Ro and Ri. Thus, viewing the iterations of the sum operation over Figs. 14b, 14c, and 14 b, note that the shift amount doubles with each iteration and the complete result is present in all lanes after only three iterations (i.e., as of Fig. 14c). In the case of a 16 wide row, the shift amount would be eight locations for the fourth iteration and the operation would be complete after the fourth iteration. b. roiv/columnprefix sum operation
Figs. 15 and 16a through i6d pertain to a row/column prefix sum operation that can also be executed on an image processor having a two-dimensional execution lane array and a corresponding two-dimensional shift register. Row/column prefix sum operations are particularly useful for integral images, accelerating box filters, and the computation of addresses for compaction operations. Referring to Fig. 15, for simplicity, only a single row is shown. However, the operation can also be performed for columns. Also, although only one row is depicted, in various implementations, as with the row/column sum operation discussed just above, any number of rows (or columns) in the register array (including all rows/columns) can be simultaneously summed over. Additionally, the dimension of the row in Fig. 15 is only shown to be 8 locations wide, whereas, in actual implementations the execution lane and shift register arrays may be 16 x 16 or even larger.
As observed in Fig. 15, the resultant of a row prefix operation for any location within a row is the sum of the values that lead up to that location. Likewise, the value of a column prefix operation for any location within a column is the sum of the values that lead up to that location.
Figs. 16a through i6d shows an embodiment of a machine level operation for a row prefix operation. As with the row sum operation discussed at length in the preceding section, the row prefix operation employs the use of a two dimensional shift register than can roll shifts between array edge locations 1601.
As observed in Fig. 16a, a row is initially loaded with data values Ao through A7 in the respective Ro register location of each execution lane. Also, a null (“o”) is loaded into the R2 register space of each execution lane.
In a first iteration of machine level operation, depicted in Fig. 16b, the Ro register space locations are shifted right one location into the destination location’s Ri register space. A subsequent ADD operation adds the Ro content with either the Ri content or the R2 content depending on the location of the lane relative to the iteration count. Specifically, the first row location selects the null in R2 (and not the shifted content in Ri) because its location (0) is equal to or less than 2N -1 where N is the iteration count (20 - 1 = o), adds the null to the content in Ro and stores the resultant back in Ro. The first row location, therefore will maintain a value of Ao in Ro.
By contrast, each of the other row locations, because their location is greater than 2N -1, will select the shifted content in Ri (rather than the null value in R2), add it to the content in Ro and store the resultant in Ro. Thus, each of the row locations other than the first row location will keep the sum of its original content and its leftmost neighbor in Ro whereas the first row location will simply keep only its original content in Ro.
In a second iteration of machine level operations, depicted in Fig. 16c, the content of the Ro register space locations are shifted right two locations into the destination’s Ri register space. Thus, as with the row/column operations described immediately above, with each next iteration of machine operations the shift amount doubles. As with the first iteration, a subsequent ADD operation adds the Ro content with either the Ri content or the R2 content depending on the location of the lane relative to the current iteration count. In this case, the first and second row locations select the null in R2 (and not the shifted content in Ri) because their location (o, 1) is less than or equal to 2n-i (2-1 = 1). These lanes therefore add the null value to the content in Ro and stores the resultant back in Ro. The first row location, therefore will maintain its value of Ao in Ro and the second row location will maintain a value of A0+A1 in Ro.
By contrast, each of the other row locations, because their location is greater than the 2n-i, will select the shifted content in Ri (rather than the null value in R2), add the content of Ri to the content in Ro and store the resultant in Ro. Thus, each of the row locations other than the first and second row locations will keep in Ro an accumulated sum based on its original content and its total shifted in content.
In a third iteration of machine level operations, depicted in Fig. i6d, the Ro register space locations are shifted right four locations into the destination’s Ri register space. Thus, again, with each next iteration of machine operations the shift amount doubles.
As with the earlier iterations, a subsequent ADD operation adds the Ro content with either the Ri content or the R2 content depending on the location of the lane relative to the current iteration count. In this case, the first through fourth row locations (o through 3) will select the null in R2 (and not the shifted content in Ri) because their location is less than or equal to 2N-i (22-i = 3). Each of these lanes will therefore add the null value to the content in Ro and store the resultant back in Ro. The first row location, therefore will maintain its original value of Ao in Ro, the second row location will maintain a value of A0+A1 in Ro, the third row location will maintain a value of A0+A1+A2 in Ro and the fourth row location will maintain a value of A0+A1+A2+A3 in Ro.
By contrast, each of the other row locations, because their location remains greater than 2n-i, will select the shifted content in Ri (rather than the null value in R2), add the content of Ri to the content in Ro and store the resultant in Ro. Thus, each of the row locations other than the first, second and third row locations will keep an accumulated sum based on its original content and its total shifted in content.
After the third iteration, the prefix sum operation is complete. If the row were of dimension sixteen, only one more set of operations that shift the Ri register contents by eight locations would be needed to accumulate the summation unique to all 16 different locations in all sixteen execution lanes. c. row/column find min operation
Figs. 17 and 18a through i8d pertain to a row/column find minimum operation that can also be executed on an image processor having a two-dimensional execution lane array and a corresponding two-dimensional shift register. Row/column find min operations are particularly useful for statistics computations and block matching post-processing.
Referring to Fig. 17, for simplicity, only a single row is shown. However, in actual implementation, a column find minimum operation can be implemented on a same processor that implements a row find minimum operation. Additionally, the minimum for a row (or column) can simultaneously be found for any number of rows (or columns) in the register array (including up to all rows/columns). Additionally, the dimension of the row/column is only shown to be 8 locations wide, whereas, in actual implementations the execution lane and shift register arrays may be 16 x 16 or even larger.
As observed in Fig. 17, the resultant of a row find minimum operation corresponds to the smallest value amongst all values within a same row and its location/position (also referred to as its index) in the row. Likewise, the resultant of a column find minimum operation corresponds to the smallest value amongst all values within a same column and its location/position within the column. As with the row sum and prefix sum operations discussed at length in the preceding sections, the row/column find minimum operation employs the use of a two dimensional shift register than can roll shifts between array edge locations 1701.
Figs. 18a through i8d show an embodiment of machine level operations for a row prefix operation. Initially, as observed in Fig. 18a, a row is loaded with data values Ao through A7 in the respective Ro register location of each execution lane. Also, the index of each row location is loaded into the Ri register space of each execution lane.
In a first iteration of machine level operations, which are depicted in Fig. 18b, the content of the Ro and Ri register locations are shifted one unit into the R2 and R3 register space of a neighboring execution lane’s register space. The respective values of the Ro and R2 registers are then compared within each execution lane. The minimum value of the comparison and its corresponding index are stored into the Ro and Ri register space. That is, if the Ro value is less than the R2 value, the Ro and Ri registers maintain their original content. Whereas, if the R2 value is less than the Ro value, the R2 value is written into Ro and the R3 value is written into Ri. This has the effect of keeping the minimum value of the comparison in Ro and its index in Ri.
In a second iteration of machine level operations, which are depicted in Fig. 18c, the content of the Ro and Ri register locations are shifted two units into the R2 and R3 register space of a downstream execution lane. Thus, once again, the shift amount doubles with a next iteration. The respective values of the Ro and R2 registers are then compared within each execution lane. The minimum value of the comparison and its corresponding index are stored into the Ro and Ri register space. This has the effect of keeping the minimum value observed from both comparisons that have been performed in each execution lane in Ro and its index in Ri.
In a third iteration of machine level operations, observed in Fig. i8d, the content of the Ro and Ri register locations are shifted four units into the R2 and R3 register space of a downstream execution lane. The respective values of the Ro and R2 registers are then compared within each execution lane. The minimum value of the comparison and its corresponding index are stored into the Ro and Ri register space. This has the effect of keeping the minimum value observed from all three comparisons that have been performed in each execution lane in Ro and its index in Ri.
After the third iteration, the find minimum operation is complete as each execution lane will have the minimum value of the entire row in its Ro register space and its corresponding index in its Ri register space (the row location that was originally provided with the minimum value will find its own row location identified in its Ri register space). If the row were of dimension sixteen, only one more set of operations based on a shift of the Ro and Ri register contents downstream in the shift register by eight locations would be needed to provide the minimum of all sixteen different locations in all sixteen execution lanes.
Note that a find maximum operation could also be implemented using the same principles described above except that the core math operation includes finding the maximum rather than finding the minimum. d. matrix multiply
Figs. 19a,b and 20 pertain to a matrix multiply. A matrix multiply is particularly useful for discrete fourier or cosine transforms (which are common primitives in compression and filtering) and to express larger matrix/multiply operations (which are commonly used in image recognition). A matrix multiply of two matrices A and B is performed by summing, for each matrix coordinate location in the resultant, products of the elements in the row of the coordinate location and their corresponding elements in the column of the coordinate location. Fig. 19b shows the resultant matrix X for the matrix multiple of matrices A and B in Fig. 19a. Here, associated partial product terms of matrices A and B for two coordinate locations 1901,1902 in the resultant matrix C are specially shown.
In particular, for instance, the resultant product for coordinate location ci2 in the resultant matrix C of Fig. 19b is (an*bn) + (ai2*b2i) + (ai3*b3i) + (ai4*b4i) which corresponds to the elements of row 1901 in matrix A being multiplied with the corresponding elements of column 1902 in matrix B in Fig. 19a.
Likewise, the resultant product for coordinate location C22 in resultant matrix C of Fig. 19b is (a2i*bi2) + (a22*b22) + (a23*b32) + (a24*b42) which corresponds to the elements of row 1903 in matrix A being multiplied with the corresponding elements of column 1902 in matrix B in Fig. 19a. As can seen from these two examples, the resultant for any coordinate location x,y in the resultant matrix C can be expressed as:
Xl< = 1 to 4 (a<.k) " (bk,\·)·
Figs. 20a through 20e show an embodiment of a matrix multiply operation that uses a two dimensional execution lane array and the unique shifting advantages of a corresponding two dimensional shift register array.
As observed in Fig. 20a, initially, two matrices A and B are loaded into the two dimensional shift register array. For example, the values of matrix A may be loaded into the Ro register space of the two dimensional shift register and the values of matrix B may be loaded into the Ri register space of the two dimensional shift register array such that each matrix coordinate corresponds to a different execution lane’s associated register space. Again, for illustrative ease, 4x4 matrices are depicted although in actual implementations larger matrices can be multiplied with a corresponding, larger dimensioned shift register array.
As observed in Fig. 20b, a rotational shearing algorithm shift is applied to both matrices with a row-wise rotational shearing algorithm shift sequence being applied to matrix A and a column-wise rotational shearing algorithm shift sequence being applied to matrix B. As is known in the art, a rotational shearing algorithm increases shift amount by N-i where N is the position in the matrix.
Thus, as observed in Fig. 20b, the first row of matrix A is not shifted at all, the second row of matrix A is shifted one unit, the third row of matrix A is shifted two units and the fourth row of matrix A is shifted three units. Similarly, the first column of matrix B is not shifted at all, the second column of matrix B is shifted one unit, the third column of matrix B is shifted two units and the fourth column of matrix B is shifted three units. Here, the two dimensional shift register array is understood to be able to roll elements at array edges for both row oriented shifts and column oriented shifts.
Note that, owing to the versatile nature of the two dimensional shift register array and the corresponding execution lane array where the respective shift instruction executed by each execution lane can specify different input operand data, the two dimensional shift register array is able to shift different rows by different horizontal shift amounts and shift different columns by different vertical shift amounts while simultaneously executing the shift instructions across all execution lanes for a same matrix (in various embodiments, a same horizontal shift amount must be specified for lanes in a same row and a same vertical shift amount must be specified for lanes in a same column). Thus, conceivably, the shearing of both the A and B matrices can be completed in as few as two cycles (i.e., all shifts for one matrix are performed in one cycle assuming the shift register can implement multiple hop shifts in a single cycle).
With the data in matrices A and B being realigned from the shearing algorithms, as observed in Fig. 20b, a multiply operation is performed where each execution lane multiplies the A and B values in its corresponding two dimensional shift register space. Here, recall that A values are, e.g., kept in Ro space and B values are kept in Ri space. The resultant of the multiplication is stored in local R2 space. Null values maybe loaded as an initial condition into R3 space and the resultant of the multiplication in R2 is added to the contents of R3. The resultant of the summation is stored back in R3. As will be apparent in the teachings that follow, R3 takes on the roll of accumulator that accumulates the summation of partial product terms over the course the matrix multiply operation.
For ease of understanding, Fig. 20b explicitly shows the contents in the resultant R3 space after the first iteration for coordinate locations cn and C22 in the resultant matrix C originally depicted in Fig. 19b. Here, after the first iteration of Fig. 20b, the R3 register space at location C11 contains the partial product term aii*bn and the R3 register space at location C22 contains the partial product term (a2i*bi2).
As observed in Fig. 20c, upon a next iteration, the Ro registers containing matrix A data are then horizontally shifted one unit and the Ri registers containing matrix B data are vertically shifted one unit. The mathematical operations described just above with respect to Fig. 20b are then repeated. Here, however, the R3 register space of each lane initially contains the first iteration’s partial product term (e.g., aii*bn in R3 of location cn and a2i*bi2 in R3 of location C22). As such, at the end of the iteration, register R3 will contain the accumulated sum of both partial products that have so far been calculated. That is, R3 in location cn will have the sum (aii*bn) + (ai2*b2i) and R3 in location C22 will have the sum (a2i*bi2) + (a22*b22).
As observed in Figs. 2od and 2oe after two more iterations of a single unit shift for both matrices followed by a multiply-add, the matrix multiply will be complete with each register array location having the correct summation of partial products in its local R3 register space. e. two dimensional discrete Fourier trans form (2D DFT)
Fig. 21 depicts a two dimensional DFT (2D DFT). A 2D DFT is particularly useful for noise reduction and accelerating convolutions. As observed in Fig. 21, a 2D DFT can be expressed as the summation over two dimensional space of the product of two complex terms 2101, 2102. A first of the complex terms 2101 corresponds to a phasor whose magnitude and phase is a function of time and frequency. In implementation, the first complex term 2101 is expressly calculated as a first matrix of coefficients. A second of the complex terms 2102 corresponds to the signal that is being transformed from the spatial domain to the frequency domain.
For simplicity, Fig. 21 represents the first complex term 2101 as Ret + jlmi and represents the second complex 2102 term as Re2 +jlm2. As is known in the art, the real part of (Rei+jImi)*(Re2 + jlm2) can be expressed as (Rei*Re2) - (Imi*Im2) while the imaginary part can be expressed as j((Rei*Im2) + (Re2*Imi)). The summations of the 2D DFT over 2D space, just like the matrix multiply discussed at length immediately above, add the products of elements in a row of a coordinate location by corresponding elements in the column of the coordinate location.
Thus, the real part of the DFT resultant can be calculated by performing a matrix multiply on an array of Ret values and an array of Re2 values and subtracting from the resultant array the result of a matrix multiply on an array of Imi values and Im2 values.
Similarly, the imaginary part of the DFT resultant can be calculated by performing a matrix multiply on an array of Ret values and an array of Im2 values and adding the resultant array to the result of a matrix multiply on an array of Re2 values and Imi values.
Figs. 22a shows machine operations for calculating the real part of the DFT. As observed in Fig. 22a, an array of Ret values are loaded into the Ro register space of the two-dimensional shift register array, an array of Re2 values are loaded into the Ri register space of the two-dimensional shift register array, an array of Imi values are loaded into the R2 register space of the two-dimensional shift register array, and an array of Im2 values are loaded into the R3 register space of the two-dimensional shift register array. As observed in Fig. 22b, a rotational shearing algorithm is then applied to each of the array values with the Ret and the Imi values being sheared horizontally and the Re2 and Im2 values being sheared vertically.
As observed in Fig. 22c, an Rei*Re2 matrix multiply and an Imi*Im2 matrix multiply are then performed with the resultants being kept in the Ro and R2 register space, respectively. The content of the R2 register space is then subtracted from the Ro register spacing with the resultant of the subtraction leaving the real part of the DFT transform in the Ro register space as observed in Fig. 22d.
In an embodiment, the real part resultant in the Ro register space is moved to R4 register space (if it exists) or written out to local memory that is coupled to the shift register array. Then, the original Rei and Imi values are re-written back into the Ro and Ri register space (e.g., from the same local memory) and horizontally sheared so that the register content of Fig. 22a is recreated in the two-dimensional shift register array.
An Rci" I m2 matrix multiply and an Rc2“Imi matrix multiply are then performed with the resultants being kept in the Ro and R2 register space, respectively. That is, a matrix multiply is performed on the contents of Ro and R3 with the resultant written back to Ro, and, a matrix multiply is performed on the contents of R2 and Ri the contents being written into R2. The resultant matrices in Ro and R2 are shown in Fig. 22e. The content of the Ro register space is then added to the content of the R2 register spacing and written back to Ro. This leaves the imaginary part of the DFT transform in the Ro register space as depicted in Fig. 22f. f. FFT Butterfly
As is known in the art, a fast fourier transform (FFT) is a faster, less computationally intensive approach to a DFT. FFTs rely on special efficient algorithms to rapidly convert time or space domain data into frequency domain data. A critical component of such algorithms is a butterfly algorithm. An exemplary butterfly algorithm is depicted in Fig. 23. Here, a butterfly operation is defined by a stage where the specific stage determines an amount of swapping that transpires between elements of a same row or column. As is known in the art, a complete FFT includes performing mathematical operations on the swapped content of multiple, different stage butterfly operations in between the butterfly operations.
Fig. 23 shows each of 1, 2, and 4 stage butterfly operations. In the case of the 1 stage butterfly, neighboring elements are swapped. In the case of the 2 stage butterfly, neighboring pairs of elements are swapped. In the case of the 4 stage butterfly, groups of 4 neighboring elements are swapped. In the case of a two dimensional FFT, elements in a first array of signal data are swapped according to each of multiple butterfly stages with mathematical operations being performed on the swapped signal data elements.
Fig. 24a shows machine level shift operations that can be used to effect a 1 stage 1 butterfly across an array of signal data that is stored in two dimensional Ro register space. For simplicity only one row is shown. It is pertinent to recognize that multiple (e.g., all) rows or columns of an array in a two dimensional shift register may be simultaneously processed in accordance with the particular row that is observed.
Here, the shift register is initially loaded with Ao through A7 across each of its rows in its Ro register space. The shift register then shifts the Ro register content one unit to the right and each execution lane stores the data that has been just been shifted into its location in its Ri register space. Then, the shift register shifts the Ro register content two units to the left (the resultant of which is labeled Ro’). Each execution lane then executes a selection operation in which either its local Ro content or its local Ri content is stored in Ro (i.e., if Ro is selected, the content of Ro remains unchanged) depending on the location of the lane. In the particular embodiment of Fig. 24a, even lanes select Ro while odd lanes select Ri. After the selection, the correctly swapped values are in the Ro register space of each execution lane (labeled as Ro”).
Fig. 24b and Fig. 24c depict 2 stage and 4 stage butterfly operations. Processing is similar to the 1 stage butterfly operation described just above, except that in the case of the 2 stage butterfly the shift register array shifts the Ro register content two units to the right and then four units to the left. Every other even lane and its rightmost neighbor select from one of Ri and Ro” whereas the other even lanes an their rightmost neighbor select from the other of Ri and Ro”. In the case of the 4 stage butterfly, depicted in Fig. 25c, the shift register array shifts the contents of Ro four units to the right and then selects all values as they reside in Ro (labeled Ro’). q. block match
Fig. 25 shows a depiction of block matching. Block matching is particularly useful for motion estimation (e.g., for video compression), image stabilization, and image fusion algorithms (e.g., exposure fusion, and temporal noise fusion). Here, a specific feature in a first base (e.g., previous) image looked for in an alternative (e.g., later) image. In the example of Fig. 26, the block ABCD that is present in the base image needs to be found in the alternative image.
Figs. 26a through 26d shows a method for performing block matching on an image processor having a two dimensional execution lane array and a two dimensional shift register array. Here, the pixels of the alternative image are kept in the Ro register space of the two dimensional shift register. A first pixel of the feature in the base image that is being looked for (e.g., “A”) is broadcast to all execution lanes and an absolute difference is taken on the content in the Ro register space and the value “A” and the resultant is stored in Ri (for simplicity it is assumed that no other pixels in the alternative image have any of the looked for feature’s values (A, B, C, D). If a pixel value in the alternative image matches (or approximately matches) the broadcast pixel value A then the resultant in Ri should be at (or near) zero. All other resultants in Ri should be substantially non zero.
Referring to Fig. 26b, the alternative image is then shifted one unit in the two-dimensional shift register, a next pixel value “B” in the feature being looked for is broadcast to all execution lanes and the absolute difference is again taken and stored in Ri. Here, the particular execution lane array location 2601 that has had two consecutive pixel matches should have the lowest resultant value in Ri. This particular execution lane location is the location where the particular order of pixel values that are being broadcast aligns with the particular scanning/shifting motion of the alternative image in Ro of the shift register array.
As observed in Figs. 26c and 26d, the process continues with each next iteration broadcasting a next pixel value and shifting the alternative image data in a particular scan order. After a number of iterations sufficient to broadcast all sought for image pixels and to correspondingly shift the alternative image in Ro over an area that corresponds to the size of the looked for image, ideally, only one location 2601 in the execution lane array will have experienced a match on every iteration cycle. As such, this particular array location 2601 should be able to maintain a zero or near zero value in its Ri register space (or at least a smaller value than the other execution lanes) after all iterations have been completed. A findmin operation as discussed above is executed on the Ri register space across all rows in the array. The lowest corresponding value in each row will then be kept at each location of its row. A findmin operation is then executed on the Ri register space across all columns in the array. The resultant should identify the pixel that matched the base image on every iteration which, in turn, can be used to identify the precise location of the looked for image in the alternative array. 4.0 Construction of Low Level Program Code
Fig. 27 shows a pre-runtime development environment in which a programmer designs a high level image processing function and the application development environment (which may include the virtual ISA environment discussed at length above with respect to Figs. 1 through 6) provides for any/all of the aforementioned special operations so that the developer does not have the write them from scratch.
Here, the developer may specifically call out any of the operations discussed at length above and/or the development environment automatically provides them from a library 2701 in response. Alternatively or in combination, the developer’s need for such operations may be implied or deduced (such as a matrix multiply in the case of a 2D DFT) and the development environment automatically inserts program code from the library 2701 that performs these functions (e.g., as part of a compilation process).
Thus, the program code that performs the above described operations or alternate embodiments thereof maybe expressed in higher level (e.g., virtual ISA) program code or lower level object code. In various embodiments, the higher level virtual ISA code may specify data values to be operated upon as memory reads having x,y address coordinates, while, the object code may instead comprehend these data accesses as two-dimensional shift register operations (such as any of the shift operations described above or similar embodiments). A compiler may convert the x,y reads in the development environment into corresponding shifts of the two dimensional shift register that are specified object code (e.g., a read in the development environment having x,y coordinates (+2, +2) may be realized in object code as a shift to the left two spaces and a shift down of two spaces). Depending on environment, the developer may have visibility into both of these levels (or, e.g., just the higher VISA level). In still yet other embodiments, such prewritten routines may be invoked during runtime (e.g., by a just-in-time compiler) rather than pre-runtime. s.o Concluding Statements
From the preceding sections is pertinent to recognize that the virtual environment described above in Section 1.0 may be instantiated on a computer system. Likewise an image processor as described above in Section 2.0 may be embodied in hardware on a computer system (e.g., as part of a handheld device’s System on Chip (SOC) that processes data from the handheld device’s camera).
It is pertinent to point out that the various image processor architecture features described above are not necessarily limited to image processing in the traditional sense and therefore may be applied to other applications that may (or may not) cause the image processor to be re-characterized. For example, if any of the various image processor architecture features described above were to be used in the creation and/or generation and/or rendering of animation as opposed to the processing of actual camera images, the image processor may be characterized as a graphics processing unit. Additionally, the image processor architectural features described above may be applied to other technical applications such as video processing, vision processing, image recognition and/or machine learning. Applied in this manner, the image processor maybe integrated with (e.g., as a co-processor to) a more general purpose processor (e.g., that is or is part of a CPU of computing system), or, may be a stand alone processor within a computing system.
The hardware design embodiments discussed above may be embodied within a semiconductor chip and/or as a description of a circuit design for eventual targeting toward a semiconductor manufacturing process. In the case of the later, such circuit descriptions may take of the form of a (e.g., VHDL or Verilog) register transfer level (RTL) circuit description, a gate level circuit description, a transistor level circuit description or mask description or various combinations thereof. Circuit descriptions are typically embodied on a computer readable storage medium (such as a CD-ROM or other type of storage technology).
From the preceding sections is pertinent to recognize that an image processor as described above maybe embodied in hardware on a computer system (e.g., as part of a handheld device’s System on Chip (SOC) that processes data from the handheld device’s camera). In cases where the image processor is embodied as a hardware circuit, note that the image data that is processed by the image processor maybe received directly from a camera. Here, the image processor may be part of a discrete camera, or, part of a computing system having an integrated camera. In the case of the later the image data may be received directly from the camera or from the computing system’s system memory (e.g., the camera sends its image data to system memory rather than the image processor). Note also that many of the features described in the preceding sections may be applicable to a graphics processor unit (which renders animation).
Fig. 28 provides an exemplary depiction of a computing system. Many of the components of the computing system described below are applicable to a computing system having an integrated camera and associated image processor (e.g., a handheld device such as a smartphone or tablet computer). Those of ordinary skill will be able to easily delineate between the two.
As observed in Fig. 28, the basic computing system may include a central processing unit 2801 (which may include, e.g., a plurality of general purpose processing cores 2815_i through 2815_N and a main memory controller 2817 disposed on a multi-core processor or applications processor), system memory 2802, a display 2803 (e.g., touchscreen, flat-panel), a local wired point-to-point link (e.g., USB) interface 2804, various network I/O functions 2805 (such as an Ethernet interface and/or cellular modem subsystem), a wireless local area network (e.g., WiFi) interface 2806, a wireless point-to-point link (e.g., Bluetooth) interface 2807 and a Global Positioning System interface 2808, various sensors 28θ9_ι through 28θ9_Ν, one or more cameras 2810, a battery 2811, a power management control unit 2824, a speaker and microphone 2813 and an audio coder/decoder 2814.
An applications processor or multi-core processor 2850 may include one or more general purpose processing cores 2815 within its CPU 2801, one or more graphical processing units 2816, a memory management function 2817 (e.g., a memory controller), an I/O control function 2818 and an image processing unit 2819. The general purpose processing cores 2815 typically execute the operating system and application software of the computing system. The graphics processing units 2816 typically execute graphics intensive functions to, e.g., generate graphics information that is presented on the display 2803. The memory control function 2817 interfaces with the system memory 2802 to write/read data to/from system memory 2802. The power management control unit 2824 generally controls the power consumption of the system 2800.
The image processing unit 2819 maybe implemented according to any of the image processing unit embodiments described at length above in the preceding sections. Alternatively or in combination, the IPU 2819 may be coupled to either or both of the GPU 2816 and CPU 2801 as a co-processor thereof. Additionally, in various embodiments, the GPU 2816 maybe implemented with any of the image processor features described at length above.
Each of the touchscreen display 2803, the communication interfaces 2804 - 2807, the GPS interface 2808, the sensors 2809, the camera 2810, and the speaker/microphone codec 2813, 2814 all can be viewed as various forms of I/O (input and/or output) relative to the overall computing system including, where appropriate, an integrated peripheral device as well (e.g., the one or more cameras 2810). Depending on implementation, various ones of these I/O components maybe integrated on the applications processor/multi-core processor 2850 or maybe located off the die or outside the package of the applications processor/multi-core processor 2850.
In an embodiment one or more cameras 2810 includes a depth camera capable of measuring depth between the camera and an object in its field of view. Application software, operating system software, device driver software and/or firmware executing on a general purpose CPU core (or other functional block having an instruction execution pipeline to execute program code) of an applications processor or other processor may perform any of the functions described above.
Embodiments of the invention may include various processes as set forth above. The processes maybe embodied in machine-executable instructions. The instructions can be used to cause a general-purpose or special-purpose processor to perform certain processes. Alternatively, these processes may be performed by specific hardware components that contain hardwired logic for performing the processes, or by any combination of programmed computer components and custom hardware components.
Elements of the present invention may also be provided as a machine-readable medium for storing the machine-executable instructions. The machine-readable medium may include, but is not limited to, floppy diskettes, optical disks, CD-ROMs, and magneto-optical disks, FLASH memory, ROMs, RAMs, EPROMs, EEPROMs, magnetic or optical cards, propagation media or other type of media/machine-readable medium suitable for storing electronic instructions. For example, the elements may be downloaded as a computer program transferred from a remote computer (e.g., a server) to a requesting computer (e.g., a client) byway of data signals embodied in a carrier wave or other propagation medium via a communication link (e.g., a modem or network connection).
In the foregoing specification, specific example embodiments have been described. It will, however, be evident that various modifications and changes may be made thereto without departing from scope of the invention as set forth in the appended claims. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.
Claims (6)
1. A method performed by an image processor comprising a two dimensional array of execution units and a two dimensional shift register array, each of the execution units being associated with a respective location in the two dimensional shift register array, each of the execution units including a register, the method comprising: loading image data into the two-dimensional shift register array; and performing a sum operation which adds all values in a particular row or column of the two-dimensional shift register array by performing plural iterations of: shifting first content of the row or column of the two dimensional shift register array, wherein an amount by which the first content is shifted doubles with each iteration; each of one or more of the execution units executing a summation in which the first content that is shifted into the location of the two dimensional shift register array associated with the execution unit is summed with second content located in the register of the execution unit, the second content being the same as content that was resident in the location of the two dimensional shift register array prior to the shifting; and writing the results of the summations back into at least the respective locations of the two-dimensional shift register array.
2. The method of claim 1 comprising using the results of the summation operation to perform any of: a) calculate statistics; b) suppress noise; c) down-sample.
3. The method of claim 2 wherein content of the two dimensional shift register array is wrapped around opposite edges of the two dimensional shift register array.
4. The method of any of claims 2 to 3 wherein the sum operation is performed across all rows or columns of the shift register array.
5. The method of any preceding claim, wherein the shift register can support multiple register location hops in a single instruction.
6. The method of any preceding claim, wherein the sum operation is performed simultaneously for multiple rows or columns of the shift register array.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
GB1900923.2A GB2577139B (en) | 2016-07-01 | 2017-06-20 | Block operations for an image processor having a two-dimensional execution lane array and a two-dimensional shift register |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/201,237 US20180007302A1 (en) | 2016-07-01 | 2016-07-01 | Block Operations For An Image Processor Having A Two-Dimensional Execution Lane Array and A Two-Dimensional Shift Register |
Publications (3)
Publication Number | Publication Date |
---|---|
GB201709786D0 GB201709786D0 (en) | 2017-08-02 |
GB2560208A GB2560208A (en) | 2018-09-05 |
GB2560208B true GB2560208B (en) | 2019-09-25 |
Family
ID=59153293
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
GB1709786.6A Active GB2560208B (en) | 2016-07-01 | 2017-06-20 | Block operations for an image processor having a two-dimensional execution lane array and a two-dimensional shift register |
GB1900923.2A Active GB2577139B (en) | 2016-07-01 | 2017-06-20 | Block operations for an image processor having a two-dimensional execution lane array and a two-dimensional shift register |
Family Applications After (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
GB1900923.2A Active GB2577139B (en) | 2016-07-01 | 2017-06-20 | Block operations for an image processor having a two-dimensional execution lane array and a two-dimensional shift register |
Country Status (9)
Country | Link |
---|---|
US (5) | US20180007302A1 (en) |
EP (1) | EP3479340A1 (en) |
JP (1) | JP6821715B2 (en) |
KR (1) | KR102190318B1 (en) |
CN (1) | CN107563953B (en) |
DE (2) | DE102017113859A1 (en) |
GB (2) | GB2560208B (en) |
TW (4) | TWI656508B (en) |
WO (1) | WO2018005036A1 (en) |
Families Citing this family (24)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20180007302A1 (en) | 2016-07-01 | 2018-01-04 | Google Inc. | Block Operations For An Image Processor Having A Two-Dimensional Execution Lane Array and A Two-Dimensional Shift Register |
KR102574449B1 (en) * | 2016-11-17 | 2023-09-04 | 삼성전자 주식회사 | Metohd and apparatus for processing data |
US10489878B2 (en) * | 2017-05-15 | 2019-11-26 | Google Llc | Configurable and programmable image processor unit |
KR102586173B1 (en) * | 2017-10-31 | 2023-10-10 | 삼성전자주식회사 | Processor and control methods thererof |
US10565037B2 (en) * | 2017-12-19 | 2020-02-18 | Hewlett Packard Enterprise Development Lp | Data update of shared fabric memory in a high performance computing system |
CN112005213A (en) * | 2018-02-27 | 2020-11-27 | 谷歌有限责任公司 | Large lookup tables for image processors |
US11087513B1 (en) * | 2018-02-27 | 2021-08-10 | Snap Inc. | Real-time bokeh effect |
US11468302B2 (en) * | 2018-03-13 | 2022-10-11 | Recogni Inc. | Efficient convolutional engine |
JP7035751B2 (en) * | 2018-04-12 | 2022-03-15 | 富士通株式会社 | Code conversion device, code conversion method, and code conversion program |
US10983583B2 (en) * | 2018-08-23 | 2021-04-20 | Apple Inc. | Electronic display reduced blanking duration systems and methods |
US10672469B1 (en) * | 2018-11-30 | 2020-06-02 | Macronix International Co., Ltd. | In-memory convolution for machine learning |
US10867375B2 (en) * | 2019-01-30 | 2020-12-15 | Siemens Healthcare Gmbh | Forecasting images for image processing |
WO2020191920A1 (en) * | 2019-03-25 | 2020-10-01 | Huawei Technologies Co., Ltd. | Storing complex data in warp gprs |
CN111858388A (en) * | 2019-04-24 | 2020-10-30 | 北京京东尚科信息技术有限公司 | Method, system, equipment and storage medium for data storage and memory access control |
US10853066B1 (en) | 2019-05-07 | 2020-12-01 | Memryx Incorporated | Memory processing units and methods of computing DOT products including zero bit skipping |
US11488650B2 (en) | 2020-04-06 | 2022-11-01 | Memryx Incorporated | Memory processing unit architecture |
US10998037B2 (en) | 2019-05-07 | 2021-05-04 | Memryx Incorporated | Memory processing units and methods of computing dot products |
US11132569B2 (en) * | 2019-05-22 | 2021-09-28 | Texas Instruments Incorporated | Hardware accelerator for integral image computation |
TWI738009B (en) * | 2019-06-20 | 2021-09-01 | 和碩聯合科技股份有限公司 | Object detection system and object detection method |
KR102372869B1 (en) * | 2019-07-31 | 2022-03-08 | 한양대학교 산학협력단 | Matrix operator and matrix operation method for artificial neural network |
TWI698759B (en) * | 2019-08-30 | 2020-07-11 | 創鑫智慧股份有限公司 | Curve function device and operation method thereof |
GB2599377B (en) * | 2020-09-29 | 2022-11-23 | Roy Smith Graeme | Signal processing systems |
US11574380B2 (en) * | 2020-10-13 | 2023-02-07 | Qualcomm Incorporated | Methods and apparatus for optimizing GPU kernel with SIMO approach for downscaling utilizing GPU cache |
US20240112312A1 (en) * | 2021-03-08 | 2024-04-04 | Google Llc | Motion-Induced Blurring to Reduce Scintillations and an Appearance of a Boundary Separating Regions of a Display |
Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6728862B1 (en) * | 2000-05-22 | 2004-04-27 | Gazelle Technology Corporation | Processor array and parallel data processing methods |
Family Cites Families (106)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4445177A (en) | 1981-05-22 | 1984-04-24 | Data General Corporation | Digital data processing system utilizing a unique arithmetic logic unit for handling uniquely identifiable addresses for operands and instructions |
JPS61296473A (en) * | 1985-06-25 | 1986-12-27 | Mitsubishi Electric Corp | Arithmetic circuit for matrix |
DE3851005T2 (en) | 1987-06-01 | 1995-04-20 | Applied Intelligent Syst Inc | Parallel neighboring processing system and method. |
US4935894A (en) | 1987-08-31 | 1990-06-19 | Motorola, Inc. | Multi-processor, multi-bus system with bus interface comprising FIFO register stocks for receiving and transmitting data and control information |
JPH0748203B2 (en) * | 1988-06-17 | 1995-05-24 | 三菱電機株式会社 | Square matrix multiplier using three-dimensional device |
JP2666411B2 (en) | 1988-10-04 | 1997-10-22 | 三菱電機株式会社 | Integrated circuit device for orthogonal transformation of two-dimensional discrete data |
US5253308A (en) | 1989-06-21 | 1993-10-12 | Amber Engineering, Inc. | Massively parallel digital image data processor using pixel-mapped input/output and relative indexed addressing |
US5173947A (en) | 1989-08-01 | 1992-12-22 | Martin Marietta Corporation | Conformal image processing apparatus and method |
WO1994009595A1 (en) | 1991-09-20 | 1994-04-28 | Shaw Venson M | Method and apparatus including system architecture for multimedia communications |
JP3482660B2 (en) | 1993-09-08 | 2003-12-22 | ソニー株式会社 | Image data processing apparatus and image data processing method |
US5848286A (en) | 1994-03-29 | 1998-12-08 | Cray Research, Inc. | Vector word shift by vo shift count in vector supercomputer processor |
US5606707A (en) | 1994-09-30 | 1997-02-25 | Martin Marietta Corporation | Real-time image processor |
US5612693A (en) | 1994-12-14 | 1997-03-18 | International Business Machines Corporation | Sliding window data compression using a toroidal bit shift register |
JPH08194679A (en) | 1995-01-19 | 1996-07-30 | Texas Instr Japan Ltd | Method and device for processing digital signal and memory cell reading method |
JP3573755B2 (en) | 1996-01-15 | 2004-10-06 | シーメンス アクチエンゲゼルシヤフト | Image processing processor |
US5892962A (en) | 1996-11-12 | 1999-04-06 | Lucent Technologies Inc. | FPGA-based processor |
US6211892B1 (en) | 1998-03-31 | 2001-04-03 | Intel Corporation | System and method for performing an intra-add operation |
US6148111A (en) | 1998-04-27 | 2000-11-14 | The United States Of America As Represented By The Secretary Of The Navy | Parallel digital image compression system for exploiting zerotree redundancies in wavelet coefficients |
US6366289B1 (en) | 1998-07-17 | 2002-04-02 | Microsoft Corporation | Method and system for managing a display image in compressed and uncompressed blocks |
US6587158B1 (en) | 1998-07-23 | 2003-07-01 | Dvdo, Inc. | Method and apparatus for reducing on-chip memory in vertical video processing |
US7010177B1 (en) | 1998-08-27 | 2006-03-07 | Intel Corporation | Portability of digital images |
EP1164544B1 (en) * | 1999-03-16 | 2011-11-02 | Hamamatsu Photonics K.K. | High-speed vision sensor |
JP3922859B2 (en) | 1999-12-28 | 2007-05-30 | 株式会社リコー | Image processing apparatus, image processing method, and computer-readable recording medium storing program for causing computer to execute the method |
US6745319B1 (en) | 2000-02-18 | 2004-06-01 | Texas Instruments Incorporated | Microprocessor with instructions for shuffling and dealing data |
JP2002044525A (en) * | 2000-07-27 | 2002-02-08 | Sony Corp | Solid-state image pickup device, its drive method and camera system |
US6728722B1 (en) | 2000-08-28 | 2004-04-27 | Sun Microsystems, Inc. | General data structure for describing logical data spaces |
US7286717B2 (en) | 2001-10-31 | 2007-10-23 | Ricoh Company, Ltd. | Image data processing device processing a plurality of series of data items simultaneously in parallel |
JP4146654B2 (en) | 2002-02-28 | 2008-09-10 | 株式会社リコー | Image processing circuit, composite image processing circuit, and image forming apparatus |
US9170812B2 (en) | 2002-03-21 | 2015-10-27 | Pact Xpp Technologies Ag | Data processing system having integrated pipelined array data processor |
WO2003088033A1 (en) | 2002-04-09 | 2003-10-23 | University Of Rochester | Multiplier-based processor-in-memory architectures for image and graphics processing |
AU2003286131A1 (en) | 2002-08-07 | 2004-03-19 | Pact Xpp Technologies Ag | Method and device for processing data |
US20060044576A1 (en) | 2004-07-30 | 2006-03-02 | Kabushiki Kaisha Toshiba | Apparatus for image processing |
US20050216700A1 (en) | 2004-03-26 | 2005-09-29 | Hooman Honary | Reconfigurable parallelism architecture |
KR20070039490A (en) | 2004-05-03 | 2007-04-12 | 실리콘 옵틱스 인코포레이션 | A bit serial processing element for a simd array processor |
US7667764B2 (en) | 2004-06-04 | 2010-02-23 | Konica Minolta Holdings, Inc. | Image sensing apparatus |
US7870176B2 (en) * | 2004-07-08 | 2011-01-11 | Asocs Ltd. | Method of and apparatus for implementing fast orthogonal transforms of variable size |
JP4219887B2 (en) | 2004-12-28 | 2009-02-04 | 富士通マイクロエレクトロニクス株式会社 | Image processing apparatus and image processing method |
US7358997B2 (en) * | 2004-12-30 | 2008-04-15 | Lexmark International, Inc. | Multiple resolution optical imager using single size image elements |
ATE504043T1 (en) | 2005-04-28 | 2011-04-15 | Univ Edinburgh | RECONFIGURABLE INSTRUCTION CELL ARRAY |
US7882339B2 (en) | 2005-06-23 | 2011-02-01 | Intel Corporation | Primitives to enhance thread-level speculation |
JP2007004542A (en) | 2005-06-24 | 2007-01-11 | Renesas Technology Corp | Semiconductor signal processing device |
JP2007067917A (en) | 2005-08-31 | 2007-03-15 | Matsushita Electric Ind Co Ltd | Image data processing apparatus |
US7602974B2 (en) | 2005-10-21 | 2009-10-13 | Mobilic Technology (Cayman) Corp. | Universal fixed-pixel-size ISP scheme |
FR2895103B1 (en) | 2005-12-19 | 2008-02-22 | Dxo Labs Sa | METHOD AND SYSTEM FOR PROCESSING DIGITAL DATA |
US7991817B2 (en) | 2006-01-23 | 2011-08-02 | California Institute Of Technology | Method and a circuit using an associative calculator for calculating a sequence of non-associative operations |
GB2436377B (en) | 2006-03-23 | 2011-02-23 | Cambridge Display Tech Ltd | Data processing hardware |
US7802073B1 (en) | 2006-03-29 | 2010-09-21 | Oracle America, Inc. | Virtual core management |
US7933940B2 (en) | 2006-04-20 | 2011-04-26 | International Business Machines Corporation | Cyclic segmented prefix circuits for mesh networks |
JP2007311555A (en) * | 2006-05-18 | 2007-11-29 | Fujifilm Corp | Solid-state imaging device and its driving method |
US20080111823A1 (en) | 2006-11-13 | 2008-05-15 | Faraday Technology Corp. | Graphics processing system |
EP1927950A1 (en) | 2006-12-01 | 2008-06-04 | Thomson Licensing | Array of processing elements with local registers |
EP1927949A1 (en) | 2006-12-01 | 2008-06-04 | Thomson Licensing | Array of processing elements with local registers |
US8321849B2 (en) | 2007-01-26 | 2012-11-27 | Nvidia Corporation | Virtual architecture and instruction set for parallel thread computing |
US20080244222A1 (en) | 2007-03-30 | 2008-10-02 | Intel Corporation | Many-core processing using virtual processors |
JP4389976B2 (en) | 2007-06-29 | 2009-12-24 | ブラザー工業株式会社 | Image processing apparatus and image processing program |
JP4844853B2 (en) | 2007-09-05 | 2011-12-28 | 国立大学法人東北大学 | Solid-state imaging device and driving method thereof |
US8661226B2 (en) | 2007-11-15 | 2014-02-25 | Nvidia Corporation | System, method, and computer program product for performing a scan operation on a sequence of single-bit values using a parallel processor architecture |
JP5134427B2 (en) * | 2008-04-30 | 2013-01-30 | 浜松ホトニクス株式会社 | Solid-state imaging device |
CN102047241B (en) | 2008-05-30 | 2014-03-12 | 先进微装置公司 | Local and global data share |
JP4999791B2 (en) | 2008-06-30 | 2012-08-15 | キヤノン株式会社 | Information processing apparatus, control method thereof, and program |
US8456480B2 (en) | 2009-01-14 | 2013-06-04 | Calos Fund Limited Liability Company | Method for chaining image-processing functions on a SIMD processor |
US8711159B2 (en) | 2009-02-23 | 2014-04-29 | Microsoft Corporation | VGPU: a real time GPU emulator |
KR101572879B1 (en) | 2009-04-29 | 2015-12-01 | 삼성전자주식회사 | Dynamic parallel system and method for parallel application program |
US20110055495A1 (en) | 2009-08-28 | 2011-03-03 | Qualcomm Incorporated | Memory Controller Page Management Devices, Systems, and Methods |
US8976195B1 (en) | 2009-10-14 | 2015-03-10 | Nvidia Corporation | Generating clip state for a batch of vertices |
US8436857B2 (en) | 2009-10-20 | 2013-05-07 | Oracle America, Inc. | System and method for applying level of detail schemes |
US20110102443A1 (en) | 2009-11-04 | 2011-05-05 | Microsoft Corporation | Virtualized GPU in a Virtual Machine Environment |
US8595428B2 (en) | 2009-12-22 | 2013-11-26 | Intel Corporation | Memory controller functionalities to support data swizzling |
GB201007406D0 (en) | 2010-05-04 | 2010-06-16 | Aspex Semiconductor Ltd | Block motion estimation |
US8749667B2 (en) | 2010-08-02 | 2014-06-10 | Texas Instruments Incorporated | System and method for maintaining maximum input rate while up-scaling an image vertically |
US8508612B2 (en) | 2010-09-30 | 2013-08-13 | Apple Inc. | Image signal processor line buffer configuration for processing ram image data |
US8797323B2 (en) | 2011-01-18 | 2014-08-05 | Intel Corporation | Shadowing dynamic volumetric media |
WO2012105174A1 (en) | 2011-01-31 | 2012-08-09 | パナソニック株式会社 | Program generation device, program generation method, processor device, and multiprocessor system |
US9092267B2 (en) | 2011-06-20 | 2015-07-28 | Qualcomm Incorporated | Memory sharing in graphics processing unit |
US20130027416A1 (en) | 2011-07-25 | 2013-01-31 | Karthikeyan Vaithianathan | Gather method and apparatus for media processing accelerators |
WO2013042249A1 (en) * | 2011-09-22 | 2013-03-28 | 富士通株式会社 | Fast fourier transform circuit |
US10310879B2 (en) | 2011-10-10 | 2019-06-04 | Nvidia Corporation | Paravirtualized virtual GPU |
JP5742651B2 (en) | 2011-10-15 | 2015-07-01 | コニカミノルタ株式会社 | Image processing apparatus, linkage method, and linkage program |
JP5746100B2 (en) | 2011-12-27 | 2015-07-08 | 京セラドキュメントソリューションズ株式会社 | Image forming apparatus |
US20130210522A1 (en) | 2012-01-12 | 2013-08-15 | Ciinow, Inc. | Data center architecture for remote graphics rendering |
US8823736B2 (en) | 2012-01-20 | 2014-09-02 | Intel Corporation | Graphics tiling architecture with bounding volume hierarchies |
US10244246B2 (en) | 2012-02-02 | 2019-03-26 | Texas Instruments Incorporated | Sub-pictures for pixel rate balancing on multi-core platforms |
US9235769B2 (en) | 2012-03-15 | 2016-01-12 | Herta Security, S.L. | Parallel object detection method for heterogeneous multithreaded microarchitectures |
TWI520598B (en) | 2012-05-23 | 2016-02-01 | 晨星半導體股份有限公司 | Image processing apparatus and image processing method |
US9232139B2 (en) | 2012-07-24 | 2016-01-05 | Apple Inc. | Image stabilization using striped output transformation unit |
US9319254B2 (en) | 2012-08-03 | 2016-04-19 | Ati Technologies Ulc | Methods and systems for processing network messages in an accelerated processing device |
US20140092087A1 (en) | 2012-09-28 | 2014-04-03 | Takayuki Kazama | Adaptive load balancing in software emulation of gpu hardware |
US9378181B2 (en) | 2012-11-09 | 2016-06-28 | Intel Corporation | Scalable computing array |
US8954992B2 (en) | 2013-03-15 | 2015-02-10 | Lenovo Enterprise Solutions (Singapore) Pte. Ltd. | Distributed and scaled-out network switch and packet processing |
US9477999B2 (en) * | 2013-09-20 | 2016-10-25 | The Board Of Trustees Of The Leland Stanford Junior University | Low power programmable image processor |
JP2016045703A (en) * | 2014-08-22 | 2016-04-04 | 富士通株式会社 | Processing device, method for processing processing device, and program |
US10996959B2 (en) | 2015-01-08 | 2021-05-04 | Technion Research And Development Foundation Ltd. | Hybrid processor |
US9749548B2 (en) | 2015-01-22 | 2017-08-29 | Google Inc. | Virtual linebuffers for image signal processors |
US10291813B2 (en) | 2015-04-23 | 2019-05-14 | Google Llc | Sheet generator for image processor |
US9769356B2 (en) | 2015-04-23 | 2017-09-19 | Google Inc. | Two dimensional shift array for image processor |
US10095479B2 (en) | 2015-04-23 | 2018-10-09 | Google Llc | Virtual image processor instruction set architecture (ISA) and memory model and exemplary target hardware having a two-dimensional shift array structure |
US9785423B2 (en) | 2015-04-23 | 2017-10-10 | Google Inc. | Compiler for translating between a virtual image processor instruction set architecture (ISA) and target hardware having a two-dimensional shift array structure |
US9772852B2 (en) | 2015-04-23 | 2017-09-26 | Google Inc. | Energy efficient processor core architecture for image processor |
US9756268B2 (en) | 2015-04-23 | 2017-09-05 | Google Inc. | Line buffer unit for image processor |
US9965824B2 (en) | 2015-04-23 | 2018-05-08 | Google Llc | Architecture for high performance, power efficient, programmable image processing |
US9632979B2 (en) | 2015-06-01 | 2017-04-25 | Intel Corporation | Apparatus and method for efficient prefix sum operation |
US10313641B2 (en) * | 2015-12-04 | 2019-06-04 | Google Llc | Shift register with reduced wiring complexity |
US20180005346A1 (en) | 2016-07-01 | 2018-01-04 | Google Inc. | Core Processes For Block Operations On An Image Processor Having A Two-Dimensional Execution Lane Array and A Two-Dimensional Shift Register |
US20180007302A1 (en) | 2016-07-01 | 2018-01-04 | Google Inc. | Block Operations For An Image Processor Having A Two-Dimensional Execution Lane Array and A Two-Dimensional Shift Register |
US10481870B2 (en) * | 2017-05-12 | 2019-11-19 | Google Llc | Circuit to perform dual input value absolute value and sum operation |
US10503689B2 (en) * | 2017-05-15 | 2019-12-10 | Google Llc | Image processor I/O unit |
-
2016
- 2016-07-01 US US15/201,237 patent/US20180007302A1/en not_active Abandoned
-
2017
- 2017-06-08 KR KR1020197001454A patent/KR102190318B1/en active IP Right Grant
- 2017-06-08 EP EP17732661.8A patent/EP3479340A1/en not_active Withdrawn
- 2017-06-08 WO PCT/US2017/036563 patent/WO2018005036A1/en unknown
- 2017-06-08 JP JP2018567828A patent/JP6821715B2/en active Active
- 2017-06-20 GB GB1709786.6A patent/GB2560208B/en active Active
- 2017-06-20 US US15/628,527 patent/US9986187B2/en active Active
- 2017-06-20 GB GB1900923.2A patent/GB2577139B/en active Active
- 2017-06-22 DE DE102017113859.5A patent/DE102017113859A1/en active Pending
- 2017-06-22 DE DE202017103725.8U patent/DE202017103725U1/en active Active
- 2017-06-30 TW TW107112864A patent/TWI656508B/en active
- 2017-06-30 TW TW109105105A patent/TWI767190B/en active
- 2017-06-30 TW TW106121882A patent/TWI625697B/en active
- 2017-06-30 TW TW108106652A patent/TWI687896B/en active
- 2017-07-03 CN CN201710534277.6A patent/CN107563953B/en active Active
-
2018
- 2018-04-05 US US15/946,095 patent/US10334194B2/en active Active
-
2019
- 2019-06-21 US US16/448,931 patent/US10531030B2/en active Active
-
2020
- 2020-01-06 US US16/735,050 patent/US11196953B2/en active Active
Patent Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6728862B1 (en) * | 2000-05-22 | 2004-04-27 | Gazelle Technology Corporation | Processor array and parallel data processing methods |
Also Published As
Publication number | Publication date |
---|---|
GB2577139A (en) | 2020-03-18 |
JP2019521441A (en) | 2019-07-25 |
TW201802767A (en) | 2018-01-16 |
TW202025081A (en) | 2020-07-01 |
EP3479340A1 (en) | 2019-05-08 |
US20180007303A1 (en) | 2018-01-04 |
WO2018005036A1 (en) | 2018-01-04 |
US10531030B2 (en) | 2020-01-07 |
GB2560208A (en) | 2018-09-05 |
US20200154072A1 (en) | 2020-05-14 |
KR102190318B1 (en) | 2020-12-11 |
TWI767190B (en) | 2022-06-11 |
CN107563953B (en) | 2021-10-26 |
US20190327437A1 (en) | 2019-10-24 |
US20180234653A1 (en) | 2018-08-16 |
CN107563953A (en) | 2018-01-09 |
DE202017103725U1 (en) | 2017-10-04 |
GB201709786D0 (en) | 2017-08-02 |
GB201900923D0 (en) | 2019-03-13 |
TWI656508B (en) | 2019-04-11 |
US9986187B2 (en) | 2018-05-29 |
TW201921315A (en) | 2019-06-01 |
TW201826219A (en) | 2018-07-16 |
TWI625697B (en) | 2018-06-01 |
US10334194B2 (en) | 2019-06-25 |
DE102017113859A1 (en) | 2018-01-04 |
US20180007302A1 (en) | 2018-01-04 |
GB2577139B (en) | 2021-05-26 |
US11196953B2 (en) | 2021-12-07 |
KR20190025919A (en) | 2019-03-12 |
JP6821715B2 (en) | 2021-01-27 |
TWI687896B (en) | 2020-03-11 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
GB2560208B (en) | Block operations for an image processor having a two-dimensional execution lane array and a two-dimensional shift register | |
US11182138B2 (en) | Compiler for translating between a virtual image processor instruction set architecture (ISA) and target hardware having a two-dimensional shift array structure | |
EP3479341B1 (en) | Core processes for block operations on an image processor having a two-dimensional execution lane array and a two-dimensional shift register | |
EP3286721B1 (en) | Virtual image processor instruction set architecture (isa) and memory model and exemplary target hardware having a two-dimensional shift array structure |