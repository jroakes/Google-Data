CN117061736A - Composite prediction for video coding - Google Patents
Composite prediction for video coding Download PDFInfo
- Publication number
- CN117061736A CN117061736A CN202311027430.8A CN202311027430A CN117061736A CN 117061736 A CN117061736 A CN 117061736A CN 202311027430 A CN202311027430 A CN 202311027430A CN 117061736 A CN117061736 A CN 117061736A
- Authority
- CN
- China
- Prior art keywords
- pixel
- predictor
- block
- predictor block
- weight
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 239000002131 composite material Substances 0.000 title claims abstract description 75
- 238000000034 method Methods 0.000 claims abstract description 126
- 230000008569 process Effects 0.000 description 98
- 230000015654 memory Effects 0.000 description 51
- 230000000295 complement effect Effects 0.000 description 43
- 230000006870 function Effects 0.000 description 18
- 239000013598 vector Substances 0.000 description 16
- 238000004891 communication Methods 0.000 description 11
- 238000010586 diagram Methods 0.000 description 10
- 238000012545 processing Methods 0.000 description 8
- 238000013139 quantization Methods 0.000 description 6
- 208000037170 Delayed Emergence from Anesthesia Diseases 0.000 description 4
- 230000006835 compression Effects 0.000 description 4
- 238000007906 compression Methods 0.000 description 4
- 230000003247 decreasing effect Effects 0.000 description 4
- 238000005192 partition Methods 0.000 description 4
- 230000004044 response Effects 0.000 description 4
- 238000000638 solvent extraction Methods 0.000 description 4
- 230000007423 decrease Effects 0.000 description 3
- 230000003287 optical effect Effects 0.000 description 3
- 230000002123 temporal effect Effects 0.000 description 3
- 230000009466 transformation Effects 0.000 description 3
- 238000013459 approach Methods 0.000 description 2
- 230000008901 benefit Effects 0.000 description 2
- 230000005540 biological transmission Effects 0.000 description 2
- 238000004590 computer program Methods 0.000 description 2
- 238000013461 design Methods 0.000 description 2
- 238000001914 filtration Methods 0.000 description 2
- 239000011159 matrix material Substances 0.000 description 2
- 238000012986 modification Methods 0.000 description 2
- 230000004048 modification Effects 0.000 description 2
- 230000002093 peripheral effect Effects 0.000 description 2
- 230000008859 change Effects 0.000 description 1
- 239000003086 colorant Substances 0.000 description 1
- 230000006837 decompression Effects 0.000 description 1
- 238000006073 displacement reaction Methods 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 238000012546 transfer Methods 0.000 description 1
- 230000001131 transforming effect Effects 0.000 description 1
- 238000013519 translation Methods 0.000 description 1
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/513—Processing of motion vectors
- H04N19/517—Processing of motion vectors by encoding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/46—Embedding additional information in the video signal during the compression process
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/103—Selection of coding mode or of prediction mode
- H04N19/105—Selection of the reference unit for prediction within a chosen coding or prediction mode, e.g. adaptive choice of position and number of pixels used for prediction
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/136—Incoming video signal characteristics or properties
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/136—Incoming video signal characteristics or properties
- H04N19/137—Motion inside a coding unit, e.g. average field, frame or block difference
- H04N19/139—Analysis of motion vectors, e.g. their magnitude, direction, variance or reliability
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/17—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object
- H04N19/176—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object the region being a block, e.g. a macroblock
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/182—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being a pixel
Abstract
Composite prediction for video coding is disclosed. A method for generating a composite predictor block for a current block includes: a predictor block is generated for the current block that includes a first predictor block of first predictor pixels. The method further comprises the steps of: a first adjustment value for adjusting a first weight to be applied to a first predictor pixel is determined for the first predictor pixel and using at least a subset of the first predictor pixels. The composite predictor block is generated using the first predictor pixel, the first weight, and the first adjustment value.
Description
Description of the division
The application belongs to a divisional application of Chinese application patent application No.201780082759.0 with the application date of 2017, 10, 31.
Cross Reference to Related Applications
The present application claims the benefit of U.S. provisional patent application Ser. No. 62/445,999 filed on day 13, 1/2017, the entire disclosure of which is incorporated herein by reference.
Technical Field
The present application relates generally to composite prediction for video coding.
Background
The digital video stream may represent video using a series of frames or still images. Digital video may be used in a variety of applications including, for example, video conferencing, high definition video entertainment, video advertising, or sharing of user-generated video. Digital video streams may include large amounts of data and consume large amounts of computing or communication resources of a computing device for processing, transmitting, or storing video data. Various methods have been proposed for reducing the amount of data in a video stream, including compression and other encoding techniques.
Motion estimation and compensation based coding may be performed by partitioning a frame or image into blocks that are predicted based on one or more predictor blocks of a reference frame. The difference (i.e., residual error) between the block and the predictor block is compressed and encoded in the bitstream. The decoder uses the differences and the reference frames to reconstruct the frame or image.
Disclosure of Invention
The present disclosure relates generally to video coding and, more particularly, to a composite prediction mode for video coding.
One aspect of the disclosed implementations is a method for generating a composite predictor block for a current block of video according to one implementation. The method includes generating, for a current block, a predictor block that includes a first predictor block of first predictor pixels. The method further includes determining, for a first predictor pixel of the first predictor pixels and using at least a subset of the first predictor pixels, a first adjustment value for adjusting a first weight to be applied to the first predictor pixel, and generating a composite predictor block using the first predictor pixel, the first weight, and the first adjustment value.
Thus, when decoding a block encoded in this way, distortion between the original block and the reconstructed block can be reduced.
Optionally, the first weight is selected from a weighting scheme comprising weights 0.75, 0.6, 0.5 and 0.25, and the method further comprises encoding the first weight in the encoded bitstream.
Optionally, the predictor block further comprises a second predictor block of second predictor pixels. Generating the composite predictor block using the first predictor pixel and the first adjustment value includes using a second adjustment value for adjusting a complement of the first weight for a second predictor pixel of the second predictor pixels, wherein the second adjustment value is determined using at least a subset of the second predictor pixels.
Optionally, the first adjustment value is determined based on a difference between the first predictor pixel and the second predictor pixel.
Optionally, the first adjustment value is determined using smoothness in a window around the first predicted pixel.
Optionally, the window is centered on the first predicted pixel and the window has a size of 3 x 3.
Optionally, the first adjustment value is determined using an decay function having a maximum value at a predetermined pixel value of the first predictor block, and the first predicted pixel is input to the decay function to determine the first adjustment value.
Optionally, the method may further comprise decoding the first weights from the encoded bitstream.
Another aspect is an apparatus for generating a composite predictor block including a memory and a processor according to one implementation of the present disclosure. The processor is configured to execute instructions stored in the memory to generate a first predictor block and a second predictor block, the first predictor block including first predictor pixels and the second predictor block including second predictor pixels, determine respective first adjustment values for respective first predictor pixels of the first predictor block, determine respective second adjustment values for respective second pixels of the second predictor block, and determine pixel values for pixels of the composite predictor block using the first predictor pixels, the first adjustment values, the second predictor pixels, and the second adjustment values. Each first adjustment value is determined using at least some of the first predictor pixels. Each second adjustment value is determined using at least some of the second predictor pixels.
Optionally, the instructions further comprise instructions for decoding a baseline weight from the encoded bitstream, wherein the baseline weight indicates a mask comprising the first baseline weight and a complement of the first baseline weight.
Optionally, each first adjustment value is used to adjust a first baseline weight and each second adjustment value is used to adjust a complement of the first baseline weight.
Optionally, the baseline weights indicate weights from a weighting scheme comprising 0.75, 0.6, 0.5, and 0.25.
Optionally, the instructions further comprise instructions to decode a complementary mask indicator and based on the complementary mask indicator, adjust the complement of the first baseline weight using each first adjustment value and adjust the first baseline weight using each second adjustment value.
Optionally, the first adjustment value of the first predictor pixel and the second adjustment value of the second predictor pixel are based on characteristics of the first predictor pixel and the second predictor pixel, wherein the first predictor pixel and the second predictor pixel are co-located.
Optionally, the feature comprises a difference between the first predictor pixel and the second predictor pixel.
Optionally, the instructions further comprise instructions for selecting a first baseline weight and a complement of the first baseline weight, wherein each first adjustment value is used to adjust the first baseline weight and each second adjustment value is used to adjust the complement of the first baseline weight; and selecting an adjustment direction having an upward value or a downward value, wherein the first baseline weight adjusts upward as the characteristic increases when the adjustment direction is the upward value, and wherein the first baseline weight adjusts downward as the characteristic increases when the adjustment direction is the downward value.
Optionally, the characteristics include a first smoothness with respect to the first predictor pixel and a second smoothness with respect to the second predictor pixel.
Optionally, determining the respective first adjustment value for the respective first predictor pixel of the first predictor block includes identifying a peak value of the first predictor block and determining the first adjustment value for the first predictor pixel based on a difference between the peak value and the first predictor pixel.
Another aspect is an apparatus for decoding a current block comprising a memory and a processor according to one implementation of the present disclosure. The processor is configured to execute instructions stored in the memory to generate a first predictor block and a second predictor block, decode a weight mask from the encoded bitstream, determine a baseline weight for a first weight for pixels of the first predictor block and a complementary baseline weight for a second weight for pixels of the second predictor block from the weight mask, determine a first adjustment value for the first predictor pixel of the first predictor block using at least some of the pixels in the first predictor block, determine a second adjustment value for the second predictor pixel of the second predictor block using at least some of the pixels in the second predictor block, and generate a composite predictor comprising a third predictor pixel using the first predictor pixel, the second predictor pixel, the baseline weight, the complementary baseline weight, the first adjustment value, and the second adjustment value. The first adjustment value is used to adjust the baseline weight. The second adjustment value is used to adjust the complementary baseline weight. The second predictor pixel is co-located with the first pixel predictor.
Optionally, the baseline weight has a first value and the complementary baseline weight has a second value, and the instructions further include decoding an indication that the complementary mask is used, and in response to the indication that the complementary mask is used being the first value, using the second value as the value of the baseline weight and using the first value as the value of the complementary baseline weight. The first value and the second value are added up to 1.
It should be noted that any of the features described above may be used with any particular aspect or embodiment of the present invention.
These and other aspects of the disclosure are disclosed in the following detailed description of the embodiments, appended claims and drawings.
Drawings
The description herein makes reference to the accompanying drawings wherein like reference numerals refer to like parts throughout the several views.
Fig. 1 is a schematic diagram of a video encoding and decoding system.
Fig. 2 is a block diagram of an example of a computing device that may implement a sending station or a receiving station.
Fig. 3 is a diagram of a video stream to be encoded and subsequently decoded.
Fig. 4 is a block diagram of an encoder according to an implementation of the present disclosure.
Fig. 5 is a block diagram of a decoder according to an implementation of the present disclosure.
Fig. 6 is a flow chart of a process of composite motion prediction for a current pixel block according to an implementation of the present disclosure.
Fig. 7 is an example of using pixel differences to adjust baseline weights according to an implementation of the present disclosure.
Fig. 8 is a flowchart of a process of complex prediction using a first predictor block and a second predictor block to predict a current pixel block in accordance with an implementation of the present disclosure.
Fig. 9 is a flowchart of a process for generating a composite predictor block for a current block of video according to a second implementation of the present disclosure.
Fig. 10 is a flowchart of a process of generating a composite predictor block according to a third implementation of the present disclosure.
Fig. 11 is a flow chart of a process of decoding a current block according to a second implementation of the present invention.
Detailed Description
As described above, compression schemes related to coding video streams may include dividing an image (i.e., an original image or a source image) into blocks and generating a digital video output bitstream using one or more techniques that limit the information included in the output. The received encoded bit stream may be decoded to recreate the block and source image from the limited information. Encoding a video stream or a portion thereof (such as a frame or block) may include using temporal or spatial similarities in the video stream to improve coding efficiency. For example, a current block of a video stream may be encoded based on identifying differences (residuals) between previously encoded pixel values and pixel values in the current block. In this way, only the residual and the parameters used to generate the residual need to be added to the encoded bitstream. The residual may be encoded using a lossy quantization step. Decoding (i.e., reconstructing) a coded block from such a residual often results in distortion between the original block and the reconstructed block.
Coding using spatial similarity may be referred to as intra prediction. Using the intra prediction mode, intra prediction may attempt to predict pixel values of a current block of a current frame of the video stream using pixels around the current block. The pixels surrounding the current block are pixels within the current frame but outside the current block. The pixels at the periphery of the block may be pixels adjacent to the current block. Which pixels of the block periphery to use may depend on the intra prediction mode and/or the scanning order of the blocks of the frame. For example, peripheral pixels above the current block (i.e., the block being encoded or decoded) and/or peripheral pixels to the left of the current block may be used in the raster scan order.
Coding using temporal similarity may be referred to as inter prediction. Inter prediction uses a motion vector that represents the temporal displacement of a previously coded block relative to the current block. Motion vectors may be identified using motion estimation methods such as motion search. In motion search, a portion of a reference frame may be translated to a series of (success) locations to form a predictor block, which may be subtracted from a portion of the current frame to form a series of residuals. The horizontal and/or vertical translation corresponding to the position with e.g. the smallest residual may be selected as motion vector. The motion vectors and the indication of the reference frame may be encoded in the encoded bitstream.
In some cases and in order to further minimize the residual, more than one predictor block may be combined to predict the current block. This may be referred to as complex prediction. Complex prediction can sometimes significantly reduce the residual error signal to be coded.
The composite predictor may be created by combining two or more predictors determined using an inter prediction mode and an intra prediction mode. For example, the composite predictor may be generated by combining an intra-generated predictor with an inter-generated predictor (i.e., intra + inter), by combining two intra-generated predictor blocks (i.e., intra + intra), or by combining two inter-generated predictor blocks (i.e., inter + inter). For example, the composite inter prediction may employ a first motion vector to obtain a first predictor block from a first block of a first frame and a second motion vector to obtain a second predictor block from a second block of a second frame. The first frame and the second frame are referred to as reference frames. The reference frames may all be past, all future, or some combination thereof. The second motion vector may be independent of or derived from the first motion vector. The encoder conveys (level) (e.g., encoded in an encoded bitstream) the first motion vector, the second motion vector, the first reference, and the second reference frame to the decoder. The composite predictor may use two or more predictor blocks.
In forming a composite predictor (e.g., in the case of two predictor blocks), a video codec (i.e., encoder and/or decoder) combines pixels of a first predictor block and pixels of a second predictor block that are co-located. For example, to obtain pixel values of pixels of a composite predictor block located at a pixel position (row=r, column=c) of the composite predictor block, the video codec combines a first pixel value of a first pixel located at a position (r, c) in the first predictor block with a second pixel value of a second pixel located at a position (r, c) in the second predictor block.
The combining may use the same weight mask for all pixels of the composite predictor block. That is, using equation (1), using mask { w1, (1-w 1) }, weight w1 is applied to each pixel value of the first predictor block, and weight (1-w 1) is applied to each pixel value of the second predictor block:
current[r][c]＝p1[r][c]*w1+p2[r][c]*(1-w1) (1)
in equation (1), current [ r ] [ c ] is the pixel value of the pixel of the composite predictor block at position (r, c), p1[ r ] [ c ] is the co-located pixel value in the first predictor block and p2[ r ] [ c ] is the co-located pixel value in the second predictor block. In an example, pixels from the first predictor block and the second predictor block are equally weighted using a mask {1/2,1/2 }. In the mask { w1, (1-w 1) }, the weight w1 may be referred to herein as a baseline weight and the weight (1-w 1) may be referred to as a complementary baseline weight. Where more than two predictor blocks are used, the mask may contain more weight. For example, the mask may explicitly or implicitly include weights for each of the predictors. The weights of the masks may add up to 1.
In another example, the weights may vary based on the first predictor block partition and the second predictor block partition. For example, the partitioning may be based on detecting edges in the first and second predictor blocks. In another example, the partitioning may be based on partitioning the first and second predictor blocks into four quadrants or two equal parts. The weights may be assigned based on which partition the first pixel value falls within the first predictor block, which partition the second pixel value falls within the second predictor block, or a combination thereof. Thus, the weighting is spatial (i.e., pixel-based in location). For example, in the case where the predictor block is split into left and right sides, it may be that the left side of the first predictor block is the predictor of the left side of the current block that is better than the left side of the second predictor block. The pixel positions within the left side of the first predictor block can be weighted more. In any case, an indication of the mask (i.e., the weights) may be sent from the encoder to the decoder in the encoded bitstream. In an example, an indication of the mask may be implicitly sent. For example, the encoder and decoder may be configured a priori to use a particular mask (e.g., mask 0.75,0.25). The encoder does not need to encode a mask in the encoded bitstream. Encoding the mask may mean encoding a value of the mask or a quantized value of the mask. The encoding mask may mean a value of the encoding mask or a quantized value of the mask. The code mask may mean an indication of the code mask. For example, as described below, the indication may be a mask index.
In implementations of the invention, compression performance may be improved by taking weights from the values of the pixels of the predictor block itself and/or by adjusting the weights to be applied to the pixels of the predictor block (i.e., when generating the composite predictor).
For example, as further described below, comparisons (e.g., differences) of pixels of a predictor block may be used to generate adjustment values and/or weights to be applied to pixels of a first predictor as well as a second predictor.
For example, if the baseline weight w1 is to be used with a first predictor block, as further described below, then at least a subset of the pixels of the first predictor block may be used to determine the adjustment value. The adjustment value may be applied to the baseline weight w1 when combining the predictor blocks to generate a composite predictor block. Different adjustment values may be generated for each pixel in the first predictor block (and the second predictor block) using the pixel of the first predictor block (and the pixel of the second predictor block). Using pixels of the first predictor block means using values of pixels of the first predictor block.
The codec (i.e., encoder and/or decoder) may determine weights to be applied to the composite prediction based at least in part on pixel values of the predictor block. Since the decoder can accurately recreate the predictor block (used by the encoder) using the information conveyed by the encoder in the encoded bitstream, the decoder can generate the same weights (i.e., the fetched weights) and the same final composite predictor block without additional information regarding the weights to be applied to the pixels of the predictor block. Baseline weights (e.g., default, initial, average weights) may be communicated in the encoded bitstream and the decoder may use the retrieved weights (i.e., adjustment values) to adjust (i.e., adjust) the baseline weights.
As described above, different weights may be used for each pixel and the weights may depend on the prediction signal (e.g., pixel values of the predictor block) itself. The "prediction signal" includes information indicating at least one pixel value. A "pixel value" includes a value associated with a pixel, such as color or brightness. The different weights may be adjusted (i.e., tuned) weights of some base weights (i.e., baseline weights). The baseline weight may be a weight applied to each of the pixels of the predictor block. In contrast, the adjusted weights are weights calculated for the pixels. The disclosure herein applies equally to the chrominance and luminance components and/or the red-green-blue (RGB) components of a pixel. That is, for example, the adjusted weights may be calculated for the chrominance components; and different or the same adjusted weights may be determined for the chrominance components.
In the case of inter-frame composite predictor blocks, given a first motion vector and a second motion vector, the first predictor block and the second predictor block may be generated from a first reference frame and a second reference frame, respectively. The weights applied to the pixels of the first predictor block and the weights applied to the pixels of the second predictor block may depend on the nature (e.g., pixel values) of the first predictor block and the second predictor block themselves. Although two predictor blocks (i.e., a first predictor block and a second predictor block) are used herein, the teachings of the present disclosure are not so limited. Any number of predictor blocks may be used for the relevant composite prediction mode of video coding.
As described further below, the encoder may communicate additional information in the encoded bitstream (described further below) and the decoder may receive and use the additional information in the encoded bitstream, which further directs the weight generation process of the decoder. The weight generation process is a process of determining which corresponding weights to apply to pixels of a predictor block when pixels of the predictor block are combined via complex prediction. The additional information may include one or more of an adjustment direction of the baseline weights, whether to use a complementary mask, and one or more peak pixel values of at least some of the predictor blocks.
The adjustment direction may indicate how to adjust the baseline weight for the predictor pixel when calculating the composite pixel using the predictor pixel. For example, the direction of adjustment may indicate whether the baseline weight is to be adjusted upward (i.e., increased in value) and downward (i.e., decreased). For example, the adjustment direction may indicate, for a predictor pixel of the predictor block, whether the baseline weight is adjusted upward or downward as the characteristics of the predictor pixel increase or decrease. As described further below, this characteristic may be with respect to pixel differences, smoothness of the pixels, or may be with respect to peak pixel values. The adjustment direction may indicate whether to increase or decrease the baseline weight as a pixel value difference or a relative smoothness difference between pixels co-located in the first predictor block and the second predictor block increases or decreases.
The complementary mask indicator may indicate that the weight mask { (1-w 1), w1} instead of the standard weight mask { w1, (1-w 1) } will be applied to the first predictor block and the second predictor block, respectively.
The peak pixel value indicates how the baseline weight is adjusted based on the decay function. The decay function may have a maximum value at the peak pixel value and decay as the difference between the pixel value and the peak of the predictor block increases. Other details are described herein after first describing the environment in which the present disclosure may be implemented.
The relevant composite prediction modes for video coding are described herein first with reference to a system in which the present teachings may be incorporated.
Fig. 1 is a schematic diagram of a video encoding and decoding system 100. The transmitting station 102 may be, for example, a computer having an internal configuration such as the hardware depicted in fig. 2. However, other suitable implementations of the sending station 102 are possible. For example, the processing of the sending station 102 may be distributed among multiple devices.
The network 104 may connect the sending station 102 and the receiving station 106 for encoding and decoding of video streams. In particular, a video stream may be encoded in the sending station 102 and the encoded video stream may be decoded in the receiving station 106. The network 104 may be, for example, the internet. Network 104 may also be a Local Area Network (LAN), wide Area Network (WAN), virtual Private Network (VPN), mobile telephone network, or any other means for transmitting a video stream from sending station 102 to receiving station 106 in this example.
In one example, the receiving station 106 may be a computer having an internal configuration such as the hardware depicted in fig. 2. However, other suitable implementations of the receiving station 106 are possible. For example, the processing of the receiving station 106 may be distributed among multiple devices.
Other implementations of the video decoding and encoding system 100 are possible. For example, the implementation may omit the network 104. In another implementation, the video stream may be encoded and any stored for later transmission to the receiving station 106 or any other device having memory. In one implementation, the receiving station 106 receives the encoded video stream (e.g., via the network 104, a computer bus, and/or some communication path) and stores the video stream for subsequent decoding. In one example implementation, real-time transport protocol (RTP) is used to transport encoded video over network 104. In another implementation, a transport protocol other than RTP may be used, such as a hypertext transfer protocol (HTTP) based video streaming protocol.
For example, when used in a video conferencing system, the sending station 102 and/or the receiving station 106 may include the capabilities to encode and decode video streams as described below. For example, the receiving station 106 may be a video conference participant that receives the encoded video bitstream from a video conference server (e.g., the sending station 102) to decode and view and further encode and transmit its own video bitstream to the video conference server for decoding and viewing by other participants.
Fig. 2 is a block diagram of an example of a computing device 200 that may implement a sending station or a receiving station. For example, computing device 200 may implement one or both of transmitting station 102 and receiving station 106 of fig. 1. Computing device 200 may be in the form of a computing system including multiple computing devices or in the form of a single computing device, such as a mobile phone, tablet, laptop, notebook, desktop, or the like.
The CPU 202 in the computing device 200 may be a central processing unit. Or CPU 202 may be any other type of device or devices capable of operating or processing information either now present or later developed. Although the disclosed implementations may be implemented with a single processor, such as CPU 202, as shown, more than one processor may be used to achieve speed and efficiency advantages.
The memory 204 in the computing device 200 may be a Read Only Memory (ROM) device or a Random Access Memory (RAM) device in one implementation. Any other suitable type of storage device may be used as memory 204. Memory 204 may include code and data 206 accessed by CPU 202 using bus 212. The memory 204 may further include an operating system 208 and application programs 210, the application programs 210 including at least one program that allows the CPU 202 to perform the methods described herein. For example, application 210 may include applications 1 through N, which further include video coding applications that perform the methods described herein. The computing device 200 may also include secondary storage 214, which secondary storage 214 may be, for example, a memory card for use with the mobile computing device 200. Because video communication sessions may include a large amount of information, they may be stored in whole or in part in secondary storage 214 and loaded into memory 204 for processing as needed.
Computing device 200 may also include one or more output devices, such as a display 218. In one example, the display 218 may be a touch sensitive display combining the display with a touch sensitive element operable to sense touch input. A display 218 may be coupled to CPU 202 via bus 212. In addition to the display 218 or as an alternative to the display 218, other output devices may be provided that allow a user to program or otherwise use the computing device 200. Where the output device is or includes a display, the display may be implemented in a variety of ways, including by a Liquid Crystal Display (LCD), a Cathode Ray Tube (CRT) display, or a Light Emitting Diode (LED) display, such as an Organic LED (OLED) display.
Computing device 200 may also include or be in communication with an image sensing device 220, image sensing device 220 being, for example, a camera or any other image sensing device 220 that now exists or later developed that can sense images, such as images of a user operating computing device 200. The image sensing device 220 may be positioned such that it is directed to a user operating the computing device 200. In one example, the position and optical axis of the image sensing device 220 may be configured such that the field of view includes an area directly adjacent to the display 218 and from which the display 218 may be seen.
Computing device 200 may also include or be in communication with a sound sensing device 222, such as a microphone or any other sound sensing device now present or later developed that may sense sound in the vicinity of computing device 200. The sound sensing device 222 can be positioned such that it is directed to a user operating the computing device 200 and can be configured to receive sound, such as speech or other utterances, produced by the user while the user is operating the computing device 200.
Although fig. 2 depicts the CPU 202 and memory 204 of the computing device 200 as being integrated into a single unit, other configurations may be utilized. The operation of the CPU 202 may be distributed among multiple machines (each machine having one or more processors) that may be coupled directly or across a local area network or other network. Memory 204 may be distributed across multiple machines, such as internet-based memory or memory in multiple machines performing the operations of computing device 200. Although depicted here as a single bus, the bus 212 of the computing device 200 may be comprised of multiple buses. Further, secondary storage 214 may be directly coupled to other components of computing device 200 or may be accessible via the internet and may include a single integrated unit such as a memory card or multiple units such as multiple memory cards. Computing device 200 may be implemented in a variety of configurations.
Fig. 3 is a schematic diagram of an example of a video stream 300 to be encoded and subsequently decoded. Video stream 300 includes video sequence 302. At the next level, the video sequence 302 includes a number of adjacent frames 304. Although three frames are described as adjacent frames 304, the video sequence 302 may include any number of adjacent frames 304. The adjacent frames 304 may then be further subdivided into individual frames, such as frame 306. At the next stage, the frame 306 may be divided into a series of segments 308 or planes. For example, segment 308 may be a subset of frames that allow parallel processing. Segment 308 may also be a subset of frames that may separate video data into separate colors. For example, a frame 306 of color video data may include a luminance plane and two chrominance planes. Segment 308 may be sampled at different resolutions.
Whether or not frame 306 is divided into segments 308, frame 306 may be further subdivided into blocks 310, which blocks 310 may include data corresponding to, for example, 16x16 pixels in frame 306. The block 310 may also be arranged to include data from one or more segments 308 of pixel data. The block 310 may also have any other suitable size, such as 4x4 pixels, 8x8 pixels, 16x8 pixels, 8x16 pixels, 16x16 pixels, or larger.
Fig. 4 is a block diagram of an encoder 400 according to an implementation of the present disclosure. As described above, the encoder 400 may be implemented in the sending station 102, such as by providing a computer software program stored in a memory, such as the memory 204. The computer software program may include machine instructions that, when executed by a processor such as CPU 202, cause sending station 102 to encode video data in the manner described herein. Encoder 400 may also be implemented as specific hardware included in, for example, transmitting station 102. The encoder 400 has the following stages that perform various functions in the forward path (shown by the solid line connection) using the video stream 300 as input to produce an encoded or compressed bitstream 420: an intra/inter prediction stage 402, a transform stage 404, a quantization stage 406, and an entropy encoding stage 408. Encoder 400 may also include a reconstruction path (shown by dashed connecting lines) to reconstruct the encoded frames for the following blocks. In fig. 4, the encoder 400 has the following stages performing various functions in the reconstruction path: a dequantization stage 410, an inverse transformation stage 412, a reconstruction stage 414, and a loop filtering stage 416. Other structural variations of encoder 400 may be used to encode video stream 300.
When video stream 300 is presented for encoding, the respective adjacent frames 306 may be processed in units of blocks. In the intra/inter prediction stage 402, blocks may be encoded using intra prediction (also referred to as intra prediction) or inter prediction (also referred to as inter prediction) or a combination of both. In any case, a predictor block may be formed. In the case of intra prediction, all or part of the predictor block may be formed from samples in the current frame that have been previously encoded and reconstructed. In the case of inter prediction, all or part of the predictor block may be formed from samples in one or more previously constructed reference frames determined using motion vectors.
Referring still next to fig. 4, a prediction block may be subtracted from a current block at an intra/inter prediction stage 402 to produce a residual block (also referred to as a residual). The transform stage 404 transforms the residual using a block-based transform into transform coefficients, e.g., in the frequency domain. Such block-based transforms include, for example, discrete Cosine Transforms (DCTs) and Asymmetric Discrete Sine Transforms (ADSTs). Other block-based transforms are possible. Furthermore, a combination of different transforms may be applied to a single residual. In one example of the application of the transform, the DCT transforms the residual block to the frequency domain where the transform coefficient values are based on spatial frequencies. The lowest frequency (DC) coefficient is located in the upper left hand corner of the matrix and the highest frequency coefficient is located in the lower right hand corner of the matrix. It is noted that the predictor block, and thus the residual block, may be of a different size than the transform block. For example, a predictor block may be partitioned (split) into smaller blocks to which individual transforms are applied.
The quantization stage 406 converts the transform coefficients into discrete magnitudes of the transform coefficients, referred to as quantization, using quantizer values or quantization stages. For example, the transform coefficients may be divided by the quantizer values and truncated. The quantized transform coefficients are then entropy encoded by an entropy encoding stage 408. Entropy coding may be performed using any number of techniques, including tokens and binary trees. The entropy encoded coefficients are output to the compressed bitstream 420 along with other information for decoding the block that may include, for example, the type of prediction used, the type of transform, the motion vector, and the quantizer values. The information for decoding the blocks may be entropy coded into blocks, frames, slices, and/or headers within the compressed bitstream 420. The compressed bitstream 420 may also be referred to as an encoded video stream or an encoded video bitstream, and these terms are used interchangeably herein.
The reconstruction path (shown by the dashed connection line) in fig. 4 may be used to ensure that both the encoder 400 and decoder 500 (described below) decode the compressed bitstream 420 using the same reference frames and blocks. The reconstruction path performs functions similar to those that occur during the decoding process discussed in more detail below, including dequantizing the quantized transform coefficients at dequantization stage 410 and inverse transforming the dequantized transform coefficients at inverse transformation stage 412 to produce a derivative residual block (also referred to as a derivative residual). At the reconstruction stage 414, the predictor blocks predicted at the intra/inter prediction stage 402 may be added to the derivative residuals to create a reconstructed block. Loop filter stage 416 may be applied to the reconstructed block to reduce distortion such as block artifacts.
Other variations of encoder 400 may be used to encode compressed bitstream 420. For example, the non-transform based encoder 400 may directly quantize the residual signal for certain blocks or frames without the transform stage 404. In another implementation, the encoder 400 may have a quantization stage 406 and a dequantization stage 410 combined into a single stage.
Fig. 5 is a block diagram of a decoder 500 according to an implementation of the present disclosure. Decoder 500 may be implemented in receiving station 106, for example, by providing a computer software program stored in memory 204. The computer software program may include machine instructions that, when executed by a processor such as CPU 202, cause receiving station 106 to decode video data in the manner described below in fig. 6. Decoder 500 may also be implemented in hardware included in, for example, transmitting station 102 or receiving station 106. Similar to the reconstruction path of encoder 400 described above, in one example, decoder 500 includes the following stages that perform various functions from compressed bitstream 420 to produce output video stream 516: an entropy decoding stage 502, a dequantization stage 504, an inverse transform stage 506, an intra/inter prediction stage 508, a reconstruction stage 510, a loop filter stage 512, and a deblocking filter stage 514. Other structural variations of decoder 500 may be used to decode compressed bitstream 420.
When the compressed bitstream 420 is presented for decoding, the data elements in the compressed bitstream 420 may be decoded by the entropy decoding stage 502 to produce a set of quantized transform coefficients. Dequantization stage 504 dequantizes the quantized transform coefficients (e.g., by multiplying the quantized transform coefficients by a quantizer value), and inverse transform stage 506 inverse transforms the dequantized transform coefficients using the selected transform type to produce a derivative residual that may be the same as the derivative residual created by inverse transform stage 412 in encoder 400. Using header information decoded from compressed bitstream 420, decoder 500 may create the same predictor block in encoder 400 using intra/inter prediction stage 508 as the predictor block created in inter/intra prediction stage 402, for example. At the reconstruction stage 510, the predictor block is added to the derivative residual to create a reconstructed block. The loop filter stage 512 may be applied to the reconstructed block to reduce block artifacts. Other filtering may be applied to the reconstructed block. In an example, the deblocking filter stage 514 is applied to reconstructed blocks to reduce block distortion, and the results are output as an output video stream 516. The output video stream 516 may also be referred to as a decoded video stream and these terms will be used interchangeably herein.
Other variations of decoder 500 may be used to decode compressed bit stream 420. For example, decoder 500 may generate output video stream 516 without deblocking filter stage 514. In some implementations of decoder 500, deblocking filter stage 514 is applied prior to loop filter stage 416. Additionally or alternatively, encoder 400 includes a deblocking filter stage in addition to loop filter stage 416.
Fig. 6 is a flow chart of a process 600 for composite motion prediction for a current pixel block in accordance with an implementation of the present invention. Process 600 may be implemented in an encoder, such as encoder 400, or a decoder, such as decoder 500.
Process 600 may be implemented, for example, as a software program that may be executed by a computing device such as sending station 102. The software program may include machine readable instructions that may be stored in a memory, such as memory 204 or secondary storage 214, and which may be executed by a processor, such as CPU 202, to cause the computing device to perform process 600. In at least some implementations, the process 600 may be performed in whole or in part by the intra/inter prediction stage 402 of the encoder 400.
Process 600 may be performed by a decoder, such as decoder 500. The process 600 may be implemented, for example, as a software program executed by a computing device such as the receiving station 106. The process 600 may be performed in whole or in part by the intra/inter prediction stage 508 of the decoder 500. For example, an implementation of process 600 may be performed by instructions stored in a memory, such as memory 204 of receiving station 106, for execution by a processor, such as CPU 202.
Process 600 may be implemented using dedicated hardware or firmware. Some computing devices may have multiple memories, multiple processors, or both. Different processors, memories, or both may be used to distribute the steps or operations of process 600. The term "processor" or "memory" is used in the singular to include computing devices having one processor or one memory as well as devices having multiple processors or multiple memories that may be used to perform some or all of the described steps.
The process 600 determines pixel values for pixel locations of the composite predictor block based on the weighting. The weighting may be based on a first pixel value of the first predictor block and a second pixel value of the second predictor block. The process 600 may determine a respective pixel value for each location in the composite predictor block. In an example, process 600 determines at least a portion of a composite predictor block as a weighting of pixel values from two or more predictor blocks. The weighting of at least one of the predictor pixel values may be based on pixel values of pixels in at least one of the predictor blocks.
At 602, the process 600 determines a first predictor block and a second predictor block to predict a current block of pixels. As used herein, "determining" means selecting, constructing, identifying, specifying, receiving or determining in any way whatsoever. For example, the process 600 may receive the first motion vector, the second motion vector, and the reference frame information as described above with respect to the intra/inter prediction stage 402 of the encoder 400 or the intra/inter prediction stage 508 of the decoder 500. The process 600 determines a first predictor block and a second predictor block accordingly. Alternatively, the process 600 determines the first predictor block and the second predictor block by receiving the first predictor block and the second predictor block determined by the previous step. The first predictor block and the second predictor block may be any combination of inter + inter predictor block, inter + intra predictor block or intra + intra predictor block. Any number (e.g., greater than two) of predictor blocks may be determined at 602. The teachings herein apply to any number of predictor blocks.
At 604, process 600 determines pixel values for pixels of the composite predictor pixel block based on a weighting that is based on pixel values of the first predictor block and pixel values of the second predictor block. As indicated above, the weighting of each pixel depends on the prediction signal itself. That is, the weighting depends on the pixel values of the pixels of the first predictor block and the second predictor block. A non-limiting example of weighting based on the first pixel value and the second pixel value of the first predictor block is now provided.
To minimize decoder complexity, the weight generation process is expected to be a simple process. The weighting of the predictor pixels (i.e. pixels of the first predictor block or the second predictor block) may be adjusted based on the characteristics of the predictor pixels. Examples of the characteristics are provided below. Each of the predictor pixels (i.e., the predictor pixels of the composite pixels to be combined to form the composite predictor) may have a respective feature value of the characteristic. For example, in the case of two predictor blocks, a first characteristic value of a characteristic of a first predictor pixel of a first predictor block may be used to adjust a baseline weight and a second characteristic value of a characteristic of a co-located second predictor pixel of a second predictor block may be used to adjust the baseline weight. The adjusted baseline weights are then applied to the first predictor pixel and the second predictor pixel of the second predictor block to generate a composite predictor pixel. As indicated above, the first predictor pixel and the second predictor pixel are co-located.
In a first example, the weight generation process proceeds as follows: given the first predictor block and the second predictor block, and for each pixel location in the composite predictor block, process 600 determines an absolute difference (e.g., a characteristic) between pixels co-located in the first predictor block and the second predictor block. The absolute difference may be used to set the weighting. In an implementation, the baseline weight may be adjusted (e.g., adjusted, modified, scaled) based on the difference. Thus, the weighting is further based on baseline weights.
Fig. 7 is an example 700 of using pixel differences to adjust baseline weights according to an implementation of the present disclosure. In this example, the difference between the first pixel of the first predictor block and the second pixel of the second predictor block is a characteristic for adjusting the weighting. The example 700 includes a first predictor block 710, a second predictor block 720, and a composite predictor block 730. The pixels of the composite predictor block 730 are generated by combining co-located pixels of the predictor blocks (e.g., the first predictor block 710 and the second predictor block 720). The pixel values of the composite predictor block 730 will be derived based on the weighting of the pixel values of the first predictor block 710 and the second predictor block 720. The adjusted weights for pixels located at pixel locations (r, c) of the composite predictor block 730 are calculated according to equation (2).
/>
In equation 2, modulated [ r ] [ c ] is the weight (i.e., adjusted or adjusted baseline weight) to be applied to the pixel values of the composite predictor block at location (r, c), p1[ r ] [ c ] is the pixel value at location (r, c) in the first predictor block, p2[ r ] [ c ] is the pixel value at location (r, c) in the second predictor block, weight is the baseline weight and maxvalue is the highest possible pixel value. Although "pixel values" are used herein, the teachings herein apply equally to the color components of pixels. The color components may include luminance and chrominance components. The color components may include RGB color components of the pixel.
With the adjustment function of equation (2), as the difference in pixel values increases, the first predictor block is weighted more and the baseline weight (weight) approaches 1. Further, as the difference in pixel values increases, the second predictor block is weighted less (i.e., 1-weight) and the baseline weight of the second predictor block approaches 0. This is because positive values are added to the baseline weights (weights) used with the first prediction variable. A baseline weight (e.g., 0.75) is used for the first predictor block pixels when the corresponding pixels of the first predictor block and the second predictor block have the same value.
The adjustment function of example 700 is merely one example of an adjustment function. Other functions may be used. For example, another adjustment function may adjust the baseline weight (weight) up or down based on the difference rather than the absolute value of the difference.
The encoder may encode and the decoder may decode the adjustment direction from the encoded bitstream. The adjustment direction may indicate an up value and a down value. For example, an up value may be indicated with a bit value of 0 and a down value may be indicated with a bit value of 1. Other indications are possible. When the adjustment direction is an upward value, the first baseline weight is adjusted upward as the difference between the corresponding pixel values in the predictor block and the second predictor block increases. As the difference increases, this adjustment function will weight the pixels of the first predictor block higher. When the adjustment direction is a downward value, the first baseline weight is adjusted downward as the difference increases. On the other hand, such adjustment facilitates pixels of the second predictor block-i.e., since the sum of the first baseline weight and the second baseline weight is 1, by decreasing the first baseline weight of the first predictor block, the second baseline weight of the second predictor block correspondingly increases.
When indicating baseline weights in the encoded bitstream, it may be assumed that corresponding values of the weighting scheme will be used with the first predictor block. The baseline weights may be selected, for example, from a weighting scheme. Examples of weighting schemes include baseline weights 0.75,0.6,0.5,0.25. The weighting scheme is a set of baseline weights that can be used by an encoder, decoder, or encoder/decoder pair. If bit 01 is indicated, a baseline weight (weight) of 0.6 for the weighting scheme will be used for the first predictor block and a complementary baseline weight of 0.4 (i.e., (1-weight)) will be used with the second predictor block. However, in some examples, the encoder may determine that complementary baseline weights are to be used with the first predictor block. Thus, the encoder encodes in the encoded bitstream and the decoder decodes from the encoded bitstream a complementary mask indicator (i.e., syntax element) that indicates that the first baseline weight is to be used with the second predictor block and that the second baseline weight (i.e., complementary baseline weight) is to be used with the first predictor block. For example, if baseline scheme 01 (i.e., decimal value 1) is indicated and a complementary mask signal is indicated, then weight 0.4 is used with the first predictor block and weight 0.6 is used with the second predictor block.
In example 700, assume that the value of the baseline weight (weight) is 0.75 and the highest possible pixel value maxvalue is 255. Using pixel 712 of the first predictor block (i.e., pixel value 112) and pixel 722 of the second predictor block (i.e., pixel value 111), the adjusted weights for pixel 732 at pixel position (0, 0) of the composite predictor block are calculated as follows:
and using pixel 714 of the first predictor block (i.e., pixel value 248) and pixel 724 of the second predictor block (i.e., pixel value 57), the adjusted weights for pixel 732 at pixel locations (1, 2) of the composite predictor block are calculated as follows:
using the adjusted weights, pixel values of the composite predictor block may be calculated. Equation (1) can be used to calculate the pixel value. For example, the pixel values of pixel 732 and pixel 734 may be calculated as:
current[0][0]＝112*0.75098+722*(1-0.75098)＝112
current[1][2]＝248*0.937255+57*(1-0.937255)＝236
note that since the pixel value is an integer value, the calculated pixel value may be rounded or truncated—in the example above, the calculated value is rounded to the nearest integer.
The baseline weights (weights) may be provided as a configuration to the encoder and decoder. Baseline weights (weights) may be set in the encoder and decoder. Alternatively, the baseline weights (weights) may be provided by the encoder to the decoder in the encoded bitstream. The encoder may encode an index of the baseline weight to be used by the decoder.
Referring again to the weighting scheme 0.75,0.6,0.5,0.25, the encoder can indicate with 2 bits which baseline weights are to be used. That is, the encoder may indicate the index of the weight according to the weighting scheme. Bit 00 may be encoded in the encoded bitstream to indicate a baseline weight of 0.75; and bit 10 may be encoded to indicate that a 0.5 baseline weight is to be used. The baseline weight (weight) may indicate that the baseline weight is to be used for the first predictor block. Thus, the decoder may determine that baseline weights (1-weight) are to be used for the second predictor block. Thus, the baseline weights represent masks of the first baseline weight and the second baseline weight, i.e., masks { weight, (1-weight) }. Alternatively, the baseline weights may be encoded (instead of the index). For example, the weights may be coarsely transmitted in the bit stream and may take several different values based on the coarse transmission.
In a second example, the smoothness of each predictor block around each pixel of the predictor block may be used to determine a weighting or adjust the baseline weight. Thus, the characteristic for adjusting the weighting may be a first smoothness with respect to a first pixel of the first predictor block and a second smoothness with respect to a second co-located pixel of the second predictor block.
The smoothness around the pixel may be indicative of noise around the pixel. For example, the higher the smoothness, the lower the noise; and the lower the smoothness, the higher the noise. The previous predictor block may have a higher weight if the local smoothness around the pixel location of one predictor block is higher than the local smoothness at the same pixel location of the other predictor block. Or when baseline weights are used, the baseline weights of the smoother predictor pixels can be adjusted or scaled upward. The smoothness at the pixel location can be determined by examining surrounding pixels. For example, smoothness at pixel locations may be determined using, for example, a 3 x 3 window centered at the pixel location. Any window size may be used. The statistics (e.g., range, standard deviation, etc.) of the 3 x 3 windows around the pixel may be used to determine the smoothness around the pixel. Other methods for determining smoothness may be used. The relative values of the first smoothness and the second smoothness may be used to adjust the baseline weights of the predictor block. For example, equation 3 may be used to adjust the baseline weight:
in equation 3, the modified 1[ r ] [ c ], smoothness1[ r ] [ c ], modulated2[ r ] [ c ], and smoothness2[ r ] [ c ] are the adjusted weight of the baseline weight (weight) of the first pixel at the position (r, c) of the first predictor block, the smoothness at the first pixel position, the adjusted weight of the second pixel at the position (r, c) of the second predictor block, and the smoothness at the second pixel position, respectively. weight is the baseline weight used with the first predictor block and (1-weight) is the baseline weight used with the second predictor block.
As described with reference to fig. 7, baseline weights may be conveyed in the encoded bitstream. The baseline weights may be selected according to a weighting scheme. As described with reference to fig. 7, the adjustment direction may also be encoded by an encoder and decoded and used by a decoder. As described with reference to fig. 7, the complementary mask indicator may also be encoded by an encoder and decoded and used by a decoder.
In a third example, the peak pixel value(s) of each predictor block may be used to determine an adjustment value. In an example, the encoder may send one peak for each predictor block of the composite prediction. The peaks may be encoded by the encoder using low precision (i.e., a rough approximation of the peaks). For example, the peaks may be gray scale pixel values, each of which may be transmitted with a small number of bits (e.g., 2 or 3 bits). Embodiments may be useful when one color predicts better than the other based on the predictor block. For a predictor block, predictor block pixels that are closer in value to the peak may be weighted more than predictor block pixels that are farther in value from the peak.
The adjusted weights for the pixel locations of the predictor block may be obtained by a function having a maximum value when the pixel value is equal to or approximately the peak value and decaying as the difference between the pixel value and the peak pixel value increases. If the first pixel value of the first predictor block is closer (i.e., approximately equal in value) to the peak pixel value of the first predictor block than the co-located second pixel value of the second predictor block, then the first predictor may be assumed to be a more accurate predictor for the pixels of the current block than the second predictor block.
The relative weighting of the adjusted weights may be used to obtain a final weighting for determining the values of the pixels of the composite predictor block using equation (4):
in equation (4), w1 and w2 are adjusted baseline weights determined using the described decay function, p1[ r ] [ c ] and p2[ r ] c ] are pixel values at the locations (r, c) of the first predictor block and the second predictor block, respectively, and current [ r ] [ c ] is the pixel (i.e., the pixel to be predicted) at the location (r, c) of the composite predictor block.
As described above, process 600 may include decoding the baseline weights such that the weights may be further based on the baseline weights. The baseline weight may indicate a mask that includes the first baseline weight and the second baseline weight. The first baseline weight may be used with a first prediction block and the second baseline weight may be used with a second prediction block. The baseline weights may indicate weights from a weighting scheme that includes weights 0.75, 0.6, 0.5, and 0.25. As described above, the weighting may be adjusted based on characteristics of the first pixel of the first prediction block and the co-located second pixel of the second prediction block. The characteristic may be a difference between a first pixel of the first prediction block and a second pixel of the second prediction block. The characteristic may be a first smoothness with respect to the first pixel and a second smoothness with respect to the second pixel. Further, as described above, process 600 may decode the complementary mask indicator and, based on the complementary mask indicator, may use the first baseline weight with the second predicted block and use the second baseline weight with the first predicted block.
As described above, process 600 may decode an adjustment direction having an upward value or a downward value. When the adjustment direction is an upward value, the first baseline weight is adjusted upward as the difference increases. When the adjustment direction is a decreasing value, the second baseline weight is adjusted downward as the difference increases.
In an implementation, determining the pixel values of the pixels of the current pixel block based on the weighting based on the pixel values of the first prediction block and the pixel values of the second prediction block may include: a first peak of the first prediction block is identified, a first weight of a first pixel of the first prediction block is determined, and a pixel value is determined based at least on the first weight and the first pixel.
Fig. 8 is a flowchart of a process 800 for complex prediction using a first predictor block and a second predictor block to predict a current pixel block in accordance with an implementation of the present disclosure. Process 800 may be implemented in an encoder, such as encoder 400.
Process 800 may be implemented as, for example, a software program that may be executed by a computing device such as sending station 102. The software program may include machine readable instructions that may be stored in a memory, such as memory 204 or secondary storage 214, and may be executed by a processor, such as CPU 202, to cause the computing device to perform process 800. In at least some implementations, the process 800 may be performed in whole or in part by the intra/inter prediction stage 402 of the encoder 400.
Process 800 may be implemented using dedicated hardware or firmware. Some computing devices may have multiple memories, multiple processors, or both. Different processors, memories, or both may be used to distribute the steps or operations of process 800. The term "processor" or "memory" in the singular encompasses a computing device having one processor or one memory as well as a device having multiple processors or multiple memories that may be used to perform some or all of the described steps.
The process 800 may receive or determine a first predictor block and a second predictor block. Any number of predictor blocks may be used, not just the first predictor block and the second predictor block.
At 802, process 800 encodes baseline weights. The baseline weights may be decoded and used by a decoder for generating a composite predictor pixel block by weighting the first predictor block and the second predictor block. At 804, process 800 encodes a peak of the first predictor block. The peak value and the first pixel value of the first predictor block are used to adjust a baseline weight of co-located pixel values of the composite predictor pixel block. The peaks are as described above with reference to the third example.
Process 800 may also include encoding the direction of adjustment of the baseline weights. Process 800 may also include encoding an indication of use of the complementary mask. In response to the indication being the first value, the decoder uses the first baseline weight with the first predictor block and uses the second baseline weight used with the second predictor block. In response to the indication being the second value, the decoder uses the first baseline weight with the second predictor block and uses the first baseline weight for use with the second predictor block, and wherein the sum of the first baseline weight and the second baseline weight is one (1). The adjustment direction and the indication of the use of the complementary mask are as described above with reference to fig. 7.
Fig. 9 is a flowchart of a process 900 for generating a composite predictor block for a current block of video according to a second implementation of the present disclosure. Process 900 may be implemented in an encoder, such as encoder 400, or a decoder, such as decoder 500.
Process 900 may be implemented as, for example, a software program that may be executed by a computing device such as sending station 102. The software program may include machine readable instructions that may be stored in a memory, such as memory 204 or secondary storage 214, and which may be executed by a processor, such as CPU 202, to cause the computing device to perform process 900. In at least some implementations, the process 900 may be performed in whole or in part by the intra/inter prediction stage 402 of the encoder 400.
Process 900 may be performed by a decoder, such as decoder 500. Process 900 may be implemented as, for example, a software program that may be executed by a computing device such as receiving station 106. The process 900 may be performed in whole or in part by the intra/inter prediction stage 508 of the decoder 500. For example, an implementation of process 900 may be performed by storing instructions in a memory, such as memory 204 of receiving station 106, for execution by a processor, such as CPU 202.
Process 900 may be implemented using dedicated hardware or firmware. Some computing devices may have multiple memories, multiple processors, or both. Different processors, memories, or both may be used to distribute the steps or operations of process 900. The term "processor" or "memory" in the singular includes computing devices having one processor or one memory available for performing some or all of the described steps as well as devices having multiple processors or multiple memories.
At 902, process 900 generates a predictor block for a current block that includes a first predictor block for a first predictor pixel. The predictor block may be generated as described above with reference to process 600. At 904, process 900 determines, for a first predictor pixel of the first predictor pixels and using at least a subset of the first predictor pixels, a first adjustment value for adjusting a first weight to be applied to the first predictor pixel. At 906, process 900 generates a composite predictor block using the first predictor pixel, the first weight, and the first adjustment value.
The first weight may be selected from a weighting scheme comprising weights 0.75, 0.6, 0.5 and 0.25. Other weights are also possible. When implemented by an encoder, the process 900 may encode the first weights in an encoded bitstream, such as the compressed bitstream 420 of fig. 4. When implemented by a decoder, the process 900 may decode the first weights from an encoded bitstream, such as the compressed bitstream 420 of fig. 5. The process 900 may code (i.e., encode when implemented by an encoder and decode when implemented by a decoder) the first weights by encoding the indices of the weight masks. The process 900 may code the first weight by encoding a coarse value of the first weight.
In an example, the predictor block includes a second predictor block of a second predictor pixel. Generating the composite predictor block using the first predictor pixel and the first adjustment value may include using a second adjustment value for a second predictor pixel of the second predictor pixels for adjusting a complement of the first weight. The second adjustment value may be determined using at least a subset of the second predictor pixels. In an example, the first adjustment value may be determined based on a difference between the first predictor pixel and the second predictor pixel. In an example, the first adjustment value may be determined using smoothness in a window around the first predicted pixel. The window may be a window centered around the first predicted pixel and a window size of 3 x 3.
In an example, the first adjustment value may be determined using an decay function having a maximum value at a predetermined pixel value of the first predictor block. The first predicted pixel may be input to the decay function to determine a first adjustment value.
Fig. 10 is a flow chart of a process 1000 for generating a composite predictor block according to a third implementation of the present disclosure. Process 1000 may be implemented by an encoder or decoder as described with reference to process 900. Process 1000 may be implemented as a software program as described with reference to process 900. Process 1000 may be implemented using dedicated hardware or firmware as described with reference to process 900.
At 1002, process 1000 generates a first predictor block and a second predictor block. The first predictor block includes first predictor pixels. The second predictor block includes second predictor pixels. At 1004, process 1000 determines a respective first adjustment value for a respective first predictor pixel of a first predictor block. Each first adjustment value is determined using at least some of the first predictor pixels. At 1006, process 1000 determines a respective second adjustment value for a respective second pixel of a second predictor block. Each second adjustment value is determined using at least some of the second predictor pixels. At 1008, process 1000 uses the first predictor pixel, the first adjustment value, the second predictor pixel, and the second adjustment value to determine a pixel value for a pixel of the composite predictor block.
In the example of process 1000, the first adjustment value of the first predictor pixel and the second adjustment value of the second predictor pixel may be based on characteristics of the first predictor pixel and the second predictor pixel. The first predictor pixel and the second predictor pixel are located in a common location. In an example, the characteristic may be a difference between the first predictor pixel and the second predictor pixel. The difference may be an absolute difference. In an example, the characteristic may be a first smoothness with respect to a first predictor pixel and a second smoothness with respect to a second predictor pixel. In one example, more than one characteristic may be combined. For example, the mask weights may be adjusted based on any combination of pixel differences, smoothness, peaks, or any other characteristics.
In an example, process 1000 may decode baseline weights from the encoded bitstream. The baseline weight may indicate a mask that includes the first baseline weight and a complement of the first baseline weight. In an example, each first adjustment value may be used to adjust a first baseline weight, and each second adjustment value may be used to adjust a complement of the first baseline weight. The baseline weights may indicate weights from a weighting scheme that includes weights 0.75, 0.6, 0.5, and 0.25.
In one example, process 1000, when implemented by a decoder, includes decoding the complementary mask indicator. Based on the complementary mask indicator, process 1000 may adjust the complement of the first baseline weight using each first adjustment value and adjust the first baseline weight using each second adjustment value.
In an example, process 1000 may include selecting a first baseline weight and a complement of the first baseline weight. Each first adjustment value may be used to adjust a first baseline weight and each second adjustment value may be used to adjust a complement of the first baseline weight. Process 1000 may also include selecting an adjustment direction having an up value or a down value. When the adjustment direction is an upward value, the first baseline weight is adjusted upward as the characteristic increases. When the adjustment direction is a decreasing value, the first baseline weight is adjusted downward as the characteristic increases.
Fig. 11 is a flow chart of a process 1100 for decoding a current block according to a second implementation of the present disclosure. The process 1100 generates a composite prediction block for the current block.
Process 1100 may be performed by a decoder, such as decoder 500. Process 1100 may be implemented as, for example, a software program that may be executed by a computing device such as receiving station 106. Process 1100 may be performed in whole or in part by intra/inter prediction stage 508 of decoder 500. For example, an implementation of process 1100 may be performed by a processor, such as CPU 202, by storing instructions in a memory, such as memory 204 of receiving station 106.
Process 1100 may be implemented using dedicated hardware or firmware. Some computing devices may have multiple memories, multiple processors, or both. Different processors, memories, or both may be used to distribute the steps or operations of process 1100. The term "processor" or "memory" in the singular encompasses a computing device having one processor or one memory as well as a device having multiple processors or multiple memories that may be used to perform some or all of the described steps.
At 1102, the process 1100 generates a first predictor block and a second predictor block. At 1104, process 1100 decodes the weight mask from an encoded bitstream, such as compressed bitstream 420 of fig. 5. At 1106, process 1100 determines from the weight mask a baseline weight for a first weight of pixels of the first predictor block and a complementary baseline weight for a second weight of pixels of the second predictor block. At 1108, process 1100 determines, for a first predictor pixel of the first predictor block, a first adjustment value using at least some pixels of the first predictor block. The first adjustment value may be used to adjust the baseline weight. At 1110, process 1100 determines, for a second predictor pixel of a second predictor block, a second adjustment value using at least some pixels of the second predictor block. The second adjustment value may be used to adjust the complementary baseline weight. The second predictor pixel is co-located with the first pixel predictor. At 1112, process 1100 generates a composite predictor that includes a third predictor pixel using the first predictor pixel, the second predictor pixel, the baseline weight, the complementary baseline weight, the first adjustment value, and the second adjustment value.
In an example, where the baseline weight has a first value and the complementary baseline weight has a second value, process 1100 may include decoding an indication that the complementary mask is used, and in response to the indication that the complementary mask is used being the first value, using the second value as the value of the baseline weight and using the first value as the complementary baseline weight, and the first value and the second value adding up to 1.
The above-described encoding and decoding aspects illustrate some encoding and decoding techniques. It should be understood, however, that encoding and decoding, as those terms are used in the claims, may refer to compression, decompression, transformation, or any other processing or change to data.
The word "exemplary" or "implementation" is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as "example" or "implementation" is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather, use of the word "example" or "implementation" is intended to present concepts in a concrete fashion. As used in this disclosure, the term "or" is intended to mean an inclusive "or" rather than an exclusive "or". That is, unless otherwise indicated or clear from the context, "X includes a or B" is intended to mean any natural inclusive permutation. That is, if X includes A; x comprises B; or X comprises a and B, then "X comprises a or B" is satisfied in any of the foregoing examples. In addition, the articles "a" and "an" as used in this application and the appended claims should generally be construed to mean "one or more" to refer to the singular form unless otherwise specified or clear from context. Furthermore, the use of the terms "implementation" or "one implementation" throughout are not intended to denote the same embodiment or implementation, unless so described.
The implementations of the sending station 102 and/or the receiving station 106 (and the algorithms, methods, instructions, etc., stored thereon and/or executed by the same, including by the encoder 400 and decoder 500) may be implemented in hardware, software, or any combination thereof. The hardware may include, for example, a computer, an Intellectual Property (IP) core, an Application Specific Integrated Circuit (ASIC), a programmable logic array, an optical processor, a programmable logic controller, microcode, a microcontroller, a server, a microprocessor, a digital signal processor, or any other suitable circuit. In the claims, the term "processor" should be understood to include any of the foregoing hardware, alone or in combination. The terms "signal" and "data" are used interchangeably. Furthermore, portions of the sending station 102 and the receiving station 106 need not necessarily be implemented in the same manner.
Furthermore, in one aspect, for example, the sending station 102 or the receiving station 106 may be implemented using a general-purpose computer or general-purpose processor with a computer program that, when executed, performs any of the corresponding methods, algorithms, and/or instructions described herein. Additionally or alternatively, for example, a special purpose computer/processor may be used that may include other hardware for performing any of the methods, algorithms, or instructions described herein.
The sending station 102 and the receiving station 106 may be implemented, for example, on computers in a video conferencing system. Alternatively, the sending station 102 may be implemented on a server and the receiving station 106 may be implemented on a device separate from the server, such as a handheld communication device. In this example, transmitting station 102 may encode content into an encoded video signal using encoder 400 and transmit the encoded video signal to a communication device. The communication device may then use the decoder 500 to decode the encoded video signal. Alternatively, the communication device may decode content stored locally on the communication device, e.g., content that was not transmitted by the transmitting station 102. Other suitable transmitting station 102 and receiving station 106 implementations are available. For example, the receiving station 106 may be a generally stationary personal computer rather than a portable communication device, and/or a device including the encoder 400 may also include the decoder 500.
Furthermore, all or part of the implementations of the disclosure may take the form of a computer program product accessible from a tangible computer-usable or computer-readable medium. A computer-usable or computer-readable medium may be any apparatus that can, for example, tangibly include, store, communicate, or transport a program for use by or in connection with any processor. The medium may be, for example, an electronic, magnetic, optical, electromagnetic or semiconductor device. Other suitable media are also available.
The foregoing embodiments, implementations and aspects have been described to ensure that the disclosure is readily understood and not to be limited by the disclosure. On the contrary, the disclosure is intended to cover various modifications and equivalent arrangements included within the scope of the appended claims, which scope is to be accorded the broadest interpretation so as to encompass all such modifications and equivalent structures as is permitted under the law.
Claims (20)
1. A method for generating a composite predictor block for a current block of video, comprising:
generating a first predictor block for the current block using one of inter prediction or intra prediction,
wherein the first predictor block comprises a first pixel in the first predictor block at a position (r, c), wherein r indicates a row number, c indicates a column number,
wherein the first predictor block comprises a respective first predicted pixel for each pixel of the current block, and
wherein the first predictor block is different from the current block;
generating a second predictor block for the current block comprising a second pixel co-located with the first pixel, the second pixel being located in the second predictor block at the location (r, c),
wherein the second predictor block includes a respective second predicted pixel for each pixel of the current block, and
Wherein the second predictor block is different from the first predictor block and different from the current block;
determining a first weight for the first pixel using a difference between a value of the first pixel and a value of the second pixel;
determining a second weight for the second pixel using the first weight; and
the method further includes generating the composite predictor block by combining the first predictor block and the second predictor block, wherein the composite predictor block includes weighted pixels determined using a weighted sum of the first pixel and the second pixel using the first weight and the second weight.
2. The method of claim 1, wherein the first weight is determined by steps comprising multiplying an absolute value of the difference by a first constant to obtain a result and adding a second constant to the result.
3. The method of claim 2, wherein the first constant is calculated as a ratio having a numerator obtained using a baseline weight and a denominator obtained using a highest possible pixel value.
4. A method according to claim 3, wherein the second constant is equal to the baseline weight.
5. The method of claim 1, wherein the second weight is determined as 1 minus the first weight.
6. The method of claim 1, further comprising:
decoding from the compressed bitstream indicates that the prediction mode of the composite predictor block is obtained using the difference.
7. The method of claim 1, further comprising:
a prediction mode indicating that the composite predictor block was obtained using the difference is encoded in a compressed bitstream.
8. An apparatus for generating a composite predictor block for a current block, comprising:
a processor configured to:
a first predictor block is generated for the current block,
wherein the first predictor block comprises a first pixel in the first predictor block at a position (r, c), wherein r indicates a row number, c indicates a column number,
wherein the first predictor block comprises a respective first predicted pixel for each pixel of the current block, and
wherein the first predictor block is different from the current block;
a second predictor block is generated for the current block,
wherein the second predictor block comprises a second pixel co-located with the first pixel, the second pixel being located in the second predictor block at the location (r, c),
Wherein the second predictor block includes a respective second predicted pixel for each pixel of the current block, and
wherein the second predictor block is different from the first predictor block and different from the current block;
determining a first weight for the first pixel using a difference between a value of the first pixel and a value of the second pixel;
determining a second weight for the second pixel using the first weight; and
the method further includes generating the composite predictor block by combining the first predictor block and the second predictor block, wherein the composite predictor block includes weighted pixels determined using a weighted sum of the first pixel and the second pixel using the first weight and the second weight, respectively.
9. The apparatus of claim 8, wherein the first weight is determined by steps comprising multiplying an absolute value of the difference by a first constant to obtain a result and adding a second constant to the result.
10. The apparatus of claim 9, wherein the first constant is calculated as a ratio having a numerator obtained using a baseline weight and a denominator obtained using a highest possible pixel value.
11. The apparatus of claim 10, wherein the second constant is equal to the baseline weight.
12. The apparatus of claim 8, wherein the second weight is determined as 1 minus the first weight.
13. The apparatus of claim 8, wherein the processor is further configured to:
decoding from the compressed bitstream indicates that the prediction mode of the composite predictor block is obtained using the difference.
14. The apparatus of claim 8, wherein the processor is further configured to:
a prediction mode indicating that the composite predictor block was obtained using the difference is encoded in a compressed bitstream.
15. A non-transitory computer-readable storage medium comprising executable instructions that, when executed by a processor, facilitate performance of operations comprising:
generating a first predictor block for a current block, wherein the first predictor block is generated using one of inter-prediction or intra-prediction, and wherein the first predictor block comprises a first pixel in the first predictor block located at a position (r, c), wherein r indicates a row number and c indicates a column number, and wherein the first predictor block is different from the current block;
Generating a second predictor block for the current block, wherein the second predictor block comprises a second pixel co-located with the first pixel, the second pixel being located in the second predictor block at the location (r, c), and wherein the second predictor block is different from the first predictor block and from the current block;
determining a first weight for the first pixel using a difference between a value of the first pixel and a value of the second pixel;
determining a second weight for the second pixel using the first weight; and
a composite predictor block is generated by combining the first predictor block and the second predictor block, wherein the composite predictor block comprises weighted pixels determined using a weighted sum of the first pixel and the second pixel, respectively, using the first weight and the second weight.
16. The non-transitory computer-readable storage medium of claim 15, wherein the first weight is determined by including the steps of multiplying an absolute value of the difference by a first constant to obtain a result and adding a second constant to the result.
17. The non-transitory computer-readable storage medium of claim 16, wherein the first constant is calculated as a ratio having a numerator obtained using a baseline weight and a denominator obtained using a highest possible pixel value.
18. The non-transitory computer-readable storage medium of claim 17, wherein the second constant is equal to the baseline weight.
19. The non-transitory computer-readable storage medium of claim 17, wherein the baseline weights are obtained from a weighting scheme comprising weights 0.75, 0.6, 0.5, and 0.25.
20. The non-transitory computer-readable storage medium of claim 15, further comprising:
decoding from the compressed bitstream indicates that the prediction mode of the composite predictor block is obtained using the difference.
Applications Claiming Priority (4)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201762445999P | 2017-01-13 | 2017-01-13 | |
US62/445,999 | 2017-01-13 | ||
PCT/US2017/059266 WO2018132150A1 (en) | 2017-01-13 | 2017-10-31 | Compound prediction for video coding |
CN201780082759.0A CN110169059B (en) | 2017-01-13 | 2017-10-31 | Composite Prediction for Video Coding |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201780082759.0A Division CN110169059B (en) | 2017-01-13 | 2017-10-31 | Composite Prediction for Video Coding |
Publications (1)
Publication Number | Publication Date |
---|---|
CN117061736A true CN117061736A (en) | 2023-11-14 |
Family
ID=60473611
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202311027430.8A Pending CN117061736A (en) | 2017-01-13 | 2017-10-31 | Composite prediction for video coding |
CN201780082759.0A Active CN110169059B (en) | 2017-01-13 | 2017-10-31 | Composite Prediction for Video Coding |
Family Applications After (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201780082759.0A Active CN110169059B (en) | 2017-01-13 | 2017-10-31 | Composite Prediction for Video Coding |
Country Status (4)
Country | Link |
---|---|
US (3) | US10827196B2 (en) |
EP (1) | EP3568978A1 (en) |
CN (2) | CN117061736A (en) |
WO (1) | WO2018132150A1 (en) |
Families Citing this family (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2018132150A1 (en) * | 2017-01-13 | 2018-07-19 | Google Llc | Compound prediction for video coding |
US10419771B2 (en) * | 2017-02-08 | 2019-09-17 | Zpeg, Inc. | Method and system for improved image compression |
US11818383B2 (en) * | 2018-10-10 | 2023-11-14 | Hfi Innovation Inc. | Methods and apparatuses of combining multiple predictors for block prediction in video coding systems |
CN113875251B (en) * | 2019-06-21 | 2023-11-28 | 华为技术有限公司 | Adaptive filter strength indication for geometric segmentation mode |
US11979587B2 (en) | 2022-10-05 | 2024-05-07 | Synaptics Incorporated | Hybrid inter-frame coding using an autoregressive model |
Family Cites Families (30)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JPH09116900A (en) * | 1995-10-20 | 1997-05-02 | Sharp Corp | Encoding noise removal device |
US6816552B2 (en) | 2001-07-11 | 2004-11-09 | Dolby Laboratories Licensing Corporation | Interpolation of video compression frames |
US7266150B2 (en) | 2001-07-11 | 2007-09-04 | Dolby Laboratories, Inc. | Interpolation of video compression frames |
TR201802625T4 (en) | 2001-11-06 | 2018-03-21 | Panasonic Ip Corp America | Motion picture coding method and motion picture decoding method. |
CN101448162B (en) * | 2001-12-17 | 2013-01-02 | 微软公司 | Method for processing video image |
US8406301B2 (en) | 2002-07-15 | 2013-03-26 | Thomson Licensing | Adaptive weighting of reference pictures in video encoding |
US7903742B2 (en) | 2002-07-15 | 2011-03-08 | Thomson Licensing | Adaptive weighting of reference pictures in video decoding |
EP2320659B1 (en) | 2002-08-08 | 2014-10-01 | Panasonic Intellectual Property Corporation of America | Moving picture encoding method and decoding method |
KR100506864B1 (en) | 2002-10-04 | 2005-08-05 | 엘지전자 주식회사 | Method of determining motion vector |
EP1422928A3 (en) | 2002-11-22 | 2009-03-11 | Panasonic Corporation | Motion compensated interpolation of digital video signals |
KR100612849B1 (en) * | 2003-07-18 | 2006-08-14 | 삼성전자주식회사 | Apparatus and method for encoding and decoding image |
EP1732643B1 (en) * | 2004-04-07 | 2013-02-27 | Cardiac Pacemakers, Inc. | System and method for rf transceiver duty cycling in an implantable medical device |
WO2005109896A2 (en) | 2004-05-04 | 2005-11-17 | Qualcomm Incorporated | Method and apparatus to construct bi-directional predicted frames for temporal scalability |
CA2655970A1 (en) * | 2006-07-07 | 2008-01-10 | Telefonaktiebolaget L M Ericsson (Publ) | Video data management |
JP5271271B2 (en) * | 2006-11-03 | 2013-08-21 | サムスン エレクトロニクス カンパニー リミテッド | Video encoding / decoding method and apparatus using motion vector tracking |
KR101403341B1 (en) * | 2007-03-28 | 2014-06-09 | 삼성전자주식회사 | Method and apparatus for video encoding and decoding |
EP2243297B1 (en) | 2008-02-05 | 2017-03-08 | Thomson Licensing | Methods and apparatus for implicit block segmentation in video encoding and decoding |
KR20090095012A (en) | 2008-03-04 | 2009-09-09 | 삼성전자주식회사 | Method and apparatus for encoding and decoding image using consecutive motion estimation |
US8565554B2 (en) * | 2010-01-09 | 2013-10-22 | Microsoft Corporation | Resizing of digital images |
PL2996335T3 (en) * | 2010-09-30 | 2018-02-28 | Samsung Electronics Co., Ltd. | Method for interpolating images by using a smoothing interpolation filter |
KR20120140181A (en) * | 2011-06-20 | 2012-12-28 | 한국전자통신연구원 | Method and apparatus for encoding and decoding using filtering for prediction block boundary |
WO2013106482A1 (en) * | 2012-01-09 | 2013-07-18 | Huawei Technologies Co., Ltd. | Quantization matrix (qm) coding based on weighted prediction |
US20130188736A1 (en) * | 2012-01-19 | 2013-07-25 | Sharp Laboratories Of America, Inc. | High throughput significance map processing for cabac in hevc |
JP6135937B2 (en) * | 2013-08-28 | 2017-05-31 | パナソニックＩｐマネジメント株式会社 | Image processing method and image processing apparatus |
US9609343B1 (en) * | 2013-12-20 | 2017-03-28 | Google Inc. | Video coding using compound prediction |
KR20170084055A (en) * | 2014-11-06 | 2017-07-19 | 삼성전자주식회사 | Video encoding method and apparatus, video decoding method and apparatus |
CN104992419A (en) * | 2015-07-08 | 2015-10-21 | 北京大学深圳研究生院 | Super pixel Gaussian filtering pre-processing method based on JND factor |
US10404989B2 (en) * | 2016-04-26 | 2019-09-03 | Google Llc | Hybrid prediction modes for video coding |
US10116957B2 (en) * | 2016-09-15 | 2018-10-30 | Google Inc. | Dual filter type for motion compensated prediction in video coding |
WO2018132150A1 (en) * | 2017-01-13 | 2018-07-19 | Google Llc | Compound prediction for video coding |
-
2017
- 2017-10-31 WO PCT/US2017/059266 patent/WO2018132150A1/en unknown
- 2017-10-31 CN CN202311027430.8A patent/CN117061736A/en active Pending
- 2017-10-31 EP EP17804705.6A patent/EP3568978A1/en active Pending
- 2017-10-31 CN CN201780082759.0A patent/CN110169059B/en active Active
- 2017-11-09 US US15/807,653 patent/US10827196B2/en active Active
-
2020
- 2020-10-19 US US17/073,892 patent/US11343528B2/en active Active
-
2022
- 2022-04-28 US US17/731,470 patent/US20220256186A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
US20220256186A1 (en) | 2022-08-11 |
US10827196B2 (en) | 2020-11-03 |
CN110169059A (en) | 2019-08-23 |
EP3568978A1 (en) | 2019-11-20 |
US11343528B2 (en) | 2022-05-24 |
US20180205964A1 (en) | 2018-07-19 |
US20210037254A1 (en) | 2021-02-04 |
CN110169059B (en) | 2023-08-22 |
WO2018132150A1 (en) | 2018-07-19 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9866863B1 (en) | Affine motion prediction in video coding | |
US10142652B2 (en) | Entropy coding motion vector residuals obtained using reference motion vectors | |
US10555000B2 (en) | Multi-level compound prediction | |
CN110169059B (en) | Composite Prediction for Video Coding | |
CN107027032B (en) | Method and device for partitioning motion vector of last frame | |
US10142628B1 (en) | Hybrid transform in video codecs | |
CN110169068B (en) | DC coefficient sign coding scheme | |
US10277905B2 (en) | Transform selection for non-baseband signal coding | |
US9674530B1 (en) | Hybrid transforms in video coding | |
CN110741641B (en) | Method and apparatus for video compression | |
US11917156B2 (en) | Adaptation of scan order for entropy coding | |
US10419777B2 (en) | Non-causal overlapped block prediction in variable block size video coding | |
US9967558B1 (en) | Adaptive motion search control for variable block size partitions in video coding | |
CN110741636B (en) | Transform block level scan order selection for video coding | |
US11405653B2 (en) | Restoration in video coding using filtering and subspace projection | |
CN110692247B (en) | Prediction for composite motion compensation |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |