US20180329785A1 - File system storage in cloud using data and metadata merkle trees - Google Patents
File system storage in cloud using data and metadata merkle trees Download PDFInfo
- Publication number
- US20180329785A1 US20180329785A1 US15/591,131 US201715591131A US2018329785A1 US 20180329785 A1 US20180329785 A1 US 20180329785A1 US 201715591131 A US201715591131 A US 201715591131A US 2018329785 A1 US2018329785 A1 US 2018329785A1
- Authority
- US
- United States
- Prior art keywords
- tree
- merkle
- file
- mtk
- merkle tree
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/07—Responding to the occurrence of a fault, e.g. fault tolerance
- G06F11/14—Error detection or correction of the data by redundancy in operation
- G06F11/1402—Saving, restoring, recovering or retrying
- G06F11/1446—Point-in-time backing up or restoration of persistent data
- G06F11/1458—Management of the backup or restore process
- G06F11/1464—Management of the backup or restore process for networked environments
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/07—Responding to the occurrence of a fault, e.g. fault tolerance
- G06F11/14—Error detection or correction of the data by redundancy in operation
- G06F11/1402—Saving, restoring, recovering or retrying
- G06F11/1446—Point-in-time backing up or restoration of persistent data
- G06F11/1448—Management of the data involved in backup or backup restore
- G06F11/1451—Management of the data involved in backup or backup restore by selection of backup contents
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/07—Responding to the occurrence of a fault, e.g. fault tolerance
- G06F11/14—Error detection or correction of the data by redundancy in operation
- G06F11/1402—Saving, restoring, recovering or retrying
- G06F11/1446—Point-in-time backing up or restoration of persistent data
- G06F11/1448—Management of the data involved in backup or backup restore
- G06F11/1453—Management of the data involved in backup or backup restore using de-duplication of the data
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2201/00—Indexing scheme relating to error detection, to error correction, and to monitoring
- G06F2201/80—Database-specific techniques
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2201/00—Indexing scheme relating to error detection, to error correction, and to monitoring
- G06F2201/84—Using snapshots, i.e. a logical point-in-time copy of the data
Definitions
- the present invention relates generally to data storage, and particularly to methods and systems for file-system management using Merkle trees.
- a Merkle tree is a tree data structure, in which nodes are labeled with checksums, e.g., hash values, of the labels or values of their child nodes. Merkle trees are used, for example, in various data storage systems for efficient data storage management.
- U.S. Pat. No. 8,706,701 whose disclosure is incorporated herein by reference, describes an authenticated file system that provides integrity and freshness of both data and metadata.
- Example embodiments rely on a balanced, Merkle-tree-based data structure that authenticates the file system directory tree and supports updates caused by file system operations.
- U.S. Patent Application Publication 2016/0110261 whose disclosure is incorporated herein by reference, describes cloud storage schemes using Merkle trees.
- Exemplary methods include storing a data stream on a client side de-duplicating block store of a client device, generating a data stream Merkle tree of the data stream, storing a secure hash algorithm key for the data stream Merkle tree, as well as the data stream Merkle tree on the client side de-duplicating block store, recursively iterating through the data stream Merkle tree using an index of a snapshot Merkle tree of the client device that is stored on a cloud data center to determine missing Merkle nodes or missing data blocks which are present in the data stream Merkle tree but not present in the snapshot Merkle tree stored on the cloud data center, and transmitting the missing data blocks to the cloud data center.
- An embodiment of the present invention that is described herein provides a data storage apparatus including an interface for communicating with a backup storage system, and one or more processors.
- the one or more processors are configured to store a local copy of at least part of a file system represented by hierarchical structure of directories and files, to store a backup copy of the at least part of the file system in the backup storage system, to store a dual Merkle tree that is calculated over the backup copy and includes (i) a metadata Merkle tree including Metadata Merkle-Tree Keys (MD-MTKs) and (ii) a data Merkle tree including Data Merkle-Tree Keys (D-MTKs), and to update the backup copy to match the local copy using the dual Merkle tree.
- MD-MTKs Metadata Merkle-Tree Keys
- D-MTKs Data Merkle-Tree Keys
- the one or more processors are configured to update the backup copy by calculating a temporary metadata Merkle tree over the local copy, and updating a sub-tree of the backup copy with a corresponding sub-tree of the local copy only if the MD-MTK of a root node of a corresponding sub-tree in the temporary metadata Merkle tree differs from the MD-MTK of a root node of the corresponding sub-tree in the dual Merkle tree.
- the one or more processors are configured to update the backup copy by scanning the temporary metadata Merkle tree in a Depth-First Search (DFS) order, updating sub-trees for which corresponding root nodes in the temporary metadata Merkle tree and the dual Merkle tree have different MD-MTKs, and refraining from updating the sub-trees for which the corresponding root nodes in the temporary metadata Merkle tree and the dual Merkle tree have matching MD-MTKs.
- DFS Depth-First Search
- the one or more processors are configured to update the backup copy by deciding, based on the temporary metadata Merkle tree, that a file is to be updated in the backup copy to match the local copy, calculating a first D-MTK over at least part of the file in the local copy, comparing the first D-MTK with a second D-MTK of the at least part of the file, which is stored in the dual Merkle tree, and updating the at least part of the file in the backup copy only if the first D-MTK does not match the second D-MTK.
- the one or more processors are configured to store the backup copy by storing at least part of a file in an object whose object name includes the D-MTK of the at least part of the file, and to update the at least part of the file by incrementing a reference count of the object.
- the one or more processors are configured to update the at least part of the file by writing content of the at least part of the file to the backup storage system only in response to a failure to increment the reference count.
- a method for data storage including storing a local copy of at least part of a file system represented by hierarchical structure of directories and files.
- a backup copy of the at least part of the file system is stored in a backup storage system.
- a dual Merkle tree which is calculated over the backup copy and includes (i) a metadata Merkle tree including Metadata Merkle-Tree Keys (MD-MTKs) and (ii) a data Merkle tree including Data Merkle-Tree Keys (D-MTKs), is stored.
- the backup copy is updated to match the local copy using the dual Merkle tree.
- a computer software product including a tangible non-transitory computer-readable medium in which program instructions are stored, which instructions, when read by one or more processors, cause the processors to store a local copy of at least part of a file system represented by hierarchical structure of directories and files, to store a backup copy of the at least part of the file system in a backup storage system, to store a dual Merkle tree that is calculated over the backup copy and includes (i) a metadata Merkle tree including Metadata Merkle-Tree Keys (MD-MTKs) and (ii) a data Merkle tree including Data Merkle-Tree Keys (D-MTKs), and to update the backup copy to match the local copy using the dual Merkle tree.
- MD-MTKs Metadata Merkle-Tree Keys
- D-MTKs Data Merkle-Tree Keys
- FIG. 1 is a block diagram that schematically illustrates a computing system, in accordance with an embodiment of the present invention
- FIG. 2 is a diagram that schematically illustrates tree data structures used in the computing system of FIG. 1 , in accordance with an embodiment of the present invention
- FIG. 3 is a flow chart that schematically illustrates a method for backing-up a file system to a cloud-based object store, in accordance with an embodiment of the present invention.
- FIG. 4 is a flow chart that schematically illustrates a method for updating a file to a cloud-based object store, in accordance with an embodiment of the present invention.
- Embodiments of the present invention that are described herein provide improved methods and systems for maintaining a backup copy of a File System (FS) in a backup storage system, e.g., a cloud-based object storage system.
- a computing system comprises multiple compute nodes that communicate over a communication network.
- one or more of the compute-node processors run a distributed FS.
- the processors store a local copy of the FS, and continually update a backup copy of the FS in the backup storage system.
- the disclosed embodiments provide a highly efficient process of updating the backup copy, using a “dual Merkle tree.”
- the dual Merkle tree comprises a metadata Merkle tree and a data Merkle tree, both calculated over the backup copy.
- the backup copy of the FS can be updated without performing search operations on the backup copy, with a minimal number of read operations from the local copy of the FS, and with a minimal amount of network traffic.
- the local copy of the FS is represented by a “FS tree”—A tree data structure representing the hierarchical structure of directories and files of the FS.
- the leaf nodes of the FS tree represent files (or empty directories), intermediate nodes represent directories, and each of the nodes holds relevant FS metadata.
- the backup copy of the FS is represented by a similar tree, having the same hierarchical structure, referred to as a “backup tree” or “cloud tree”.
- each node of the backup tree (which typically represents a file or directory) also holds a Metadata Merkle-tree Key (MD-MTK) of the metadata Merkle tree, and a Data Merkle-tree Key (D-MTK) of the data Merkle tree.
- MD-MTK Metadata Merkle-tree Key
- D-MTK Data Merkle-tree Key
- the MD-MTK of a node is calculated over (i) the metadata of the node, and (ii) the MD-MTKs of its child nodes.
- the D-MTK of a node is calculated over the entire content of the sub-tree of the node including the node itself, and including user data in files, metadata and any other content.
- the processors carry out a two-stage process of updating the backup copy of the FS to match the local copy.
- the processors create a “temporary Merkle tree,” which has the same hierarchical structure as the FS tree and the backup tree.
- Each node of the temporary Merkle tree holds a MD-MTK that is calculated over (i) the MD-MTKs of its child nodes in the temporary Merkle tree, and (ii) the metadata of the corresponding node in the FS tree.
- the processors typically create the temporary Merkle tree by scanning the FS tree in a Depth-First Search (DFS) order.
- DFS Depth-First Search
- the processors decide which sub-trees of the backup tree have changed and need to be updated by the corresponding sub-trees of the FS tree, and which sub-trees have not changed and can be skipped. For a given sub-tree, the decision is made by comparing the MD-MTKs of the root node of that sub-tree in the backup tree and in the temporary Merkle tree. Typically, the processors scan the temporary Merkle tree in DFS order and, for each traversed node, decide whether to skip or update the sub-tree of that node.
- the processors do not actually copy the entire sub-tree of the FS tree indiscriminately to the backup tree.
- the processors traverse the sub-tree and rewrite only parts of it that have changed.
- the processors compare the Data MTKs (D-MTKs) of corresponding parts (“data blobs”) of the file in the FS tree and in the backup tree. A given data blob is actually written to the backup tree only if its D-MTK in the backup tree does not match the corresponding D-MTK in the FS tree.
- the processors further reduce write operations to the cloud by using the built-in de-duplication and reference-counting features of the cloud-based object store.
- the processors store each data blob in the cloud in an object, whose name is the D-MTK of the data blob.
- the processors attempt to increment the reference count of the corresponding object. Only if the update fails, implying that no object having the same content as the data blob already exists in the backup copy, the data blob is actually written to the cloud. Otherwise, only the reference count is incremented.
- the disclosed update process is highly efficient in terms of read and write operations to the backup storage system (e.g., cloud-based object store), and in terms of communication traffic over the network between compute nodes.
- the update process typically begins by finding files and directories that are suspected as changed, using the metadata Merkle tree. Only then, those files are checked with finer resolution of data blobs for actual data changes, using the data Merkle tree. As a result, the update process is fast, low-cost and scalable.
- FIG. 1 is a block diagram that schematically illustrates a computing system 20 , in accordance with an embodiment of the present invention.
- System 20 may comprise, for example, a data center, a High-Performance Computing (HPC) system, or a computing system that performs any other suitable function.
- HPC High-Performance Computing
- System 20 comprises multiple compute nodes 24 that communicate with one another over a network 28 , in the present example a Local Area Network (LAN).
- Compute nodes 24 are referred to herein as nodes, for brevity, and may comprise, for example, servers, workstations or any other suitable type of compute node.
- Nodes 24 may communicate over network 28 in accordance with any suitable network communication protocol, such as Ethernet or Infiniband.
- System 20 may comprise any suitable number of compute nodes of any type.
- Nodes 24 may be collocated or located in multiple geographical locations. The collection of nodes 24 is also sometimes referred to as a cluster.
- each node 24 comprises a Central Processing Unit (CPU) 32 , also referred to as a processor.
- CPU Central Processing Unit
- Each node also comprises a volatile memory 36 such as Random Access Memory (RAM), and non-volatile storage 40 , also referred to simply as disk, such as one or more Solid State Drives (SSDs) or Hard Disk Drives (HDDs).
- RAM Random Access Memory
- SSDs Solid State Drives
- HDDs Hard Disk Drives
- Each node 24 further comprises a network interface 44 such as a Network Interface Controller (NIC) for communicating over network 28 .
- NIC Network Interface Controller
- VMs Virtual Machines
- the embodiments described herein refer mainly to VMs, the disclosed techniques can be used with any other suitable type of workloads, e.g., user applications, operating system processes or containers, and/or any other suitable software.
- each CPU 32 runs a respective File System (FS) module 48 that carries out various file management functions.
- the plurality of modules 48 running on CPUs 32 of nodes 24 , implement a distributed FS that manages the storage of files.
- This distributed FS typically serves the various VMs 52 using a suitable storage protocol such as Network File System (NFS) or Server Message Block (SMB).
- NFS Network File System
- SMB Server Message Block
- system 20 may run a centralized FS, e.g., on a dedicated server, instead of a distributed FS.
- computing system 20 is connected via a Wide Area Network (WAN) 60 , e.g., the Internet, to a cloud-based object storage system 64 .
- Storage system 64 serves as the persistent storage media in which the distributed FS backs-up its data and metadata, e.g., copies of files and directories.
- object storage system 64 comprises the Amazon Simple Storage Service (S 3 ). The description that follows refers simply to “S 3 ” for brevity.
- any other suitable cloud-based object storage system e.g., Google Cloud Storage or Microsoft Azure, can be used.
- system 20 and nodes 24 shown in FIG. 1 are example configurations that are chosen purely for the sake of conceptual clarity. In alternative embodiments, any other suitable system and/or node configuration can be used. For example, some or even all of the functionality of modules 48 may be implemented on one or more processors that are separate from nodes 24 .
- CPUs 32 comprise general-purpose processors, which are programmed in software to carry out the functions described herein.
- the software may be downloaded to the processors in electronic form, over a network, for example, or it may, alternatively or additionally, be provided and/or stored on non-transitory tangible media, such as magnetic, optical, or electronic memory.
- the description that follows refers to “the FS” as carrying out the various storage tasks.
- the functionality of the FS may be carried out by any one or more processors in system 20 , e.g., collectively by FS modules 48 running on CPUs 32 of nodes 24 , and/or by a processor of a dedicated centralized server.
- the description that follows refers to “the FS memory” as storing certain data structures.
- the FS memory may comprise any suitable memory space associated with compute nodes 24 , e.g., on one or more of RAM devices 36 .
- system 20 backs-up its FS to cloud-based object storage system 64 , in the present example to S 3 .
- the back-up typically comprises retaining on S 3 an updated copy of the entire hierarchical structure of the FS directories and files, including both user file data and metadata.
- the FS carries out a highly efficient process of updating the FS to S 3 , which has the following characteristics:
- FIG. 2 is a diagram that schematically illustrates three tree data structures used for representing and updating the FS of system 20 , in accordance with an embodiment of the present invention.
- the three data structures are used for representing the FS, both locally in system 20 and in the cloud (in S 3 ), and for the cloud update process.
- the description that follows refers to updating of the entire FS.
- the data structures and processes described herein can also be used for updating only selected parts of the FS, e.g., specific directories.
- FIG. 2 shows an example “FS tree” 70 , a data structure used for representing the FS locally in system 20 .
- Tree 70 is stored locally in system 20 , e.g., in a suitable location in RAM devices 36 and/or disks 40 .
- FS tree 70 comprises multiple nodes 74 , stemming from a root node (at the top) and ending with leaf nodes (at the bottom). Each leaf node represents a file or an empty directory. Each intermediate node represents a directory, which may contain one or more files and/or one or more directories.
- the root node represents the entire FS. The part of the tree that stems from a certain node is referred to as the sub-tree of that node.
- nodes 74 represent the hierarchical structure of the FS.
- node X being a child of node Y means that the file or directory represented by node X is contained in the directory represented by node Y.
- the FS tree need not necessarily be binary, need not necessarily be balanced, and need not necessarily have a uniform number of levels.
- Each node 74 in FS tree 70 stores metadata that pertains to itself and to its sub-tree.
- the metadata comprises:
- the node When a leaf node 74 of FS tree 70 represents a file, the node also comprises one or more pointers to “data blobs” that hold the actual data of the file.
- the data blobs typically comprise memory regions in the FS memory (e.g., across RAM devices 36 ).
- the node index I-NODE is omitted from the calculation of the MD-MTK. This feature is useful, for example, for efficiently creating and storing copies of FSs.
- FIG. 2 shows an example “Temporary Merkle tree” 80 , a data structure that the FS produces temporarily when backing-up the FS to S 3 .
- Tree 80 is stored locally in system 20 , e.g., in a suitable location in RAM devices 36 and/or disks 40 .
- the backup process, including generation and usage of Merkle tree 80 is described in FIGS. 3 and 4 below.
- Merkle tree 80 comprises multiple nodes 84 , and has the same hierarchical structure as FS tree 70 .
- each node 84 in tree 80 corresponds to a respective node 74 in tree 70 (and thus represents the same file or directory as its corresponding node 74 ).
- the parent-child hierarchy among nodes 84 is also the same as the hierarchy among nodes 74 .
- the FS stores the following parameters in each node 84 of Merkle tree 80 :
- the FS produces the MD-MTK of each node 84 by calculating a hash function over (i) the metadata of the corresponding node 74 of FS tree 70 , and (ii) the MD-MTKs of the child nodes of the node 84 in question. Any suitable hash function can be used for this purpose. Alternatively, the FS may produce the MD-MTK by calculating any other suitable checksum or signature.
- the checksum used for calculating the MD-MTK guarantees the following: If two nodes are found to have the same MD-MTK, then they represent identical FS sub-trees with very high likelihood. As will be explained below, this property enables the update process to skip entire FS sub-trees without scanning them.
- FIG. 2 shows an example “cloud tree” 90 , a data structure used for representing the backed-up version of the FS in S 3 .
- the cloud tree is also referred to as “backup tree,” and the two terms are used interchangeably.
- Tree 90 is stored “in the cloud,” e.g., in cloud-based object storage system 64 .
- Cloud tree 90 comprises multiple nodes 94 , and has the same hierarchical structure as FS tree 70 and temporary Merkle tree 80 .
- each node 94 in tree 90 corresponds to a respective node 74 in tree 70 , and to a respective node 84 in tree 80 (and thus also represents the same file or directory as its corresponding node 74 ).
- the parent-child hierarchy among nodes 94 is also the same as the hierarchy among nodes 74 , and among nodes 84 .
- the FS stores the following parameters in each node 94 of cloud tree 90 :
- the main difference between temporary Merkle tree 80 and backup tree 90 is that the nodes of temporary Merkle tree 80 comprise MD-MTKs and do not point to any user file data.
- the nodes comprise, in addition to the MD-MTKs, also D-MTKs that function as a pointers to user data blobs.
- the FS produces the D-MTK of each node 94 by calculating a hash function over the sub-tree of this node 94 in cloud tree 90 . Any suitable hash function can be used for this purpose. Alternatively, the FS may produce the D-MTK by calculating any other suitable checksum or signature.
- the checksum used for calculating the D-MTK guarantees the following: If two nodes are found to have the same D-MTK, then they represent identical sub-trees with very high likelihood.
- the type of checksum used for calculating the D-MTK may be the same as or different from the type of checksum used for calculating the MD-MTK.
- Cloud tree 90 is an example of a dual Merkle tree.
- the term “dual Merkle tree” refers to any suitable data structure, or multiple data structures, that hold Metadata Merkle-Tree Keys (MD-MTKs) and Data Merkle-Tree Keys (D-MTKs) calculated over metadata and data, respectively, of at least part of a file system.
- the FS may represent the dual Merkle tree in any other suitable manner.
- FIG. 3 is a flow chart that schematically illustrates a method for backing-up the FS of system 20 to S 3 , in accordance with an embodiment of the present invention. As noted above, this process may be performed by any processor or processors in system 20 . The update process may be performed periodically, or in response to some event, e.g., an administrator command.
- the method of FIG. 3 has two main stages.
- the FS scans FS tree 70 in a Depth-First Search (DFS) order and constructs temporary Merkle tree 80 .
- the FS scans temporary Merkle tree 80 in a Depth-First Search (DFS) order and updates cloud tree 90 stored in S 3 .
- DFS Depth-First Search
- the first stage (construction of temporary Merkle tree 80 based on FS tree 70 ) begins with the FS selecting the next node 74 (initially the root node) of FS tree 70 in accordance with the DFS order, at a node selection step 100 .
- the FS calculates a MD-MTK for the node 84 (in temporary Merkle tree 80 ) that corresponds to the selected node 74 .
- the MD-MTK is calculated over (i) the metadata of the selected node 74 , and (ii) the MD-MTKs of the child nodes of the corresponding node 84 .
- the FS stores the MD-MTK in the corresponding node 84 of temporary Merkle tree 80 , at a MD-MTK storage step 108 .
- the FS checks whether the entire FS tree 70 has been scanned. If not, the method loops back to step 100 above, in which the FS selects the next node 74 . Otherwise, the method proceeds to the second stage.
- the second stage (updating of cloud tree 90 in S 3 based on temporary Merkle tree 80 ) begins with the FS selecting the next node 84 (initially the root node) of temporary Merkle tree 80 in accordance with the DFS order, at a node selection step 116 .
- the FS reads the corresponding node 94 of cloud tree 90 from S 3 , at a cloud readout step 120 .
- the FS compares the MD-MTK of the currently selected node 84 of temporary Merkle tree 80 with the MD-MTK of the corresponding node 94 read from cloud tree 90 .
- the FS checks whether the two MD-MTKs are the same or not.
- the FS may conclude that the existing sub-tree of the node 94 in cloud tree 90 is identical to the sub-tree of the corresponding node 74 in FS tree 70 .
- the entire sub-tree of the corresponding node 74 of FS tree 70 does not need to be updated in the cloud and can be safely skipped.
- the FS concludes that some difference exists between the sub-tree of the node 94 in cloud tree 90 and the sub-tree of the corresponding node 74 in FS tree 70 . In the latter case, the update process should continue scanning inside this sub-tree and update the cloud tree as appropriate.
- the FS updates the sub-tree of the node 94 in cloud tree 90 with the corresponding sub-tree of FS tree 70 , at a sub-tree updating step 132 .
- the FS does not actually copy the entire sub-tree from FS tree 70 to cloud tree 90 , but only the parts of the sub-tree that have changed since the last update.
- the FS typically scans the sub-tree of temporary Merkle tree 80 using DFS, and continues to compare MD-MTKs. Any part of the sub-tree whose MD-MTK matches the corresponding MD-MTK in cloud tree 90 is skipped, and DFS scanning continues only within sub-trees whose MD-MTK does not match the corresponding MD-MTK in cloud tree 90 . This process continues until reaching a leaf node of temporary Merkle tree 80 whose MD-MTK does not match the corresponding MD-MTK in cloud tree 90 . Only at this stage, actual data has to be copied from the FS to the cloud. This selective data updating process is described in detail in FIG. 4 below. If checking step 128 concludes that the two MD-MTKs match, sub-tree updating step 132 is skipped.
- the FS checks whether the entire temporary Merkle tree 80 has been scanned. If not, the method loops back to step 116 above, in which the FS selects the next node 84 . Otherwise, the method terminates at a termination step 140 .
- FIG. 4 is a flow chart that schematically illustrates a method for updating a file from FS tree 70 to cloud tree 90 , in accordance with an embodiment of the present invention.
- the method of FIG. 4 can be used as part of sub-tree updating step 132 of FIG. 3 above.
- the method of FIG. 4 is invoked when step 132 of FIG. 3 reaches a leaf node of temporary Merkle tree 80 whose MD-MTK does not match the corresponding MD-MTK in cloud tree 90 .
- This mismatch in MD-MTK means that the file represented by the leaf node has changed since the most recent update of the FS to the cloud.
- the FS scans the data blobs of the file in question, skips any data blobs that have not changed, and copies to the cloud only data blobs that have changed.
- the FS distinguishes between data blobs that have changed and data blobs that have not changed by comparing corresponding data MTKs (D-MTKs) in FS tree 70 and cloud tree 90 .
- the method of FIG. 4 begins with the FS selecting the next data blob (initially the first data blob) of the file in question, at a data blob selection step 150 .
- the FS compares the D-MTK of the selected data blob in FS tree 70 with the D-MTK of the corresponding data blob in cloud tree 90 .
- the FS checks whether the two D-MTKs match, at a match checking step 158 .
- the FS replaces the data blob in cloud tree 90 with the corresponding (and more up-to-date) data blob of FS tree 70 .
- the replacement process in an embodiment, is illustrated by steps 162 - 170 .
- the FS stores each data blob in S 3 as an object whose name is the D-MTK of the data blob.
- data blobs having the same data may appear in different files. In such a case, the FS does not write the actual data multiple times to the cloud, but only writes the metadata of the data blob and increments the reference count (REFCNT) of the existing object.
- REFCNT reference count
- the FS attempts to update the reference count of the object (whose name is the D-MTK of the data blob of FS tree 70 ) in S 3 , at a REFCNT updating step 162 .
- the FS checks whether the REFCNT update was successful or not.
- the FS concludes that an object having the same data does not exist in the cloud. Only in this case, at an overwriting step 170 , the FS overwrites the data blob in cloud tree 90 with the actual data of the data blob of FS tree 70 . The FS performs this action by writing to S 3 a new object whose name is the D-MTK of the data blob of FS tree 70 .
- a data-blob completion checking step 174 the FS checks whether all the data blobs of the file have been checked. If not, the method loops back to step 150 above for selecting (and possibly updating) the next data blob. Otherwise, the method terminates at a termination step 178 .
- FIGS. 3 and 4 above are example flows, which are chosen purely for the sake of conceptual clarity.
- the FS of system 20 may perform back-up to the cloud, based on both MD-MTKs and D-MTKs, using any other suitable method.
- the embodiments described herein refer mainly to backup of a file system to an object-based cloud storage system
- the disclosed techniques can also be used for backup to any other backup storage system, which is not necessarily a cloud system and is not necessarily object based.
- An alternative example of a backup storage system is a LAN-based object storage system. Systems of this sort are offered, for example, by Cloudian (San Mateo, Calif.), Dell EMC (Hopkinton, Mass.), and others.
Abstract
Description
- The present invention relates generally to data storage, and particularly to methods and systems for file-system management using Merkle trees.
- A Merkle tree is a tree data structure, in which nodes are labeled with checksums, e.g., hash values, of the labels or values of their child nodes. Merkle trees are used, for example, in various data storage systems for efficient data storage management.
- For example, U.S. Pat. No. 8,706,701, whose disclosure is incorporated herein by reference, describes an authenticated file system that provides integrity and freshness of both data and metadata. Example embodiments rely on a balanced, Merkle-tree-based data structure that authenticates the file system directory tree and supports updates caused by file system operations.
- As another example, U.S. Patent Application Publication 2016/0110261, whose disclosure is incorporated herein by reference, describes cloud storage schemes using Merkle trees. Exemplary methods include storing a data stream on a client side de-duplicating block store of a client device, generating a data stream Merkle tree of the data stream, storing a secure hash algorithm key for the data stream Merkle tree, as well as the data stream Merkle tree on the client side de-duplicating block store, recursively iterating through the data stream Merkle tree using an index of a snapshot Merkle tree of the client device that is stored on a cloud data center to determine missing Merkle nodes or missing data blocks which are present in the data stream Merkle tree but not present in the snapshot Merkle tree stored on the cloud data center, and transmitting the missing data blocks to the cloud data center.
- An embodiment of the present invention that is described herein provides a data storage apparatus including an interface for communicating with a backup storage system, and one or more processors. The one or more processors are configured to store a local copy of at least part of a file system represented by hierarchical structure of directories and files, to store a backup copy of the at least part of the file system in the backup storage system, to store a dual Merkle tree that is calculated over the backup copy and includes (i) a metadata Merkle tree including Metadata Merkle-Tree Keys (MD-MTKs) and (ii) a data Merkle tree including Data Merkle-Tree Keys (D-MTKs), and to update the backup copy to match the local copy using the dual Merkle tree.
- In an embodiment, the one or more processors are configured to update the backup copy by calculating a temporary metadata Merkle tree over the local copy, and updating a sub-tree of the backup copy with a corresponding sub-tree of the local copy only if the MD-MTK of a root node of a corresponding sub-tree in the temporary metadata Merkle tree differs from the MD-MTK of a root node of the corresponding sub-tree in the dual Merkle tree.
- In an embodiment, the one or more processors are configured to update the backup copy by scanning the temporary metadata Merkle tree in a Depth-First Search (DFS) order, updating sub-trees for which corresponding root nodes in the temporary metadata Merkle tree and the dual Merkle tree have different MD-MTKs, and refraining from updating the sub-trees for which the corresponding root nodes in the temporary metadata Merkle tree and the dual Merkle tree have matching MD-MTKs.
- In an embodiment, the one or more processors are configured to update the backup copy by deciding, based on the temporary metadata Merkle tree, that a file is to be updated in the backup copy to match the local copy, calculating a first D-MTK over at least part of the file in the local copy, comparing the first D-MTK with a second D-MTK of the at least part of the file, which is stored in the dual Merkle tree, and updating the at least part of the file in the backup copy only if the first D-MTK does not match the second D-MTK.
- In some embodiments, the one or more processors are configured to store the backup copy by storing at least part of a file in an object whose object name includes the D-MTK of the at least part of the file, and to update the at least part of the file by incrementing a reference count of the object. In an embodiment, the one or more processors are configured to update the at least part of the file by writing content of the at least part of the file to the backup storage system only in response to a failure to increment the reference count.
- There is additionally provided, in accordance with an embodiment of the present invention, a method for data storage including storing a local copy of at least part of a file system represented by hierarchical structure of directories and files. A backup copy of the at least part of the file system is stored in a backup storage system. A dual Merkle tree, which is calculated over the backup copy and includes (i) a metadata Merkle tree including Metadata Merkle-Tree Keys (MD-MTKs) and (ii) a data Merkle tree including Data Merkle-Tree Keys (D-MTKs), is stored. The backup copy is updated to match the local copy using the dual Merkle tree.
- There is further provided, in accordance with an embodiment of the present invention, a computer software product, the product including a tangible non-transitory computer-readable medium in which program instructions are stored, which instructions, when read by one or more processors, cause the processors to store a local copy of at least part of a file system represented by hierarchical structure of directories and files, to store a backup copy of the at least part of the file system in a backup storage system, to store a dual Merkle tree that is calculated over the backup copy and includes (i) a metadata Merkle tree including Metadata Merkle-Tree Keys (MD-MTKs) and (ii) a data Merkle tree including Data Merkle-Tree Keys (D-MTKs), and to update the backup copy to match the local copy using the dual Merkle tree.
- The present invention will be more fully understood from the following detailed description of the embodiments thereof, taken together with the drawings in which:
-
FIG. 1 is a block diagram that schematically illustrates a computing system, in accordance with an embodiment of the present invention; -
FIG. 2 is a diagram that schematically illustrates tree data structures used in the computing system of FIG. 1, in accordance with an embodiment of the present invention; -
FIG. 3 is a flow chart that schematically illustrates a method for backing-up a file system to a cloud-based object store, in accordance with an embodiment of the present invention; and -
FIG. 4 is a flow chart that schematically illustrates a method for updating a file to a cloud-based object store, in accordance with an embodiment of the present invention. - Embodiments of the present invention that are described herein provide improved methods and systems for maintaining a backup copy of a File System (FS) in a backup storage system, e.g., a cloud-based object storage system. In some embodiments, a computing system comprises multiple compute nodes that communicate over a communication network. Among other tasks, one or more of the compute-node processors run a distributed FS. The processors store a local copy of the FS, and continually update a backup copy of the FS in the backup storage system.
- The disclosed embodiments provide a highly efficient process of updating the backup copy, using a “dual Merkle tree.” The dual Merkle tree comprises a metadata Merkle tree and a data Merkle tree, both calculated over the backup copy. By using this novel data structure, the backup copy of the FS can be updated without performing search operations on the backup copy, with a minimal number of read operations from the local copy of the FS, and with a minimal amount of network traffic.
- In some embodiments, the local copy of the FS is represented by a “FS tree”—A tree data structure representing the hierarchical structure of directories and files of the FS. The leaf nodes of the FS tree represent files (or empty directories), intermediate nodes represent directories, and each of the nodes holds relevant FS metadata. The backup copy of the FS is represented by a similar tree, having the same hierarchical structure, referred to as a “backup tree” or “cloud tree”.
- In some embodiments, each node of the backup tree (which typically represents a file or directory) also holds a Metadata Merkle-tree Key (MD-MTK) of the metadata Merkle tree, and a Data Merkle-tree Key (D-MTK) of the data Merkle tree. The MD-MTK of a node is calculated over (i) the metadata of the node, and (ii) the MD-MTKs of its child nodes. The D-MTK of a node is calculated over the entire content of the sub-tree of the node including the node itself, and including user data in files, metadata and any other content.
- In some embodiments, the processors carry out a two-stage process of updating the backup copy of the FS to match the local copy. In the first stage, the processors create a “temporary Merkle tree,” which has the same hierarchical structure as the FS tree and the backup tree. Each node of the temporary Merkle tree holds a MD-MTK that is calculated over (i) the MD-MTKs of its child nodes in the temporary Merkle tree, and (ii) the metadata of the corresponding node in the FS tree. The processors typically create the temporary Merkle tree by scanning the FS tree in a Depth-First Search (DFS) order.
- In the second stage of the update process, the processors decide which sub-trees of the backup tree have changed and need to be updated by the corresponding sub-trees of the FS tree, and which sub-trees have not changed and can be skipped. For a given sub-tree, the decision is made by comparing the MD-MTKs of the root node of that sub-tree in the backup tree and in the temporary Merkle tree. Typically, the processors scan the temporary Merkle tree in DFS order and, for each traversed node, decide whether to skip or update the sub-tree of that node.
- Even when a certain sub-tree of the backup tree needs to be updated (because the MD-MTK of this sub-tree in the temporary Merkle tree differs from the MD-MTK of the corresponding sub-tree in the backup tree), the processors do not actually copy the entire sub-tree of the FS tree indiscriminately to the backup tree. The processors traverse the sub-tree and rewrite only parts of it that have changed. When reaching a leaf node, which represent a file, the processors compare the Data MTKs (D-MTKs) of corresponding parts (“data blobs”) of the file in the FS tree and in the backup tree. A given data blob is actually written to the backup tree only if its D-MTK in the backup tree does not match the corresponding D-MTK in the FS tree.
- Moreover, in some embodiments in which the backup storage system comprises a cloud-based object store, the processors further reduce write operations to the cloud by using the built-in de-duplication and reference-counting features of the cloud-based object store. In an embodiment, the processors store each data blob in the cloud in an object, whose name is the D-MTK of the data blob. When a data blob needs to be updated in the backup tree, the processors attempt to increment the reference count of the corresponding object. Only if the update fails, implying that no object having the same content as the data blob already exists in the backup copy, the data blob is actually written to the cloud. Otherwise, only the reference count is incremented.
- As can be appreciated from the description above, the disclosed update process is highly efficient in terms of read and write operations to the backup storage system (e.g., cloud-based object store), and in terms of communication traffic over the network between compute nodes. The update process typically begins by finding files and directories that are suspected as changed, using the metadata Merkle tree. Only then, those files are checked with finer resolution of data blobs for actual data changes, using the data Merkle tree. As a result, the update process is fast, low-cost and scalable.
-
FIG. 1 is a block diagram that schematically illustrates acomputing system 20, in accordance with an embodiment of the present invention.System 20 may comprise, for example, a data center, a High-Performance Computing (HPC) system, or a computing system that performs any other suitable function. -
System 20 comprisesmultiple compute nodes 24 that communicate with one another over anetwork 28, in the present example a Local Area Network (LAN).Compute nodes 24 are referred to herein as nodes, for brevity, and may comprise, for example, servers, workstations or any other suitable type of compute node.Nodes 24 may communicate overnetwork 28 in accordance with any suitable network communication protocol, such as Ethernet or Infiniband.System 20 may comprise any suitable number of compute nodes of any type.Nodes 24 may be collocated or located in multiple geographical locations. The collection ofnodes 24 is also sometimes referred to as a cluster. - In the present example, each
node 24 comprises a Central Processing Unit (CPU) 32, also referred to as a processor. Each node also comprises avolatile memory 36 such as Random Access Memory (RAM), andnon-volatile storage 40, also referred to simply as disk, such as one or more Solid State Drives (SSDs) or Hard Disk Drives (HDDs). Eachnode 24 further comprises anetwork interface 44 such as a Network Interface Controller (NIC) for communicating overnetwork 28. -
CPU 32 of eachnode 24 runs one or more workloads, in the present example Virtual Machines (VMs) 52. Although the embodiments described herein refer mainly to VMs, the disclosed techniques can be used with any other suitable type of workloads, e.g., user applications, operating system processes or containers, and/or any other suitable software. - In some embodiments, each
CPU 32 runs a respective File System (FS)module 48 that carries out various file management functions. The plurality ofmodules 48, running onCPUs 32 ofnodes 24, implement a distributed FS that manages the storage of files. This distributed FS typically serves thevarious VMs 52 using a suitable storage protocol such as Network File System (NFS) or Server Message Block (SMB). In alternative embodiments,system 20 may run a centralized FS, e.g., on a dedicated server, instead of a distributed FS. - In the embodiment of
FIG. 1 ,computing system 20 is connected via a Wide Area Network (WAN) 60, e.g., the Internet, to a cloud-basedobject storage system 64.Storage system 64 serves as the persistent storage media in which the distributed FS backs-up its data and metadata, e.g., copies of files and directories. In the embodiments described herein, objectstorage system 64 comprises the Amazon Simple Storage Service (S3). The description that follows refers simply to “S3” for brevity. Alternatively, any other suitable cloud-based object storage system, e.g., Google Cloud Storage or Microsoft Azure, can be used. - The configurations of
system 20 andnodes 24 shown inFIG. 1 are example configurations that are chosen purely for the sake of conceptual clarity. In alternative embodiments, any other suitable system and/or node configuration can be used. For example, some or even all of the functionality ofmodules 48 may be implemented on one or more processors that are separate fromnodes 24. - The different elements of
system 20 andnodes 24 may be implemented using suitable hardware, using software, or using a combination of hardware and software elements. In some embodiments,CPUs 32 comprise general-purpose processors, which are programmed in software to carry out the functions described herein. The software may be downloaded to the processors in electronic form, over a network, for example, or it may, alternatively or additionally, be provided and/or stored on non-transitory tangible media, such as magnetic, optical, or electronic memory. - For the sake of clarity, the description that follows refers to “the FS” as carrying out the various storage tasks. In various embodiments, the functionality of the FS may be carried out by any one or more processors in
system 20, e.g., collectively byFS modules 48 running onCPUs 32 ofnodes 24, and/or by a processor of a dedicated centralized server. - For the sake of clarity, the description that follows refers to “the FS memory” as storing certain data structures. In various embodiments, the FS memory may comprise any suitable memory space associated with
compute nodes 24, e.g., on one or more ofRAM devices 36. - In some embodiments,
system 20 backs-up its FS to cloud-basedobject storage system 64, in the present example to S3. The back-up typically comprises retaining on S3 an updated copy of the entire hierarchical structure of the FS directories and files, including both user file data and metadata. As will be explained below, the FS carries out a highly efficient process of updating the FS to S3, which has the following characteristics: -
- Updating is performed without performing search operations on the cloud version of the FS, thereby reducing the number of expensive readout operations from the cloud.
- Updating is performed with a minimal amount of traffic exchange over
network 32.
-
FIG. 2 is a diagram that schematically illustrates three tree data structures used for representing and updating the FS ofsystem 20, in accordance with an embodiment of the present invention. The three data structures are used for representing the FS, both locally insystem 20 and in the cloud (in S3), and for the cloud update process. For clarity, the description that follows refers to updating of the entire FS. Alternatively, however, the data structures and processes described herein can also be used for updating only selected parts of the FS, e.g., specific directories. - The top of
FIG. 2 shows an example “FS tree” 70, a data structure used for representing the FS locally insystem 20.Tree 70 is stored locally insystem 20, e.g., in a suitable location inRAM devices 36 and/ordisks 40. -
FS tree 70 comprisesmultiple nodes 74, stemming from a root node (at the top) and ending with leaf nodes (at the bottom). Each leaf node represents a file or an empty directory. Each intermediate node represents a directory, which may contain one or more files and/or one or more directories. The root node represents the entire FS. The part of the tree that stems from a certain node is referred to as the sub-tree of that node. - The parent-child relationships between
nodes 74 represent the hierarchical structure of the FS. In this representation, node X being a child of node Y means that the file or directory represented by node X is contained in the directory represented by node Y. As can be seen in the present example, the FS tree need not necessarily be binary, need not necessarily be balanced, and need not necessarily have a uniform number of levels. - Each
node 74 inFS tree 70 stores metadata that pertains to itself and to its sub-tree. In the present example the metadata comprises: -
- A unique node index denoted I-NODE.
- A time stamp of the most recent time any file or directory in the node's sub-tree was modified, denoted “LAST MOD”.
- A unique name.
- When a
leaf node 74 ofFS tree 70 represents a file, the node also comprises one or more pointers to “data blobs” that hold the actual data of the file. The data blobs typically comprise memory regions in the FS memory (e.g., across RAM devices 36). - (In an alternative embodiment, the node index I-NODE is omitted from the calculation of the MD-MTK. This feature is useful, for example, for efficiently creating and storing copies of FSs.)
- The middle of
FIG. 2 shows an example “Temporary Merkle tree” 80, a data structure that the FS produces temporarily when backing-up the FS to S3.Tree 80 is stored locally insystem 20, e.g., in a suitable location inRAM devices 36 and/ordisks 40. The backup process, including generation and usage ofMerkle tree 80, is described inFIGS. 3 and 4 below. -
Merkle tree 80 comprisesmultiple nodes 84, and has the same hierarchical structure asFS tree 70. In other words, eachnode 84 intree 80 corresponds to arespective node 74 in tree 70 (and thus represents the same file or directory as its corresponding node 74). The parent-child hierarchy amongnodes 84 is also the same as the hierarchy amongnodes 74. - In the present example, during the backup process, the FS stores the following parameters in each
node 84 of Merkle tree 80: -
- The metadata stored in the corresponding
node 74 ofFS tree 70. - A unique name.
- A Metadata Merkle-Tree Key (MD-MTK), which is calculated over (i) the metadata stored in the corresponding
node 74 ofFS tree 70, and (ii) the MD-MTKs of the child nodes of thenode 84 in question.
- The metadata stored in the corresponding
- In an embodiment, the FS produces the MD-MTK of each
node 84 by calculating a hash function over (i) the metadata of the correspondingnode 74 ofFS tree 70, and (ii) the MD-MTKs of the child nodes of thenode 84 in question. Any suitable hash function can be used for this purpose. Alternatively, the FS may produce the MD-MTK by calculating any other suitable checksum or signature. - Typically, the checksum used for calculating the MD-MTK (the type of checksum and the parameters over which it is calculated) guarantees the following: If two nodes are found to have the same MD-MTK, then they represent identical FS sub-trees with very high likelihood. As will be explained below, this property enables the update process to skip entire FS sub-trees without scanning them.
- The bottom of
FIG. 2 shows an example “cloud tree” 90, a data structure used for representing the backed-up version of the FS in S3. The cloud tree is also referred to as “backup tree,” and the two terms are used interchangeably.Tree 90 is stored “in the cloud,” e.g., in cloud-basedobject storage system 64. -
Cloud tree 90 comprisesmultiple nodes 94, and has the same hierarchical structure asFS tree 70 andtemporary Merkle tree 80. In other words, eachnode 94 intree 90 corresponds to arespective node 74 intree 70, and to arespective node 84 in tree 80 (and thus also represents the same file or directory as its corresponding node 74). The parent-child hierarchy amongnodes 94 is also the same as the hierarchy amongnodes 74, and amongnodes 84. - In the present example, in the backup process, the FS stores the following parameters in each
node 94 of cloud tree 90: -
- The metadata stored in the corresponding
node 74 ofFS tree 70. - The MD-MTK stored in the corresponding
node 84 oftemporary Merkle tree 80. - An additional Merkle-Tree Key (MTK), which is calculated over the entire sub-tree of the
node 94 in question intree 90. This MTK is referred to as “data MTK” and is denoted D-MTK. Typically, the D-MTK is calculated over the entire content of the sub-tree, including user data in files, metadata and any other content.
- The metadata stored in the corresponding
- In some embodiments, the main difference between
temporary Merkle tree 80 andbackup tree 90 is that the nodes oftemporary Merkle tree 80 comprise MD-MTKs and do not point to any user file data. Inbackup tree 90, on the other hand, the nodes comprise, in addition to the MD-MTKs, also D-MTKs that function as a pointers to user data blobs. - In an embodiment, the FS produces the D-MTK of each
node 94 by calculating a hash function over the sub-tree of thisnode 94 incloud tree 90. Any suitable hash function can be used for this purpose. Alternatively, the FS may produce the D-MTK by calculating any other suitable checksum or signature. - Typically, the checksum used for calculating the D-MTK guarantees the following: If two nodes are found to have the same D-MTK, then they represent identical sub-trees with very high likelihood. The type of checksum used for calculating the D-MTK may be the same as or different from the type of checksum used for calculating the MD-MTK.
-
Cloud tree 90 is an example of a dual Merkle tree. In the context of the present patent application and in the claim, the term “dual Merkle tree” refers to any suitable data structure, or multiple data structures, that hold Metadata Merkle-Tree Keys (MD-MTKs) and Data Merkle-Tree Keys (D-MTKs) calculated over metadata and data, respectively, of at least part of a file system. In alternative embodiments, the FS may represent the dual Merkle tree in any other suitable manner. -
FIG. 3 is a flow chart that schematically illustrates a method for backing-up the FS ofsystem 20 to S3, in accordance with an embodiment of the present invention. As noted above, this process may be performed by any processor or processors insystem 20. The update process may be performed periodically, or in response to some event, e.g., an administrator command. - The method of
FIG. 3 has two main stages. In the first stage (illustrated by steps 100-112), the FS scansFS tree 70 in a Depth-First Search (DFS) order and constructstemporary Merkle tree 80. In the second stage (illustrated by steps 116-136), the FS scanstemporary Merkle tree 80 in a Depth-First Search (DFS) order and updates cloudtree 90 stored in S3. - The first stage (construction of
temporary Merkle tree 80 based on FS tree 70) begins with the FS selecting the next node 74 (initially the root node) ofFS tree 70 in accordance with the DFS order, at anode selection step 100. - At a MD-
MTK calculation step 104, the FS calculates a MD-MTK for the node 84 (in temporary Merkle tree 80) that corresponds to the selectednode 74. The MD-MTK is calculated over (i) the metadata of the selectednode 74, and (ii) the MD-MTKs of the child nodes of the correspondingnode 84. The FS stores the MD-MTK in the correspondingnode 84 oftemporary Merkle tree 80, at a MD-MTK storage step 108. - At a checking
step 112, the FS checks whether theentire FS tree 70 has been scanned. If not, the method loops back to step 100 above, in which the FS selects thenext node 74. Otherwise, the method proceeds to the second stage. - The second stage (updating of
cloud tree 90 in S3 based on temporary Merkle tree 80) begins with the FS selecting the next node 84 (initially the root node) oftemporary Merkle tree 80 in accordance with the DFS order, at anode selection step 116. The FS reads the correspondingnode 94 ofcloud tree 90 from S3, at acloud readout step 120. - At a MD-
MTK comparison step 124, the FS compares the MD-MTK of the currently selectednode 84 oftemporary Merkle tree 80 with the MD-MTK of the correspondingnode 94 read fromcloud tree 90. At amatch checking step 128, the FS checks whether the two MD-MTKs are the same or not. - As explained above, if the two MD-MTKs are the same, the FS may conclude that the existing sub-tree of the
node 94 incloud tree 90 is identical to the sub-tree of the correspondingnode 74 inFS tree 70. In other words, if the two MD-MTKs are the same, the entire sub-tree of the correspondingnode 74 ofFS tree 70 does not need to be updated in the cloud and can be safely skipped. Otherwise, if the two MD-MTKs are not the same, the FS concludes that some difference exists between the sub-tree of thenode 94 incloud tree 90 and the sub-tree of the correspondingnode 74 inFS tree 70. In the latter case, the update process should continue scanning inside this sub-tree and update the cloud tree as appropriate. - Thus, if checking
step 128 concludes that the two MD-MTKs do not match, the FS updates the sub-tree of thenode 94 incloud tree 90 with the corresponding sub-tree ofFS tree 70, at asub-tree updating step 132. - Typically, in
step 132, the FS does not actually copy the entire sub-tree fromFS tree 70 to cloudtree 90, but only the parts of the sub-tree that have changed since the last update. The FS typically scans the sub-tree oftemporary Merkle tree 80 using DFS, and continues to compare MD-MTKs. Any part of the sub-tree whose MD-MTK matches the corresponding MD-MTK incloud tree 90 is skipped, and DFS scanning continues only within sub-trees whose MD-MTK does not match the corresponding MD-MTK incloud tree 90. This process continues until reaching a leaf node oftemporary Merkle tree 80 whose MD-MTK does not match the corresponding MD-MTK incloud tree 90. Only at this stage, actual data has to be copied from the FS to the cloud. This selective data updating process is described in detail inFIG. 4 below. If checkingstep 128 concludes that the two MD-MTKs match,sub-tree updating step 132 is skipped. - At a
completion checking step 136, the FS checks whether the entiretemporary Merkle tree 80 has been scanned. If not, the method loops back to step 116 above, in which the FS selects thenext node 84. Otherwise, the method terminates at a termination step 140. -
FIG. 4 is a flow chart that schematically illustrates a method for updating a file fromFS tree 70 to cloudtree 90, in accordance with an embodiment of the present invention. The method ofFIG. 4 can be used as part ofsub-tree updating step 132 ofFIG. 3 above. As explained above, the method ofFIG. 4 is invoked whenstep 132 ofFIG. 3 reaches a leaf node oftemporary Merkle tree 80 whose MD-MTK does not match the corresponding MD-MTK incloud tree 90. - This mismatch in MD-MTK means that the file represented by the leaf node has changed since the most recent update of the FS to the cloud. In such a case, the FS scans the data blobs of the file in question, skips any data blobs that have not changed, and copies to the cloud only data blobs that have changed. The FS distinguishes between data blobs that have changed and data blobs that have not changed by comparing corresponding data MTKs (D-MTKs) in
FS tree 70 andcloud tree 90. - The method of
FIG. 4 begins with the FS selecting the next data blob (initially the first data blob) of the file in question, at a datablob selection step 150. At a D-MTK comparison step 154, the FS compares the D-MTK of the selected data blob inFS tree 70 with the D-MTK of the corresponding data blob incloud tree 90. The FS checks whether the two D-MTKs match, at amatch checking step 158. - If the two D-MTKs do not match, the FS replaces the data blob in
cloud tree 90 with the corresponding (and more up-to-date) data blob ofFS tree 70. The replacement process, in an embodiment, is illustrated by steps 162-170. In the present example, the FS stores each data blob in S3 as an object whose name is the D-MTK of the data blob. In practice, data blobs having the same data may appear in different files. In such a case, the FS does not write the actual data multiple times to the cloud, but only writes the metadata of the data blob and increments the reference count (REFCNT) of the existing object. The above-described naming convention (D-MTK used as the object name) essentially implements de-duplication. Further aspects of this technique are addressed in U.S. patent application Ser. No. 15/406,724, entitled “Object Storage in Cloud with Reference Counting using Versions,” which is assigned to the assignee of the present patent application and whose disclosure is incorporated herein by reference. - Thus, if the D-MTK of the selected data blob in
FS tree 70 does not match the D-MTK of the corresponding data blob incloud tree 90, the FS attempts to update the reference count of the object (whose name is the D-MTK of the data blob of FS tree 70) in S3, at aREFCNT updating step 162. At asuccess checking step 166, the FS checks whether the REFCNT update was successful or not. - If S3 acknowledged that the REFCNT was updated successfully, the FS concludes that an object having the same data indeed already exists in the cloud. In such a case, only the REFCNT is updated, and there is no need to write the actual data of the data blob to the cloud.
- Otherwise, if S3 returns a notification that the REFCNT update has failed, the FS concludes that an object having the same data does not exist in the cloud. Only in this case, at an overwriting
step 170, the FS overwrites the data blob incloud tree 90 with the actual data of the data blob ofFS tree 70. The FS performs this action by writing to S3 a new object whose name is the D-MTK of the data blob ofFS tree 70. - At a data-blob
completion checking step 174, the FS checks whether all the data blobs of the file have been checked. If not, the method loops back to step 150 above for selecting (and possibly updating) the next data blob. Otherwise, the method terminates at a termination step 178. - The method flows of
FIGS. 3 and 4 above are example flows, which are chosen purely for the sake of conceptual clarity. In alternative embodiments, the FS ofsystem 20 may perform back-up to the cloud, based on both MD-MTKs and D-MTKs, using any other suitable method. - Although the embodiments described herein refer mainly to backup of a file system to an object-based cloud storage system, the disclosed techniques can also be used for backup to any other backup storage system, which is not necessarily a cloud system and is not necessarily object based. An alternative example of a backup storage system is a LAN-based object storage system. Systems of this sort are offered, for example, by Cloudian (San Mateo, Calif.), Dell EMC (Hopkinton, Mass.), and others.
- It will thus be appreciated that the embodiments described above are cited by way of example, and that the present invention is not limited to what has been particularly shown and described hereinabove. Rather, the scope of the present invention includes both combinations and sub-combinations of the various features described hereinabove, as well as variations and modifications thereof which would occur to persons skilled in the art upon reading the foregoing description and which are not disclosed in the prior art. Documents incorporated by reference in the present patent application are to be considered an integral part of the application except that to the extent any terms are defined in these incorporated documents in a manner that conflicts with the definitions made explicitly or implicitly in the present specification, only the definitions in the present specification should be considered.
Claims (13)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/591,131 US10387271B2 (en) | 2017-05-10 | 2017-05-10 | File system storage in cloud using data and metadata merkle trees |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/591,131 US10387271B2 (en) | 2017-05-10 | 2017-05-10 | File system storage in cloud using data and metadata merkle trees |
Publications (2)
Publication Number | Publication Date |
---|---|
US20180329785A1 true US20180329785A1 (en) | 2018-11-15 |
US10387271B2 US10387271B2 (en) | 2019-08-20 |
Family
ID=64096288
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US15/591,131 Active 2037-10-09 US10387271B2 (en) | 2017-05-10 | 2017-05-10 | File system storage in cloud using data and metadata merkle trees |
Country Status (1)
Country | Link |
---|---|
US (1) | US10387271B2 (en) |
Cited By (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN109359093A (en) * | 2018-12-19 | 2019-02-19 | 杭州安恒信息技术股份有限公司 | A kind of rule file update method and system |
CN109684333A (en) * | 2018-12-24 | 2019-04-26 | 杭州复杂美科技有限公司 | A kind of storage of data and method of cutting out, equipment and storage medium |
US20190213268A1 (en) * | 2018-01-10 | 2019-07-11 | Red Hat, Inc. | Dynamic subtree pinning in storage systems |
CN110800255A (en) * | 2019-03-04 | 2020-02-14 | 阿里巴巴集团控股有限公司 | Updating block chain world state mercker patricia dictionary tree subtree |
US10587454B2 (en) * | 2018-01-30 | 2020-03-10 | Hewlett Packard Enterprise Development Lp | Object counts persistence for object stores |
US10621032B2 (en) * | 2017-06-22 | 2020-04-14 | Uber Technologies, Inc. | Checksum tree generation for improved data accuracy verification |
CN111444163A (en) * | 2020-03-25 | 2020-07-24 | 汉海信息技术(上海)有限公司 | Method and device for map data management and electronic map rollback |
US20230132278A1 (en) * | 2020-02-28 | 2023-04-27 | Inspur Suzhou Intelligent Technology Co., Ltd. | File data access method, apparatus, and computer-readable storage medium |
US11940969B2 (en) | 2022-05-25 | 2024-03-26 | International Business Machines Corporation | Managing locations of derived storage objects |
Family Cites Families (21)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7664966B2 (en) | 2004-05-17 | 2010-02-16 | Microsoft Corporation | Secure storage on recordable medium in a content protection system |
US20130104251A1 (en) * | 2005-02-01 | 2013-04-25 | Newsilike Media Group, Inc. | Security systems and methods for use with structured and unstructured data |
US8832466B1 (en) * | 2006-01-27 | 2014-09-09 | Trustwave Holdings, Inc. | Methods for augmentation and interpretation of data objects |
US20100274772A1 (en) | 2009-04-23 | 2010-10-28 | Allen Samuels | Compressed data objects referenced via address references and compression references |
US20100332401A1 (en) | 2009-06-30 | 2010-12-30 | Anand Prahlad | Performing data storage operations with a cloud storage environment, including automatically selecting among multiple cloud storage sites |
US8457018B1 (en) * | 2009-06-30 | 2013-06-04 | Emc Corporation | Merkle tree reference counts |
US20140222758A1 (en) * | 2009-08-14 | 2014-08-07 | Ic Manage, Inc. | Coherent File State Maintained Among Confederated Repositories By Distributed Workspace Apparatuses Backed Up By a File State Ledgerdemain Store |
US9705730B1 (en) * | 2013-05-07 | 2017-07-11 | Axcient, Inc. | Cloud storage using Merkle trees |
US8706701B1 (en) | 2010-11-18 | 2014-04-22 | Emc Corporation | Scalable cloud file system with efficient integrity checks |
US9805054B2 (en) | 2011-11-14 | 2017-10-31 | Panzura, Inc. | Managing a global namespace for a distributed filesystem |
US20160110261A1 (en) | 2013-05-07 | 2016-04-21 | Axcient, Inc. | Cloud storage using merkle trees |
WO2015006170A1 (en) | 2013-07-12 | 2015-01-15 | FREILICH, Arthur | A computer system storing content into application independent objects |
US10380072B2 (en) | 2014-03-17 | 2019-08-13 | Commvault Systems, Inc. | Managing deletions from a deduplication database |
US9886443B1 (en) | 2014-12-15 | 2018-02-06 | Nutanix, Inc. | Distributed NFS metadata server |
US10853242B2 (en) | 2015-03-13 | 2020-12-01 | Hitachi Vantara Llc | Deduplication and garbage collection across logical databases |
US10303887B2 (en) * | 2015-09-14 | 2019-05-28 | T0.Com, Inc. | Data verification methods and systems using a hash tree, such as a time-centric merkle hash tree |
US9990150B2 (en) | 2016-03-22 | 2018-06-05 | Toshiba Memory Corporation | Method to provide transactional semantics for updates to data structures stored in a non-volatile memory |
US10242065B1 (en) * | 2016-06-30 | 2019-03-26 | EMC IP Holding Company LLC | Combining merkle trees in graph databases |
US10230525B2 (en) * | 2016-12-23 | 2019-03-12 | Amazon Technologies, Inc. | Public key rollup for merkle tree signature scheme |
US10884984B2 (en) * | 2017-01-06 | 2021-01-05 | Oracle International Corporation | Low-latency direct cloud access with file system hierarchies and semantics |
US11036408B2 (en) * | 2017-03-26 | 2021-06-15 | Oracle International Corporation | Rule-based modifications in a data storage appliance monitor |
-
2017
- 2017-05-10 US US15/591,131 patent/US10387271B2/en active Active
Cited By (14)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10621032B2 (en) * | 2017-06-22 | 2020-04-14 | Uber Technologies, Inc. | Checksum tree generation for improved data accuracy verification |
US20190213268A1 (en) * | 2018-01-10 | 2019-07-11 | Red Hat, Inc. | Dynamic subtree pinning in storage systems |
US10862736B2 (en) * | 2018-01-30 | 2020-12-08 | Hewlett Packard Enterprise Development Lp | Object counts persistence for object stores |
US10587454B2 (en) * | 2018-01-30 | 2020-03-10 | Hewlett Packard Enterprise Development Lp | Object counts persistence for object stores |
CN109359093A (en) * | 2018-12-19 | 2019-02-19 | 杭州安恒信息技术股份有限公司 | A kind of rule file update method and system |
CN109684333A (en) * | 2018-12-24 | 2019-04-26 | 杭州复杂美科技有限公司 | A kind of storage of data and method of cutting out, equipment and storage medium |
CN110800255A (en) * | 2019-03-04 | 2020-02-14 | 阿里巴巴集团控股有限公司 | Updating block chain world state mercker patricia dictionary tree subtree |
KR20200107772A (en) * | 2019-03-04 | 2020-09-16 | 알리바바 그룹 홀딩 리미티드 | Blockchain World State Merkle Patricia Tri Subtree Update |
US10691676B1 (en) * | 2019-03-04 | 2020-06-23 | Alibaba Group Holding Limited | Updating blockchain world state Merkle Patricia Trie subtree |
KR102322729B1 (en) | 2019-03-04 | 2021-11-05 | 어드밴스드 뉴 테크놀로지스 씨오., 엘티디. | Blockchain World State Merkle Patricia Trie Subtree Update |
US20230132278A1 (en) * | 2020-02-28 | 2023-04-27 | Inspur Suzhou Intelligent Technology Co., Ltd. | File data access method, apparatus, and computer-readable storage medium |
US11899542B2 (en) * | 2020-02-28 | 2024-02-13 | Inspur Suzhou Intelligent Technology Co., Ltd. | File data access method, apparatus, and computer-readable storage medium |
CN111444163A (en) * | 2020-03-25 | 2020-07-24 | 汉海信息技术(上海)有限公司 | Method and device for map data management and electronic map rollback |
US11940969B2 (en) | 2022-05-25 | 2024-03-26 | International Business Machines Corporation | Managing locations of derived storage objects |
Also Published As
Publication number | Publication date |
---|---|
US10387271B2 (en) | 2019-08-20 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10387271B2 (en) | File system storage in cloud using data and metadata merkle trees | |
US11379411B2 (en) | System and method for replicating file systems in remote object storages | |
US10678448B2 (en) | Deduplication of virtual machine content | |
US10534768B2 (en) | Optimized log storage for asynchronous log updates | |
US8200706B1 (en) | Method of creating hierarchical indices for a distributed object system | |
US11354065B2 (en) | Cloud edition and retrieve | |
US11861392B2 (en) | Deploying a cloud instance of a user virtual machine | |
US20220138169A1 (en) | On-demand parallel processing of objects using data connector components | |
US11392458B2 (en) | Reconstructing lost data objects by generating virtual user files from available nodes within a cluster | |
US11853581B2 (en) | Restoring a storage system using file relocation metadata | |
US10754731B1 (en) | Compliance audit logging based backup | |
US20220138151A1 (en) | Sibling object generation for storing results of operations performed upon base objects | |
US11403024B2 (en) | Efficient restoration of content | |
US20220138153A1 (en) | Containerization and serverless thread implementation for processing objects | |
US11494105B2 (en) | Using a secondary storage system to implement a hierarchical storage management plan | |
US11544156B1 (en) | Incremental restore for volumes using object-based snapshots | |
US11494335B2 (en) | Reconstructing lost data objects by generating virtual user files from available tiers within a node | |
US11755538B2 (en) | Distributed management of file modification-time field | |
US11586375B1 (en) | Incremental restore for volumes using object-based snapshots | |
US20230376451A1 (en) | Client support of multiple fingerprint formats for data file segments | |
US20220114139A1 (en) | Fractional consistent global snapshots of a distributed namespace |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: ELASTIFILE LTD., ISRAELFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:MOSEK, AMIR;FRANK, SHAHAR;REEL/FRAME:042316/0845Effective date: 20170419 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: RESPONSE TO NON-FINAL OFFICE ACTION ENTERED AND FORWARDED TO EXAMINER |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: NOTICE OF ALLOWANCE MAILED -- APPLICATION RECEIVED IN OFFICE OF PUBLICATIONS |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: PUBLICATIONS -- ISSUE FEE PAYMENT VERIFIED |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:ELASTIFILE LTD;REEL/FRAME:050664/0385Effective date: 20191008 |
|
FEPP | Fee payment procedure |
Free format text: ENTITY STATUS SET TO UNDISCOUNTED (ORIGINAL EVENT CODE: BIG.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |