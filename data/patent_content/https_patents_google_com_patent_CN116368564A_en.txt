CN116368564A - Trained generative model speech coding - Google Patents
Trained generative model speech coding Download PDFInfo
- Publication number
- CN116368564A CN116368564A CN202180070872.3A CN202180070872A CN116368564A CN 116368564 A CN116368564 A CN 116368564A CN 202180070872 A CN202180070872 A CN 202180070872A CN 116368564 A CN116368564 A CN 116368564A
- Authority
- CN
- China
- Prior art keywords
- model
- audio data
- training
- sampled
- data
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000000034 method Methods 0.000 claims abstract description 84
- 238000012549 training Methods 0.000 claims abstract description 83
- 230000006870 function Effects 0.000 claims abstract description 79
- 238000010801 machine learning Methods 0.000 claims abstract description 78
- 238000009826 distribution Methods 0.000 claims abstract description 65
- 239000013598 vector Substances 0.000 claims description 51
- 230000000694 effects Effects 0.000 claims description 19
- 230000001131 transforming effect Effects 0.000 claims description 8
- 238000001228 spectrum Methods 0.000 description 68
- 230000015654 memory Effects 0.000 description 65
- 238000005070 sampling Methods 0.000 description 32
- 238000012545 processing Methods 0.000 description 29
- 238000004891 communication Methods 0.000 description 26
- 238000013139 quantization Methods 0.000 description 26
- 230000001629 suppression Effects 0.000 description 17
- 230000008569 process Effects 0.000 description 14
- 239000000203 mixture Substances 0.000 description 13
- 238000007476 Maximum Likelihood Methods 0.000 description 12
- 230000005236 sound signal Effects 0.000 description 12
- 238000005192 partition Methods 0.000 description 10
- 230000035945 sensitivity Effects 0.000 description 9
- 230000003044 adaptive effect Effects 0.000 description 8
- 230000006835 compression Effects 0.000 description 8
- 238000007906 compression Methods 0.000 description 8
- 230000004048 modification Effects 0.000 description 8
- 238000012986 modification Methods 0.000 description 8
- 230000015572 biosynthetic process Effects 0.000 description 7
- 239000003607 modifier Substances 0.000 description 7
- 238000003786 synthesis reaction Methods 0.000 description 7
- 230000005540 biological transmission Effects 0.000 description 6
- 238000004590 computer program Methods 0.000 description 6
- 238000010586 diagram Methods 0.000 description 6
- 238000011156 evaluation Methods 0.000 description 6
- 238000013138 pruning Methods 0.000 description 6
- 230000009467 reduction Effects 0.000 description 6
- 230000009466 transformation Effects 0.000 description 6
- 238000000926 separation method Methods 0.000 description 5
- 238000009827 uniform distribution Methods 0.000 description 5
- 230000006978 adaptation Effects 0.000 description 4
- 230000010339 dilation Effects 0.000 description 4
- 238000001914 filtration Methods 0.000 description 4
- 238000002156 mixing Methods 0.000 description 4
- 230000003287 optical effect Effects 0.000 description 4
- 238000005516 engineering process Methods 0.000 description 3
- 230000006872 improvement Effects 0.000 description 3
- 239000000654 additive Substances 0.000 description 2
- 230000001364 causal effect Effects 0.000 description 2
- 230000001413 cellular effect Effects 0.000 description 2
- 230000004044 response Effects 0.000 description 2
- 239000000758 substrate Substances 0.000 description 2
- 239000013589 supplement Substances 0.000 description 2
- 238000012935 Averaging Methods 0.000 description 1
- XUIMIQQOPSSXEZ-UHFFFAOYSA-N Silicon Chemical compound [Si] XUIMIQQOPSSXEZ-UHFFFAOYSA-N 0.000 description 1
- 230000002159 abnormal effect Effects 0.000 description 1
- 230000009471 action Effects 0.000 description 1
- 230000000996 additive effect Effects 0.000 description 1
- 238000013459 approach Methods 0.000 description 1
- 238000003491 array Methods 0.000 description 1
- 238000013528 artificial neural network Methods 0.000 description 1
- 230000015556 catabolic process Effects 0.000 description 1
- 230000008859 change Effects 0.000 description 1
- 238000010367 cloning Methods 0.000 description 1
- 239000002131 composite material Substances 0.000 description 1
- 239000000470 constituent Substances 0.000 description 1
- 230000008878 coupling Effects 0.000 description 1
- 238000010168 coupling process Methods 0.000 description 1
- 238000005859 coupling reaction Methods 0.000 description 1
- 238000006731 degradation reaction Methods 0.000 description 1
- 230000001419 dependent effect Effects 0.000 description 1
- 230000005284 excitation Effects 0.000 description 1
- 230000002349 favourable effect Effects 0.000 description 1
- 238000012074 hearing test Methods 0.000 description 1
- 230000003993 interaction Effects 0.000 description 1
- 238000002372 labelling Methods 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 239000000463 material Substances 0.000 description 1
- 239000011159 matrix material Substances 0.000 description 1
- 239000013307 optical fiber Substances 0.000 description 1
- 230000008447 perception Effects 0.000 description 1
- 239000000047 product Substances 0.000 description 1
- 238000009877 rendering Methods 0.000 description 1
- 229910052710 silicon Inorganic materials 0.000 description 1
- 239000010703 silicon Substances 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
- 238000005309 stochastic process Methods 0.000 description 1
- 239000000126 substance Substances 0.000 description 1
- 230000002194 synthesizing effect Effects 0.000 description 1
- 239000010409 thin film Substances 0.000 description 1
- 238000009966 trimming Methods 0.000 description 1
- 230000001755 vocal effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G10—MUSICAL INSTRUMENTS; ACOUSTICS
- G10L—SPEECH ANALYSIS OR SYNTHESIS; SPEECH RECOGNITION; SPEECH OR VOICE PROCESSING; SPEECH OR AUDIO CODING OR DECODING
- G10L19/00—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis
- G10L19/02—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis using spectral analysis, e.g. transform vocoders or subband vocoders
- G10L19/032—Quantisation or dequantisation of spectral components
- G10L19/038—Vector quantisation, e.g. TwinVQ audio
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G10—MUSICAL INSTRUMENTS; ACOUSTICS
- G10L—SPEECH ANALYSIS OR SYNTHESIS; SPEECH RECOGNITION; SPEECH OR VOICE PROCESSING; SPEECH OR AUDIO CODING OR DECODING
- G10L19/00—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis
- G10L19/04—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis using predictive techniques
-
- G—PHYSICS
- G10—MUSICAL INSTRUMENTS; ACOUSTICS
- G10L—SPEECH ANALYSIS OR SYNTHESIS; SPEECH RECOGNITION; SPEECH OR VOICE PROCESSING; SPEECH OR AUDIO CODING OR DECODING
- G10L21/00—Processing of the speech or voice signal to produce another audible or non-audible signal, e.g. visual or tactile, in order to modify its quality or its intelligibility
- G10L21/02—Speech enhancement, e.g. noise reduction or echo cancellation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
-
- G—PHYSICS
- G10—MUSICAL INSTRUMENTS; ACOUSTICS
- G10L—SPEECH ANALYSIS OR SYNTHESIS; SPEECH RECOGNITION; SPEECH OR VOICE PROCESSING; SPEECH OR AUDIO CODING OR DECODING
- G10L19/00—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis
Abstract
A method includes receiving sampled audio data corresponding to an utterance and training a Machine Learning (ML) model using the sampled audio data to generate a high-fidelity audio stream from a low-bit-rate input bitstream. Training of the ML model includes attenuating the impact of low probability distortion events in the sampled audio data on the trained ML model, wherein the attenuation of the distortion events is achieved by including terms in an objective function of the ML model that encourage a low variance predictive distribution of a next sample in the sampled audio data based on previous samples of the audio data.
Description
Technical Field
Embodiments relate to encoding, conveying, and decoding utterances in a communication environment (e.g., an application).
Background
The audio codec can be used to compress speech in a communication application (e.g., when executed on a mobile computing device). However, these audio codecs may not compress speech to a desired size for minimizing bandwidth usage (e.g., bit rate) in the communication network. The possibility to use a machine learning based generation model as an audio codec suggests that further compression is possible resulting in a reduction of the size and bandwidth usage (e.g. bit rate) of the speech application. However, successfully training machine learning based generative models that can handle speech from a wide variety of speakers and speech emitted in a wide variety of environments can be difficult.
Disclosure of Invention
In a general aspect, a method includes receiving sampled audio data corresponding to an utterance and training a Machine Learning (ML) model using the sampled audio data to generate a high-fidelity audio stream from a low-bit-rate input bitstream. Training of the ML model includes attenuating the impact of low probability distortion events in the sampled audio data on the trained ML model, wherein attenuation of distortion events is achieved by including terms in an objective function of the ML model that encourage a low variance predictive distribution of a next sample in the sampled audio data based on previous samples of the audio data.
Example embodiments can include one or more of the following features, alone or in any combination with one another.
In a first example, the term encouraging a low variance prediction distribution of the next bit in the generated bitstream can include a regularization term.
In a second example, the regularization term can be defined as:
W represents a vector of network parameter weights,
{ x } represents the sequence of the sampled audio data,
E data indicating an average of a set of data in a database comprising said sampled audio data, an
In a third example, the regularization term can include a logarithm that is a monotonically increasing function of the prediction variance.
In a fourth example, the regularization term can be defined as:
J var ({x}，W)＝E data log(σ q +a) wherein
W represents a vector of network parameter weights,
{ x } represents the sequence of the sampled audio data,
E data indicating an average, sigma, of a set of data in a database comprising said sampled audio data q Representing the prediction variance
a represents a floor.
In a fifth example, the objective function can include a log-likelihood objective function and a regularization term, and training of the ML model can include selecting weights for a network that minimizes a prediction variance associated with the regularization term.
In a sixth example, the ML model can be a regression network.
In a seventh example, the sampled audio data can be separated in the time domain, the separated sampled audio data can be converted into a sequence of speech parameter vectors, the sequence of speech parameter vectors can be transformed, and the sequence of transformed speech parameter vectors can be quantized prior to training the ML model.
In another general aspect, a method of delivering an audio bitstream includes: receiving, at a first device, sampled first audio data corresponding to a first utterance; converting the sampled first audio data into a sequence of speech parameter vectors; creating a first bit stream representing the utterance by quantizing the sequence of transformed speech parameter vectors; delivering, by the first device, the first bit stream to the second device; receiving, at the first device, a second bitstream representing a second utterance from a second device; creating a sequence of speech parameter vectors based on the second bitstream; creating a sequence of vectors based on inverse transforming the sequence of speech parameter vectors; generating a high-fidelity audio stream representing the second utterance based on the vector sequence and by using a trained Machine Learning (ML) model, wherein training of the ML model includes attenuating an effect of low probability distortion events in the sampled training audio data on the trained ML model, wherein attenuation of the distortion events is achieved by including a term in an objective function of the ML model that encourages a low variance predictive distribution of a next sample in the sampled training audio data based on previous samples of the audio data.
Example embodiments can include one or more of the following features, alone or in any combination with one another.
In an eighth example, the term encouraging the low variance predictive distribution of the next sample in the sampled training audio data can include a regularization term.
In a ninth example, the regularization term can be defined as:
W represents a vector of network parameter weights,
{ x } represents the sequence of the sampled audio data,
E data indicating an average of a set of data in a database comprising said sampled audio data, an
In a tenth example, the regularization term can include a logarithm that is a monotonically increasing function of the prediction variance.
In an eleventh example, the regularization term can be defined as:
J var ({x}，W)＝E data log(σ q +a) wherein
W represents a vector of network parameter weights,
{ x } represents the sequence of the sampled audio data,
E data indicating an average of a set of data in a database comprising said sampled audio data,
σ q representing the prediction variance
a represents a floor.
In a twelfth example, the objective function can include a log-likelihood objective function and a regularization term, and training of the ML model includes selecting weights for the network that minimize a prediction variance associated with the regularization term.
In a thirteenth example, the ML model can be a regression network.
Drawings
The example embodiments will become more fully understood from the detailed description given herein below and the accompanying drawings, wherein like elements are represented by like reference numerals, which are given by way of illustration only and thus do not limit the example embodiments, and wherein:
fig. 1 illustrates a graphical representation and a block diagram of a portion of a communication system in accordance with at least one example embodiment.
Fig. 2A and 2B illustrate block diagrams of an audio processing system in accordance with at least one example embodiment.
FIG. 3 shows a block diagram of a model training system in accordance with at least one example embodiment.
Fig. 4 shows a flow chart of a method for delivering audio in accordance with at least one example embodiment.
FIG. 5 shows a flow chart of a method for training a model in accordance with at least one example embodiment.
Fig. 6A and 6B are bar graphs showing the relative performance of models using the techniques described herein.
Fig. 7 illustrates an example of a computer device and a mobile computer device in accordance with at least one example embodiment.
It should be noted that these figures are intended to illustrate general characteristics of methods, structures and/or materials utilized in certain example embodiments, and to supplement the written description provided below. The use of similar or identical reference numbers in various figures is intended to indicate the presence of similar or identical elements or features.
Detailed Description
The possibility to use a machine learning based generation model as an audio codec suggests that further compression is possible resulting in a reduction of the size and bandwidth usage (e.g. bit rate) of the speech application. However, the performance of the generative model may degrade with distortion that may be present in the real world input signal. For example, one technical problem of generating a composite is that it may be sensitive to the quality of the data used for training and the sequence of conditions used for training and inference. Such degradation can be caused by sensitivity of the maximum likelihood criterion to outliers in the training data (e.g., noise events that are not related to the speech to be modeled), resulting in poor synthesized speech quality.
Example implementations of the technology described herein relate to a technical solution in which prediction variance regularization is used to reduce sensitivity of maximum likelihood criteria to outliers. The use of prediction variance regularization can result in an improvement in the performance of one or more generative models as audio codecs (e.g., utterances synthesized by the generative models can better represent the original speech). Example embodiments can use noise reduction to remove unwanted signals (e.g., during model training) to improve the performance of generating models as audio codecs with reasonable computational complexity (e.g., minimizing processor usage) to low bit rates as low as, for example, 3kb/s of real world speech signals.
Fig. 1 illustrates a graphical representation and a block diagram of a portion of a communication system in accordance with at least one example embodiment. As shown in fig. 1, the communication system 100 includes a first computing device 115 operated by a first user 105 and a second computing device 120 operated by a second user 110. The first computing device 115 and the second computing device 120 can be communicatively coupled, for example, via the internet.
The first computing device 115 can include an application 125 that includes an associated encoder 135 and an associated decoder 145, and the second computing device 120 can include an application 130 that includes an associated encoder 150 and an associated decoder 140. The encoders 135, 150 and decoders 140, 145 can be pre-installed on the respective computing devices 115, 120 and/or installed on the respective computing devices 115, 120 as the associated applications 125, 130 are installed. For example, the encoders 135, 150 and decoders 140, 145 can include audio and/or video codecs that are pre-installed on the corresponding computing devices 115, 120 and/or installed on the corresponding computing devices 115, 120 as the associated applications 125, 130 are installed.
The application 125 can be communicatively coupled with the application via coupling of the first computing device 115 and the second computing device 120. For example, data (e.g., a bitstream) generated by the encoder 135 can be delivered to the decoder 140, and data (e.g., an audio bitstream) generated by the encoder 150 can be delivered to the decoder 145. The encoders 135, 150 can be configured to compress (e.g., encode) utterances of the corresponding users 105, 110 captured using, for example, microphones of the computing devices 115, 120. The compressed utterance can have a small size (e.g., memory usage) such that a low bit rate (e.g., small bandwidth utilization) can be achieved between computing device 115 and computing device 120.
The applications 125, 130 can include user interfaces 155, 160. The user interfaces 155, 160 can be configured to provide an interface to the users 105, 110. For example, the user interfaces 155, 160 can be configured to initiate and control communications between the computing device 115 and the computing device 120. The user interfaces 155, 160 can be configured to capture and display audio and/or video captured using components of the computing devices 115, 120. The user interfaces 155, 160 can be configured to control audio and/or video (e.g., silence, background modification, camera on/off, etc.). The user interfaces 155, 160 can be configured to provide other communication operations (e.g., chat). The user interfaces 155, 160 can be configured as audio communication (e.g., telephone call, short range private communication (e.g., intercom), etc.) applications. The user interfaces 155, 160 can be configured as audio devices (e.g., streaming music, broadcast audio, podcasts, etc.), video devices (e.g., streaming video), and the like. Any of the functions of the user interfaces 155, 160 can include using techniques/implementations as described below.
The decoder 140, 145 can comprise an audio codec comprising a generation model for decoding the audio stream. Thus, the encoders 135, 150 can include an audio codec to compress audio such that the compressed audio can be decompressed (e.g., decoded, synthesized) using a generative model. The generative model can be a machine-learned (e.g., trained) generative model. The generative model can be trained using noise reduction techniques to remove unwanted signals in the audio before and/or during training of the generative model. Training a model using prediction variance regularization will be described in more detail below.
Example embodiments can include identification of a cause of sensitivity to distortion (e.g., audio noise) when training a model, and techniques to reduce that sensitivity (e.g., reduce the impact of audio noise on the performance of the trained model). The cause of sensitivity can be associated with the properties of a Log Likelihood (LL) objective function. The LL objective function incurs a relatively high penalty if the model assigns a low probability to the observation data. Thus, in the context of an autoregressive structure, the LL objective function can encourage an overly broad predictive distribution when at least some training data is difficult to accurately predict from past signals and conditions, which is the case for real world training data that includes random or abnormal noise events. By including prediction variance regularization in the overall objective function used to train the machine learning model, such effects can be mitigated (e.g., reduced). To avoid the need to model independent signals simultaneously, example embodiments can apply noise reduction techniques at lower signal-to-noise ratios before extracting features for conditions.
To understand how to model a process using an autoregressive model, consider a model made of a real-valued random sample X i Constituent random Process { X i -wherein the time index i e Z. Joint distribution of finite sequences, p (x i ，…，x i-N ) Can be expressed as the product of conditional distributions:
where β represents condition information.
From equation (1), it can be derived that for a sufficiently large N, an approximate implementation of the stochastic process can be achieved by estimating the distribution p (x i |x i-1 ，…，x i-N Beta) are created by recursive sampling in the model. Standard form distribution q (x) with parameter alpha i |α) can be used as model prediction distribution. The standard form distribution can be, for example, gaussian or logical mixture. The formula can utilize a deterministic neural network phi:
In order to find the parameter W, a reasonable goal can be to minimize the true value joint distribution p (x i ,…,x i-N ) And model distribution q (x i ,…,x i-N ) The Kullback-Leibler divergence between, or equivalently, the cross entropy between these distributions. The latter metric can be tractable, even though p may be only one empirical distribution. From equation (1) and equation q (x i |α) a cross entropy based estimation of phi parameters can be achieved using maximum likelihood based forced teaching. For M signal samples, the maximum likelihood estimate of W can be written as:
Note that equation (2) can lead to fast training because it facilitates parallel implementation.
For sufficiently large N and M, the upper limit that the LL target can provide differential entropy rates is:
here, for ease of labeling, an unconditional case is considered.
Instead, equation (3) can be interpreted as a lower bound on the uncertainty metric associated with the model predictive distribution. The lower limit is associated with the process itself and is model independent. Although the differential entropy rate can be sub-additive to the added signal, the predictive model may not be well suited to the added signal. In general, the model of the summed signal can be multiplicative in the desired model configuration. The sum of the finite-order linear autoregressive models may not be a finite-order autoregressive model. This problem can be alleviated by noise suppression.
One challenging problem is related to the shortcomings of the kulbeck-leber divergence and thus also to the LL objective of equation (2). When the model distribution q disappears in the support region of the true value p, the kulbeck-leber divergence can diverge. In equation (2), this divergence can be expressed as a function of the probability q (x) of having a low model i |φ(x i-1 ，…，x i-N Beta, W)) training data x i Is a penalty of (1). Thus, several non-representative outliers in the training data may cause the training process to equip the predictive model distribution with heavy tails (e.g., data outside of the dominant frequency). Such tails can lead to signal synthesis with relatively high entropy rates during inference. In audio synthesis, a relatively high entropy rate can correspond to a noisy synthesized signal. Thus, it may be desirable to combat the severity of the penalty of low probability training data.
Machine Learning (ML) objectives also have a second related disadvantage. When using the ML objective function, the model distribution should converge to a true value distribution as the data sample size increases. In practice, however, the random nature of the training data and training methods can lead to inaccuracies. Thus, the method can attempt to minimize the effects of such errors. For example, implicit descriptions of pitch by the prediction distribution may be inaccurate. The predictive model distribution with heavy tails for voiced speech then increases the likelihood of training data, as it reduces the impact of model pitch deviation from true value pitch. From this reasoning, it may be necessary to consider the audibility (perception) of the distortion, resulting in a refinement of the empirical excitation of the objective function.
Both related techniques can modify the maximum likelihood criterion to achieve improved performance. Both of these techniques can reduce the impact of hard-to-predict data points in the training set, and these techniques can eliminate the need for heuristic modification during inference.
The first technique for modifying the maximum likelihood criterion can be to add a term to the objective function that encourages a low variance prediction distribution. In this approach, for a given database { x } weight W, the overall objective function can be defined as:
J({x}，W)＝J LL ({x}；W)+vJ var ({x}，W)， (4)
Wherein the log-likelihood on the database,
J LL ({x}；W)＝E data logq(x i ；φ(x i-1 ，…，x i-N ，W))
regularization term J with variance defined below var ({ x }, W), and wherein v is a tunable constant.
The variance of the prediction distribution can be an instantaneous parameter that varies with a set of data, and J var ({ x }, W) can be the average of the predicted distributions. The prediction distribution of each sample can have different variances and the averaging method can be selected to have properties that are favorable for a particular application. As discussed above, the prediction distribution can be a standard form of distribution q (x|α).
The prediction distribution q (x|α) can be a mixed distribution. Therefore, an expression of the mixture distribution variance should be determined. The average value of the mixing profile can be:
The variance of the mixing distribution can be:
considering the specifics of the logic mixing in more detail, the logic distribution of component k can be expressed as:
wherein s is k Is of scale, and mu k Is offset.
The logic distribution can be symmetric around μ, and thus μ is the distribution average. The variance of the logic distribution can be expressed as:
the variance of the mixture of the logical models can be a combination of equation (6) and equation (8):
the technique for reducing the prediction variance can be a variance regularization directly using the prediction variance equation (9) as the objective function equation (4):
Wherein E is data The average value of the dataset is indicated.
Can choose to minimize
For signals with uniform overall signal variance, it may be desirable to set a low prediction variance for regions with relatively low conditional differential entropy (e.g., for speech corresponding to low variance that encourages voiced speech only). This can be achieved by a monotonically increasing concave function of the prediction variance. Logarithms can be used for this purpose, as logarithms can be invariant with scale. The effect of small variances becoming smaller can be equivalent to the effect of large variances becoming smaller by the same proportion. Thus:
can use
J var ({x},W)＝E data log(σ q +a) (11)，
Wherein a provides a floor.
A second technique for modifying the maximum likelihood criterion to prevent the vanishing support problem of kulbeck-leber divergence can be to use a baseline distribution. For example, the following form of mixing profile is used:
Wherein the parameter alpha 0 Set by the designer and wherein the first term is omitted during inference (other terms can pass through a factor γ k /(1-γ 0 And (5) carrying out renormalization).
By selecting alpha 0 To provide an excessively wide distribution, the distribution for inference can be low variance.
In an example embodiment, consider an input signal with a sampling rate of S Hz. To avoid the need to model the added independent signals, the inputs can be preprocessed with real-time TasNet at the time of inference. The encoder is capable of converting the signal into a sequence of logarithmic mel-spectra. A subsequent set of logarithmic mel spectra can be stacked into a supervector that can undergo the Karhunen-loeve transform (KLT). The stacked log mel spectrum of the transform can be encoded using partition vector quantization, where each partition has a small number of coefficients. In an example embodiment, no other information may be encoded.
The decoder is capable of decoding the bitstream into a sequence of quantized log mel spectra. These spectra can form the input of a conditional stack that includes a set of one-dimensional (1D) convolution layers. In addition to the first convolution layer, the 1D convolution layer can include dilation. The output can be a vector sequence having dimensions equal to the gated loop unit (GRU) states and the sampling rate can be equal to the sampling rate of the mel spectrum of the encoder.
The autoregressive network can include multiband WaveGRU based on gated loop units. For an N-band WaveGRU, N samples can be generated simultaneously, one sample per band, at the update rate of S/NHz. For each update, the state of the GRU network can be projected onto an nxkx3 dimensional space defining N parameter sets. Each parameter set can correspond to a logical mix of frequency bands. The value of the next signal sample for each band can be extracted by first selecting a mixed component (e.g., a logical distribution) based on the band probabilities, and then extracting samples from the logical distribution by transforming samples from the uniform distribution. For each set of N samples, the synthesis filter bank is capable of generating N subsequent time domain samples. The time domain samples can produce an output at a sample rate of SHz.
The input of WaveGRU can include the addition of autoregressions and conditional components. The autoregressive component can be the projection of the last N band samples onto the dimensionality vector of the WaveGRU state. The second component can be the output of the conditional stack (e.g., in the dimension of the WaveGRU state), repeated in time to obtain the correct sample rate of S/NHz.
Training of the GRU network and the condition stack can be performed simultaneously using forced teaching. In other words, the past signal samples provided as inputs to the GRU can be true value signal samples. An objective function equation (10) combining log-likelihood (cross entropy) and variance regularization can be used for each subsequent signal sample.
Fig. 2A and 2B illustrate block diagrams of an audio processing system in accordance with at least one example embodiment. As shown in fig. 2A and 2B, the audio processing system 200 includes at least one processor 205, at least one memory 210, and a controller 220. Fig. 2A illustrates components of a system 200 for encoding an audio signal into a bitstream at a computing device for transmission from the computing device to another computing device. Fig. 2B illustrates components of a system 200 for decoding a bitstream received at a computing device from another computing device and reconstructing/synthesizing an audio signal from the decoded bitstream. Components of system 200 can be included in computing devices 115 and 120 such that devices 115 and 120 can process audio signals for transmission as a bitstream to another device, and can receive a bitstream from another device and process the received bitstream to synthesize an audio signal for rendering to a user. As shown in fig. 2A, the audio processing system 200 can include a sample 225 block, a time domain separator 230 block, a converter 235 block, a transformer 240 block, and a quantizer 245 block. As shown in fig. 2B, the audio processing system 200 can include a power 250 block, a convolution 255 block, and a reconstruction 260 block. The at least one processor 205, the at least one memory 210, the controller 220, the sample 225 block, the time domain separator 230 block, the converter 235 block, the transformer 240 block, the quantizer 245 block, the power 250 block, the convolution 255 block, and the reconstruction 260 block are communicatively coupled via the bus 215. In fig. 2A and 2B, the solid line represents a control link and the broken line represents a data link.
The instructions stored on the at least one memory 210 may be executable with the at least one processor 205 to implement the various features and functions described herein, or additional or alternative features and functions. The at least one processor 205 may be a general purpose processor. The at least one processor 205 may be a Graphics Processing Unit (GPU) and/or an Audio Processing Unit (APU). The at least one processor 205 and the at least one memory 210 may be used for various other purposes. In particular, the at least one memory 210 can represent various types of memory and examples of related hardware and software that can be used to implement any of the modules described herein.
The at least one memory 210 may be configured to store data and/or information associated with the audio processing system 200. For example, the at least one memory 210 may be configured to store code associated with implementing a communication application including a codec that uses a regression (e.g., autoregressive) model. For example, the at least one memory 210 may be configured to store code associated with encoding/decoding audio data (e.g., an audio stream or utterance) using a regression (e.g., autoregressive) model. The at least one memory 210 may be a non-transitory computer-readable medium having code that, when executed by the processor 205, causes the processor 205 to implement one or more techniques described herein. The at least one memory 210 may be a shared resource. For example, audio processing system 200 can be an element of a larger system (e.g., a server, personal computer, mobile device, etc.). Accordingly, the at least one memory 210 may be configured to store data and/or information associated with other elements within the larger system (e.g., web browsing, cameras, games, etc.).
The controller 220 may be configured to generate and deliver various control signals to various blocks in the audio processing system 200. The controller 220 may be configured to generate control signals to implement the techniques described herein. The controller 220 may be configured to control data for the codec based on a regression model.
Referring to fig. 2A, an audio stream 5 is input to an audio processing system 200. The audio processing system 200 can be configured to generate a bitstream 10 (e.g., a compressed audio bitstream) based on the audio stream 5. The bit stream 10 can be delivered as an operation of a communication application. For example, the applications 125, 130 can be used to transport the bit stream 10 from the device 115 to the device 120. For example, the applications 125, 130 can be used to transport the bit stream 10 from the device 120 to the device 115.
The block of samples 225 can be configured to sample the audio stream 5. Sampling can include generating a discrete-time signal representing the audio stream 5 using a sampling rate of S Hz. The sampling rate can be directly proportional to the bit rate. Thus, the lower the sampling rate, the lower the bit rate. Thus, the sampling rate can lead to compression of the audio stream 5. In other words, the lower the sampling rate S, the more compressed the audio stream 5 can be (keeping the bit depth or number of bits used to store the sampled audio stream 5 constant). Thus, the sampling rate S may be chosen such that (or help to make) the bit rate of the audio stream as low as, for example, 3kb/S.
The time domain separator 230 block may be configured to separate the speech, avoiding the need to model the added independent signals. In some embodiments, the sampled audio stream 5 can be processed to separate individual speech signals in the sampled audio stream 5 and/or to suppress noise in the separated individual speech signals. In some embodiments, the real-time TasNet (time-domain audio separation network) can apply a set of weighting functions (or masks) to the sampled audio stream 5 to separate the speech and perform noise suppression. In other words, to separate each speaker that may be heard in the utterance represented by the sampled audio stream 5, a weighted mask can be applied to the sampled audio stream. In some embodiments, tasNet, which has only one output channel, can be used to suppress noise and mask all but one speech channel by multiplying the (learning-represented) component that does not belong to one speech signal. The result can be that the user (e.g., users 105, 110) can be the focus of the audio processing system 200 by isolating the user using a mask and filtering out any background speech.
The converter 235 block can be configured to parameterize the separated audio streams. In an example embodiment, the separate audio streams can be converted into a sequence of logarithmic mel spectra, and these spectra can form an input comprising a conditional stack of one-dimensional (1D) convolution layers. The logarithmic mel-frequency spectrum can be a representation of the short-term power spectrum of the separated audio stream 5, based on a linear cosine transform of the logarithmic power spectrum on a nonlinear mel-frequency scale. A set of resulting log mel spectra can be stacked into a supervector. To quantify speech (e.g., utterances) associated with a user (e.g., users 105, 110), the log-mel spectrum can be adapted to a gaussian mixture model to enable the user to effectively shift the mean to a certain direction. The adaptation direction is a real-valued vector that characterizes the user. This is sometimes referred to as a supervector.
The transformer 240 block can be configured to apply a card Hu Na-peff transform (KLT) to a logarithmic mel spectrum (e.g., a supervector) corresponding to the audio stream 5. KLT is a linear transformation in which the basis function is taken from the statistics of the signal (e.g., logarithmic mel spectrum or supervector). The KLT can be an adaptive transform (e.g., adaptive to audio power). KLT can be the best transform related to energy compression. In other words, the KLT is able to put as much energy as possible into as few coefficients as possible.
The quantizer 245 block can be configured to quantize energy (e.g., power or coefficients) associated with the transformed audio stream 5. For example, stacked log mel spectra of transforms are encoded using partition vector quantization, where each partition has a small number of coefficients. Quantization of energy can refer to assigning energy (e.g., a stacked log mel spectrum of transforms) to discrete energy levels. In split vector quantization, the coefficients of the log mel spectrum or supervector can be split into p equally sized groups. If the groups are not equal in size, the remaining coefficients can be added to one of the groups or put into their own smaller group.
Referring to fig. 2B, the bitstream 10 is input into an audio processing system 200. The audio processing system 200 can be configured to synthesize the audio stream 5 (e.g., as a reconstructed audio stream) based on the received bitstream 10. The audio stream 5 can be synthesized (e.g., reconstructed) based on the bitstream 10 using a generative model. The bit stream 10 can be received as an operation of a communication application. For example, the application 125, 130 can be used to receive the bit stream 10 from the device 120 through the device 115. For example, the application 125, 130 can be used to receive the bit stream 10 from the device 115 through the device 120.
The power 250 block can be configured to generate a sequence of quantized log mel spectra based on the bit stream 10. For at least a portion of the bitstream 10 corresponding to at least a portion of the audio stream 5, the sequence of quantized log mel-spectra should substantially match the stacked log mel-spectra of the transforms input to the quantizer 245.
The convolution 255 block can be configured to generate a vector sequence based on the quantized log mel spectrum. The quantized log mel-spectrum sequence can be an input to a conditional stack that includes a set of one-dimensional (1D) convolution layers. In addition to the first convolution layer, the 1D convolution layer can include dilation. The output can be a vector sequence having dimensions equal to the gated loop unit (GRU) states and the sampling rate can be equal to the sampling rate of the mel spectrum of the encoder.
The reconstruction 260 block can be configured to generate an audio stream reconstruction of a corresponding encoded audio stream (e.g., a bitstream). The reconstruction 260 block can be configured to use a regression (e.g., autoregressive) network to generate an audio stream reconstruction (e.g., reconstructed audio stream 5). The regression network can include multiband WaveGRU based on gated loop units. For an N-band WaveGRU, N samples can be generated simultaneously, one sample per band, at an update rate of S/N Hz. For each update, the state of the GRU network can be projected onto an nxkx3 dimensional space defining N parameter sets. Each parameter set can correspond to a logical mix of frequency bands. The value of the next signal sample for each band can be extracted by first selecting a mixed component (e.g., a logical distribution) based on the band probabilities, and then extracting samples from the logical distribution by transforming samples from the uniform distribution. For each set of N samples, the synthesis filter bank is capable of generating N subsequent time domain samples. The time domain samples can produce an output (e.g., reconstructed audio stream 5 or speech) at a sampling rate of S Hz.
FIG. 3 shows a block diagram of a model training system in accordance with at least one example embodiment. As shown in fig. 3, model training system 300 includes at least one processor 305, at least one memory 310, a controller 320, a sample 325 block, a time domain separator 330 block, an evaluator and modifier 335 block, a transformer 340 block, a quantizer 245 block, a reconstruction 350 block, and a comparison 355 block. The at least one processor 305, the at least one memory 310, the controller 320, the sample 325 block, the time domain separator 330 block, the converter 335 block, the transformer 340 block, the quantizer 245 block, the reconstruction 350 block, and the evaluator and modifier 355 block are communicatively coupled via a bus 315. In fig. 3, a solid line represents a control link and a broken line represents a data link.
The at least one processor 305 may be utilized to execute instructions stored on the at least one memory 310 to implement the various features and functions described herein, or additional or alternative features and functions. The at least one processor 305 may be a general purpose processor. The at least one processor 305 may be a Graphics Processing Unit (GPU) and/or an Audio Processing Unit (APU). The at least one processor 305 and the at least one memory 310 may be used for various other purposes. In particular, the at least one memory 310 can represent examples of various types of memory and related hardware and software that can be used to implement any of the modules described herein.
The at least one memory 310 may be configured to store data and/or information associated with the audio processing system 300. For example, the at least one memory 310 may be configured to store code associated with training a regression (e.g., autoregressive) model for encoding audio (e.g., speech). For example, the at least one memory 310 may be configured to store code associated with force teaching regression model training and removing noise from audio data used in force teaching. The at least one memory 310 may be a non-transitory computer-readable medium having code that, when executed by the processor 305, causes the processor 305 to implement one or more techniques described herein. The at least one memory 310 may be a shared resource. For example, model training system 300 may be an element of a larger system (e.g., a server, personal computer, mobile device, etc.). Accordingly, the at least one memory 310 may be configured to store data and/or information associated with other elements within a larger system.
The controller 320 may be configured to generate and convey various control signals to various blocks in the model training system 300. The controller 320 may be configured to generate control signals to implement the techniques described herein. The controller 320 may be configured to control the evaluator and modifier 355 block to evaluate the objective function associated with the recursive model and to modify the weights associated with the objective function in response to the evaluation. The modification weights can be performed in response to determining whether the objective function equation 4 has been minimized during the training process.
As shown in fig. 3, audio stream 5 is input to model training system 300. The block of samples 325 can be configured to sample the audio stream 5. Sampling can include generating a discrete-time signal representing the audio stream 5 using a sampling rate S Hz.
The time domain separator 330 block can be configured to separate speech. To avoid the need to model the added independent signals, the sampled audio stream 5 can be processed with real-time TasNet (time-domain audio separation network) to separate speech and/or suppress noise. TasNet can apply a set of weighting functions (or masks) to separate speech. In other words, to separate each speaker that may be heard in the utterance represented by the sampled audio stream 5, a weighted mask can be applied to the sampled audio stream. The result can be that the user (e.g., 105, 110) can be the focus of the audio processing system 200 by isolating the user using a mask and filtering out any background speech.
The converter 335 block can be configured to convert the separated audio stream into a log mel-spectrum sequence. These spectra can form the input of a conditional stack that includes a set of one-dimensional (1D) convolution layers. The logarithmic mel-frequency spectrum can be a representation of the short-term power spectrum of the separated audio stream, based on a linear cosine transform of the logarithmic power spectrum on a nonlinear mel-frequency scale. A set of resulting log mel spectra can be stacked into a supervector. To quantify speech (e.g., utterances) associated with a user (e.g., users 105, 110), the log-mel spectrum can be adapted to a gaussian mixture model to enable the user to effectively shift the mean to a certain direction. The adaptation direction is a real-valued vector that characterizes the user. This is sometimes referred to as a supervector.
The transformer 340 block can be configured to apply a card Hu Na-peff transform (KLT) to a logarithmic mel spectrum (e.g., a supervector) corresponding to the audio stream 5. KLT is a linear transformation in which the basis function is taken from the statistics of the signal (e.g., logarithmic mel spectrum or supervector). The KLT can be an adaptive transform (e.g., adaptive to audio power). KLT can be the best transform related to energy compression. In other words, the KLT is able to put as much energy as possible into as few coefficients as possible.
The quantizer 345 block can be configured to quantize energy (e.g., power or coefficients) associated with the transformed audio stream 5. For example, stacked log mel spectra of transforms are encoded using partition vector quantization, where each partition has a small number of coefficients. Quantization of energy can refer to assigning energy (e.g., a stacked log mel spectrum of transforms) to discrete energy levels. In split vector quantization, the coefficients of the log mel spectrum or supervector can be split into p equally sized groups. If the groups are not equal in size, the remaining coefficients can be added to one of the groups or put into their own smaller group.
Example embodiments can include two techniques that can reduce the impact of hard-to-predict data points (e.g., low probability data) in a training set. The first technique is able to modify the maximum likelihood criterion by adding a term to the objective function that encourages a low variance prediction distribution. In other words, regularization terms can be used in the objective function to attenuate the effects of outlier data (e.g., high differential entropy data) during model training.
As discussed in equations (4) - (10) above, for signals with uniform overall signal variance, it may be desirable to set a low prediction variance for regions with relatively low conditional differential entropy (e.g., for speech corresponding to low variance that encourages voiced speech only). This can be achieved by a monotonically increasing concave function of the prediction variance. Logarithms can be used for this purpose, as logarithms can be invariant with scale.
A second technique for modifying the maximum likelihood criterion can be to prevent the vanishing support problem of kulbeck-leber divergence by using the baseline distribution as discussed above with respect to equation 12. In an example embodiment, the distribution for inference can be selected to have a low variance.
The reconstruction 350 block can be configured to generate an audio stream reconstruction of a corresponding encoded audio stream (e.g., a bitstream). The reconstruction 260 block can be configured to reconstruct the audio stream using a Machine Learning (ML) model. The reconstruction 350 block can be configured to pass the result of executing the objective function equation 4 to the evaluator and modifier 355 block.
The effect of reducing noise when training a generated model can reduce the sensitivity of the model to distortion when the model is used to decompress an audio stream that includes some noise. For example, the cause of sensitivity can be associated with an attribute of a Log Likelihood (LL) objective function. The LL objective function incurs a penalty if the model assigns a low probability to the observation data. Thus, in the context of an autoregressive structure, assigning low probabilities to observed data can encourage an overly broad predictive distribution when at least some training data is difficult to accurately predict from past signals and conditions. Thus, the reconstruction 350 block can be configured to mitigate the effect of assigning low probabilities to observed data on the LL objective function during training of the ML model.
The ML model can include a regression (e.g., autoregressive) network to generate an audio stream reconstruction (e.g., reconstructed audio stream 5) of the input audio stream. The regression network can include multiband WaveGRU based on gated loop units. For an N-band WaveGRU, N samples can be generated simultaneously, one sample per band, at an update rate of S/N Hz. For each update, the state of a gated loop unit (GRU) network can be projected onto an nxkx3 dimensional space defining N parameter sets. Each parameter set can correspond to a logical mix of frequency bands. The value of the next signal sample for each band can be extracted by first selecting a mixed component (e.g., a logical distribution) based on the band probabilities, and then extracting samples from the logical distribution by transforming samples from the uniform distribution. For each set of N samples, the synthesis filter bank is capable of generating N subsequent time domain samples. The time domain samples are capable of producing an output at a sampling rate of S Hz.
The evaluator and modifier 355 block can be configured to enable training of the regression model. In an example embodiment, training of the regression model (e.g., as a GRU network and a conditional stack) can be performed simultaneously using forced teaching, where past signal samples are provided as true value signal samples as inputs to the model. The objective function of equation 4 can be used for each subsequent signal sample. The evaluator and modifier 355 block can evaluate the result of the objective function equation 4 from the current iteration against the result of the objective function equation 4 of at least one previous iteration of the training period. The evaluator and modifier 355 block can be configured to minimize the objective function including regularization term equation 4, for example, using a random gradient descent or correlation method, which can maximize the likelihood of the training data as shown in equation 2.
If the result of the evaluation passes the criterion, the training can end. For example, the criterion can be based on minimizing objective function equation 4. If the modification of the weights results in a change in the result of the objective function below a threshold, the evaluation can be considered to pass the criterion. If the result of the evaluation fails the criteria, the regression model can be modified (e.g., the weights associated with the recursive model or the GRU network can be changed), e.g., using a random gradient descent or correlation method, and training can continue.
Fig. 4 and 5 are flowcharts of methods according to example embodiments. The methods described with respect to fig. 4 and 5 may be performed due to execution of software code stored in a memory (e.g., a non-transitory computer-readable storage medium) associated with the apparatus and executed by at least one processor associated with the apparatus.
However, alternative embodiments are also contemplated, such as systems embodied as special purpose processors. The special purpose processor can be a Graphics Processing Unit (GPU) and/or an Audio Processing Unit (APU). The GPU can be a component of a graphics card. The APU can be a component of a sound card. The graphics card and/or sound card can also include video/audio memory, random access memory digital to analog converter (RAMDAC), and driver software. The video/audio memory can be a frame buffer that stores digital data representing images, video frames, audio data associated with the frames, and/or streaming audio. The RAMDAC can be configured to read the contents of the video/audio memory, convert the contents to analog signals, and send the analog signals to a display/monitor and/or speaker. The driver software can be software code stored in the memory. The software code can be configured to implement the methods described herein.
Although the methods described below are described as being performed by a processor and/or a special purpose processor, the methods are not necessarily performed by the same processor. In other words, at least one processor and/or at least one dedicated processor may perform the methods described below with respect to fig. 4 and 5.
Fig. 4 shows a flow chart of a method for delivering audio in accordance with at least one example embodiment. As shown in fig. 4, in step S405, sampled audio data corresponding to a first utterance is received at a first device. For example, the audio stream 5 can be sensed by the computing device 115, 120 executing the communication application 125, 130. The audio stream 5 can be sampled. For example, sampling can include generating a discrete-time signal representing the audio stream 5 using a sampling rate S Hz. The sampling rate can be directly proportional to the bit rate. Thus, the lower the sampling rate, the lower the bit rate. Thus, the sampling rate can lead to compression of the audio stream 5. In other words, the lower the sampling rate S, the more compressed the audio stream 5 can be (keeping the bit depth or number of bits used to store the sampled audio stream 5 constant). Thus, the sampling rate S can be chosen such that (or help to make) the bit rate of the audio stream as low as, for example, 3kb/S.
In step S410, the sampled audio signal is separated in the time domain and noise in the signal is suppressed. For example, the sampled audio stream 5 can be pre-processed with a real-time TasNet (time-domain audio separation network) to separate speech and reduce noise. TasNet can apply a set of weighting functions (or masks) to separate speech and/or suppress noise. In other words, in order to separate each speaker that may be heard in the utterance represented by the sampled audio stream 5 and suppress noise, a weighted mask can be applied to the sampled audio stream. The result can be that the user (e.g., users 105, 110) can be the focus of the audio processing by using a mask to isolate the user and filtering out any background speech.
In step S415, the separated sampled audio signal is converted into parameters characterizing the speech signal. For example, the parameter characterizing the speech signal can be a sequence of vectors. For example, the separated audio stream can be converted into a logarithmic mel-spectrum sequence. These spectra can form the input of a conditional stack that includes a set of one-dimensional (1D) convolution layers. The logarithmic mel-frequency spectrum can be a representation of the short-term power spectrum of the separated audio stream, based on a linear cosine transform of the logarithmic power spectrum on a nonlinear mel-frequency scale. A set of resulting log mel spectra can be stacked into a supervector. To quantify speech (e.g., utterances) associated with a user (e.g., users 105, 110), the log-mel spectrum can be adapted to a gaussian mixture model to enable the user to effectively shift the mean to a certain direction. The adaptation direction is a real-valued vector that characterizes the user. This is sometimes referred to as a supervector.
In step S420, a first bitstream representing the utterance is generated by quantizing the transformation parameters characterizing the speech signal. For example, the vector sequence can be transformed. In an example implementation, the card Hu Na-peff transform (KLT) can be applied to a logarithmic mel spectrum (e.g., a supervector) corresponding to the audio stream 5. KLT is a linear transformation in which the basis function is taken from the statistics of the signal (e.g., logarithmic mel spectrum or supervector). The KLT can be an adaptive transform (e.g., adaptive to audio power). KLT can be the best transform related to energy compression. In other words, the KLT is able to put as much energy as possible into as few coefficients as possible. For example, energy (e.g., power or coefficients) associated with the transformed audio stream 5 can be quantized. The stacked log mel spectrum of the transform can be encoded using partition vector quantization, where each partition has a small number of coefficients. Quantization of energy can refer to assigning energy (e.g., a stacked log mel spectrum of transforms) to discrete energy levels. In split vector quantization, the coefficients of the log mel spectrum or supervector can be split into p equally sized groups. If the groups are not equal in size, the remaining coefficients can be added to one of the groups or put into their own smaller group.
In step S425, the first bitstream is transmitted from the first device to the second device so that the second device decodes the bitstream and synthesizes an audio signal based on the decoded bitstream. For example, the bitstream 10 delivered from the computing device 115 to the computing device 120 can be a first bitstream.
In step S430, the first device receives a second bitstream from the second device, the second bitstream representing a speech signal of the second utterance. For example, the bitstream received by computing device 115 from computing device 120 can be a second bitstream, which can then be decoded and used to synthesize an audio signal at the receiving computing device using a trained machine learning model.
In step S435, a sequence of quantization parameters characterizing the speech signal is created based on the second bitstream. For example, a quantized log mel-spectrum sequence can be created based on the received bitstream. For at least a portion of the received bitstream, the sequence of quantized log-mel spectra should substantially match the stacked log-mel spectra of transforms input to a quantizer of the computing device generating the received bitstream.
In step S440, a vector sequence is generated based on the inverse transformation of the quantization parameter representing the speech signal. For example, a vector sequence can be created based on inverse transformed quantized logarithmic mel spectrum. The quantized log mel-spectrum sequence can then be the input to a conditional stack that includes a set of one-dimensional (1D) convolutional layers. In addition to the first convolution layer, the 1D convolution layer can include dilation. The output can be a vector sequence having dimensions equal to the gating loop (GRU) state, and the sampling rate can be equal to the sampling rate of the mel spectrum of the encoder.
In step S445, the second utterance is regenerated based on the vector sequence using a trained regression (e.g., autoregressive) network. For example, the regression network can be used to create an audio stream reconstruction (e.g., reconstructed audio stream 5). The regression network can include multiband WaveGRU based on gated loop units. For an N-band WaveGRU, N samples can be created simultaneously, one sample per band, at an update rate of S/N Hz. For each update, the state of the GRU network can be projected onto an nxkx3 dimensional space defining N parameter sets. Each parameter set can correspond to a logical mix of frequency bands. The value of the next signal sample for each band can be extracted by first selecting a mixed component (e.g., a logical distribution) based on the band probabilities, and then extracting samples from the logical distribution by transforming samples from the uniform distribution. For each set of N samples, the synthesis filter bank is able to create N subsequent time domain samples. The time domain samples can produce an output (e.g., a reconstructed audio signal or utterance) at a sampling rate of S Hz. The reconstructed audio can be converted (e.g., using a digital-to-analog converter) into an analog audio signal for playback on a speaker of the first device.
FIG. 5 shows a flow chart of a method for training a model in accordance with at least one example embodiment. As shown in fig. 5, in step S505, sampled audio data corresponding to an utterance is received. For example, a database comprising at least one speech segment (e.g., utterance) data set can be used as audio data. Sampling can include using a sampling rate S Hz to create a discrete-time signal representing audio data (e.g., audio stream 5). The sampling rate can be directly proportional to the bit rate. The database can be a publicly available database.
In step S510, a Machine Learning (ML) model is trained based on sampled audio data by including regularization terms in an objective function of the ML model. Example implementations can include training an ML model to generate a high-fidelity audio bitstream from a low bit-rate input bitstream. Training of the ML model can include attenuating (e.g., minimizing the effects of) the impact of low probability distortion events in the sampled audio data on the trained ML model. In other words, the effect of noise in the audio on training of the ML model can be minimized. Attenuation of distortion events can be achieved by including terms (e.g., regularized terms) in the objective function of the ML model. This term (e.g., regularization term) can encourage a low variance predictive distribution of the next sample in the sampled audio data.
Example embodiments can include two techniques that can reduce the impact of hard-to-predict data points (e.g., low probability data) in a training set. The first technique is able to modify the maximum likelihood criterion by adding a term to the objective function that encourages a low variance prediction distribution.
As discussed in equations (4) - (10) above, for signals with uniform overall signal variance, it may be desirable to set a low prediction variance for regions with relatively low conditional differential entropy (e.g., for speech corresponding to low variance that encourages voiced speech only). This can be achieved by a monotonically increasing concave function of the prediction variance. Logarithms can be used for this purpose, as logarithms can be invariant with scale.
A second technique for modifying the maximum likelihood criterion can include preventing the vanishing support problem of kulbeck-leber divergence by using the baseline distribution as discussed above with respect to equation 12. In an example embodiment, the distribution for inference can be selected to have a low variance.
The sampled audio signal can be separated in the time domain before training the ML model. In an example embodiment, separating speech can include noise suppression. For example, the sampled audio stream 5 can be pre-processed with a real-time TasNet (time-domain audio separation network) to separate speech and suppress noise. TasNet can apply a set of weighting functions (or masks) to separate speech and suppress noise. In other words, in order to separate each speaker that may be heard in the utterance represented by the sampled audio stream 5 and suppress noise, a weighted mask can be applied to the sampled audio stream. The result can be that the user (e.g., users 105, 110) can be the focus of the audio processing by using a mask to isolate the user and filtering out any background speech.
The separated sampled audio signal can be converted into parameters characterizing the speech signal. For example, the separated audio stream can be converted into a logarithmic mel-spectrum sequence. These spectra can form the input of a conditional stack that includes a set of one-dimensional (1D) convolution layers. The logarithmic mel-frequency spectrum can be a representation of the short-term power spectrum of the separated audio stream, based on a linear cosine transform of the logarithmic power spectrum on a nonlinear mel-frequency scale. A set of resulting log mel spectra can be stacked into a supervector. To quantify speech (e.g., utterances) associated with a user (e.g., users 105, 110), the log-mel spectrum can be adapted to a gaussian mixture model to enable the user to effectively shift the mean to a certain direction. The adaptation direction is a real-valued vector that characterizes the user. This is sometimes referred to as a supervector.
Parameters characterizing the speech signal can be transformed. For example, the card Hu Na-peff transform (KLT) can be applied to a logarithmic mel spectrum (e.g., a supervector) corresponding to the audio stream 5. KLT is a linear transformation in which the basis function is taken from the statistics of the signal (e.g., logarithmic mel spectrum or supervector). The KLT can be an adaptive transform (e.g., adaptive to audio power). KLT can be the best transform related to energy compression. In other words, the KLT is able to put as much energy as possible into as few coefficients as possible.
The energy (e.g., power or coefficients) associated with the transformed audio stream 5 can be quantized. For example, stacked log mel spectra of transforms are encoded using partition vector quantization, where each partition has a small number of coefficients. Quantization of energy can refer to assigning energy (e.g., a stacked log mel spectrum of transforms) to discrete energy levels. In split vector quantization, the coefficients of the log mel spectrum or supervector can be split into p equally sized groups. If the groups are not equal in size, the remaining coefficients can be added to one of the groups or put into their own smaller group.
Training the ML model can include reconstructing the utterance by inputting quantized audio data (e.g., as compressed audio data or a low bit rate input bitstream) into a regression (e.g., autoregressive) network, which can be based on the gating loop unit. For example, a regression (e.g., autoregressive) network can be used to generate an audio stream reconstruction (e.g., reconstructed audio stream 5). The regression network can include multiband WaveGRU based on gated loop units. For an N-band WaveGRU, N samples can be generated simultaneously, one sample per band, at the update rate of S/NHz. For each update, the state of the GRU network can be projected onto an nxkx3 dimensional space defining N parameter sets. Each parameter set can correspond to a logical mix of frequency bands. The value of the next signal sample for each band can be extracted by first selecting a mixed component (e.g., a logical distribution) based on the band probabilities, and then extracting samples from the logical distribution by transforming samples from the uniform distribution. For each set of N samples, the synthesis filter bank is capable of generating N subsequent time domain samples. The time domain samples can produce an output at a sample rate of SHz.
Training the ML model can further include modifying the regression network based on comparing the reconstructed utterance to the true value samples. For example, the regression network can be modified based on training of the regression model. In an example embodiment, training of the regression model (e.g., as a GRU network and conditional stack) can be performed simultaneously using forced teaching, where past signal samples are provided as real-valued signal samples as inputs to the model, and the model is trained to maximize the likelihood of observed signal data, assuming that the past signal samples represent the real-valued data. The evaluation of model training can be based on cost or loss functions. The cost or loss function can be used to evaluate the comparison against a predefined criterion. The cost or loss function can be, for example, maximum Likelihood Estimation (MLE), MLE and cross entropy, mean Square Error (MSE), logarithmic loss, etc.
If the result of the loss function passes the criterion, the training can end. If the result of the loss function fails the criteria, the regression model can be modified (e.g., the weights associated with the recursive model or the GRU network can be changed), and training can continue. Thus, the past signal samples (e.g., sampled audio stream 5) can be true value signal samples in the forced teaching algorithm. An objective function equation (10) combining log-likelihood (cross entropy) and variance regularization can be used for each subsequent signal sample.
Training a Machine Learning (ML) model can include training the ML model to generate a high-fidelity audio bitstream from a low bit-rate input bitstream. Training of the ML model can include attenuating the impact of low probability distortion events in the sampled audio data on the trained ML model. For example, an utterance with noise can include noise that can lead to low probability distortion events in the sampled audio data. Attenuation of distortion events (e.g., minimizing the effect or impact of noise on training of the ML model) is achieved by including terms (e.g., regularization terms) in the objective function of the ML model. This term can encourage a low variance predictive distribution of the next sample in the sampled audio data. Thus, an objective function with regularization terms can include modifications to the objective function associated with the ML model. The objective function can include a regularization term that can reduce the effect of noise on the ML model, and reduce the effect of noise can reduce the sensitivity of the generated model to distortion.
The following example illustrates the performance of a trained ML model based on prediction variance regularization and noise suppression. The present example uses eight systems, all based on a variation of a single baseline system operating with a 16kHz sampling signal. The baseline system was adjusted using a 160-dimensional logarithmic mel-spectrum sequence calculated from an 80ms window at an update rate of 50 Hz. The system uses four frequency bands, each with a sampling frequency of 4kHz. The conditional stack consists of a single non-causal input layer (giving 40ms look ahead and extending from 160 channels to 512 channels), three kernel-size 2 dilation causal convolutional layers, and three upsampling transpose convolutional layers (kernel size 2). The conditional output is tiled to match the GRU update frequency. The GRU status dimension is 1024. These eight systems differ in the logical mix components used for the per-band predictive allocation.
The system trains 750 ten thousand steps from the randomly initialized weights W, using a small batch of 256. The target signal and the forced teaching autoregressive input audio come from a combination of clean and noisy sources. In some cases, additional noise is added, with a random signal-to-noise ratio (SNR) between 0 and 40dB SNR.
Table 1 shows decoder attribute combinations (i.e., variance regularization (v), noise suppression (t), quantization (q), and pruning) for eight systems (i.e., baseline systems labeled "b", and systems labeled "v", "t", "vt", "q", "qv", "qt", and "qvt"), and each attribute is briefly discussed below. Variance regularization is applied only to the first two bands and scales the parameter v in equation 4 with the voicing fraction. Noise suppression is applied using a version of the full convolution time domain audio separation network (Conv-TasNet). The system is quantized to 120 bits per supervector, each supervector containing two log mel spectra, which means a rate of 3 kb/s. Quantization is two-dimensional vector quantization of KLT coefficients. The weight pruning attribute is selected to enable the model to be implemented on the consumer device. For three GRU matrices, a block diagonal matrix with 16 blocks was used, which used 93% less weight than the fully connected model. For other hidden layers, iterative magnitude pruning is used to remove 92% of the model weights. Pruning allows the codec to reliably operate on a user device, such as a Pixel 2 phone, in single-threaded mode.
System marking | b | v | t | vt | q | qv | qt | qvt |
Variance regularization | √ | √ | √ | √ | ||||
Noise suppression | √ | √ | √ | √ | ||||
3kb/s quantization | √ | √ | √ | √ | ||||
93% trimming | √ | √ | √ | √ |
TABLE 1
In this example, to evaluate the absolute quality of different systems at different SNRs, a Mean Opinion Score (MOS) hearing test was performed according to ITU-t p.800 recommendations. Data is collected using a crowdsourcing platform, requiring listeners to be people in native english and headphones. The evaluation dataset consisted of 30 samples of noisy VCTK datasets from a voice cloning kit at the center of speech technology, of which 15 samples were clean (i.e., no noise samples) and 15 samples increased additive noise at SNR of 2.5dB, 7.5dB and 12.5 dB. Each utterance for each system was evaluated approximately 40 times and the average and 95% confidence interval for each SNR was calculated.
Fig. 6A and 6B are bar graphs illustrating the quality of the system of table 1 based on MOS values.
Fig. 6A shows the effect of prediction variance regularization and noise suppression without weight pruning and quantization. For each clean sample, and samples with SNR of 12.5dB, 7.5dB, and 2.5dB MOS values, we present: baseline systems (with and without noise suppression), systems with prediction variance regularization (with and without noise suppression), and untreated signals as references (with and without noise suppression). As can be seen in fig. 6A, prediction variance regularization results in significant quality improvement and reduced sensitivity to noise in the input signal. Noise suppression in the presence of noise helps to improve performance.
Fig. 6B illustrates the quality of an embodiment including pruning and quantization that may be used in consumer devices with limited processing capabilities. For each clean sample, and samples with SNR of 12.5dB, 7.5dB, and 2.5dB MOS values, we present: an Opus codec operating at 6 kb/s; a generative model system with quantized 3 kb/s; a 3kb/s generative model system with quantization and noise suppression; a 3kb/s generative model system with quantization and prediction variance regularization; a 3kb/s generative model system with quantization, prediction variance regularization, and noise suppression; and an EVS codec operating at 5.9 kb/s. As can be seen from fig. 6B, the improvement in the generated model is particularly large for clean signals due to variance regularization. The effect of noise suppression varies in an unexpected manner with SNR and may be the result of an interaction between noise suppression and quantization, which may be related to noise suppression that reduces signal variability and quantization itself that reduces noise. FIG. 6B shows that a 3kb/s WaveGRU decoder implementation (e.g., a 3kb/s generative model system with prediction variance regularization) performs much better than a 6kb/s Opus and is similar to an EVS codec operating at 5.9 kb/s.
Fig. 7 illustrates an example of a computer device 700 and a mobile computer device 750 that may be used with the techniques described herein. Computing device 700 is intended to represent various forms of digital computers, such as laptops, desktops, workstations, personal digital assistants, servers, blade servers, mainframes, and other appropriate computers. Computing device 750 is intended to represent various forms of mobile devices, such as personal digital assistants, cellular telephones, smartphones, and other similar computing devices. The components shown herein, their connections and relationships, and their functions, are meant to be exemplary only, and are not meant to limit implementations of the invention described and/or claimed in this document.
The storage device 706 is capable of providing mass storage for the computing device 700. In one implementation, the storage device 706 may be or contain a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network, or other configurations. The computer program product can be tangibly embodied in an information carrier. The computer program product may also contain instructions that, when executed, perform one or more methods such as those described above. The information carrier is a computer-readable medium or machine-readable medium, such as the memory 704, the storage device 706, or memory on processor 702.
The high speed controller 708 manages bandwidth-intensive operations for the computing device 700, while the low speed controller 712 manages lower bandwidth-intensive operations. Such allocation of functions is merely illustrative. In one embodiment, the high speed controller 708 is coupled to the memory 704, the display 716 (e.g., via a graphics processor or accelerator), and to a high speed expansion port 710 that can accept various expansion cards (not shown). In an implementation, a low speed controller 712 is coupled to the storage device 706 and to a low speed expansion port 714. The low-speed expansion port, which may include various communication ports (e.g., USB, bluetooth, ethernet, wireless ethernet), may be coupled to one or more input/output devices, such as a keyboard, a pointing device, a scanner, or a network connection device (such as a switch or router), for example, through a network adapter.
The processor 752 is capable of executing instructions within the computing device 750, including instructions stored in the memory 764. The processor may be implemented as a chipset of chips that include separate and multiple analog and digital processors. For example, the processor may provide for coordination of the other components of the device 750, such as control of user interfaces, applications run by device 750, and wireless communication by device 750.
The processor 752 may communicate with a user through a control interface 758 and a display interface 756 coupled to a display 754. The display 754 may be, for example, a TFT LCD (thin film transistor liquid crystal display) or OLED (organic light emitting diode) display, or other suitable display technology. The display interface 756 may comprise suitable circuitry for driving the display 754 to present graphical and other information to a user. The control interface 758 may receive commands from a user and convert them for submission to the processor 752. In addition, an external interface 762 may be provided in communication with processor 752 to enable device 750 to communicate with other devices in the vicinity. For example, in some embodiments, the external interface 762 may provide wired communication, or in other embodiments, wireless communication, and multiple interfaces may also be used.
The memory may include, for example, flash memory and/or NVRAM memory, as discussed below. In one implementation, a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that, when executed, perform one or more methods such as those described above. The information carrier is a computer-readable medium or machine-readable medium, such as the memory 764, expansion memory 774, or memory on processor 752, for example, that may be received by transceiver 768 or external interface 762.
The device 750 may also communicate audibly using an audio codec 760, and the audio codec 760 may receive verbal information from a user and convert it to usable digital information. Audio codec 760 may likewise generate audible sound for a user, such as through a speaker in a handset of device 750. Such sound may include sound from voice telephone calls, may include sound recordings (e.g., voice messages, music files, etc.), and may also include sound generated by applications operating on device 750.
While example embodiments are susceptible to various modifications and alternative forms, embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that there is no intent to limit example embodiments to the particular forms disclosed, but on the contrary, example embodiments are to cover all modifications, equivalents, and alternatives falling within the scope of the claims. Like numbers refer to like elements throughout the description of the figures.
Various implementations of the systems and techniques described here can be implemented in digital electronic circuitry, integrated circuitry, specially designed ASICs (application specific integrated circuits), computer hardware, firmware, software, and/or combinations thereof. These various embodiments can include embodiments in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device. Various implementations of the systems and techniques described herein can be realized as and/or are generally referred to herein as a circuit, module, block, or system that can combine software and hardware aspects. For example, a module may include functionality/acts/computer program instructions to be executed on a processor (e.g., a processor formed on a silicon substrate, gaAs substrate, etc.) or some other programmable data processing apparatus.
Some of the above-described example embodiments are described as processes or methods depicted in a flowchart. Although a flowchart depicts operations as a sequential process, many of the operations can be performed in parallel, concurrently, or in synchronization. In addition, the order of operations may be rearranged. These processes may terminate when their operations are completed, but may also have additional steps not included in the figures. These processes may correspond to methods, functions, procedures, subroutines, and the like.
The methods discussed above (some of which are illustrated by flowcharts) may be implemented by hardware, software, firmware, middleware, microcode, hardware description languages, or any combination thereof. When implemented in software, firmware, middleware or microcode, the program code or code segments to perform the necessary tasks may be stored in a machine or computer readable medium such as a storage medium. The processor(s) may perform the necessary tasks.
For the purposes of describing example embodiments, specific structural and functional details disclosed herein are merely representative. However, the example embodiments may be embodied in many alternate forms and should not be construed as limited to only the embodiments set forth herein.
It will be understood that, although the terms first, second, etc. may be used herein to describe various elements, these elements should not be limited by these terms. These terms are only used to distinguish one element from another element. For example, a first element could be termed a second element, and, similarly, a second element could be termed a first element, without departing from the scope of example embodiments. As used herein, the term and/or includes any and all combinations of one or more of the associated listed items.
It will be understood that when an element is referred to as being connected or coupled to another element, it can be directly connected or coupled to the other element or intervening elements may be present. In contrast, when an element is referred to as being directly connected or directly coupled to another element, there are no intervening elements present. Other words used to describe the relationship between elements should be interpreted in the same manner (e.g., between pairs directly between, adjacent pairs directly adjacent, etc.).
The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of example embodiments. As used herein, the singular forms "a", "an" and "the" are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms "comprises," "comprising," "includes," and/or "including," when used herein, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and/or groups thereof.
It should also be noted that in some alternative implementations, the functions/acts noted may occur out of the order noted in the figures. For example, two figures shown in succession may in fact be executed concurrently or the figures may sometimes be executed in the reverse order, depending upon the functionality/acts involved.
Unless otherwise defined, all terms (including technical and scientific terms) used herein have the same meaning as commonly understood by one of ordinary skill in the art to which example embodiments belong. It will be further understood that terms, such as those defined in commonly used dictionaries, should be interpreted as having a meaning that is consistent with their meaning in the context of the relevant art and will not be interpreted in an idealized or overly formal sense unless expressly so defined herein.
Portions of the above example embodiments and corresponding detailed description are presented in terms of software, or algorithms and symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the means used by those skilled in the art to effectively convey the substance of their work to others skilled in the art. An algorithm, as the term is used here, and as it is used generally, is conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of optical, electrical, or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.
In the illustrative embodiments described above, references to acts and symbolic representations of operations that may be implemented as program modules or functional processes (e.g., in the form of flowcharts) include routines, programs, objects, components, data structures, etc., which perform particular tasks or implement particular abstract data types, and may be described and/or implemented using existing hardware at existing structural elements. Such existing hardware may include one or more Central Processing Units (CPUs), digital Signal Processors (DSPs), application specific integrated circuits, field Programmable Gate Arrays (FPGA) computers, and the like.
It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise, or as is apparent from the discussion, terms such as processing or computing or calculating or determining a display, or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical electronic quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.
It should also be noted that the software-implemented aspects of the example embodiments are typically encoded on some form of non-transitory program storage medium or implemented over some type of transmission medium. The program storage medium may be magnetic (e.g., a floppy disk or a hard drive) or optical (e.g., a compact disk read only memory or CD ROM), and may be read only or random access. Similarly, the transmission medium may be twisted wire pairs, coaxial cable, optical fiber, or some other suitable transmission medium known to the art. The example embodiments are not limited by these aspects of any given implementation.
Finally, it should also be noted that although the appended claims set forth a particular combination of features described herein, the scope of the present disclosure is not limited to the particular combinations claimed hereinafter, but extends to encompass any combination of features or embodiments disclosed herein, regardless of whether that particular combination has been specifically enumerated in the appended claims at this time.
Claims (15)
1. A method, comprising:
receiving sampled audio data corresponding to an utterance; and
training a Machine Learning (ML) model using the sampled audio data to generate a high-fidelity audio stream from a low bit rate input bit stream, wherein the training of the ML model includes attenuating the effect of low probability distortion events in the sampled audio data on the trained ML model, wherein the attenuation of the distortion events is achieved by including in an objective function of the ML model an item that encourages a low variance predictive distribution of a next sample in the sampled audio data based on previous samples of the audio data.
2. The method of claim 1, wherein the term encouraging a low variance predictive distribution of a next bit in the generated bitstream comprises a regularization term.
3. The method of claim 2, wherein the regularization term is defined as:
W represents a vector of network parameter weights,
{ x } represents the sequence of the sampled audio data,
E data indicating an average of a set of data in a database comprising said sampled audio data, an
4. A method according to claim 2 or 3, wherein the regularization term comprises a logarithm of a monotonically increasing function of prediction variance.
5. The method of claim 4, wherein the regularization term is defined as:
J var ({x},W)＝E data log(σ q +a) wherein
W represents a vector of network parameter weights,
{ x } represents the sequence of the sampled audio data,
E data indicating an average of a set of data in a database comprising said sampled audio data,
σ q representing the prediction variance
a represents a floor.
6. The method of any of the preceding claims, wherein the objective function comprises a log-likelihood objective function and a regularization term, and wherein the training of the ML model comprises selecting weights for a network that minimizes a prediction variance associated with the regularization term.
7. A method according to any preceding claim, wherein the ML model is a regression network.
8. The method of any preceding claim, wherein prior to training the ML model, the method further comprises:
separating the sampled audio data in the time domain;
converting the separated sampled audio data into a sequence of speech parameter vectors;
transforming the sequence of speech parameter vectors; and
the sequence of transformed speech parameter vectors is quantized.
9. A method of delivering an audio bitstream, the method comprising:
receiving, at a first device, sampled first audio data corresponding to a first utterance;
converting the sampled first audio data into a sequence of speech parameter vectors;
creating a first bit stream representing the utterance by quantizing the sequence of transformed speech parameter vectors;
delivering, by the first device, the first bit stream to a second device;
receiving, at the first device, a second bitstream representing a second utterance from the second device;
creating a sequence of speech parameter vectors based on the second bitstream;
creating a sequence of vectors based on inverse transforming the sequence of speech parameter vectors;
Generating a high-fidelity audio stream representing the second utterance based on the vector sequence and by using a trained Machine Learning (ML) model, wherein the training of the ML model includes attenuating an effect of low probability distortion events in sampled training audio data on the trained ML model, wherein the attenuation of the distortion events is achieved by including an item in an objective function of the ML model that encourages a low variance predictive distribution of a next sample in the sampled training audio data based on previous samples of the audio data.
10. The method of claim 9, wherein the term encouraging a low variance predictive distribution of a next sample in the sampled training audio data comprises a regularization term.
11. The method of claim 10, wherein the regularization term is defined as:
W represents a vector of network parameter weights,
{ x } represents the sequence of the sampled audio data,
E data indicating an average of a set of data in a database comprising said sampled audio data, an
12. The method of claim 10 or claim 11, wherein the regularization term comprises a logarithm of a monotonically increasing function of prediction variance.
13. The method of claim 12, wherein the regularization term is defined as:
J var ({x},W)＝E data log(σ q +a) wherein
W represents a vector of network parameter weights,
{ x } represents the sequence of the sampled audio data,
E data indicating an average of a set of data in a database comprising said sampled audio data,
σ q representing the prediction variance
a represents a floor.
14. The method of any of claims 9-13, wherein the objective function comprises a log-likelihood objective function and a regularization term, and wherein the training of the ML model comprises selecting weights for a network that minimizes a prediction variance associated with the regularization term.
15. The method of any of claims 9-14, wherein the ML model is a regression network.
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2021/070064 WO2022159247A1 (en) | 2021-01-22 | 2021-01-22 | Trained generative model speech coding |
Publications (1)
Publication Number | Publication Date |
---|---|
CN116368564A true CN116368564A (en) | 2023-06-30 |
Family
ID=74626274
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202180070872.3A Pending CN116368564A (en) | 2021-01-22 | 2021-01-22 | Trained generative model speech coding |
Country Status (6)
Country | Link |
---|---|
US (1) | US11978464B2 (en) |
EP (1) | EP4196981A1 (en) |
JP (1) | JP2024503563A (en) |
KR (1) | KR20230069167A (en) |
CN (1) | CN116368564A (en) |
WO (1) | WO2022159247A1 (en) |
Family Cites Families (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
AU2003243026A1 (en) | 2003-06-19 | 2005-01-04 | Kwangwoon Foundation | Gmm incremental robust adaptation with forgetting factor for speaker verification |
US7634474B2 (en) | 2006-03-30 | 2009-12-15 | Microsoft Corporation | Using connectivity distance for relevance feedback in search |
CN103456310B (en) * | 2013-08-28 | 2017-02-22 | 大连理工大学 | Transient noise suppression method based on spectrum estimation |
CN107767409B (en) | 2017-09-22 | 2020-04-03 | 中国科学院西安光学精密机械研究所 | Consistent point drift registration method based on high-dimensional expression |
CN112639968A (en) * | 2018-08-30 | 2021-04-09 | 杜比国际公司 | Method and apparatus for controlling enhancement of low bit rate encoded audio |
US11024321B2 (en) * | 2018-11-30 | 2021-06-01 | Google Llc | Speech coding using auto-regressive generative neural networks |
US11924445B2 (en) * | 2020-09-25 | 2024-03-05 | Qualcomm Incorporated | Instance-adaptive image and video compression using machine learning systems |
-
2021
- 2021-01-22 KR KR1020237012449A patent/KR20230069167A/en not_active Application Discontinuation
- 2021-01-22 WO PCT/US2021/070064 patent/WO2022159247A1/en active Application Filing
- 2021-01-22 CN CN202180070872.3A patent/CN116368564A/en active Pending
- 2021-01-22 EP EP21705853.6A patent/EP4196981A1/en active Pending
- 2021-01-22 JP JP2023520247A patent/JP2024503563A/en active Pending
- 2021-01-22 US US17/757,122 patent/US11978464B2/en active Active
Also Published As
Publication number | Publication date |
---|---|
US20230352036A1 (en) | 2023-11-02 |
WO2022159247A1 (en) | 2022-07-28 |
JP2024503563A (en) | 2024-01-26 |
EP4196981A1 (en) | 2023-06-21 |
KR20230069167A (en) | 2023-05-18 |
US11978464B2 (en) | 2024-05-07 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
Kleijn et al. | Generative speech coding with predictive variance regularization | |
US10803381B2 (en) | Fixed point integer implementations for neural networks | |
US9990917B2 (en) | Method and system of random access compression of transducer data for automatic speech recognition decoding | |
US11355097B2 (en) | Sample-efficient adaptive text-to-speech | |
Zhen et al. | Cascaded cross-module residual learning towards lightweight end-to-end speech coding | |
WO2018159403A1 (en) | Learning device, speech synthesis system, and speech synthesis method | |
CN112767954A (en) | Audio encoding and decoding method, device, medium and electronic equipment | |
US10020000B2 (en) | Method and apparatus for improved ambisonic decoding | |
Dendani et al. | Speech enhancement based on deep AutoEncoder for remote Arabic speech recognition | |
CN114678032B (en) | Training method, voice conversion method and device and electronic equipment | |
JP7329393B2 (en) | Audio signal processing device, audio signal processing method, audio signal processing program, learning device, learning method and learning program | |
US20180358025A1 (en) | Method and apparatus for audio object coding based on informed source separation | |
JP2022505888A (en) | Methods and equipment for rate quality scalable coding using generative models | |
CN114333893A (en) | Voice processing method and device, electronic equipment and readable medium | |
US20230186927A1 (en) | Compressing audio waveforms using neural networks and vector quantizers | |
RU2716911C2 (en) | Method and apparatus for encoding multiple audio signals and a method and apparatus for decoding a mixture of multiple audio signals with improved separation | |
Park et al. | Unsupervised speech domain adaptation based on disentangled representation learning for robust speech recognition | |
CN116368564A (en) | Trained generative model speech coding | |
CN114333892A (en) | Voice processing method and device, electronic equipment and readable medium | |
CN114333891A (en) | Voice processing method and device, electronic equipment and readable medium | |
CN112687262A (en) | Voice conversion method and device, electronic equipment and computer readable storage medium | |
WO2020231437A1 (en) | Identifying salient features for generative networks | |
US20230298603A1 (en) | Method for encoding and decoding audio signal using normalizing flow, and training method thereof | |
Touazi et al. | An efficient low bit-rate compression scheme of acoustic features for distributed speech recognition | |
Sach et al. | A Maximum Entropy Information Bottleneck (MEIB) Regularization for Generative Speech Enhancement with HiFi-GAN |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |