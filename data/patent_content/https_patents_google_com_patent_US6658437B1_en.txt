US6658437B1 - System and method for data space allocation using optimized bit representation - Google Patents
System and method for data space allocation using optimized bit representation Download PDFInfo
- Publication number
- US6658437B1 US6658437B1 US09/586,848 US58684800A US6658437B1 US 6658437 B1 US6658437 B1 US 6658437B1 US 58684800 A US58684800 A US 58684800A US 6658437 B1 US6658437 B1 US 6658437B1
- Authority
- US
- United States
- Prior art keywords
- allocation
- space
- data
- units
- allocation units
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/02—Addressing or allocation; Relocation
- G06F12/0223—User address space allocation, e.g. contiguous or non contiguous base addressing
- G06F12/023—Free address space management
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2219—Large Object storage; Management thereof
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99932—Access augmentation or optimizing
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99951—File or database maintenance
- Y10S707/99956—File allocation
Definitions
- This invention relates generally to space management systems and, more particularly to bit representations of the allocation status of data space in relational database systems.
- Computer systems have significantly improved in their ability to store and access large quantities of data. Advances in computer data space management systems have made it possible to manipulate increasingly large blocks of data stored in data storage devices.
- the binary buddy system is a high performance space management system that can operate on blocks of data of a wide range of sizes, allocating and freeing the blocks with great efficiency.
- the binary buddy system manages blocks, or memory segments, whose sizes correspond to powers of two.
- the data space in which data values are contained includes a buddy space that has a size that is a power of two units large.
- a buddy space might comprise four megabytes (4 MB) of storage locations, which corresponds to 4 ⁇ 1,024,000 bytes or 2 12 bytes.
- the entire buddy space is divided into segments (known as buddy segments). In this example, if the buddy space were divided into the largest possible segments there would be two segments, each 2 MB in size.
- Each of these two buddy segments could be further subdivided into two smaller buddy segments—and so on until a minimal buddy segment size is reached. That is, the buddy space can be comprised of multiple buddy segments, all of different sizes, all being powers of two.
- the minimal segment size that the system can allocate might be, for example, one kilobyte (1 KB) of data storage locations.
- a space allocator of the buddy system allocates a buddy segment for the data value.
- the space allocator either finds a segment of the correct power-of-two size, or finds a larger segment (starting with up to 4 MB in the above example) and splits it down repeatedly to the desired size.
- buddy segments might be allocated in storage blocks of size 1 KB, 2 KB, 4 KB, 8 KB, . . . 512 KB, 1 MB, and so on, up to the buddy space size limit of the computer system in which the database is installed.
- the space allocator When a data value is removed from a buddy segment, the space allocator automatically joins that segment with its buddy, if the buddy is free. Similarly, that resulting larger segment is joined with its buddy if the buddy is free—and so on until the maximum possible size segment again is reached.
- Implementations of the buddy system space management technique generally have two main components: the space allocation information and the data space itself.
- the space allocation information includes the status of the buddy spaces with respect to subdivisions into buddy segments and the assignment of the buddy segments to data values.
- the computer system uses the allocation information to manage the allocation and freeing of storage locations for data values.
- the space allocation information is represented as a large main-memory data structure.
- the space allocation information is represented as disk-resident data structures.
- This patent describes a hierarchical relational database management system which stores and retrieves large data objects (LOBs) from database storage that utilizes a data manager that maintains LOB data space allocation with two types of allocation pages.
- the first type of allocation page called a regular buddy space (RBS) page, controls distinct buddy spaces comprising equal-size areas of the LOB data space in which LOB buddy segments are stored.
- the second type of allocation page called a super buddy space (SBS) page, controls the RBS pages.
- RBS super buddy space
- the binary buddy space management system allows much more space to be tracked from a single allocation space because a single SBS page can control numerous RBS allocation pages.
- a single SBS page can manage a 64-gigabyte sized data space, thus, only a single disk access is needed to search the 64-gigabyte space and allocate any SBS-size segment. In this way the number of access operations necessary to store LOBs is reduced.
- the SBS page structure is a compact representation that only requires taco bits of allocation space per minimum disk block size and hence does not take excessive main memory to track very large (terabytes) of disk space.
- the SBS page structure can be integrated with an existing buddy space allocation structure without restructuring the data space.
- a space, management system stores and retrieves large data objects (LOBs) from a computer system storage device.
- the computer system storage device contains a LOB data space having LOB data values.
- the space management system permits a computer system user to generate requests for access to LOBs of a database and includes a plurality of allocation units for storing data. each having, an address.
- the allocation units are grouped into a plurality of blocks, each block including at least two allocation units.
- the space management system includes first and second types of space allocation maps, where each space allocation map has a predetermined number of bits.
- the first type space allocation map represents blocks of allocation units below a predetermined size. Each bit in the first type space allocation map represents the allocation status of a corresponding one of the allocation units at a particular address.
- the space allocation map of the second type represents blocks of allocation units equal to. or greater than. the predetermined size.
- the entire second type space allocation map represents the status and size of a single block of allocation units.
- the space management system also includes a controller unit for interpreting the space allocation map and for executing requests to store or retrieve information in the allocation units. The use of an efficient space allocation map allows faster data access and frees up space for use in other control functions.
- FIG. 1 is a block diagram of a computer system having a relational database management system constructed in accordance with the present invention.
- FIG. 2 is a block diagram of the relational database management system illustrated in FIG. 1 .
- FIG. 3 is a block diagram representation of the data structures maintained by the data manager illustrated in FIG. 2 in allocating space for LOBs.
- FIG. 4 is a representation of the LOB descriptor data structure illustrated in FIG. 3 .
- FIG. 5 is a flow diagram that illustrates the processing steps performed by the data manager illustrated in FIG. 2 in responding to user requests for data space allocation.
- FIG. 6 is a flow diagram that illustrates the processing steps performed by the data manager illustrated in FIG. 2 in responding to user requests for freeing data space.
- FIG. 7 is a representation of a portion of the allocation page data structure illustrated in FIG. 3 .
- FIG. 8 is a representation of the allocation bitmap-encoding scheme for the allocation page data structure illustrated in FIG. 3 .
- FIG. 9 is a representation of an exemplary allocation array made up of groups of allocation bit maps and a size array in accordance with the invention.
- FIG. 10 is a representation of the allocation bitmap data structures illustrated in FIG. 8 during a space allocation processing.
- FIG. 11 is a representation of the SBS and RBS allocation pages in their relative locations in the data storage subsystem illustrated in FIG. 1 .
- FIG. 12 a flow diagram that illustrates the processing steps performed by the data manager illustrated in FIG. 2 in searching the SBS data structures.
- FIG. 13 a flow diagram that illustrates the processing steps performed by the data manager illustrated in FIG. 2 in searching the RBS buddy segment data structures during a space allocation.
- FIG. 14 is a flow diagram that illustrates the processing steps performed by the data manager illustrated in FIG. 2 in freeing an SBS buddy segment.
- FIG. 15 is a flow diagram that illustrates the processing steps performed by the data manager illustrated in FIG. 2 in freeing an RBS buddy segment.
- FIG. 1 illustrates a computer processing network system 20 constructed in accordance with the present invention.
- the system includes a central processor unit (CPU) 22 having random access memory (RAM) 23 in which is resident a relational database management system 24 (DBMS).
- the CPU 22 is connected to a file server 26 , to which many clients 28 can be connected. In FIG. 1, only three clients are shown, for simplicity of illustration.
- a storage subsystem 30 that is connected to the CPU 22 provides storage locations where data values comprising a relational database are kept. The storage locations are grouped into equal-sized areas called storage pages, or blocks.
- the DBMS 24 receives database requests from the clients 28 and performs data access operations to store and retrieve referenced data values from the storage subsystem 30 .
- the DBMS supports a large data object (LOB) data type consisting of data values typically greater than 32 kilobytes (KB) in size.
- LOB large data object
- the DBMS 24 maintains data structures called allocation pages that keep track of data storage availability in the storage subsystem according to a two-tiered system in which one tier of pages, called “regular buddy space” (RBS) pages, are indexed to the pages of the storage subsystem and another tier of pages, called “super buddy space” (SBS) pages, are indexed to the RBS pages. That is, the RBS pages indicate pages of the storage subsystem as being either free or allocated and the SBS pages indicate RBS pages as being either free or allocated.
- RBS regular buddy space
- SBS super buddy space
- an RBS page is four kilobytes (4 ⁇ 1024 bytes, written as 4 KB) in size and controls eight megabytes (8 ⁇ 1,024,000 bytes, written as 8 MB) of data.
- the CPU 22 can comprise, for example, a large mainframe machine such as the International Business Machines Corporation (IBM Corporation) product called “System/390” or can comprise a workstation such as the IBM Corporation product called “AS/400” or can comprise an “IBM Personal Computer” processor or compatible machine.
- the file server 26 is a processor that is at least as powerful computationally as any one of the clients 28 .
- the file server can comprise, for example, a workstation and each of the clients can comprise an “IBM Personal Computer” machine.
- the storage subsystem 30 can comprise any of a number of conventional direct access storage devices (DASDs) known to those skilled in the art, such as one or more magnetic disk drive systems.
- DASDs direct access storage devices
- a relational database system such as illustrated in FIG. 1 is a type of database that organizes information for more efficient user manipulation and will be familiar to those skilled in the art.
- a relational database organizes data values into tables with user-defined interrelationships between the tables.
- a relational database management system permits users to construct statements that the system will recognize and use to extract, insert, and combine data values from the tables.
- the selected data values can be assigned to new strings, which comprise table entries, or can replace existing strings.
- users can use a substring operator in an assignment statement to extract a portion of a character string or video image and assign the extracted portion to a new string (or to replace the existing string) for further manipulation.
- Users can use a concatenate operator to join two separate strings into a single string, perhaps combining video images or phonetic sounds. Further examples of string operators will occur readily to those skilled in the art.
- the data values of the relational database in the illustrated DBMS 24 are stored in accordance with storage units defined by a data device hardware configuration.
- the relational database stores a single data value (or table entry) entirely within a single storage unit called a page, which contains one kilobyte (1024) of storage locations.
- a page usually includes between 512 bytes and 32768 bytes (32 ⁇ 1024 bytes, referred to as 32 kilobytes and abbreviated 32 KB). Storing a data value within a single page limits the maximum size of a single data value to the size of the page itself.
- the relational database management system 24 includes a specially defined data type called a long field or large object, generally referred to as a LOB.
- a LOB a long field or large object
- SQL database language known as “SQL” permits a user to define LOB data types referred to as BLOB, CLOB, and DBCLOB.
- the LOB data values are stored in a file located within one or more disk drives of the storage subsystem 30 comprising a designated area called the LOB data space.
- a LOB can have a size so large (several gigabytes) that LOBs are stored in subdivided parts called LOB segments according to the binary buddy system.
- the disconnected LOB segments are kept in the LOB data space in disk storage.
- a LOB storage/retrieval mechanism of the data manager maintains pointers from one LOB segment to another, thereby keeping all the segments of a single LOB data value together.
- To store or retrieve all the LOB segments of a LOB from the LOB data space on disk a series of many disk access operations may be necessary.
- Management of the LOB data space is controlled by allocation pages that are kept in a LOB space allocation file.
- Each allocation page in the LOB space allocation file indicates free space and occupied, or allocated, space in a fixed amount of the LOB data space.
- the fixed amount of space controlled by an allocation page is generally referred to as a buddy space and can contain many buddy segments.
- the pages in the space allocation file include a means of indicating free blocks of storage locations within the buddy space and in that way the allocation file controls the storage of data in the buddy space. Control of free storage locations is carried out by setting flags in the allocation pages that indicate whether a space is currently occupied or is free to be used.
- FIG. 2 illustrates the functional blocks of the DBMS 24 .
- FIG. 2 shows that the DBMS includes two primary functional blocks, a translator 36 and a data manager 38 .
- the translator receives database requests from the clients 28 (FIG. 1) in the form of assignment statements according to a database language format (such as the language known as “SQL”) and converts them into data structure representations and expressions that are recognizable by the data manager.
- the translator 36 converts the assignment statements from the clients 28 according to conventional translation schemes, depending on the relational database management system being used.
- the assignment statements as formulated by the clients for example, might be in an SQL language format specified by a database management system software product called “DB2” available from IBM Corporation.
- DB2 database management system software product
- the data manager 38 carries out the translated assignment statement operation that was specified by the user.
- the data manager performs the operations with a controller 40 , a LOB manager 44 that handles LOB processing, and a set of operator routines 48 typically comprising string operators and the like.
- the assignment statement operations will involve the storage and retrieval of data values from the database storage subsystem 30 (FIG. 1 ). In that circumstance, it will be necessary for the data manager to allocate sufficient storage blocks in the database storage subsystem or, if a block is no longer needed, it will be necessary for the data manager to free storage blocks so they can be used for subsequent storage operations. It is typically the function of the LOB manager to attend to allocation of storage and the actual requests to the CPU for input/output processing.
- FIG. 3 illustrates the database space in the storage subsystem 30 (FIG. 1 ).
- the data space includes a plurality of relations defined by data tables, of which one data table 102 is shown in FIG. 3 for purposes of illustration.
- the data table relations are defined by columns of the data table.
- FIG. 3 illustrates that one entry in a column of the data table can refer to a LOB data structure 104 stored in the database space.
- FIG. 3 shows that a data structure called a LOB descriptor 106 is associated with the LOB and includes various control fields described further below.
- FIG. 3 shows that the various control fields of the LOB descriptor point to the LOB.
- FIG. 3 also illustrates the LOB allocation file RBS pages 108 , which point to the LOB spaces, and the LOB allocation file SBS pages 110 , which point to the RBS pages above them and control the RBS pages.
- the RBS allocation pages 108 and SBS allocation pages 110 are illustrated in a tiered arrangement in FIG. 3 to best reflect their functional relationships, however, in the preferred embodiment, the RBS pages and SBS pages are arranged serially in the database space, as described further below. It also should be understood that, if desired, the RBS pages and SBS pages may be kept separately from the LOB data space.
- the LOB descriptor 106 preferably is of the minimum size necessary to perform its function of defining a LOB in the database. In the preferred embodiment, the LOB descriptor comprises a single value that defines a large data object that may be stored in the data space in non-contiguous blocks of memory.
- FIG. 4 shows details of the LOB descriptor 106 data structure in the preferred embodiment.
- the first field of the LOB descriptor is a data space number that identifies a data space of the storage subsystem in which the LOB is stored. It should be understood that the database may contain multiple data spaces for the storage of data values.
- the next field in the LOB descriptor provides the size of the LOB in bytes.
- the next field is the number of buddy segments in the LOB.
- the next two fields indicate the size of the first buddy segment and the size of the last buddy segment. respectively. Because the data manager allocates buddy segments in a binary fashion, the size of all the intervening buddy segments is known from specifying the first and last buddy segment sizes.
- the remainder of the LOB descriptor comprises a sequence of offset numbers that act as pointers to the buddy segment memory blocks of the LOB.
- the data manager illustrated in FIG. 2 responds to user requests for access to LOB data values, such as for storing data values, by searching for free blocks of storage locations.
- LOB data values such as for storing data values
- the processing of the data manager in responding to such requests will be better understood with reference to the flow diagram of FIG. 5 .
- the data manager After the data manager receives a user data request that calls for storing a LOB data value, as represented by the flow diagram box numbered 312 , the data manager identifies the configuration of space needed for storage of the LOB. The data manager does this by breaking the data value up into power-of-two-sized blocks of data space and allocating data spaces accordingly. This step is represented in FIG. 5 by the flow diagram box numbered 314 .
- this step results in the data manager determining that it must look for data spaces of 64 MB, 2 MB, and 1 MB in size for storing the data value.
- steps performed by the data manager in determining the breakdown of data space sizes without further explanation.
- the data manager determines a size range of data space required for each of the power-of-two pieces identified in the previous step.
- the power-of-two pieces are designated as being in an RBS range if the space needed is a space in the series 1 KB, 2 KB, 4 KB, . . . 512 KB, 1 MB, 2 MB, 4 MB.
- the power-of-two pieces are designated as being in an SBS range if the space needed is in the series 8 MB, 16 MB, 32 MB, 64 MB.
- space is not allocated in single blocks of larger size than 64 MB, but it should be apparent that SBS blocks of up to 64 GB in size can be managed in the SBS range by the data manager.
- the decision box numbered 318 in FIG. 5 indicates that the data manager follows a different path of processing depending on whether the power-of-two piece to be allocated is in the RBS range or the SBS range. If the piece is in the SBS range, an affirmative outcome at the decision box 318 , then the data manager finds an SBS segment (comprising one or more RBS-sized pages of space) by locating either an SBS segment of the correct size, splitting a larger SBS segment down until the data manager has a correct-sized SBS segment, or allocating a new SBS page and (if needed) splitting it to the correct size. These steps are described in greater detail below in connection with FIG. 11 .
- the data manager determines if any further power-of-two pieces remain to be allocated, as represented by the decision box numbered 322 . If more remain, an affirmative outcome, then the data manager processing returns to the flow diagram box numbered 316 to identify whether the next power-of-two piece is in the SBS range or the RBS range. If the last power-of-two piece has been allocated, a negative outcome at the decision box 322 , then the data manager processing for allocating this LOB is done and processing ends.
- the data manager finds an RBS segment in the 1 KB to 4 MB range by locating either an existing divided SBS segment having RBS pages such that a block of RBS pages of the correct size can be located, locating an existing SBS page that can be split into a minimal SBS segment (comprising a single RBS page of 8 MB that can be further split), or by allocating a new SBS segment and splitting it down until the data manager has a correct-sized RBS segment.
- the data manager determines at the decision box numbered 322 if any further power-of-two pieces remain to be allocated and, if more remain, returns to the flow diagram box numbered 316 to identify whether the next power-of-two piece is in the SBS range or the RBS range. If the last power-of-two piece has been allocated, then the data manager processing for allocating this LOB is done and processing ends.
- FIG. 6 illustrates the processing followed by the data manager for freeing a block of data space, such as in response to a user request to delete a LOB.
- the data manager After the data manager receives a user request that calls for freeing a LOB data value, as represented by the FIG. 6 flow diagram box numbered 360 , the data manager breaks up the LOB into the underlying buddy segments that make up the LOB. The step of breaking up the LOB is represented by the flow diagram box numbered 362 . For example, if a LOB of size 67 MB is to be deleted, then the data manager identifies the underlying buddy segments to have respective sizes of 64 MB, 2 MB, and 1 MB. At the flow diagram box numbered 364 , the data manager identifies, for each underlying buddy segment, whether the segment is in the RBS range or the SBS range, as defined above in connection with the allocation processing.
- the data manager follows a different path of processing depending on whether the underlying buddy segment to be freed is in the RBS range or the SBS range, as defined above. If the underlying segment is in the SBS range, an affirmative outcome at the decision box 366 then at the flow diagram box numbered 368 the data manager examines the corresponding allocation page for the SBS segment and determines if the buddy of the freed segment also is free. If the buddy is free, then the data manager changes the allocation page to join up the two freed segments into one larger free segment. The data manager continues this process of joining free blocks until it can free the maximum SBS-size block (in the preferred embodiment, a maximum 64 GB block can be accommodated). At that point, an entire SBS page has been freed and the joining up steps for that underlying segment are completed. These steps are described in greater detail below in connection with FIG. 13 .
- the data manager determines if more underlying buddy segments remain to be freed. If more remain, an affirmative outcome, then data manager processing returns to the decision box numbered 364 to identify the size range of the next underlying buddy segment. If the last underlying segment was freed, so that no more underlying buddy segments remain (a negative outcome at box 370 ), then the data manager steps for freeing this LOB are completed and such processing ends.
- the data manager examines the corresponding RBS allocation page for the RBS segment and determines if the buddy of the freed segment also is free. If the buddy is free, then the data manager changes the allocation page to join up the two freed RBS segments into one larger free segment. The data manager continues this process of joining free blocks until it can free two 4-MB buddy segments of the same RBS page. At that point, an entire SBS segment has been freed and the free RBS pages are “turned into” a free SBS segment. That is.
- the information in the corresponding SBS allocation page is changed to reflect the free status of the segment.
- a two-tiered system of allocation pages is used to control the allocation of storage locations in the LOB data space in which the RBS pages control the buddy segment pages of the data space and the SBS pages control the RBS pages.
- Each allocation page has three parts, comprising an allocation bit map, a count array, and a pointer array. These data structures are illustrated in FIG. 7 .
- the values of the allocation bitmap 120 are shown in FIG. 7 with a corresponding diagrammatic representation, which indicates allocated blocks of storage locations with dark bands and indicates available blocks with light bands.
- the bitmap is ordered according to storage location address. For an RBS page, the allocated blocks of storage and free blocks of storage correspond to allocated and free blocks of buddy segments, respectively.
- each RBS page controls a block of storage locations equal to (8K) ⁇ (1 KB) of storage, or 8 MB of storage. It should be apparent that a different data page size will provide a different block size over which an RBS page has control.
- each SBS page controls 8,192 RBS pages (and, indirectly, their associated disk memory locations).
- each SBS page controls a block of storage locations equal to (8K pages) ⁇ (8 MB of memory storage), or 64 gigabytes (64 GB) of storage.
- the system includes 64 SBS pages. so that the total storage area controlled has a size of (64) ⁇ (64 GB), or 4 terabytes.
- a single SBS allocation page can be used to allocate an entire 64 GB block of storage for a LOB.
- the SBS allocation pages provide a means of checking the storage status (allocated or free) of an entire 64 GB block of storage pages without actually examining each of the RBS pages that control it.
- an allocation page “controls” the allocation of memory blocks in a data space by indicating which blocks are free (available) and which ones have already been allocated, in conjunction with operating processes of the data manager. If an allocation page indicates that a block is allocated, then the data manager will not attempt to use that block of memory to store a data value when a user makes an access request, such as with an assignment statement. If an allocation page indicates that a block is free, then the data manager will go ahead and try to use that block when it needs to find space to store a data value.
- FIG. 7 shows that the count array 122 and the pointer array 124 are indexed according to the size of the memory blocks being controlled.
- a portion of the respective arrays is illustrated with a column 126 indicating sizes from one to thirty-two.
- the count array shows the number of buddy segments of each size available in the space controlled by the corresponding allocation page.
- the count array shows the number of RBS pages of each size that are available.
- the pointer array 124 shows the first place where an available buddy segment was last observed by any process. updating the allocation page, where the pointer array is viewed in terms of an RBS page.
- the pointer array shows the first place where a free page was observed.
- the count array 122 and pointer array 124 permit the data manager to determine immediately if it should look in a given allocation page for a given buddy segment size and provide a place to start looking for a segment of a particular size so the data manager does not have to start each search for an available space from the beginning of the bit map. In this way, the count array and pointer array increase the efficiency of the search for a buddy segment.
- the count array 122 data structure indicates that there is a single free block of 1 KB in size, two free blocks of 2 KB, and two free blocks of 4 KB.
- the pointer array 124 data structure includes a first pointer 128 that points to the free 1 KB block, a second pointer 130 that points to the first 2 KB free block, and a third pointer 132 that points to the first 4 KB free block.
- the pointer array 124 might point to a buddy segment that is available, but on other occasions the pointer array might point to a segment that was recently allocated.
- the pointer array actually provides a hint to the location of a free buddy segment, rather than an absolute location of an available buddy segment. Nevertheless, the pointer for a particular buddy size is guaranteed to be at least a correct starting point for a search for that size buddy segment. That is, the search will not skip past any free buddy segments of that size.
- the count array 122 and the pointer array 124 are updated to indicate the current count of free blocks and point to the location of the newly allocated block, respectively. In this way, a bitmap pointer for a given size buddy segment can be said to move forward. As segments are designated to be available, the count array is updated to indicate the additional free segments and the pointer array is set to point to the segment closest to the beginning of the bitmap. In this way, a bitmap pointer can be said to move backward. Upon initialization of the database system, all of the segment pointers of the pointer array are pointed to the first available buddy segment of each respective size. Those skilled in the art will appreciate how to implement a moving data structure pointer without further explanation.
- the bit map 120 provides a representation of the allocation information concerning a particular allocation page. Each allocation page has a corresponding bit map. In the preferred embodiment, the bit map indicates whether a page (within a segment) is allocated or available.
- FIGS. 7-9 A more detailed illustration of the bit encoding used to store the size and allocation information of various sizes of buddy segments is provided by reference to FIGS. 7-9. More particularly, as illustrated in FIG. 8, for block sized less than 16 times the segment unit size, a first type of bit map is used where only a single bit of allocation information in the bit map is used for each disk page in segments of 4 MB, or less.
- the size bit is shared among the 16 status bits, as described below.
- the second type of bit map is used for blocks of 16 or more times the unit size, where the entire group of 16 bits is used for a single block, as described below.
- FIG. 9 shows an allocation array that includes 5 groups of bit maps each having 16 bits. Also shown is a size array, which determines whether a block is a first type or second type bit map.
- the allocation array in FIG. 9 shows that blocks of buddy segments are arranged into base groups. A single “size bit” in the size array is shared among 16 status bits. The address of a block is determined by the bit position in the base group and by the position of the base group in the larger allocation array. In the illustrated embodiment there are 16 bits in a group, each having 16 address locations numbered 0-15.
- the group 5 bit map shows, at address 64 , an allocated block of size 4 , (represented by “1111”), followed by a free block of size 4 at address 68 (0000). followed by a free block of size 8 at address 72 (0000 0000).
- the size of a set of free blocks is implicit in the number of free unit blocks—they are never subdivided.
- the string “0000” will always represent one free block of size 4 , and never two free blocks of size 2 nor four free blocks of size 1 .
- the exact size of the allocated buddy segments cannot be determined. That is, in the above example, 1100 1111 0011 0000, it cannot be determined whether there are two 1K buddy segments, or one 2K buddy segments at address zero. However, this doesn't present a problem because the allocation bit map is never consulted to locate allocated blocks. Hence the size of allocated blocks is not needed by the database management system.
- bit map 120 is a first type bit map that encodes the allocation status as follows: one allocated block of size two (or two allocated single unit blocks) at address zero; one free block at address two; one allocated block at address 3 ; one free block of size 4 at address 4 ; one allocated block of size 8 at address 8 ; one free block of size two at address 16 ; two allocated blocks at address 18 ; one free block of size 4 at address 20 ; four allocated blocks at address 24 ; one free block of size two at address 28 ; and two allocated blocks at address 30 .
- An additional constraint on the first type of allocation bit map is that blocks larger than 1 can start only on an appropriate block address.
- a block of size 4 can only start on address 0 , 4 , 8 , 12 , . . .
- An additional constraint is that block sizes can only be powers of 2, as discussed above.
- the bit string 1111 1100 0000 0011 represents one allocated block of size 4 , one allocated block of size 2 , one free block of size 2 , one free block of size 4 , one free block of size 2 , and one allocated block of size two.
- the first byte is the status byte for the buddy segment.
- the first bit is the allocation bit, where a “1” indicates that the block is allocated and a “0” indicates that the block is free.
- the second bit is a check bit that is set to be the opposite of the status bit as a verification of the allocation status.
- the third through eighth bits are unused and are set to zero.
- the sizes of allocated blocks, as well as free blocks is known.
- FIG. 7 data structures in terms of an RBS page would relate to the data structures in terms of an SBS page.
- the SBS page control of RBS pages is directly analogous to the RBS control of memory location pages.
- the following description of the bitmap encoding is with respect to the RBS pages, but an analogous discussion would apply to the SBS pages in a manner that should be readily apparent.
- the data manager searches the LOB data space for a free segment, if the segment at a current boundary is larger than the desired size, then the data manager continues the search at the end of the current segment. If the segment at the current boundary is smaller than the desired segment size, then the search continues at the next boundary of the desired segment size.
- the path of a search for a buddy segment of size four is illustrated in FIG. 10 with respect to the bitmap 120 , count array data structure 122 , and pointer array data structure 124 first illustrated in FIG. 7 .
- a bitmap pointer initially points (at the location marked “Start here”) to the allocation bitmap 120 at a segment of size four that was recently allocated. Therefore, the data manager will begin the search for a free block there. Because that segment of size four is allocated, the data manager continues the search at the boundary of the next segment, marked “First stop”, where the data manager comes upon a segment of size eight.
- the current-segment being examined is size eight, which is larger than the desired segment, of size four, so that the data manager continues the search at the end of the current segment.
- the data manager locates a free segment of size two (marked “Second stop”).
- the current segment size of two is smaller than the desired segment size of four, and therefore the data manager continues its search at the next boundary of the desired segment size (size four), where the search is successful (at the point marked “Last stop”).
- FIG. 11 shows an arrangement of the RBS pages and SBS pages in the storage subsystem 30 of FIG. 1 according to the preferred embodiment, wherein an SBS allocation page is followed by the RBS pages that it controls.
- a first SBS page 140 is shown followed by a group of RBS pages 142 , followed by a second SBS page 144 , and so forth.
- Each SBS page includes a bitmap 146 , count array 148 , and pointer array 150 , as described above, relative to the RBS pages it controls, and also includes a divided array data structure 152 and an SBS page directory 154 data structure, also as described above.
- each RBS allocation page includes an analogous bitmap 156 , count array 158 , and pointer array 160 , as described above, relative to the data storage pages that it controls.
- the SBS allocation pages 140 include a divided array data structure 152 and an SBS page directory data structure 154 , which are not found in the RBS allocation pages 144 .
- the divided array data structure 152 indicates a subdivision of SBS pages 140 .
- a minimum SBS unit is an RBS page, which in the illustrated embodiment controls 8 MB of storage space.
- SBS units are allocated in powers of two according to the binary buddy system and are marked as being either allocated or free, depending on their status.
- an SBS buddy segment that is two units in size (16 MB) can have a status of allocated (if it is in use) or free (if it is available).
- an SBS buddy segment is one unit however, then there is a possibility that it was further divided into smaller sizes as part of an RBS buddy segment.
- the divided array data structure is used to track which SBS buddy segments have been subdivided into RBS buddy segments.
- the divided array contains one bit for every SBS unit. When an SBS unit bit of a divided array is turned on, it indicates that the corresponding SBS unit has been subdivided into smaller RBS sizes. The SBS unit otherwise is assumed to be a full SBS size and its status is shown by the SBS allocation bits.
- the SBS page directory data structure 154 is an array that contains one entry for each super buddy space in the LOB data space. Only one SBS page directory 154 is needed to cover the entire LOB data space.
- the SBS page directory 154 contains a flag for a predetermined number N of the largest buddy segment sizes for each SBS page. In the preferred embodiment, for example, the top sixteen sizes of buddy segments are stored. If there is at least one buddy segment of a particular size available in an SBS page 140 , that corresponding flag is set in the SBS page directory 154 . The flag otherwise is set to zero. In the preferred embodiment, there are seventeen sizes of buddy segments in binary size increments, ranging from the smallest size of 1 KB to the largest buddy segment size of 64 MB.
- the representation of the SBS page directory 154 provides convenient use because each entry for a particular SBS page 140 is effectively a logarithm scale. That is, one can easily determine if an SBS page contains the needed space by comparing the log (base 2 ) of the desired segment size with the SBS page directory entry. If the page directory entry is greater than or equal to the (adjusted) log of the desired buddy segment size, then that SBS page 140 contains at least one free buddy segment of the desired size.
- SBS page directory 154 is arbitrarily kept with the first SBS page, which for convenience will be referred to as the “zero page” of the SBS pages. Because the directory contains primarily flags to indicate subdivisions, it can be kept rather compact. Thus, in the preferred embodiment, the SBS page directory occupies approximately 4 KB. For easier data structure definitions. in the preferred embodiment every SBS page 140 includes an area in which the SBS page directory could be maintained. Because only one is needed, however, only the SBS page directory in the SBS zero page is updated and maintained. This aspect of the preferred embodiment is apparent from the representation of the RBS pages 142 and SBS pages 140 in FIG. 11 .
- the data manager in searching the SBS pages 140 and updating the allocation information when allocating blocks will be better understood with reference to the flow diagram of FIG. 12 .
- the data manager reads the SBS zero page.
- the data manager finds the appropriate starting SBS page using the SBS page directory data structure, as described above.
- the data manager uses a conventional linear page search to locate an SBS buddy segment of the appropriate size, as represented by the flow diagram box numbered 206 .
- the data manager determines if a buddy segment was found in the located space.
- the data manager proceeds to use the segment for a store operation and, as represented by the flow diagram box numbered 210 , updates the SBS page counter and pointer data structures to refer to the new buddy segment. If no SBS buddy segment was found at box 208 , then the data manager proceeds to the flow diagram box numbered 212 , where it determines if a new space can be allocated. If a new space cannot be allocated, such as when no suitable space is free, the data manager returns an error indication at the flow diagram box numbered 216 . If a new space can be allocated, an affirmative outcome at the decision box 212 , then the data manager allocates a new buddy space at the flow diagram box numbered 214 . The data manager then concludes its operation by updating the SBS page counter and pointer array for the newly allocated buddy segment, as represented by the flow diagram box numbered 210 .
- the flow diagram of FIG. 13 represents the processing steps followed by the data manager in allocating an RBS buddy segment.
- the data manager reads the SBS zero page, represented by the flow diagram box numbered 220 .
- the data manager uses the SBS page directory data structure to find the appropriate starting SBS page, as represented by the flow diagram box numbered 222 .
- the flow diagram box numbered 224 indicates that the data manager next searches the SBS pages for single buddy segments that are in the divided state, using the SBS pointer array data structure to locate a segment of the appropriate size. As before, conventional linear search techniques can be used.
- the next processing step is the beginning of a processing loop for locating a proper-sized RBS buddy segment that can be allocated.
- the data manager begins by opening the RBS page that corresponds, to the single SBS unit located previously.
- opening refers to orienting a pointer to a specific area of storage locations in the data storage subsystem.
- the data manager uses a conventional linear page search and attempts to locate an available RBS buddy segment.
- an RBS buddy segment is located, an affirmative response at the box numbered 228 . then the data manager updates both the RBS and SBS counter array and pointer array data structures for the RBS buddy segment, as represented by the flow diagram box numbered 230 . Thus ends the allocation processing. If no RBS buddy segment is located at the decision box numbered 228 , then at the decision box numbered 232 , the data manager determines if additional divided SBS units remain to be opened and checked for free status. If there are additional divided SBS units an affirmative response, then processing returns to the flow diagram box numbered 226 where the next RBS page is opened. If there is a negative response at the decision box numbered 232 , meaning that there are no additional divided SBS units, then the data manager has completed its loop through the SBS units without finding an available RBS buddy segment.
- the data manager next allocates a new SBS unit and also divides and allocates an RBS buddy segment. This step is represented in FIG. 13 by the flow diagram box numbered 234 .
- the data manager completes the allocation processing by updating the RBS and SBS page counter and pointer array data structures for the newly allocated RBS buddy segment, as represented by the flow diagram box numbered 230 .
- FIG. 14 is a flow diagram that represents the processing steps followed by the data manager in freeing an SBS buddy segment.
- the data manager reads the SBS zero page.
- the data manager reads the SBS page corresponding to the SBS buddy segment to be freed (flow diagram box numbered 262 ). It should be apparent that the SBS page read by the data manager would be a page other than the zero page, which was already read in the previous processing step.
- the next step represented by the flow diagram box numbered 264 , is for the data manager to mark the SBS buddy segment as having a free status.
- the data manager updates the SBS page counter and pointer array data structures.
- the processing of the data manager in freeing an RBS buddy segment will be better understood with reference to the flow diagram box of FIG. 15 .
- the data manager reads the SBS zero page.
- the data manager reads the SBS page corresponding to the RBS buddy segment to be freed.
- the SBS page read by the data manager during the processing of FIG. 15 will be a page other than the zero page, which was already read in the previous processing step.
- the data manager reads the RBS page containing the RBS buddy segment identified previously (flow diagram box numbered 274 ).
- the data manager updates the pointer and counter arrays on both the RBS and SBS pages.
- the data manager described above in connection with a presently preferred embodiment of the invention uses a two-tiered allocation page configuration to manage a data space of up to four terabytes. It should be apparent that the principles of this invention could be used with even greater multiple-tiered configurations to manage still larger data spaces of extremely large size containing LOBs of similarly large size.
- the preferred embodiment of the invention has been primarily disclosed as a computer system and method of operation thereof.
- the computer system described above includes appropriate components (including program storage, input/output facilities, a connecting bus, and the like) and that the computer system could be programmed or otherwise designed to facilitate the practice of the method of the invention.
- Such a computer system would include appropriate program means for executing the method of the invention.
- an article of manufacture such as a pre-recorded floppy disk or other similar computer program product for use with such computer systems, could include a storage medium and program means recorded thereon (readable by an appropriate component of the computer system) for directing the computer system to facilitate the practice of the method of the invention. It will be understood that such apparatus and articles of manufacture also fall within the spirit and scope of the invention.
Abstract
Description
Claims (21)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/586,848 US6658437B1 (en) | 2000-06-05 | 2000-06-05 | System and method for data space allocation using optimized bit representation |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/586,848 US6658437B1 (en) | 2000-06-05 | 2000-06-05 | System and method for data space allocation using optimized bit representation |
Publications (1)
Publication Number | Publication Date |
---|---|
US6658437B1 true US6658437B1 (en) | 2003-12-02 |
Family
ID=29550352
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/586,848 Expired - Fee Related US6658437B1 (en) | 2000-06-05 | 2000-06-05 | System and method for data space allocation using optimized bit representation |
Country Status (1)
Country | Link |
---|---|
US (1) | US6658437B1 (en) |
Cited By (42)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20020116408A1 (en) * | 2001-02-16 | 2002-08-22 | Green Paul A. | Implementing standards-based file operations in proprietary operating systems |
US20020147900A1 (en) * | 2000-10-27 | 2002-10-10 | Koji Tashiro | Partition creating method and deleting method |
US20030037060A1 (en) * | 2001-08-14 | 2003-02-20 | Kuehnel Andreas H. | Method and apparatus for managing large numbers of objects having the same property |
US20030046294A1 (en) * | 2001-08-31 | 2003-03-06 | Bmc Software, Inc. | Symmetrical database data set allocation |
US20030056082A1 (en) * | 2001-09-19 | 2003-03-20 | Maxfield John D. | System and method for controlling free space distribution by key range within a database |
US20030120689A1 (en) * | 2001-12-21 | 2003-06-26 | Fujitsu Limited | Database management program and recording medium |
US20040186967A1 (en) * | 2003-03-18 | 2004-09-23 | Anupam Anand | Free pointer pool implementation |
US20050076144A1 (en) * | 2003-10-02 | 2005-04-07 | Internet Associates, Llc | Methods, computer systems, and computer readable media for controlling the status of network address space |
US20050196165A1 (en) * | 2004-03-05 | 2005-09-08 | Finisar Corporation | Multi-level memory access in an optical transceiver |
US20050210055A1 (en) * | 2004-03-22 | 2005-09-22 | Microsoft Corporation | Computing device with relatively limited storage space and operating/file system thereof |
US20050209991A1 (en) * | 2004-03-22 | 2005-09-22 | Microsoft Corporation | Computing device with relatively limited storage space and operating / file system thereof |
US20050254776A1 (en) * | 2004-04-05 | 2005-11-17 | Michael Morrison | Digital audio and video recording and storage system and method |
US20050268049A1 (en) * | 2002-08-30 | 2005-12-01 | Koninklijke Philips Electronics N.V. | Dynamic memory management |
US20060075006A1 (en) * | 2004-09-23 | 2006-04-06 | Oracle International Corporation | Storage model for large object columns |
US20060085471A1 (en) * | 2004-10-15 | 2006-04-20 | Vijayan Rajan | System and method for reclaiming unused space from a thinly provisioned data container |
US20070011214A1 (en) * | 2005-07-06 | 2007-01-11 | Venkateswararao Jujjuri | Oject level adaptive allocation technique |
US20070112785A1 (en) * | 2005-11-08 | 2007-05-17 | Autup, Inc. | System and method for updating a storage medium |
US20070136387A1 (en) * | 2002-10-22 | 2007-06-14 | Microsoft Corporation | Transaction-Safe FAT Files System |
US20070299816A1 (en) * | 2006-06-27 | 2007-12-27 | Oracle International Corporation | Immutable Bookmarks for Large Objects in a Database |
US20080005206A1 (en) * | 2006-06-30 | 2008-01-03 | Broadcom Corporation | Method for automatically managing disk fragmentation |
US20080005205A1 (en) * | 2006-06-30 | 2008-01-03 | Broadcom Corporation | Fast and efficient method for deleting very large files from a filesystem |
US20080021865A1 (en) * | 2006-07-20 | 2008-01-24 | International Business Machines Corporation | Method, system, and computer program product for dynamically determining data placement |
US20080104353A1 (en) * | 2006-10-26 | 2008-05-01 | Prashanth Madisetti | Modified buddy system memory allocation |
US20080172426A1 (en) * | 2007-01-16 | 2008-07-17 | Microsoft Corporation | Storage system format for transaction safe file system |
US20080172425A1 (en) * | 2007-01-16 | 2008-07-17 | Microsoft Corporation | FAT directory structure for use in transaction safe file system |
US20080177939A1 (en) * | 2002-10-22 | 2008-07-24 | Microsoft Corporation | Transaction-safe fat file system improvements |
US20080183748A1 (en) * | 2007-01-31 | 2008-07-31 | Maruti Haridas Kamat | Data Processing System And Method |
US7467163B1 (en) * | 2006-02-10 | 2008-12-16 | Unisys Corporation | System and method to manipulate large objects on enterprise server data management system |
CN100449504C (en) * | 2005-01-05 | 2009-01-07 | 华为技术有限公司 | Buffer management based on bitmap list |
US20100115006A1 (en) * | 2004-03-22 | 2010-05-06 | Microsoft Corporation | Computing device with relatively limited storage space and operating/file system thereof |
US20100169322A1 (en) * | 2008-12-26 | 2010-07-01 | Sun Microsystems, Inc. | Efficient access of bitmap array with huge usage variance along linear fashion, using pointers |
US20110131387A1 (en) * | 2009-11-30 | 2011-06-02 | Josef Michael Bacik | Managing unallocated storage space using extents and bitmaps |
US20110191396A1 (en) * | 2010-02-03 | 2011-08-04 | Fujitsu Limited | Storage device and data storage control method |
US8364732B2 (en) | 2006-05-23 | 2013-01-29 | Microsoft Corporation | Extending cluster allocations in an extensible file system |
US20130080481A1 (en) * | 2011-09-27 | 2013-03-28 | Sybase, Inc. | Extreme large space allocation |
US8606830B2 (en) | 2004-12-17 | 2013-12-10 | Microsoft Corporation | Contiguous file allocation in an extensible file system |
US8650278B2 (en) | 2003-08-15 | 2014-02-11 | Internet Associates, Llc | Generating displays of networking addresses |
US20150220447A1 (en) * | 2014-01-31 | 2015-08-06 | Fujitsu Limited | Information processing apparatus and method |
CN105991782A (en) * | 2015-02-04 | 2016-10-05 | 北京神州泰岳软件股份有限公司 | IP address management method and apparatus |
US10474641B2 (en) | 2004-12-17 | 2019-11-12 | Microsoft Technology Licensing, Llc | Extensible file system |
US10614032B2 (en) | 2004-12-17 | 2020-04-07 | Microsoft Technology Licensing, Llc | Quick filename lookup using name hash |
US20220067017A1 (en) * | 2020-08-31 | 2022-03-03 | Oracle International Corporation | Automatic, repetitive, and gradual shrink of very large database object structures |
Citations (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5490274A (en) * | 1993-06-30 | 1996-02-06 | Microsoft Corporation | Modified buddy system for managing disk space |
US5732402A (en) * | 1995-02-10 | 1998-03-24 | International Business Machines Corporation | System and method for data space management using buddy system space allocation |
-
2000
- 2000-06-05 US US09/586,848 patent/US6658437B1/en not_active Expired - Fee Related
Patent Citations (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5490274A (en) * | 1993-06-30 | 1996-02-06 | Microsoft Corporation | Modified buddy system for managing disk space |
US5732402A (en) * | 1995-02-10 | 1998-03-24 | International Business Machines Corporation | System and method for data space management using buddy system space allocation |
Non-Patent Citations (1)
Title |
---|
Publication: "The Starburst Long Field Manager" Report RJ-6899. pps. 1-14. IBM Almaden Research Center. San Jose, CA. Published Jun. 1989. |
Cited By (100)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6901497B2 (en) * | 2000-10-27 | 2005-05-31 | Sony Computer Entertainment Inc. | Partition creating method and deleting method |
US20020147900A1 (en) * | 2000-10-27 | 2002-10-10 | Koji Tashiro | Partition creating method and deleting method |
US20020116408A1 (en) * | 2001-02-16 | 2002-08-22 | Green Paul A. | Implementing standards-based file operations in proprietary operating systems |
US6970892B2 (en) * | 2001-02-16 | 2005-11-29 | Stratus Technologies Bermuda Ltd | Implementing standards-based file operations in proprietary operating systems |
US20030037060A1 (en) * | 2001-08-14 | 2003-02-20 | Kuehnel Andreas H. | Method and apparatus for managing large numbers of objects having the same property |
US7107299B2 (en) * | 2001-08-14 | 2006-09-12 | Hewlett-Packard Development Company, L.P. | Method and apparatus for managing large numbers of objects having the same property |
US20030046294A1 (en) * | 2001-08-31 | 2003-03-06 | Bmc Software, Inc. | Symmetrical database data set allocation |
US7299243B2 (en) * | 2001-09-19 | 2007-11-20 | Bmc Software, Inc. | System and method for controlling free space distribution by key range within a database |
US20080040406A1 (en) * | 2001-09-19 | 2008-02-14 | Bmc Software, Inc. | System and method for controlling free space distribution by key range within a database |
US7720876B2 (en) | 2001-09-19 | 2010-05-18 | Bmc Software, Inc. | System and method for controlling free space distribution by key range within a database |
US20030056082A1 (en) * | 2001-09-19 | 2003-03-20 | Maxfield John D. | System and method for controlling free space distribution by key range within a database |
US20030120689A1 (en) * | 2001-12-21 | 2003-06-26 | Fujitsu Limited | Database management program and recording medium |
US7376678B2 (en) * | 2001-12-21 | 2008-05-20 | Fujitsu Limited | Database management program and recording medium |
US20050268049A1 (en) * | 2002-08-30 | 2005-12-01 | Koninklijke Philips Electronics N.V. | Dynamic memory management |
US20080177939A1 (en) * | 2002-10-22 | 2008-07-24 | Microsoft Corporation | Transaction-safe fat file system improvements |
US20070136387A1 (en) * | 2002-10-22 | 2007-06-14 | Microsoft Corporation | Transaction-Safe FAT Files System |
US8738845B2 (en) | 2002-10-22 | 2014-05-27 | Microsoft Corporation | Transaction-safe fat file system improvements |
US8156165B2 (en) | 2002-10-22 | 2012-04-10 | Microsoft Corporation | Transaction-safe FAT files system |
US8024507B2 (en) | 2002-10-22 | 2011-09-20 | Microsoft Corporation | Transaction-safe FAT file system improvements |
US20040186967A1 (en) * | 2003-03-18 | 2004-09-23 | Anupam Anand | Free pointer pool implementation |
US8650278B2 (en) | 2003-08-15 | 2014-02-11 | Internet Associates, Llc | Generating displays of networking addresses |
US7330907B2 (en) * | 2003-10-02 | 2008-02-12 | Internet Associates, Llc | Methods, computer systems, and computer readable media for controlling the status of network address space |
US8825903B1 (en) | 2003-10-02 | 2014-09-02 | Infoblox Inc. | Controlling the status of network address space |
US20050076144A1 (en) * | 2003-10-02 | 2005-04-07 | Internet Associates, Llc | Methods, computer systems, and computer readable media for controlling the status of network address space |
US7739406B2 (en) | 2003-10-02 | 2010-06-15 | Internet Associates, Llc | Controlling the status of network address space |
US20090248897A1 (en) * | 2003-10-02 | 2009-10-01 | Dennis Joseph Boylan | Controlling The Status Of Network Address Space |
US7558881B2 (en) * | 2003-10-02 | 2009-07-07 | Internet Associates, Llc | Methods, computer systems, and computer readable media for controlling the status of network address space |
US9338128B2 (en) | 2003-10-02 | 2016-05-10 | Infoblox Inc. | Controlling the status of network address space |
US20080140843A1 (en) * | 2003-10-02 | 2008-06-12 | Dennis Joseph Boylan | Methods, computer systems, and computer readable media for controlling the status of network address space |
US8090265B2 (en) * | 2004-03-05 | 2012-01-03 | Finisar Corporation | Byte-configurable memory in an optical transceiver |
US20050196165A1 (en) * | 2004-03-05 | 2005-09-08 | Finisar Corporation | Multi-level memory access in an optical transceiver |
US8200095B2 (en) | 2004-03-05 | 2012-06-12 | Finisar Corporation | Multi-level memory access in an optical transceiver |
US20050238359A1 (en) * | 2004-03-05 | 2005-10-27 | Finisar Corporation | Byte-configurable memory in an optical transceiver |
US20050209991A1 (en) * | 2004-03-22 | 2005-09-22 | Microsoft Corporation | Computing device with relatively limited storage space and operating / file system thereof |
US20100115006A1 (en) * | 2004-03-22 | 2010-05-06 | Microsoft Corporation | Computing device with relatively limited storage space and operating/file system thereof |
US8069192B2 (en) | 2004-03-22 | 2011-11-29 | Microsoft Corporation | Computing device with relatively limited storage space and operating / file system thereof |
US20050210055A1 (en) * | 2004-03-22 | 2005-09-22 | Microsoft Corporation | Computing device with relatively limited storage space and operating/file system thereof |
US7499929B2 (en) * | 2004-03-22 | 2009-03-03 | Microsoft Corporation | Computing device with relatively limited storage space and operating/file system thereof |
US8019194B2 (en) * | 2004-04-05 | 2011-09-13 | S. two Corp. | Digital audio and video recording and storage system and method |
US20050254776A1 (en) * | 2004-04-05 | 2005-11-17 | Michael Morrison | Digital audio and video recording and storage system and method |
US20060075006A1 (en) * | 2004-09-23 | 2006-04-06 | Oracle International Corporation | Storage model for large object columns |
US7853619B2 (en) * | 2004-09-23 | 2010-12-14 | Oracle International Corporation | Storage model for large object columns |
US20060085471A1 (en) * | 2004-10-15 | 2006-04-20 | Vijayan Rajan | System and method for reclaiming unused space from a thinly provisioned data container |
US7603532B2 (en) * | 2004-10-15 | 2009-10-13 | Netapp, Inc. | System and method for reclaiming unused space from a thinly provisioned data container |
US8621172B2 (en) * | 2004-10-15 | 2013-12-31 | Netapp, Inc. | System and method for reclaiming unused space from a thinly provisioned data container |
US10303650B2 (en) | 2004-12-17 | 2019-05-28 | Microsoft Technology Licensing, Llc | Contiguous file allocation in an extensible file system |
US9575972B2 (en) | 2004-12-17 | 2017-02-21 | Microsoft Technology Licensing, Llc | Contiguous file allocation in an extensible file system |
US8606830B2 (en) | 2004-12-17 | 2013-12-10 | Microsoft Corporation | Contiguous file allocation in an extensible file system |
US10474641B2 (en) | 2004-12-17 | 2019-11-12 | Microsoft Technology Licensing, Llc | Extensible file system |
US10614032B2 (en) | 2004-12-17 | 2020-04-07 | Microsoft Technology Licensing, Llc | Quick filename lookup using name hash |
CN100449504C (en) * | 2005-01-05 | 2009-01-07 | 华为技术有限公司 | Buffer management based on bitmap list |
US20070011214A1 (en) * | 2005-07-06 | 2007-01-11 | Venkateswararao Jujjuri | Oject level adaptive allocation technique |
WO2007056413A2 (en) * | 2005-11-08 | 2007-05-18 | Autup, Inc. | System and method for updating a storage medium |
WO2007056413A3 (en) * | 2005-11-08 | 2009-04-30 | Autup Inc | System and method for updating a storage medium |
US20070112785A1 (en) * | 2005-11-08 | 2007-05-17 | Autup, Inc. | System and method for updating a storage medium |
US7467163B1 (en) * | 2006-02-10 | 2008-12-16 | Unisys Corporation | System and method to manipulate large objects on enterprise server data management system |
US8452729B2 (en) | 2006-05-23 | 2013-05-28 | Microsoft Corporation | Extending cluster allocations in an extensible file system |
US9558223B2 (en) | 2006-05-23 | 2017-01-31 | Microsoft Technology Licensing, Llc | Extending cluster allocations in an extensible file system |
US8725772B2 (en) | 2006-05-23 | 2014-05-13 | Microsoft Corporation | Extending cluster allocations in an extensible file system |
US10585868B2 (en) | 2006-05-23 | 2020-03-10 | Microsoft Technology Licensing, Llc | Extending cluster allocations in an extensible file system |
US8433677B2 (en) | 2006-05-23 | 2013-04-30 | Microsoft Corporation | Extending cluster allocations in an extensible file system |
US8805780B2 (en) | 2006-05-23 | 2014-08-12 | Microsoft Corporation | Extending cluster allocations in an extensible file system |
US8364732B2 (en) | 2006-05-23 | 2013-01-29 | Microsoft Corporation | Extending cluster allocations in an extensible file system |
US9122695B2 (en) | 2006-05-23 | 2015-09-01 | Microsoft Technology Licensing, Llc | Extending cluster allocations in an extensible file system |
US20070299816A1 (en) * | 2006-06-27 | 2007-12-27 | Oracle International Corporation | Immutable Bookmarks for Large Objects in a Database |
US7630957B2 (en) * | 2006-06-27 | 2009-12-08 | Oracle International Corporation | Immutable bookmarks for large objects in a database |
US7765244B2 (en) | 2006-06-30 | 2010-07-27 | Broadcom Corporation | Fast and efficient method for deleting very large files from a filesystem |
US20100290755A1 (en) * | 2006-06-30 | 2010-11-18 | Broadcom Corporation | Fast and efficient method for deleting very large files from a filesystem |
US7660837B2 (en) * | 2006-06-30 | 2010-02-09 | Broadcom Corporation | Method for automatically managing disk fragmentation |
US20080005205A1 (en) * | 2006-06-30 | 2008-01-03 | Broadcom Corporation | Fast and efficient method for deleting very large files from a filesystem |
US20080005206A1 (en) * | 2006-06-30 | 2008-01-03 | Broadcom Corporation | Method for automatically managing disk fragmentation |
US7966351B2 (en) | 2006-06-30 | 2011-06-21 | Broadcom Corporation | Fast and efficient method for deleting very large files from a filesystem |
US7860896B2 (en) | 2006-06-30 | 2010-12-28 | Broadcom Corporation | Method for automatically managing disk fragmentation |
US20080021865A1 (en) * | 2006-07-20 | 2008-01-24 | International Business Machines Corporation | Method, system, and computer program product for dynamically determining data placement |
US20080104353A1 (en) * | 2006-10-26 | 2008-05-01 | Prashanth Madisetti | Modified buddy system memory allocation |
US7610468B2 (en) | 2006-10-26 | 2009-10-27 | Hewlett-Packard Development Company, L.P. | Modified buddy system memory allocation |
US7747664B2 (en) * | 2007-01-16 | 2010-06-29 | Microsoft Corporation | Storage system format for transaction safe file system |
US9141630B2 (en) | 2007-01-16 | 2015-09-22 | Microsoft Technology Licensing, Llc | Fat directory structure for use in transaction safe file system |
US8001165B2 (en) | 2007-01-16 | 2011-08-16 | Microsoft Corporation | Storage system format for transaction safe file system |
US8499013B2 (en) | 2007-01-16 | 2013-07-30 | Microsoft Corporation | FAT directory structure for use in transaction safe file system |
US20080172425A1 (en) * | 2007-01-16 | 2008-07-17 | Microsoft Corporation | FAT directory structure for use in transaction safe file system |
US20100217788A1 (en) * | 2007-01-16 | 2010-08-26 | Microsoft Corporation | Storage system format for transaction safe file system |
US20080172426A1 (en) * | 2007-01-16 | 2008-07-17 | Microsoft Corporation | Storage system format for transaction safe file system |
US8024383B2 (en) | 2007-01-16 | 2011-09-20 | Mircrosoft Corporation | Fat directory structure for use in transaction safe file |
US20100049776A1 (en) * | 2007-01-16 | 2010-02-25 | Microsoft Corporation | Fat directory structure for use in transaction safe file |
US9239761B2 (en) | 2007-01-16 | 2016-01-19 | Microsoft Technology Licensing, Llc | Storage system format for transaction safe file system |
US7613738B2 (en) | 2007-01-16 | 2009-11-03 | Microsoft Corporation | FAT directory structure for use in transaction safe file system |
US20080183748A1 (en) * | 2007-01-31 | 2008-07-31 | Maruti Haridas Kamat | Data Processing System And Method |
US20100169322A1 (en) * | 2008-12-26 | 2010-07-01 | Sun Microsystems, Inc. | Efficient access of bitmap array with huge usage variance along linear fashion, using pointers |
US20110131387A1 (en) * | 2009-11-30 | 2011-06-02 | Josef Michael Bacik | Managing unallocated storage space using extents and bitmaps |
US8275968B2 (en) * | 2009-11-30 | 2012-09-25 | Red Hat, Inc. | Managing unallocated storage space using extents and bitmaps |
US8914336B2 (en) * | 2010-02-03 | 2014-12-16 | Fujitsu Limited | Storage device and data storage control method |
US20110191396A1 (en) * | 2010-02-03 | 2011-08-04 | Fujitsu Limited | Storage device and data storage control method |
US20130080481A1 (en) * | 2011-09-27 | 2013-03-28 | Sybase, Inc. | Extreme large space allocation |
US9489295B2 (en) * | 2014-01-31 | 2016-11-08 | Fujitsu Limited | Information processing apparatus and method |
US20150220447A1 (en) * | 2014-01-31 | 2015-08-06 | Fujitsu Limited | Information processing apparatus and method |
JP2015143943A (en) * | 2014-01-31 | 2015-08-06 | 富士通株式会社 | information processing apparatus, control method, and control program |
CN105991782A (en) * | 2015-02-04 | 2016-10-05 | 北京神州泰岳软件股份有限公司 | IP address management method and apparatus |
CN105991782B (en) * | 2015-02-04 | 2019-05-21 | 北京神州泰岳软件股份有限公司 | A kind of method and apparatus of management IP address |
US20220067017A1 (en) * | 2020-08-31 | 2022-03-03 | Oracle International Corporation | Automatic, repetitive, and gradual shrink of very large database object structures |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6658437B1 (en) | System and method for data space allocation using optimized bit representation | |
US5732402A (en) | System and method for data space management using buddy system space allocation | |
US6049804A (en) | Method and apparatus for segmenting a database | |
US5398142A (en) | Method for eliminating file fragmentation and reducing average seek times in a magnetic disk media environment | |
US6349308B1 (en) | Inverted index storage structure using subindexes and large objects for tight coupling of information retrieval with database management systems | |
US5649181A (en) | Method and apparatus for indexing database columns with bit vectors | |
US5809494A (en) | Method for rapidly and efficiently hashing records of large databases | |
US4991087A (en) | Method of using signature subsets for indexing a textual database | |
CA2281287C (en) | Method and system for efficiently searching for free space in a table of a relational database having a clustering index | |
EP1311940B1 (en) | Improved space allocation in a write anywhere file system | |
US6725223B2 (en) | Storage format for encoded vector indexes | |
US7987190B2 (en) | Filesystem having a filename cache | |
US6859808B1 (en) | Mapping logical row identifiers for primary B+tree-like structures to physical row identifiers | |
US6654868B2 (en) | Information storage and retrieval system | |
US5924092A (en) | Computer system and method which sort array elements to optimize array modifications | |
US6697795B2 (en) | Virtual file system for dynamically-generated web pages | |
JPH05242149A (en) | Database keyword indexing method and database retrieval index structure | |
EA006562B1 (en) | A method of encoding keys within database and database | |
Brown et al. | Supporting full-text information retrieval with a persistent object store | |
Putz | Using a relational database for an inverted text index | |
Hammer et al. | Data structures for databases | |
EP0665499A2 (en) | Hierarchic data storage system | |
Gardarin et al. | Predicate trees: An approach to optimize relational query operations | |
JP2636487B2 (en) | Directory management method for cache control unit | |
JPH02116936A (en) | Reorganizing system |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:LEHMAN, TOBIN J.;REEL/FRAME:010850/0695Effective date: 20000530 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026664/0866Effective date: 20110503 |
|
REMI | Maintenance fee reminder mailed | ||
LAPS | Lapse for failure to pay maintenance fees | ||
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20151202 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044144/0001Effective date: 20170929 |