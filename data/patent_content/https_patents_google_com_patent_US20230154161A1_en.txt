US20230154161A1 - Memory-optimized contrastive learning - Google Patents
Memory-optimized contrastive learning Download PDFInfo
- Publication number
- US20230154161A1 US20230154161A1 US17/988,655 US202217988655A US2023154161A1 US 20230154161 A1 US20230154161 A1 US 20230154161A1 US 202217988655 A US202217988655 A US 202217988655A US 2023154161 A1 US2023154161 A1 US 2023154161A1
- Authority
- US
- United States
- Prior art keywords
- neural network
- image
- text
- encoder neural
- training
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06V—IMAGE OR VIDEO RECOGNITION OR UNDERSTANDING
- G06V10/00—Arrangements for image or video recognition or understanding
- G06V10/70—Arrangements for image or video recognition or understanding using pattern recognition or machine learning
- G06V10/77—Processing image or video features in feature spaces; using data integration or data reduction, e.g. principal component analysis [PCA] or independent component analysis [ICA] or self-organising maps [SOM]; Blind source separation
- G06V10/774—Generating sets of training patterns; Bootstrap methods, e.g. bagging or boosting
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/045—Combinations of networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F40/00—Handling natural language data
- G06F40/10—Text processing
- G06F40/12—Use of codes for handling textual entities
- G06F40/126—Character encoding
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/044—Recurrent networks, e.g. Hopfield networks
- G06N3/0442—Recurrent networks, e.g. Hopfield networks characterised by memory or gating, e.g. long short-term memory [LSTM] or gated recurrent units [GRU]
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/0464—Convolutional networks [CNN, ConvNet]
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/09—Supervised learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T9/00—Image coding
- G06T9/002—Image coding using neural networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06V—IMAGE OR VIDEO RECOGNITION OR UNDERSTANDING
- G06V10/00—Arrangements for image or video recognition or understanding
- G06V10/70—Arrangements for image or video recognition or understanding using pattern recognition or machine learning
- G06V10/764—Arrangements for image or video recognition or understanding using pattern recognition or machine learning using classification, e.g. of video objects
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06V—IMAGE OR VIDEO RECOGNITION OR UNDERSTANDING
- G06V10/00—Arrangements for image or video recognition or understanding
- G06V10/70—Arrangements for image or video recognition or understanding using pattern recognition or machine learning
- G06V10/77—Processing image or video features in feature spaces; using data integration or data reduction, e.g. principal component analysis [PCA] or independent component analysis [ICA] or self-organising maps [SOM]; Blind source separation
- G06V10/776—Validation; Performance evaluation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06V—IMAGE OR VIDEO RECOGNITION OR UNDERSTANDING
- G06V10/00—Arrangements for image or video recognition or understanding
- G06V10/70—Arrangements for image or video recognition or understanding using pattern recognition or machine learning
- G06V10/82—Arrangements for image or video recognition or understanding using pattern recognition or machine learning using neural networks
Definitions
- This specification relates to training neural networks.
- Neural networks are machine learning models that employ one or more layers of nonlinear units to predict an output for a received input.
- Some neural networks include one or more hidden layers in addition to an output layer. The output of each hidden layer is used as input to the next layer in the network, i.e., the next hidden layer or the output layer.
- Each layer of the network generates an output from a received input in accordance with current values of a respective set of parameters.
- This specification describes a system implemented as computer programs on one or more computers in one or more locations that trains an image encoder neural network and a text encoder neural network.
- the system trains the image encoder, the text encoder, or both through contrastive learning.
- this specification describes how the system modifies contrastive learning training to allow large models to be trained with large batch sizes without being bottlenecked by the limited memory of the device(s) on which the system performs the training.
- the system can perform the training on a set of one or more accelerator devices, e.g., deep learning accelerators like Graphics Processing Units (GPUs) or Tensor Processing Units (TPUs).
- GPUs Graphics Processing Units
- TPUs Tensor Processing Units
- these devices are advantageous for model training because they have dedicated hardware for performing common training operations in hardware, e.g., matrix multiplication circuitry for performing matrix multiplies in hardware, they have limited on-chip memory, thereby resulting in a memory bottleneck when large multi-modal models are trained through contrastive learning.
- This specification performs the contrastive learning in a way that overcomes this bottleneck.
- Contrastive learning techniques can be used to learn representations, e.g., of images, text, or both, that yield significant improvements when the representations are used for downstream tasks, e.g., image classification, image captioning, text-to-image search, and so on.
- each embedding for each input in the batch can be “contrasted” with a more diverse set of candidates, e.g., embeddings for other inputs in the same batch.
- larger batch sizes allow for more negative examples to be used in the contrastive learning objective, improving the quality of the representations generated by the encoder neural network, e.g. resulting in an encoder neural network that produces encodings that cluster similar inputs more closely while clearly separating dissimilar inputs.
- the training of these neural networks is generally performed on one or more computing devices, e.g., central processing units (CPUs) or deep learning accelerators like graphics processing units (GPUs), tensor processing units (TPUs), other ASICs, or FPGAs, that have limited on-device memory.
- CPUs central processing units
- GPUs graphics processing units
- TPUs tensor processing units
- FPGAs field-programmable gate arrays
- increasing the batch size can be infeasible because it would require more memory to perform the forward pass for each input in the larger batch than is available on the devices on which the training is being performed.
- this specification describes techniques for performing contrastive learning with batch sizes that would otherwise exceed this memory limit.
- the described techniques decrease the memory footprint of training on batches having the batch size so that the footprint never exceeds the available memory on the one or more devices. Training using the described techniques results in improved representations, i.e., representations that perform better on downstream tasks, e.g., zero shot or few shot image classification.
- the size, i.e., the number of parameters, of the encoder neural network(s) has also been shown to improve the performance of contrastive learning.
- naively increasing the size of the neural network requires storing a large gradient vector, i.e., a gradient vector that includes a respective entry for each of the parameters, in the on-device memory, further bottlenecking the training, especially when combined with large batch sizes.
- This specification describes techniques for updating the parameters of the encoder neural network without needing to store an entire gradient vector in memory, removing this bottleneck and freeing up more of the on-device memory to, e.g., further increase the model size or the batch size.
- FIG. 1 shows an example neural network system.
- FIG. 2 is a flow diagram of an example process for training the neural network.
- FIG. 3 is a flow diagram of an example process for updating the image encoder neural network.
- FIG. 4 is a flow diagram of an example process for updating the text encoder neural network.
- FIG. 5 is a flow diagram of an example process for applying an optimizer to chunked gradients.
- This specification describes systems implemented as computer programs on one or more computers in one or more locations that trains an image encoder neural network and a text encoder neural network.
- FIG. 1 shows an example neural network system 100 .
- the neural network system 100 is an example of a system implemented as computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below can be implemented.
- This system 100 trains an image encoder neural network 110 and a text encoder neural network 120 .
- the image encoder neural network 110 is a neural network that has parameters (“image encoder neural network parameters” or “image encoder parameters”) and receives an input image 102 and processes the input image 102 in accordance with the parameters to generate an image embedding 112 of the input image in an embedding space.
- An “embedding” as used in this specification is a vector of numeric values, e.g., floating point values or other values, having a pre-determined dimensionality. The space of possible vectors having the pre-determined dimensionality is referred to as the “embedding space.”
- the image encoder neural network 110 can have any appropriate architecture that allows the neural network 110 to map an input image to a vector from the embedding space.
- the image encoder neural network 110 can be a convolutional neural network.
- the image encoder neural network 110 can be a vision Transformer neural network that has one or more self-attention layers.
- the image encoder neural network 110 can be a neural network that has a mix of both convolutional and self-attention layers.
- the text encoder neural network 120 is a neural network that has parameters (“text encoder neural network parameters” or “text encoder parameters”) and receives an input text segment 104 and processes the input text segment 104 in accordance with the parameters to generate a text embedding 124 of the input segment 104 in the same embedding space, i.e., the image embeddings 112 and text embeddings 124 have the same dimensionality.
- the text segments 104 can be single words, sentences, or other multi-word phrases.
- the text encoder neural network 120 can have any appropriate architecture that allows the neural network 120 to map an input text segment to a vector from the embedding space.
- the text encoder neural network 120 can be an encoder-only Transformer neural network.
- the text encoder neural network 120 can be a recurrent neural network, e.g., a long short-term memory (LSTM) neural network or a gated recurrent unit (GRU) neural network.
- LSTM long short-term memory
- GRU gated recurrent unit
- the image encoder 110 After being trained, the image encoder 110 , the text encoder 120 , or both can be used for one or more downstream tasks.
- An example of a downstream task is image classification, where the input is an image and the output is a classification output that identifies, from a set of object classes, one or more object classes that are predicted to be depicted in the image.
- the neural networks 110 and 120 can be used for zero-shot image classification.
- the system processes, for each object class in the set, a text segment characterizing the object class using the trained text encoder to generate a respective text embedding for each object class.
- the system then processes the input image using the image encoder to generate an image embedding of the input image and selects, as the one or more classes that are identified in the classification output, the object classes having text embeddings that are closest in the embedding space to the image embedding.
- Another example of a downstream task is image search, where the input is text and the output is one or more images that relevant to the input text, i.e., have similar semantic content to the input text.
- the system processes the input using the text encoder to generate a text embedding for the input text.
- the system identifies one or image embeddings that have been generated using the trained image encoder that are closest to the text embedding and provides data identifying the images from which the one or more closest image embeddings were generated in response to the input text.
- the system 100 trains the neural networks 110 and 120 on a set of one or more computing devices, e.g., one or more CPUs, GPUs, TPUs, or other ASICs, or FPGAs.
- the set of one or more computing devices has limited on-device or on-chip memory.
- the system 100 uses contrastive learning.
- the goal of contrastive learning is to train the image encoder 110 and the text encoder 120 so that they can embed image and text inputs into the embedding space in such a way that inputs with similar semantics are mapped to nearby points regardless of their modalities.
- the neural networks 110 and 120 receive a minibatch of N pairs (x i ; y i ), where x i is an image and y i is a text sequence (e.g., a textual description) with similar semantic contents to x i .
- Each image x i and text sequence y i is then mapped into respective embeddings, i.e., into respective points in the embedding space, by the corresponding neural network 110 or 120 .
- the system can then train the neural network 110 , the neural network 120 , or both using a contrastive loss 130 that encourages, for all pairs in the minibatch, the embeddings of x i and y i to be closer together while being farther from all other embeddings of all other images and text segments in the minibatch.
- an N ⁇ N similarity matrix A is computed, where A i:j is a value that represents how similar the image embedding of x i is to the text embedding of y j .
- a i:j can be the dot product between the image embedding of x i and the text embedding of y j similar are the embeddings of image xi and text sequence yi.
- the system 100 can then train the neural network 110 , the neural network 120 , or both using gradients of a contrastive loss computed using the matrix A.
- the contrastive loss can be the cross-entropy loss on the rows and columns of A, where the diagonal entries are treated as correct classes while other entries are treated as incorrect classes.
- a specific example of such a loss is:
- ⁇ is the softmax temperature which serves to steepen or dampen the softmax distributions in the rows and columns of A.
- the embeddings of x i and y i become closer together while becoming farther from all other embeddings of all other images and text segments in the minibatch, thereby achieving the goal of the contrastive learning.
- the contrastive loss for any given pair in a minibatch depends not only the embeddings for the given pair, but the embeddings for all other pairs in the minibatch.
- the mini-batch size In order to improve the training of the neural networks 110 or 120 , i.e., so that the trained neural networks 110 and 120 generate higher-quality, more accurate embeddings, it is generally desirable to increase the mini-batch size, to increase the size, i.e., the number of parameters of, the neural networks 110 and 120 , or both.
- this creates a memory bottleneck due to the limited on-chip memory of the set of computing devices used for the training. While techniques for circumventing this bottleneck exist for other types of learning, they are generally inapplicable to contrastive learning due to the inter-dependency among every pair of examples when computing the contrastive loss.
- the system 100 makes use of one or more techniques that are tailored to contrastive learning and allow the system to effectively use a contrastive loss even when training large models with large batch sizes on devices/systems with limited on-device memory.
- contrastive learning to train the image encoder 110 , the text encoder 120 , or both is described below with reference to FIGS. 2 - 5 .
- the system 100 can incorporate contrastive learning into the training of the neural networks 110 and 120 in any of a variety of ways.
- the system 100 can train both the neural networks 110 and 120 jointly and from scratch using contrastive learning.
- the system 100 can first pre-train the image encoder 110 on a labeled image data set as part of a classification model using a softmax classification loss or other appropriate image classification loss. The system 100 can then perform a first contrastive learning phase to train only the text encoder 120 while keeping the image encoder 110 fixed.
- the system 100 can then perform a “fine-tuning” contrastive learning phase to train both neural networks 110 and 120 using contrastive learning. Performing this fine-tuning allows the neural network 110 to learn from noisy image-text data, improving the performance of the neural networks 110 and 120 on some downstream tasks relative to only pre-training the image encoder on the labeled image data set.
- FIG. 2 is a flow diagram of an example process 200 for training using contrastive learning.
- the process 200 will be described as being performed by a system of one or more computers located in one or more locations.
- a neural network system e.g., the neural network system 100 of FIG. 1 , appropriately programmed, can perform the process 200 .
- the system can repeatedly perform iterations of the process 200 on different batches of training examples to update the parameters of the image encoder neural network, the text encoder neural network, or both.
- the system obtains a batch of training pairs, e.g., by sampling the batch from a larger set of training data, and uses the batch of one or more training examples to update the parameters of the image encoder neural network, the text encoder neural network, or both.
- the system can continue performing iterations of the process 200 until termination criteria for the training of the neural network have been satisfied, e.g., until the parameters have converged, until a threshold amount of wall clock time has elapsed, or until a threshold number of iterations of the process 200 have been performed.
- the system obtains a batch of training pairs (step 202 ).
- Each training pair including an input image and an input text segment.
- the input text segment has been determined by the system or an external source to describe the contents of the input image or otherwise be relevant to the input image.
- the input image and the input text segment have been determined to be semantically similar.
- the system obtains data partitioning the batch of training pairs into a plurality of chunks of training pairs (step 204 ).
- the system or another system can randomly partition the training pairs in the batch into fixed sized chunks, such that the one or more computing devices, e.g., one or more CPUs, GPUs, TPUs, or other ASICs, or FPGAs, have sufficient available memory to perform a forward pass through both neural networks on the training pairs in each chunk.
- Performing a “forward pass” refers to performing the operations required to generate respective embeddings for each input in a set of inputs.
- the amount of memory required to perform a forward pass on the batch of training input pairs exceeds the amount of available memory in the memory of the set of one or more computing devices, but, by dividing the batch into chunks, the amount of memory required to perform the first forward pass for each chunk does not exceed the amount of available memory.
- the system then performs steps 206 - 210 for each of the chunks.
- the system performs, on the set of one or more computing devices, a first forward pass through the image encoder neural network in accordance with current values of the image encoder neural network parameters on the input images in the training pairs in the chunk to generate a respective image embedding of each input image (step 206 ).
- the system performs, on the set of one or more computing devices, a first forward pass through the text encoder neural network in accordance with current values of the text encoder neural network parameters on the input text segments in the training pairs in the chunk to generate a respective text embedding of each text segment (step 208 ).
- each device can perform the respective forward passes for a partition of the pairs in each chunk.
- the system then stores, in memory of the set of one or more computing devices, the respective image embeddings and the respective text embeddings (step 210 ).
- the system stores the image embedding and the text embeddings without storing the intermediate hidden states, e.g., activations and intermediate outputs generated by the hidden layers of the neural networks, generated by performing the first forward passes through the image encoder neural network and the text encoder neural network.
- the system can perform steps 206 - 210 sequentially for each of the chunks according to an arbitrarily determined chunk order.
- the system then generates, for each training pair in the batch and using the respective image embeddings and the respective text embeddings for the plurality of chunks stored in the memory of the set of one or more computing devices, a respective similarity between the image embedding of the input image in the training pair and the respective text embeddings of the input text segments in all of the training pairs in the batch (step 212 ).
- the system can compute, for each image embedding, dot products between the image embedding and all of the text embeddings for all of the input text segments in all of the training pairs in the batch.
- the system then trains the image encoder, the text encoder, or both, using the generated similarities (step 214 ).
- the system trains only the image encoder during the contrastive learning phase. These cases are described below with reference to FIG. 3 .
- the system trains only the text encoder during the contrastive learning phase. These cases are described below with reference to FIG. 4 .
- FIG. 3 is a flow diagram of an example process 300 for updating the parameters of the image encoder using the generated similarities.
- the process 300 will be described as being performed by a system of one or more computers located in one or more locations.
- a neural network system e.g., the neural network system 100 of FIG. 1 , appropriately programmed, can perform the process 300 .
- the system determines, for each training pair in the batch, a respective gradient with respect to the image embedding of the input image in the training pair of a contrastive loss function that is based on the respective similarities (step 302 ). For example, the system can compute the respective gradients with respect to the image embeddings of the contrastive loss function described above with reference to FIG. 1 .
- the system can determine a respective gradient of the contrastive loss function with respect to each respective similarity between any two input image—input text segment pairs in the batch and then determine, using backpropagation, the respective gradients of the contrastive loss function with respect to the image embeddings for the input images in the training pairs in the batch from the respective gradients of the contrastive loss function with respect to the respective similarities and the image embeddings.
- the system then performs steps 304 and 306 for each chunk.
- the system then performs, on the one or more computing devices, a second forward pass through the image encoder neural network in accordance with current values of the image encoder neural network parameters on the input images in the training pairs in the chunk to re-generate the intermediate hidden states of the image encoder neural network (step 304 ). That is, because the intermediate hidden states are necessary to backpropagate the gradient through the image encoder, the system performs the second forward pass to re-generate these quantities.
- the system then performs a backward pass through the image encoder neural network using the respective gradients with respect to the image embeddings of the input images in the training pairs in the chunk and the re-generated intermediate hidden states to generate a respective chunked gradient of the contrastive loss function with respect to each of the image encoder neural network (step 306 ).
- Performing a “backward pass” refers to performing the operations necessary to perform backpropagation through a neural network, i.e., to compute a respective gradient of a loss function with respect to each of the parameters of a neural network given a gradient of the loss function with respect to the output of the neural network (in this case, the gradient with respect to the image embeddings).
- the chunked gradient is referred to as a “chunked” gradient because it is a combination, e.g., an average or sum, of individual gradients with respect to only each pair in the chunk, i.e., as opposed to a batched gradient, which would be a combination of individual gradients with respect to each of the pairs in the entire batch.
- the system can discard the re-generated intermediate hidden states prior to performing a backward pass for any subsequent chunks. This ensures that the on-chip memory does not need to store intermediate hidden states for more than one chunk at any given time.
- the system updates the current values of the image encoder neural network parameters using the respective chunked gradients for the chunks (step 308 ).
- the system updates the current values by applying an optimizer to the current values of the image encoder neural network parameters using the respective chunked gradients to generate updated values for the image encoder neural network parameters.
- the optimizer can be any appropriate neural network training optimizer, e.g., Adam, Adafactor, rmsProp, and so on.
- the system to apply the optimizer, combines the chunked gradients, e.g., averages or sums the chunked gradients, to generate a batch gradient and then applies an optimizer to the current values of the image encoder network parameters to generate updated values of the parameters.
- the chunked gradients e.g., averages or sums the chunked gradients
- the system must allocate on-chip memory on the one or more devices for a cumulative gradient that needs to be stored as the system combines each chunked gradient.
- This cumulative gradient has as many entries as the total number of image encoder network parameters. That is, once a chunked gradient is computed, the system must accumulate the chunked gradient into the cumulative gradient and then discard the chunked gradient in order to avoid excessive memory consumption, i.e., must update the cumulative gradient in a “streaming” fashion. When the image encoder neural network is large, this can consume more memory than is available in on-chip memory.
- the on-chip memory already needs to store the values of all of the parameters in order to perform the forward and backward passes, also storing the cumulative gradient will require double the on-chip memory, which can be a significant fraction of the memory capacity when the model is large, e.g., has over 1 billion parameters.
- the system may apply the optimizer in a manner that does not require a separately stored cumulative gradient. This is described in more detail below with reference to FIG. 5 .
- the system trains only the text encoder during the contrastive learning phase.
- FIG. 4 is a flow diagram of an example process 400 for updating the parameters of the text encoder using the generated similarities.
- the process 400 will be described as being performed by a system of one or more computers located in one or more locations.
- a neural network system e.g., the neural network system 100 of FIG. 1 , appropriately programmed, can perform the process 400 .
- the system determines, for each training pair in the batch, a respective gradient with respect to the text embedding of the input text segment in the training pair of the contrastive loss function (step 402 ).
- the system then performs steps 404 and 406 for each chunk.
- the system then performs, on the one or more computing devices, a second forward pass through the text encoder neural network in accordance with current values of the text encoder neural network parameters on the input images in the training pairs in the chunk to re-generate the intermediate hidden states of the text encoder neural network (step 404 ).
- the system then performs a backward pass through the text encoder neural network using the respective gradients with respect to the text embeddings of the input images in the training pairs in the chunk and the re-generated intermediate hidden states to generate a respective chunked gradient of the contrastive loss function with respect to each of the text encoder neural network parameters (step 406 ).
- the system can discard the re-generated intermediate hidden states prior to performing the second forward pass and backward pass for any subsequent chunks. This ensures that the on-chip memory does not need to store intermediate hidden states for more than one chunk at any given time.
- the system updates the current values of the text encoder neural network parameters using the respective chunked gradients for the chunks (step 408 ).
- the system updates the current values by applying an optimizer to the current values of the text encoder neural network parameters using the respective chunked gradients to generate updated values for the text encoder neural network parameters.
- the optimizer can be any appropriate neural network training optimizer, e.g., Adam, Adafactor, rmsProp, and so on.
- the system combines the chunked gradients, e.g., averages or sums the chunked gradients, to generate a batch gradient and then applies an optimizer to the current values of the image encoder network parameters to generate updated values of the parameters.
- the chunked gradients e.g., averages or sums the chunked gradients
- the system applies the optimizer in a manner that does not require a cumulative gradient. This is described in more detail below with reference to FIG. 5 .
- the system trains both the neural networks during the contrastive learning phase. In these cases, the system performs the second forward passes and backward passes through both the neural networks and updates the current values of the parameters of both neural networks as described above with reference to FIGS. 3 and 4 .
- the system can perform the operations required to compute the chunked gradients for both neural networks for any given chunk before moving on to the next chunk.
- the system can use different sized chunks for the processing of the image encoder neural network and the processing of the text encoder neural network. For example, this can enable the system to use larger chunks (and decrease training times) for the smaller neural network and smaller chunks for the larger neural network if the two neural networks are the same size.
- the system can use data parallelism, so that each of the plurality computing devices performs the first forward passes and the second forwarded passes for a respective partition of the training pairs in the chunk. That is, when the set of computing devices includes R devices and each chunk includes M pairs, each of the R devices operates as a replica that computes per-device gradients for the M/R pairs assigned to the device by performing the required forward and backward passes for the M/R pairs assigned to the device. The system can then compute the chunked gradient from the per-device gradients by performing an all-reduce operation on the per-device gradients, i.e., an operation that averages the per-device gradients to generate the chunked gradient.
- FIG. 5 is a flow diagram of an example process 500 for applying an optimizer to chunked gradients.
- the process 500 will be described as being performed by a system of one or more computers located in one or more locations.
- a neural network system e.g., the neural network system 100 of FIG. 1 , appropriately programmed, can perform the process 500 .
- the system can perform the process 500 to apply an optimizer to the parameters of the image encoder, to the parameters of the text encoder, or both.
- the system can perform the process 500 for any appropriate optimizer that maintains respective estimates of one or more gradient moments of the gradients of the parameters and determines an update to the current values of the image encoder neural network parameters using the respective estimates.
- the optimizer can be the Adam or AdamW optimizers that maintain estimates of the first and second moments of the gradients.
- the optimizer can be the Adafactor optimizer.
- the optimizer can be the rmsProp optimizer.
- the system uses one of these optimizers for the training, since the optimizer already allocates memory to store gradient moments, typically called slots, the system directly accumulates the chunk gradients into these slots. Thus, the system effectively accumulates the chunk gradients without needing to use additional memory to store the cumulative gradients.
- the system maintains one or more respective estimates of one or more of the gradient moments of the gradients with respect to the network parameters (step 502 ).
- the system maintains respective estimates of the first and second moments of the gradients.
- the system updates, for each of the gradient moments, the respective estimate of the gradient moment using the respective chunked gradient for the chunk (step 504 ).
- the system can update the respective estimate of the first gradient moment v 1 as follows:
- c i is the chunked gradient for the chunk i
- ⁇ 1 is the optimizer's exponential decay rate for the first gradient moment
- k 1 equals ⁇ 1 for the first chunk and 1/K for all subsequent chunks, where K is the total number of chunks.
- the system instead of updating the first moment estimate once using the batch gradient, the system updates the gradient moment K times, one for each chunk.
- the system can update the respective estimate of the first gradient moment v 1 as follows:
- c i is the chunked gradient for the chunk i
- ⁇ 1 is the optimizer's exponential decay rate for the first gradient moment
- k 1 equals ⁇ 1 for the first chunk and 1/K for all subsequent chunks, where K is the total number of chunks.
- the system can update the respective estimate of the second gradient moment v 2 as follows:
- Var(c i ) is an estimate of the variance of c i .
- the system instead of updating the second moment estimate once using the batch gradient, the system updates the second gradient moment K times, one for each chunk.
- the system can update the respective estimates of the one or more gradient moments without allocating any additional on-chip memory.
- the system can discard the respective chunked gradient for the chunk, i.e., so that the chunked gradient is not stored in memory.
- the system determines the update to the current values of the network parameters using the respective estimates of each of the gradient moments after the respective estimates have been updated using the respective chunked gradients for all of the chunks (step 506 ).
- the system determines the update using the update rule for the optimizer.
- an example update rule for parameters ⁇ is as follows:
- Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non transitory storage medium for execution by, or to control the operation of, data processing apparatus.
- the computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them.
- the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- data processing apparatus refers to data processing hardware and encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers.
- the apparatus can also be, or further include, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
- the apparatus can optionally include, in addition to hardware, code that creates an execution environment for computer programs, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- a computer program which may also be referred to or described as a program, software, a software application, an app, a module, a software module, a script, or code, can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages; and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.
- a program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub programs, or portions of code.
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a data communication network.
- the term “database” is used broadly to refer to any collection of data: the data does not need to be structured in any particular way, or structured at all, and it can be stored on storage devices in one or more locations.
- the index database can include multiple collections of data, each of which may be organized and accessed differently.
- engine is used broadly to refer to a software-based system, subsystem, or process that is programmed to perform one or more specific functions.
- an engine will be implemented as one or more software modules or components, installed on one or more computers in one or more locations. In some cases, one or more computers will be dedicated to a particular engine; in other cases, multiple engines can be installed and running on the same computer or computers.
- the processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output.
- the processes and logic flows can also be performed by special purpose logic circuitry, e.g., an FPGA or an ASIC, or by a combination of special purpose logic circuitry and one or more programmed computers.
- Computers suitable for the execution of a computer program can be based on general or special purpose microprocessors or both, or any other kind of central processing unit.
- a central processing unit will receive instructions and data from a read only memory or a random access memory or both.
- the essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data.
- the central processing unit and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
- PDA personal digital assistant
- GPS Global Positioning System
- USB universal serial bus
- Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks.
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks
- magneto optical disks e.g., CD ROM and DVD-ROM disks.
- embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's device in response to requests received from the web browser.
- a computer can interact with a user by sending text messages or other forms of message to a personal device, e.g., a smartphone that is running a messaging application, and receiving responsive messages from the user in return.
- Data processing apparatus for implementing machine learning models can also include, for example, special-purpose hardware accelerator units for processing common and compute-intensive parts of machine learning training or production, i.e., inference, workloads.
- Machine learning models can be implemented and deployed using a machine learning framework, e.g., a TensorFlow framework or a Jax framework.
- a machine learning framework e.g., a TensorFlow framework or a Jax framework.
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface, a web browser, or an app through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (LAN) and a wide area network (WAN), e.g., the Internet.
- LAN local area network
- WAN wide area network
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- a server transmits data, e.g., an HTML page, to a user device, e.g., for purposes of displaying data to and receiving user input from a user interacting with the device, which acts as a client.
- Data generated at the user device e.g., a result of the user interaction, can be received at the server from the device.
Abstract
Methods, systems, and apparatus, including computer programs encoded on computer storage media, for using memory-optimized contrastive learning to train image encoder and text encoder neural networks.
Description
- This application claims priority to U.S. Provisional Application No. 63/280,105, filed on Nov. 16, 2021. The disclosure of the prior application is considered part of and is incorporated by reference in the disclosure of this application.
- This specification relates to training neural networks.
- Neural networks are machine learning models that employ one or more layers of nonlinear units to predict an output for a received input. Some neural networks include one or more hidden layers in addition to an output layer. The output of each hidden layer is used as input to the next layer in the network, i.e., the next hidden layer or the output layer. Each layer of the network generates an output from a received input in accordance with current values of a respective set of parameters.
- This specification describes a system implemented as computer programs on one or more computers in one or more locations that trains an image encoder neural network and a text encoder neural network. In particular, as part of the training, the system trains the image encoder, the text encoder, or both through contrastive learning.
- More specifically, this specification describes how the system modifies contrastive learning training to allow large models to be trained with large batch sizes without being bottlenecked by the limited memory of the device(s) on which the system performs the training. For example, the system can perform the training on a set of one or more accelerator devices, e.g., deep learning accelerators like Graphics Processing Units (GPUs) or Tensor Processing Units (TPUs). While these devices are advantageous for model training because they have dedicated hardware for performing common training operations in hardware, e.g., matrix multiplication circuitry for performing matrix multiplies in hardware, they have limited on-chip memory, thereby resulting in a memory bottleneck when large multi-modal models are trained through contrastive learning. This specification performs the contrastive learning in a way that overcomes this bottleneck.
- Particular embodiments of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages.
- Contrastive learning techniques can be used to learn representations, e.g., of images, text, or both, that yield significant improvements when the representations are used for downstream tasks, e.g., image classification, image captioning, text-to-image search, and so on.
- Additionally, increasing the batch size that is used during training can improve the quality of the representations because each embedding for each input in the batch can be “contrasted” with a more diverse set of candidates, e.g., embeddings for other inputs in the same batch. In particular, larger batch sizes allow for more negative examples to be used in the contrastive learning objective, improving the quality of the representations generated by the encoder neural network, e.g. resulting in an encoder neural network that produces encodings that cluster similar inputs more closely while clearly separating dissimilar inputs.
- However, the training of these neural networks is generally performed on one or more computing devices, e.g., central processing units (CPUs) or deep learning accelerators like graphics processing units (GPUs), tensor processing units (TPUs), other ASICs, or FPGAs, that have limited on-device memory. Thus, increasing the batch size can be infeasible because it would require more memory to perform the forward pass for each input in the larger batch than is available on the devices on which the training is being performed. To address this issue, this specification describes techniques for performing contrastive learning with batch sizes that would otherwise exceed this memory limit. That is, for a given batch size that would otherwise exceed this memory limit, the described techniques decrease the memory footprint of training on batches having the batch size so that the footprint never exceeds the available memory on the one or more devices. Training using the described techniques results in improved representations, i.e., representations that perform better on downstream tasks, e.g., zero shot or few shot image classification.
- Moreover, increasing the size, i.e., the number of parameters, of the encoder neural network(s) has also been shown to improve the performance of contrastive learning. However, naively increasing the size of the neural network requires storing a large gradient vector, i.e., a gradient vector that includes a respective entry for each of the parameters, in the on-device memory, further bottlenecking the training, especially when combined with large batch sizes. This specification describes techniques for updating the parameters of the encoder neural network without needing to store an entire gradient vector in memory, removing this bottleneck and freeing up more of the on-device memory to, e.g., further increase the model size or the batch size.
- The details of one or more embodiments of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
-
FIG. 1 shows an example neural network system. -
FIG. 2 is a flow diagram of an example process for training the neural network. -
FIG. 3 is a flow diagram of an example process for updating the image encoder neural network. -
FIG. 4 is a flow diagram of an example process for updating the text encoder neural network. -
FIG. 5 is a flow diagram of an example process for applying an optimizer to chunked gradients. - Like reference numbers and designations in the various drawings indicate like elements.
- This specification describes systems implemented as computer programs on one or more computers in one or more locations that trains an image encoder neural network and a text encoder neural network.
-
FIG. 1 shows an exampleneural network system 100. Theneural network system 100 is an example of a system implemented as computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below can be implemented. - This
system 100 trains an image encoderneural network 110 and a text encoderneural network 120. - The image encoder
neural network 110 is a neural network that has parameters (“image encoder neural network parameters” or “image encoder parameters”) and receives aninput image 102 and processes theinput image 102 in accordance with the parameters to generate an image embedding 112 of the input image in an embedding space. An “embedding” as used in this specification is a vector of numeric values, e.g., floating point values or other values, having a pre-determined dimensionality. The space of possible vectors having the pre-determined dimensionality is referred to as the “embedding space.” - The image encoder
neural network 110 can have any appropriate architecture that allows theneural network 110 to map an input image to a vector from the embedding space. For example, the image encoderneural network 110 can be a convolutional neural network. As another example, the image encoderneural network 110 can be a vision Transformer neural network that has one or more self-attention layers. As yet another example, the image encoderneural network 110 can be a neural network that has a mix of both convolutional and self-attention layers. - The text encoder
neural network 120 is a neural network that has parameters (“text encoder neural network parameters” or “text encoder parameters”) and receives aninput text segment 104 and processes theinput text segment 104 in accordance with the parameters to generate a text embedding 124 of theinput segment 104 in the same embedding space, i.e., theimage embeddings 112 andtext embeddings 124 have the same dimensionality. Thetext segments 104 can be single words, sentences, or other multi-word phrases. - The text encoder
neural network 120 can have any appropriate architecture that allows theneural network 120 to map an input text segment to a vector from the embedding space. For example, the text encoderneural network 120 can be an encoder-only Transformer neural network. As another example, the text encoderneural network 120 can be a recurrent neural network, e.g., a long short-term memory (LSTM) neural network or a gated recurrent unit (GRU) neural network. - After being trained, the
image encoder 110, thetext encoder 120, or both can be used for one or more downstream tasks. - An example of a downstream task is image classification, where the input is an image and the output is a classification output that identifies, from a set of object classes, one or more object classes that are predicted to be depicted in the image.
- As a particular example, the
neural networks - The system then processes the input image using the image encoder to generate an image embedding of the input image and selects, as the one or more classes that are identified in the classification output, the object classes having text embeddings that are closest in the embedding space to the image embedding.
- Another example of a downstream task is image search, where the input is text and the output is one or more images that relevant to the input text, i.e., have similar semantic content to the input text.
- To perform an image search, the system (or a different inference system) processes the input using the text encoder to generate a text embedding for the input text. The system then identifies one or image embeddings that have been generated using the trained image encoder that are closest to the text embedding and provides data identifying the images from which the one or more closest image embeddings were generated in response to the input text.
- The
system 100 trains theneural networks - For at least part of the training, the
system 100 uses contrastive learning. The goal of contrastive learning is to train theimage encoder 110 and thetext encoder 120 so that they can embed image and text inputs into the embedding space in such a way that inputs with similar semantics are mapped to nearby points regardless of their modalities. - To this end, in each training step during contrastive learning, the
neural networks neural network - The system can then train the
neural network 110, theneural network 120, or both using acontrastive loss 130 that encourages, for all pairs in the minibatch, the embeddings of xi and yi to be closer together while being farther from all other embeddings of all other images and text segments in the minibatch. - A particular example of a
contrastive loss 130 will be described next. - Based on the embeddings for the images and the text segments in the pairs in the mini-batch, an N×N similarity matrix A is computed, where Ai:j is a value that represents how similar the image embedding of xi is to the text embedding of yj. For example, Ai:j can be the dot product between the image embedding of xi and the text embedding of yj similar are the embeddings of image xi and text sequence yi.
- The
system 100 can then train theneural network 110, theneural network 120, or both using gradients of a contrastive loss computed using the matrix A. For example, the contrastive loss can be the cross-entropy loss on the rows and columns of A, where the diagonal entries are treated as correct classes while other entries are treated as incorrect classes. A specific example of such a loss is: -
- where τ is the softmax temperature which serves to steepen or dampen the softmax distributions in the rows and columns of A.
- As this loss is minimized, for all pairs in the minibatch, the embeddings of xi and yi become closer together while becoming farther from all other embeddings of all other images and text segments in the minibatch, thereby achieving the goal of the contrastive learning.
- As can be seen from the above loss, the contrastive loss for any given pair in a minibatch depends not only the embeddings for the given pair, but the embeddings for all other pairs in the minibatch.
- In order to improve the training of the
neural networks neural networks neural networks - By contrast to conventional approaches, when performing contrastive learning, the
system 100 makes use of one or more techniques that are tailored to contrastive learning and allow the system to effectively use a contrastive loss even when training large models with large batch sizes on devices/systems with limited on-device memory. - Using contrastive learning to train the
image encoder 110, thetext encoder 120, or both is described below with reference toFIGS. 2-5 . - The
system 100 can incorporate contrastive learning into the training of theneural networks - As one particular example, the
system 100 can train both theneural networks - As another particular example, the
system 100 can first pre-train theimage encoder 110 on a labeled image data set as part of a classification model using a softmax classification loss or other appropriate image classification loss. Thesystem 100 can then perform a first contrastive learning phase to train only thetext encoder 120 while keeping theimage encoder 110 fixed. - Optionally, the
system 100 can then perform a “fine-tuning” contrastive learning phase to train bothneural networks neural network 110 to learn from noisy image-text data, improving the performance of theneural networks -
FIG. 2 is a flow diagram of anexample process 200 for training using contrastive learning. For convenience, theprocess 200 will be described as being performed by a system of one or more computers located in one or more locations. For example, a neural network system, e.g., theneural network system 100 ofFIG. 1 , appropriately programmed, can perform theprocess 200. - The system can repeatedly perform iterations of the
process 200 on different batches of training examples to update the parameters of the image encoder neural network, the text encoder neural network, or both. - That is, at each iteration of the
process 200, the system obtains a batch of training pairs, e.g., by sampling the batch from a larger set of training data, and uses the batch of one or more training examples to update the parameters of the image encoder neural network, the text encoder neural network, or both. - The system can continue performing iterations of the
process 200 until termination criteria for the training of the neural network have been satisfied, e.g., until the parameters have converged, until a threshold amount of wall clock time has elapsed, or until a threshold number of iterations of theprocess 200 have been performed. - The system obtains a batch of training pairs (step 202). Each training pair including an input image and an input text segment. In particular, the input text segment has been determined by the system or an external source to describe the contents of the input image or otherwise be relevant to the input image. In other words, the input image and the input text segment have been determined to be semantically similar.
- The system obtains data partitioning the batch of training pairs into a plurality of chunks of training pairs (step 204). For example, the system or another system can randomly partition the training pairs in the batch into fixed sized chunks, such that the one or more computing devices, e.g., one or more CPUs, GPUs, TPUs, or other ASICs, or FPGAs, have sufficient available memory to perform a forward pass through both neural networks on the training pairs in each chunk. Performing a “forward pass” refers to performing the operations required to generate respective embeddings for each input in a set of inputs.
- In some cases, for large batch sizes, the amount of memory required to perform a forward pass on the batch of training input pairs exceeds the amount of available memory in the memory of the set of one or more computing devices, but, by dividing the batch into chunks, the amount of memory required to perform the first forward pass for each chunk does not exceed the amount of available memory.
- The system then performs steps 206-210 for each of the chunks.
- The system performs, on the set of one or more computing devices, a first forward pass through the image encoder neural network in accordance with current values of the image encoder neural network parameters on the input images in the training pairs in the chunk to generate a respective image embedding of each input image (step 206).
- The system performs, on the set of one or more computing devices, a first forward pass through the text encoder neural network in accordance with current values of the text encoder neural network parameters on the input text segments in the training pairs in the chunk to generate a respective text embedding of each text segment (step 208).
- As will be described in more detail below, when there are multiple devices in the set, each device can perform the respective forward passes for a partition of the pairs in each chunk.
- The system then stores, in memory of the set of one or more computing devices, the respective image embeddings and the respective text embeddings (step 210). In particular, the system stores the image embedding and the text embeddings without storing the intermediate hidden states, e.g., activations and intermediate outputs generated by the hidden layers of the neural networks, generated by performing the first forward passes through the image encoder neural network and the text encoder neural network.
- For example, the system can perform steps 206-210 sequentially for each of the chunks according to an arbitrarily determined chunk order.
- The system then generates, for each training pair in the batch and using the respective image embeddings and the respective text embeddings for the plurality of chunks stored in the memory of the set of one or more computing devices, a respective similarity between the image embedding of the input image in the training pair and the respective text embeddings of the input text segments in all of the training pairs in the batch (step 212). For example, the system can compute, for each image embedding, dot products between the image embedding and all of the text embeddings for all of the input text segments in all of the training pairs in the batch.
- The system then trains the image encoder, the text encoder, or both, using the generated similarities (step 214).
- In some cases, the system trains only the image encoder during the contrastive learning phase. These cases are described below with reference to
FIG. 3 . - In some other cases, the system trains only the text encoder during the contrastive learning phase. These cases are described below with reference to
FIG. 4 . -
FIG. 3 is a flow diagram of anexample process 300 for updating the parameters of the image encoder using the generated similarities. For convenience, theprocess 300 will be described as being performed by a system of one or more computers located in one or more locations. For example, a neural network system, e.g., theneural network system 100 ofFIG. 1 , appropriately programmed, can perform theprocess 300. - The system determines, for each training pair in the batch, a respective gradient with respect to the image embedding of the input image in the training pair of a contrastive loss function that is based on the respective similarities (step 302). For example, the system can compute the respective gradients with respect to the image embeddings of the contrastive loss function described above with reference to
FIG. 1 . - To compute the gradients, the system can determine a respective gradient of the contrastive loss function with respect to each respective similarity between any two input image—input text segment pairs in the batch and then determine, using backpropagation, the respective gradients of the contrastive loss function with respect to the image embeddings for the input images in the training pairs in the batch from the respective gradients of the contrastive loss function with respect to the respective similarities and the image embeddings.
- The system then performs
steps 304 and 306 for each chunk. - The system then performs, on the one or more computing devices, a second forward pass through the image encoder neural network in accordance with current values of the image encoder neural network parameters on the input images in the training pairs in the chunk to re-generate the intermediate hidden states of the image encoder neural network (step 304). That is, because the intermediate hidden states are necessary to backpropagate the gradient through the image encoder, the system performs the second forward pass to re-generate these quantities.
- The system then performs a backward pass through the image encoder neural network using the respective gradients with respect to the image embeddings of the input images in the training pairs in the chunk and the re-generated intermediate hidden states to generate a respective chunked gradient of the contrastive loss function with respect to each of the image encoder neural network (step 306).
- Performing a “backward pass” refers to performing the operations necessary to perform backpropagation through a neural network, i.e., to compute a respective gradient of a loss function with respect to each of the parameters of a neural network given a gradient of the loss function with respect to the output of the neural network (in this case, the gradient with respect to the image embeddings).
- The chunked gradient is referred to as a “chunked” gradient because it is a combination, e.g., an average or sum, of individual gradients with respect to only each pair in the chunk, i.e., as opposed to a batched gradient, which would be a combination of individual gradients with respect to each of the pairs in the entire batch.
- Additionally, for each chunk, after performing a backward pass through the image encoder neural network using the respective gradients with respect to the image embeddings of the training pairs in the chunk and the re-generated intermediate hidden states, the system can discard the re-generated intermediate hidden states prior to performing a backward pass for any subsequent chunks. This ensures that the on-chip memory does not need to store intermediate hidden states for more than one chunk at any given time.
- The system updates the current values of the image encoder neural network parameters using the respective chunked gradients for the chunks (step 308).
- Generally, the system updates the current values by applying an optimizer to the current values of the image encoder neural network parameters using the respective chunked gradients to generate updated values for the image encoder neural network parameters. The optimizer can be any appropriate neural network training optimizer, e.g., Adam, Adafactor, rmsProp, and so on.
- In some implementations, to apply the optimizer, the system combines the chunked gradients, e.g., averages or sums the chunked gradients, to generate a batch gradient and then applies an optimizer to the current values of the image encoder network parameters to generate updated values of the parameters.
- However, to do this, because storing the respective chunked gradients for all of the chunks would be consume an excessive amount of on-chip memory, the system must allocate on-chip memory on the one or more devices for a cumulative gradient that needs to be stored as the system combines each chunked gradient. This cumulative gradient has as many entries as the total number of image encoder network parameters. That is, once a chunked gradient is computed, the system must accumulate the chunked gradient into the cumulative gradient and then discard the chunked gradient in order to avoid excessive memory consumption, i.e., must update the cumulative gradient in a “streaming” fashion. When the image encoder neural network is large, this can consume more memory than is available in on-chip memory. For example, because the on-chip memory already needs to store the values of all of the parameters in order to perform the forward and backward passes, also storing the cumulative gradient will require double the on-chip memory, which can be a significant fraction of the memory capacity when the model is large, e.g., has over 1 billion parameters.
- To account for this, in some implementations, the system may apply the optimizer in a manner that does not require a separately stored cumulative gradient. This is described in more detail below with reference to
FIG. 5 . - In some other cases, the system trains only the text encoder during the contrastive learning phase.
-
FIG. 4 is a flow diagram of anexample process 400 for updating the parameters of the text encoder using the generated similarities. For convenience, theprocess 400 will be described as being performed by a system of one or more computers located in one or more locations. For example, a neural network system, e.g., theneural network system 100 ofFIG. 1 , appropriately programmed, can perform theprocess 400. - The system determines, for each training pair in the batch, a respective gradient with respect to the text embedding of the input text segment in the training pair of the contrastive loss function (step 402).
- The system then performs
steps - The system then performs, on the one or more computing devices, a second forward pass through the text encoder neural network in accordance with current values of the text encoder neural network parameters on the input images in the training pairs in the chunk to re-generate the intermediate hidden states of the text encoder neural network (step 404).
- The system then performs a backward pass through the text encoder neural network using the respective gradients with respect to the text embeddings of the input images in the training pairs in the chunk and the re-generated intermediate hidden states to generate a respective chunked gradient of the contrastive loss function with respect to each of the text encoder neural network parameters (step 406).
- Additionally, for each chunk, after performing a backward pass through the text encoder neural network using the respective gradients with respect to the text embeddings of the training pairs in the chunk and the re-generated intermediate hidden states, the system can discard the re-generated intermediate hidden states prior to performing the second forward pass and backward pass for any subsequent chunks. This ensures that the on-chip memory does not need to store intermediate hidden states for more than one chunk at any given time.
- The system updates the current values of the text encoder neural network parameters using the respective chunked gradients for the chunks (step 408).
- Generally, the system updates the current values by applying an optimizer to the current values of the text encoder neural network parameters using the respective chunked gradients to generate updated values for the text encoder neural network parameters. The optimizer can be any appropriate neural network training optimizer, e.g., Adam, Adafactor, rmsProp, and so on.
- As described above for the image encoder, in some implementations, to apply the optimizer, the system combines the chunked gradients, e.g., averages or sums the chunked gradients, to generate a batch gradient and then applies an optimizer to the current values of the image encoder network parameters to generate updated values of the parameters.
- In some other implementations, to avoid a memory bottleneck, the system applies the optimizer in a manner that does not require a cumulative gradient. This is described in more detail below with reference to
FIG. 5 . - In yet other cases, the system trains both the neural networks during the contrastive learning phase. In these cases, the system performs the second forward passes and backward passes through both the neural networks and updates the current values of the parameters of both neural networks as described above with reference to
FIGS. 3 and 4 . - When both neural networks are being trained, the system can perform the operations required to compute the chunked gradients for both neural networks for any given chunk before moving on to the next chunk.
- In some implementations, the system can use different sized chunks for the processing of the image encoder neural network and the processing of the text encoder neural network. For example, this can enable the system to use larger chunks (and decrease training times) for the smaller neural network and smaller chunks for the larger neural network if the two neural networks are the same size.
- When the set of computing devices includes multiple devices, the system can use data parallelism, so that each of the plurality computing devices performs the first forward passes and the second forwarded passes for a respective partition of the training pairs in the chunk. That is, when the set of computing devices includes R devices and each chunk includes M pairs, each of the R devices operates as a replica that computes per-device gradients for the M/R pairs assigned to the device by performing the required forward and backward passes for the M/R pairs assigned to the device. The system can then compute the chunked gradient from the per-device gradients by performing an all-reduce operation on the per-device gradients, i.e., an operation that averages the per-device gradients to generate the chunked gradient.
-
FIG. 5 is a flow diagram of anexample process 500 for applying an optimizer to chunked gradients. For convenience, theprocess 500 will be described as being performed by a system of one or more computers located in one or more locations. For example, a neural network system, e.g., theneural network system 100 ofFIG. 1 , appropriately programmed, can perform theprocess 500. - The system can perform the
process 500 to apply an optimizer to the parameters of the image encoder, to the parameters of the text encoder, or both. - In particular, the system can perform the
process 500 for any appropriate optimizer that maintains respective estimates of one or more gradient moments of the gradients of the parameters and determines an update to the current values of the image encoder neural network parameters using the respective estimates. For example, the optimizer can be the Adam or AdamW optimizers that maintain estimates of the first and second moments of the gradients. - As another example, the optimizer can be the Adafactor optimizer.
- As yet another example, the optimizer can be the rmsProp optimizer.
- That is, when the system uses one of these optimizers for the training, since the optimizer already allocates memory to store gradient moments, typically called slots, the system directly accumulates the chunk gradients into these slots. Thus, the system effectively accumulates the chunk gradients without needing to use additional memory to store the cumulative gradients.
- In particular, the system maintains one or more respective estimates of one or more of the gradient moments of the gradients with respect to the network parameters (step 502). For example, for Adam, the system maintains respective estimates of the first and second moments of the gradients.
- For each chunk, the system, updates, for each of the gradient moments, the respective estimate of the gradient moment using the respective chunked gradient for the chunk (step 504).
- For any given chunk i, the system can update the respective estimate of the first gradient moment v1 as follows:
-
v 1 ←k 1 v 1+(1−β1)c i, - where ci is the chunked gradient for the chunk i, β1 is the optimizer's exponential decay rate for the first gradient moment, and k1 equals β1 for the first chunk and 1/K for all subsequent chunks, where K is the total number of chunks.
- That is, instead of updating the first moment estimate once using the batch gradient, the system updates the gradient moment K times, one for each chunk.
- For any given chunk i, the system can update the respective estimate of the first gradient moment v1 as follows:
-
v 1 ←k 1 v 1+(1−β1)c i, - where ci is the chunked gradient for the chunk i, β1 is the optimizer's exponential decay rate for the first gradient moment, and k1 equals β1 for the first chunk and 1/K for all subsequent chunks, where K is the total number of chunks.
- For any given chunk i, the system can update the respective estimate of the second gradient moment v2 as follows:
-
v 2 ←k 2 v 2+(1−β2)(c i 2−Var(c i)), - where ci is the chunked gradient for the chunk i, β2 is the optimizer's exponential decay rate for the second gradient moment, and k2 equals β2 for the first chunk and 1/K for all subsequent chunks, where K is the total number of chunks, and Var(ci) is an estimate of the variance of ci. For example, when the system uses data parallelism with R devices that each compute per-device gradients for the MIR pairs assigned to the device and ci is computed as an all-reduce operation of the per-device gradients, the system can compute Var(ci)=Var[d]/R, where Var[d] is the variance of the per-device gradients used to compute ci.
- That is, instead of updating the second moment estimate once using the batch gradient, the system updates the second gradient moment K times, one for each chunk.
- Thus, the system can update the respective estimates of the one or more gradient moments without allocating any additional on-chip memory.
- For each chunk and after updating, for each of the gradient moments, the respective estimate of the gradient moment using the respective chunked gradient for the chunk, the system can discard the respective chunked gradient for the chunk, i.e., so that the chunked gradient is not stored in memory.
- The system determines the update to the current values of the network parameters using the respective estimates of each of the gradient moments after the respective estimates have been updated using the respective chunked gradients for all of the chunks (step 506). Generally, the system determines the update using the update rule for the optimizer. For example, for the Adam optimizer, an example update rule for parameters θ is as follows:
-
- where t is an index for the current training step, a is a learning rate constant, and E is a numerical stability constant. Thus, neither the update of the parameters nor the update to the gradient moment estimate(s) requires the system to store a cumulative gradient as chunked gradients stream in.
- This specification uses the term “configured” in connection with systems and computer program components. For a system of one or more computers to be configured to perform particular operations or actions means that the system has installed on it software, firmware, hardware, or a combination of them that in operation cause the system to perform the operations or actions. For one or more computer programs to be configured to perform particular operations or actions means that the one or more programs include instructions that, when executed by data processing apparatus, cause the apparatus to perform the operations or actions.
- Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non transitory storage medium for execution by, or to control the operation of, data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them. Alternatively or in addition, the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- The term “data processing apparatus” refers to data processing hardware and encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can also be, or further include, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit). The apparatus can optionally include, in addition to hardware, code that creates an execution environment for computer programs, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- A computer program, which may also be referred to or described as a program, software, a software application, an app, a module, a software module, a script, or code, can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages; and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub programs, or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a data communication network.
- In this specification, the term “database” is used broadly to refer to any collection of data: the data does not need to be structured in any particular way, or structured at all, and it can be stored on storage devices in one or more locations. Thus, for example, the index database can include multiple collections of data, each of which may be organized and accessed differently.
- Similarly, in this specification the term “engine” is used broadly to refer to a software-based system, subsystem, or process that is programmed to perform one or more specific functions. Generally, an engine will be implemented as one or more software modules or components, installed on one or more computers in one or more locations. In some cases, one or more computers will be dedicated to a particular engine; in other cases, multiple engines can be installed and running on the same computer or computers.
- The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by special purpose logic circuitry, e.g., an FPGA or an ASIC, or by a combination of special purpose logic circuitry and one or more programmed computers.
- Computers suitable for the execution of a computer program can be based on general or special purpose microprocessors or both, or any other kind of central processing unit. Generally, a central processing unit will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data. The central processing unit and the memory can be supplemented by, or incorporated in, special purpose logic circuitry. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
- Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks.
- To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's device in response to requests received from the web browser. Also, a computer can interact with a user by sending text messages or other forms of message to a personal device, e.g., a smartphone that is running a messaging application, and receiving responsive messages from the user in return.
- Data processing apparatus for implementing machine learning models can also include, for example, special-purpose hardware accelerator units for processing common and compute-intensive parts of machine learning training or production, i.e., inference, workloads.
- Machine learning models can be implemented and deployed using a machine learning framework, e.g., a TensorFlow framework or a Jax framework.
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface, a web browser, or an app through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (LAN) and a wide area network (WAN), e.g., the Internet.
- The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, a server transmits data, e.g., an HTML page, to a user device, e.g., for purposes of displaying data to and receiving user input from a user interacting with the device, which acts as a client. Data generated at the user device, e.g., a result of the user interaction, can be received at the server from the device.
- While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or on the scope of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially be claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
- Similarly, while operations are depicted in the drawings and recited in the claims in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
- Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous.
Claims (20)
1. A method performed by one or more computers and for training an image encoder neural network having image encoder neural network parameters and configured to process an image to generate an image embedding of the image in an embedding space and a text encoder neural network having text encoder neural network parameters and configured to process a text segment to generate a text embedding of the text segment in the embedding space, the method comprising:
obtaining a batch of training pairs, each training pair including an input image and an input text segment;
obtaining data partitioning the batch of training pairs into a plurality of chunks of training pairs;
for each chunk:
performing, on a set of one or more computing devices, a first forward pass through the image encoder neural network in accordance with current values of the image encoder neural network parameters on the input images in the training pairs in the chunk to generate a respective image embedding of each input image;
performing, on the set of one or more computing devices, a first forward pass through the text encoder neural network in accordance with current values of the text encoder neural network parameters on the input text segments in the training pairs in the chunk to generate a respective text embedding of each text segment;
storing, in memory of the set of one or more computing devices, the respective image embeddings and the respective text embeddings without storing intermediate hidden states generated by performing the first forward passes through the image encoder neural network and the text encoder neural network;
for each training pair in the batch and using the respective image embeddings and the respective text embeddings for the plurality of chunks stored in the memory of the set of one or more computing devices, generating a respective similarity between the image embedding of the input image in the training pair and the respective text embeddings of the input text segments in all of the training pairs in the batch;
determining, for each training pair in the batch, a respective gradient with respect to the image embedding of the input image in the training pair of a contrastive loss function that is based on the respective similarities;
for each chunk:
performing, on the one or more computing devices, a second forward pass through the image encoder neural network in accordance with current values of the image encoder neural network parameters on the input images in the training pairs in the chunk to re-generate the intermediate hidden states of the image encoder neural network;
performing a backward pass through the image encoder neural network using the respective gradients with respect to the image embeddings of the input images in the training pairs in the chunk and the re-generated intermediate hidden states to generate a respective chunked gradient of the contrastive loss function with respect to each of the image encoder neural network parameters; and
updating the current values of the image encoder neural network parameters using the respective chunked gradients for the chunks.
2. The method of claim 1 , further comprising:
determining, for each training pair in the batch, a respective gradient with respect to the text embedding of the input text segment in the training pair of the contrastive loss function that is based on the respective similarities;
for each chunk:
performing, on the one or more computing devices, a second forward pass through the text encoder neural network in accordance with current values of the text encoder neural network parameters on the input text segments in the training pairs in the chunk to re-generate the intermediate hidden states of the text encoder neural network; and
performing a backward pass through the text encoder neural network using the respective gradients with respect to the text embeddings for the text segments in the training pairs in the chunk and the re-generated intermediate hidden states of the text encoder neural network to generate a respective chunked gradient of the contrastive loss function with respect to each of the text encoder neural network parameters; and
updating the current values of the text encoder neural network parameters using the respective chunked gradients for the chunks.
3. The method of claim 1 , wherein updating the current values of the image encoder neural network parameters using the respective chunked gradients for the chunks comprises:
applying an optimizer to the current values of the image encoder neural network parameters using the respective chunked gradients.
4. The method of claim 3 , wherein the optimizer maintains respective estimates of one or more gradient moments and determines an update to the current values of the image encoder neural network parameters using the respective estimates, and wherein applying the optimizer comprises:
for each chunk and for each of the gradient moments, updating the respective estimate of the gradient moment using the respective chunked gradient for the chunk; and
determining the update using the respective estimates of each of the gradient moments after the respective estimates have been updated using the respective chunked gradients for all of the chunks.
5. The method of claim 4 , further comprising, for each chunk and after updating, for each of the gradient moments, the respective estimate of the gradient moment using the respective chunked gradient for the chunk, discarding the respective chunked gradient for the chunk.
6. The method of claim 1 , further comprising:
for each chunk, after performing a backward pass through the image encoder neural network using the respective gradients with respect to the image embeddings of the training pairs in the chunk and the re-generated intermediate hidden states, discarding the re-generated intermediate hidden states prior to performing a backward pass for any subsequent chunks.
7. The method of claim 1 , wherein generating a respective similarity between the image embedding of the input image in the training pair and the respective text embeddings of the input text segments in all of the training pairs in the batch comprises, for each particular training pair in the batch:
computing a dot product between the image embedding of the input image in the training pair and the text embedding of the text embedding of the input text segment in the particular training pair.
8. The method of claim 1 , wherein determining, for each training pair in the batch, a respective gradient of a contrastive loss function that is based on the respective similarities with respect to the image embedding of the input image in the training pair comprises:
determining a respective gradient of the contrastive loss function with respect to each respective similarity between any two input image—input text segment pairs in the batch; and
determining the respective gradients of the contrastive loss function with respect to the image embeddings for the input images in the training pairs in the batch from the respective gradients of the contrastive loss function with respect to the respective similarities and the image embeddings.
9. The method of claim 1 , further comprising:
prior to jointly training the image encoder neural network and the text encoder neural network, training an image classification model that includes the image encoder neural network on an image classification task, wherein the current values of the image encoder neural network parameters are determined based on values of the parameters after training the image classification model.
10. The method of claim 1 , further comprising:
after training the image encoder neural network and the text encoder neural network, using the trained image encoder neural network and the trained text encoder neural network to perform a downstream task.
11. The method of claim 10 , wherein the downstream task is image classification.
12. The method of claim 1 , wherein the set includes a plurality of computing devices and wherein, for each chunk, each of the plurality computing devices performs the first forward passes for a respective partition of the training pairs in the chunk.
13. The method of claim 1 , wherein an amount of memory required to perform a forward pass on the batch of training input pairs exceeds an amount of available memory in the memory of the set of one or more computing devices, and wherein an amount of memory required to perform the first forward pass for each chunk does not exceed the amount of available memory.
14. A system comprising one or more computers and one or more storage devices storing instructions that when executed by the one or more computers cause the one more computers to perform operations for training an image encoder neural network having image encoder neural network parameters and configured to process an image to generate an image embedding of the image in an embedding space and a text encoder neural network having text encoder neural network parameters and configured to process a text segment to generate a text embedding of the text segment in the embedding space, the operations comprising:
obtaining a batch of training pairs, each training pair including an input image and an input text segment;
obtaining data partitioning the batch of training pairs into a plurality of chunks of training pairs;
for each chunk:
performing, on a set of one or more computing devices, a first forward pass through the image encoder neural network in accordance with current values of the image encoder neural network parameters on the input images in the training pairs in the chunk to generate a respective image embedding of each input image;
performing, on the set of one or more computing devices, a first forward pass through the text encoder neural network in accordance with current values of the text encoder neural network parameters on the input text segments in the training pairs in the chunk to generate a respective text embedding of each text segment;
storing, in memory of the set of one or more computing devices, the respective image embeddings and the respective text embeddings without storing intermediate hidden states generated by performing the first forward passes through the image encoder neural network and the text encoder neural network;
for each training pair in the batch and using the respective image embeddings and the respective text embeddings for the plurality of chunks stored in the memory of the set of one or more computing devices, generating a respective similarity between the image embedding of the input image in the training pair and the respective text embeddings of the input text segments in all of the training pairs in the batch;
determining, for each training pair in the batch, a respective gradient with respect to the image embedding of the input image in the training pair of a contrastive loss function that is based on the respective similarities;
for each chunk:
performing, on the one or more computing devices, a second forward pass through the image encoder neural network in accordance with current values of the image encoder neural network parameters on the input images in the training pairs in the chunk to re-generate the intermediate hidden states of the image encoder neural network;
performing a backward pass through the image encoder neural network using the respective gradients with respect to the image embeddings of the input images in the training pairs in the chunk and the re-generated intermediate hidden states to generate a respective chunked gradient of the contrastive loss function with respect to each of the image encoder neural network parameters; and
updating the current values of the image encoder neural network parameters using the respective chunked gradients for the chunks.
15. The system of claim 14 , the operations further comprising:
determining, for each training pair in the batch, a respective gradient with respect to the text embedding of the input text segment in the training pair of the contrastive loss function that is based on the respective similarities;
for each chunk:
performing, on the one or more computing devices, a second forward pass through the text encoder neural network in accordance with current values of the text encoder neural network parameters on the input text segments in the training pairs in the chunk to re-generate the intermediate hidden states of the text encoder neural network; and
performing a backward pass through the text encoder neural network using the respective gradients with respect to the text embeddings for the text segments in the training pairs in the chunk and the re-generated intermediate hidden states of the text encoder neural network to generate a respective chunked gradient of the contrastive loss function with respect to each of the text encoder neural network parameters; and
updating the current values of the text encoder neural network parameters using the respective chunked gradients for the chunks.
16. The system of claim 14 , wherein updating the current values of the image encoder neural network parameters using the respective chunked gradients for the chunks comprises:
applying an optimizer to the current values of the image encoder neural network parameters using the respective chunked gradients.
17. The system of claim 16 , wherein the optimizer maintains respective estimates of one or more gradient moments and determines an update to the current values of the image encoder neural network parameters using the respective estimates, and wherein applying the optimizer comprises:
for each chunk and for each of the gradient moments, updating the respective estimate of the gradient moment using the respective chunked gradient for the chunk; and
determining the update using the respective estimates of each of the gradient moments after the respective estimates have been updated using the respective chunked gradients for all of the chunks.
18. The system of claim 17 , further comprising, for each chunk and after updating, for each of the gradient moments, the respective estimate of the gradient moment using the respective chunked gradient for the chunk, discarding the respective chunked gradient for the chunk.
19. The system of claim 14 , the operations further comprising:
for each chunk, after performing a backward pass through the image encoder neural network using the respective gradients with respect to the image embeddings of the training pairs in the chunk and the re-generated intermediate hidden states, discarding the re-generated intermediate hidden states prior to performing a backward pass for any subsequent chunks.
20. One or more non-transitory computer-readable storage media storing instructions that when executed by one or more computers cause the one more computers to perform operations for training an image encoder neural network having image encoder neural network parameters and configured to process an image to generate an image embedding of the image in an embedding space and a text encoder neural network having text encoder neural network parameters and configured to process a text segment to generate a text embedding of the text segment in the embedding space, the operations comprising:
obtaining a batch of training pairs, each training pair including an input image and an input text segment;
obtaining data partitioning the batch of training pairs into a plurality of chunks of training pairs;
for each chunk:
performing, on a set of one or more computing devices, a first forward pass through the image encoder neural network in accordance with current values of the image encoder neural network parameters on the input images in the training pairs in the chunk to generate a respective image embedding of each input image;
performing, on the set of one or more computing devices, a first forward pass through the text encoder neural network in accordance with current values of the text encoder neural network parameters on the input text segments in the training pairs in the chunk to generate a respective text embedding of each text segment;
storing, in memory of the set of one or more computing devices, the respective image embeddings and the respective text embeddings without storing intermediate hidden states generated by performing the first forward passes through the image encoder neural network and the text encoder neural network;
for each training pair in the batch and using the respective image embeddings and the respective text embeddings for the plurality of chunks stored in the memory of the set of one or more computing devices, generating a respective similarity between the image embedding of the input image in the training pair and the respective text embeddings of the input text segments in all of the training pairs in the batch;
determining, for each training pair in the batch, a respective gradient with respect to the image embedding of the input image in the training pair of a contrastive loss function that is based on the respective similarities;
for each chunk:
performing, on the one or more computing devices, a second forward pass through the image encoder neural network in accordance with current values of the image encoder neural network parameters on the input images in the training pairs in the chunk to re-generate the intermediate hidden states of the image encoder neural network;
performing a backward pass through the image encoder neural network using the respective gradients with respect to the image embeddings of the input images in the training pairs in the chunk and the re-generated intermediate hidden states to generate a respective chunked gradient of the contrastive loss function with respect to each of the image encoder neural network parameters; and
updating the current values of the image encoder neural network parameters using the respective chunked gradients for the chunks.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US17/988,655 US20230154161A1 (en) | 2021-11-16 | 2022-11-16 | Memory-optimized contrastive learning |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202163280105P | 2021-11-16 | 2021-11-16 | |
US17/988,655 US20230154161A1 (en) | 2021-11-16 | 2022-11-16 | Memory-optimized contrastive learning |
Publications (1)
Publication Number | Publication Date |
---|---|
US20230154161A1 true US20230154161A1 (en) | 2023-05-18 |
Family
ID=84981445
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US17/988,655 Pending US20230154161A1 (en) | 2021-11-16 | 2022-11-16 | Memory-optimized contrastive learning |
Country Status (2)
Country | Link |
---|---|
US (1) | US20230154161A1 (en) |
WO (1) | WO2023091511A2 (en) |
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20230316592A1 (en) * | 2022-03-31 | 2023-10-05 | Konica Minolta Business Solutions U.S.A., Inc. | Method and system for automated generation of representative icons from images |
-
2022
- 2022-11-16 US US17/988,655 patent/US20230154161A1/en active Pending
- 2022-11-16 WO PCT/US2022/050143 patent/WO2023091511A2/en unknown
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20230316592A1 (en) * | 2022-03-31 | 2023-10-05 | Konica Minolta Business Solutions U.S.A., Inc. | Method and system for automated generation of representative icons from images |
Also Published As
Publication number | Publication date |
---|---|
WO2023091511A3 (en) | 2023-07-27 |
WO2023091511A2 (en) | 2023-05-25 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11669744B2 (en) | Regularized neural network architecture search | |
US11651218B1 (en) | Adversartail training of neural networks | |
US10885436B1 (en) | Training text summarization neural networks with an extracted segments prediction objective | |
US11922281B2 (en) | Training machine learning models using teacher annealing | |
US20200104678A1 (en) | Training optimizer neural networks | |
US20210271970A1 (en) | Neural network optimizer search | |
US20200104687A1 (en) | Hybrid neural architecture search | |
US10679006B2 (en) | Skimming text using recurrent neural networks | |
US20200057936A1 (en) | Semi-supervised training of neural networks | |
US11488016B2 (en) | Look-up table based neural networks | |
US20240127058A1 (en) | Training neural networks using priority queues | |
US10438113B2 (en) | Hierarchical device placement with reinforcement learning | |
US11347995B2 (en) | Neural architecture search with weight sharing | |
US20210374345A1 (en) | Processing large-scale textual inputs using neural networks | |
US20220230065A1 (en) | Semi-supervised training of machine learning models using label guessing | |
EP3899806A1 (en) | Convolutional neural networks with soft kernel selection | |
WO2021178916A1 (en) | Single-stage model training for neural architecture search | |
US20230351149A1 (en) | Contrastive captioning neural networks | |
US11907825B2 (en) | Training neural networks using distributed batch normalization | |
US20230154161A1 (en) | Memory-optimized contrastive learning | |
US20220188636A1 (en) | Meta pseudo-labels | |
US20200104686A1 (en) | Decreasing neural network inference times using softmax approximation | |
US20220108149A1 (en) | Neural networks with pre-normalized layers or regularization normalization layers | |
US20220092429A1 (en) | Training neural networks using learned optimizers | |
WO2020152267A1 (en) | Learning non-differentiable weights of neural networks using evolutionary strategies |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:PHAM, HIEU HY;DAI, ZIHANG;GHIASI, GOLNAZ;AND OTHERS;SIGNING DATES FROM 20221203 TO 20221208;REEL/FRAME:062074/0426 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |