CN114073037B - RLWE compression and imperceptible expansion of plaintext - Google Patents
RLWE compression and imperceptible expansion of plaintext Download PDFInfo
- Publication number
- CN114073037B CN114073037B CN201980098195.9A CN201980098195A CN114073037B CN 114073037 B CN114073037 B CN 114073037B CN 201980098195 A CN201980098195 A CN 201980098195A CN 114073037 B CN114073037 B CN 114073037B
- Authority
- CN
- China
- Prior art keywords
- server
- encryption
- plaintext
- result
- query
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
- 230000006835 compression Effects 0.000 title claims description 8
- 238000007906 compression Methods 0.000 title claims description 8
- 238000000034 method Methods 0.000 claims abstract description 42
- 238000012545 processing Methods 0.000 claims description 52
- 230000015654 memory Effects 0.000 claims description 36
- 238000004891 communication Methods 0.000 claims description 16
- 239000013598 vector Substances 0.000 description 13
- 238000010586 diagram Methods 0.000 description 9
- 229920000582 polyisocyanurate Polymers 0.000 description 9
- 238000004590 computer program Methods 0.000 description 8
- 230000006870 function Effects 0.000 description 7
- 239000004606 Fillers/Extenders Substances 0.000 description 5
- 238000004422 calculation algorithm Methods 0.000 description 5
- 230000003287 optical effect Effects 0.000 description 3
- 230000008569 process Effects 0.000 description 3
- 230000004044 response Effects 0.000 description 3
- 230000008901 benefit Effects 0.000 description 2
- 238000004364 calculation method Methods 0.000 description 2
- 230000003993 interaction Effects 0.000 description 2
- PXFBZOLANLWPMH-UHFFFAOYSA-N 16-Epiaffinine Natural products C1C(C2=CC=CC=C2N2)=C2C(=O)CC2C(=CC)CN(C)C1C2CO PXFBZOLANLWPMH-UHFFFAOYSA-N 0.000 description 1
- 230000003592 biomimetic effect Effects 0.000 description 1
- 230000008859 change Effects 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 238000012423 maintenance Methods 0.000 description 1
- 238000012986 modification Methods 0.000 description 1
- 230000004048 modification Effects 0.000 description 1
- 230000006855 networking Effects 0.000 description 1
- 238000012946 outsourcing Methods 0.000 description 1
- 238000012856 packing Methods 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 230000001953 sensory effect Effects 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
- 230000003068 static effect Effects 0.000 description 1
- 238000012546 transfer Methods 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Abstract
A method (600) of compressing and unnoticeable expansion RLWE of plaintext includes obtaining a plaintext query (134) comprising a sequence of plaintext integers (136), and generating a polynomial (172) having coefficients (173), the coefficients (173) comprising the sequence of plaintext integers of the plaintext query. The method further includes encrypting the polynomial using the secret encryption key (132) and transmitting the encrypted polynomial (182) to the server (111). The secret encryption key is randomly sampled from a ciphertext space, and the server is configured to extend the encryption polynomial using a public encryption key (130) to obtain a sequence of encryption integers (210) related to the sequence of plaintext integers. The method also includes receiving (192) an encryption result from the server. The encryption result is based on the encrypted integer sequence.
Description
Technical Field
The present disclosure relates to compression and imperceptible expansion of RLWE plaintext.
Background
A private information retrieval (private information retrieval, PIR) scheme allows a user to retrieve data from one or more storage devices while not revealing any information about the user or the retrieved data to a server hosting the one or more storage devices. For PIRs, the server storage is typically unprotected and private information is retrieved from a public storage or server storage having a set of subscribed users, all of whom are permitted to download data from the entire storage. Although a user can simply download all content from a server storage device so that the access mode is not displayed, it can take a long time when all content must be downloaded from a cloud storage service across multiple storage devices. Furthermore, conventional PIR schemes consume a significant amount of bandwidth, particularly when a user wishes to retrieve multiple data blocks or entries from a server.
Disclosure of Invention
An aspect of the present disclosure provides a method for compressing one or more integers into an encrypted polynomial. The method includes obtaining, at data processing hardware of a user device, a plaintext query comprising a sequence of plaintext integers, and generating, by the data processing hardware, a polynomial having coefficients comprising the sequence of plaintext integers of the plaintext query. The method further includes encrypting, by the data processing hardware, the polynomial using a secret encryption key and transmitting the encrypted polynomial to a server in communication with the data processing hardware. The secret encryption key is randomly sampled from ciphertext space by data processing hardware, the server being configured to expand the encryption polynomial using a common encryption key to obtain an encrypted sequence of integers related to the plaintext sequence of integers of the plaintext query. The method further includes receiving, at the data processing hardware, an encryption result from the server. The encryption result is based on the encrypted integer sequence.
Implementations of the disclosure may include one or more of the following optional features. In some embodiments, the server is configured to, after expanding the encryption polynomial using the public encryption key: calculating the encryption result based on the un-trusted data store at the server and the encrypted integer sequence; and returning the encryption result to the user equipment. In some implementations, the server is configured to calculate the encryption result by determining an inner product of the untrusted data store and the encrypted integer sequence. Additionally or alternatively, in these embodiments, the method further comprises, after receiving the encryption result from the server, decrypting the encryption result by the data processing hardware to obtain a decryption result. Here, the decryption result corresponds to at least one data block of the untrusted data store.
In some examples, the server is configured to extend the encryption polynomial by generating a tree data structure, whereby the encryption polynomial includes a root of the tree data structure. In these examples, the top row of the tree data structure includes the encrypted integer sequence. Additionally, encrypting the polynomial may include encrypting the polynomial with a fully homomorphic encryption scheme. Each plaintext integer in the sequence of plaintext integers of the plaintext query corresponds to a selection criterion of a respective block of data of an untrusted data store at the server.
In some implementations, obtaining the plaintext query includes generating a randomized query that includes the plaintext integer sequence. In these embodiments, the method may optionally further comprise: inverting, by the data processing hardware, a plaintext integer selected from the sequence of plaintext integers of the randomized query to form a modified query; and sending, by the data processing hardware, the modified query to the server. The selected plaintext integer is associated with a corresponding data block of an untrusted data store of the server, and the server is configured to: calculating an unencrypted result based on the untrusted data store at the server and the modified query; and returning the unencrypted result to the user equipment. Optionally, the method further comprises: after receiving the encrypted result and the unencrypted result from the server, computing, by the data processing hardware, a difference between the encrypted result and the unencrypted result to obtain values of respective data blocks of the untrusted data store, the respective data blocks being associated with the selected plaintext integers of the plaintext integer sequence of the randomized query.
Another aspect of the present disclosure provides a system for compressing one or more integers into an encrypted polynomial. The system includes user data processing hardware and memory hardware in communication with the data processing hardware of the user device. The memory hardware stores instructions that, when executed on the data processing hardware, cause the data processing hardware to: a plaintext query comprising a sequence of plaintext integers is obtained and a polynomial is generated having coefficients comprising the sequence of plaintext integers of the plaintext query. The operations further include encrypting the polynomial using a secret encryption key and transmitting the encrypted polynomial to a server in communication with the data processing hardware. The secret encryption key is randomly sampled from ciphertext space by data processing hardware, the server being configured to expand the encryption polynomial using a common encryption key to obtain an encrypted sequence of integers related to the plaintext sequence of integers of the plaintext query. The operations further include receiving an encryption result from the server. The encryption result is based on the encrypted integer sequence.
The present aspects may include one or more of the following optional features. In some embodiments, the server is configured to, after expanding the encryption polynomial using the public encryption key: calculating the encryption result based on the un-trusted data store at the server and the encrypted integer sequence; and returning the encryption result to the user equipment. In these embodiments, the server may be configured to calculate the encryption result by determining an inner product of the untrusted data store and the encrypted integer sequence. Additionally or alternatively, in these embodiments, the operations further comprise, after receiving the encryption result from the server, decrypting the encryption result to obtain a decrypted result. Here, the decryption result corresponds to at least one data block of the untrusted data store.
In some examples, the server is configured to extend the encryption polynomial by generating a tree data structure, whereby the encryption polynomial includes a root of the tree data structure. In these examples, the top row of the tree data structure includes the encrypted integer sequence. Additionally, encrypting the polynomial may include encrypting the polynomial with a fully homomorphic encryption scheme. Each plaintext integer in the sequence of plaintext integers of the plaintext query corresponds to a selection criterion of a respective block of data of an untrusted data store at the server.
In some implementations, obtaining the plaintext query includes generating a randomized query that includes the plaintext integer sequence. In these embodiments, the operations may optionally further comprise: inverting a plaintext integer selected from the sequence of plaintext integers of the randomized query to form a modified query; and sending the modified query to the server. Here, the selected plaintext integer is associated with a corresponding data block of an untrusted data store of the server, and the server is configured to: calculating an unencrypted result based on the untrusted data store at the server and the modified query; and returning the unencrypted result to the user equipment. Optionally, the operations further comprise: after receiving the encrypted result and the unencrypted result from the server, calculating a difference between the encrypted result and the unencrypted result to obtain values of respective data blocks of the untrusted data store, the respective data blocks being associated with the selected plaintext integers of the plaintext integer sequence of the randomized query.
The details of one or more embodiments of the disclosure are set forth in the accompanying drawings and the description below. Other aspects, features, and advantages will be apparent from the description and drawings, and from the claims.
Drawings
FIG. 1 is a schematic diagram of an exemplary private information retrieval system that compresses and expands queries when data blocks stored on non-transitory data stores of a distributed system are significantly accessed.
FIG. 2A is a schematic diagram of a tree data structure generated by an expander of the system of FIG. 1.
FIG. 2B provides an example algorithm for expanding the encryption polynomial.
Fig. 3 is a schematic diagram of a decryptor of the system of fig. 1.
FIG. 4 is a schematic diagram of an example selection query that selects which data blocks to download from a distributed system.
Fig. 5A and 5B are schematic diagrams of the system of fig. 1 performing online and offline calculations.
FIG. 6 is a flow chart of an exemplary arrangement of the operation of a method for compressing and expanding queries when data blocks are explicitly retrieved from non-trusted storage using private information retrieval.
FIG. 7 is a schematic diagram of an exemplary computing device that may be used to implement the systems and methods described herein.
Like reference symbols in the various drawings indicate like elements.
Detailed Description
Fully homomorphic encryption (Fully homomorphic encryption, FHE) is a cryptographic system with important homomorphic characteristics that allows an untrusted party to perform secure computations on encrypted data. That is, a user with a secret key sK, a public key pK, and some data x would like to apply a function f to retrieve f (x). However, the user does not want to compute and/or does not have the computing power of application f. FHE enables the user to encrypt data under the key sK to generate an encrypted E (sK, x). The user may then wrap (outsource) the computation of x by sending the encryption E (sK, x), the function f, and the public key pK to the server. The server may then use the public key pK to calculate a certain function f 'such that decrypting f' (E (sK, x)) will generate f (x). The server then simply applies f' to the encryption E (sK, x), which can be sent back to the user to decrypt and retrieve f (x).
In many cases, the data x is not a single value, but a sequence of values x 1,...,xl, and the user wishes to outsource the computation f (x 1,...,xl) to a server. One original method of outsourcing the computation is to construct l encryptions E (sK, x 1),...,E(sK,xl) and send all l encryptions together with the public key pK to the server. However, since encryption is typically quite large, this results in significant overhead in the communication/network costs of the user and the server. Therefore, it is advantageous to compress the encryption of x 1,...,xl to less than one encryption to improve the communication cost. To support this compression, the server must be able to expand the compressed encryption back to the original l encrypts E (sK, x 1),...,E(sK,xl) in order to be able to calculate f and return the f (x) encryption. Furthermore, to maintain privacy, the extended protocol for the server must remain imperceptible (oblivious) so that the server does not know the value x 1,...,xl and the key sK.
Embodiments herein are directed to a dedicated information retrieval (private information retrieval, PIR) routine that allows a user or client to compress one or more integers into an encrypted polynomial and allows a server to expand the encrypted polynomial to retrieve the encrypted integer given a public key and the encrypted polynomial without knowing the plaintext value or key of the integer. This routine may provide compression of greater than 1000x by maximizing the use of space and packing multiple values into the same ciphertext. The server may use the expanded encrypted integer to explicitly access data blocks stored on an untrusted data store, which may be publicly known and unencrypted (e.g., plaintext). In one example, a client using a client device may wish to access map data for a particular location without revealing the location to a server. For example, a customer may just land at an airport and wish to privately retrieve his or her environment map data. The PIR routine prevents the server storing the map data from knowing which data (i.e., data revealing the client's location) was retrieved by the client device. In another example, a client may wish to download video from a server without revealing which video was downloaded. In some implementations, the PIR routine performs a portion of the computation and communication in an offline manner (i.e., when contention for resources is low), thereby reducing the online portion of the computation and communication (i.e., when contention for resources is high).
Referring to fig. 1, in some implementations, an example system 100 includes a user device 10 (also referred to as a client device 10) associated with a respective user or client device 12 and in communication with a remote system 111 via a network 112. User device 10 may correspond to any computing device, such as a desktop workstation, a laptop workstation, or a mobile device (i.e., a smart phone). The remote system 111 may be a single computer, multiple computers, or a distributed system (e.g., cloud environment) with scalable/resilient computing resources 118 (e.g., data processing hardware) and/or storage resources 116 (e.g., memory hardware). The untrusted data store 150 is overlaid (overlain) over the storage resources 116 to allow one or more client devices or computing resources 118 to use the storage resources 116 telescopically. The untrusted data store 150 is configured to store a plurality of data blocks 152,152a-n.
For example, the untrusted data store 150 includes n data blocks (B) 152 that are publicly known and unencrypted, and allows one or more client devices 10 to use PIR to ingeniously retrieve the data blocks (B) 152 to hide access patterns while retaining search functionality on the data blocks (B) 152 by the client devices 10. Thus, the client device 10 may not own the data block 152, and in some configurations, the contents of the data block 152 are available to the public. Alternatively, the data block 152 may be specific to a particular client 12, but the client 12 still wishes to hide the access pattern from the untrusted data store 150. A client device 10 (e.g., a computer) associated with a client 12 may include associated memory hardware 122 and associated data processing hardware 124. Each client device 10 may utilize associated memory hardware 122 to save or store a public key (pK) 130 and a secret key (sK) 132, as well as instructions executable by data processing hardware 124 for generating a query 134. In some examples, data processing hardware 124 executes a compressor 160 for compressing queries 134 issued to remote system 111, which may also be referred to herein as a server executing in an untrusted environment.
In some examples, the compressor 160 obtains or receives a plaintext query 134 that includes l integers 136 (i.e., a sequence of integers 136 of length l), where l is a number of integers 136 that is equal to or less than a number n of data blocks stored in the untrusted data store 150. For example, if the untrusted data store 150 includes one million data blocks 152, the query 134 will include one million or less integers 136. In some examples, and as discussed in more detail below, the integer 136 of the query 134 indicates the computation that the server 111 will make on the data block 152. That is, each integer 136 of the query 134 corresponds to a data block 152 stored on the untrusted data store 150, and the value of each integer 136 provides the server 111 with a value that is calculated from the corresponding data block 152. The compressor 160 also receives a secret encryption key (sK) 132. (sK) 132 may be randomly sampled from ciphertext space by user device 10.
In some implementations, the compressor 160 implements a polynomial generator 170, the polynomial generator 170 receiving the query 134 and generating a related polynomial 172 having coefficients 173 and an order d. Coefficients 173 of polynomial 172 include integers 136 of query 134. When the number l of integers 136 is less than the d-th order, the miss coefficient (missing coefficient) 173 may be set to zero. Conversely, when the number l of integers 136 is greater than the d-th order, the polynomial generator 170 may generate a plurality of individual polynomials 172 until all integers 136 are included as coefficients 173. In this case, a plurality of individual polynomials 172 may be combined and the plurality of individual polynomials 172 may be regarded as one individual combined polynomial 172. In some examples, polynomial generator 170 uses a method of error loop learning (RING LEARNING WITH error, RLWE) to generate polynomial 172.RLWE is directed to error learning (LEARNING WITH error, LWE) of polynomial loops over finite fields. LWE is a cryptographic method of quantum-resistance based on the difficulty of finding the value of the solution b=a×s+e, where a and B are known. That is, the LWE method (and thus by the extended RLWE method) relies on a random linear equation that has been perturbed by a small amount of noise e.
In the example shown, the compressor 160 further includes an encryptor 180 that receives the polynomial 172 and the secret encryption key (sK) 132. The encryptor 180 encrypts the polynomial 172 using the sK 132, generating an encrypted polynomial 182 using, for example, a Fully Homomorphic Encryption (FHE) scheme. For example, the encryptor 180 may use Brakerski-Gentry-Vaikuntanathan (BGV) method or Fan-Vercauteren (FV) method. FHE is a form of encryption that allows the ciphertext to be computed, producing an encrypted result that when decrypted matches the result of the operation as if the operation had been performed on plaintext. Because the encryption operation using FHE is biomimetic (affine) in its input as plaintext, the ciphertext may be represented as the encryption single term multiplied by the sum of, for example, 0 or 1 (i.e., polynomial 172 with coefficient 173).
Thereafter, the client device 10, i.e. via the data processing hardware 124, sends the encryption polynomial 182 to the server 111. Thus, the compressor 160 compresses d ciphers into a single cipher. Typical PIR schemes require a separate selection vector for each encryption. Thus, for example, if d is equal to 1024 or 2048, system 100 increases communication and/or network costs by a factor of 1024 or 2048, respectively, as compared to such conventional schemes.
With continued reference to fig. 1, in some embodiments, the server 111 (i.e., the remote system 111) executes an extender 200 that receives the encryption polynomial 182 and the public encryption key (pK) 130. When providing the encryption polynomial 182, the client device 10 may provide the pK 130. As explained in more detail below, expander 200 expands encryption polynomial 182 to inadvertently retrieve encrypted integer sequence 210E (sK, x 1),...,E(sK,xl). That is, the extender 200 retrieves the encryption of each integer 136 of the plaintext query 134 from the encryption polynomial 182, wherein each integer 136 has been encrypted by the client device 10 using the sK 132 to form the encrypted sequence of integers 210. Because the content of the sK 132 is never revealed to the server 111, the server 111 does not determine or know the plaintext value (i.e., the integer 136) associated with the encrypted integer sequence 210.
Referring now to fig. 2A, optionally, when the cryptographic polynomial 182 is expanded, the expander 200 generates a tree data structure 220 having nodes 230, 230 a-n. The encryption polynomial 182 may be set to the root 230R of the tree data structure 220. That is, the extender 200 may operate in a tree-like manner starting from the root 230R. In some examples, the height of the tree (i.e., number of layers or rows) is log 2 (d) +1. For example, a d of 1024 steps would result in a height of 10. The "top" (i.e., last layer) of tree 220 may include encrypted integer sequence 210. FIG. 2B provides an example algorithm 240 for expanding the cryptographic polynomial 182 into the cryptographic integer sequence 210. In some embodiments, tree data structure 220 takes the form of a two-dimensional array (two-dimensional array) res.
The array res may be populated by a first for loop with index i, which refers to the level (i.e., height) of the tree data structure 220, and a second for loop with index j, which iterates through all nodes 230 (of which there is 2 i) at level i of the tree 220. The index of the level starts from zero, so the first level has 2 0 =1 nodes 230, which acts as root 230R. Each node 230 of the tree 220 is associated with a corresponding value 231, 231 a-n. For non-leaf nodes 230 (i.e., nodes having at least one child node 230), these values 231 are intermediate values 231 used to calculate the final expanded ciphertext (i.e., the encrypted integer sequence 210). The value 231 associated with each node 230 will be stored in a two-dimensional array res. In particular, res [ i ] [ j ] refers to a value associated with the leftmost jth node of the ith stage. The innermost loop calculates the values 231 of the two child nodes 230 of the leftmost jth node 230 of the ith stage. The parent node refers to the value of the leftmost jth node of the ith level. In some examples, left and right refer to additional intermediate values 231 for calculating final values 231 of left and right child node values 231, respectively (which would be stored in res [ i ] [ j ] and res [ i ] [ j+2 i ], respectively). In some implementations (e.g., when server 111 is memory-constrained), intermediate value 231 is deleted after use in the loop to preserve memory. For example, after computing the value of level i, algorithm 240 of fig. 2B no longer requires values 231 of level 0, 1.
In a typical binary tree, nodes 230 are often placed in consecutive indexes. However, in some examples, extender 200 does not place node 230 in a contiguous index. Sum of algorithm 240 uses pK to correctly add two ciphertexts that have been replaced with different powers. After two loops are completed, the leaf node 230 (i.e., the highest level of the tree 220) includes the encrypted integer sequence 210. In the example shown, leaf node 230 divides by order d before returning to encrypted integer sequence 210. Alternatively, the polynomial 172 may be divided by the order d prior to encryption. In this case, a smaller parameter (e.g., noise) may be selected to reduce the bandwidth consumed by the communication between the user device 10 and the server 111 at the cost of additional computation by the user device 10.
Referring back to fig. 1, the server 111 returns the encryption result 192 to the user device 10 based on the encrypted integer sequence 210. For example, server 111 may execute calculator 190, calculator 190 receiving encrypted integer 210 and retrieving a block of data from untrusted data store 150 using the encrypted integer. For example, calculator 190 calculates encryption result 192 based on data block 152 and encrypted integer sequence 210 retrieved from untrusted data store 150.
Referring now to FIG. 3, in some examples, calculator 190 calculates encryption result 192 by determining an inner product 310 (also referred to as dot product or scalar product (scalar product)) of encrypted integer sequence 210 and data block 152 retrieved from untrusted data store 150. The encryption result 192 may include an inner product 310. In some embodiments, the user device 10 receives the encryption result 192 from the server 111 and executes (i.e., via the data processing hardware 124) the decryptor 300 for decrypting the encryption result 192 using the sK 132. The sK 132 may be stored on the local memory hardware 122 and the decryptor 300 may obtain the sK 132 for decrypting the encryption result 192. Thus, decryptor 300 outputs decryption result 302, decryption result 302 representing the result obtained by calculating inner product 310 of plaintext query 134 and data block 152, however, the retrieval is not perceived (oblivious). Decryption results 302 may correspond to any number of data blocks 152, depending on the query 134 (or queries) sent to server 111.
Referring now to the schematic view 400 of FIG. 4, in some examples, each plaintext integer 136 in the plaintext query 134 corresponds to a selection criterion for a corresponding data block 152 of the untrusted data store 150. The plaintext query 134 may include a selection vector for selecting a single block of data 152 from the untrusted data store 150. For example, the first plain query 134a input to the compressor 160 may include vectors of all zeros except a single (1) at the second location. Here, the decryptor 300 decrypts the encryption result 192 returned from the first query 134a into the decryption result 302, and the decryption result 302 includes the data block 152 corresponding to the second location of the untrusted data store 150, because the inner product 310 will multiply all data blocks 152 except the second data block by zero. Since the data block 152 multiplied by zero will be culled (drop out), the summation will result in only the data block 152 of the second position remaining. Obviously, such a query 134a may be used to imperceptibly select any data block 152 from any location (position)/position (location) of the data store 150. However, the query 134 may perform various other functions as well.
The compression algorithm performed by compressor 160 exceeds receiving only select vectors, but rather includes receiving general vectors (i.e., vectors in which each integer 136 may include any integer in plaintext space). That is, while a typical PIR scheme requires a separate selection vector (each of length equal to the number n of data blocks) to be sent to server 111 for each data block 152 to be retrieved, compressor 160 may compress d ciphers into a single general vector. For example, the second query 134b input to the compressor 160 sets three integers 136 (i.e., the 2 nd, 3 rd and the first integer 136) equal to one (1), while the remaining integers 136 are set equal to zero. Here, the second query 134b will return a corresponding encryption result 192, the encryption result 192 corresponding to the sum of the values of the 2 nd, 3 rd and first data block 152 of the untrusted data store 150. Query 134 may also retrieve a weighted sum. For example, the third query 134c input to the compressor 160 sets all integers 136 equal to one (1), except that the 3 rd integer 136 is set to the weighting coefficient α. Thus, the third query 134c will return the corresponding encryption result 192 corresponding to the weighted sum (i.e., the 3 rd data block will be weighted to α, while the remaining data blocks 152 will be weighted to 1). In yet another example, the server 111 may return an average of the plurality of data blocks 152 in response to a fourth query 134d input to the compressor 160, the fourth query 134d setting all integers 136 equal to one (1). Thus, it can be appreciated that the compressor 160 provides compression on a general vector (as opposed to a select-only vector), where the integer 136 may span the entire plaintext space.
In some implementations, the system 100 distributes computing and/or communication between offline and online periods. An offline period is defined as a period of time during which resources (e.g., bandwidth, computation, power, etc.) are relatively cheaper than during an online period. That is, there is less contention for resources during the offline period than during the online period. For example, the user device 10 (fig. 1) may connect to WiFi during the night (offline period) so that it is relatively cheaper to use mobile data than during the day (online period). Because of the multiplication coefficients (multiplicative factor) caused by the extended overhead (which may be increased by up to 4 to 5 times in some applications), the imperceptible retrieval has a considerable cost (i.e., resource usage) increase compared to the ordinary plaintext retrieval. Thus, it is advantageous to take advantage of the cost difference between online and offline periods. Thus, the system 100 may perform offline calculations to reduce costs (i.e., reduce consumed resources) by transferring extended overhead to offline periods when it is desired to perform an unaware query 134 on the untrusted data store 150.
Referring now to FIG. 5a, a diagram 500a illustrates a compressor 160 receiving a randomized plaintext query 134R during an offline period. Randomization plaintext query 134R randomizes (e.g., by data processing hardware 124) the setting of each integer 136 to equal 0 or one (1). In the example shown, the 2 nd, 4 th and 5 th integers 136 are set equal to one (1), while the remaining integers 136 are set equal to 0. As previously described, the query 134R will cause the server 111 to return an encryption result 192R, the encryption result 192R being the sum of the data blocks 152 associated with the integers 136 (i.e., the 2 nd, 4 th, and 5 th integers 136) in the randomized plaintext query 134R that are set equal to one (1). When the query 134R is conducted during an offline period, the cost of retrieving the corresponding encryption result 192R is relatively low. User device 10 may store (i.e., in local memory hardware 122) encryption result 192R and randomized plaintext query 134R until user 12 makes query 134 within an online period.
In some examples, when user 12 makes query 134 during an online period, inverter 530 executing on data processing hardware 124 inverts a single plaintext integer (i.e., selected integer 136M) of randomized plaintext query 134R to form modified query 134M. That is, when the selected integer 136M of the randomized plaintext query 134R is set equal to 0, the inverter 530 changes the selected integer 136M from 0 to one (1). On the other hand, when the selected integer 136M of the randomized plaintext query 134R is set equal to one (1), the inverter 530 changes the selected integer 136M from one (1) to 0. The inverted integer 136M of the modified query 134M (e.g., the 3 rd integer 136 in fig. 5A) corresponds to a block of data 152 that the user 12 wants to retrieve from the untrusted data store 150 in an online period. Here, inverter 530 sends modified query 134M in plaintext (IN THE CLEAR) (i.e., in plaintext (in plaintext)) to extender 200 of server 111. That is, encryptor 180 does not encrypt modified query 134M. Because the modified query 134M is not encrypted, it is a binary vector that is the number n of data blocks 152 in the data store 150 and has no extended overhead due to encryption. Thus, the bandwidth consumed by the modified query 134M is significantly less than, for example, the bandwidth consumed by the encryption polynomial 182. Because the modified query 134M is not compressed and therefore does not need to be expanded (thereby greatly reducing the computation required by the server 111), the calculator 190 of the server 111 directly receives the modified query 134M and calculates the plaintext result 520. That is, the computation (e.g., dot product) between the modified query 134M and the data block 152 includes the plaintext result 520, the plaintext result 520 being equal to the sum of the data blocks 152 selected by the modified query 134M. Server 111 may provide plaintext result 520 to user device 10.
Referring now to schematic 500B of fig. 5B, in some examples, user device 10 executes decryptor 300 (i.e., via data processing hardware 124) to decrypt previously stored encryption results 192R into corresponding decryption results 302R. Here, the previously stored encryption result 192R corresponds to the randomized plaintext query 134R that was executed during the offline period as described in fig. 5A. In these examples, data processing hardware 124 also executes a result calculator 540, result calculator 540 being configured to calculate a result difference 542 between plaintext result 520 received from server 111 and decryption result 302R output from decryptor 300.
Because the data blocks 152 retrieved in response to the query 134R,134M differ by only a single inverted integer 136M, the resulting difference 542 corresponds to the value associated with the inverted integer 136M. Thus, user device 10 retrieves data block 152 using the smallest resource during the online period, and server 111 does not determine which data block 152 to retrieve from untrusted data store 150. Encryption of the randomized query 134R ensures that the server 111 cannot determine which integer 136 has been inverted between the randomized query 134R and the modified query 134M. Because the modified query 134M was modified from the randomized query 134R, although the query 134M was sent in plaintext (i.e., as plaintext (as plaintext)) to the server 111, the server is unable to determine information from the modified query 134M. It should be noted, however, that the randomized query 134R and the encryption result 192R should not be reused to ensure privacy, as reuse would cause the server 111 to determine the differences between the modified queries 134M. In some examples, the user device 10 retrieves multiple encryption results 192R from the independent randomized query 134R to establish a "pool" of encryption results 192R and randomized query 134R for use during an online period. In some implementations, the randomized query 134R includes randomized integers sampled from the plaintext space, rather than randomized byte vectors (bit vectors). While this increases the computation, it ensures that data blocks 152 other than the retrieved data blocks 152 remain hidden from client 12 (i.e., inner product 310 does not reveal additional information about data blocks 152 to client 12). This may be advantageous when the untrusted data store 150 is private.
FIG. 6 is a flow diagram of an example method 600 for compressing a query to imperceptibly retrieve encryption results from a server. The method 600 begins at operation 602 with obtaining a plaintext query 134 at the data processing hardware 124 of the user device 10. Query 134 includes a plaintext integer sequence 136. At operation 604, the method 600 includes generating, by the data processing hardware 124, a polynomial 172 having coefficients 173. Coefficients 173 include plaintext integer sequence 136. At operation 606, the method 600 includes encrypting, by the data processing hardware 124, the polynomial 172 using the secret encryption key 132. The secret encryption key 132 is randomly sampled from the ciphertext space by the data processing hardware 124.
At operation 608, the method 600 includes transmitting, by the data processing hardware 124, the cryptographic polynomial 182 to a server 111 in communication with the data processing hardware 124. The server 111 is configured to extend the encryption polynomial 182 using the public encryption key 130 to obtain the encrypted integer sequence 210. The encrypted integer sequence 210 corresponds to the plaintext integer sequence 136 of the plaintext query 134. At step 610, method 600 includes receiving, at data processing hardware 124, encryption result 192 from server 111. The encryption result 192 is based on the encrypted integer sequence 210. In some embodiments, the method 600 includes calculating the encryption result 192 based on the untrusted data store 150 (e.g., a database) and the encrypted integer sequence 210 stored on the server 111, and returning the encryption result 192 to the user device 10. For example, the server 111 may calculate the encryption result 192 by determining an inner product 310 of the database 150 stored on the server 111 and the encrypted integer sequence 210.
FIG. 7 is a schematic diagram of an exemplary computing device 700 that may be used to implement the systems and methods described in this document. Computing device 700 is intended to represent various forms of digital computers, such as laptops, desktops, workstations, personal digital assistants, servers, blade servers, mainframes, and other appropriate computers. The components shown here, their connections and relationships, and their functions, are meant to be exemplary only, and are not meant to limit implementations of the invention described and/or claimed in this document.
Computing device 700 includes a processor 710, memory 720, storage device 730, high-speed interface/controller 740 coupled to memory 720 and to a plurality of high-speed expansion ports 750, and low-speed interface/controller 760 coupled to low-speed bus 770 and storage device 730. Each of the components 710, 720, 730, 740, 750, and 760 are interconnected using various buses, and may be mounted on a common motherboard or in other manners as appropriate. Processor 710 may process instructions for execution within computing device 700, including instructions stored in memory 720 or on storage device 730, to display graphical information for a GUI on an external input/output device, such as display 780 coupled to high speed interface 740. In other embodiments, multiple processors and/or multiple buses may be used, as appropriate, along with multiple memories and multiple memory types. In addition, multiple computing devices may be connected, each providing a portion of the necessary operations (e.g., as a server bank, a group of blade servers, or a multiprocessor system).
Memory 720 stores information non-transitory within computing device 700. Memory 720 may be a computer-readable medium, a volatile memory unit or a non-volatile memory unit. Non-transitory memory 720 may be a physical device that temporarily or permanently stores programs (e.g., sequences of instructions) or data (e.g., program state information) for use by computing device 700. Examples of non-volatile memory include, but are not limited to, flash memory and read-only memory (ROM)/programmable read-only memory (PROM)/erasable programmable read-only memory (EPROM)/electrically erasable programmable read-only memory (EEPROM) (e.g., typically used for firmware such as a boot strap). Examples of volatile memory include, but are not limited to, random Access Memory (RAM), dynamic Random Access Memory (DRAM), static Random Access Memory (SRAM), phase Change Memory (PCM), and magnetic disk or tape.
Storage device 730 is capable of providing mass storage for computing device 700. In some implementations, the storage device 730 is a computer-readable medium. In various different implementations, storage device 730 may be or contain a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or a set of devices, including devices in a storage area network or other configurations. In a further embodiment, the computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that, when executed, perform one or more methods, such as those described above. The information carrier is a computer-or machine-readable medium, such as memory 720, storage device 730, or memory on processor 710.
The high speed controller 740 manages bandwidth-intensive operations for the computing device 700, while the low speed controller 760 manages lower bandwidth-intensive operations. This allocation of functions is only an example. In some implementations, high-speed controller 740 is connected to memory 720, display 780 (e.g., via a graphics processor or accelerator), and high-speed expansion interface 750, which may accept a variety of expansion cards (not shown). In some implementations, a low-speed controller 760 is coupled to the storage device 730 and the low-speed expansion port 790. The low-speed expansion port 790, including various communication ports (e.g., USB, bluetooth, ethernet, wireless ethernet), may be connected to one or more input/output devices, such as a keyboard, pointing device, scanner, or network device, such as a switch or router, through, for example, a network adapter.
As shown, computing device 700 may be implemented in a number of different forms. For example, it may be implemented as a standard server 700a or as a laptop 700b multiple times in a group of such servers 700a, or as part of a rack server system 700 c.
Various implementations of the systems and techniques described here can be realized in digital electronic circuitry, integrated circuitry, specially designed ASICs (application specific integrated circuits), computer hardware, firmware, software, and/or combinations thereof. These various implementations may include implementations in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
A software application (i.e., a software resource) may refer to computer software that causes a computing device to perform tasks. In some examples, a software application may be referred to as an "application," app, "or" program. Example applications include, but are not limited to, system diagnostic applications, system management applications, system maintenance applications, word processing applications, spreadsheet applications, messaging applications, media streaming applications, social networking applications, and gaming applications.
These computer programs (also known as programs, software applications, or code) include machine instructions for a programmable processor, and may be implemented in a high-level procedural, and/or object-oriented programming language, and/or in assembly/machine language. The terms "machine-readable medium" and "computer-readable medium" as used herein refer to any computer program product, apparatus and/or device (e.g., magnetic discs, optical disks, memory, programmable Logic Devices (PLDs)) for providing machine instructions and/or data to a programmable processor, including a machine-readable medium that receives machine instructions as a machine-readable signal.
The processes and logic flows described in this specification can be performed by one or more programmable processors (also referred to as data processing hardware) executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Typically, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such a device. Computer readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, such as internal hard disks or removable disks; magneto-optical disk; CD ROM and DVD-ROM discs. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, one or more aspects of the disclosure can be implemented on a computer having a display device (e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor) for displaying information to the user, a keyboard, and a pointing device (e.g., a mouse or a trackball) by which the user can provide input to the computer. Other types of devices may also be used to provide for interaction with a user; for example, feedback provided to the user may be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user may be received in any form including acoustic, speech, or tactile input. Further, the computer may interact with the user by sending and receiving documents to and from the device used by the user; for example, by sending a web page to a web browser on a user's client device in response to a request received from the web browser.
Various implementations have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the disclosure. Accordingly, other implementations are within the scope of the following claims.
Claims (16)
1. A method (600) of compressing and expanding queries, the method comprising:
obtaining, at data processing hardware (124) of the user device (10), a plaintext query (134) comprising a sequence of plaintext integers (136) by generating a randomized query (134);
Generating, by the data processing hardware (124), a polynomial (172) having coefficients (173), the coefficients (173) comprising the plaintext integer sequence (136) of the plaintext query (134);
Encrypting, by the data processing hardware (124), the polynomial (182) using a secret encryption key (132), the secret encryption key (132) being randomly sampled from ciphertext space by the data processing hardware (124);
Transmitting, by the data processing hardware (124), an encryption polynomial (182) to a server (111) in communication with the data processing hardware (124), the server (111) configured to extend the encryption polynomial (182) using a public encryption key (130) to obtain an encrypted integer sequence (210), the encrypted integer sequence (210) corresponding to the plaintext integer sequence (136) of the plaintext query (134);
-receiving, at the data processing hardware (124), an encryption result (192) from the server (111), the encryption result (192) being based on the encrypted integer sequence (210);
Inverting, by the data processing hardware (124), a selected plaintext integer (136) from the sequence of plaintext integers (136) of the randomized query (134) to form a modified query (134), the selected plaintext integer (136) being associated with a respective block of data (152) of an untrusted data store (150) at the server (111);
-sending, by the data processing hardware (124), the modified query (134) to the server (111), the server (111) being configured to:
Computing an unencrypted result (192) based on an untrusted data store (150) at the server (111) and the modified query (134); and
-Returning the encryption result (192) to the user equipment (10); and
-After receiving the encrypted result (192) and the unencrypted result (192) from the server (111), calculating, by the data processing hardware (124), a difference between the encrypted result (192) and the unencrypted result (192) to obtain values of respective data blocks (152) of the untrusted data store (150), the respective data blocks (152) being associated with the selected plaintext integers (136) of the plaintext integer sequence (136) of the randomized query (134).
2. The method (600) of claim 1, wherein the server (111) is configured to extend the encryption polynomial (182) by generating a tree data structure (220), the encryption polynomial (182) comprising a root (230R) of the tree data structure (220).
3. The method (600) of claim 2, wherein a top row of the tree data structure (220) includes the encrypted integer sequence (210).
4. The method (600) of claim 1, wherein encrypting the polynomial (182) comprises encrypting the polynomial (182) with a fully homomorphic encryption scheme.
5. The method (600) of claim 1, wherein the server (111) is configured to, after expanding the encryption polynomial (182) using the public encryption key (130):
-calculating the encryption result (192) based on an untrusted data store (150) at the server (111) and the encrypted integer sequence (210); and
-Returning the encryption result (192) to the user equipment (10).
6. The method (600) of claim 5, wherein the server (111) is configured to calculate the encryption result (192) by determining an inner product (310) of the untrusted data store (150) and the encrypted integer sequence (210).
7. The method (600) of claim 5, wherein the method further comprises: after receiving the encryption result (192) from the server (111), decrypting the encryption result (192) by the data processing hardware (124) to obtain a decryption result (302), the decryption result (302) corresponding to at least one data block (152) of the untrusted data store (150).
8. The method (600) of claim 1, wherein each plaintext integer (136) in the sequence of plaintext integers (136) of the plaintext query (134) corresponds to a selection criterion of a respective data block (152) of an untrusted data store (150) at the server (111).
9. A compression and expansion query system (100), the system comprising:
Data processing hardware (124); and
Memory hardware (122) in communication with the data processing hardware (124), the memory hardware (122) storing instructions that when executed on the data processing hardware (124) cause the data processing hardware (124) to:
obtaining a plaintext query (134) comprising a sequence of plaintext integers (136) by generating a randomized query (134);
Generating a polynomial (172) having coefficients (173), the coefficients (173) comprising the plaintext integer sequence (136) of the plaintext query (134);
encrypting the polynomial (182) using a secret encryption key (132), the secret encryption key (132) being randomly sampled from ciphertext space by the data processing hardware (124);
-sending an encryption polynomial (182) to a server (111) in communication with the data processing hardware (124), the server (111) being configured to extend the encryption polynomial (182) using a common encryption key (130) to obtain a sequence of encryption integers (210), the sequence of encryption integers (210) corresponding to the sequence of plaintext integers (136) of the plaintext query (134);
-receiving an encryption result (192) from the server (111), the encryption result (192) being based on the encrypted integer sequence (210);
Inverting a selected plaintext integer (136) from the sequence of plaintext integers (136) of the randomized query (134) to form a modified query (134), the selected plaintext integer (136) being associated with a corresponding data block (152) of an untrusted data store (150) at the server (111);
-sending the modified query (134) to the server (111), the server (111) being configured to:
Computing an unencrypted result (192) based on an untrusted data store (150) at the server (111) and the modified query (134); and
-Returning the encryption result (192) to the system (100); and
After receiving the encrypted result (192) and the unencrypted result (192) from the server (111), calculating a difference between the encrypted result (192) and the unencrypted result (192) to obtain values of respective data blocks (152) of the untrusted data store (150), the respective data blocks (152) being associated with the selected plaintext integers (136) of the plaintext integer sequence (136) of the randomized query (134).
10. The system (100) of claim 9, wherein the server (111) is configured to extend the encryption polynomial (182) by generating a tree data structure (220), the encryption polynomial (182) including a root (230R) of the tree data structure (220).
11. The system (100) of claim 10, wherein a top row of the tree data structure (220) includes the encrypted integer sequence (210).
12. The system (100) of claim 9, wherein encrypting the polynomial (182) includes encrypting the polynomial (182) with a fully homomorphic encryption scheme.
13. The system (100) of claim 9, wherein the server (111) is configured to, after expanding the encryption polynomial (182) using the public encryption key (130):
-calculating the encryption result (192) based on an untrusted data store (150) at the server (111) and the encrypted integer sequence (210); and
-Returning the encryption result (192) to the system (100).
14. The system (100) of claim 13, wherein the server (111) is configured to calculate the encryption result (192) by determining an inner product (310) of the untrusted data store (150) and the encrypted integer sequence (210) at the server (111).
15. The system (100) of claim 13, wherein the operations further comprise: after receiving the encryption result (192) from the server (111), decrypting the encryption result (192) to obtain a decryption result (302), the decryption result (302) corresponding to at least one data block (152) of the untrusted data store (150) at the server (111).
16. The system (100) of claim 9, wherein each plaintext integer (136) in the sequence of plaintext integers (136) of the plaintext query (134) corresponds to a selection criterion of a respective data block (152) of an untrusted data store (150) at the server (111).
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201962845793P | 2019-05-09 | 2019-05-09 | |
US62/845,793 | 2019-05-09 | ||
PCT/US2019/064334 WO2020226695A1 (en) | 2019-05-09 | 2019-12-03 | Compression and oblivious expansion of rlwe ciphertexts |
Publications (2)
Publication Number | Publication Date |
---|---|
CN114073037A CN114073037A (en) | 2022-02-18 |
CN114073037B true CN114073037B (en) | 2024-05-17 |
Family
ID=
Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN103401871A (en) * | 2013-08-05 | 2013-11-20 | 苏州大学 | Method and system for sequencing ciphertexts orienting to homomorphic encryption |
WO2014100788A2 (en) * | 2012-12-21 | 2014-06-26 | Microsoft Corporation | Managed secure computations on encrypted data |
CN105610793A (en) * | 2015-12-18 | 2016-05-25 | 江苏大学 | Outsourced data encrypted storage and cryptograph query system and application method therefor |
US10075288B1 (en) * | 2014-02-28 | 2018-09-11 | The Governing Council Of The University Of Toronto | Systems, devices, and processes for homomorphic encryption |
EP3419211A1 (en) * | 2017-06-23 | 2018-12-26 | Flytxt B.V. | Privacy preserving computation protocol for data analytics |
Patent Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2014100788A2 (en) * | 2012-12-21 | 2014-06-26 | Microsoft Corporation | Managed secure computations on encrypted data |
CN103401871A (en) * | 2013-08-05 | 2013-11-20 | 苏州大学 | Method and system for sequencing ciphertexts orienting to homomorphic encryption |
US10075288B1 (en) * | 2014-02-28 | 2018-09-11 | The Governing Council Of The University Of Toronto | Systems, devices, and processes for homomorphic encryption |
CN105610793A (en) * | 2015-12-18 | 2016-05-25 | 江苏大学 | Outsourced data encrypted storage and cryptograph query system and application method therefor |
EP3419211A1 (en) * | 2017-06-23 | 2018-12-26 | Flytxt B.V. | Privacy preserving computation protocol for data analytics |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
TWI734368B (en) | Data homomorphic encryption and decryption method and device for realizing privacy protection | |
Raman et al. | Distributed storage meets secret sharing on the blockchain | |
US9355271B2 (en) | System and method for dynamic, non-interactive, and parallelizable searchable symmetric encryption | |
KR101829267B1 (en) | Homomorphic Encryption Method by Which Ciphertext Size Is Reduced | |
Yang et al. | Achieving efficient and privacy-preserving cross-domain big data deduplication in cloud | |
EP2947814B1 (en) | Tampering detection device, tampering detection method, and program | |
US20140270159A1 (en) | System and method for providing compressed encryption and decryption in homomorphic encryption based on integers | |
CN109361644B (en) | Fuzzy attribute based encryption method supporting rapid search and decryption | |
KR20120068524A (en) | Method and apparatus for providing data management | |
US10546032B2 (en) | System and method for association rule mining from encrypted databases | |
CN113630250B (en) | Model training method and system based on data encryption | |
CN116170142B (en) | Distributed collaborative decryption method, device and storage medium | |
US11310045B2 (en) | Compression and oblivious expansion of RLWE ciphertexts | |
CN114073037B (en) | RLWE compression and imperceptible expansion of plaintext | |
JP6693503B2 (en) | Secret search system, server device, secret search method, search method, and program | |
Vo-Huu et al. | EPiC: efficient privacy-preserving counting for MapReduce | |
JP2023529690A (en) | Apparatus and method for performing statistical calculation on isomorphic ciphertext | |
Sharma et al. | Cloud Storage Security using Firebase and Fernet Encryption | |
CN113158087A (en) | Query method and device for space text | |
Thiyagarajan et al. | Ensuring Security for Data Storage in Cloud Computing using HECC-ElGamal Cryptosystem and GSO Optimization | |
Sharma et al. | Privacy preserving on searchable encrypted data in cloud | |
CN108040068B (en) | Quick access control system based on cloud security platform | |
KR20170054696A (en) | Homomorphic encryption apparatus for cluster in cloud, method thereof and computer recordable medium storing the method | |
Rajput et al. | Performance Evaluation of AES With Different Key Size on Cloud Computing | |
CN117318918A (en) | Data homomorphic encryption method and device |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
GR01 | Patent grant |