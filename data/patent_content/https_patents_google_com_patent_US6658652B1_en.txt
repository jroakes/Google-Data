US6658652B1 - Method and system for shadow heap memory leak detection and other heap analysis in an object-oriented environment during real-time trace processing - Google Patents
Method and system for shadow heap memory leak detection and other heap analysis in an object-oriented environment during real-time trace processing Download PDFInfo
- Publication number
- US6658652B1 US6658652B1 US09/589,798 US58979800A US6658652B1 US 6658652 B1 US6658652 B1 US 6658652B1 US 58979800 A US58979800 A US 58979800A US 6658652 B1 US6658652 B1 US 6658652B1
- Authority
- US
- United States
- Prior art keywords
- data area
- heap
- function
- profile data
- live
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/02—Addressing or allocation; Relocation
- G06F12/0223—User address space allocation, e.g. contiguous or non contiguous base addressing
- G06F12/023—Free address space management
- G06F12/0253—Garbage collection, i.e. reclamation of unreferenced memory
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/362—Software debugging
- G06F11/3636—Software debugging by tracing the execution of the program
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/362—Software debugging
- G06F11/366—Software debugging using diagnostics
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/50—Allocation of resources, e.g. of the central processing unit [CPU]
- G06F9/5005—Allocation of resources, e.g. of the central processing unit [CPU] to service a request
- G06F9/5011—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resources being hardware resources other than CPUs, Servers and Terminals
- G06F9/5016—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resources being hardware resources other than CPUs, Servers and Terminals the resource being the memory
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/34—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment
- G06F11/3466—Performance evaluation by tracing or monitoring
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99951—File or database maintenance
- Y10S707/99952—Coherency, e.g. same view to multiple users
- Y10S707/99953—Recoverability
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99951—File or database maintenance
- Y10S707/99956—File allocation
- Y10S707/99957—Garbage collection
Definitions
- the present invention relates to an improved data processing system and, in particular, to a method and apparatus for optimizing performance in a data processing system. Still more particularly, the present invention provides a method and apparatus for a software program development tool for enhancing performance of a software program through software profiling.
- Performance tools are used to monitor and examine a data processing system to determine resource consumption as various software applications are executing within the data processing system. For example, a performance tool may identify the most frequently executed modules and instructions in a data processing system, or may identify those modules, which allocate the largest amount of memory or perform the most I/O requests. Hardware performance tools may be built into the system or added at a later point in time. Software performance tools also are useful in data processing systems, such as personal computer systems, which typically do not contain many, if any, built-in hardware performance tools.
- a trace tool may use more than one technique to provide trace information that indicates execution flows for an executing program.
- One technique keeps track of particular sequences of instructions by logging certain events as they occur, so-called event-based profiling technique. For example, a trace tool may log every entry into, and every exit from, a module, subroutine, method, function, or system component. Typically, a time-stamped record is produced for each such event. Corresponding pairs of records similar to entry-exit records also are used to trace execution of arbitrary code segments, starting and completing I/O or data transmission, and for many other events of interest.
- Another trace technique involves program sampling to identify certain locations in programs in which the programs appear to spend large amounts of time. This technique is based on the idea of interrupting the application or data processing system execution at regular intervals, so-called sample-based profiling. At each interruption, information is recorded for a predetermined length of time or for a predetermined number of events of interest. For example, the program counter of the currently executing thread, which is a process that is part of the larger program being profiled, may be recorded during the intervals. These values may be resolved against a load map and symbol table information for the data processing system at post-processing time, and a profile of where the time is being spent may be obtained from this analysis.
- isolating such hot spots to the instruction level permits compiler writers to find significant areas of suboptimal code generation at which they may thus focus their efforts to improve code generation efficiency.
- Another potential use of instruction level detail is to provide guidance to the designer of future systems. Such designers employ profiling tools to find characteristic code sequences and/or single instructions that require optimization for the available software for a given type of hardware.
- Other data structures can be dynamically allocated within memory when requested either by the application or by the runtime environment.
- a portion of memory is dynamically provided for the data structure or data object, and after the application is finished using the data structure, the memory space for the data structure is dynamically deallocated.
- a memory leak occurs when the dynamically allocated memory space is not properly deallocated; either the application or the runtime environment may lose its pointer or memory reference to the dynamically allocated memory space, and once lost, the pointer or memory reference may not be retrieved.
- the memory allocation mechanism which may be the operating system, will not reallocate the memory space because it was not deallocated, and a portion of memory is no longer being utilized. If one considers a newly initialized system as having a “full” memory, then the memory may slowly lose portions of its allocable space until a “low” memory condition occurs in which no more memory may be allocated, which usually causes the system to crash soon after this condition arises.
- Memory leaks are extremely difficult to find as the first and only symptom of a memory leak may be a system crash, which may occur significantly after the “leaky” code has executed.
- the Jvm may allocate memory from a “Java Heap” where the memory heap allocations and deallocations are hidden from the Java programmer.
- the Jvm uses the implied new constructor in this case as it allocates the string “ABC”.
- the deallocations are done by the Jvm asynchronously at Garbage collection (GC) time when there are no longer any reverences to the ABC string; that is, the object is no longer referenced.
- GC Garbage collection
- a method and system for detecting memory leaks in an object-oriented environment during real-time trace processing is provided.
- a profiler processes events caused by the execution of the program, and the profiler maintains a profile data structure containing execution-related metrics for the program.
- the execution-related metrics may include object allocation and deallocation metrics that are associated with object processing initiated on behalf of an executing method.
- An object allocator allocates objects during the execution of the program and modifies object allocation metrics in the profile data structure.
- Object metrics are stored in a particular location and a pointer to that location is stored in a hash table associated with the object's ID. In another embodiment a pointer to the location is stored in a shadow heap in the same relative position as the position of the object in the heap.
- the object allocation metrics and the object deallocation metrics may be compared to identify memory leaks.
- FIG. 1 depicts a distributed data processing system in which the present invention may be implemented
- FIGS. 2A-B are block diagrams depicting a data processing system in which the present invention may be implemented
- FIG. 3A is a block diagram depicting the relationship of software components operating within a computer system that may implement the present invention
- FIG. 3B is a block diagram depicting a Java virtual machine in accordance with a preferred embodiment of the present invention.
- FIG. 4 is a block diagram depicting components used to profile processes in a data processing system
- FIG. 5 is an illustration depicting various phases in profiling the active processes in an operating system
- FIG. 6 is a flowchart depicting a process used by a trace program for generating trace records from processes executing on a data processing system
- FIG. 7 is a flowchart depicting a process used in a system interrupt handler trace hook
- FIG. 9 is an illustration depicting a call stack sample
- FIG. 10A is a diagram depicting a program execution sequence along with the state of the call stack at each function entry/exitpoint;
- FIG. 10B is a diagram depicting a particular timer based sampling of the execution flow depicted in FIG. 10A;
- FIG. 11A is a diagram depicting a tree structure generated from sampling a call stack
- FIG. 11B is a diagram depicting an event tree, which reflects call stacks observed during system execution
- FIG. 12 is a table depicting a call stack tree
- FIG. 13 is a flow chart depicting a method for building a call stack tree using a trace text file as input
- FIG. 14 is a flow chart depicting a method for building a call stack tree dynamically as tracing is taking place during system execution;
- FIG. 15A is a flowchart depicting a process for creating a call stack tree structure from call stack unwind records in a trace file
- FIG. 15B is a flowchart depicting a process for identifying functions from an address obtained during sampling
- FIG. 16 is a diagram depicting a record generated using the processes of present invention.
- FIG. 17 is a diagram depicting another type of report that may be produced to show the calling structure between routines shown in FIG. 12;
- FIG. 18 is a table depicting a report generated from a trace file containing both event-based profiling information (method entry/exits) and sample-based profiling information (stack unwinds);
- FIG. 19 is a table depicting major codes and minor codes that may be employed to instrument modules for profiling
- FIG. 20 is a block diagram depicting a data structure that may be used to facilitate tracking additional information related to a routine
- FIG. 21 is a block diagram depicting a data structure that may be used to facilitate tracking additional information related to a routine without increasing the object's size using a hash table in accordance with the present invention
- FIG. 22 is a block diagram more clearly depicting a relationship between a node data area and a hash table in a data structure, that may be used to facilitate tracking memory in accordance with another embodiment of the present invention
- FIG. 23 is a flowchart depicts the process followed by object allocation code for allocating an object with trace support by utilizing a hash table in accordance with an alternative embodiment of the present invention
- FIG. 24 is a flowchart depicts the process followed by the hashing code called by the profiler for finding the proper slot in the hash table for an object in accordance with a preferred embodiment of the present invention
- FIG. 25 is a flowchart depicting the process followed by the profiler for maintaining pointers to the node data area in accordance with a preferred embodiment of the present invention.
- FIG. 26 is a flowchart depicting the process followed by object deallocation code for deallocating an object with trace support in accordance with a preferred embodiment of the present invention
- FIG. 27 is a flowchart depicting an alternate embodiment of the present invention that is specific to Java and other languages with implicit deallocation during garbage collection is depicted;
- FIG. 28 is a block diagram depicting a data structure that may be used to facilitate tracking additional information related to a routine without increasing the object's size using a shadow heap instead of a hash table in accordance with the present invention
- FIG. 29 is a flowchart depicting a process for storing information related to an object for trace support using a shadow heap in accordance with a preferred embodiment of the present;
- FIG. 30 is a block diagram depicting a relationship between a node data area and a shadow heap in a data structure that may be used to facilitate tracking memory in accordance with another embodiment of the present invention
- FIG. 31 is a flowchart depicting the process followed by the object allocation code for allocating an object with trace support, which utilizes a shadow heap in accordance with a preferred embodiment of the present invention
- FIG. 32 is a flowchart depicting the process followed by object deallocation code for deallocating an object with trace support in accordance with a preferred embodiment of the present invention
- FIG. 33 is an alternate embodiment of the present invention that is specific to Java and other languages with implicit deallocation during garbage collection is depicted;
- FIG. 34 is an example of such a live object report
- FIG. 35 shows a small extract of a report attributing live objects to specific call stack configurations, showing memory allocation information for one particular call stack;
- FIG. 36 illustrates one example of additional information that can be reported if the profiler has collected the classes of live and dying objects in addition to the counts.
- FIG. 37 shows memory allocation information for a particular call stack.
- FIG. 1 a pictorial representation of a distributed data processing system in which the present invention may be implemented is depicted.
- Distributed data processing system 100 is a network of computers in which the present invention may be implemented.
- Distributed data processing system 100 contains a network 102 , which is the medium used to provide communications links between various devices and computers connected together within distributed data processing system 100 .
- Network 102 may include permanent connections, such as wire or fiber optic cables, or temporary connections made through telephone connections.
- a server 104 is connected to network 102 along with storage unit 106 .
- clients 108 , 110 , and 112 also are connected to a network 102 .
- These clients 108 , 110 , and 112 may be, for example, personal computers or network computers.
- a network computer is any computer, coupled to a network, which receives a program or other application from another computer coupled to the network.
- server 104 provides data, such as boot files, operating system images, and applications to clients 108 - 112 .
- Clients 108 , 110 , and 112 are clients to server 104 .
- Distributed data processing system 100 may include additional servers, clients, and other devices not shown.
- distributed data processing system 100 is the Internet with network 102 representing a worldwide collection of networks and gateways that use the TCP/IP suite of protocols to communicate with one another.
- network 102 representing a worldwide collection of networks and gateways that use the TCP/IP suite of protocols to communicate with one another.
- network 102 representing a worldwide collection of networks and gateways that use the TCP/IP suite of protocols to communicate with one another.
- network 102 representing a worldwide collection of networks and gateways that use the TCP/IP suite of protocols to communicate with one another.
- At the heart of the Internet is a backbone of high-speed data communication lines between major nodes or host computers, consisting of thousands of commercial, government, educational, and other computer systems, that route data and messages.
- distributed data processing system 100 also may be implemented as a number of different types of networks, such as, for example, an Intranet or a local area network.
- FIG. 1 is intended as an example, and not as an architectural limitation for the processes of the present invention.
- Data processing system 200 may be a symmetric multiprocessor (SMP) system including a plurality of processors 202 and 204 connected to system bus 206 . Alternatively, a single processor system may be employed. Also connected to system bus 206 is memory controller/cache 208 , which provides an interface to local memory 209 . I/O Bus Bridge 210 is connected to system bus 206 and provides an interface to I/O bus 212 . Memory controller/cache 208 and I/O Bus Bridge 210 may be integrated as depicted.
- SMP symmetric multiprocessor
- Peripheral component interconnect (PCI) bus bridge 214 connected to I/O bus 212 provides an interface to PCI local bus 216 .
- a modem 218 may be connected to PCI local bus 216 .
- Typical PCI bus implementations will support four PCI expansion slots or add-in connectors.
- Communications links to network computers 108 - 112 in FIG. 1 may be provided through modem 218 and network adapter 220 connected to PCI local bus 216 through add-in boards.
- Additional PCI bus bridges 222 and 224 provide interfaces for additional PCI buses 226 and 228 , from which additional modems or network adapters may be supported. In this manner, server 200 allows connections to multiple network computers.
- a memory mapped graphics adapter 230 and hard disk 232 may also be connected to I/O bus 212 as depicted, either directly or indirectly.
- FIG. 2A may vary.
- other peripheral devices such as optical disk drive and the like also may be used in addition or in place of the hardware depicted.
- the depicted example is not meant to imply architectural limitations with respect to the present invention.
- the data processing system depicted in FIG. 2A may be, for example, an IBM RISC/System 6000 system, a product of International Business Machines Corporation in Armonk, New York, running the Advanced Interactive Executive (AIX) operating system.
- IBM RISC/System 6000 system a product of International Business Machines Corporation in Armonk, New York, running the Advanced Interactive Executive (AIX) operating system.
- AIX Advanced Interactive Executive
- Data processing system 250 is an example of a client computer.
- Data processing system 250 employs a peripheral component interconnect (PCI) local bus architecture.
- PCI peripheral component interconnect
- Processor 252 and main memory 254 are connected to PCI local bus 256 through PCI Bridge 258 .
- PCI Bridge 258 also may include an integrated memory controller and cache memory for processor 252 . Additional connections to PCI local bus 256 may be made through direct component interconnection or through add-in boards.
- local area network (LAN) adapter 260 SCSI host bus adapter 262 , and expansion bus interface 264 are connected to PCI local bus 256 by direct component connection.
- audio adapter 266 graphics adapter 268 , and audio/video adapter (A/V) 269 are connected to PCI local bus 266 by add-in boards inserted into expansion slots.
- Expansion bus interface 264 provides a connection for a keyboard and mouse adapter 270 , modem 272 , and additional memory 274 .
- SCSI host bus adapter 262 provides a connection for hard disk drive 276 , tape drive 278 , CD-ROM 280 , and DVD drive 282 in the depicted example.
- Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.
- An operating system runs on processor 252 and is used to coordinate and provide control of various components within data processing system 250 in FIG. 2 B.
- the operating system may be a commercially available operating system such as JavaOS for BusinessTM or OS/2TM, which are available from International Business Machines CorporationsTM.
- JavaOS is loaded from a server on a network to a network client and supports Java programs and applets.
- JavaOS does not support paging or virtual memory.
- An object oriented programming system such as Java may run in conjunction with the operating system and may provide calls to the operating system from Java programs or applications executing on data processing system 250 .
- Hard disk drives are often absent and memory is constrained when data processing system 250 is used as a network client.
- FIG. 2B may vary depending on the implementation.
- other peripheral devices such as optical disk drives and the like may be used in addition to or in place of the hardware depicted in FIG. 2 B.
- the depicted example is not meant to imply architectural limitations with respect to the present invention.
- the processes of the present invention may be applied to a multiprocessor data processing system.
- the present invention provides a process and system for profiling software applications. Although the present invention may operate on a variety of computer platforms and operating systems, it may also operate within a Java runtime environment. Hence, the present invention may operate in conjunction with a Java virtual machine (Jvm) yet within the boundaries of a Jvm as defined by Java standard specifications. In order to provide a context for the present invention, portions of the operation of a Jvm according to Java specifications are herein described.
- Java-based system 300 contains platform specific operating system 302 that provides hardware and system support to software executing on a specific hardware platform.
- Jvm 304 is one software application that may execute in conjunction with the operating system.
- Jvm 304 provides a Java run-time environment with the ability to execute Java application or applet 306 , which is a program, servlet, or software component written in the Java programming language.
- the computer system in which Jvm 304 operates may be similar to data processing system 200 or computer 100 described above. However, Jvm 304 may be implemented in dedicated hardware on a so-called Java chip, Java-on-silicon, or Java processor with an embedded picoJava core.
- Jvm Java run-time environment
- the Jvm is a virtual computer, i.e. a computer that is specified abstractly.
- the specification defines certain features that every Jvm must implement, with some range of design choices that may depend upon the platform on which the Jvm is designed to execute. For example, all JVMs must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes.
- a Jvm may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAs.
- the Jvm is the name of a virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the Jvm, which is itself a piece of software running on the processor.
- the Jvm allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the Jvm. In this manner, Java is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating systems architectures.
- a compiler typically generates an architecture-neutral file format—the compiled code is executable on many processors, given the presence of the Java run-time system.
- the Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture.
- a bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter.
- a Java interpreter is part of the Jvm that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Byte codes may be translated into native code by a just-in-time compiler or JIT.
- a Jvm must load class files and execute the bytecodes within them.
- the Jvm contains a class loader, which loads class files from an application and the class files from the Java application programming interfaces (APIs) which are needed by the application.
- the execution engine that executes the bytecodes may vary across platforms and implementations.
- One type of software-based execution engine is a just-in-time compiler. With this type of execution, the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for jitting a method. The native machine code for the method is then cached and reused upon the next invocation of the method.
- the execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. JVMs usually interpret bytecodes, but LJVMs may also use other techniques, such as just-in-time compiling, to execute bytecodes.
- Interpreting code provides an additional benefit. Rather than instrumenting the Java source code, the interpreter may be instrumented. Trace data may be generated via selected events and timers through the instrumented interpreter without modifying the source code. Profile instrumentation is discussed in more detail further below.
- Java application When an application is executed on a Jvm that is implemented in software on a platform-specific operating system, a Java application may interact with the host operating system by invoking native methods.
- a Java method is written in the Java language, compiled to bytecodes, and stored in class files.
- a native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.
- Jvm 350 includes a class loader subsystem 352 , which is a mechanism for loading types, such as classes and interfaces, given fully qualified names. Jvm 350 also contains runtime data areas 354 , execution engine 356 , native method interface 358 , and memory management 374 .
- Execution engine 356 is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem 352 .
- Execution engine 356 may be, for example, Java interpreter 362 or just-in-time compiler 360 .
- Native method interface 358 allows access to resources in the underlying operating system. Native method interface 358 may be, for example, a Java native interface.
- Runtime data areas 354 contain native method stacks 364 , Java stacks 366 , PC registers 368 , method area 370 , and heap 372 . These different data areas represent the organization of memory needed by Jvm 350 to execute a program.
- Java stacks 366 are used to store the state of Java method invocations. When a new thread is launched, the Jvm creates a new Java stack for the thread. The Jvm performs only two operations directly on Java stacks: it pushes and pops frames.
- a thread's Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables, the parameters with which it was invoked, its return value, if any, and intermediate calculations. Java stacks are composed of stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method, the Jvm pushes a new frame onto the Java stack of the thread.
- the Jvm pops the frame for that method and discards it.
- the Jvm does not have any registers for holding intermediate values; any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner, the Java instruction set is well defined for a variety of platform architectures.
- PC registers 368 are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register (program counter) and Java stack. If the thread is executing a Jvm method, the value of the PC register indicates the next instruction to execute. If the thread is executing a native method, then the contents of the PC register are undefined.
- Native method stacks 364 store the state of invocations of native methods. The state of native method invocations is stored in an implementation-dependent way in native method stacks, registers, or other implementation-dependent memory areas. In some Jvm implementations, native method stacks 364 and Java stacks 366 are combined.
- Method area 370 contains class data while heap 372 contains all instantiated objects.
- the Jvm specification strictly defines data types and operations. Most JVMs choose to have one method area and one heap, each of which is shared by all threads running inside the Jvm.
- the Jvm loads a class file, it parses information about a type from the binary data contained in the class file. It places this type information into the method area.
- Each time a class instance or array is created the memory for the new object is allocated from heap 372 .
- Jvm 350 includes an instruction that allocates memory space within the memory for heap 372 but includes no instruction for freeing that space within the memory.
- Memory management 374 in the depicted example manages memory space within the memory allocated to heap 370 . Memory management 374 may include a Garbage Collector, which automatically reclaims memory used by objects that are no longer referenced. Additionally, a Garbage Collector also may move objects to reduce heap fragmentation.
- processes within the following figures provide an overall perspective of the many processes employed within the present invention: processes that generate event-based profiling information; processes that generate sample-based profiling information; processes that use the profile information to generate more useful information, such as representations of call stack trees, to be placed into profile reports; and processes that generate the profile reports for the user of the profiling utility.
- a trace program 400 is used to profile processes 402 .
- Trace program 400 may be used to record data upon the execution of a hook, which is a specialized piece of code at a specific location in a routine or program in which other routines may be connected. Trace hooks are typically inserted for the purpose of debugging, performance analysis, or enhancing functionality. These trace hooks are employed to send trace data to trace program 400 , which stores the trace data in buffer 404 . The trace data in buffer 404 may be subsequently stored in a file for post-processing, or the trace data may be processed in real-time.
- the present invention employs trace hooks that aid in identifying methods that may be used in processes 402 .
- trace hooks since classes may be loaded and unloaded, these changes may also be identified using trace data. This is especially relevant with “network client” data processing systems, such as those that may operate under JavaOS, since classes and jitted methods may be loaded and unloaded more frequently due to the constrained memory and role as a network client.
- FIG. 5 a diagram depicts various phases in profiling the processes active in an operating system.
- the generated trace output may be as long and as detailed as the analyst requires for the purpose of profiling a particular program.
- An initialization phase 500 is used to capture the state of the client machine at the time tracing is initiated.
- This trace initialization data includes trace records that identify all existing threads, all loaded classes, and all methods for the loaded classes. Records from trace data captured from hooks are written to indicate thread switches, interrupts, and loading and unloading of classes and jitted methods. Any class, which is loaded, has trace records that indicate the name of the class and its methods. In the depicted example, four byte IDs are used as identifiers for threads, classes, and methods. These IDs are associated with names that have been output in the records. A record is written to indicate when all of the start up information has been written.
- a trace buffer may have a combination of types of records, such as those that may originate from a trace hook executed in response to a particular type of event, e.g., a method entry or method exit, and those that may originate from a stack walking function executed in response to a timer interrupt, e.g., a stack unwind record, also called a call stack record.
- the following process may occur during the profiling phase if the user of the profiling utility has requested sample-based profiling information.
- a trace record is written, which indicates the system program counter.
- This system program counter may be used to identify the routine that is interrupted.
- a timer interrupt is used to initiate gathering of trace data.
- Interrupts based on a programmed performance monitor event or other types of periodic events may be employed.
- the data collected in the trace buffer is sent to a trace file for post-processing.
- the file may be sent to a server, which determines the profile for the processes on the client machine.
- the post-processing also may be performed on the client machine.
- B-trees and/or hash tables may be employed to maintain names associated the records in the trace file to be processed.
- a hash table employs hashing to convert an identifier or a key, meaningful to a user, into a value for the location of the corresponding data in the table.
- each trace record is processed in a serial manner. As soon as the indicator is encountered that all of the startup information has been processed, trace records from trace hooks and trace records from timer interrupts are then processed. Timer interrupt information from the timer interrupt records are resolved with existing hash tables. In addition, this information identifies the thread and function being executed. The data is stored in hash tables with a count identifying the number of timer tick occurrences associated with each way of looking at the data. After all of the trace records are processed, the information is formatted for output in the form of a report.
- trace information may be processed on the fly so that trace data structures are maintained during the profiling phase.
- a profiling function such as a timer interrupt
- the trace record information is processed to construct and maintain any appropriate data structures.
- the data structures may contain all the information necessary for generating a profile report without the need for post-processing of the trace file.
- FIG. 6 a flowchart depicts a process used by a trace program for generating trace records from processes executing on a data processing system.
- FIG. 6 provides further detail concerning the generation of trace records that were not described with respect to FIG. 5 .
- Trace records may be produced by the execution of small pieces of code called “hooks”. Hooks may be inserted in various ways into the code executed by processes, including statically (source code) and dynamically (through modification of a loaded executable). This process is employed after trace hooks have already been inserted into the process or processes of interest.
- the process begins by allocating a buffer (step 600 ), such as buffer 404 in FIG. 4 .
- trace hooks are turned on (step 602 ), and tracing of the processes on the system begins (step 604 ). Trace data is received from the processes of interest (step 606 ). This type of tracing may be performed during phases 500 and/or 502 . This trace data is stored as trace records in the buffer (step 608 ).
- the buffer contents are sent to a file for post-processing (step 612 ).
- a report is then generated in post-processing (step 614 ) with the process terminating thereafter.
- the processes of the present invention may be used to process trace information in real-time depending on the implementation.
- FIG. 7 a flowchart depicts a process that may be used during an interrupt handler trace hook.
- the process begins by obtaining a program counter (step 700 ). Typically, the program counter is available in one of the saved program stack areas. Thereafter, an interrupted thread ID is obtained (step 701 ) and a determination is made as to whether the code being interrupted is interpreted code (step 702 ). This determination may be made by determining whether the program counter is within an address range for the interpreter used to interpret bytecodes. If the code being interrupted is interpreted, a method block address is obtained for the code being interpreted (step 704 ). A trace record is then written (step 706 ). The trace record is written by sending the trace information to a trace program, such as trace program 400 , which-generates trace records for post-processing in the depicted example. This trace record is referred to as an interrupt record, or an interrupt hook.
- a trace program such as trace program 400 , which-generates trace records for post-processing in the depicted example. This trace record is referred to as an interrupt record, or an interrupt hook.
- This type of trace may be performed during phase 502 .
- a similar process i.e. determining whether code that was interrupted is interpreted code, may occur during post-processing of a trace file.
- a set of processes may be employed to obtain sample-based profiling information.
- the applications may be periodically interrupted in order to obtain information about the current runtime environment. This information may be written to a buffer or file for post-processing, or the information may be processed on the fly into data structures representing an ongoing history of the runtime environment.
- FIGS. 8 and 9 describe sample-based profiling in more detail.
- a sample-based profiler may obtain information from the stack of an interrupted thread.
- the thread is interrupted by a software timer interrupt available in many operating systems.
- the user of the trace facility selects either the program counter option or the stack unwind option, which may be accomplished by enabling one major code or another major code, as described further below.
- This timer interrupt is employed to sample information from a call stack.
- walking-back up the call stack a complete call stack can be obtained for analysis.
- a “stack walk” may also be described as a “stack unwind”, and the process of “walking the stack” may also be described as “unwinding the stack.”
- Each of these terms illustrates a different metaphor for the process.
- the process can be described as “walking” as the process must obtain and process the stack frames step-by-step or frame-by-frame.
- the process may also be described as “unwinding” as the process must obtain and process the stack frames that point to one another, and these pointers and their information must be “unwound” through many pointer references.
- a call stack is an ordered list of routines plus offsets within routines (i.e. modules, functions, methods, etc.) that have been entered during execution of a program. For example, if routine A calls routine B, and then routine B calls routine C, while the processor is executing instructions in routine C, the call stack is ABC. When control returns from routine C back to routine B, the call stack is AB. For more compact presentation and ease of interpretation within a generated report, the names of the routines are presented without any information about offsets. Offsets could be used for more detailed analysis of the execution of a program, however, offsets are not considered further herein.
- the generated sample-based profile information reflects a sampling of call stacks, not just leaves of the possible call stacks, as in some program counter sampling techniques.
- a leaf is a node at the end of a branch, i.e. a node that has no descendants.
- a descendant is a child of a parent node, and a leaf is a node that has no children.
- a “stack” is a region of reserved memory in which a program or programs store status data, such as procedure and function call addresses, passed parameters, and sometimes local variables.
- a “stack frame” is a portion of a thread's stack that represents local storage (arguments, return addresses, return values, and local variables) for a single function invocation. Every active thread of execution has a portion of system memory allocated for its stack space.
- a thread's stack consists of sequences of stack frames. The set of frames on a thread's stack represent the state of execution of that thread at any time.
- a call stack represents all not-yet-completed function calls—in other words, it reflects the function invocation sequence at any point in time.
- Call stack 800 includes information identifying the routine that is currently running, the routine that invoked it, and so on all the way up to the main program.
- Call stack 800 includes a number of stack frames 802 , 804 , 806 , and 808 .
- stack frame 802 is at the top of call stack 800
- stack frame 808 is located at the bottom of call stack 800 .
- the top of the call stack is also referred to as the “root”.
- the timer interrupt (found in most operating systems) is modified to obtain the program counter value (pcv) of the interrupted thread, together with the pointer to the currently active stack frame for that thread. In the Intel architecture, this is typically represented by the contents of registers: EIP (program counter) and EBP (pointer to stack frame).
- the first parameter acquired is the program counter value.
- the next value is the pointer to the top of the current stack frame for the interrupted thread. In the depicted example, this value would point to EBP 808 a in stack frame 808 .
- EBP 606 points to EBP 806 a in stack frame 806 , which in turn points to EBP 804 a in stack frame 804 .
- this EBP points to EBP 802 a in stack frame 802 .
- EIPs 802 b - 808 b Within stack frames 802 - 808 are EIPs 802 b - 808 b , which identify the calling routine's return address. The routines may be identified from these addresses. Thus, routines are defined by collecting all of the return addresses by walking up or backwards through the stack.
- a call stack such as call stack 900 is obtained by walking the call stack.
- a call stack is obtained each time a periodic event, such as, for example, a timer interrupt occurs.
- These call stacks may be stored as call stack unwind trace records (also called merely “stack unwinds”) within the trace file for post-processing or may be processed on-the-fly while the program continues to execute.
- call stack 900 contains a pid 902 , which is the process identifier, and a tid 904 , which is the thread identifier.
- Call stack 900 also contains addresses addr 1 906 , addr 2 908 . . . addrN 910 .
- addr 1 906 represents the value of the program counter at the time of the interrupt. This address occurs somewhere within the scope of the interrupted function.
- addr 2 908 represents an address within the process that called the function that was interrupted. For Intel-processor-based data processing systems, it represents the return address for that call; decrementing that value by 4 results in the address of the actual call, also known as the call-site. This corresponds with EIP 808 b in FIG.
- addrN 910 is the top of the call stack (EIP 802 b ).
- the call stack that would be returned if the timer interrupt interrupted the thread whose call stack state is depicted in FIG. 8 would consist of: a pid, which is the process id of the interrupted thread; a tid, which is the thread id for the interrupted thread; a pcv, which is a program counter value (not shown on FIG. 8) for the interrupted thread; EIP 808 b ; EIP 806 b ; EIP 804 b ; and EIP 802 b .
- pcv addr 1
- EIP 808 b addr 2
- EIP 806 b addr 3
- EIP 804 b addr 4
- EIP 802 b addr 5 .
- FIG. 10A a diagram of a program execution sequence along with the state of the call stack at each function entry/exit point is provided.
- the illustration shows entries and exits occurring at regular time intervals, but this is only a simplification for the illustration. If each function (A, B, C, and X in the figure) were instrumented with entry/exit event hooks, then complete accounting of the time spent within and below each function would be readily obtained.
- the executing thread is in routine C.
- the call stack at time 0 is C.
- routine C calls routine A, and the call stack becomes CA and so on.
- the call stack in FIG. 10A is a reconstructed call stack that is generated by processing the event-based trace records in a trace file to follow such events as method entries and method exits.
- FIG. 10B in which the same program is executed but is being sampled on a regular basis.
- the interrupt occurs at a frequency equivalent to two timestamp values.
- Each sample includes a snapshot of the interrupted thread's call stack. Not all call stack combinations are seen with this technique; for example, note that routine X does not show up at all in the set of call stack samples in FIG. 10 B. This is an acceptable limitation of sampling. The idea is that with an appropriate sampling rate (e.g., 30-1000 times per second), the call stacks in which most of the time is spent will be identified. Although some call stacks are omitted, it is a minor issue provided these call stacks are combinations for which little time is consumed.
- an appropriate sampling rate e.g., 30-1000 times per second
- FIG. 10C shows an example of the manner in which time may be expended by two routines: a program's “main” calls routine A at time “t” equal to zero; routine A computes for 1 ms and then calls routine B; routine B computes for 8 ms and then returns to routine A; routine A computes for 1 ms and then returns to “main”. From the point of view of “main”, routine A took 10 ms to execute, but most of that time was spent executing instructions in routine B and was not spent executing instructions within routine A. This is a useful piece of information for a person attempting to optimize the example program. In addition, if routine B is called from many places in the program, it might be useful to know how much of the time spent in routine B was on behalf of (or when called by) routine A and how much of the time was on behalf of other routines.
- the call stack consists of the routine that is currently running, the routine that invoked it, and so on all the way up to main.
- a profiler may add a higher, thread level with the pid/tid (the process IDs and thread IDs). In any case, an attempt is made to follow the trace event records, such as method entries and exits, as shown in FIG. 10A, to reconstruct the structure of the call stack frames while the program was executing at various times during the trace.
- the post-processing of a trace file may result in a report consisting of three kinds of time spent in a routine, such as routine A: (1) base time-the time spent executing code in routine A itself; (2) cumulative time (or “CUM time” for short)—the time spent executing in routine A plus all the time spent executing every routine that routine A calls (and all the routines they call, etc.); and (3) wall-clock time or elapsed time.
- This type of timing information may be obtained from event-based trace records as these records have timestamp information for each record.
- a routine's cumulative time is the sum of all the time spent executing the routine plus the time spent executing any other routine while that routine is below it on the call stack.
- routine A's base time is 2 ms, and its cumulative time is 10 ms.
- Routine B's base time is 8 ms, and its cumulative time is also 8 ms because it does not call any other routines. It should be noted that cumulative time may not be generated if a call stack tree is being generated on the fly—cumulative time may only be computed after the fact during the post-processing phase of a profile utility.
- routine B For wall-clock or elapsed time, if while routine B was running, the system fielded an interrupt or suspended this thread to run another thread, or if routine B blocked waiting on a lock or I/O, then routine B and all the entries above routine B on the call stack accumulate elapsed time but not base or cumulative time. Base and cumulative time are unaffected by interrupts, dispatching, or blocking. Base time only increases while a routine is running, and cumulative time only increases while the routine or a routine below it on the call stack is running.
- routine A's elapsed time is the same as its cumulative time—10 ms. Changing the example slightly, suppose there was a 1 ms interrupt in the middle of B, as shown in FIG. 10 D. Routine A's base and cumulative time are unchanged at 2 ms and 10 ms, but its elapsed time is now 11 ms.
- routine A initiated two disk I/O's
- routine B initiated three more I/O's when called by routine A
- routine A's “base I/O's” are two
- routine A's “cumulative I/O's” are five. “Elapsed I/O's” would be all I/O's, including those by other threads and processes that occurred between entry to routine A and exit from routine A.
- base the amount of the tracked system resource consumed directly by this routine
- cumulative the amount of the tracked system resource consumed by this routine and all routines below it on the call stack
- elapsed the total amount of the tracked system resource consumed (by any routine) between entry to this routine and exit from the routine.
- FIG. 11A a diagram depicts a tree structure generated from trace data. This figure illustrates a call stack tree 1100 in which each node in tree structure 1100 represents a function entry point.
- each node in tree structure 1100 contains an address (addr), a base time (BASE), cumulative time (CUM) and parent and children pointers.
- addr address
- BASE base time
- CUM cumulative time
- this type of timing information may be obtained from event-based trace records as these records have timestamp information for each record.
- the address represents a function entry point.
- the base time represents the amount of time consumed directly by the thread executing this function.
- the cumulative time is the amount of time consumed by the thread executing this function and all functions below it on the call stack.
- pointers are included for each node. One pointer is a parent pointer, a pointer to the node's parent.
- Each node also contains a pointer to each child of the node.
- tree structure 1100 may be implemented in a variety of ways and that many different types of statistics may be maintained at the nodes other than those in the depicted example.
- the call stack is developed from looking back at all return addresses. These return addresses will resolve within the bodies of those functions. This information allows for accounting discrimination between distinct invocations of the same function. In other words, if function X has 2 distinct calls to function A, the time associated with those calls can be accounted for separately. However, most reports would not make this distinction.
- FIG. 11B a call stack tree which reflects call stacks observed during a specific example of system execution will now be described.
- the statistics are time-based statistics.
- the particular statistics shown include the number of distinct times the call stack is produced, the sum of the time spent in the call stack, the total time spent in the call stack plus the time in those call stacks invoked from this call stack (referred to as cumulative time), and the number of instances of this routine above this instance (indicating depth of recursion).
- the call stack is CAB, and the statistics kept for this node are 2:3:4:1.
- call stack CAB is first produced at time 2 in FIG. 10A, and is exited at time 3 .
- Call stack CAB is produced again at time 4 , and is exited at time 7 .
- the first statistic indicates that this particular call stack, CAB, is produced twice in the trace.
- the second statistic indicates that call stack CAB exists for three units of time (at time 2 , time 4 , and time 6 ).
- the third statistic indicates the cumulative amount of time spent in call stack CAB and those call stacks invoked from call stack CAB (i.e., those call stacks having CAB as a prefix, in this case CABB).
- the cumulative time in the example shown in FIG. 11B is four units of time.
- the recursion depth of call stack CAB is one, as none of the three routines present in the call stack have been recursively entered.
- each node in the tree contains data and pointers.
- the data items include the name of the routine at that V node, and the four statistics discussed above.
- many other types of statistical information may be stored at each node.
- the pointers for each node include a pointer to the node's parent, a pointer to the first child of the node (i.e. the left-most child), a pointer to the next sibling of the node, and a pointer to the next instance of a given routine in the tree. For example, in FIG.
- node 1154 would contain a parent pointer to node 1156 , a first child pointer to node 1158 , a next sibling pointer to node 1160 , and a next instance pointer to node 1162 .
- pointers may be stored to make subsequent analysis more efficient.
- other structural elements such as tables for the properties of a routine that are invariant across instances, e.g., the routine's name, may also be stored.
- the type of performance information and statistics maintained at each node are not constrained to time-based performance statistics.
- the present invention may be used to present many types of trace information in a compact manner, which supports performance queries. For example, rather than keeping statistics regarding time, tracing may be used to track the number of Java bytecodes executed in each method (i.e., routine) called.
- the tree structure of the present invention would then contain statistics regarding bytecodes executed rather than time. In particular, the quantities recorded in the second and third categories would reflect the number of bytecodes executed rather than the amount of time spent in each method.
- Tracing may also be used to track memory allocation and deallocation. Every time a routine creates an object, a trace record could be generated.
- the tree structure of the present invention would then be used to efficiently store and retrieve information regarding memory allocation. Each node would represent the number of method calls, the amount of memory allocated within a method, the amount of memory allocated by methods called by the method, and the number of methods above this instance (i.e., the measure of recursion).
- the tree structure of the present invention may be used to represent a variety of performance data in a manner which is very compact, and allows a wide variety of performance queries to be performed.
- FIG. 11B depicts one way in which data may be pictorially presented to a user. The same data may also be presented to a user in tabular form as shown in FIG. 12 .
- FIG. 12 contains a routine, pt_pidtid, which is the main process/thread, which calls routine C.
- Table 12 includes columns of data for Level 1230 , RL 1232 , Calls 1234 , Base 1236 , Cum 1238 , and Indent 1240 .
- Level 1230 is the tree level (counting from the root as level 0 ) of the node.
- RL 1232 is the recursion level.
- Calls 1234 is the number of occurrences of this particular call stack, i.e., the number of times this distinct call stack configuration occurs.
- Base 1236 is the total observed time in the particular call stack, i.e., the total time that the stack had exactly these routines on the stack.
- Cum 1238 is the total time in the particular call stack plus deeper levels below it.
- Indent 1240 depicts the level of the tree in an indented manner. From this type of call stack configuration information, it is possible to infer each unique call stack configuration, how many times the call stack configuration occurred, and how long it persisted on the stack. This type of information also provides the dynamic structure of a program, as it is possible to see which routine called which other routine. However, there is no notion of time-order in the call stack tree. It cannot be inferred that routines at a certain level were called before or after other routines on the same level.
- FIG. 13 depicts a flow chart of a method for building a call stack tree using a trace file as input.
- the call stack tree is built to illustrate module entry and exit points.
- step 1350 it is first determined if there are more trace records in the trace file (step 1350 ). If so, several pieces of data are obtained from the trace record, including the time, whether the event is an enter or an exit, and the module name (step 1352 ). Next, the last time increment is attributed to the current node in the tree (step 1354 ). A check is made to determine if the trace record is an enter or an exit record (step 1356 ). If it is an exit record, the tree is traversed to the parent (using the parent pointer), and the current tree node is set equal to the parent node (step 1358 ).
- a flow chart depicts a method for building a call stack tree dynamically as tracing is taking place during system execution.
- an event is logged, it is added to the tree in real time.
- a separate call stack tree is maintained for each thread.
- the call stack tree reflects the call stacks recorded to date, and a current tree node field indicates the current location in a particular tree.
- the thread ID is obtained (step 1471 ).
- the time, type of event i.e., in this case, whether the event is a method entry or exit
- the name of the module i.e., method
- location of the thread's call stack i.e., location of the thread's “current tree node”
- the last time increment is attributed to the current tree node (step 1474 ).
- a check is made to determine if the trace event is an enter or an exit event (step 1476 ). If it is an exit event, the tree is traversed to the parent (using the parent pointer), and the current tree node is set equal to the parent node (step 1478 ). At this point, the tree can be dynamically pruned in order to reduce the amount of memory dedicated to its maintenance (step 1479 ).
- Pruning is discussed in more detail below. If the trace event is an enter event, a check is made to determine if the module is already a child node of the current tree node (step 1480 ). If not, a new node is created for the module, and it is attached to the tree below the current tree node (step 1482 ). The tree is then traversed to the module's node, and the current tree node is set equal to the module node (step 1484 ). The number of calls to the current tree node is then incremented (step 1486 ). Control is then passed back to the executing module, and the dynamic tracing/reduction program waits for the next event to occur (step 1488 ).
- One of the advantages of using the dynamic tracing/reduction technique described in FIG. 14 is its enablement of long-term system trace collection with a finite memory buffer. Very detailed performance profiles may be obtained without the expense of an “infinite” trace buffer. Coupled with dynamic pruning, the method depicted in FIG. 14 can support a fixed-buffer-size trace mechanism.
- dynamic tracing and reduction is especially useful in profiling the performance characteristics of long running programs.
- a finite trace buffer can severely impact the amount of useful trace information that may be collected and analyzed.
- dynamic tracing and reduction and perhaps dynamic pruning
- an accurate and informative performance profile may be obtained for a long running program.
- Pruning can be performed in many ways, and a variety of pruning criteria is possible. For example, pruning decisions may be based on the amount of cumulative time attributed to a subtree. Note that pruning may be disabled unless the amount of memory dedicated to maintaining the call stack exceeds some limit.
- the cumulative time associated with the current node is compared with the cumulative time associated with the parent node. If the ratio of these two cumulative times does not exceed a pruning threshold (e.g., 0.1), then the current node and all of its descendants are removed from the tree.
- the algorithm to build the tree proceeds as before by traversing to the parent, and changing the current node to the parent.
- the pruning threshold can be raised or lowered to regulate the level of pruning from very aggressive to none.
- More global techniques are also possible, including a periodic sweep of the entire call stack tree, removing all subtrees whose individual cumulative times are not a significant fraction of their parent node's cumulative times.
- Data reduction allows analysis programs to easily and quickly answer many questions regarding how computing time was spent within the traced program. This information may be gathered by “walking the tree” and accumulating the data stored at various nodes within the call stack tree, from which it can be determined the amount of time spent strictly within routine A, the total amount of time spent in routine A and in the routines called by routine A either directly or indirectly, etc.
- FIG. 15A a flowchart depicts a process for creating a call stack tree structure from call stack unwind records in a trace file.
- FIGS. 10A-14 above primarily showed the processes involved in generating a call stack tree from event-based trace records, which show events such as method entries and method exits. These types of trace records allow a call stack to be generated, usually during a postprocessing phase of the profile tool or utility. Using timer interrupts, a profiling function may walk an active call stack to generate a call stack unwind trace record.
- FIG. 15A describes a process for combining the information in a call stack unwind trace record into a call stack tree.
- the call stack tree may have been previously constructed from other call stack unwind trace records or from event-based trace records according to the methods described in FIGS. 10A-14.
- the process begins by reading a call stack unwind record (step 1500 ). This step processes the call stack information in the record to determine what routines are or were executing when the timer interrupt occurs or occurred, depending on whether the call stack unwind record is being processed on-the-fly or is being postprocessed.
- a sample-based profiling function avoids, through the call stack unwind, the need for adding additional instructions to the program, which affects the performance and time spent in routines.
- the process then sets sample_address equal to the call_stack_address[index] (step 1512 ).
- the B-tree is then used to lookup the address to get a routine name (step 1513 ).
- a determination is made as to whether PTR.child.name for any child of PTR is equal to the looked-up routine name (step 1514 ). In other words, this step determines whether the routine name has ever been seen at this level in the tree structure.
- step 1516 the cumulative time for the node is incremented by incrementing the variable PTR.child.CUM (step 1518 ).
- step 1518 the cumulative time represents the number of times that this particular call stack configuration has been processed.
- step 1520 a determination is made as to whether the sample address, sample_address, is equal the last address in the call stack sample, call_stack_address[ 1 ] (step 1520 ). If the sample address is equal to the address being processed, the base time for the node is incremented by incrementing the variable PTR.child.BASE (step 1522 ). The pointer PTR is then set equal to the child (step 1524 ), and the index is decremented (step 1526 ) with the process then returning to step 1508 as previously described. With reference again to step 1520 , if the sample address is not equal to the address being processed, the process then proceeds to step 1524 .
- step 1510 may be modified to wait until the next timer interrupt occurs and then continue to loop back to step 1510 at the next interrupt.
- the addresses obtained during sampling are used to identify functions.
- the functions are identified by mapping these addresses into functions.
- a flowchart depicts a process for identifying functions from an address obtained during sampling.
- the process begins by reading a program counter value that is obtained during sampling of the call stack (step 1550 ).
- a determination is made as to whether the end of file has been reached (step 1552 ). If the end of the file has not been reached, the program counter value is looked up in a global map (step 1554 ).
- a global map in the depicted example is a map of system and per process symbols that are generated from system loader information and application, library, and system symbol tables.
- a process plus function id is obtained from the global map in response to looking up the program counter value (step 1556 ). Thereafter, the process returns to step 1550 .
- the function information may be used in generating reports, such as those described below.
- the process in FIG. 15B also may be used during execution of a program that is sampled.
- FIG. 16 a diagram of a record generated using the processes of present invention is depicted.
- Each routine in record 1600 is listed separately, along with information regarding the routine in FIG. 16 .
- calls column 1602 lists the number of times each routine has been called.
- BASE column 1604 contains the total time spent in the routine, while CUM column 1606 includes the cumulative time spent in the routine and all routines called by the routine.
- Name column 1608 contains the name of the routine.
- diagram 1700 illustrates much of the same information found in FIG. 17, but in a slightly different format.
- diagram 1700 includes information on calls, base time, and cumulative time.
- FIG. 17 shows a trace output containing times spent within various routines as measured in microseconds.
- FIG. 17 contains one stanza (delimited by horizontal lines) for each routine that appears in the trace output.
- the stanza contains information about the routine itself on the line labeled “Self”, about who called it on lines labeled “Parent”, and about who the routine called on lines labeled “Child”.
- the stanzas are in order of cumulative time.
- the third stanza is about routine A, as indicated by the line beginning with “Self.”
- the numbers on the “Self” line of this stanza show that routine A was called three times in this trace, once by routine C and twice by routine B.
- routines C and B are (immediate) parents of routine A.
- Routine A is a child of routines C and B. All the numbers on the “Parent” rows of the second stanza are breakdowns of routine A's corresponding numbers. Three microseconds of the seven microsecond total base time spent in A was when it was called by routine C, and three microseconds when it was first called by routine B, and another one microsecond when it was called by routine B for a second time. Likewise, in this example, half of routine A's fourteen microsecond cumulative time was spent on behalf of each parent.
- routine C called routine B and routine A once each. All the numbers on “Child” rows are subsets of numbers from the child's profile. For example, of the three calls to routine A in this trace, one was by routine C; of routine A's seven microsecond total base time, three microseconds were while it was called directly by routine C; of routine A's fourteen microsecond cumulative time, seven microseconds was on behalf of routine C. Notice that these same numbers are the first row of the third stanza, where routine C is listed as one of routine A's parents.
- Program sampling may contain information from the call stack and may provide a profile reflecting the sampling of an entire call stack, not just the leaves.
- the sample-based profiling technique may also be applied to other types of stacks. For example, with Java programs, a large amount of time is spent in a routine called the “interpreter”. If only the call stack was examined, the profile would not reveal much useful information. Since the interpreter also tracks information in its own stack, e.g., a Java stack (with its own linkage conventions), the process can be used to walk up the Java stack to obtain the calling sequence from the perspective of the interpreted Java program.
- FIG. 18 a figure depicts a report generated from a trace file containing both event-based profiling information, such as method entry/exits, and stack unwind information generated during sample-based profiling.
- FIG. 1B is similar to FIG. 12, in which a call stack tree is presented as a report, except that FIG. 18 contains embedded stack walking information.
- Call stack tree 1800 contains two stack unwinds generated within the time period represented by the total of 342 ticks.
- Stack unwind identifier 1802 denotes the beginning of stack unwind information 1806 , with the names of routines that are indented to the right containing the stack information that the stack walking process was able to discern.
- Stack unwind identifier 1804 denotes the beginning of stack unwind information 1808 .
- J: identifies an interpreted Java method
- F: identifies a native function, such as a native function within JavaOS.
- a call from a Java method to a native method is via “ExecuteJava.”
- ExecuteJava a native function within JavaOS.
- identifiers 1802 and 1804 also denote the major code associated with the stack unwind.
- a table depicts major codes and minor codes that may be employed to instrument software modules for profiling.
- a set of codes may be used to turn on and off various types of profiling functions in a particular profiling session.
- the minor code for a stack unwind is designated as 0x7fffffff, which may be used for two different purposes.
- the first purpose denoted with a major code of 0x40, is for a stack unwind during a timer interrupt.
- the second purpose denoted with a major code of 0x41, is for a stack unwind in an instrumented routine.
- a profile or major code purpose of tracing jitted methods with a major code value of 0x50. Tracing of jitted methods may be distinguished based on the minor code that indicates method invocation or method exit. In contrast, a major code of 0x30 indicates a profiling purpose of instrumenting interpreted methods, while the minor code again indicates, with the same values, method invocation or method exit.
- the connection can be made between the use of major and minor codes, the instrumentation of code, and the post-processing of profile information.
- the stack unwind identifiers can be seen to be equal to 0x40, which, according to the table in FIG. 19, is a stack unwind generated in response to a timer interrupt. This type of stack unwind may have occurred in response to an interrupt that was created in order to generate a sampled profile of the executing software.
- a stack unwind may be instrumented into a routine. If so, the output for this type of stack unwind will be designated with a major code of 0x41.
- tracing may also be used to track memory allocation and deallocation in order to find and resolve memory leaks.
- a memory leak occurs when the dynamically allocated memory space is not properly deallocated.
- the memory allocation mechanism which may be the Jvm, cannot reallocate the memory space because it was not deallocated, and a portion of memory is no longer being utilized. Over time, the amount of allocable memory may gradually diminish.
- memory leaks are extremely difficult to find, as the first and only symptom of a memory leak may be a system crash, which may occur significantly after the “leaky” code has executed.
- the system may enter a soft shutdown mode in which an application is safely halted without crashing.
- the present invention may enable a software developer to identify a memory leak. Every time a routine creates an object, thereby requiring memory allocation for the object, an event may be generated, and the profiler may be notified of the memory allocation event. To process the event, a call stack tree structure maintained in real-time by the profiler may then be used to efficiently store and retrieve information regarding memory allocation.
- Each node representing a routine could store the number of method calls, the amount of memory allocated within a method, the amount of memory allocated by methods called by the method, and the number of methods above in this instance (i.e., the measure of recursion), etc. This provides memory allocation and deallocation information in conjunction with a method call stack context. However, keeping track of memory deallocations related to objects created for a method is difficult because objects in an object-oriented runtime environment are generally freed by a Garbage Collector, such as, a Garbage Collector within memory management 374 .
- FIG. 20 a block diagram depicting a data structure that may be used to facilitate tracking additional information related to a routine. This process is more thoroughly discussed in “METHOD AND SYSTEM FOR MEMORY LEAK DETECTION IN AN OBJECT-ORIENTED ENVIRONMENT DURING REAL-TIME TRACE PROCESSING”, U.S. application Ser. No. 09/414,331, which is incorporated herein by reference.
- Node 2002 is similar to one of the nodes depicted within FIG. 11 A.
- Address 2004 represents a routine entry point.
- Base metric 2006 (“BASE”) represents the amount of a tracked metric (such as time) consumed directly by the execution of the routine represented by node 2002 .
- Cumulative metric 2008 (“CUM”) is the amount of a metric (such as time) consumed by the execution of this routine and all routines below it on the call stack.
- Parent 2010 is a pointer to this node's parent node in the call stack tree.
- Children 2012 are pointers to each child node of this node.
- DPTR 2014 is a pointer to a node data area provided by the profiler.
- DPTR pointer to the node data area
- the profiler allocates a node data area for a node, which represents a method that has had an object, allocated.
- Node 2020 represents a method that has had at least one object allocation, so node 2020 has DPTR 2022 that points to node data area 2030 , which is one of several node data areas maintained by the profiler, such as node data area 2040 and node data area 2050 .
- the profiler may use a variety of data structures for maintaining the node data areas, such as, a linked list. As a node data area is needed for a node, a new element may be added to the linked list.
- the profiler has its own buffer area or “mini heap” from which it may allocate space for each node data area. Here space in mini heap 2032 has been allocated for node data areas 2050 , 2040 and 2030 .
- Node data area 2030 may contain a variety of information related to a node including statistical data, or as described in the above-mentioned patent application, memory allocation information. In the case of memory allocation, node data area 2030 may contain, for example, the number of object allocations, number of object deallocations, number of bytes allocated, number of bytes deallocated, counts and classes of live objects, and other memory-related information.
- the pointer to the node data area for node 2020 is returned to the object allocation code, and the object allocation code places the pointer to the node data area within the object.
- the profiler returns the pointer to the node data area for each object allocated for the method represented by node 2020 , so each object “owned” by the method contains this pointer.
- the object allocation code allocates objects from a heap, such as Jvm heap 2060 .
- a heap such as Jvm heap 2060 .
- each object owned by a method has been modified to hold a copy of the appropriate node data area pointer.
- objects 2062 , 2064 , 2066 and 2068 owned by node 2020 contain copies of its DPTR 2022 .
- One problem associated with modifying an object's size is allocating the additional space in the heap needed to accommodate the object. If the modified object fits into a minimum allocation area designated for an object then no further allocation of heap area is necessary by the object allocation code. However, if the modified object does not fit within the minimum allocation area designated for the object, then the object allocation code must allocate an additional minimum allocation area for the portion of the object not fitting into the allocated area of the heap. In this case, most of the additional area allocated in the heap is unused and wasted because its only content is a pointer. If the insertion of node data area pointer in an object does not increase the object's size over that in the minimum allocation area the memory space in the heap is conserved and even optimized because no additional space must be allocated from the heap for the pointer. However, if the inclusion of a pointer within an object increases the object's area over the area allocated in the heap, then the additional minimum allocation area allocated in the heap for the object is mostly wasted because the area is used only for object overflow caused by inserting the pointer.
- a final problem associated with modifying an object is that the pointer affects the object's behavior. It is not unreasonable to assume that the object code defining an object has been optimized prior to allocating the object. If that object is then modified it cannot be taken for granted that the object will behave as expected. While the differences in the object with and without the pointer may only amount to a slight reduction in performance, this slight reduction cannot be assured. Moreover, the inclusion of the pointer has the affect of slanting some of the statistical information sought by including the pointer in the first place. Thus, the inclusion of a pointer affects the very post processing information that was originally sought by including the pointer.
- FIG. 21 a block diagram depicting a data structure that may be used to facilitate tracking additional information related to a routine without increasing the object's size using a hash table in accordance with the present invention.
- Node 2120 is similar to node 2020 depicted in FIG. 20 above, which in turn is one of the nodes depicted within FIG. 11 A.
- Node 2120 includes a data item related to non-temporal profile statistics, DPTR 2122 , which is a pointer to a node data area provided by the profiler. As discussed above, when a node is created, a node data area is not automatically allocated for the node, and its DPTR is initialized to zero or NULL.
- Profiler 2110 allocates a node data area for a node, which represents a method that has had an object allocated.
- Node 2120 represents a method that has had at least one object allocation, so node 2120 has DPTR 2122 that points to node data area 2130 , which is one of several node data areas residing in mini heap 2132 maintained by the profiler, such as, node data area 2140 and node data area 2150 .
- Profiler 2110 may use a variety of data structures for maintaining the node data areas, such as, a linked list. As a node data area is needed for a node, a new element may be added to the linked list. Alternatively, the profiler has its own buffer area or “mini-heap” from which it may allocate space for each node data area. Space in mini heap 2132 has been allocated for node data areas 2150 , 2140 and 2130 .
- Node data area 2130 may contain a variety of information related to a node including statistical data, or, as described in the U.S. application Ser. No. 09/414,331, memory allocation information. In the case of memory allocation, node data area 2130 may contain the number of object allocations, number of object deallocations, number of bytes allocated, number of bytes deallocated, and counts and classes of live objects.
- the hash table 2161 is used for storing pointers to node data areas rather than storing them inside the objects themselves.
- profiler 2110 maintains a call stack tree structure in real-time for efficient storage and retrieval of information, such as, memory allocation information. Once a method is called, profiler 2110 allocates memory from its buffer area and initializes a hash table within the allocated memory.
- Hash table 2161 is implemented as an array. Each node or slot in hash table 2161 contains a hash value (or key) and a pair of data values.
- the pair of data values comprise an object ID (or element) and a pointer to a node data area.
- a key is an integer generated from an element such as a string of text or in this case, an object ID.
- object IDs are the elements to be hashed into unique key values. Therefore, the minimum number of unique key values needed for a method is also the number of objects allocated for a method.
- a key value is an integer that is substantially smaller than the element (or object ID) itself.
- a key is generated by a formula in such a way that it is unlikely that two elements or object IDs will produce the same key.
- the range of the keys' values determines the size of the hash table so an ideal mapping function, H(t), limits the size of hash table 2161 without substantially increasing he number of collisions. Ideally,
- Hash table 2161 requires that the mapping function, h(k), be a one-to-one mapping from each k to integers in (1,m), that is a perfect hashing function. Unfortunately, finding a perfect hashing function for all possible object IDs is not possible. Therefore, a small number of elements may map on to the same key.
- a key When a key is generated from an object ID it is necessary to compare the key with the key slot in the hash table. Objects having identical IDs will map to the same slot, and since object IDs are unique each slot in the hash table should hold a unique element. However, a key may be hashed to a slot where a key has previously been hashed. This is called a collision. No two elements will occupy the same slot. A collision means that there is more than one unique element that hashed to a single slot of the hash table.
- Various techniques are used to manage collisions such as chaining, overflow areas, and re-hashing schemes. Re-hashing schemes include using neighboring slots (linear probing); quadratic probing; and random probing. Each of these techniques will be discussed briefly below.
- Re-hashing schemes use a second hashing operation when there is a collision. If there is a further collision, another re-hash takes place until an empty “islot” in the hash table is found.
- the re-hashing function can either be a new function or a re-application of the hash function. The functions must be applied to a key in the same order.
- Linear probing is one of the simplest re-hashing functions. For instance, varying the key by +1 (or ⁇ 1) on a collision, allows for effectively looking in neighboring slots in the hash table for an empty slot. Linear probing quickly calculates the new slot address extremely effectively but is subject to a clustering phenomenon, wherein, re-hashes from one location occupy a block of slots in the table which “grows” towards slots to which other keys hash. Clustering invites more collisions and therefore, the number of re-hashed keys can become large.
- Quadratic probing is where a secondary hash function depends on a re-hash index such as:
- Random probing utilizes a random function for rehashing a key after a collision.
- re-hashing schemes use the originally allocated hash table space and thus, avoid linked list overhead, but require advance knowledge of the number of items to be stored.
- collision elements are stored in slots to which other keys map directly thus, the potential for multiple collisions increase as the table becomes full. Therefore, the size of a hash table allocation is inversely proportional to the anticipated number of collisions.
- Chaining involves linking all collisions in lists attached to the appropriate hash table slot. Chaining handles an unlimited number of collisions and doesn't require prior knowledge of how many keys are contained in the collection to be hashed.
- Overflow areas are another scheme where the originally allocated hash table is divided into two sections: the primary area to which keys are mapped and an area for collisions; the overflow area. When a collision occurs, a slot in the overflow area is used for the new element and a link from the primary slot established as in a chained system.
- Overflow area schemes are essentially chaining, except that the overflow area is pre-allocated and thus possibly faster to access.
- object hash table 2161 remains empty.
- object allocation code 2112 allocates space in Jvm heap 2160 for the object, for instance, object A 2162 .
- Object allocation code 2112 issues an object allocation event to the profiler 2110 .
- Profiler 2110 calls the hashing algorithm code 2111 to determine a slot in hash table 2161 for a pointer to the data node area owned by the method. This is accomplished by hashing the object's unique ID using hash function H(k) 2114 .
- object IDs are not addresses of the object and addresses from C MALLOCs are also handled, then an object type must be used to distinguish two objects with the same ID. For the purposes of this patent application, we assume that this object type is incorporated into the object ID and is thus always unique.
- the profiler 2110 After the object allocation code 2112 has called the profiler 2110 with an object allocation event, the profiler 2110 allocates a pointer DPTR 2122 for node data area 2130 .
- the profiler then calls hashing algorithm code 2111 , which hashes object A's ID using hash function H(k) 2114 .
- the result of hashing object A's ID is an integer key depicted as key A 2172 .
- Hashing algorithm code 2111 then checks the object ID field of slot key A 2172 in hash table 2161 . If a NULL is returned, key A 2172 is the proper slot for object A in hash table 2161 . Space for DPTR 2122 in hash table 2161 is thereby reserved at a slot number having an integer value equal to key A 2172 .
- Hashing algorithm code 2111 then stores object A ID 2182 , in the object ID field and DPTR 2122 in a data pointer field in hash table 2161 .
- object A's hashed ID may collide with another previously stored hashed object ID in hash table 2160 .
- a NULL is not returned when hashing algorithm code 2111 checks the object ID field.
- An object ID might instead be returned.
- hash function H(k) 2114 produced key C 2176 , rather than key A 2172 . Because slot key C 2176 is presently occupied with object C ID 2186 a collision occurs.
- Hashing algorithm code 2111 returns object C ID 2186 rather then a NULL.
- hashing algorithm code 2111 cannot enter object A's ID data in slot key C 2176 because the fields are full. Therefore, hashing algorithm code 2111 returns to collision management function reH(k) 2116 for a new slot to check.
- Collision management function reH (k) 2116 may be any one of the schemes described above, however, it should be understood that the collision management scheme used for storing the data must be the collision management scheme used for accessing previously entered data. Collision management function 2116 returns another key, key A 2172 and hashing algorithm code 2111 again checks the object ID field at the slot number having an integer value equal to key A 2172 . If a NULL is returned then object A ID 2182 is stored in the object ID field and DPTR 2122 is stored in the data pointer field.
- Reclaiming deallocated objects works in reverse.
- the garbage collection code sends an event to the profiler, which calls the hashing algorithm 2111 with the freed object's ID.
- the hashing algorithm hashes the Object's ID using hash function H(k) 2114 , for example, object B. If key N 2178 is returned, the reclamation code checks the object ID field at the slot number having an integer value equal to key N 2178 .
- Object N ID 2188 is returned and compared with object B's ID 2184 . Because object B's ID 2184 is different from Object N ID 2188 , a collision has occurred between object B's key 2174 and object N's key 2178 .
- the reclamation code repeatedly returns to collision management system 2116 for another key until key B 2174 is returned.
- the reclamation code can then reclaim the slot in hash table 2160 by nulling or zeroing both the object ID field and the data pointer field. Slot key B 2174 in hash table 2160 would then have NULL written over both object B ID 2184 and DPTR 2122 . With the data pointer nulled, the reference is lost from node data area 2130 to object B's slot in hash table 2160 .
- the object could be marked “freed” and all data pointers (DPTRs) left alone.
- the hashing algorithm would be augmented to never match on a “freed” object.
- FIG. 22 a block diagram more clearly depicting a relationship between a node data area and a hash table in a data structure, that may be used to facilitate tracking memory in accordance with another embodiment of the present invention.
- the diagram depicted in FIG. 22 is similar in many respects to the diagram depicted in FIG. 21, therefore, only the differences between the two will be described in detail.
- Node 2220 owns node data area 2230 and contains pointer DPTR 2222 that points to node data area 2230 .
- node data area 2230 holds memory usage information which tracks heap memory usage by node 2220 .
- a heap may contain either allocated or ‘live’ objects which are currently active, deallocated or ‘dying’ objects which have no reference to another object and therefore, are not active or free space.
- the ‘dying’ objects are freed during garbage collection.
- Garbage collection is a routine that searches the memory heap for objects that are no longer active in order to reclaim that space. Any object that is not referenced is, by definition, not active. Objects that have been deallocated are not referenced and hence not active.
- a Garbage Collector's primary function is to make as much memory available in the heap as possible, but may also reorganize the distribution of the objects within the heap, known as compaction.
- node data area 2230 tracks memory usage by total allocations, measured by total allocated objects 2231 and total allocated bytes 2232 and by total live allocations, measured by total live objects 2233 and total live bytes 2234 .
- Total allocations refer to the object count and space that has been allocated but may not currently be allocated, while live allocations refer to current object count and space allocations.
- Node 2220 will contain pointer DPTR 2222 after one object has been allocated for the method. Each time an object is allocated the profiler increments the total allocations and total live allocations contained in node data area 2230 . The pointer is then placed in hash table 2261 with the object's ID as described above with respect to FIG. 21 .
- hash table 2261 comprises a series of slots each indexed to a unique key value, e.g., key values 2272 - 2278 .
- Each slot contains an object ID field and a data area pointer field.
- the object ID column of hash table 2261 represents object A ID 2282 , object B ID 2284 , object C ID 2286 and object N ID 2288 as being allocated as each has a copy of pointer DPTR 2222 in their respective data pointer fields.
- the third column of hash table 2261 is set with a data pointer only when an object has been allocated for that particular slot in hash table 2261 .
- Total allocation objects 2231 and total allocation bytes 2232 stored in node data area 2230 are incremented as each of object A ID 2282 , object B ID 2284 , object C ID 2286 , and object N ID 2288 is allocated.
- Hash table 2261 merely lists objects that were alive at some point since the last garbage collection. Therefore, the only accurate live object count can be acquired at garbage collection time. It is during garbage collection that the object deallocate event is issued.
- the garbage collection code may only account for live objects.
- the total live objects 2233 and total live bytes 2234 are both zeroed at the beginning of each garbage collection.
- a flowchart depicts the process followed by object allocation code for allocating an object with trace support by utilizing a hash table in accordance with an alternative embodiment of the present invention.
- the process begins when the object allocation code allocates memory for an object for the current method (step 2302 ).
- the object allocation code sends an object allocation event to the profiler (step 2304 ).
- a check is made by the profiler to determine if a hash table for the current method already exists (step 2306 ). If one does not exist the profiler allocates memory from its buffer area and initializes a hash table for the current method within the allocated memory (step 2308 ).
- the profiler calls the hashing code to determine the correct slot in the hash table in which to put the Object ID and the pointer to this method's node data area (step 2310 ).
- the profiler increments the number of total and live objects allocated and the number of total and live bytes allocated for the method via the node data area pointer (step 2312 ).
- the profiler may record additional information in the node data area; for example in addition to counts, the actual classes of the live objects could be recorded in a linked list in the node data area (not shown in FIG. 22.)
- the classes of live objects while not usually necessary for memory leak detection, may be of interest to analysts and developers.
- the ability to record arbitrary information related to memory usage shows the 9 power and generality of the present invention. The process is complete with respect to the allocation of an object “owned” by a method.
- FIG. 24 a flowchart depicts the process followed by the hashing code called by the profiler for finding the proper slot in the hash table for an object in accordance with a preferred embodiment of the present invention. This process expands on step 2310 shown in FIG. 23 .
- the process begins by hashing the object ID for a newly allocated object using hash function H(k) which returns an integer key value (step 2402 ).
- the object allocation code locates a slot in the hash table having an identical key value (step 2404 ).
- a value stored in the object field of the key value slot is retrieved (step 2406 ).
- the object allocation code checks for collisions (step 2408 ). A collision can occur when the hash function generates a key for a slot that is already in use. Therefore, if any value other than NULL is retrieved from the object ID field, then a collision has occurred.
- a collision has occurred, as there are cases where the object may have been previously hashed and stored in the hash table. If a collision has occurred, a new key should be generated by either rehashing the object ID or the object ID and pointer should be stored in a chained list or an overflow area as described above. Assuming the profiler's memory allocation for the hash table does not support either a chained list or an overflow area, a new integer key value is generated from the object ID using rehash function reH(k) (step 2410 ).
- a new hash table entry slot is found for the new key value (step 2404 ) and the value held in that slot's object field is retrieved (step 2406 ) and checked for collision with the object ID (step 2408 ). The process flows through steps 2404 - 2410 until a slot is located for the object ID.
- the process is then complete with respect to finding a slot in a hash table for an object ID. Once a key value is found with an open slot in the hash table, the key value is used as an index for the hash table slot (step 2412 ).
- FIG. 25 a flowchart depicting the process followed by the profiler for maintaining pointers to the node data area in accordance with a preferred embodiment of the present invention. This process is initiated by the object allocation code sending an event to the profiler, depicted as step 2304 shown in FIG. 23 .
- the process begins with the profiler receiving an event notifying it of the allocation of the object (step 2502 ).
- the profiler knows the identity of the currently executing thread that caused the allocation of the object, and the profiler also knows the identity of the current method executing within the current thread.
- the profiler maintains a call stack tree structure in real-time, so the profiler also has a pointer to the current node in the call stack tree structure in which the current node represents the currently executing method.
- the profiler receives an object allocation event. A determination is made as to whether the node associated with the object allocation event, i.e., the node (in the call stack tree representation) representing the method that caused the object allocation event, contains a node data area pointer (step 2504 ). If not, then a node data area is allocated and initialized (step 2506 ), and the pointer to the node data area is stored within the node (step 2508 ), after which processing continues. In either case, once the node has a pointer to a node data area, the profiler stores the pointer to the node data area in the hash table slot for the object being allocated (step 2510 , shown as step 2310 in FIG. 23) and the profiler can use this pointer to update information in the node data area during the profiling phase of a trace with memory leak detection support.
- the node associated with the object allocation event i.e., the node (in the call stack tree representation) representing the method that caused the object allocation event, contains a node
- the object deallocation code such as, a Garbage Collector, provides the corresponding memory deallocation tracking functionality.
- FIG. 26 a flowchart depicting the process followed by object deallocation code for deallocating an object with trace support in accordance with a preferred embodiment of the present invention.
- the process begins when the Object deallocation code/Garbage Collector has been called to reclaim space in the heap (step 2602 ).
- the object deallocation code/Garbage Collector may reclaim memory space in the heap using a variety of techniques, the present invention will be described using the mark and sweep garbage collection technique, however one of ordinary skill in the art would realize that other techniques could easily be employed.
- mark and sweep garbage collection each object has a bit reserved for marking which is clear initially. During garbage collection all ‘live’ or allocated objects which have a reference are traced from the root and marked. Then the heap is swept wherein all objects are examined and unmarked objects are reclaimed as free space for the heap.
- the mark and sweep process begins with each active object being marked as a live object in the heap (step 2604 ). After all live objects have been marked, the Garbage Collector sweeps the heap, one object allocation space at a time, checking each allocation space (step 2606 ).
- An object allocation space in the heap may consist of a live object (allocated), a dying object (deallocated) or may be free space. The allocation space is checked for a dying object (step 2608 ).
- the garbage collector/object deallocation code If the allocation space in the heap being checked contains a dying or deallocated object, the garbage collector/object deallocation code generates a deallocation event (step 2610 ).
- the profiler nulls the object ID and the pointer to the node data area (copy of DPTR) in the hash table, and decrements the live object and live bytes counters in the node data area (step 2612 ).
- the profiler may record additional information in the node data area, such as the classes of deallocated objects.
- the object deallocation code/Garbage Collector reclaims its space in the heap and hashes the object ID (step 2614 ).
- the mark and sweep process then continues by checking whether there is another object in the heap (step 2616 ). If so, the process returns to step 2608 to determine if the next object is dying.
- the object deallocation code/Garbage Collector takes no action.
- the mark and sweep process continues by checking whether there another object in the heap (step 2616 ). The process will continue through the heap until all object allocation spaces in the heap have been checked. Once all object allocation spaces have been checked the process ends.
- the node data areas contain accurate information about the live objects owned by each method at each point in the call stack tree, and reports such as those shown in FIGS. 34, 35 , 36 , and 37 , described below, may be generated. Live object and byte counts may be compared with those at previous garbage collection points to detect memory leaks.
- object deallocation events can be generated by the code that implements the FREE( ) call in C or C++, with the profiler handling the deallocation event exactly as described above.
- the information in the node data areas is accurate at all times, and reports may be generated and checks for memory leaks performed at any convenient time.
- FIG. 27 a flowchart depicting an alternate embodiment of the present invention that is specific to Java and other languages with implicit deallocation during garbage collection is depicted.
- the profiler in response to allocation events the profiler builds and uses a hash table as discussed above or shadow heap entries as will be discussed below, but does not increment the live counts in the node data area.
- the live counts in each node data area are zero.
- the garbage collector instead of generating events for each dying object, the garbage collector generates an event for each live object it encounters.
- the profiler increments the live object and live byte counts in the appropriate node data area. At the end of each garbage collection in which this is done, the live counts are accurate for each node in the call stack tree.
- the alternate embodiment depicted in FIG. 27 can only be implemented for language implementations that include explicit garbage collection. However, for these languages, it has two advantages over the implementation depicted in FIG. 26 . First, no work is done for objects that are allocated but that become dead before the next garbage collection, so memory leak detection is done with less total work. Second, an analyst may direct that some garbage collections be skipped, for example performing the process depicted in FIG. 27 only every tenth garbage collection; this might be appropriate for detecting slow leaks, and would further reduce the amount of processing needed to accomplish memory leak detection.
- the process begins when the Garbage Collector has been called to reclaim space in the heap (step 2702 ).
- the Garbage Collector zeros the total live count and bytes in the data area (step 2704 ). Similar to the mark and sweep process described in FIG. 26 above, the Garbage Collector first marks each active object in the heap as a live object (step 2706 ). After all live objects have been marked, the Garbage Collector sweeps the heap, one object allocation space at a time, checking each allocation space (step 2708 ).
- An object allocation space in the heap may consist of a live object (allocated), a dying object (deallocated) or may be free space. The allocation space is checked for a live object (step 2710 ).
- the Garbage Collector If the allocation space in the heap being checked contains a live (or allocated) object, the Garbage Collector generates an allocation event (step 2712 ).
- the profiler nulls object ID and the pointer to the node data area (copy of DPTR) in the hash table, and increments the live object and live bytes counters in the node data area (step 2714 ).
- the profiler may record additional information in the node data area such as the classes of the live objects. If, at step 2710 the Garbage Collector determines that the object is not live, then the Garbage Collector reclaims its space in the heap (step 2716 ).
- the mark and sweep process then continues by checking whether there is another object in the heap (step 2718 . If so, the process returns to step 2710 to determine if the next object is alive. The process will continue through the heap until all object allocation spaces in the heap have been checked. Once all object allocation spaces have been checked the process ends.
- the node data areas contain accurate information about the live objects owned by each method at each point in the call stack tree, and reports such as those shown in FIGS. 34, 35 , 36 , and 37 described below, may be generated. Live object and byte counts may be compared with those at previous garbage collection points to detect memory leaks.
- Jvm heap 2802 represents a typical heap for storing objects.
- Jvm heap 2802 is allocated between address hmin 2810 and hmax 2812 in memory.
- Jvm heap 2802 is subdivided into equal minimum object allocation spaces, for instance sixteen bytes each. Each minimum object allocation space may contain either a live object or a dying object, otherwise the minimum object allocation space is free.
- Jvm heap 2802 contains four objects, object A, object B, object C and object N. Objects A, B and N fit into one minimum object allocation space while object C utilizes three minimum object allocation spaces for storing the object.
- one problem associated with increasing an object's size for incorporating a data pointer is allocating additional space in the heap for the object. If the modified object fits into the minimum allocation space designated for an object then no further work is necessary by the object allocation code. However, if the modified object does not fit within the minimum allocation area designated for the object, then the object allocation code allocates an additional minimum allocation space for the object.
- DPARRAY 2804 is one-fourth the area of Jvm heap 2802 .
- DPARRAY 2804 is allocated between address Jmin 2820 and Jmax 2822 in memory which correlate to hmin 2810 and hmax 2812 .
- DPARRAY 2804 is also subdivided into equal spaces, however, in the case of the shadow heap the minimum allocation space contains only enough memory for a data pointer to a node data area.
- each data pointer in DPARRAY 2804 corresponds to the position of the object's handle in Jvm heap 2802 .
- object handle 2814 is positioned between hmin 2810 and hmax 2812 in Jvm heap 2802 .
- each minimum object space is sixteen bytes and that a data pointer in DPARRAY 2804 is one-fourth the size of a minimum object allocation space, or four bytes, the location of Jind 2824 within DPARRAY 2802 can be determined by:
- FIG. 28 depicts free minimum object spaces between each object in Jvm heap 2802 .
- the garbage collector will compact the objects within Jvm heap 2802 , thereby filling any free minimum object allocation spaces interspersed between the objects. It should be understood that because any data pointer for an object is located in DPARRAY 2804 using (handle ⁇ hmin)/16, that corresponding data pointer in DPARRAY 2804 is moved with the object handle.
- a data node area may contain a wide variety of data about the call stack and statistical information kept for the node.
- the information may directly relate to a particular object or may instead relate incrementally to objects used by the routine associated with a node.
- the process begins by accessing the object's handle in the heap (step 2902 ).
- a pointer to a node data area related to the object is stored in a shadow heap rather than in the object itself. Therefore, the position of the pointer to the node data area in the shadow heap can be calculated from the position of the object in the heap.
- the position of the data pointer in the shadow heap is determined by finding the position of the object's handle in the heap, relative to the first address of the heap (handle—hmin) and dividing that number by the minimum object space of sixteen (step 2904 ).
- a minimum object space contains sixteen bytes and the heap contains four times as much space as the shadow heap.
- the minimum size of the object could be arbitrarily set as could the sizes of both the heap and the shadow heap without departing of the scope of the present invention.
- node 3020 includes a data item related to non-temporal profile statistics, DPTR 3022 , which is a pointer to a node data area provided by the profiler.
- DPTR 3022 is a pointer to a node data area provided by the profiler.
- Node 3020 owns node data area 3030 and contains pointer DPTR 3022 that points to node data area 3030 .
- node data area 3030 holds memory usage information which tracks heap memory usage by node 3020 .
- Profiler 3040 allocates a node data area for a node, which represents a method that has had an object allocated.
- Node 3020 represents a routine that has had at least one object allocation, so node 3020 has DPTR 3022 that points to node data area 3030 , which may be one of several node data areas residing in a mini heap maintained by the profiler.
- Profiler 3040 may use a variety of data structures for maintaining the node data areas, such as, a linked list. As a node data area is needed for a node, a new element may be added to the linked list. Alternatively, the profiler has its own buffer area or “mini-heap” from which it may allocate space for each node data area.
- DPARRAY 3004 Until object allocation code 3042 allocates an object, DPARRAY 3004 remains empty.
- object allocation code 3042 allocates space in Jvm heap 3002 for the object, for instance, object A.
- Object allocation code 3042 sends an allocation event to profiler 3040 .
- Profiler 3040 owns the data structures necessary for tracking metrics associated with the routine, such as object allocation metrics. These data structures include a call stack tree which includes node 3020 , DPARRAY 3004 and node data area 3030 .
- Profiler 3040 stores a copy of a pointer to the node data area in DPARRAY 3004 .
- DPARRAY 3004 This is accomplished by constructing DPARRAY 3004 such that a data pointer slot exists in DPARRAY 3004 that corresponds to each minimum object allocation space in Jvm heap 3002 .
- DPARRAY 3004 contains a slot for each minimum object allocation space in Jvm heap 3002 .
- Each data pointer is stored in the same relative position within DPARRAY 3004 as the position of the data pointer's corresponding object in Jvm heap 3002 .
- object allocation code 3042 allocates the object and sends an object allocation event to profiler 3040 .
- Profiler 3040 determines if the routine's node has been allocated a node data area. If not profiler 3040 allocates node data area 3030 and stores a pointer to the node data area in node 3020 . Whether or not profiler 3040 allocates a node data area for the current node, node 3020 , profiler 3040 stores a copy of pointer 3022 in DPARRAY 3004 , in addition to storing a copy of DPTR 3022 if one has not been previously stored in node 3020 . Profiler 3040 stores a copy of DPTR 3022 in the identical relative position in DPARRAY 3004 as object allocation code 3042 stores the allocated object in Jvm heap 3002 .
- a data pointer associated with an object need not be nulled, as described in preferred embodiments directed at using a hash tables, because once the space for the object is reclaimed, the pointer is shadowing free space in the heap. Once that space is occupied by another object, the previous pointer is overwritten by a pointer related the new object. This is true whether the space is occupied by a new allocated object or by an object repositioned in the heap by compaction via the Garbage Collector.
- node data area 3030 tracks memory usage by total allocation and total live allocation.
- the total allocation is measured by total allocated count 3031 and total allocated bytes 3032 .
- the total live allocation is measured by total live count 3033 and total live bytes 3034 .
- Total allocation refers to the quantity of objects allocated and space allocated for the object(s) for the routine. Total allocation does not infer that the object is currently active. Live allocations, on the other hand, refer to the active object count and space allocations.
- Node 3020 will contain pointer DPTR 3022 after one object has been allocated for the method.
- Each time an object is allocated profiler 3040 stores a copy of the pointer in a slot in DPARRAY 3004 that is relative to the object's position in Jvm heap 3002 and increments the total allocation count 3031 and the total allocation bytes 3032 contained in node data area 3030 .
- total allocation count 3031 and total allocation bytes 3032 stored in node data area 3030 were each incremented as each of object A 3062 , object B 3064 , object C 3066 , and object N 3068 were allocated.
- DPARRAY 3004 merely lists pointers from objects that were alive at some point since the last garbage collection. Fn Therefore, the only accurate live object count can be acquired at garbage collection time.
- FIG. 31 a flowchart depicting the process followed by the object allocation code for allocating an object with trace support, which utilizes a shadow heap in accordance with a preferred embodiment of the present invention.
- the process begins when the object allocation code allocates memory for an object for the current method (step 3102 ).
- the object allocation code then sends an object allocation event to the profiler (step 3104 ).
- the profiler increments the total allocation and bytes and the live allocation and bytes in the node data area for the method (step 3112 ).
- the profiler may record additional information in the node data area such as the classes of the live objects.
- the profiler finds the proper slot for the pointer to the node data area in the shadow heap.
- the profiler identifies the correct slot for the pointer by finding the slot within the shadow heap having the same relative position within the shadow heap as the position of its corresponding object within the heap (step 3114 ). Determining the proper slot, or position of the pointer in the shadow memory was described above with respect to FIG. 29 .
- the position of the pointer to the node data area in the shadow heap can be calculated from the position of the object in the heap.
- the position of the data pointer in the shadow heap is determined by finding the position of the object's handle in the heap, relative to the first address of the heap (handle—hmin) and dividing that number by sixteen.
- the profiler places the pointer to node data area in the;proper slot in the shadow memory (step 3116 ), and the process is complete with respect to the allocation of an object “owned” by a method.
- FIGS. 32 and 33 depict processes that are similar to the processes described above with respect to FIGS. 26 and 27, respectively and therefore will not be discussed in detail.
- FIG. 32 a flowchart depicting the process followed by object deallocation code for deallocating an object with trace support in accordance with a preferred embodiment of the present invention.
- the process begins by calling the object deallocation code/Garbage Collector to reclaim space in the heap (step 3202 ). Using the mark and sweep garbage collection method, the process begins by marking each active object in the heap as a live object (step 3204 ) and then the Garbage Collector sweeps the heap for live objects, checking each minimum allocation space, one object allocation space at a time (step 3206 ). The process checks a minimum allocation space for a dying object (step 3208 ).
- the object deallocation code/Garbage Collector If the minimum allocation space contains a dying object (deallocated object), the object deallocation code/Garbage Collector generates a deallocation event (step 3210 ).
- the profiler uses the pointer to the data node area stored in the shadow heap to decrement the live object and live bytes counters in the node data area (step 3212 ).
- the profiler may record additional information in the node data area such as the classes of deallocated objects.
- the object deallocation code/Garbage Collector reclaims its space in the heap (step 3214 ).
- step 3216 The process continues by checking for another minimum allocation space in the heap (step 3216 ). If another space exists, the process returns to step 3208 to determine if an object in the space is dying. The process iterates from step 3208 to step 3216 until no other objects are present in the heap.
- the object deallocation code/Garbage Collector takes no action. However, the mark and sweep process continues by checking whether another object is present in the heap (step 3216 ). The process will continue through the heap until all object allocation spaces in the heap have been checked. Once all object allocation spaces have been checked the process ends. At the end of the process, the node data areas contain accurate metric values concerning the live objects owned by each method at each point in the call stack tree. Reports can then be generated such as those shown in FIGS. 34, 35 , 36 , and 37 . Live object and byte counts may be compared with those at previous garbage collection points to detect memory leaks.
- FIG. 33 an alternate embodiment of the present invention that is specific to Java and other languages with implicit deallocation during garbage collection is depicted.
- the profiler builds a shadow heap in response to allocation events, but does not increment the live counts in the node data area.
- the live counts in each node data area are zero.
- the garbage collector instead of generating events for each dying object, the garbage collector generates an event for each live object it encounters. In response to these events, the profiler increments the live object and live byte counts in the appropriate node data area. At the end of each garbage collection in which this is done, the live counts are accurate for each node in the call stack tree.
- FIG. 33 describes an alternate embodiment which can only be implemented for language implementations that include explicit garbage collection.
- this embodiment has the advantage over the preferred embodiment depicted in FIG. 32 in that no work is done for objects that are allocated but that become dead before the next garbage collection. Thus, memory leak detection is done with less total work.
- Another advantage is that an analyst may direct that some garbage collections be skipped, for example performing the process depicted in FIG. 33 only every tenth garbage collection; this might be appropriate for detecting slow leaks, and would further reduce the amount of processing needed to accomplish memory leak detection.
- the process begins when the Garbage Collector has been called to reclaim space in the heap (step 3302 ).
- the Garbage Collector zeros the total live count and bytes in the data area (step 3304 ).
- Object space reclamation is performed by first marking each active object in the heap as a live object (step 3306 ) and then examining each object allocation space in the heap, one object allocation space at a time (step 3308 ).
- the allocation space is checked for a live object (step 3310 ). If the allocation space being checked contains a live (allocated object), the Garbage Collector generates an allocation event (step 3312 ).
- the profiler increments the live object and live bytes counters in the node data area using the pointer to the node data area stored in the shadow heap in the same relative position as the object's position in the heap (step 3314 ).
- the profiler may record additional information such as the classes of live objects.
- the Garbage Collector determines that the object is not live, then the object allocation code/Garbage Collector reclaims its space in the heap (step 3316 ). The process continues by checking whether there another object in the heap (step 3318 ). If so, the process returns to step 3310 to determine if the next object is alive. The process will continue through the heap until all object allocation spaces in the heap have been checked. Once all object allocation spaces have been checked the process ends.
- the object allocation code, the object deallocation code, and the profiler are coordinated such that the object allocations and object deallocations are tracked through the profiler.
- Memory allocations and deallocations are not only tracked but also attributed to the methods that cause the memory transactions and the execution context (call stack) in which the methods performed the memory transactions.
- the number of allocations, deallocations, the number of bytes allocated, and the number of bytes deallocated for each method and/or thread can be traced, and the trace information can be post-processed and presented as useful information to a software developer or analyst. Examples of such information include, but are not limited to, FIGS. 34, 35 , 36 , and 37 presented below.
- FIG. 34 is an example of such a live object report.
- table 3400 live objects and object bytes are listed per class for a single garbage collection. For each garbage collection time the linked list of classes is zeroed and rebuilt. From such a report an analyst may notice an unexpected number of live objects of a particular class, but this report gives the analyst no clue as to which method has created them.
- FIG. 35 shows a small extract of a report attributing live objects to specific call stack configurations, showing memory allocation information for one particular call stack.
- table 3500 total allocated objects, total allocated bytes, live objects, object bytes, and data pointer information are listed for each method in the call stack.
- the first column in table 3500 shows the level of each method on the stack, with level 0 identifying the method that was invoked first, level 1 a method it called, and so forth.
- method main called method screenSet_up which in turn called method parseCommandLine which in turn called method getToken.
- the next four columns show the total objects and bytes allocated over the life of the program, and the live objects and bytes at this particular garbage collection, respectively.
- the last two columns show the pointer to the node data area for this method on this call stack, and the method name, respectively.
- Reports such as the one illustrated in FIG. 35 are usually sufficient to identify memory leaks in object oriented programs.
- the number of live objects for each method at successive garbage collection points can be compared, and methods whose live memory continues to grow are easily identified.
- the identity of the guilty method and its location in the call stack tree are sufficient because the software developer or analyst can detect the leak by inspection of the source code of the method once he knows which method to examine.
- the method in question allocates many different classes of objects at many different locations in its code, additional information may be helpful.
- FIG. 36 illustrates one example of additional information that can be reported if the profiler has collected the classes of live and dying objects in addition to the counts.
- Table 3600 gives the classes of all objects allocated by method parseCommandLine from table 3500 since the last garbage collection, and for each object, whether it is still alive or not. In this example, the method allocated three strings, which are no longer referenced, and an object of the Token class and a character array which are both still alive.
- table 3500 and table 3600 can be merged to produce a report identifying all allocated objects that are still alive, their class, and which method at which point in the call stack tree allocated them.
- FIG. 37 shows a small extract of such a report; table 3700 shows memory allocation information for one particular call stack.
- Four key metrics are reported for each method: “calls,” “base,” “cum” (short for cumulative), and the classes of all live objects. Calls indicates the number of times the method has been called since the program began execution. Base and cum both pertain to the amount of live memory. Base indicates the amount of live memory allocated directly by this method in the context defined by its set of parents. Cum indicates the amount allocated both by the method directly and by all of its children. Similarly, %Base is the percentage of all live memory allocated directly by this method, and %Cum indicates the percentage of all live memory allocated by the method and all of its children.
- method getToken has allocated 55770 StringBuffer objects, each of size 640 bytes, one StringBuffer object for each time getToken has been called, and none of these objects has been freed. These objects account for over 75% of all live bytes, and may be the source of a memory leak. Verification of the leak is made by comparing live objects over subsequent object deallocations or Garbage collections.
- Call stack data for the heap leak detection may come from a variety of sources other than the Jvm heap.
- call stack data may be obtained from a C heap memory allocation instrumentation.
- the call stack can provide insight into which parts of the environment made the calls to MALLOC( ) and FREE( ).
- MALLOC( ) is a C standard library routine for memory allocation.
- MALLOC( ) takes the number of bytes required for a routine and returns a pointer to a block of that size rather than allocating minimum object allocation space(s) for an object as described above.
- Memory allocated with MALLOC must be reclaimed explicitly using the FREE( ) memory deallocation routine before the memory can be reused rather than by the Garbage Collector described in the preceding descriptions.
- the manner in which the allocation/deallocation code functions does not affect its applicability to the present invention.
- the advantages of the present invention are realized whether heap space is allocated for routines as contiguous predefined areas in the heap (such as minimum object allocation spaces) or a block of available memory.
- the present invention functions equally well whether a ‘live’ object count is derived from implicit object deallocation code that reclaims heap memory as minimum object allocation spaces (such as a Garbage Collector), or from explicit deallocation code that reclaims heap memory as random sized blocks (such as FREE( )).
- implicit object deallocation code that reclaims heap memory as minimum object allocation spaces
- explicit deallocation code that reclaims heap memory as random sized blocks
Abstract
Description
Claims (48)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/589,798 US6658652B1 (en) | 2000-06-08 | 2000-06-08 | Method and system for shadow heap memory leak detection and other heap analysis in an object-oriented environment during real-time trace processing |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/589,798 US6658652B1 (en) | 2000-06-08 | 2000-06-08 | Method and system for shadow heap memory leak detection and other heap analysis in an object-oriented environment during real-time trace processing |
Publications (1)
Publication Number | Publication Date |
---|---|
US6658652B1 true US6658652B1 (en) | 2003-12-02 |
Family
ID=29550354
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/589,798 Expired - Lifetime US6658652B1 (en) | 2000-06-08 | 2000-06-08 | Method and system for shadow heap memory leak detection and other heap analysis in an object-oriented environment during real-time trace processing |
Country Status (1)
Country | Link |
---|---|
US (1) | US6658652B1 (en) |
Cited By (228)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20020010809A1 (en) * | 2000-07-20 | 2002-01-24 | Ralph Lipe | Method and apparatus for identifying programming object attributes |
US20020144185A1 (en) * | 2001-03-29 | 2002-10-03 | International Business Machines Corporation | Verification of global coherence in a multi-node NUMA system |
US20030028859A1 (en) * | 2001-07-31 | 2003-02-06 | Nigel Street | Method of collecting, visualizing and analyzing object interaction |
US20030069905A1 (en) * | 2000-07-31 | 2003-04-10 | Microsoft Corporation | Method and system for concurrent garbage collection |
US20030131012A1 (en) * | 2000-10-27 | 2003-07-10 | Joakim Dahlstedt | System and method for regeneration of methods and garbage collection of unused methods |
US20030191864A1 (en) * | 2002-04-01 | 2003-10-09 | Sun Microsystems, Inc. | Method and system for detecting deprecated elements during runtime |
US20030196061A1 (en) * | 2002-04-16 | 2003-10-16 | Hideya Kawahara | System and method for secure execution of multiple applications using a single GC heap |
US20030195943A1 (en) * | 2002-04-16 | 2003-10-16 | Elliott Bradshaw | System and method for managing memory |
US20030229766A1 (en) * | 2002-06-06 | 2003-12-11 | David Dice | Methods and apparatus for performing a memory management technique |
WO2004002044A2 (en) * | 2002-02-01 | 2003-12-31 | John Fairweather | A system for exchanging binary data |
US20040001010A1 (en) * | 2002-06-26 | 2004-01-01 | Nicholas Shaylor | Method and apparatus for creating string objects in a programming language |
US20040034742A1 (en) * | 2002-06-24 | 2004-02-19 | Field Scott A. | Stack allocation system and method |
US20040039746A1 (en) * | 2002-06-14 | 2004-02-26 | Sun Microsystems, Inc. | Protecting object identity in a language with built-in synchronization objects |
US20040111718A1 (en) * | 2002-12-04 | 2004-06-10 | Detlefs David L. | Block-offset table employing gaps in value set |
US20040133895A1 (en) * | 2002-12-20 | 2004-07-08 | Bea Systems, Inc. | System and method for memory leak detection in a virtual machine environment |
US20040154016A1 (en) * | 2003-01-31 | 2004-08-05 | Randall Keith H. | System and method of measuring application resource usage |
US20040162861A1 (en) * | 2003-02-19 | 2004-08-19 | Detlefs David L. | Parallel non-contiguous allocation and card parsing |
US20040162860A1 (en) * | 2003-02-14 | 2004-08-19 | Detlefs David L. | Parallel card table scanning and updating |
US20040215880A1 (en) * | 2003-04-25 | 2004-10-28 | Microsoft Corporation | Cache-conscious coallocation of hot data streams |
US6832302B1 (en) * | 2001-10-24 | 2004-12-14 | At&T Corp. | Methods and apparatus for detecting heap smashing |
US20050050059A1 (en) * | 2003-08-25 | 2005-03-03 | Van Der Linden Robbert C. | Method and system for storing structured documents in their native format in a database |
US20050050467A1 (en) * | 2003-08-28 | 2005-03-03 | Henrik Loeser | Method and system for processing structured documents in a native database |
US20050050011A1 (en) * | 2003-08-25 | 2005-03-03 | Van Der Linden Robbert C. | Method and system for querying structured documents stored in their native format in a database |
US20050076184A1 (en) * | 2003-10-01 | 2005-04-07 | Schumacher Michael K. | Apparatus and method for detecting memory leaks |
US20050076030A1 (en) * | 2003-08-29 | 2005-04-07 | International Business Machines Corporation | Method and system for providing path-level access control for structured documents stored in a database |
US20050091646A1 (en) * | 2003-10-24 | 2005-04-28 | Microsoft Corporation | Statistical memory leak detection |
US20050091645A1 (en) * | 2003-10-24 | 2005-04-28 | Microsoft Corporation | Adaptive instrumentation runtime monitoring and analysis |
US20050144410A1 (en) * | 2003-12-31 | 2005-06-30 | Microsoft Corporation | Dynamic memory heap tagging |
US20050160431A1 (en) * | 2002-07-29 | 2005-07-21 | Oracle Corporation | Method and mechanism for debugging a series of related events within a computer system |
US20050204342A1 (en) * | 2004-03-11 | 2005-09-15 | International Business Machines Corp. | Method, system and article for detecting memory leaks in Java software |
US20050216894A1 (en) * | 2004-03-25 | 2005-09-29 | Masato Igarashi | Design evaluation system and design evaluation method |
US20050235127A1 (en) * | 2004-04-19 | 2005-10-20 | Cisco Technology, Inc. | Method and system for memory leak detection |
US20050240747A1 (en) * | 2004-04-23 | 2005-10-27 | Alcatel Ip Networks, Inc. | Memory leak detection |
US20050246511A1 (en) * | 2004-04-30 | 2005-11-03 | Microsoft Corporation | Special-use heaps |
US20050289307A1 (en) * | 2004-06-24 | 2005-12-29 | International Business Machines Corporation | Method and system for determining memory usage of a heap |
US6985976B1 (en) * | 2002-02-22 | 2006-01-10 | Teja Technologies, Inc. | System, method, and computer program product for memory management for defining class lists and node lists for allocation and deallocation of memory blocks |
US20060026379A1 (en) * | 2004-07-27 | 2006-02-02 | Samsung Electronics Co., Ltd. | Effective memory management method and device in object-oriented application |
US20060031282A1 (en) * | 2000-12-18 | 2006-02-09 | Timothy Tuttle | Techniques for updating live objects at clients using a dynamic routing network |
US20060031283A1 (en) * | 2000-12-18 | 2006-02-09 | Timothy Tuttle | Asynchronous messaging using a node specialization architecture in the dynamic routing network |
US20060031844A1 (en) * | 2004-06-04 | 2006-02-09 | David Dice | Techniques for accessing a shared resource using an improved synchronization mechanism |
US20060041866A1 (en) * | 2004-08-17 | 2006-02-23 | Rajini Sivaram | Debugging an application process at runtime |
US20060070040A1 (en) * | 2002-11-25 | 2006-03-30 | Microsoft Corporation | Dynamic prefetching of hot data streams |
US20060085156A1 (en) * | 2004-10-18 | 2006-04-20 | Kolawa Adam K | Method and system for predicting memory leaks from unit testing |
US20060095427A1 (en) * | 2004-10-28 | 2006-05-04 | International Business Machines Corporation | Memory leakage management |
US20060101416A1 (en) * | 1998-12-23 | 2006-05-11 | Callahan Charles D Ii | Parallelism performance analysis based on execution trace information |
US20060117318A1 (en) * | 2004-08-17 | 2006-06-01 | Shaw Parsing, Llc | Modular event-driven processing |
US20060130001A1 (en) * | 2004-11-30 | 2006-06-15 | International Business Machines Corporation | Apparatus and method for call stack profiling for a software application |
US20060200808A1 (en) * | 2005-03-02 | 2006-09-07 | Cisco Technology, Inc. | System and method providing for interaction between programming languages |
US20060206885A1 (en) * | 2005-03-10 | 2006-09-14 | Seidman David I | Identifying memory leaks in computer systems |
US7127720B2 (en) | 2000-12-18 | 2006-10-24 | Charles E Cano | Storing state in a dynamic content routing network |
US20060242636A1 (en) * | 2005-04-26 | 2006-10-26 | Microsoft Corporation | Variational path profiling |
US20060248103A1 (en) * | 2005-04-29 | 2006-11-02 | Cisco Technology, Inc. | Method of detecting memory leaks in software applications |
US7133993B1 (en) * | 2004-01-06 | 2006-11-07 | Altera Corporation | Inferring size of a processor memory address based on pointer usage |
US20060253845A1 (en) * | 2005-05-03 | 2006-11-09 | International Business Machines Corporation | Method and apparatus for determining leaks in a Java heap |
US20060253507A1 (en) * | 2005-05-04 | 2006-11-09 | Tonic Solutions, Inc. | System and method for monitoring memory usage |
US20060265694A1 (en) * | 2005-05-20 | 2006-11-23 | Microsoft Corporation | Heap-based bug identification using anomaly detection |
US20060265438A1 (en) * | 2005-05-20 | 2006-11-23 | Microsoft Corporation | Leveraging garbage collection to dynamically infer heap invariants |
US20060277440A1 (en) * | 2005-06-02 | 2006-12-07 | International Business Machines Corporation | Method, system, and computer program product for light weight memory leak detection |
US7165190B1 (en) | 2002-07-29 | 2007-01-16 | Oracle International Corporation | Method and mechanism for managing traces within a computer system |
US20070027942A1 (en) * | 2005-07-27 | 2007-02-01 | Trotter Martin J | Memory leak detection |
US20070050519A1 (en) * | 2000-12-18 | 2007-03-01 | Cano Charles E | Storing state in a dynamic content routing network |
US20070067758A1 (en) * | 2005-09-21 | 2007-03-22 | Piotr Findeisen | Identifying sources of memory retention |
US7200588B1 (en) | 2002-07-29 | 2007-04-03 | Oracle International Corporation | Method and mechanism for analyzing trace data using a database management system |
US20070083856A1 (en) * | 2002-11-25 | 2007-04-12 | Microsoft Corporation | Dynamic temporal optimization framework |
US20070130238A1 (en) * | 2005-12-07 | 2007-06-07 | Microsoft Corporation | Garbage collector support for transactional memory |
US20070136547A1 (en) * | 2005-12-13 | 2007-06-14 | Microsoft Corporation | Runtime detection for invalid use of zero-length memory allocations |
US20070136546A1 (en) * | 2005-12-09 | 2007-06-14 | International Business Machines Corporation | Use of Region-Oriented Memory Profiling to Detect Heap Fragmentation and Sparse Memory Utilization |
US20070169030A1 (en) * | 2005-12-07 | 2007-07-19 | Microsoft Corporation | Compiler support for optimizing decomposed software transactional memory operations |
US20070220492A1 (en) * | 2006-03-16 | 2007-09-20 | Microsoft Corporation | Application verifier infrastructure and checks |
US20070250820A1 (en) * | 2006-04-20 | 2007-10-25 | Microsoft Corporation | Instruction level execution analysis for debugging software |
US20070255773A1 (en) * | 2006-04-28 | 2007-11-01 | Sap Ag | Method and system for inspecting memory leaks and analyzing contents of garbage collection files |
US20070255775A1 (en) * | 2006-04-28 | 2007-11-01 | Sap Ag | Method and system for inspecting memory leaks |
US7293142B1 (en) | 2004-04-19 | 2007-11-06 | Cisco Technology, Inc. | Memory leak detection system and method using contingency analysis |
US20070266381A1 (en) * | 2006-05-11 | 2007-11-15 | Square D Company | Loading a chain of processors from an XML file |
US20070288908A1 (en) * | 2006-06-09 | 2007-12-13 | International Business Machines Corporation | Computer implemented method and system for accurate, efficient and adaptive calling context profiling |
US7313661B1 (en) * | 2005-03-18 | 2007-12-25 | Sun Microsystems, Inc. | Tool for identifying causes of memory leaks |
US20080005208A1 (en) * | 2006-06-20 | 2008-01-03 | Microsoft Corporation | Data structure path profiling |
US7325106B1 (en) * | 2004-07-16 | 2008-01-29 | Sun Microsystems, Inc. | Method for monitoring heap for memory leaks |
US20080028178A1 (en) * | 2006-07-31 | 2008-01-31 | Microsoft Corporation | Detection of memory leaks |
US20080046889A1 (en) * | 2003-03-27 | 2008-02-21 | International Business Machines Corporation | Deallocation of computer data in a multithreaded computer |
US20080046785A1 (en) * | 2006-08-18 | 2008-02-21 | International Business Machines Corporation | Timeout request scheduling using grouping and nonsynchronized processing to enhance performance |
US20080046673A1 (en) * | 2006-08-16 | 2008-02-21 | International Business Machines Corporation | Method and system to optimize java virtual machine performance |
US7376937B1 (en) * | 2001-05-31 | 2008-05-20 | Oracle International Corporation | Method and mechanism for using a meta-language to define and analyze traces |
US7380239B1 (en) | 2001-05-31 | 2008-05-27 | Oracle International Corporation | Method and mechanism for diagnosing computer applications using traces |
US20080126625A1 (en) * | 2006-07-17 | 2008-05-29 | International Business Machines Corporation | Just-in-time buffer allocation for use in event completion style input/output models |
US20080148102A1 (en) * | 2006-12-15 | 2008-06-19 | International Business Machines Corporation | Method for enhancing debugging of runtime memory access errors by using an integrated visualization tool and a runtime memory error detection tool |
US20080163178A1 (en) * | 2006-12-29 | 2008-07-03 | Ivanova Gorka J | System and method for displaying component information of a trace |
US20080163177A1 (en) * | 2006-12-29 | 2008-07-03 | Sap Ag | System and method for displaying trace information |
US20080178189A1 (en) * | 2007-01-23 | 2008-07-24 | Piotr Findeisen | Efficient detection of sources of increasing memory consumption |
US20080222450A1 (en) * | 2007-03-07 | 2008-09-11 | Jinchao Yang | Zero-penalty RAID controller memory leak detection and isolation method and system utilizing sequence numbers |
US20080222637A1 (en) * | 2004-09-09 | 2008-09-11 | Marc Alan Dickenson | Self-Optimizable Code |
US20080243968A1 (en) * | 2007-03-30 | 2008-10-02 | Sap Ag | Method and system for object age detection in garbage collection heaps |
US20080244531A1 (en) * | 2007-03-30 | 2008-10-02 | Sap Ag | Method and system for generating a hierarchical tree representing stack traces |
US20080244546A1 (en) * | 2007-03-30 | 2008-10-02 | Sap Ag | Method and system for providing on-demand profiling infrastructure for profiling at virtual machines |
US20080263522A1 (en) * | 2005-09-09 | 2008-10-23 | International Business Machines Corporation | Common Debug Adaptor |
US20080294936A1 (en) * | 2007-05-25 | 2008-11-27 | International Business Machines Corporation | Software memory leak analysis using memory isolation |
US20080301646A1 (en) * | 2007-05-29 | 2008-12-04 | Satish Chandra Gupta | Detecting Dangling Pointers and Memory Leaks Within Software |
US20080313406A1 (en) * | 2007-06-14 | 2008-12-18 | Kristian Hoegsberg Kristensen | Methods and systems for porting sysprof |
US7475397B1 (en) | 2004-07-28 | 2009-01-06 | Sun Microsystems, Inc. | Methods and apparatus for providing a remote serialization guarantee |
US7480856B2 (en) * | 2002-05-02 | 2009-01-20 | Intel Corporation | System and method for transformation of XML documents using stylesheets |
US20090077625A1 (en) * | 2003-08-25 | 2009-03-19 | International Business Machines Corporation | Associating information related to components in structured documents stored in their native format in a database |
US20090210750A1 (en) * | 2008-02-19 | 2009-08-20 | Sas Institute Inc. | Systems And Methods For Identifying Memory Leaks In A Computer System |
US20090228870A1 (en) * | 2008-03-06 | 2009-09-10 | International Business Machines Corporation | On-demand monitoring of memory usage |
US7594234B1 (en) | 2004-06-04 | 2009-09-22 | Sun Microsystems, Inc. | Adaptive spin-then-block mutual exclusion in multi-threaded processing |
US7636745B1 (en) * | 2004-03-12 | 2009-12-22 | Sun Microsystems, Inc. | Concurrent-marking-initiation heuristic |
US20090313743A1 (en) * | 2008-06-20 | 2009-12-24 | Craig Jason Hofmeyer | Pants with saggy pants control system |
US20090327373A1 (en) * | 2008-06-30 | 2009-12-31 | International Business Machines Corporation | Method for performing memory leak analysis inside a virtual machine |
US20100017789A1 (en) * | 2008-07-15 | 2010-01-21 | International Business Machines Corporation | Selectively Obtaining Call Stack Information Based on Criteria |
US20100017583A1 (en) * | 2008-07-15 | 2010-01-21 | International Business Machines Corporation | Call Stack Sampling for a Multi-Processor System |
US7685580B1 (en) * | 2005-08-30 | 2010-03-23 | Sun Microsystems, Inc. | Method and apparatus for selectively eliminating write barriers in snapshot-at-the beginning concurrent-marking garbage collectors |
US20100095280A1 (en) * | 2007-03-30 | 2010-04-15 | Ralf Schmelter | Method and system for providing loitering trace in virtual machines |
US20100114915A1 (en) * | 2008-11-03 | 2010-05-06 | Gorton Jr Richard C | Bounded hash table sorting in a dynamic program profiling system |
US7814225B2 (en) | 2000-12-18 | 2010-10-12 | Rumelhart Karl E | Techniques for delivering personalized content with a real-time routing network |
US20100287352A1 (en) * | 2009-05-05 | 2010-11-11 | International Business Machines Corporation | Virtual machine tool interface for tracking objects |
US20110029822A1 (en) * | 2009-08-03 | 2011-02-03 | Sap Ag | Tracking of java objects during request processing |
US20110035554A1 (en) * | 2007-01-07 | 2011-02-10 | Matt Watson | Memory Management Methods and Systems |
US7908591B1 (en) * | 2006-07-17 | 2011-03-15 | The Mathworks, Inc. | Memory profiling |
US7925621B2 (en) | 2003-03-24 | 2011-04-12 | Microsoft Corporation | Installing a solution |
US7930491B1 (en) | 2004-04-19 | 2011-04-19 | Cisco Technology, Inc. | Memory corruption detection system and method using contingency analysis regulation |
US7937651B2 (en) | 2005-01-14 | 2011-05-03 | Microsoft Corporation | Structural editing operations for network forms |
US20110107297A1 (en) * | 2009-11-03 | 2011-05-05 | International Business Machines Corporation | Systems and methods for resource leak detection |
US7950003B1 (en) * | 2006-12-07 | 2011-05-24 | Sony Computer Entertainment Inc. | Heads-up-display software development tool for analyzing and optimizing computer software |
US7962901B2 (en) | 2006-04-17 | 2011-06-14 | Microsoft Corporation | Using dynamic analysis to improve model checking |
US7971139B2 (en) | 2003-08-06 | 2011-06-28 | Microsoft Corporation | Correlation, association, or correspondence of electronic forms |
US7979856B2 (en) | 2000-06-21 | 2011-07-12 | Microsoft Corporation | Network-based software extensions |
US8001459B2 (en) | 2005-12-05 | 2011-08-16 | Microsoft Corporation | Enabling electronic documents for limited-capability computing devices |
US8010515B2 (en) | 2005-04-15 | 2011-08-30 | Microsoft Corporation | Query to an electronic form |
US20110264712A1 (en) * | 2010-04-23 | 2011-10-27 | Tatu Ylonen Oy Ltd | Copy planning in a concurrent garbage collector |
US8060869B1 (en) * | 2007-06-08 | 2011-11-15 | Oracle America, Inc. | Method and system for detecting memory problems in user programs |
US20110283080A1 (en) * | 2010-05-14 | 2011-11-17 | Lim Geun-Sik | Apparatus and method for managing memory |
US8074217B2 (en) | 2000-06-21 | 2011-12-06 | Microsoft Corporation | Methods and systems for delivering software |
US20110302183A1 (en) * | 2010-06-02 | 2011-12-08 | Oracle International Corporation | Tracking object fields using relocatable object watchpoints |
US20110307828A1 (en) * | 2010-06-11 | 2011-12-15 | Microsoft Corporation | Memory allocation visualization for unmanaged languages |
US8117552B2 (en) | 2003-03-24 | 2012-02-14 | Microsoft Corporation | Incrementally designing electronic forms and hierarchical schemas |
US8131785B1 (en) * | 2009-05-22 | 2012-03-06 | Adobe Systems Incorporated | Free space management for hierarchical data document |
US20120078972A1 (en) * | 2010-09-29 | 2012-03-29 | Siemens Aktiengesellschaft | Method, Computer Readable Medium And System For Allocation And Management Of Memory In Runtime Environments |
US8200975B2 (en) | 2005-06-29 | 2012-06-12 | Microsoft Corporation | Digital signatures for network forms |
US20120159455A1 (en) * | 2010-12-16 | 2012-06-21 | Ralf Schmelter | Rating interestingness of profiling data subsets |
US8250093B2 (en) | 2003-08-25 | 2012-08-21 | International Business Machines Corporation | Method and system for utilizing a cache for path-level access control to structured documents stored in a database |
CN102662825A (en) * | 2012-02-22 | 2012-09-12 | 中国人民解放军国防科学技术大学 | Method for detecting memory leakage of heap operational program |
US20120324173A1 (en) * | 2011-06-17 | 2012-12-20 | International Business Machines Corporation | Efficient discard scans |
CN102968593A (en) * | 2011-08-31 | 2013-03-13 | 国际商业机器公司 | Method and system for positioning isolating point of application program under multi-tenant environment |
US20130086132A1 (en) * | 2011-10-03 | 2013-04-04 | Oracle International Corporation | Time-based object aging for generational garbage collectors |
US20130111481A1 (en) * | 2011-11-02 | 2013-05-02 | International Business Machines Corporation | Programmatic identification of root method |
WO2013074201A1 (en) * | 2011-11-18 | 2013-05-23 | Apple Inc. | Method for tracking memory usages of a data processing system |
US8499106B2 (en) * | 2010-06-24 | 2013-07-30 | Arm Limited | Buffering of a data stream |
US8522209B2 (en) | 2007-03-30 | 2013-08-27 | Sap Ag | Method and system for integrating profiling and debugging |
US20130311521A1 (en) * | 2008-10-24 | 2013-11-21 | Microsoft Corporation | Blob manipulation in an integrated structured storage system |
US8601469B2 (en) | 2007-03-30 | 2013-12-03 | Sap Ag | Method and system for customizing allocation statistics |
US8640116B2 (en) * | 2004-02-26 | 2014-01-28 | Broadcom Corporation | Loader module, and method for loading program code into a memory |
US8667471B2 (en) | 2007-03-30 | 2014-03-04 | Sap Ag | Method and system for customizing profiling sessions |
WO2014036540A2 (en) * | 2012-08-31 | 2014-03-06 | Yume, Inc. | Network service system and method with off-heap caching |
US20140068610A1 (en) * | 2012-09-06 | 2014-03-06 | Marek Baluch | Method and system for adjusting the operating memory used by a java virtual machine during runtime |
US8738877B2 (en) | 2011-12-14 | 2014-05-27 | Advance Micro Devices, Inc. | Processor with garbage-collection based classification of memory |
US8793289B2 (en) | 2006-04-28 | 2014-07-29 | Sap Ag | Method and system for detecting memory leaks and copying garbage collection files |
US8799904B2 (en) | 2011-01-21 | 2014-08-05 | International Business Machines Corporation | Scalable system call stack sampling |
US8799872B2 (en) | 2010-06-27 | 2014-08-05 | International Business Machines Corporation | Sampling with sample pacing |
US20140280364A1 (en) * | 2013-03-12 | 2014-09-18 | Oracle International Corporation | Disposal of rarely used member variables via shadow structures |
US8843912B2 (en) * | 2012-02-20 | 2014-09-23 | International Business Machines Corporation | Optimization of an application to reduce local memory usage |
US8843684B2 (en) | 2010-06-11 | 2014-09-23 | International Business Machines Corporation | Performing call stack sampling by setting affinity of target thread to a current process to prevent target thread migration |
US8892993B2 (en) | 2003-08-01 | 2014-11-18 | Microsoft Corporation | Translation file |
US8918729B2 (en) | 2003-03-24 | 2014-12-23 | Microsoft Corporation | Designing electronic forms |
US8918616B2 (en) | 2011-08-24 | 2014-12-23 | Microsoft Corporation | Memory allocation analysis |
US8938533B1 (en) * | 2009-09-10 | 2015-01-20 | AppDynamics Inc. | Automatic capture of diagnostic data based on transaction behavior learning |
TWI476585B (en) * | 2012-12-27 | 2015-03-11 | Chunghwa Telecom Co Ltd | System and method for two-phase memory leak detection |
US9013494B2 (en) | 2006-12-07 | 2015-04-21 | Sony Computer Entertainment Inc. | Heads-up-display software development tool |
US20150121151A1 (en) * | 2013-10-24 | 2015-04-30 | Fujitsu Limited | Information processing apparatus and information collection method |
US9043635B2 (en) | 2004-08-17 | 2015-05-26 | Shaw Parsing, Llc | Techniques for upstream failure detection and failure recovery |
US9141510B2 (en) | 2011-08-24 | 2015-09-22 | Microsoft Technology Licensing, Llc | Memory allocation tracking |
US20150269066A1 (en) * | 2014-03-21 | 2015-09-24 | Red Hat Israel, Ltd. | Indirect resource management |
US20150269052A1 (en) * | 2014-03-21 | 2015-09-24 | Marvell World Trade Ltd | Method and apparatus for supporting performance analysis |
US9176783B2 (en) | 2010-05-24 | 2015-11-03 | International Business Machines Corporation | Idle transitions sampling with execution context |
US9229917B2 (en) | 2003-03-28 | 2016-01-05 | Microsoft Technology Licensing, Llc | Electronic form user interfaces |
US9311220B1 (en) * | 2013-12-31 | 2016-04-12 | Google Inc. | System to uncover root cause of non-deterministic (flaky) tests |
US9311598B1 (en) | 2012-02-02 | 2016-04-12 | AppDynamics, Inc. | Automatic capture of detailed analysis information for web application outliers with very low overhead |
US9335038B2 (en) | 2011-07-20 | 2016-05-10 | Ip Holdings, Llc | Vertically disposed HID lamp fixture |
US9418005B2 (en) | 2008-07-15 | 2016-08-16 | International Business Machines Corporation | Managing garbage collection in a data processing system |
US20160253103A1 (en) * | 2015-02-27 | 2016-09-01 | International Business Machines Corporation | Tuning utilization and heap memory size for real-time garbage collection |
USD769514S1 (en) | 2014-10-22 | 2016-10-18 | Ip Holdings, Llc | Horticulture grow light |
US9471378B2 (en) | 2012-05-31 | 2016-10-18 | Apple Inc. | Adaptive resource management of a data processing system |
USD769513S1 (en) | 2015-04-15 | 2016-10-18 | Ip Holdings, Llc | Light fixture |
USD770079S1 (en) | 2015-04-02 | 2016-10-25 | Ip Holdings, Llc | Light fixture |
USD770670S1 (en) | 2015-06-24 | 2016-11-01 | Ip Holdings, Llc | Horticulture grow light |
USD771301S1 (en) | 2013-06-20 | 2016-11-08 | Ip Holdings, Llc | Horticulture grow light fixture |
USD773107S1 (en) | 2015-04-13 | 2016-11-29 | Ip Holdings, Llc | Horticulture grow light |
USD775406S1 (en) | 2014-02-24 | 2016-12-27 | Ip Holdings, Llc | Horticulture grow light reflector |
USD775760S1 (en) | 2013-03-27 | 2017-01-03 | Ip Holdings, Llc | Horticulture grow light housing |
US9612808B1 (en) * | 2016-02-25 | 2017-04-04 | International Business Machines Corporation | Memory use for string object creation |
USD783887S1 (en) | 2014-12-11 | 2017-04-11 | Ip Holdings, Llc | Horticulture grow light |
US20170124123A1 (en) * | 2015-10-30 | 2017-05-04 | Netapp, Inc. | Auto-expiring locks based on object stamping |
USD792635S1 (en) | 2014-08-07 | 2017-07-18 | Ip Holdings, Llc | Horticulture grow light |
USD793616S1 (en) | 2014-09-11 | 2017-08-01 | Ip Holdings, Llc | Light fixture |
US9752766B2 (en) | 2013-07-18 | 2017-09-05 | Ip Holdings, Llc | Air cooled horticulture lighting fixture |
US9750199B2 (en) | 2013-07-18 | 2017-09-05 | Ip Holdings, Llc | Air cooled horticulture lighting fixture |
USD796728S1 (en) | 2016-06-06 | 2017-09-05 | Ip Holdings, Llc | Light fixture |
USD796727S1 (en) | 2013-07-09 | 2017-09-05 | Ip Holdings, Llc | Horticulture grow light housing |
USD797350S1 (en) | 2016-11-01 | 2017-09-12 | Ip Holdings, Llc | Light fixture |
USD797353S1 (en) | 2014-06-11 | 2017-09-12 | Ip Holdings, Llc | Sealed optics air cooled grow light |
USD804078S1 (en) | 2016-08-31 | 2017-11-28 | Ip Holdings, Llc | Light fixture |
USD804079S1 (en) | 2016-08-31 | 2017-11-28 | Ip Holdings, Llc | Light fixture |
USD804706S1 (en) | 2016-01-05 | 2017-12-05 | Ip Holdings, Llc | Light fixture |
USD804707S1 (en) | 2016-01-07 | 2017-12-05 | Ip Holding, Llc | Light fixture |
US20180024909A1 (en) * | 2016-07-25 | 2018-01-25 | International Business Machines Corporation | Monitoring growth of memory buffers in logging and dynamically adapting quantity and detail of logging |
USD814687S1 (en) | 2015-01-08 | 2018-04-03 | Ip Holdings, Llc | Light fixture |
USD822882S1 (en) | 2017-05-17 | 2018-07-10 | Ip Holdings, Llc | Horticulture grow light |
USD842532S1 (en) | 2017-10-25 | 2019-03-05 | Hgci, Inc. | Light fixture |
USD843049S1 (en) | 2017-09-14 | 2019-03-12 | Hgci, Inc. | Horticulture grow light |
USD848664S1 (en) | 2017-11-07 | 2019-05-14 | Hgci, Inc. | Light fixture |
USD848663S1 (en) | 2017-11-03 | 2019-05-14 | Hgci, Inc. | Light fixture |
USD848665S1 (en) | 2017-11-08 | 2019-05-14 | Hgci, Inc. | Horticulture grow light |
US10353797B2 (en) * | 2006-12-29 | 2019-07-16 | International Business Machines Corporation | Using memory tracking data to inform a memory map tool |
US10417189B2 (en) | 2015-10-30 | 2019-09-17 | Netapp, Inc. | Hybrid model of fine-grained locking and data partitioning |
USD871654S1 (en) | 2017-10-30 | 2019-12-31 | Hgci, Inc. | Light fixture |
US10552185B2 (en) * | 2018-05-24 | 2020-02-04 | International Business Machines Corporation | Lightweight and precise value profiling |
US10706101B2 (en) | 2016-04-14 | 2020-07-07 | Advanced Micro Devices, Inc. | Bucketized hash tables with remap entries |
US10719362B2 (en) * | 2018-10-10 | 2020-07-21 | Oracle International Corporation | Managing multiple isolated execution contexts in a single process |
US10761965B2 (en) * | 2018-09-28 | 2020-09-01 | Atlassian Pty Ltd. | Detecting method calls based on stack trace data |
US10831591B2 (en) | 2018-01-11 | 2020-11-10 | Commvault Systems, Inc. | Remedial action based on maintaining process awareness in data storage management |
WO2020242655A1 (en) * | 2019-05-29 | 2020-12-03 | Microsoft Technology Licensing, Llc | Exposing memory-backed objects as queryable memory resources |
US10901615B2 (en) | 2004-04-30 | 2021-01-26 | Commvault Systems, Inc. | Systems and methods for storage modeling and costing |
US11132139B2 (en) | 2005-12-19 | 2021-09-28 | Commvault Systems, Inc. | Systems and methods for migrating components in a hierarchical storage network |
US11138034B2 (en) * | 2017-10-26 | 2021-10-05 | Huawei Technologies Co., Ltd. | Method and apparatus for collecting information, and method and apparatus for releasing memory |
US11301333B2 (en) | 2015-06-26 | 2022-04-12 | Commvault Systems, Inc. | Incrementally accumulating in-process performance data and hierarchical reporting thereof for a data stream in a secondary copy operation |
US20220114092A1 (en) * | 2020-10-13 | 2022-04-14 | Dynatrace Llc | Method And System For Estimating Garbage Collection Suspension Contributions Of Individual Allocation Sites |
US11449253B2 (en) | 2018-12-14 | 2022-09-20 | Commvault Systems, Inc. | Disk usage growth prediction system |
US11474896B2 (en) | 2015-10-29 | 2022-10-18 | Commvault Systems, Inc. | Monitoring, diagnosing, and repairing a management database in a data storage management system |
CN117435440A (en) * | 2023-12-20 | 2024-01-23 | 麒麟软件有限公司 | Dynamic analysis method and system for program heap space |
US11983077B2 (en) | 2022-02-24 | 2024-05-14 | Commvault Systems, Inc. | Incrementally accumulating in-process performance data and hierarchical reporting thereof for a data stream in a secondary copy operation |
Citations (47)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4746920A (en) | 1986-03-28 | 1988-05-24 | Tandem Computers Incorporated | Method and apparatus for clock management |
US4821220A (en) | 1986-07-25 | 1989-04-11 | Tektronix, Inc. | System for animating program operation and displaying time-based relationships |
US5047919A (en) | 1986-04-03 | 1991-09-10 | Harris Corporation | Method and apparatus for monitoring software execution in a parallel multiprocessor computer system |
US5161226A (en) | 1991-05-10 | 1992-11-03 | Jmi Software Consultants Inc. | Microprocessor inverse processor state usage |
US5179702A (en) | 1989-12-29 | 1993-01-12 | Supercomputer Systems Limited Partnership | System and method for controlling a highly parallel multiprocessor using an anarchy based scheduler for parallel execution thread scheduling |
JPH05303533A (en) | 1992-04-27 | 1993-11-16 | Omron Corp | Data processing system |
US5307499A (en) | 1990-11-30 | 1994-04-26 | Singapore Computer Systems Limited | Interpretive object-oriented facility which can access pre-compiled classes |
US5355487A (en) | 1991-02-28 | 1994-10-11 | International Business Machines Corporation | Non-invasive trace-driven system and method for computer system profiling |
US5371878A (en) | 1990-12-24 | 1994-12-06 | Ball Corporation | System for analysis of embedded computer systems |
DE9414117U1 (en) | 1994-08-31 | 1994-12-15 | Liedtke Acryl Gmbh | Food box, especially for bananas |
US5408650A (en) * | 1993-06-29 | 1995-04-18 | Digital Equipment Corporation | Memory analysis system for dynamically displaying memory allocation and de-allocation events associated with an application program |
US5442758A (en) | 1993-07-19 | 1995-08-15 | Sequent Computer Systems, Inc. | Apparatus and method for achieving reduced overhead mutual exclusion and maintaining coherency in a multiprocessor system utilizing execution history and thread monitoring |
US5450586A (en) | 1991-08-14 | 1995-09-12 | Hewlett-Packard Company | System for analyzing and debugging embedded software through dynamic and interactive use of code markers |
US5459868A (en) | 1990-11-30 | 1995-10-17 | St Computer Systems & Services | Interpretive object-oriented facility which can access pre-compiled classes |
US5483654A (en) | 1993-09-15 | 1996-01-09 | Allen-Bradley Company, Inc. | Apparatus to select computer program for execution |
US5485574A (en) | 1993-11-04 | 1996-01-16 | Microsoft Corporation | Operating system based performance monitoring of programs |
US5509070A (en) | 1992-12-15 | 1996-04-16 | Softlock Services Inc. | Method for encouraging purchase of executable and non-executable software |
WO1996012224A1 (en) | 1994-10-18 | 1996-04-25 | Marcam Corporation | Method and apparatus for testing object-oriented programming constructs |
DE29600609U1 (en) | 1996-01-17 | 1997-02-13 | Siemens Ag | Automation device |
US5613118A (en) | 1994-06-20 | 1997-03-18 | International Business Machines Corporation | Profile-based preprocessor for optimizing programs |
US5682328A (en) | 1996-09-11 | 1997-10-28 | Bbn Corporation | Centralized computer event data logging system |
US5689707A (en) * | 1995-12-04 | 1997-11-18 | Ncr Corporation | Method and apparatus for detecting memory leaks using expiration events and dependent pointers to indicate when a memory allocation should be de-allocated |
US5706515A (en) | 1996-03-25 | 1998-01-06 | Sun Microsystems, Inc. | System and method for implementing an atomic wait for notification operation |
US5742672A (en) | 1994-07-19 | 1998-04-21 | Burk; Peter | Installation of a multi-terminal network |
US5761380A (en) | 1996-02-12 | 1998-06-02 | International Business Machines Corporation | Coordinating installation of distributed software components |
US5768500A (en) | 1994-06-20 | 1998-06-16 | Lucent Technologies Inc. | Interrupt-based hardware support for profiling memory system performance |
US5799143A (en) | 1996-08-26 | 1998-08-25 | Motorola, Inc. | Multiple context software analysis |
US5845077A (en) | 1995-11-27 | 1998-12-01 | Microsoft Corporation | Method and system for identifying and obtaining computer software from a remote computer |
US5872909A (en) | 1995-01-24 | 1999-02-16 | Wind River Systems, Inc. | Logic analyzer for software |
US5884080A (en) | 1996-11-26 | 1999-03-16 | International Business Machines Corporation | System and method for instruction burst performance profiling for single-processor and multi-processor systems |
US5884082A (en) | 1995-05-19 | 1999-03-16 | Lucent Technologies Inc. | Method for monitoring a digital multiprocessor |
US5900001A (en) * | 1997-04-23 | 1999-05-04 | Sun Microsystems, Inc. | Method and apparatus for optimizing exact garbage collection using a bifurcated data structure |
US5908470A (en) | 1997-01-03 | 1999-06-01 | Ncr Corporation | Method for contention-free access and management of timers in multiprocessing environments |
US5911144A (en) * | 1997-04-23 | 1999-06-08 | Sun Microsystems, Inc. | Method and apparatus for optimizing the assignment of hash values to nodes residing in a garbage collected heap |
US5919247A (en) | 1996-07-24 | 1999-07-06 | Marimba, Inc. | Method for the distribution of code and data updates |
US5920876A (en) * | 1997-04-23 | 1999-07-06 | Sun Microsystems, Inc. | Performing exact garbage collection using bitmaps that identify pointer values within objects |
US5966540A (en) | 1997-02-06 | 1999-10-12 | International Business Machines Corp. | Hosted machine code installation |
US5964846A (en) | 1997-07-07 | 1999-10-12 | International Business Machines Corporation | System and method for mapping processor clock values in a multiprocessor system |
US5978578A (en) | 1997-01-30 | 1999-11-02 | Azarya; Arnon | Openbus system for control automation networks |
US5991543A (en) | 1997-08-29 | 1999-11-23 | Dell Usa, L.P. | Software installation and testing for a build-to-order computer system |
US5995757A (en) | 1997-08-29 | 1999-11-30 | Dell Usa, L.P. | Software installation and testing for a build-to order computer system |
US6006035A (en) | 1997-12-31 | 1999-12-21 | Network Associates | Method and system for custom computer software installation |
US6093216A (en) * | 1998-05-29 | 2000-07-25 | Intel Corporation | Method of run-time tracking of object references in Java programs |
US6105040A (en) * | 1997-06-30 | 2000-08-15 | Sun Microsystems, Inc. | Method and apparatus for managing stored objects |
US6199075B1 (en) * | 1997-05-30 | 2001-03-06 | Sun Microsystems, Inc. | Method and apparatus for generational garbage collection of a heap memory shared by multiple processors |
US6338159B1 (en) * | 1997-12-12 | 2002-01-08 | International Business Machines Corporation | System and method for providing trace information |
US6349406B1 (en) * | 1997-12-12 | 2002-02-19 | International Business Machines Coporation | Method and system for compensating for instrumentation overhead in trace data by computing average minimum event times |
-
2000
- 2000-06-08 US US09/589,798 patent/US6658652B1/en not_active Expired - Lifetime
Patent Citations (47)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4746920A (en) | 1986-03-28 | 1988-05-24 | Tandem Computers Incorporated | Method and apparatus for clock management |
US5047919A (en) | 1986-04-03 | 1991-09-10 | Harris Corporation | Method and apparatus for monitoring software execution in a parallel multiprocessor computer system |
US4821220A (en) | 1986-07-25 | 1989-04-11 | Tektronix, Inc. | System for animating program operation and displaying time-based relationships |
US5179702A (en) | 1989-12-29 | 1993-01-12 | Supercomputer Systems Limited Partnership | System and method for controlling a highly parallel multiprocessor using an anarchy based scheduler for parallel execution thread scheduling |
US5459868A (en) | 1990-11-30 | 1995-10-17 | St Computer Systems & Services | Interpretive object-oriented facility which can access pre-compiled classes |
US5307499A (en) | 1990-11-30 | 1994-04-26 | Singapore Computer Systems Limited | Interpretive object-oriented facility which can access pre-compiled classes |
US5371878A (en) | 1990-12-24 | 1994-12-06 | Ball Corporation | System for analysis of embedded computer systems |
US5355487A (en) | 1991-02-28 | 1994-10-11 | International Business Machines Corporation | Non-invasive trace-driven system and method for computer system profiling |
US5161226A (en) | 1991-05-10 | 1992-11-03 | Jmi Software Consultants Inc. | Microprocessor inverse processor state usage |
US5450586A (en) | 1991-08-14 | 1995-09-12 | Hewlett-Packard Company | System for analyzing and debugging embedded software through dynamic and interactive use of code markers |
JPH05303533A (en) | 1992-04-27 | 1993-11-16 | Omron Corp | Data processing system |
US5509070A (en) | 1992-12-15 | 1996-04-16 | Softlock Services Inc. | Method for encouraging purchase of executable and non-executable software |
US5408650A (en) * | 1993-06-29 | 1995-04-18 | Digital Equipment Corporation | Memory analysis system for dynamically displaying memory allocation and de-allocation events associated with an application program |
US5442758A (en) | 1993-07-19 | 1995-08-15 | Sequent Computer Systems, Inc. | Apparatus and method for achieving reduced overhead mutual exclusion and maintaining coherency in a multiprocessor system utilizing execution history and thread monitoring |
US5483654A (en) | 1993-09-15 | 1996-01-09 | Allen-Bradley Company, Inc. | Apparatus to select computer program for execution |
US5485574A (en) | 1993-11-04 | 1996-01-16 | Microsoft Corporation | Operating system based performance monitoring of programs |
US5613118A (en) | 1994-06-20 | 1997-03-18 | International Business Machines Corporation | Profile-based preprocessor for optimizing programs |
US5768500A (en) | 1994-06-20 | 1998-06-16 | Lucent Technologies Inc. | Interrupt-based hardware support for profiling memory system performance |
US5742672A (en) | 1994-07-19 | 1998-04-21 | Burk; Peter | Installation of a multi-terminal network |
DE9414117U1 (en) | 1994-08-31 | 1994-12-15 | Liedtke Acryl Gmbh | Food box, especially for bananas |
WO1996012224A1 (en) | 1994-10-18 | 1996-04-25 | Marcam Corporation | Method and apparatus for testing object-oriented programming constructs |
US5872909A (en) | 1995-01-24 | 1999-02-16 | Wind River Systems, Inc. | Logic analyzer for software |
US5884082A (en) | 1995-05-19 | 1999-03-16 | Lucent Technologies Inc. | Method for monitoring a digital multiprocessor |
US5845077A (en) | 1995-11-27 | 1998-12-01 | Microsoft Corporation | Method and system for identifying and obtaining computer software from a remote computer |
US5689707A (en) * | 1995-12-04 | 1997-11-18 | Ncr Corporation | Method and apparatus for detecting memory leaks using expiration events and dependent pointers to indicate when a memory allocation should be de-allocated |
DE29600609U1 (en) | 1996-01-17 | 1997-02-13 | Siemens Ag | Automation device |
US5761380A (en) | 1996-02-12 | 1998-06-02 | International Business Machines Corporation | Coordinating installation of distributed software components |
US5706515A (en) | 1996-03-25 | 1998-01-06 | Sun Microsystems, Inc. | System and method for implementing an atomic wait for notification operation |
US5919247A (en) | 1996-07-24 | 1999-07-06 | Marimba, Inc. | Method for the distribution of code and data updates |
US5799143A (en) | 1996-08-26 | 1998-08-25 | Motorola, Inc. | Multiple context software analysis |
US5682328A (en) | 1996-09-11 | 1997-10-28 | Bbn Corporation | Centralized computer event data logging system |
US5884080A (en) | 1996-11-26 | 1999-03-16 | International Business Machines Corporation | System and method for instruction burst performance profiling for single-processor and multi-processor systems |
US5908470A (en) | 1997-01-03 | 1999-06-01 | Ncr Corporation | Method for contention-free access and management of timers in multiprocessing environments |
US5978578A (en) | 1997-01-30 | 1999-11-02 | Azarya; Arnon | Openbus system for control automation networks |
US5966540A (en) | 1997-02-06 | 1999-10-12 | International Business Machines Corp. | Hosted machine code installation |
US5920876A (en) * | 1997-04-23 | 1999-07-06 | Sun Microsystems, Inc. | Performing exact garbage collection using bitmaps that identify pointer values within objects |
US5911144A (en) * | 1997-04-23 | 1999-06-08 | Sun Microsystems, Inc. | Method and apparatus for optimizing the assignment of hash values to nodes residing in a garbage collected heap |
US5900001A (en) * | 1997-04-23 | 1999-05-04 | Sun Microsystems, Inc. | Method and apparatus for optimizing exact garbage collection using a bifurcated data structure |
US6199075B1 (en) * | 1997-05-30 | 2001-03-06 | Sun Microsystems, Inc. | Method and apparatus for generational garbage collection of a heap memory shared by multiple processors |
US6105040A (en) * | 1997-06-30 | 2000-08-15 | Sun Microsystems, Inc. | Method and apparatus for managing stored objects |
US5964846A (en) | 1997-07-07 | 1999-10-12 | International Business Machines Corporation | System and method for mapping processor clock values in a multiprocessor system |
US5991543A (en) | 1997-08-29 | 1999-11-23 | Dell Usa, L.P. | Software installation and testing for a build-to-order computer system |
US5995757A (en) | 1997-08-29 | 1999-11-30 | Dell Usa, L.P. | Software installation and testing for a build-to order computer system |
US6338159B1 (en) * | 1997-12-12 | 2002-01-08 | International Business Machines Corporation | System and method for providing trace information |
US6349406B1 (en) * | 1997-12-12 | 2002-02-19 | International Business Machines Coporation | Method and system for compensating for instrumentation overhead in trace data by computing average minimum event times |
US6006035A (en) | 1997-12-31 | 1999-12-21 | Network Associates | Method and system for custom computer software installation |
US6093216A (en) * | 1998-05-29 | 2000-07-25 | Intel Corporation | Method of run-time tracking of object references in Java programs |
Non-Patent Citations (14)
Title |
---|
A Unifying Approach to Performance Analysis In The Java Environment; Alexander et al; Vol 39, No. 1; pp 1-16. |
Adaptive Trace-Directed ProgramRestructuring; International Business Machines Technical Disclosure Bulletin; vol. 37 No. 02B, Feb. 1994; pp. 115-116. |
Application of Interpreter for Debugging Functions; International Business Machines Technical Disclosure Bulletin; Vol 36, No 09B, Sep. 1993; pp 67-68. |
Call Path Profiling of Monotonic Program Resources in UNIX; Hall et al; Jun. 24-25, 1993; pp. 1-13. |
Data Structure and Insertion Algorithm for Representing Asynchronous Occurrences for Visualization by Trace Visualization Tools using Ghant Charts with Occurrence Hierarchies; International Business Machines Technical Disclosure Bulletin; Vol 36, No 07, Jul. 1993; pp. 547-557. |
Exploiting Hardware Performance Counters with Flow and Context Sensitive Profiling; Ammons et al; 1997; pp. 85-96. |
Gupta, Aloke and Fuchs, W. Kent, "Garbage Collection in a Distributed Object-Oriented System", 1993 IEEE, p. 257-265, retrieved from the IEEE database Dec. 5, 2002.* * |
Java Virtual Machine Profiler Interface; Viswanathan et al.; vol. 39, No. 1; pp. 1-14. |
Minimizing Locking to Access Global Shared Data; International Business Machines Technical Disclosure Bulletin; Feb. 1995; pp. 619-622. |
Optimally Profiling and Tracing Programs; Ball et al; Jul. 1994; pp 1319-1360. |
Petit-Bianco, Alexandre, "Java Garbage Collection for Real-Time Systems", Dr. Dobb's Journal Oct. 1998, retrieved from a google.com search Dec. 5, 2002. www.ddj.com/documents/s=915/ddj9810a/9810a.* * |
Profiling and Tracing Dynamic Library Usage Via Interposition; Curry; USENIX Conference; 1994; pp. 267-278. |
Venners, Bill, "Java's garbage-collected heap", Java World, 1996, retireved from a google.com search Dec. 5, 2002. www.javaworld.com/javaworld/jw-08-1996/jw-08-gc_p.* * |
Zorn, Benjamin and Grunwald, Dirk, "Evaluating Models of Memory Allocation", 1994 ACM, retrieved from the ACM database Dec. 5, 2002.* * |
Cited By (439)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20060101416A1 (en) * | 1998-12-23 | 2006-05-11 | Callahan Charles D Ii | Parallelism performance analysis based on execution trace information |
US7739667B2 (en) * | 1998-12-23 | 2010-06-15 | Cray Inc. | Parallelism performance analysis based on execution trace information |
US7650370B2 (en) | 1999-10-28 | 2010-01-19 | Bea Systems, Inc. | System and method for regeneration of methods and garbage collection of unused methods |
US20050256913A1 (en) * | 1999-10-28 | 2005-11-17 | Bea Systems, Inc. | System and method for regeneration of methods and garbage collection of unused methods |
US8074217B2 (en) | 2000-06-21 | 2011-12-06 | Microsoft Corporation | Methods and systems for delivering software |
US7979856B2 (en) | 2000-06-21 | 2011-07-12 | Microsoft Corporation | Network-based software extensions |
US7451159B2 (en) | 2000-07-20 | 2008-11-11 | Micosoft Corporation | Method and apparatus for identifying programming object attributes |
US7099886B2 (en) * | 2000-07-20 | 2006-08-29 | Microsoft Corporation | Method and apparatus for identifying programming object attributes |
US20020010809A1 (en) * | 2000-07-20 | 2002-01-24 | Ralph Lipe | Method and apparatus for identifying programming object attributes |
US7457821B2 (en) | 2000-07-20 | 2008-11-25 | Microsoft Corporation | Method and apparatus for identifying programming object attributes |
US20050262137A1 (en) * | 2000-07-20 | 2005-11-24 | Microsoft Corporation | Method and apparatus for identifying programming object attributes |
US7584169B2 (en) | 2000-07-20 | 2009-09-01 | Microsoft Corporation | Method and apparatus for identifying programming object attributes |
US20050154724A1 (en) * | 2000-07-20 | 2005-07-14 | Microsoft Corporation | Method and apparatus for identifying programming object attributes |
US20030069905A1 (en) * | 2000-07-31 | 2003-04-10 | Microsoft Corporation | Method and system for concurrent garbage collection |
US7310655B2 (en) * | 2000-07-31 | 2007-12-18 | Microsoft Corporation | Method and system for concurrent garbage collection |
US6970893B2 (en) * | 2000-10-27 | 2005-11-29 | Bea Systems, Inc. | System and method for regeneration of methods and garbage collection of unused methods |
US20030131012A1 (en) * | 2000-10-27 | 2003-07-10 | Joakim Dahlstedt | System and method for regeneration of methods and garbage collection of unused methods |
US9613076B2 (en) | 2000-12-18 | 2017-04-04 | Zarbaña Digital Fund Llc | Storing state in a dynamic content routing network |
US7127720B2 (en) | 2000-12-18 | 2006-10-24 | Charles E Cano | Storing state in a dynamic content routing network |
US20060031283A1 (en) * | 2000-12-18 | 2006-02-09 | Timothy Tuttle | Asynchronous messaging using a node specialization architecture in the dynamic routing network |
US20070050519A1 (en) * | 2000-12-18 | 2007-03-01 | Cano Charles E | Storing state in a dynamic content routing network |
US7277917B2 (en) * | 2000-12-18 | 2007-10-02 | Shaw Parsing Llc | Asynchronous messaging using a dynamic routing network |
US20070239822A1 (en) * | 2000-12-18 | 2007-10-11 | Timothy Tuttle | Asynchronous messaging using a node specialization architecture in the dynamic routing network |
US8505024B2 (en) | 2000-12-18 | 2013-08-06 | Shaw Parsing Llc | Storing state in a dynamic content routing network |
US20060265488A1 (en) * | 2000-12-18 | 2006-11-23 | Timothy Tuttle | Asynchronous messaging using a dynamic routing network |
US7930362B2 (en) | 2000-12-18 | 2011-04-19 | Shaw Parsing, Llc | Techniques for delivering personalized content with a real-time routing network |
US20060031282A1 (en) * | 2000-12-18 | 2006-02-09 | Timothy Tuttle | Techniques for updating live objects at clients using a dynamic routing network |
US7814225B2 (en) | 2000-12-18 | 2010-10-12 | Rumelhart Karl E | Techniques for delivering personalized content with a real-time routing network |
US10860567B2 (en) | 2000-12-18 | 2020-12-08 | Zarbaña Digital Fund Llc | Storing state in a dynamic content routing network |
US7051070B2 (en) * | 2000-12-18 | 2006-05-23 | Timothy Tuttle | Asynchronous messaging using a node specialization architecture in the dynamic routing network |
US8407722B2 (en) | 2000-12-18 | 2013-03-26 | Shaw Parsing L.L.C. | Asynchronous messaging using a node specialization architecture in the dynamic routing network |
US7043525B2 (en) * | 2000-12-18 | 2006-05-09 | Bang Networks, Inc. | Techniques for updating live objects at clients using a dynamic routing network |
US9071648B2 (en) | 2000-12-18 | 2015-06-30 | Shaw Parsing L.L.C. | Asynchronous messaging using a node specialization architecture in the dynamic routing network |
US20020144185A1 (en) * | 2001-03-29 | 2002-10-03 | International Business Machines Corporation | Verification of global coherence in a multi-node NUMA system |
US6785773B2 (en) * | 2001-03-29 | 2004-08-31 | International Business Machines Corporation | Verification of global coherence in a multi-node NUMA system |
US7380239B1 (en) | 2001-05-31 | 2008-05-27 | Oracle International Corporation | Method and mechanism for diagnosing computer applications using traces |
US7376937B1 (en) * | 2001-05-31 | 2008-05-20 | Oracle International Corporation | Method and mechanism for using a meta-language to define and analyze traces |
US20030028859A1 (en) * | 2001-07-31 | 2003-02-06 | Nigel Street | Method of collecting, visualizing and analyzing object interaction |
US6832302B1 (en) * | 2001-10-24 | 2004-12-14 | At&T Corp. | Methods and apparatus for detecting heap smashing |
WO2004002044A2 (en) * | 2002-02-01 | 2003-12-31 | John Fairweather | A system for exchanging binary data |
WO2004002044A3 (en) * | 2002-02-01 | 2004-06-10 | John Fairweather | A system for exchanging binary data |
US6985976B1 (en) * | 2002-02-22 | 2006-01-10 | Teja Technologies, Inc. | System, method, and computer program product for memory management for defining class lists and node lists for allocation and deallocation of memory blocks |
US20030191864A1 (en) * | 2002-04-01 | 2003-10-09 | Sun Microsystems, Inc. | Method and system for detecting deprecated elements during runtime |
US7320123B2 (en) * | 2002-04-01 | 2008-01-15 | Sun Microsystems, Inc. | Method and system for detecting deprecated elements during runtime |
US7430586B2 (en) * | 2002-04-16 | 2008-09-30 | Zoran Corporation | System and method for managing memory |
US20030195943A1 (en) * | 2002-04-16 | 2003-10-16 | Elliott Bradshaw | System and method for managing memory |
US20030196061A1 (en) * | 2002-04-16 | 2003-10-16 | Hideya Kawahara | System and method for secure execution of multiple applications using a single GC heap |
US7480856B2 (en) * | 2002-05-02 | 2009-01-20 | Intel Corporation | System and method for transformation of XML documents using stylesheets |
US20030229766A1 (en) * | 2002-06-06 | 2003-12-11 | David Dice | Methods and apparatus for performing a memory management technique |
US6862674B2 (en) * | 2002-06-06 | 2005-03-01 | Sun Microsystems | Methods and apparatus for performing a memory management technique |
US20040039746A1 (en) * | 2002-06-14 | 2004-02-26 | Sun Microsystems, Inc. | Protecting object identity in a language with built-in synchronization objects |
US7458061B2 (en) * | 2002-06-14 | 2008-11-25 | Sun Microsystems, Inc. | Protecting object identity in a language with built-in synchronization objects |
US20040034742A1 (en) * | 2002-06-24 | 2004-02-19 | Field Scott A. | Stack allocation system and method |
US7124251B2 (en) * | 2002-06-24 | 2006-10-17 | Microsoft Corporation | Stack allocation system and method |
US7162712B2 (en) * | 2002-06-26 | 2007-01-09 | Sun Microsystems, Inc. | Method and apparatus for creating string objects in a programming language |
US20040001010A1 (en) * | 2002-06-26 | 2004-01-01 | Nicholas Shaylor | Method and apparatus for creating string objects in a programming language |
US20050160431A1 (en) * | 2002-07-29 | 2005-07-21 | Oracle Corporation | Method and mechanism for debugging a series of related events within a computer system |
US7165190B1 (en) | 2002-07-29 | 2007-01-16 | Oracle International Corporation | Method and mechanism for managing traces within a computer system |
US7512954B2 (en) | 2002-07-29 | 2009-03-31 | Oracle International Corporation | Method and mechanism for debugging a series of related events within a computer system |
US7200588B1 (en) | 2002-07-29 | 2007-04-03 | Oracle International Corporation | Method and mechanism for analyzing trace data using a database management system |
US8046752B2 (en) | 2002-11-25 | 2011-10-25 | Microsoft Corporation | Dynamic prefetching of hot data streams |
US20070083856A1 (en) * | 2002-11-25 | 2007-04-12 | Microsoft Corporation | Dynamic temporal optimization framework |
US20060070040A1 (en) * | 2002-11-25 | 2006-03-30 | Microsoft Corporation | Dynamic prefetching of hot data streams |
US20040111718A1 (en) * | 2002-12-04 | 2004-06-10 | Detlefs David L. | Block-offset table employing gaps in value set |
US7757202B2 (en) | 2002-12-20 | 2010-07-13 | Bea Systems, Inc. | System and method for memory leak detection in a virtual machine environment |
US20040133895A1 (en) * | 2002-12-20 | 2004-07-08 | Bea Systems, Inc. | System and method for memory leak detection in a virtual machine environment |
US20080065842A1 (en) * | 2002-12-20 | 2008-03-13 | Bea Systems, Inc. | System and Method for Memory Leak Detection in a Virtual Machine Environment |
US7293263B2 (en) * | 2002-12-20 | 2007-11-06 | Bea Systems, Inc. | System and method for memory leak detection in a virtual machine environment |
US20040154016A1 (en) * | 2003-01-31 | 2004-08-05 | Randall Keith H. | System and method of measuring application resource usage |
US8799883B2 (en) * | 2003-01-31 | 2014-08-05 | Hewlett-Packard Development Company, L. P. | System and method of measuring application resource usage |
US20040162860A1 (en) * | 2003-02-14 | 2004-08-19 | Detlefs David L. | Parallel card table scanning and updating |
US7058781B2 (en) | 2003-02-14 | 2006-06-06 | Sun Microsystems, Inc. | Parallel card table scanning and updating |
US20040162861A1 (en) * | 2003-02-19 | 2004-08-19 | Detlefs David L. | Parallel non-contiguous allocation and card parsing |
US7043509B2 (en) * | 2003-02-19 | 2006-05-09 | Sun Microsystems, Inc. | Parallel non-contiguous allocation and card parsing |
US7925621B2 (en) | 2003-03-24 | 2011-04-12 | Microsoft Corporation | Installing a solution |
US8918729B2 (en) | 2003-03-24 | 2014-12-23 | Microsoft Corporation | Designing electronic forms |
US8117552B2 (en) | 2003-03-24 | 2012-02-14 | Microsoft Corporation | Incrementally designing electronic forms and hierarchical schemas |
US20080046889A1 (en) * | 2003-03-27 | 2008-02-21 | International Business Machines Corporation | Deallocation of computer data in a multithreaded computer |
US8209692B2 (en) * | 2003-03-27 | 2012-06-26 | International Business Machines Corporation | Deallocation of computer data in a multithreaded computer |
US9229917B2 (en) | 2003-03-28 | 2016-01-05 | Microsoft Technology Licensing, Llc | Electronic form user interfaces |
US7343598B2 (en) | 2003-04-25 | 2008-03-11 | Microsoft Corporation | Cache-conscious coallocation of hot data streams |
US20040215880A1 (en) * | 2003-04-25 | 2004-10-28 | Microsoft Corporation | Cache-conscious coallocation of hot data streams |
US9239821B2 (en) | 2003-08-01 | 2016-01-19 | Microsoft Technology Licensing, Llc | Translation file |
US8892993B2 (en) | 2003-08-01 | 2014-11-18 | Microsoft Corporation | Translation file |
US9268760B2 (en) | 2003-08-06 | 2016-02-23 | Microsoft Technology Licensing, Llc | Correlation, association, or correspondence of electronic forms |
US8429522B2 (en) | 2003-08-06 | 2013-04-23 | Microsoft Corporation | Correlation, association, or correspondence of electronic forms |
US7971139B2 (en) | 2003-08-06 | 2011-06-28 | Microsoft Corporation | Correlation, association, or correspondence of electronic forms |
US7792866B2 (en) | 2003-08-25 | 2010-09-07 | International Business Machines Corporation | Method and system for querying structured documents stored in their native format in a database |
US8250093B2 (en) | 2003-08-25 | 2012-08-21 | International Business Machines Corporation | Method and system for utilizing a cache for path-level access control to structured documents stored in a database |
US20090077625A1 (en) * | 2003-08-25 | 2009-03-19 | International Business Machines Corporation | Associating information related to components in structured documents stored in their native format in a database |
US8150818B2 (en) * | 2003-08-25 | 2012-04-03 | International Business Machines Corporation | Method and system for storing structured documents in their native format in a database |
US8145668B2 (en) | 2003-08-25 | 2012-03-27 | International Business Machines Corporation | Associating information related to components in structured documents stored in their native format in a database |
US20050050059A1 (en) * | 2003-08-25 | 2005-03-03 | Van Der Linden Robbert C. | Method and system for storing structured documents in their native format in a database |
US20050050011A1 (en) * | 2003-08-25 | 2005-03-03 | Van Der Linden Robbert C. | Method and system for querying structured documents stored in their native format in a database |
US20050050467A1 (en) * | 2003-08-28 | 2005-03-03 | Henrik Loeser | Method and system for processing structured documents in a native database |
US7171430B2 (en) * | 2003-08-28 | 2007-01-30 | International Business Machines Corporation | Method and system for processing structured documents in a native database |
US9600597B2 (en) | 2003-08-28 | 2017-03-21 | International Business Machines Corporation | Processing structured documents stored in a database |
US8037090B2 (en) | 2003-08-28 | 2011-10-11 | International Business Machines Corporation | Processing structured documents stored in a database |
US7512608B2 (en) | 2003-08-28 | 2009-03-31 | International Business Machines Corporation | Method for processing structured documents stored in a database |
US20090171926A1 (en) * | 2003-08-28 | 2009-07-02 | International Business Machines Corporation | Processing Structured Documents Stored in a Database |
US8775468B2 (en) | 2003-08-29 | 2014-07-08 | International Business Machines Corporation | Method and system for providing path-level access control for structured documents stored in a database |
US9495553B2 (en) | 2003-08-29 | 2016-11-15 | International Business Machines Corporation | Providing path-level access control for structured documents stored in a database |
US20050076030A1 (en) * | 2003-08-29 | 2005-04-07 | International Business Machines Corporation | Method and system for providing path-level access control for structured documents stored in a database |
US20050076184A1 (en) * | 2003-10-01 | 2005-04-07 | Schumacher Michael K. | Apparatus and method for detecting memory leaks |
US7257692B2 (en) * | 2003-10-01 | 2007-08-14 | Lakeside Software, Inc. | Apparatus and method for detecting memory leaks |
US20050091646A1 (en) * | 2003-10-24 | 2005-04-28 | Microsoft Corporation | Statistical memory leak detection |
US20050091645A1 (en) * | 2003-10-24 | 2005-04-28 | Microsoft Corporation | Adaptive instrumentation runtime monitoring and analysis |
US7587709B2 (en) * | 2003-10-24 | 2009-09-08 | Microsoft Corporation | Adaptive instrumentation runtime monitoring and analysis |
US7577943B2 (en) * | 2003-10-24 | 2009-08-18 | Microsoft Corporation | Statistical memory leak detection |
US20050144410A1 (en) * | 2003-12-31 | 2005-06-30 | Microsoft Corporation | Dynamic memory heap tagging |
US7350045B2 (en) * | 2003-12-31 | 2008-03-25 | Microsoft Corporation | Dynamic memory heap tagging |
US7133993B1 (en) * | 2004-01-06 | 2006-11-07 | Altera Corporation | Inferring size of a processor memory address based on pointer usage |
US8640116B2 (en) * | 2004-02-26 | 2014-01-28 | Broadcom Corporation | Loader module, and method for loading program code into a memory |
US20050204342A1 (en) * | 2004-03-11 | 2005-09-15 | International Business Machines Corp. | Method, system and article for detecting memory leaks in Java software |
US7636745B1 (en) * | 2004-03-12 | 2009-12-22 | Sun Microsystems, Inc. | Concurrent-marking-initiation heuristic |
US20050216894A1 (en) * | 2004-03-25 | 2005-09-29 | Masato Igarashi | Design evaluation system and design evaluation method |
US7624389B2 (en) * | 2004-03-25 | 2009-11-24 | Kabushiki Kaisha Toshiba | Design evaluation system and design evaluation method |
US20050235127A1 (en) * | 2004-04-19 | 2005-10-20 | Cisco Technology, Inc. | Method and system for memory leak detection |
US7293142B1 (en) | 2004-04-19 | 2007-11-06 | Cisco Technology, Inc. | Memory leak detection system and method using contingency analysis |
US7487321B2 (en) | 2004-04-19 | 2009-02-03 | Cisco Technology, Inc. | Method and system for memory leak detection |
US7930491B1 (en) | 2004-04-19 | 2011-04-19 | Cisco Technology, Inc. | Memory corruption detection system and method using contingency analysis regulation |
US7200731B2 (en) * | 2004-04-23 | 2007-04-03 | Alcatel Ip Networks, Inc. | Memory leak detection |
US20050240747A1 (en) * | 2004-04-23 | 2005-10-27 | Alcatel Ip Networks, Inc. | Memory leak detection |
US7506129B2 (en) * | 2004-04-23 | 2009-03-17 | Alcatel Ip Networks, Inc. | Memory leak detection |
US10901615B2 (en) | 2004-04-30 | 2021-01-26 | Commvault Systems, Inc. | Systems and methods for storage modeling and costing |
US7284107B2 (en) | 2004-04-30 | 2007-10-16 | Microsoft Corporation | Special-use heaps |
US20050246511A1 (en) * | 2004-04-30 | 2005-11-03 | Microsoft Corporation | Special-use heaps |
US7644409B2 (en) | 2004-06-04 | 2010-01-05 | Sun Microsystems, Inc. | Techniques for accessing a shared resource using an improved synchronization mechanism |
US20060031844A1 (en) * | 2004-06-04 | 2006-02-09 | David Dice | Techniques for accessing a shared resource using an improved synchronization mechanism |
US7594234B1 (en) | 2004-06-04 | 2009-09-22 | Sun Microsystems, Inc. | Adaptive spin-then-block mutual exclusion in multi-threaded processing |
US8046758B2 (en) | 2004-06-04 | 2011-10-25 | Oracle America, Inc. | Adaptive spin-then-block mutual exclusion in multi-threaded processing |
US7444484B2 (en) * | 2004-06-24 | 2008-10-28 | International Business Machines Corporation | Method and system for determining memory usage of a heap |
US20050289307A1 (en) * | 2004-06-24 | 2005-12-29 | International Business Machines Corporation | Method and system for determining memory usage of a heap |
US7325106B1 (en) * | 2004-07-16 | 2008-01-29 | Sun Microsystems, Inc. | Method for monitoring heap for memory leaks |
US20060026379A1 (en) * | 2004-07-27 | 2006-02-02 | Samsung Electronics Co., Ltd. | Effective memory management method and device in object-oriented application |
US7475397B1 (en) | 2004-07-28 | 2009-01-06 | Sun Microsystems, Inc. | Methods and apparatus for providing a remote serialization guarantee |
US20060117318A1 (en) * | 2004-08-17 | 2006-06-01 | Shaw Parsing, Llc | Modular event-driven processing |
US8356305B2 (en) | 2004-08-17 | 2013-01-15 | Shaw Parsing, L.L.C. | Thread boundaries comprising functionalities for an event by a single thread and tasks associated with the thread boundaries configured in a defined relationship |
US9043635B2 (en) | 2004-08-17 | 2015-05-26 | Shaw Parsing, Llc | Techniques for upstream failure detection and failure recovery |
US8397237B2 (en) | 2004-08-17 | 2013-03-12 | Shaw Parsing, L.L.C. | Dynamically allocating threads from a thread pool to thread boundaries configured to perform a service for an event |
US20060041866A1 (en) * | 2004-08-17 | 2006-02-23 | Rajini Sivaram | Debugging an application process at runtime |
US7757217B2 (en) * | 2004-08-17 | 2010-07-13 | International Business Machines Corporation | Debugging an application process at runtime |
US20080222637A1 (en) * | 2004-09-09 | 2008-09-11 | Marc Alan Dickenson | Self-Optimizable Code |
US8266606B2 (en) | 2004-09-09 | 2012-09-11 | International Business Machines Corporation | Self-optimizable code for optimizing execution of tasks and allocation of memory in a data processing system |
US20060085156A1 (en) * | 2004-10-18 | 2006-04-20 | Kolawa Adam K | Method and system for predicting memory leaks from unit testing |
US7779223B2 (en) | 2004-10-28 | 2010-08-17 | International Business Machines Corporation | Memory leakage management |
US20060095427A1 (en) * | 2004-10-28 | 2006-05-04 | International Business Machines Corporation | Memory leakage management |
US20080168444A1 (en) * | 2004-10-28 | 2008-07-10 | Marc Alan Dickenson | Memory leakage management |
US7398369B2 (en) * | 2004-10-28 | 2008-07-08 | International Business Machines Corporation | Memory leakage management |
US20060130001A1 (en) * | 2004-11-30 | 2006-06-15 | International Business Machines Corporation | Apparatus and method for call stack profiling for a software application |
US7937651B2 (en) | 2005-01-14 | 2011-05-03 | Microsoft Corporation | Structural editing operations for network forms |
US7406683B2 (en) * | 2005-03-02 | 2008-07-29 | Cisco Technology, Inc. | System and method providing for interaction between programming languages |
US20060200808A1 (en) * | 2005-03-02 | 2006-09-07 | Cisco Technology, Inc. | System and method providing for interaction between programming languages |
US20060206885A1 (en) * | 2005-03-10 | 2006-09-14 | Seidman David I | Identifying memory leaks in computer systems |
US7434206B2 (en) | 2005-03-10 | 2008-10-07 | Hewlett-Packard Development Company, L.P. | Identifying memory leaks in computer systems |
US7313661B1 (en) * | 2005-03-18 | 2007-12-25 | Sun Microsystems, Inc. | Tool for identifying causes of memory leaks |
US8010515B2 (en) | 2005-04-15 | 2011-08-30 | Microsoft Corporation | Query to an electronic form |
US20060242636A1 (en) * | 2005-04-26 | 2006-10-26 | Microsoft Corporation | Variational path profiling |
US7607119B2 (en) | 2005-04-26 | 2009-10-20 | Microsoft Corporation | Variational path profiling |
US20060248103A1 (en) * | 2005-04-29 | 2006-11-02 | Cisco Technology, Inc. | Method of detecting memory leaks in software applications |
US7870170B2 (en) * | 2005-05-03 | 2011-01-11 | International Business Machines Corporation | Method and apparatus for determining leaks in a Java heap |
US20060253845A1 (en) * | 2005-05-03 | 2006-11-09 | International Business Machines Corporation | Method and apparatus for determining leaks in a Java heap |
US20060253507A1 (en) * | 2005-05-04 | 2006-11-09 | Tonic Solutions, Inc. | System and method for monitoring memory usage |
US7793304B2 (en) * | 2005-05-04 | 2010-09-07 | Symantec Corporation | System and method for monitoring memory usage |
US20060265438A1 (en) * | 2005-05-20 | 2006-11-23 | Microsoft Corporation | Leveraging garbage collection to dynamically infer heap invariants |
US7912877B2 (en) * | 2005-05-20 | 2011-03-22 | Microsoft Corporation | Leveraging garbage collection to dynamically infer heap invariants |
US20060265694A1 (en) * | 2005-05-20 | 2006-11-23 | Microsoft Corporation | Heap-based bug identification using anomaly detection |
US7770153B2 (en) * | 2005-05-20 | 2010-08-03 | Microsoft Corporation | Heap-based bug identification using anomaly detection |
US7496795B2 (en) | 2005-06-02 | 2009-02-24 | International Business Machines Corporation | Method, system, and computer program product for light weight memory leak detection |
US20060277440A1 (en) * | 2005-06-02 | 2006-12-07 | International Business Machines Corporation | Method, system, and computer program product for light weight memory leak detection |
US8200975B2 (en) | 2005-06-29 | 2012-06-12 | Microsoft Corporation | Digital signatures for network forms |
US7827538B2 (en) * | 2005-07-27 | 2010-11-02 | International Business Machines Corporation | Memory leak detection |
US20070027942A1 (en) * | 2005-07-27 | 2007-02-01 | Trotter Martin J | Memory leak detection |
US7685580B1 (en) * | 2005-08-30 | 2010-03-23 | Sun Microsystems, Inc. | Method and apparatus for selectively eliminating write barriers in snapshot-at-the beginning concurrent-marking garbage collectors |
US8196109B2 (en) * | 2005-09-09 | 2012-06-05 | International Business Machines Corporation | Common debug adaptor in a multiple computer programming language environment |
US20080263522A1 (en) * | 2005-09-09 | 2008-10-23 | International Business Machines Corporation | Common Debug Adaptor |
US7765528B2 (en) * | 2005-09-21 | 2010-07-27 | Hewlett-Packard Development Company, L.P. | Identifying sources of memory retention |
US20070067758A1 (en) * | 2005-09-21 | 2007-03-22 | Piotr Findeisen | Identifying sources of memory retention |
US8001459B2 (en) | 2005-12-05 | 2011-08-16 | Microsoft Corporation | Enabling electronic documents for limited-capability computing devices |
US9210234B2 (en) | 2005-12-05 | 2015-12-08 | Microsoft Technology Licensing, Llc | Enabling electronic documents for limited-capability computing devices |
US20070169031A1 (en) * | 2005-12-07 | 2007-07-19 | Microsoft Corporation | Efficient placement of software transactional memory operations around procedure calls |
US20070169030A1 (en) * | 2005-12-07 | 2007-07-19 | Microsoft Corporation | Compiler support for optimizing decomposed software transactional memory operations |
US20070130238A1 (en) * | 2005-12-07 | 2007-06-07 | Microsoft Corporation | Garbage collector support for transactional memory |
US8099726B2 (en) | 2005-12-07 | 2012-01-17 | Microsoft Corporation | Implementing strong atomicity in software transactional memory |
US7810085B2 (en) | 2005-12-07 | 2010-10-05 | Microsoft Corporation | Removal of unnecessary read-to-update upgrades in software transactional memory |
US20070136365A1 (en) * | 2005-12-07 | 2007-06-14 | Microsoft Corporation | Reducing unnecessary software transactional memory operations on newly-allocated data |
US20070136290A1 (en) * | 2005-12-07 | 2007-06-14 | Microsoft Corporation | Removal of unnecessary read-to-update upgrades in software transactional memory |
US8799882B2 (en) | 2005-12-07 | 2014-08-05 | Microsoft Corporation | Compiler support for optimizing decomposed software transactional memory operations |
US7747565B2 (en) * | 2005-12-07 | 2010-06-29 | Microsoft Corporation | Garbage collector support for transactional memory |
US7861237B2 (en) | 2005-12-07 | 2010-12-28 | Microsoft Corporation | Reducing unnecessary software transactional memory operations on newly-allocated data |
US8266609B2 (en) | 2005-12-07 | 2012-09-11 | Microsoft Corporation | Efficient placement of software transactional memory operations around procedure calls |
US20070136546A1 (en) * | 2005-12-09 | 2007-06-14 | International Business Machines Corporation | Use of Region-Oriented Memory Profiling to Detect Heap Fragmentation and Sparse Memory Utilization |
US7500077B2 (en) | 2005-12-09 | 2009-03-03 | International Business Machines Corporation | Use of region-oriented memory profiling to detect heap fragmentation and sparse memory utilization |
US20070136547A1 (en) * | 2005-12-13 | 2007-06-14 | Microsoft Corporation | Runtime detection for invalid use of zero-length memory allocations |
US7730453B2 (en) * | 2005-12-13 | 2010-06-01 | Microsoft Corporation | Runtime detection for invalid use of zero-length memory allocations |
US11132139B2 (en) | 2005-12-19 | 2021-09-28 | Commvault Systems, Inc. | Systems and methods for migrating components in a hierarchical storage network |
US20070220492A1 (en) * | 2006-03-16 | 2007-09-20 | Microsoft Corporation | Application verifier infrastructure and checks |
US7962901B2 (en) | 2006-04-17 | 2011-06-14 | Microsoft Corporation | Using dynamic analysis to improve model checking |
US20070250820A1 (en) * | 2006-04-20 | 2007-10-25 | Microsoft Corporation | Instruction level execution analysis for debugging software |
US20070255773A1 (en) * | 2006-04-28 | 2007-11-01 | Sap Ag | Method and system for inspecting memory leaks and analyzing contents of garbage collection files |
US8793289B2 (en) | 2006-04-28 | 2014-07-29 | Sap Ag | Method and system for detecting memory leaks and copying garbage collection files |
US7734666B2 (en) * | 2006-04-28 | 2010-06-08 | Sap Ag | Method and system for inspecting memory leaks and analyzing contents of garbage collection files |
US20100205230A1 (en) * | 2006-04-28 | 2010-08-12 | Sap Ag | Method and System for Inspecting Memory Leaks and Analyzing Contents of Garbage Collection Files |
US7953772B2 (en) * | 2006-04-28 | 2011-05-31 | Sap Ag | Method and system for inspecting memory leaks and analyzing contents of garbage collection files |
US20070255775A1 (en) * | 2006-04-28 | 2007-11-01 | Sap Ag | Method and system for inspecting memory leaks |
US8229979B2 (en) | 2006-04-28 | 2012-07-24 | Sap Ag | Method and system for inspecting memory leaks |
US7716646B2 (en) * | 2006-05-11 | 2010-05-11 | Rekha Kaushik | Loading a chain of processors from an XML file |
US20070266381A1 (en) * | 2006-05-11 | 2007-11-15 | Square D Company | Loading a chain of processors from an XML file |
US8122438B2 (en) | 2006-06-09 | 2012-02-21 | International Business Machines Corporation | Computer implemented method and system for accurate, efficient and adaptive calling context profiling |
US20070288908A1 (en) * | 2006-06-09 | 2007-12-13 | International Business Machines Corporation | Computer implemented method and system for accurate, efficient and adaptive calling context profiling |
US7818722B2 (en) * | 2006-06-09 | 2010-10-19 | International Business Machines Corporation | Computer implemented method and system for accurate, efficient and adaptive calling context profiling |
US20080288926A1 (en) * | 2006-06-09 | 2008-11-20 | International Business Machine Corporation | Computer Implemented Method and System for Accurate, Efficient and Adaptive Calling Context Profiling |
US20080005208A1 (en) * | 2006-06-20 | 2008-01-03 | Microsoft Corporation | Data structure path profiling |
US7926043B2 (en) * | 2006-06-20 | 2011-04-12 | Microsoft Corporation | Data structure path profiling |
US20080126625A1 (en) * | 2006-07-17 | 2008-05-29 | International Business Machines Corporation | Just-in-time buffer allocation for use in event completion style input/output models |
US7908591B1 (en) * | 2006-07-17 | 2011-03-15 | The Mathworks, Inc. | Memory profiling |
US7500079B2 (en) | 2006-07-31 | 2009-03-03 | Microsoft Corporation | Detection of memory leaks |
WO2008016493A1 (en) * | 2006-07-31 | 2008-02-07 | Microsoft Corporation | Detection of memory leaks |
US20080028178A1 (en) * | 2006-07-31 | 2008-01-31 | Microsoft Corporation | Detection of memory leaks |
US20080046673A1 (en) * | 2006-08-16 | 2008-02-21 | International Business Machines Corporation | Method and system to optimize java virtual machine performance |
US7475214B2 (en) | 2006-08-16 | 2009-01-06 | International Business Machines Corporation | Method and system to optimize java virtual machine performance |
US20090132869A1 (en) * | 2006-08-18 | 2009-05-21 | International Business Machines Corporation | Timeout request scheduling using grouping and nonsynchronized processing to enhance performance |
US7506218B2 (en) | 2006-08-18 | 2009-03-17 | International Business Machines Corporation | Timeout request scheduling using grouping and nonsynchronized processing to enhance performance |
US20080046785A1 (en) * | 2006-08-18 | 2008-02-21 | International Business Machines Corporation | Timeout request scheduling using grouping and nonsynchronized processing to enhance performance |
US9013494B2 (en) | 2006-12-07 | 2015-04-21 | Sony Computer Entertainment Inc. | Heads-up-display software development tool |
US7950003B1 (en) * | 2006-12-07 | 2011-05-24 | Sony Computer Entertainment Inc. | Heads-up-display software development tool for analyzing and optimizing computer software |
US20080148102A1 (en) * | 2006-12-15 | 2008-06-19 | International Business Machines Corporation | Method for enhancing debugging of runtime memory access errors by using an integrated visualization tool and a runtime memory error detection tool |
US8910119B2 (en) | 2006-12-29 | 2014-12-09 | Sap Ag | System and method for displaying component information of a trace |
US20080163177A1 (en) * | 2006-12-29 | 2008-07-03 | Sap Ag | System and method for displaying trace information |
US10353797B2 (en) * | 2006-12-29 | 2019-07-16 | International Business Machines Corporation | Using memory tracking data to inform a memory map tool |
US20080163178A1 (en) * | 2006-12-29 | 2008-07-03 | Ivanova Gorka J | System and method for displaying component information of a trace |
US11513874B2 (en) | 2007-01-07 | 2022-11-29 | Apple Inc. | Memory management methods and systems |
US10802895B2 (en) | 2007-01-07 | 2020-10-13 | Apple Inc. | Memory management methods and systems |
US10127090B2 (en) | 2007-01-07 | 2018-11-13 | Apple Inc. | Memory management methods and systems |
US8516198B2 (en) * | 2007-01-07 | 2013-08-20 | Apple Inc. | Memory management methods and systems |
US20110035554A1 (en) * | 2007-01-07 | 2011-02-10 | Matt Watson | Memory Management Methods and Systems |
US9535771B2 (en) | 2007-01-07 | 2017-01-03 | Apple Inc. | Memory management methods and systems |
US20080178189A1 (en) * | 2007-01-23 | 2008-07-24 | Piotr Findeisen | Efficient detection of sources of increasing memory consumption |
US8037477B2 (en) * | 2007-01-23 | 2011-10-11 | Hewlett-Packard Development Company, L.P. | Efficient detection of sources of increasing memory consumption |
US7870358B2 (en) | 2007-03-07 | 2011-01-11 | Lsi Corporation | Zero-penalty RAID controller memory leak detection and isolation method and system utilizing sequence numbers |
US20080222450A1 (en) * | 2007-03-07 | 2008-09-11 | Jinchao Yang | Zero-penalty RAID controller memory leak detection and isolation method and system utilizing sequence numbers |
US20080244531A1 (en) * | 2007-03-30 | 2008-10-02 | Sap Ag | Method and system for generating a hierarchical tree representing stack traces |
US7904493B2 (en) | 2007-03-30 | 2011-03-08 | Sap Ag | Method and system for object age detection in garbage collection heaps |
US8336033B2 (en) | 2007-03-30 | 2012-12-18 | Sap Ag | Method and system for generating a hierarchical tree representing stack traces |
US7971010B2 (en) * | 2007-03-30 | 2011-06-28 | Sap Ag | Mechanism for performing loitering trace of objects that cause memory leaks in a post-garbage collection heap |
US20080244546A1 (en) * | 2007-03-30 | 2008-10-02 | Sap Ag | Method and system for providing on-demand profiling infrastructure for profiling at virtual machines |
US8356286B2 (en) * | 2007-03-30 | 2013-01-15 | Sap Ag | Method and system for providing on-demand profiling infrastructure for profiling at virtual machines |
US8667471B2 (en) | 2007-03-30 | 2014-03-04 | Sap Ag | Method and system for customizing profiling sessions |
US20080243968A1 (en) * | 2007-03-30 | 2008-10-02 | Sap Ag | Method and system for object age detection in garbage collection heaps |
US8601469B2 (en) | 2007-03-30 | 2013-12-03 | Sap Ag | Method and system for customizing allocation statistics |
US20100095280A1 (en) * | 2007-03-30 | 2010-04-15 | Ralf Schmelter | Method and system for providing loitering trace in virtual machines |
US8522209B2 (en) | 2007-03-30 | 2013-08-27 | Sap Ag | Method and system for integrating profiling and debugging |
US8397111B2 (en) | 2007-05-25 | 2013-03-12 | International Business Machines Corporation | Software memory leak analysis using memory isolation |
US20080294936A1 (en) * | 2007-05-25 | 2008-11-27 | International Business Machines Corporation | Software memory leak analysis using memory isolation |
US7895483B2 (en) | 2007-05-25 | 2011-02-22 | International Business Machines Corporation | Software memory leak analysis using memory isolation |
US20110093748A1 (en) * | 2007-05-25 | 2011-04-21 | International Business Machines Corporation | Software Memory Leak Analysis Using Memory Isolation |
US20080301646A1 (en) * | 2007-05-29 | 2008-12-04 | Satish Chandra Gupta | Detecting Dangling Pointers and Memory Leaks Within Software |
US8245209B2 (en) * | 2007-05-29 | 2012-08-14 | International Business Machines Corporation | Detecting dangling pointers and memory leaks within software |
US8549503B2 (en) | 2007-05-29 | 2013-10-01 | International Business Machines Corporation | Detecting dangling pointers and memory leaks within software |
US8060869B1 (en) * | 2007-06-08 | 2011-11-15 | Oracle America, Inc. | Method and system for detecting memory problems in user programs |
US20080313406A1 (en) * | 2007-06-14 | 2008-12-18 | Kristian Hoegsberg Kristensen | Methods and systems for porting sysprof |
US8533686B2 (en) * | 2007-06-14 | 2013-09-10 | Red Hat, Inc. | Methods and systems for porting Sysprof |
US20090210750A1 (en) * | 2008-02-19 | 2009-08-20 | Sas Institute Inc. | Systems And Methods For Identifying Memory Leaks In A Computer System |
US8904359B2 (en) * | 2008-03-06 | 2014-12-02 | International Business Machines Corporation | On-demand monitoring of memory usage |
US20090228870A1 (en) * | 2008-03-06 | 2009-09-10 | International Business Machines Corporation | On-demand monitoring of memory usage |
US20090313743A1 (en) * | 2008-06-20 | 2009-12-24 | Craig Jason Hofmeyer | Pants with saggy pants control system |
US20090327373A1 (en) * | 2008-06-30 | 2009-12-31 | International Business Machines Corporation | Method for performing memory leak analysis inside a virtual machine |
US8032568B2 (en) * | 2008-06-30 | 2011-10-04 | International Business Machines Corporation | Method for performing memory leak analysis inside a virtual machine |
US20100017789A1 (en) * | 2008-07-15 | 2010-01-21 | International Business Machines Corporation | Selectively Obtaining Call Stack Information Based on Criteria |
US20100017583A1 (en) * | 2008-07-15 | 2010-01-21 | International Business Machines Corporation | Call Stack Sampling for a Multi-Processor System |
US9418005B2 (en) | 2008-07-15 | 2016-08-16 | International Business Machines Corporation | Managing garbage collection in a data processing system |
US8566795B2 (en) * | 2008-07-15 | 2013-10-22 | International Business Machines Corporation | Selectively obtaining call stack information based on criteria |
US20130311521A1 (en) * | 2008-10-24 | 2013-11-21 | Microsoft Corporation | Blob manipulation in an integrated structured storage system |
US8868624B2 (en) * | 2008-10-24 | 2014-10-21 | Microsoft Corporation | Blob manipulation in an integrated structured storage system |
US8024719B2 (en) * | 2008-11-03 | 2011-09-20 | Advanced Micro Devices, Inc. | Bounded hash table sorting in a dynamic program profiling system |
US20100114915A1 (en) * | 2008-11-03 | 2010-05-06 | Gorton Jr Richard C | Bounded hash table sorting in a dynamic program profiling system |
US8543987B2 (en) | 2009-05-05 | 2013-09-24 | International Business Machines Corporation | Method for simultaneous garbage collection and object allocation |
US20100287352A1 (en) * | 2009-05-05 | 2010-11-11 | International Business Machines Corporation | Virtual machine tool interface for tracking objects |
US8539452B2 (en) | 2009-05-05 | 2013-09-17 | International Business Machines Corporation | Virtual machine tool interface for tracking objects |
US8131785B1 (en) * | 2009-05-22 | 2012-03-06 | Adobe Systems Incorporated | Free space management for hierarchical data document |
US20110029822A1 (en) * | 2009-08-03 | 2011-02-03 | Sap Ag | Tracking of java objects during request processing |
US9015317B2 (en) | 2009-09-10 | 2015-04-21 | AppDynamics, Inc. | Conducting a diagnostic session for monitored business transactions |
US8938533B1 (en) * | 2009-09-10 | 2015-01-20 | AppDynamics Inc. | Automatic capture of diagnostic data based on transaction behavior learning |
US9369356B2 (en) | 2009-09-10 | 2016-06-14 | AppDynamics, Inc. | Conducting a diagnostic session for monitored business transactions |
US9037707B2 (en) | 2009-09-10 | 2015-05-19 | AppDynamics, Inc. | Propagating a diagnostic session for business transactions across multiple servers |
US9077610B2 (en) | 2009-09-10 | 2015-07-07 | AppDynamics, Inc. | Performing call stack sampling |
US8689180B2 (en) * | 2009-11-03 | 2014-04-01 | International Business Machines Corporation | Systems and methods for resource leak detection |
US20110107297A1 (en) * | 2009-11-03 | 2011-05-05 | International Business Machines Corporation | Systems and methods for resource leak detection |
US20110264712A1 (en) * | 2010-04-23 | 2011-10-27 | Tatu Ylonen Oy Ltd | Copy planning in a concurrent garbage collector |
US9223689B2 (en) * | 2010-05-14 | 2015-12-29 | Samsung Electronics Co., Ltd. | Apparatus and method for managing memory |
US20110283080A1 (en) * | 2010-05-14 | 2011-11-17 | Lim Geun-Sik | Apparatus and method for managing memory |
CN102298553A (en) * | 2010-05-14 | 2011-12-28 | 三星电子株式会社 | Apparatus and method for managing memory in consideration of user response time |
CN102298553B (en) * | 2010-05-14 | 2016-05-04 | 三星电子株式会社 | Come equipment and the method for diode-capacitor storage according to subscriber response time |
US9176783B2 (en) | 2010-05-24 | 2015-11-03 | International Business Machines Corporation | Idle transitions sampling with execution context |
US20110302183A1 (en) * | 2010-06-02 | 2011-12-08 | Oracle International Corporation | Tracking object fields using relocatable object watchpoints |
US8489652B2 (en) * | 2010-06-02 | 2013-07-16 | Oracle International Corporation | Tracking object fields using relocatable object watchpoints |
US20110307828A1 (en) * | 2010-06-11 | 2011-12-15 | Microsoft Corporation | Memory allocation visualization for unmanaged languages |
US8843684B2 (en) | 2010-06-11 | 2014-09-23 | International Business Machines Corporation | Performing call stack sampling by setting affinity of target thread to a current process to prevent target thread migration |
US8959442B2 (en) * | 2010-06-11 | 2015-02-17 | Microsoft Corporation | Memory allocation visualization for unmanaged languages |
US8499106B2 (en) * | 2010-06-24 | 2013-07-30 | Arm Limited | Buffering of a data stream |
US8799872B2 (en) | 2010-06-27 | 2014-08-05 | International Business Machines Corporation | Sampling with sample pacing |
US8874530B2 (en) * | 2010-09-29 | 2014-10-28 | Siemens Aktiengesellschaft | Method, computer readable medium and system for allocation and management of memory in runtime environments |
US20120078972A1 (en) * | 2010-09-29 | 2012-03-29 | Siemens Aktiengesellschaft | Method, Computer Readable Medium And System For Allocation And Management Of Memory In Runtime Environments |
US20120159455A1 (en) * | 2010-12-16 | 2012-06-21 | Ralf Schmelter | Rating interestingness of profiling data subsets |
US8839208B2 (en) * | 2010-12-16 | 2014-09-16 | Sap Ag | Rating interestingness of profiling data subsets |
US8799904B2 (en) | 2011-01-21 | 2014-08-05 | International Business Machines Corporation | Scalable system call stack sampling |
US8943276B2 (en) * | 2011-06-17 | 2015-01-27 | International Business Machines Corporation | Efficient discard scans |
US20120324173A1 (en) * | 2011-06-17 | 2012-12-20 | International Business Machines Corporation | Efficient discard scans |
US9075723B2 (en) * | 2011-06-17 | 2015-07-07 | International Business Machines Corporation | Efficient discard scans |
US20130219124A1 (en) * | 2011-06-17 | 2013-08-22 | International Business Machines Corporation | Efficient discard scans |
US10955127B2 (en) | 2011-07-20 | 2021-03-23 | Hgci, Inc. | Cooling a horticulture light fixture using an isolation chamber |
US11877551B2 (en) | 2011-07-20 | 2024-01-23 | Hgci, Inc. | Cooling a horticulture light fixture using an isolation chamber |
US9335038B2 (en) | 2011-07-20 | 2016-05-10 | Ip Holdings, Llc | Vertically disposed HID lamp fixture |
US10473317B2 (en) | 2011-07-20 | 2019-11-12 | Hgci, Inc. | Cooling a horticulture light fixture using an isolation chamber |
US9141510B2 (en) | 2011-08-24 | 2015-09-22 | Microsoft Technology Licensing, Llc | Memory allocation tracking |
US8918616B2 (en) | 2011-08-24 | 2014-12-23 | Microsoft Corporation | Memory allocation analysis |
US10963374B2 (en) | 2011-08-24 | 2021-03-30 | Microsoft Technology Licensing, Llc | Memory allocation analysis |
CN102968593A (en) * | 2011-08-31 | 2013-03-13 | 国际商业机器公司 | Method and system for positioning isolating point of application program under multi-tenant environment |
US20130086132A1 (en) * | 2011-10-03 | 2013-04-04 | Oracle International Corporation | Time-based object aging for generational garbage collectors |
US8825721B2 (en) * | 2011-10-03 | 2014-09-02 | Oracle International Corporation | Time-based object aging for generational garbage collectors |
US9152535B2 (en) * | 2011-11-02 | 2015-10-06 | International Business Machines Corporation | Programmatic identification of root method |
US20130111481A1 (en) * | 2011-11-02 | 2013-05-02 | International Business Machines Corporation | Programmatic identification of root method |
EP2657844A3 (en) * | 2011-11-18 | 2016-05-25 | Apple Inc. | Method for tracking memory usages of a data processing system |
CN103123604A (en) * | 2011-11-18 | 2013-05-29 | 苹果公司 | Method for tracking memory usages of a data processing system |
KR101357397B1 (en) | 2011-11-18 | 2014-02-03 | 애플 인크. | Method for tracking memory usages of a data processing system |
US8626993B2 (en) | 2011-11-18 | 2014-01-07 | Apple Inc. | Method for tracking memory usages of a data processing system |
US8949518B2 (en) | 2011-11-18 | 2015-02-03 | Apple Inc. | Method for tracking memory usages of a data processing system |
WO2013074201A1 (en) * | 2011-11-18 | 2013-05-23 | Apple Inc. | Method for tracking memory usages of a data processing system |
US8738877B2 (en) | 2011-12-14 | 2014-05-27 | Advance Micro Devices, Inc. | Processor with garbage-collection based classification of memory |
US9311598B1 (en) | 2012-02-02 | 2016-04-12 | AppDynamics, Inc. | Automatic capture of detailed analysis information for web application outliers with very low overhead |
US8972960B2 (en) | 2012-02-20 | 2015-03-03 | International Business Machines Corporation | Optimization of an application to reduce local memory usage |
US8843912B2 (en) * | 2012-02-20 | 2014-09-23 | International Business Machines Corporation | Optimization of an application to reduce local memory usage |
CN102662825A (en) * | 2012-02-22 | 2012-09-12 | 中国人民解放军国防科学技术大学 | Method for detecting memory leakage of heap operational program |
CN102662825B (en) * | 2012-02-22 | 2014-07-16 | 中国人民解放军国防科学技术大学 | Method for detecting memory leakage of heap operational program |
US9471378B2 (en) | 2012-05-31 | 2016-10-18 | Apple Inc. | Adaptive resource management of a data processing system |
USD826468S1 (en) | 2012-06-26 | 2018-08-21 | Hgci, Inc. | Light fixture |
USD802830S1 (en) | 2012-06-26 | 2017-11-14 | Ip Holdings, Llc | Light fixture |
WO2014036540A2 (en) * | 2012-08-31 | 2014-03-06 | Yume, Inc. | Network service system and method with off-heap caching |
US9021050B2 (en) | 2012-08-31 | 2015-04-28 | Yume, Inc. | Network service system and method with off-heap caching |
CN104620219B (en) * | 2012-08-31 | 2017-09-22 | 优米有限公司 | The network service system and method cached with out-pile |
WO2014036540A3 (en) * | 2012-08-31 | 2014-05-30 | Yume, Inc. | Network service system and method with off-heap caching |
CN104620219A (en) * | 2012-08-31 | 2015-05-13 | 优米有限公司 | Network service system and method with off-heap caching |
US20140068610A1 (en) * | 2012-09-06 | 2014-03-06 | Marek Baluch | Method and system for adjusting the operating memory used by a java virtual machine during runtime |
US9753846B2 (en) * | 2012-09-06 | 2017-09-05 | Red Hat, Inc. | Adjusting the operating memory used by a virtual machine during runtime |
TWI476585B (en) * | 2012-12-27 | 2015-03-11 | Chunghwa Telecom Co Ltd | System and method for two-phase memory leak detection |
US20140280364A1 (en) * | 2013-03-12 | 2014-09-18 | Oracle International Corporation | Disposal of rarely used member variables via shadow structures |
US9298751B2 (en) * | 2013-03-12 | 2016-03-29 | Oracle International Corporation | Disposal of rarely used member variables via shadow structures |
USD775760S1 (en) | 2013-03-27 | 2017-01-03 | Ip Holdings, Llc | Horticulture grow light housing |
USD771301S1 (en) | 2013-06-20 | 2016-11-08 | Ip Holdings, Llc | Horticulture grow light fixture |
USD802828S1 (en) | 2013-06-20 | 2017-11-14 | Ip Holdings, Llc | Horticulture grow light fixture |
USD843640S1 (en) | 2013-06-20 | 2019-03-19 | Hgci, Inc. | Horticulture grow light fixture |
USD796727S1 (en) | 2013-07-09 | 2017-09-05 | Ip Holdings, Llc | Horticulture grow light housing |
US9750199B2 (en) | 2013-07-18 | 2017-09-05 | Ip Holdings, Llc | Air cooled horticulture lighting fixture |
US9888633B1 (en) | 2013-07-18 | 2018-02-13 | Ip Holdings, Llc | Air cooled horticulture lighting fixture |
US9903578B1 (en) | 2013-07-18 | 2018-02-27 | Ip Holdings, Llc | Air cooled horticulture lighting fixture for a double ended high pressure sodium lamp |
US9752766B2 (en) | 2013-07-18 | 2017-09-05 | Ip Holdings, Llc | Air cooled horticulture lighting fixture |
US9710319B2 (en) * | 2013-10-24 | 2017-07-18 | Fujitsu Limited | Information processing apparatus and information collection method |
US20150121151A1 (en) * | 2013-10-24 | 2015-04-30 | Fujitsu Limited | Information processing apparatus and information collection method |
US9311220B1 (en) * | 2013-12-31 | 2016-04-12 | Google Inc. | System to uncover root cause of non-deterministic (flaky) tests |
USD775406S1 (en) | 2014-02-24 | 2016-12-27 | Ip Holdings, Llc | Horticulture grow light reflector |
US20150269052A1 (en) * | 2014-03-21 | 2015-09-24 | Marvell World Trade Ltd | Method and apparatus for supporting performance analysis |
US9558096B2 (en) * | 2014-03-21 | 2017-01-31 | Marvell World Trade Ltd. | Method and apparatus for supporting performance analysis |
US10754766B2 (en) * | 2014-03-21 | 2020-08-25 | Red Hat Israel, Ltd. | Indirect resource management |
US20150269066A1 (en) * | 2014-03-21 | 2015-09-24 | Red Hat Israel, Ltd. | Indirect resource management |
USD854229S1 (en) | 2014-06-11 | 2019-07-16 | Hgci, Inc. | Sealed optics air cooled grow light |
USD802826S1 (en) | 2014-06-11 | 2017-11-14 | Ip Holdings, Llc | Sealed optics air cooled grow light |
USD797353S1 (en) | 2014-06-11 | 2017-09-12 | Ip Holdings, Llc | Sealed optics air cooled grow light |
USD825826S1 (en) | 2014-06-11 | 2018-08-14 | Hgci, Inc. | Sealed optics air cooled grow light |
USD792635S1 (en) | 2014-08-07 | 2017-07-18 | Ip Holdings, Llc | Horticulture grow light |
USD940381S1 (en) | 2014-09-11 | 2022-01-04 | Hgci, Inc. | Light fixture |
USD837442S1 (en) | 2014-09-11 | 2019-01-01 | Hgci, Inc. | Light fixture |
USD793616S1 (en) | 2014-09-11 | 2017-08-01 | Ip Holdings, Llc | Light fixture |
USD769514S1 (en) | 2014-10-22 | 2016-10-18 | Ip Holdings, Llc | Horticulture grow light |
USD783887S1 (en) | 2014-12-11 | 2017-04-11 | Ip Holdings, Llc | Horticulture grow light |
USD814687S1 (en) | 2015-01-08 | 2018-04-03 | Ip Holdings, Llc | Light fixture |
US9710379B2 (en) * | 2015-02-27 | 2017-07-18 | International Business Machines Corporation | Tuning utilization and heap memory size for real-time garbage collection |
US20160253103A1 (en) * | 2015-02-27 | 2016-09-01 | International Business Machines Corporation | Tuning utilization and heap memory size for real-time garbage collection |
USD770079S1 (en) | 2015-04-02 | 2016-10-25 | Ip Holdings, Llc | Light fixture |
USD773107S1 (en) | 2015-04-13 | 2016-11-29 | Ip Holdings, Llc | Horticulture grow light |
USD804708S1 (en) | 2015-04-15 | 2017-12-05 | Ip Holding, Llc | Light fixture |
USD786488S1 (en) | 2015-04-15 | 2017-05-09 | Ip Holdings, Llc | Light fixture |
USD769513S1 (en) | 2015-04-15 | 2016-10-18 | Ip Holdings, Llc | Light fixture |
USD804709S1 (en) | 2015-04-15 | 2017-12-05 | Ip Holdings, Llc | Light fixture |
USD770670S1 (en) | 2015-06-24 | 2016-11-01 | Ip Holdings, Llc | Horticulture grow light |
USD826469S1 (en) | 2015-06-24 | 2018-08-21 | Hgci, Inc. | Horticulture grow light |
USD781492S1 (en) | 2015-06-24 | 2017-03-14 | Ip Holdings, Llc | Horticulture grow light |
USD802829S1 (en) | 2015-06-24 | 2017-11-14 | Ip Holdings, Llc | Horticulture grow light |
US11301333B2 (en) | 2015-06-26 | 2022-04-12 | Commvault Systems, Inc. | Incrementally accumulating in-process performance data and hierarchical reporting thereof for a data stream in a secondary copy operation |
US11474896B2 (en) | 2015-10-29 | 2022-10-18 | Commvault Systems, Inc. | Monitoring, diagnosing, and repairing a management database in a data storage management system |
US11301430B2 (en) | 2015-10-30 | 2022-04-12 | Netapp, Inc. | Hybrid model of fine-grained locking and data partitioning |
US11216439B2 (en) | 2015-10-30 | 2022-01-04 | Netapp, Inc. | Auto-expiring locks based on object stamping |
US10417189B2 (en) | 2015-10-30 | 2019-09-17 | Netapp, Inc. | Hybrid model of fine-grained locking and data partitioning |
US10452633B2 (en) * | 2015-10-30 | 2019-10-22 | Netapp, Inc. | Auto-expiring locks based on object stamping |
US20170124123A1 (en) * | 2015-10-30 | 2017-05-04 | Netapp, Inc. | Auto-expiring locks based on object stamping |
USD825827S1 (en) | 2016-01-05 | 2018-08-14 | Hgci, Inc. | Light fixture |
USD804706S1 (en) | 2016-01-05 | 2017-12-05 | Ip Holdings, Llc | Light fixture |
USD804707S1 (en) | 2016-01-07 | 2017-12-05 | Ip Holding, Llc | Light fixture |
USD825828S1 (en) | 2016-01-07 | 2018-08-14 | Hgci, Inc. | Light fixture |
US9612808B1 (en) * | 2016-02-25 | 2017-04-04 | International Business Machines Corporation | Memory use for string object creation |
US10706101B2 (en) | 2016-04-14 | 2020-07-07 | Advanced Micro Devices, Inc. | Bucketized hash tables with remap entries |
USD796728S1 (en) | 2016-06-06 | 2017-09-05 | Ip Holdings, Llc | Light fixture |
USD951525S1 (en) | 2016-06-06 | 2022-05-10 | Hgci, Inc. | Light fixture |
USD839471S1 (en) | 2016-06-06 | 2019-01-29 | Hgci, Inc. | Light fixture |
US20180024909A1 (en) * | 2016-07-25 | 2018-01-25 | International Business Machines Corporation | Monitoring growth of memory buffers in logging and dynamically adapting quantity and detail of logging |
USD873467S1 (en) | 2016-08-31 | 2020-01-21 | Hgci, Inc. | Light fixture |
USD804078S1 (en) | 2016-08-31 | 2017-11-28 | Ip Holdings, Llc | Light fixture |
USD851804S1 (en) | 2016-08-31 | 2019-06-18 | Hgci, Inc. | Light fixture |
USD804079S1 (en) | 2016-08-31 | 2017-11-28 | Ip Holdings, Llc | Light fixture |
USD826467S1 (en) | 2016-11-01 | 2018-08-21 | Hgci, Inc. | Light fixture |
USD797350S1 (en) | 2016-11-01 | 2017-09-12 | Ip Holdings, Llc | Light fixture |
USD822882S1 (en) | 2017-05-17 | 2018-07-10 | Ip Holdings, Llc | Horticulture grow light |
USD843049S1 (en) | 2017-09-14 | 2019-03-12 | Hgci, Inc. | Horticulture grow light |
USD950833S1 (en) | 2017-09-14 | 2022-05-03 | Hgci, Inc. | Horticulture grow light |
USD842532S1 (en) | 2017-10-25 | 2019-03-05 | Hgci, Inc. | Light fixture |
US11138034B2 (en) * | 2017-10-26 | 2021-10-05 | Huawei Technologies Co., Ltd. | Method and apparatus for collecting information, and method and apparatus for releasing memory |
USD871654S1 (en) | 2017-10-30 | 2019-12-31 | Hgci, Inc. | Light fixture |
USD996696S1 (en) | 2017-10-30 | 2023-08-22 | Hgci, Inc. | Light fixture |
USD848663S1 (en) | 2017-11-03 | 2019-05-14 | Hgci, Inc. | Light fixture |
USD985181S1 (en) | 2017-11-03 | 2023-05-02 | Hgci, Inc. | Light fixture |
USD995886S1 (en) | 2017-11-07 | 2023-08-15 | Hgci, Inc. | Light fixture |
USD848664S1 (en) | 2017-11-07 | 2019-05-14 | Hgci, Inc. | Light fixture |
USD994961S1 (en) | 2017-11-08 | 2023-08-08 | Hgci, Inc. | Horticulture grow light |
USD942067S1 (en) | 2017-11-08 | 2022-01-25 | Hgci, Inc. | Horticulture grow light |
USD848665S1 (en) | 2017-11-08 | 2019-05-14 | Hgci, Inc. | Horticulture grow light |
US11815993B2 (en) | 2018-01-11 | 2023-11-14 | Commvault Systems, Inc. | Remedial action based on maintaining process awareness in data storage management |
US11200110B2 (en) | 2018-01-11 | 2021-12-14 | Commvault Systems, Inc. | Remedial action based on maintaining process awareness in data storage management |
US10831591B2 (en) | 2018-01-11 | 2020-11-10 | Commvault Systems, Inc. | Remedial action based on maintaining process awareness in data storage management |
US10552185B2 (en) * | 2018-05-24 | 2020-02-04 | International Business Machines Corporation | Lightweight and precise value profiling |
US11061704B2 (en) | 2018-05-24 | 2021-07-13 | International Business Machines Corporation | Lightweight and precise value profiling |
US10761965B2 (en) * | 2018-09-28 | 2020-09-01 | Atlassian Pty Ltd. | Detecting method calls based on stack trace data |
US10719362B2 (en) * | 2018-10-10 | 2020-07-21 | Oracle International Corporation | Managing multiple isolated execution contexts in a single process |
US11941275B2 (en) | 2018-12-14 | 2024-03-26 | Commvault Systems, Inc. | Disk usage growth prediction system |
US11449253B2 (en) | 2018-12-14 | 2022-09-20 | Commvault Systems, Inc. | Disk usage growth prediction system |
WO2020242655A1 (en) * | 2019-05-29 | 2020-12-03 | Microsoft Technology Licensing, Llc | Exposing memory-backed objects as queryable memory resources |
US11442842B2 (en) | 2019-05-29 | 2022-09-13 | Microsoft Technology Licensing, Llc | Exposing memory-backed objects as queryable memory resources |
US20220114092A1 (en) * | 2020-10-13 | 2022-04-14 | Dynatrace Llc | Method And System For Estimating Garbage Collection Suspension Contributions Of Individual Allocation Sites |
US11983077B2 (en) | 2022-02-24 | 2024-05-14 | Commvault Systems, Inc. | Incrementally accumulating in-process performance data and hierarchical reporting thereof for a data stream in a secondary copy operation |
CN117435440A (en) * | 2023-12-20 | 2024-01-23 | 麒麟软件有限公司 | Dynamic analysis method and system for program heap space |
CN117435440B (en) * | 2023-12-20 | 2024-04-05 | 麒麟软件有限公司 | Dynamic analysis method and system for program heap space |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6658652B1 (en) | Method and system for shadow heap memory leak detection and other heap analysis in an object-oriented environment during real-time trace processing | |
US6560773B1 (en) | Method and system for memory leak detection in an object-oriented environment during real-time trace processing | |
US7389497B1 (en) | Method and system for tracing profiling information using per thread metric variables with reused kernel threads | |
US6662358B1 (en) | Minimizing profiling-related perturbation using periodic contextual information | |
US6539339B1 (en) | Method and system for maintaining thread-relative metrics for trace data adjusted for thread switches | |
US6598012B1 (en) | Method and system for compensating for output overhead in trace date using trace record information | |
US6513155B1 (en) | Method and system for merging event-based data and sampled data into postprocessed trace output | |
US6904594B1 (en) | Method and system for apportioning changes in metric variables in an symmetric multiprocessor (SMP) environment | |
US6735758B1 (en) | Method and system for SMP profiling using synchronized or nonsynchronized metric variables with support across multiple systems | |
US6507805B1 (en) | Method and system for compensating for instrumentation overhead in trace data by detecting minimum event times | |
US6349406B1 (en) | Method and system for compensating for instrumentation overhead in trace data by computing average minimum event times | |
US6728955B1 (en) | Processing events during profiling of an instrumented program | |
US6546548B1 (en) | Method and system for compensating for output overhead in trace data using initial calibration information | |
US6651243B1 (en) | Method and system for periodic trace sampling for real-time generation of segments of call stack trees | |
US6604210B1 (en) | Method and system for detecting and recovering from in trace data | |
US6732357B1 (en) | Determining and compensating for temporal overhead in trace record generation and processing | |
US6751789B1 (en) | Method and system for periodic trace sampling for real-time generation of segments of call stack trees augmented with call stack position determination | |
US8280683B2 (en) | Probabilistic framework for the highly efficient correlation of call chains with hardware events | |
US7111294B2 (en) | Thread-specific heaps | |
US7114150B2 (en) | Apparatus and method for dynamic instrumenting of code to minimize system perturbation | |
Dieckmann et al. | A study of the allocation behavior of the SPECjvm98 Java benchmarks | |
US7475214B2 (en) | Method and system to optimize java virtual machine performance | |
US6338159B1 (en) | System and method for providing trace information | |
US8959490B2 (en) | Optimizing heap memory usage | |
US20020120428A1 (en) | Topological, on-the-fly classification of objects into a global set and local sets |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:ALEXANDER, WILLIAM PRESTON III;LEVINE, FRANK ELIOT;REYNOLDS, WILLIAM ROBERT;AND OTHERS;REEL/FRAME:010870/0627;SIGNING DATES FROM 20000531 TO 20000606 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
CC | Certificate of correction | ||
FPAY | Fee payment |
Year of fee payment: 4 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026664/0866Effective date: 20110503 |
|
FPAY | Fee payment |
Year of fee payment: 12 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |