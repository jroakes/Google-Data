This application is a divisional of U.S. application Ser. No. 11/043,438, filed on Jan. 25, 2005, entitled “Information Retrieval System For Archiving Multiple Document Versions”, now U.S. Pat. No. 7,702,618; which, in turn, is related to U.S. application Ser. No. 10/900,021 filed on Jul. 26, 2004, entitled “Phrase-Based Indexing in an Information Retrieval System”, now U.S. Pat. No. 7,580,921, both of which are co-owned and incorporated by reference herein.
FIELD OF THE INVENTION
The present invention relates to an information retrieval system for indexing, searching, and classifying documents in a large scale corpus, such as the Internet.
BACKGROUND OF THE INVENTION
Information retrieval systems, generally called search engines, are now an essential tool for finding information in large scale, diverse, and growing corpuses such as the Internet. Generally, search engines create an index that relates documents (or “pages”) to the individual words present in each document. A document is retrieved in response to a query containing a number of query terms, typically based on having some number of query terms present in the document. The retrieved documents are then ranked according to other statistical measures, such as frequency of occurrence of the query terms, host domain, link analysis, and the like. The retrieved documents are then presented to the user, typically in their ranked order, and without any further grouping or imposed hierarchy. In some cases, a selected portion of a text of a document is presented to provide the user with a glimpse of the document's content.
Direct “Boolean” matching of query terms has well known limitations, and in particular does not identify documents that do not have the query terms, but have related words. For example, in a typical Boolean system, a search on “Australian Shepherds” would not return documents about other herding dogs such as Border Collies that do not have the exact query terms. Rather, such a system is likely to also retrieve and highly rank documents that are about Australia (and have nothing to do with dogs), and documents about “shepherds” generally.
The problem here is that conventional systems index documents based on individual terms, rather than on concepts. Concepts are often expressed in phrases, such as “Australian Shepherd,” “President of the United States,” or “Sundance Film Festival”. At best, some prior systems will index documents with respect to a predetermined and very limited set of ‘known’ phrases, which are typically selected by a human operator. Indexing of phrases is typically avoided because of the perceived computational and memory requirements to identify all possible phrases of say three, four, or five or more words. For example, on the assumption that any five words could constitute a phrase, and a large corpus would have at least 200,000 unique terms, there would approximately 3.2×1026 possible phrases, clearly more than any existing system could store in memory or otherwise programmatically manipulate. A further problem is that phrases continually enter and leave the lexicon in terms of their usage, much more frequently than new individual words are invented. New phrases are always being generated, from sources such technology, arts, world events, and law. Other phrases will decline in usage over time.
Some existing information retrieval systems attempt to provide retrieval of concepts by using co-occurrence patterns of individual words. In these systems a search on one word, such as “President” will also retrieve documents that have other words that frequently appear with “President”, such as “White” and “House.” While this approach may produce search results having documents that are conceptually related at the level of individual words, it does not typically capture topical relationships that inhere between co-occurring phrases.
Accordingly, there is a need for an information retrieval system and methodology that can comprehensively identify phrases in a large scale corpus, index documents according to phrases, search and rank documents in accordance with their phrases, and provide additional clustering and descriptive information about the documents.
Another problem with conventional information retrieval systems is that they can only index a relatively small portion of the documents available on the Internet. It is currently estimated that there are over 200 billion pages on the Internet today. However, even the best search engines index only 6 to 8 billion pages, thereby missing the majority of available pages. There are several reasons for the limited indexing capability of existing systems. Most significantly, typical systems rely on a variation of an inverted index that maintains for every term (as discussed above) a list of every page on which the term occurs, along with position information identifying the exact position of each occurrence of the term on the page. The combination of indexing individual terms and indexing positional information requires a very large storage system.
A further problem with many information retrieval systems used for searching the Internet is their inability to archive pages that change over time. Conventionally, most Internet search engines only store the relevance information for a current instance (or version) of a given page, and update this information each time the page is re-indexed. As a result, a given search only returns the current versions of pages that satisfy the query. Users are unable as a result to search for prior instances of pages, or pages that were current in a specific date interval. Also, the search engines likewise do not use version or date related relevance information when evaluating search queries or presenting search results.
Accordingly, it is desirable to provide an information retrieval system that can effectively index tens of billions, and eventually over 100 billion pages of content, without the substantial storage requirements of existing systems. Further, it is desirable to provide an information retrieval system that can index and retrieve both current and prior instances of documents and pages.
SUMMARY OF THE INVENTION
An information retrieval system and methodology uses phrases to index, search, rank, and describe documents in the document collection. The system is adapted to identify phrases that have sufficiently frequent and/or distinguished usage in the document collection to indicate that they are “valid” or “good” phrases. In this manner multiple word phrases, for example phrases of four, five, or more terms, can be identified. This avoids the problem of having to identify and index every possible phrase resulting from the all of the possible sequences of a given number of words.
The system is further adapted to identify phrases that are related to each other, based on a phrase's ability to predict the presence of other phrases in a document. More specifically, a prediction measure is used that relates the actual co-occurrence rate of two phrases to an expected co-occurrence rate of the two phrases. Information gain, as the ratio of actual co-occurrence rate to expected co-occurrence rate, is one such prediction measure. Two phrases are related where the prediction measure exceeds a predetermined threshold. In that case, the second phrase has significant information gain with respect to the first phrase. Semantically, related phrases will be those that are commonly used to discuss or describe a given topic or concept, such as “President of the United States” and “White House.” For a given phrase, the related phrases can be ordered according to their relevance or significance based on their respective prediction measures.
An information retrieval system indexes documents in the document collection by the valid or good phrases. For each phrase, a posting list identifies the documents that contain the phrase. In addition, for a given phrase, a second list, vector, or other structure is used to store data indicating which of the related phrases of the given phrase are also present in each document containing the given phrase. In this manner, the system can readily identify not only which documents contain which phrases in response to a search query, but which documents also contain phrases that are related to query phrases, and thus more likely to be specifically about the topics or concepts expressed in the query phrases.
The information retrieval system is also adapted to use the phrases when searching for documents in response to a query. The query is processed to identify any phrases that are present in the query, so as to retrieve the associated posting lists for the query phrases, and the related phrase information. In addition, in some instances a user may enter an incomplete phrase in a search query, such as “President of the”. Incomplete phrases such as these may be identified and replaced by a phrase extension, such as “President of the United States.” This helps ensure that the user's most likely search is in fact executed.
Another aspect of the present invention is the capability to index an extremely large number of documents, on the order of one hundred billion or more, using a multiple index structure. In one embodiment, a primary and a secondary index are provided. The primary index stores index data for phrases, with a limited number of documents indexed for each phrase. For a particular phrase, the index data for the documents is stored in rank order of the documents' relevance to the phrase. This storage arrangement is preferably both logical and physical (i.e., how the data is stored on the underlying storage devices). Where more than the limited number of documents include a particular phrase, the index data for these remaining documents is stored in the secondary index, but here ordered by document number instead of relevance rank, and retrieved, for example, using scatter-gather type methods.
For example, the primary index may be structured to store 32k document entries for each phrase, and the secondary index may be structured to store any further documents entries for further documents beyond the 32k that contain the phrase. To obtain the document entries for the primary index, the documents are scored for relevance with respect to the phrase, and rank ordered by their relevance score. Alternatively, the documents may be rank ordered by various document features useful for relevance analysis. The rank ordering for the document entries is used to partition the entries between the primary index and the secondary index. Where there are less than the limited number of documents that contain the phrase, then all of the entries are stored in the primary index, again in relevance rank order. The indexing arrangement enables a ten to fifteen-fold increase in storage capacity for the index, and because of the optimized index information, a ten fold increase in server performance.
Another aspect of the present invention is the capability to index multiple versions or instances of documents for archiving. This capability enables a user to search for documents within a specific range of dates, and enables date or version related relevance information to be used in evaluating documents in response to a search query and in organizing search results. In one embodiment, a document is associated with one or more date ranges. Each date range is associated with relevance data derived from the document and deemed valid for the document during the date range. A current date range is associated with a current instance of the document, from the date that the document was most recently indexed. When a document is encountered during an indexing pass, it is compared with a previous version to determine if the document has changed. If the document has not changed, then indexed relevance data is maintained. If the document has changed, then the current date range for the document is closed, and the document is re-indexed, and a new current date range is established, and associated with the current relevance data.
The present invention has further embodiments in system and software architectures, computer program products and computer implemented methods, and computer generated user interfaces and presentations.
The foregoing are just some of the features of an information retrieval system and methodology based on phrases. Those of skill in the art of information retrieval will appreciate the flexibility of generality of the phrase information allows for a large variety of uses and applications in indexing, document annotation, searching, ranking, and other areas of document analysis and processing.
BRIEF DESCRIPTION OF THE DRAWINGS
FIG. 1 is block diagram of the software architecture of one embodiment of the present invention.
FIG. 2 illustrates a method of identifying phrases in documents.
FIG. 3 illustrates a document with a phrase window and a secondary window.
FIG. 4 illustrates a method of identifying related phrases.
FIG. 5 illustrates a method of indexing documents for related phrases.
FIG. 6 illustrates a method of retrieving documents based on phrases.
FIG. 7 illustrates a method of providing an archival index.
FIG. 8 illustrates dates and date ranges referenced in an archival index.
The figures depict a preferred embodiment of the present invention for purposes of illustration only. One skilled in the art will readily recognize from the following discussion that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles of the invention described herein.
DETAILED DESCRIPTION OF THE INVENTION
I. System Overview
Referring now to FIG. 1, there is shown the software architecture of an embodiment of a search system 100 in accordance with one embodiment of present invention. In this embodiment, the system includes a indexing system 110, a search system 120, a presentation system 130, and a front end server 140.
The indexing system 110 is responsible for identifying phrases in documents, and indexing documents according to their phrases, by accessing various websites 190 and other document collections. The front end server 140 receives queries from a user of a client 170, and provides those queries to the search system 120. The search system 120 is responsible for searching for documents relevant to the search query (search results), including identifying any phrases in the search query, and then ranking the documents in the search results using the presence of phrases to influence the ranking order. The search system 120 provides the search results to the presentation system 130. The presentation system 130 is responsible for modifying the search results including removing near duplicate documents, and generating topical descriptions of documents, and providing the modified search results back to the front end server 140, which provides the results to the client 170. The system 100 further includes a primary index 150 and a secondary index 152 that stores the indexing information pertaining to documents, and a phrase data store 160 that stores phrases, and related statistical information. The primary index 150 is distributed across a number of primary servers 1 . . . M1, and the secondary index 152 is likewise distributed across a number of secondary servers 1 . . . M2.
In the context of this application, “documents” are understood to be any type of media that can be indexed and retrieved by a search engine, including web documents, images, multimedia files, text documents, PDFs or other image formatted files, and so forth. A document may have one or more pages, partitions, segments or other components, as appropriate to its content and type. Equivalently a document may be referred to as a “page,” as commonly used to refer to documents on the Internet. No limitation as to the scope of the invention is implied by the use of the generic term “documents.” The search system 100 operates over a large corpus of documents, such as the Internet and World Wide Web, but can likewise be used in more limited collections, such as for the document collections of a library or private enterprises. In either context, it will be appreciated that the documents are typically distributed across many different computer systems and sites. Without loss of generality then, the documents generally, regardless of format or location (e.g., which website or database) will be collectively referred to as a corpus or document collection. Each document has an associated identifier that uniquely identifies the document; the identifier is preferably a URL, but other types of identifiers (e.g., document numbers) may be used as well. In this disclosure, the use of URLs to identify documents is assumed.
II. Indexing System
In one embodiment, the indexing system 110 provides three primary functional operations: 1) identification of phrases and related phrases, 2) indexing of documents with respect to phrases, and 3) generation and maintenance of a phrase-based taxonomy. Those of skill in the art will appreciate that the indexing system 110 will perform other functions as well in support of conventional indexing functions, and thus these other operations are not further described herein. The indexing system 110 operates on the primary index 150 and secondary index 152 and data repository 160 of phrase data. These data repositories are further described below.
1. Phrase Identification
The phrase identification operation of the indexing system 110 identifies “good” and “bad” phrases in the document collection that are useful to indexing and searching documents. In one aspect, good phrases are phrases that tend to occur in more than a certain percentage of documents in the document collection, and/or are indicated as having a distinguished appearance in such documents, such as delimited by markup tags or other morphological, format, or grammatical markers. Another aspect of good phrases is that they are predictive of other good phrases, and are not merely sequences of words that appear in the lexicon. For example, the phrase “President of the United States” is a phrase that predicts other phrases such as “George Bush” and “Bill Clinton.” However, other phrases are not predictive, such as “fell down the stairs” or “top of the morning,” “out of the blue,” since idioms and colloquisms like these tend to appear with many other different and unrelated phrases. Thus, the phrase identification phase determines which phrases are good phrases and which are bad (i.e., lacking in predictive power).
Referring to now FIG. 2, the phrase identification process has the following functional stages:
200: Collect possible and good phrases, along with frequency and co-occurrence statistics of the phrases.
202: Classify possible phrases to either good or bad phrases based on frequency statistics.
204: Prune good phrase list based on a predictive measure derived from the co-occurrence statistics.
Each of these stages will now be described in further detail.
The first stage 200 is a process by which the indexing system 110 crawls a set of documents in the document collection, making repeated partitions of the document collection over time. One partition is processed per pass. The number of documents crawled per pass can vary, and is preferably about 1,000,000 per partition. It is preferred that only previously uncrawled documents are processed in each partition, until all documents have been processed, or some other termination criteria is met. In practice, the crawling continues as new documents are being continually added to the document collection. The following steps are taken by the indexing system 110 for each document that is crawled.
Traverse the words of the document with a phrase window length of n, where n is a desired maximum phrase length. The length of the window will typically be at least 2, and preferably 4 or 5 terms (words). Preferably phrases include all words in the phrase window, including what would otherwise be characterized as stop words, such as “a”, “the,” and so forth. A phrase window may be terminated by an end of line, a paragraph return, a markup tag, or other indicia of a change in content or format.
FIG. 3 illustrates a portion of a document 300 during a traversal, showing the phrase window 302 starting at the word “stock” and extending 5 words to the right. The first word in the window 302 is candidate phrase i, and the each of the sequences i+1, i+2, i+3, i+4, and i+5 is likewise a candidate phrase. Thus, in this example, the candidate phrases are: “stock”, “stock dogs”, “stock dogs for”, “stock dogs for the”, “stock dogs for the Basque”, and “stock dogs for the Basque shepherds”.
In each phrase window 302, each candidate phrase is checked in turn to determine if it is already present in the good phrase list 208 or the possible phrase list 206. If the candidate phrase is not present in either the good phrase list 208 or the possible phrase list 206, then the candidate has already been determined to be “bad” and is skipped.
If the candidate phrase is in the good phrase list 208, as entry gj, then the index 150 entry for phrase gj is updated to include the document (e.g., its URL or other document identifier), to indicate that this candidate phrase gj appears in the current document. An entry in the index 150 for a phrase gj (or a term) is referred to as the posting list of the phrase gj. The posting list includes a list of documents d (by their document identifiers, e.g. a document number, or alternatively a URL) in which the phrase occurs. In one embodiment, the document number is derived by a one-way hash of the URL, using, for example, MD5.
In addition, the co-occurrence matrix 212 is updated, as further explained below. In the very first pass, the good and bad lists will be empty, and thus, most phrases will tend to be added to the possible phrase list 206.
If the candidate phrase is not in the good phrase list 208 then it is added to the possible phrase list 206, unless it is already present therein. Each entry p on the possible phrase list 206 has three associated counts:
P(p): Number of documents on which the possible phrase appears;
S(p): Number of all instances of the possible phrase; and
M(p): Number of interesting instances of the possible phrase. An instance of a possible phrase is “interesting” where the possible phrase is distinguished from neighboring content in the document by grammatical or format markers, for example by being in boldface, or underline, or as anchor text in a hyperlink, or in quotation marks. These (and other) distinguishing appearances are indicated by various HTML markup language tags and grammatical markers. These statistics are maintained for a phrase when it is placed on the good phrase list 208.
In addition the various lists, a co-occurrence matrix 212 (G) for the good phrases is maintained. The matrix G has a dimension of m×m, where m is the number of good phrases. Each entry G(j, k) in the matrix represents a pair of good phrases (gj, gk). The co-occurrence matrix 212 logically (though not necessarily physically) maintains three separate counts for each pair (gj, gk) of good phrases with respect to a secondary window 304 that is centered at the current word i, and extends +/−h words. In one embodiment, such as illustrated in FIG. 3, the secondary window 304 is 30 words. The co-occurrence matrix 212 thus maintains:
R(j,k): Raw Co-occurrence count. The number of times that phrase gj appears in a secondary window 304 with phrase gk;
D(j,k): Disjunctive Interesting count. The number of times that either phrase gj or phrase gk appears as distinguished text in a secondary window; and
C(j,k): Conjunctive Interesting count: the number of times that both gj and phrase gk appear as distinguished text in a secondary window. The use of the conjunctive interesting count is particularly beneficial to avoid the circumstance where a phrase (e.g., a copyright notice) appears frequently in sidebars, footers, or headers, and thus is not actually predictive of other text.
Referring to the example of FIG. 3, assume that the “stock dogs” is on the good phrase list 208, as well as the phrases “Australian Shepherd” and “Australian Shepard Club of America”. Both of these latter phrases appear within the secondary window 304 around the current phrase “stock dogs”. However, the phrase “Australian Shepherd Club of America” appears as anchor text for a hyperlink (indicated by the underline) to website. Thus the raw co-occurrence count for the pair {“stock dogs”, “Australian Shepherd”} is incremented, and the raw occurrence count and the disjunctive interesting count for {“stock dogs”, “Australian Shepherd Club of America”} are both incremented because the latter appears as distinguished text.
The process of traversing each document with both the sequence window 302 and the secondary window 304, is repeated for each document in the partition.
Once the documents in the partition have been traversed, the next stage of the indexing operation is to update 202 the good phrase list 208 from the possible phrase list 206. A possible phrase p on the possible phrase list 206 is moved to the good phrase list 208 if the frequency of appearance of the phrase and the number of documents that the phrase appears in indicates that it has sufficient usage as semantically meaningful phrase.
In one embodiment, this is tested as follows. A possible phrase p is removed from the possible phrase list 206 and placed on the good phrase list 208 if:
a) P(p)>10 and S(p)>20 (the number of documents containing phrase p is more than 10, and the number of occurrences of phrase p is more then 20); or
b) M(p)>5 (the number of interesting instances of phrase p is more than 5).
These thresholds are scaled by the number of documents in the partition; for example if 2,000,000 documents are crawled in a partition, then the thresholds are approximately doubled. Of course, those of skill in the art will appreciate that the specific values of the thresholds, or the logic of testing them, can be varied as desired.
If a phrase p does not qualify for the good phrase list 208, then it is checked for qualification for being a bad phrase. A phrase p is a bad phrase if:
a) number of documents containing phrase, P(p)<2; and
b) number of interesting instances of phrase, M(p)=0.
These conditions indicate that the phrase is both infrequent, and not used as indicative of significant content and again these thresholds may be scaled per number of documents in the partition.
It should be noted that the good phrase list 208 will naturally include individual words as phrases, in addition to multi-word phrases, as described above. This is because each the first word in the phrase window 302 is always a candidate phrase, and the appropriate instance counts will be accumulated. Thus, the indexing system 110 can automatically index both individual words (i.e., phrases with a single word) and multiple word phrases. The good phrase list 208 will also be considerably shorter than the theoretical maximum based on all possible combinations of m phrases. In typical embodiment, the good phrase list 208 will include about 6.5×105 phrases. A list of bad phrases is not necessary to store, as the system need only keep track of possible and good phrases.
By the final pass through the document collection, the list of possible phrases will be relatively short, due to the expected distribution of the use of phrases in a large corpus. Thus, if say by the 10th pass (e.g., 10,000,000 documents), a phrase appears for the very first time, it is very unlikely to be a good phrase at that time. It may be new phrase just coming into usage, and thus during subsequent crawls becomes increasingly common. In that case, its respective counts will increases and may ultimately satisfy the thresholds for being a good phrase.
The third stage of the indexing operation is to prune 204 the good phrase list 208 using a predictive measure derived from the co-occurrence matrix 212. Without pruning, the good phrase list 208 is likely to include many phrases that while legitimately appearing in the lexicon, themselves do not sufficiently predict the presence of other phrases, or themselves are subsequences of longer phrases. Removing these weak good phrases results in a very robust likely of good phrases. To identify good phrases, a predictive measure is used which expresses the increased likelihood of one phrase appearing in a document given the presence of another phrase. This is done, in one embodiment, as follows:
As noted above, the co-occurrence matrix 212 is an m×m matrix of storing data associated with the good phrases. Each row j in the matrix represents a good phrase gj and each column k represented a good phrase gk. For each good phrase gj, an expected value E(gj) is computed. The expected value E is the percentage of documents in the collection expected to contain gj. This is computed, for example, as the ratio of the number of documents containing gj to the total number T of documents in the collection that have been crawled: P(j)/T.
As noted above, the number of documents containing gj is updated each time gj appears in a document. The value for E(gj) can be updated each time the counts for gj are incremented, or during this third stage.
Next, for each other good phrase gk (e.g., the columns of the matrix), it is determined whether gj predicts gk. A predictive measure for gi is determined as follows:
i) compute the expected value E(gk). The expected co-occurrence rate E(j,k) of gj and gk, if they were unrelated phrases is then E(gj)*E(gk);
ii) compute the actual co-occurrence rate A(j,k) of gj and gk. This is the raw co-occurrence count R(j, k) divided by T, the total number of documents;
gj is said to predict gk where the actual co-occurrence rate A(j,k) exceeds the expected co-occurrence rate E(j,k) by a threshold amount.
In one embodiment, the predictive measure is information gain. Thus, a phrase gi predicts another phrase gk when the information gain I of gk in the presence of gj exceeds a threshold. In one embodiment, this is computed as follows:
I(j,k)=A(j,k)/E(j,k)
And good phrase gj predicts good phrase gk where:
I(j,k)>Information Gain threshold.
In one embodiment, the information gain threshold is 1.5, but is preferably between 1.1 and 1.7. Raising the threshold over 1.0 serves to reduce the possibility that two otherwise unrelated phrases co-occur more than randomly predicted.
As noted the computation of information gain is repeated for each column k of the matrix G with respect to a given row j. Once a row is complete, if the information gain for none of the good phrases gk exceeds the information gain threshold, then this means that phrase gi does not predict any other good phrase. In that case, gj is removed from the good phrase list 208, essentially becoming a bad phrase. Note that the column j for the phrase gj is not removed, as this phrase itself may be predicted by other good phrases.
This step is concluded when all rows of the co-occurrence matrix 212 have been evaluated.
The final step of this stage is to prune the good phrase list 208 to remove incomplete phrases. An incomplete phrase is a phrase that only predicts its phrase extensions, and which starts at the left most side of the phrase (i.e., the beginning of the phrase). The “phrase extension” of phrase p is a super-sequence that begins with phrase p. For example, the phrase “President of” predicts “President of the United States”, “President of Mexico”, “President of AT&T”, etc. All of these latter phrases are phrase extensions of the phrase “President of” since they begin with “President of” and are super-sequences thereof.
Accordingly, each phrase gj remaining on the good phrase list 208 will predict some number of other phrases, based on the information gain threshold previously discussed. Now, for each phrase gj the indexing system 110 performs a string match with each of the phrases gk that is predicts. The string match tests whether each predicted phrase gk is a phrase extension of the phrase gj. If all of the predicted phrases gk are phrase extensions of phrase then phrase gj is incomplete, and is removed from the good phrase list 208, and added to an incomplete phrase list 216. Thus, if there is at least one phrase gk that is not an extension of gj, then gj is complete, and maintained in the good phrase list 208. For example then, “President of the United” is an incomplete phrase because the only other phrase that it predicts is “President of the United States” which is an extension of the phrase.
The incomplete phrase list 216 itself is very useful during actual searching. When a search query is received, it can be compared against the incomplete phase list 216. If the query (or a portion thereof) matches an entry in the list, then the search system 120 can lookup the most likely phrase extensions of the incomplete phrase (the phrase extension having the highest information gain given the incomplete phrase), and suggest this phrase extension to the user, or automatically search on the phrase extension. For example, if the search query is “President of the United,” the search system 120 can automatically suggest to the user “President of the United States” as the search query.
After the last stage of the indexing process is completed, the good phrase list 208 will contain a large number of good phrases that have been discovered in the corpus. Each of these good phrases will predict at least one other phrase that is not a phrase extension of it. That is, each good phrase is used with sufficient frequency and independence to represent meaningful concepts or ideas expressed in the corpus. Unlike existing systems which use predetermined or hand selected phrases, the good phrase list reflects phrases that actual are being used in the corpus. Further, since the above process of crawling and indexing is repeated periodically as new documents are added to the document collection, the indexing system 110 automatically detects new phrases as they enter the lexicon.
2. Identification of Related Phrases and Clusters of Related Phrases
Referring to FIG. 4, the related phrase identification process includes the following functional operations.
400: Identify related phrases having a high information gain value.
402: Identify clusters of related phrases.
404: Store cluster bit vector and cluster number.
Each of these operations is now described in detail.
First, recall that the co-occurrence matrix 212 contains good phrases gj, each of which predicts at least one other good phrase gk with an information gain greater than the information gain threshold. To identify 400 related phrases then, for each pair of good phrases (gj, gk) the information gain is compared with a Related Phrase threshold, e.g., 100. That is, gj and gk are related phrases where:
I(g j ,g k)>100.
This high threshold is used to identify the co-occurrences of good phrases that are well beyond the statistically expected rates. Statistically, it means that phrases gj and gk co-occur 100 times more than the expected co-occurrence rate. For example, given the phrase “Monica Lewinsky” in a document, the phrase “Bill Clinton” is a 100 times more likely to appear in the same document, then the phrase “Bill Clinton” is likely to appear on any randomly selected document. Another way of saying this is that the accuracy of the predication is 99.999% because the occurrence rate is 100:1.
Accordingly, any entry (gj, gk) that is less than the Related Phrase threshold is zeroed out, indicating that the phrases gj, gk are not related. Any remaining entries in the co-occurrence matrix 212 now indicate all related phrases.
The columns gk in each row gj of the co-occurrence matrix 212 are then sorted by the information gain values I(gj, gk), so that the related phrase gk with the highest information gain is listed first. This sorting thus identifies for a given phrase gj, which other phrases are most likely related in terms of information gain.
The next step is to determine 402 which related phrases together form a cluster of related phrases. A cluster is a set of related phrases in which each phrase has high information gain with respect to at least one other phrase. In one embodiment, clusters are identified as follows.
In each row gj of the matrix, there will be one or more other phrases that are related to phrase gj. This set is related phrase set Rj, where R={gk, gl, . . . gm}.
For each related phrase m in Rj, the indexing system 110 determines if each of the other related phrases in R is also related to gj. Thus, if I(gk, gl) is also non-zero, then gj, gk, and gl are part of a cluster. This cluster test is repeated for each pair (gl, gm) in R.
For example, assume the good phrase “Bill Clinton” is related to the phrases “President”, “Monica Lewinsky”, because the information gain of each of these phrases with respect to “Bill Clinton” exceeds the Related Phrase threshold. Further assume that the phrase “Monica Lewinsky” is related to the phrase “purse designer”. These phrases then form the set R. To determine the clusters, the indexing system 110 evaluates the information gain of each of these phrases to the others by determining their corresponding information gains. Thus, the indexing system 110 determines the information gain I(“President”, “Monica Lewinsky”), I(“President”, “purse designer”), and so forth, for all pairs in R. In this example, “Bill Clinton,” “President”, and “Monica Lewinsky” form a one cluster, “Bill Clinton,” and “President” form a second cluster, and “Monica Lewinsky” and “purse designer” form a third cluster, and “Monica Lewinsky”, “Bill Clinton,” and “purse designer” form a fourth cluster. This is because while “Bill Clinton” does not predict “purse designer” with sufficient information gain, “Monica Lewinsky” does predict both of these phrases.
To record 404 the cluster information, each cluster is assigned a unique cluster number (cluster ID). This information is then recorded in conjunction with each good phrase
In one embodiment, the cluster number is determined by a cluster bit vector that also indicates the orthogonality relationships between the phrases. The cluster bit vector is a sequence of bits of length n, the number of good phrases in the good phrase list 208. For a given good phrase gj, the bit positions correspond to the sorted related phrases R of A bit is set if the related phrase gk in R is in the same cluster as phrase gj. More generally, this means that the corresponding bit in the cluster bit vector is set if there is information gain in either direction between gj and gk.
The cluster number then is the value of the bit string that results. This implementation has the property that related phrases that have multiple or one-way information gain appear in the same cluster.
An example of the cluster bit vectors are as follows, using the above phrases:
|
|
|
|
|
Monica |
purse |
Cluster |
|
Bill Clinton |
President |
Lewinsky |
designer |
ID |
|
|
|
|
1 |
1 |
1 |
0 |
14 |
President |
1 |
1 |
0 |
0 |
12 |
Monica |
1 |
0 |
1 |
1 |
11 |
Lewinsky |
purse |
0 |
0 |
1 |
1 |
3 |
designer |
|
To summarize then, after this process there will be identified for each good phrase gj, a set of related phrases R, which are sorted in order of information gain I(gj, gk) from highest to lowest. In addition, for each good phrase gj, there will be a cluster bit vector, the value of which is a cluster number identifying the primary cluster of which the phrase gj is a member, and the orthogonality values (1 or 0 for each bit position) indicating which of the related phrases in R are in common clusters with gj. Thus in the above example, “Bill Clinton”, “President”, and “Monica Lewinsky” are in cluster 14 based on the values of the bits in the row for phrase “Bill Clinton”.
To store this information, two basic representations are available. First, as indicated above, the information may be stored in the co-occurrence matrix 212, wherein:
entry G[row j,col. k]=(I(j,k), clusterNumber, clusterBitVector)
Alternatively, the matrix representation can be avoided, and all information stored in the good phrase list 208, wherein each row therein represents a good phrase gj:
Phrase rowj=list [phrase gk, (I(j,k), clusterNumber, clusterBitVector)].
This approach provides a useful organization for clusters. First, rather than a strictly—and often arbitrarily—defined hierarchy of topics and concepts, this approach recognizes that topics, as indicated by related phrases, form a complex graph of relationships, where some phrases are related to many other phrases, and some phrases have a more limited scope, and where the relationships can be mutual (each phrase predicts the other phrase) or one-directional (one phrase predicts the other, but not vice versa). The result is that clusters can be characterized “local” to each good phrase, and some clusters will then overlap by having one or more common related phrases.
For a given good phrase gj then the ordering of the related phrases by information gain provides a taxonomy for naming the clusters of the phrase: the cluster name is the name of the related phrase in the cluster having the highest information gain.
The above process provides a very robust way of identifying significant phrases that appear in the document collection, and beneficially, the way these related phrases are used together in natural “clusters” in actual practice. As a result, this data-driven clustering of related phrases avoids the biases that are inherent in any manually directed “editorial” selection of related terms and concepts, as is common in many systems.
3. Indexing Documents with Phrases and Related Phrases
Given the good phrase list 208, including the information pertaining to related phrases and clusters, the next functional operation of the indexing system 110 is to index documents in the document collection with respect to the good phrases and clusters, and store the updated information in the primary index 150 and the secondary index 152. FIG. 5 illustrates this process, in which there are the following functional stages for indexing a document:
500: Post document to the posting lists of good phrases found in the document.
502: Update instance counts and related phrase bit vector for related phases and secondary related phrases.
504: Reorder index entries according to posting list size.
506: Rank index entries in each posting list by an information retrieval score or feature value.
508: Partition each posting list between the primary server 150 and a secondary server 152.
These stages are now described in further detail.
A set of documents is traversed or crawled, as before; this may be the same or a different set of documents. For a given document d, traverse 500 the document word by word with a sequence window 302 of length n, from position i, in the manner described above.
In a given phrase window 302, identify all good phrases in the window, starting at position i. Each good phrase is denoted as gi. Thus, g1 is the first good phrase, g2 would be the second good phrase, and so forth.
For each good phrase gi (example g1 “President” and g4 “President of ATT”) post the document identifier (e.g., the URL) to the posting list for the good phrase gi in the index 150. This update identifies that the good phrase gi appears in this specific document.
In one embodiment, the posting list for a phrase g3 takes the following logical form:
Phrase gj: list: (document d, [list: related phase counts] [related phrase information])
For each phrase gj there is a list of the documents d on which the phrase appears. For each document, there is a list of counts of the number of occurrences of the related phrases R of phrase gj that also appear in document d.
In one embodiment, the related phrase information is a related phase bit vector. This bit vector may be characterized as a “bi-bit” vector, in that for each related phrase gk there are two bit positions, gk-1, gk-2. The first bit position stores a flag indicating whether the related phrase gk is present in the document d (i.e., the count for gk in document d is greater than 0). The second bit position stores a flag that indicates whether a related phrase gl of gk is also present in document d. The related phrases gl of a related phrase gk of a phrase gj are herein called the “secondary related phrases of gj” The counts and bit positions correspond to the canonical order of the phrases in R (sorted in order of decreasing information gain). This sort order has the effect of making the related phrase gk that is most highly predicted by gj associated with the most significant bit of the related phrase bit vector, and the related phrase gl that is least predicted by gj associated with the least significant bit.
It is useful to note that for a given phrase g, the length of the related phrase bit vector, and the association of the related phrases to the individual bits of the vector, will be the same with respect to all documents containing g. This implementation has the property of allowing the system to readily compare the related phrase bit vectors for any (or all) documents containing g, to see which documents have a given related phrase. This is beneficial for facilitating the search process to identify documents in response to a search query. Accordingly, a given document will appear in the posting lists of many different phrases, and in each such posting list, the related phrase vector for that document will be specific to the phrase that owns the posting list. This aspect preserves the locality of the related phrase bit vectors with respect to individual phrases and documents.
Accordingly, the next stage 502 includes traversing the secondary window 304 of the current index position in the document (as before a secondary window of +/−K terms, for example, 30 terms), for example from i−K to i+K. For each related phrase gk of gi that appears in the secondary window 304, the indexing system 110 increments the count of gk with respect to document d in the related phrase count. If gi appears later in the document, and the related phrase is found again within the later secondary window, again the count is incremented.
As noted, the corresponding first bit gel in the related phrase bit map is set based on the count, with the bit set to 1 if the count for gk is >0, or set to 0 if the count equals 0.
Next, the second bit, gk-2 is set by looking up related phrase gk in the index 150, identifying in gk's posting list the entry for document d, and then checking the secondary related phrase counts (or bits) for gk for any its related phrases. If any of these secondary related phrases counts/bits are set, then this indicates that the secondary related phrases of gj are also present in document d.
When document d has been completely processed in this manner, the indexing system 110 will have identified the following:
i) each good phrase g in document d;
for each good phrase gj which of its related phrases gk are present in document d;
for each related phrase gk present in document d, which of its related phrases gl (the secondary related phrases of gj) are also present in document d.
a) Partitioned Indexing
Each phrase in the index 150 is given a phrase number, based on its frequency of occurrence in the corpus. The more common the phrase, the lower phrase number it receives in the index. The indexing system 110 then sorts 504 all of the posting lists 214 in the primary index 150 in declining order according to the number of documents listed in each posting list, so that the most frequently occurring phrases have the lowest phrase number and are listed first in the primary index 150. As noted above, the primary index 150 is distributed across M1 primary servers. To reduce disk contention, phrases are distributed across these machines by hash function, e.g., phase_number MOD M1.
To significantly increase the number of documents that can be indexed by the system, the primary index 150 is further processed to selectively partition each of the posting lists 214. As noted above, the posting list of each phrase contains a list of documents. Each document in the posting list is given 506 an information retrieval-type score with respect to the phrase. However the score is computed, the documents in the posting list are then ranked in declining order by this score, with the highest scoring documents listed first in the posting list. This pre-ranking of documents is particularly beneficial for improved performance when retrieving documents in response to a search query.
The scoring algorithm for pre-ranking the documents may be the same underlying relevance scoring algorithm used in the search system 120 to generate a relevance score. In one embodiment, the IR score is based on the page rank algorithm, as described in U.S. Pat. No. 6,285,999. Alternatively or additionally, statistics for a number of IR-relevant attributes of the document, such as the number of inlinks, outlinks, document length, may also be stored, and used alone or in combination in order to rank the documents. For example, the documents may be ranked in declining order according to the number of inlinks. To further facilitate the fastest possible retrieval of information from the primary index 150, the entries in each posting list 214 are physically stored on the appropriate primary server in the rank ordering by the IR-type score.
Given that the highest scoring documents for a given phrase are now at the beginning of the posting list, the posting list 214 is partitioned 508 between the primary index 150 and the secondary index 152. The posting list entries for up to the first K documents remain stored on the primary server 150, while the posting list entries for the remaining n>K documents are stored in the secondary index 152, and deleted from the end of the posting list 214 in the primary index 150. In one embodiment K is set to 32,768 (32k), but a higher or lower value of K may be used. A phrase that has its posting list partitioned between the primary and the secondary index is called a ‘common’ phrase, whereas a phrase that is not partitioned is called a ‘rare’ phrase. The portion of a posting list stored in the primary index 150 is referred to as the primary posting list, and contains the primary entries, and portion of a posting list stored in the secondary index 152 is referred to as the secondary posting list and contains the secondary entries. The secondary entries for a given posting list 214 are assigned to a secondary server according to another hash function of the phrase number, e.g., phrase number MOD M2. The secondary server ID is stored in the posting list on the primary server, to allow the search system 120 to readily access the appropriate secondary server as needed. For each phrase posting list stored on one of the secondary servers, the secondary entries are stored physically in order of their document numbers, from lowest document number to highest (in contrast to the relevance ordering in the primary index 150). Preferably, no relevance information is stored in the secondary entries, so that the entries contain a minimal amount of data, such as the document number, and document locator (e.g., URL). The ranking and partitioning steps may be performed sequentially for each phrase; alternatively all (or a number of) phrases can first be ranked, and then partitioned; the algorithm design is merely a design choice and the above variations are considered equivalents. The ranking and partitioning steps are conducted during each indexing pass over a set of documents, so that any phrases that are updated with new documents during an indexing pass are re-ranked and re-partitioned. Other optimizations and operations are also possible.
In one embodiment, the selection of document attributes that are stored in the primary index 150 for each document in the post listing 214 is variable, and in particular decreases towards the end of the posting list 214 in the primary index. In other words, documents that are highly ranked in the posting list based on their relevance score (or other relevance based attributes), will have all or most of the document attributes stored in the document entry in the posting list. Documents at near the end of the posting list 214 in the primary index will have only a more limited set of such attributes stored.
In one embodiment, each posting list 214 in the primary index 150 has three sections (or tiers), of lengths m, 3 m, 5 m, where m here is a number of document entries, In this embodiment, it is desirable that each section have length K, as described above, that is m=K, and the entire primary index has 9K entries; the secondary index would then store the secondary entries where n>9K.
In the first section (first m entries), the following relevance attributes are stored for each document entry in the posting list of a given phrase:
-
- 1. The document relevance score (e.g., page rank);
- 2. Total number of occurrences of the phrase in the document;
- 3. A rank ordered list of up to 10,000 anchor documents that also contain the phrase and which point to this document, and for each anchor document its relevance score (e.g., page rank), and the anchor text itself; and
- 4. The position of each phrase occurrence, and for each occurrence, a set of flags indicating whether the occurrence is a title, bold, a heading, in a URL, in the body, in a sidebar, in a footer, in an advertisement, capitalized, or in some other type of HTML markup.
In the second section (next 3 m entries), only items 1-3 are stored.
In the third section (final 5 m entries), only item 1 is stored.
Systematically reducing which document attributes are stored in later portions of each posting list 214 is acceptable because document near the end of the posting list are already determined to be less relevant to the particular phrase (lower relevance score), and so it is not entirely necessary to store all of their relevance characteristics.
The foregoing storage arrangement enables storing significantly more entries in a given amount of hard disk storage than conventional techniques. First, elimination of the term position information for every phrase in every document provides approximately a 50% reduction in the amount of storage needed for a given set of documents, thereby effectively doubling the number of documents that can be stored. Second, partitioning the posting lists between the primary index and secondary indices and storing relevance information only in the primary index provides further substantial savings. Many phrases have over 100,000, even 1,000,000 documents in their posting lists. Storing the relevance information for only a limited number of entries in the primary index eliminates the storage needed for the documents that are not likely to be returned in search. This aspect provides approximately a ten-fold increase in the number of documents that can be stored. Finally, further savings (approximately 25%-50% reduction in required storage capacity) are achieved by selectively storing less relevance information in the primary index 150 for the less relevant (lower ranked) documents in each posting list 214.
b) Determining the Topics for a Document
The indexing of documents by phrases and use of the clustering information provides yet another advantage of the indexing system 110, which is the ability to determine the topics that a document is about based on the related phrase information.
Assume that for a given good phrase gj and a given document d, the posting list entry is as follows:
gj: document d: related phrase counts:={3,4,3,0,0,2,1,1,0}
-
- related phrase bit vector:={11 11 10 00 00 10 10 10 01}
where, the related phrase bit vector is shown in the bi-bit pairs.
From the related phrase bit vector, we can determine primary and secondary topics for the document d. A primary topic is indicated by a bit pair (1,1), and a secondary topic is indicated by a bit pair (1,0). A related phrase bit pair of (1,1) indicates that both the related phrase gk for the bit pair is present in document d, along the secondary related phrases gl as well. This may be interpreted to mean that the author of the document d used several related phrases gj, gk, and gi together in drafting the document. A bit pair of (1,0) indicates that both gj and gk are present, but no further secondary related phrases from gk are present, and thus this is a less significant topic.
c) Indexing Instances of Documents for Archival Retrieval
Another embodiment of the present invention allows the capability to store and maintain historical documents in the indices, and thereby enable archival retrieval of date specific instances (versions) of individual documents or pages. This capability has various beneficial uses, including enabling a user to search for documents within a specific range of dates, enabling the search system 120 to use date or version related relevance information in evaluating documents in response to a search query, and in organizing search results.
In this embodiment, the document identifier encodes the identity of the document with respect to a date interval. The first time a document is crawled by the indexing system 110, the document identifier is stored as a hash of the document URL and the date stamp of the document, for example, MD5 (URL, first date). Associated with the particular instance of the document is date range field, which comprises a range of dates for which the document instance is deemed to be valid. The date range can be specified as a date pair comprising a first date on which the document is deemed valid (the indexing date) and a last date on which the document is deemed valid (e.g, 11-01-04; 12-15-04). Alternatively, the date range can be specified as a first date, and a number indicating a number of days following the first date (e.g., 11-01-04, 45). A date can be specified in any useful format, including date strings or day numbers. During the period in which the document is the currently valid document, the second value is a status flag or token (including a NULL value), indicating this state; this is called the current interval. For example, (11-01-04, “open”) indicates that the document is currently valid. This indicates that the document will satisfy search that includes a date limitation after the first date. Regardless of the particular implementation, the first date for a given date interval may be referred to as the “open date”, and the last date for a given interval may be referred to as the “closed date”.
During subsequent indexing passes by the indexing system 110, the indexing system 110 determines whether the document has changed. If there is no change in the document, then the indexing system 110 takes no further action with respect to document. If there has been a change in the document (thus a new instance or version of the document), then the indexing system 110 re-indexes the document. Upon re-indexing, the indexing system 110 closes the current interval, by changing the open status flag to the current date minus one day. For example, if the indexing system 110 indexes the document on 12/16/2004 and determines that the document has changed, then current interval is closed as follows: (11-01-04, 12-15-04), and a new current interval is created, e.g., (12-16-04, “open”). FIG. 8 provides an illustration of this example. The indexing system 110 maintains each of the date ranges for the document, along with corresponding indexed relevance data (e.g., phrases, relevance statistics, document inlinks, and so forth) for the date range. FIG. 7 illustrates this process. Thus, each date range and set of relevance data is associated with a particular instance or version of the document. For each date interval for a given document, the indexing system maintains a unique document identifier, e.g., MD5 (URL, first date), so as to be able to retrieve the appropriate cached document instance. In an embodiment using the primary and secondary indexes, when an indexing pass is completed, the posting lists 214 in the primary index are rescored, re-ranked, and repartitioned.
The determination of whether a given document has changed since the last indexing pass may be made in any number of ways, including using statistical rules, grammatical rules, or similar heuristics. In one embodiment, the indexing system 110 uses the phrases of a document to determine if a document has changed. Each time a document is indexed, the top N topics are identified and maintained as a list in association with the date range information, for example, the top 20 topics for the date range (11-04-04, 12-15-04). The topic list of the instance being indexed is then compared with the topic list of a prior document instance, preferably the most recently closed date range. If more than M % of the topics have changed (e.g., 5%), then the document is deemed to have changed, and is re-indexed for all phrases. It should be noted that other methods of determining whether a document has changed may also be used, and that the use of phrase-based indexing is not required. For example, a set of statistical rules may be used based on changes in document length, changes in which terms are most frequent, changes in term frequency, changes in the amount of types of HTML markup, or other measures of document structure or content.
III. Search System
The search system 120 operates to receive a query and search for documents relevant to the query, and provide a list of these documents (with links to the documents) in a set of search results. FIG. 6 illustrates the main functional operations of the search system 120:
600: Identify phrases in the query.
602: Retrieve documents relevant to query phrases.
604: Rank documents in search results according to phrases.
The details of each of these of these stages is as follows.
1. Identification of Phrases in the Query and Query Expansion
The first stage 600 of the search system 120 is to identify any phrases that are present in the query in order to effectively search the index. The following terminology is used in this section:
q: a query as input and received by the search system 120.
Qp: phrases present in the query.
Qr: related phrases of Qp.
Qe: phrase extensions of Qp.
Q: the union of Qp and Qr.
A query q is received from a client 190, having up to some maximum number of characters or words.
A phrase window of size N (e.g., 5) is used by the search system 120 to traverse the terms of the query q. The phrase window starts with the first term of the query, extends N terms to the right. This window is then shifted right M-N times, where M is the number of terms in the query.
At each window position, there will be N terms (or fewer) terms in the window. These terms constitute a possible query phrase. The possible phrase is looked up in the good phrase list 208 to determine if it is a good phrase or not. If the possible phrase is present in the good phrase list 208, then a phrase number is returned for phrase; the possible phrase is now a candidate phrase.
After all possible phrases in each window have been tested to determine if they are good candidate phrases, the search system 120 will have a set of phrase numbers for the corresponding phrases in the query. These phrase numbers are then sorted (declining order).
Starting with the highest phrase number as the first candidate phrase, the search system 120 determines if there is another candidate phrase within a fixed numerical distance within the sorted list, i.e., the difference between the phrase numbers is within a threshold amount, e.g. 20,000. If so, then the phrase that is leftmost in the query is selected as a valid query phrase Qp. This query phrase and all of its sub-phrases are removed from the list of candidates, and the list is resorted and the process repeated. The result of this process is a set of valid query phrases Qp.
For example, assume the search query is “Hillary Rodham Clinton Bill on the Senate Floor”. The search system 120 would identify the following candidate phrases, “Hillary Rodham Clinton Bill on,” “Hillary Rodham Clinton Bill,” and “Hillary Rodham Clinton”. The first two are discarded, and the last one is kept as a valid query phrase. Next the search system 120 would identify “Bill on the Senate Floor”, and the subsphrases “Bill on the Senate”, “Bill on the”, “Bill on”, “Bill”, and would select “Bill” as a valid query phrase Qp. Finally, the search system 120 would parse “on the senate floor” and identify “Senate Floor” as a valid query phrase.
Next, the search system 120 adjusts the valid phrases Qp for capitalization. When parsing the query, the search system 120 identifies potential capitalizations in each valid phrase. This may be done using a table of known capitalizations, such as “united states” being capitalized as “United States”, or by using a grammar based capitalization algorithm. This produces a set of properly capitalized query phrases.
The search system 120 then makes a second pass through the capitalized phrases, and selects only those phrases are leftmost and capitalized where both a phrase and its subphrase is present in the set. For example, a search on “president of the united states” will be capitalized as “President of the United States”.
In the next stage, the search system 120 identifies 602 the documents that are relevant to the query phrases Q. The search system 120 then retrieves the posting lists of the query phrases Q and where necessary, intersects these lists to determine which documents appear on the all (or some number) of the posting lists for the query phrases. If a phrase Q in the query has a set of phrase extensions Qe (as further explained below), then the search system 120 first forms the union of the posting lists of the phrase extensions, prior to doing the intersection with the posting lists. The search system 120 identifies phrase extensions by looking up each query phrase Q in the incomplete phrase list 216, as described above.
Using the primary index 150 and the secondary index 152, the search system 120 can further optimize the intersection operation. There are four general cases of intersection analysis that the search system 120 has to handle based on whether the query phrases are common or rare.
The first case is for single query phrase, which can be either common or rare. In this case, the search system 120 passes a selected number (e.g., 100 or 1000) of the first entries in the phrase's posting list from the primary index 150 to the ranking phase 604 for final ranking. The ranking phase can optimize the ranking operation since the documents are already in rank order. Alternatively, since these are already pre-ranked by their relevance to the phrase, the set of documents can be directly provided as the search results, providing essentially instantaneous results to the user.
The second case is where there are two common query phrases. Here, the search system 120 accesses the posting lists 214 for each phrase in the primary index 150 and intersects these lists to form the final document list, which is then passed to the ranking phrase 604 for relevance scoring based on the set of relevance attributes associated with document. Because there are at least K documents in each posting list, there is a very high likelihood of a sufficient number documents containing both phrases, and thus intersection of the secondary entries in the secondary index 152 is not necessary. This further reduces the amount of time needed for retrieval.
The third case is where there are two rare query phrases. This case is treated in the same manner as the second case, since here the entire posting list for each phrase is stored in the primary index.
The final case is where the valid query phrases comprise a common phrase and a rare phrase. In this case, the search system 120 first intersects the posting lists 214 from the primary index 150 for both phrases to form a first set or common documents. Next, the search system 120 intersects the posting list for the rare phrase with the secondary entries for the common phrase (which are already sorted in document number order) to form a second set of common documents. The two sets are conjoined and then passed to ranking phase.
All instances where there are three or more query phrases can be reductively handled by one successive intersections using the above methods.
2. Ranking
a) Ranking Documents Based on Contained Phrases
The search system 120 provides a ranking stage 604 in which the documents in the search results are ranked, using the relevance information and document attributes, along with the phrase information in each document's related phrase bit vector, and the cluster bit vector for the query phrases. This approach ranks documents according to the phrases that are contained in the document, or informally “body hits.”
As described above, for any given phrase gj, each document d in the gj's posting list has an associated related phrase bit vector that identifies which related phrases gk and which secondary related phrases gl are present in document d. The more related phrases and secondary related phrases present in a given document, the more bits that will be set in the document's related phrase bit vector for the given phrase. The more bits that are set, the greater the numerical value of the related phrase bit vector.
Accordingly, in one embodiment, the search system 120 sorts the documents in the search results according to the value of their related phrase bit vectors. The documents containing the most related phrases to the query phrases Q will have the highest valued related phrase bit vectors, and these documents will be the highest-ranking documents in the search results.
This approach is desirable because semantically, these documents are most topically relevant to the query phrases. Note that this approach provides highly relevant documents even if the documents do not contain a high frequency of the input query terms q, since related phrase information was used to both identify relevant documents, and then rank these documents. Documents with a low frequency of the input query terms may still have a large number of related phrases to the query terms and phrases and thus be more relevant than documents that have a high frequency of just the query terms and phrases but no related phrases.
In a second embodiment, the search system 120 scores each document in the result set according which related phrases of the query phrase Q it contains. This is done as follows:
Given each query phrase Q, there will be some number N of related phrases Qr to the query phrase, as identified during the phrase identification process. As described above, the related query phrases Qr are ordered according to their information gain from the query phrase Q. These related phrases are then assigned points, started with N points for the first related phrase Qr1 (i.e., the related phrase Qr with the highest information gain from Q), then N−1 points for the next related phrase Qr2, then N−2 points for Qr3, and so on, so that the last related phrase QrN is assigned 1 point.
Each document in the search results is then scored by determining which related phrases Qr of the query phrase Q are present, and giving the document the points assigned to each such related phrase Qr. The documents are then sorted from highest to lowest score.
As a further refinement, the search system 120 can cull certain documents from the result set. In some cases documents may be about many different topics; this is particularly the case for longer documents. In many cases, users prefer documents that are strongly on point with respect to a single topic expressed in the query over documents that are relevant to many different topics.
To cull these latter types of documents, the search system 120 uses the cluster information in the cluster bit vectors of the query phrases, and removes any document in which there are more than a threshold number of clusters in the document. For example, the search system 120 can remove any documents that contain more than two clusters. This cluster threshold can be predetermined, or set by the user as a search parameter.
b) Ranking Documents Based on Anchor Phrases
In addition to ranking the documents in the search results based on body hits of query phrases Q, in one embodiment, the search system 120 also ranks the documents based on the appearance of query phrases Q and related query phrases Qr in anchors to other documents. In one embodiment, the search system 120 calculates a score for each document that is a function (e.g., linear combination) of two scores, a body hit score and an anchor hit score.
For example, the document score for a given document can be calculated as follows:
Score=0.30*(body hit score)+0.70*(anchor hit score).
The weights of 0.30 and 0.70 can be adjusted as desired. The body hit score for a document is the numerical value of the highest valued related phrase bit vector for the document, given the query phrases Qp, in the manner described above. Alternatively, this value can directly obtained by the search system 120 by looking up each query phrase Q in the index 150, accessing the document from the posting list of the query phrase Q, and then accessing the related phrase bit vector.
The anchor hit score of a document d a function of the related phrase bit vectors of the query phrases Q where Q is an anchor term in a document that references document d. When the indexing system 110 indexes the documents in the document collection, it maintains for each phrase a list of the documents in which the phrase is anchor text in an outlink, and also for each document a list of the inlinks (and the associated anchor text) from other documents. The inlinks for a document are references (e.g. hyperlinks) from other documents (referencing documents) to a given document.
To determine the anchor hit score for a given document d then, the search system 120 iterates over the set of referencing documents R (i=1 to number of referencing documents) listed in index by their anchor phrases Q, and sums the following product:
R.Q.Related phrase bit vector*D.Q.Related phrase bit vector.
The product value here is a score of how topical anchor phrase Q is to document D. This score is here called the “inbound score component.” This product effectively weights the current document D's related bit vector by the related bit vectors of anchor phrases in the referencing document R. If the referencing documents R themselves are related to the query phrase Q (and thus, have a higher valued related phrase bit vector), then this increases the significance of the current document D score. The body hit score and the anchor hit score are then combined to create the document score, as described above.
Next, for each of the referencing documents R, the related phrase bit vector for each anchor phrase Q is obtained. This is a measure of how topical the anchor phrase Q is to the document R. This value is here called the outbound score component.
From the index 150 then, all of the (referencing document, referenced document) pairs are extracted for the anchor phrases Q. These pairs are then sorted by their associated (outbound score component, inbound score component) values. Depending on the implementation, either of these components can be the primary sort key, and the other can be the secondary sort key. The sorted results are then presented to the user. Sorting the documents on the outbound score component makes documents that have many related phrases to the query as anchor hits, rank most highly, thus representing these documents as “expert” documents. Sorting on the inbound document scores makes documents that are frequently referenced by the anchor terms the most highly ranked.
c) Ranking Documents Based on Date Range Relevance
The search system 120 can use the date range information in several ways during the search and ranking operations. First, the search system 120 can use the date range as an explicit search delimiter. For example, a query may include terms or phrases and a date, such as “United States Patent and Trademark Office Dec. 4, 2004”. The search system 120 can identify the date term, and then select documents that have the desired phrase and which are indexed for a date range that includes the date term in the query. From the selected documents, the search system 120 can then obtain a relevance score for each document using the indexed relevance data associated with the date range. In this manner, an older or previous instance of a document may be retrieved instead of the current instance where it is more relevant to the search query. This is particularly useful for documents and pages that change frequently, such as the home pages of news sites and other sites containing frequently changing information.
Second, where no date term is included in a search query, the search system 120 can use the date information in the index during relevance ranking, by weighting document relevance scores according to how old they are, so that older documents have their relevance scores down weighted (or newer documents are more highly weighted). Alternatively, in some cases, it is older versions of a document that are most relevant to a topic, rather than the most current version of a document. For example, news portal sites contemporaneously created at the time of historical events are likely to be more relevant to a specific query about the event, than current instances of the news portal. In this case, the search system 120 can upweight older document instances, where for example, the pattern of document relevance scores for all of the instances of a document shows an increase around some historical date, followed by decreasing relevance scores for more current instances of the document.
Where one or more date terms are included in the search query, as above, documents may have their relevance scores down weighted in proportion to the difference between the date term and the document date range, so that documents that are either much older than the date range (measured from either the open or the close date) or much newer than the desired date terms have their relevance scored down weighted. Conversely, a relevance score can be increased instead of down weighted where the date range for the document is closer to the desired date.
Third, the search system 120 can use the date range information as either a primary or secondary factor for ordering the search results. For examples, documents can be grouped in reversed chronological order (e.g. monthly groups), and within each group, the documents can be listed from most to least relevant to the search query.
Another use of the data range information is to rank documents based on the frequency with which they are updated. The search system 120 can determine the number of instances of a given document (e.g., number of discrete date ranges) over an interval of time (this count can be maintained during indexing). The number of instances is then used to upweight those documents which are more frequently updated.
The present invention has been described in particular detail with respect to one possible embodiment. Those of skill in the art will appreciate that the invention may be practiced in other embodiments. First, the particular naming of the components, capitalization of terms, the attributes, data structures, or any other programming or structural aspect is not mandatory or significant, and the mechanisms that implement the invention or its features may have different names, formats, or protocols. Further, the system may be implemented via a combination of hardware and software, as described, or entirely in hardware elements. Also, the particular division of functionality between the various system components described herein is merely exemplary, and not mandatory; functions performed by a single system component may instead be performed by multiple components, and functions performed by multiple components may instead performed by a single component.
Some portions of above description present the features of the present invention in terms of algorithms and symbolic representations of operations on information. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. These operations, while described functionally or logically, are understood to be implemented by computer programs. Furthermore, it has also proven convenient at times, to refer to these arrangements of operations as modules or by functional names, without loss of generality.
Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as “processing” or “computing” or “calculating” or “determining” or “displaying” or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system memories or registers or other such information storage, transmission or display devices.
Certain aspects of the present invention include process steps and instructions described herein in the form of an algorithm. It should be noted that the process steps and instructions of the present invention could be embodied in software, firmware or hardware, and when embodied in software, could be downloaded to reside on and be operated from different platforms used by real time network operating systems.
The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general-purpose computer selectively activated or reconfigured by a computer program stored on a computer readable medium that can be accessed by the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, application specific integrated circuits (ASICs), or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus. Furthermore, the computers referred to in the specification may include a single processor or may be architectures employing multiple processor designs for increased computing capability.
The algorithms and operations presented herein are not inherently related to any particular computer or other apparatus. Various general-purpose systems may also be used with programs in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will be apparent to those of skill in the, along with equivalent variations. In addition, the present invention is not described with reference to any particular programming language. It is appreciated that a variety of programming languages may be used to implement the teachings of the present invention as described herein, and any references to specific languages are provided for disclosure of enablement and best mode of the present invention.
The present invention is well suited to a wide variety of computer network systems over numerous topologies. Within this field, the configuration and management of large networks comprise storage devices and computers that are communicatively coupled to dissimilar computers and storage devices over a network, such as the Internet.
Finally, it should be noted that the language used in the specification has been principally selected for readability and instructional purposes, and may not have been selected to delineate or circumscribe the inventive subject matter. Accordingly, the disclosure of the present invention is intended to be illustrative, but not limiting, of the scope of the invention, which is set forth in the following claims.