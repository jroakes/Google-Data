US20240054102A1 - Scalable and Cost-Efficient Information Retrieval Architecture for Massive Datasets - Google Patents
Scalable and Cost-Efficient Information Retrieval Architecture for Massive Datasets Download PDFInfo
- Publication number
- US20240054102A1 US20240054102A1 US17/886,860 US202217886860A US2024054102A1 US 20240054102 A1 US20240054102 A1 US 20240054102A1 US 202217886860 A US202217886860 A US 202217886860A US 2024054102 A1 US2024054102 A1 US 2024054102A1
- Authority
- US
- United States
- Prior art keywords
- storage media
- computing system
- data elements
- data index
- data
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000000034 method Methods 0.000 claims description 40
- 238000005192 partition Methods 0.000 claims description 13
- 239000007787 solid Substances 0.000 claims description 5
- 230000008901 benefit Effects 0.000 description 9
- 238000004891 communication Methods 0.000 description 7
- 238000010586 diagram Methods 0.000 description 7
- 230000007246 mechanism Effects 0.000 description 5
- 230000008569 process Effects 0.000 description 5
- 238000012546 transfer Methods 0.000 description 4
- 238000013459 approach Methods 0.000 description 3
- 230000004075 alteration Effects 0.000 description 2
- 230000003068 static effect Effects 0.000 description 2
- 238000009825 accumulation Methods 0.000 description 1
- 238000007792 addition Methods 0.000 description 1
- 238000004590 computer program Methods 0.000 description 1
- 238000013500 data storage Methods 0.000 description 1
- 238000001514 detection method Methods 0.000 description 1
- 230000000694 effects Effects 0.000 description 1
- 238000005516 engineering process Methods 0.000 description 1
- 230000006870 function Effects 0.000 description 1
- 230000014759 maintenance of location Effects 0.000 description 1
- 238000012986 modification Methods 0.000 description 1
- 230000004048 modification Effects 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 238000012545 processing Methods 0.000 description 1
- 230000004044 response Effects 0.000 description 1
- 238000000638 solvent extraction Methods 0.000 description 1
- 230000001960 triggered effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2228—Indexing structures
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/10—File systems; File servers
- G06F16/13—File access structures, e.g. distributed indices
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2455—Query execution
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/27—Replication, distribution or synchronisation of data between databases or within a distributed database system; Distributed database system architectures therefor
- G06F16/273—Asynchronous replication or reconciliation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/40—Information retrieval; Database structures therefor; File system structures therefor of multimedia data, e.g. slideshows comprising image and additional audio data
- G06F16/41—Indexing; Data structures therefor; Storage structures
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0602—Interfaces specially adapted for storage systems specifically adapted to achieve a particular effect
- G06F3/061—Improving I/O performance
- G06F3/0611—Improving I/O performance in relation to response time
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0628—Interfaces specially adapted for storage systems making use of a particular technique
- G06F3/0646—Horizontal data movement in storage systems, i.e. moving data in between storage devices or systems
- G06F3/0647—Migration mechanisms
- G06F3/0649—Lifecycle management
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0668—Interfaces specially adapted for storage systems adopting a particular infrastructure
- G06F3/0671—In-line storage system
- G06F3/0683—Plurality of storage devices
- G06F3/0685—Hybrid storage combining heterogeneous device types, e.g. hierarchical storage, hybrid arrays
Definitions
- the present disclosure relates generally to a scalable and cost-efficient information retrieval for large-scale datasets. More particularly, the present disclosure relates to a bifurcated information retrieval architecture that includes multiple data indices stored on multiple different sets of storage media having differing latency characteristics.
- Search engine indexing refers to the collecting, parsing, and storing of data within an index to facilitate fast and accurate information retrieval.
- an index can be generated for a dataset that includes a number of data elements, such as webpages or other documents, images, videos, audio files, data files, entities, and/or other data elements in a dataset.
- One purpose of generating and storing an index is to optimize speed and performance in finding and returning relevant data elements that are potentially responsive to a search query.
- a dataset can include a massive number (e.g., millions or billions) of data elements.
- a massive number e.g., millions or billions
- One example is Internet-scale datasets which seek to index (approximately) all data elements (e.g., webpages, videos, etc.) across the entire Internet.
- large, globally popular data sharing platforms e.g., video sharing platforms
- massive numbers of data elements e.g., hundreds of millions of videos).
- storage media e.g., such as Random Access Memory (RAM)
- RAM Random Access Memory
- RAM and other low-latency media have significant operational cost and therefore it is typically infeasible to use these media to store the index of a massive dataset.
- other storage media e.g., such as Solid State Drive (SSD) or “flash”
- SSD Solid State Drive
- SSD or other similar storage media may not be applicable to indexing and retrieval techniques that require dynamic changes or updates to the index.
- One example aspect of the present disclosure is directed to a computer-implemented method for indexing a dataset comprising a large number of data elements.
- the method includes, for each of a plurality of storage periods: maintaining, by a computing system, a first data index stored by a first set of storage media having a first latency associated therewith; and maintaining, by the computing system, a second data index stored by a second set of storage media having a second latency associated therewith, the second latency being greater than the first latency, the second data index containing existing data elements included in the dataset.
- the method includes receiving, by the computing system, one or more additional data elements that have been added to the dataset; and indexing, by the computing system, one or more representations of the one or more additional data elements in the first data index stored by the first set of storage media.
- the method includes transferring, by the computing system, the one or more representations of the one or more additional data elements contained in the first data index stored by the first set of storage media to the second data index stored by the second set of storage media.
- the computing system includes a first set of storage media that stores a first data index, the first set of storage media having a first latency associated therewith.
- the computing system includes a second set of storage media that stores a second data index, the second set of storage media having a second latency associated therewith, the second latency being greater than the first latency, the second data index containing existing data elements included in a dataset.
- the computing system includes one or more processors and one or more non-transitory computer-readable media that store instructions that, when executed by the one or more processors, cause the computing system to perform operations.
- the operations include, during pendency of a storage period: receiving, by the computing system, one or more additional data elements that have been added to the dataset; and indexing, by the computing system, one or more representations of the one or more additional data elements in the first data index stored by the first set of storage media.
- the operations include, during pendency of the storage period or upon expiration of the storage period: transferring, by the computing system, the one or more representations of the one or more additional data elements contained in the first data index stored by the first set of storage media to the second data index stored by the second set of storage media.
- Another example aspect of the present disclosure is directed to one or more non-transitory computer-readable media that store instructions that, when executed by one or more processors, cause the one or more processors to perform operations.
- the operations include, for each of a plurality of storage periods: maintaining, by a computing system, a first data index stored by a first set of storage media having a first latency associated therewith; and maintaining, by the computing system, a second data index stored by a second set of storage media having a second latency associated therewith, the second latency being greater than the first latency, the second data index containing existing data elements included in a dataset.
- the operations include, during pendency of the storage period: receiving, by the computing system, one or more additional data elements that have been added to the dataset; and indexing, by the computing system, one or more representations of the one or more additional data elements in the first data index stored by the first set of storage media.
- the operations include, during pendency of the storage period or upon expiration of the storage period: transferring, by the computing system, the one or more representations of the one or more additional data elements contained in the first data index stored by the first set of storage media to the second data index stored by the second set of storage media.
- FIG. 1 depicts a block diagram of an example computing system according to example embodiments of the present disclosure.
- FIG. 2 depicts a block diagram of an example computing device according to example embodiments of the present disclosure.
- FIG. 3 depicts a graphical representation of a process for indexing data elements according to example embodiments of the present disclosure.
- FIG. 4 depicts a graphical diagram of an example hierarchical retrieval technique according to example embodiments of the present disclosure.
- FIG. 5 depicts a flow chart diagram of an example method to index data elements according to example embodiments of the present disclosure
- the present disclosure is directed to a scalable and cost-efficient storage architecture for large-scale datasets, such as Internet-scale datasets that include very large numbers (e.g., billions) of data elements. More particularly, the present disclosure relates to a bifurcated storage architecture that includes a first data index stored by a first set of storage media and a second data index stored by a second set of storage media, where the first set of storage media has a lower latency than the second set of storage media.
- the indexing of the dataset can occur over a number of storage periods.
- any new data elements that are added to the dataset can be indexed into the first data index, while the majority (e.g., all) of the existing data elements of dataset can be indexed in the second data index.
- the new data elements included in the first data index can be transferred from the first data index stored by the first set of storage media to the second data index stored by the second set of storage media.
- all of the data elements indexed in the second data index can be updated (e.g., recomputed or otherwise re-indexed).
- an information retrieval index can be split into two (e.g., partially overlapping) parts: fresh (e.g., new data elements introduced within the most recent storage period (e.g., the last 30 days)) and stable (e.g., all data elements existing in the dataset except those introduced within at least a portion of the most recent storage period (e.g., except elements introduced within the last 7 days).
- fresh e.g., new data elements introduced within the most recent storage period (e.g., the last 30 days)
- stable e.g., all data elements existing in the dataset except those introduced within at least a portion of the most recent storage period (e.g., except elements introduced within the last 7 days).
- the fresh index can be stored on storage media having relatively lower latency and higher applicability to dynamic updates, but higher operational cost (e.g., RAM).
- the stable index can be stored on storage media having relatively higher latency and lower applicability to dynamic updates, but lower operational cost (e.g., SSD).
- One benefit of such a split is that the retrieval system needs to support (complex) instant updates of only the small fresh index. The retrieval system can then update the larger stable index periodically by recomputing new versions of the entire served dataset at once.
- a plurality of centroids can be stored in the first set of storage media.
- the plurality of centroids can respectively correspond to a plurality of partitions of the existing data elements included in the second data index stored by the second set of storage media.
- the centroids can be used to perform a hierarchical retrieval technique (e.g., such as a hierarchical nearest neighbor search).
- the hierarchical retrieval technique first can include identifying one or more of the centroids stored by the first set of storage media based on the query.
- the hierarchical retrieval technique can include accessing, from the second set of storage media, only the data elements included in the one or more of the partitions respectively associated with the one or more centroids identified based on the query.
- Hierarchical retrieval techniques of this nature can identify results that are responsive to the query with reduced computational costs (e.g., by evaluating only a smaller subset of the indexed data elements included in the identified partition(s), rather than all indexed data elements). Further, because the centroids are maintained in the first set of storage media having the lower latency, they can be accessed and/or updated faster and with reduced computational cost.
- the proposed approach provides a number of technical effects and benefits.
- there are a number of different storage mediums which offer different benefits and challenges when used to store a data index.
- the present disclosure provides an architecture for scalable and cost-efficient matching which stores a majority of indexed data on (e.g., remote) SSD.
- the proposed approach allows an information retrieval system to support low query-per-second (QPS) use-cases (e.g., detection and removal of objectionable content) with low operational cost (e.g., due to total SSD operational cost required being very low even at massive scale).
- QPS query-per-second
- the proposed approaches open up the previously inaccessible option of performing a matching or search query against all elements in a massive dataset.
- High QPS use cases may also remain efficient through the use of hierarchical retrieval techniques that efficiently leverage multiple different types of storage media.
- FIG. 1 shows an example search system 114 .
- the search system 114 is an example of an information retrieval system implemented as one or more computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below can be implemented.
- a user 102 can interact with the search system 114 through a client device 104 .
- the client device 104 can be a computer coupled to the search system 114 through a data communication network 112 , e.g., local area network (LAN) or wide area network (WAN), e.g., the Internet, or a combination of networks.
- LAN local area network
- WAN wide area network
- the search system 114 can be implemented on the client device 104 , for example, if a user installs an application that performs searches on the client device 104 .
- the client device 104 will generally include a memory, e.g., a random access memory (RAM) 106 , for storing instructions and data and a processor 108 for executing stored instructions.
- the memory can include both read only and writable memory.
- a user 102 can use the client device 104 to submit a query 110 to a search system 114 .
- a search engine 130 within the search system 114 performs a search to identify resources matching the query.
- the query 110 may be transmitted through the network 112 to the search system 114 .
- the query can include natural language, image, video, audio, a representation of a data element, and/or other data types.
- a query can itself be transformed into a query representation (e.g., using a model similar to (e.g., trained jointly with) the model that transforms data elements into representations (e.g., embeddings), as described in further detail below.
- the search system 114 responds to the query 110 by generating search results 128 , which are transmitted through the network to the client device 104 for presentation to the user 102 , e.g., as a search results web page to be displayed by a web browser running on the client device 104 .
- the client device 104 may be running a dedicated application (e.g., mobile application) that is specifically designed to interact with the search system 114 .
- An example search result can include a web page title, a snippet of text or a portion of an image extracted from the web page, and the Uniform Resource Locator (URL) of the web page or other relevant resource, for example.
- the snippet of text from a web page or other resource can contain, for example, one or more contiguous (e.g., adjacent words or sentences) or non-contiguous portions of text.
- Another example search result can include a title of a stored video, a thumbnail or frame extracted from the video, and the Uniform Resource Locator (URL) of the stored video.
- data elements can correspond to videos, images, webpages, files, entities, and/or other data elements.
- the search system 114 includes a first search index stored in a first set of storage media 160 and a second search index stored in a second set of storage media 162 .
- the search system 114 also includes search engine 130 .
- the first search index 160 stored in the first set of storage media can be referred to as a first database while the second search index 162 stored in the second set of storage media can be referred to as a second database.
- databases will be used broadly to refer to any collection of data: the data does not need to be structured in any particular way, or structured at all, and it can be stored on storage devices in one or more locations. Thus, for example, databases can include multiple collections of data, each of which may be organized and accessed differently.
- engine will be used broadly to refer to a software-based system or subsystem that can perform one or more specific functions. Generally, an engine will be implemented as one or more software modules or components, installed on one or more computers in one or more locations. In some cases, one or more computers will be dedicated to a particular engine; in other cases, multiple engines can be installed and running on the same computer or computers.
- the search engine 130 identifies resources that satisfy the query 110 .
- the search engine 130 can perform a retrieval algorithm with respect to data elements stored in the first search index 160 and/or the second search index 162 .
- the search engine 130 can generally include an indexing engine 120 that indexes resources (e.g., data elements included in a dataset), the indices 160 and 162 that store the indexed information, and a ranking engine 152 or other software that generates scores for the resources that satisfy the query 110 and that ranks the resources according to their respective scores.
- the indices 160 and 162 can store one or more indexed representations for each of a number of data elements included in a dataset.
- the indexed representation(s) for each data element can correspond to embeddings that have been generated from at least a portion of the data elements.
- an “embedding” can be a learned representation of a data element that is expressed (e.g., as a numerical vector) in a learned latent space.
- the indexing engine 120 can include a machine-learned embedding generation model that can generate the embeddings for the data elements.
- An embedding can be generated for the data element as a whole or can be generated for a portion of the data element (e.g., one or more frames extracted from a larger video).
- the indexed representation(s) for each data element can correspond to other forms of encodings of the data elements. In other examples, the indexed representation(s) for each data element can correspond to the raw data elements themselves.
- the indexing of a dataset can occur over a number of storage periods. During the pendency of each storage period, any new data elements that are added to the dataset can be indexed by the indexing engine 120 into the first data index 160 , while the majority (e.g., all) of the existing data elements of dataset can be indexed in the second data index 162 .
- the new data elements included in the first data index 160 can be transferred from the first data index 160 stored by the first set of storage media to the second data index 162 stored by the second set of storage media. Additionally or alternatively, all of the data elements indexed in the second data index 162 can be updated (e.g., recomputed or otherwise re-indexed).
- an information retrieval index can be split into two (e.g., partially overlapping) parts: fresh data stored in first data index 160 (e.g., including new data elements introduced within the most recent storage period (e.g., the last 30 days)) and stable data stored in second data index 162 (e.g., including all data elements existing in the dataset except those introduced within at least a portion of the most recent storage period (e.g., except elements introduced within the last 7 days).
- fresh data stored in first data index 160 e.g., including new data elements introduced within the most recent storage period (e.g., the last 30 days)
- stable data stored in second data index 162 e.g., including all data elements existing in the dataset except those introduced within at least a portion of the most recent storage period (e.g., except elements introduced within the last 7 days).
- the first data index 160 can be stored on storage media having relatively lower latency but higher operational cost (e.g., RAM), while the second data index 162 can be stored on storage media having relatively higher latency but lower operational cost (e.g., SSD).
- One benefit of such a split is that the search system 114 needs to support (complex) instant updates of only the small fresh first data index 160 .
- the search system 114 e.g., the indexing engine 120
- FIG. 2 is a diagram of an example client or server entity (hereinafter called “client/server entity”), which may correspond to one or more of clients 104 and/or search system 114 , according to an implementation consistent with the principles of the invention.
- the client/server entity may include a bus 210 , a processor 220 , a main memory 230 , a read only memory (ROM) 240 , a storage device 250 , an input device 260 , an output device 270 , and a communication interface 280 .
- Bus 210 may include a path that permits communication among the elements of the client/server entity.
- Processor 220 may include a conventional processor, microprocessor, or processing logic that interprets and executes instructions.
- Main memory 230 may include a random access memory (RAM) or another type of dynamic storage device that may store information and instructions for execution by processor 220 .
- ROM 240 may include a conventional ROM device or another type of static storage device that may store static information and instructions for use by processor 220 .
- Storage device 250 may include a magnetic and/or optical recording medium and its corresponding drive.
- Input device 260 may include a conventional mechanism that permits an operator to input information to the client/server entity, such as a keyboard, a mouse, a pen, voice recognition and/or biometric mechanisms, etc.
- Output device 270 may include a conventional mechanism that outputs information to the operator, including a display, a printer, a speaker, etc.
- Communication interface 280 may include any transceiver-like mechanism that enables the client/server entity to communicate with other devices and/or systems.
- communication interface 280 may include mechanisms for communicating with another device or system via one or more communications networks.
- the client/server entity may perform certain searching-related operations.
- the client/server entity may perform these operations in response to processor 220 executing software instructions contained in a computer-readable medium, such as memory 230 .
- a computer-readable medium may be defined as a physical or logical memory device and/or carrier wave.
- the software instructions may be read into memory 230 from another computer-readable medium, such as data storage device 250 , or from another device via communication interface 280 .
- the software instructions contained in memory 230 may cause processor 220 to perform processes that will be described later.
- hardwired circuitry may be used in place of or in combination with software instructions to implement processes consistent with the principles of the invention.
- implementations consistent with the principles of the invention are not limited to any specific combination of hardware circuitry and software.
- FIG. 3 depicts a graphical representation of a process for indexing data elements according to example embodiments of the present disclosure.
- a computing system e.g., the indexing engine 120 of FIG. 1
- the first set of storage media can be or include Random Access Memory (RAM) storage media
- the second set of storage media can be or include solid State Drive (SSD) storage media.
- RAM Random Access Memory
- SSD solid State Drive
- the first data index 160 and second data index and 162 can be updated over a number of storage periods.
- a storage period can be one day, one week, one month, or other measures of time.
- storage periods can be triggered by the accumulation of a threshold amount of data and/or other dynamic characteristics or attributes.
- storage periods can be defined or dynamically managed based on various data retention requirements.
- any additional data elements that are added to the dataset can be indexed in the first data index 160 .
- a representation 300 of a newly added data element is added to the first data index 160 .
- an additional or newly added data element refers to a data element that is being newly indexed into the index of the dataset; the data element may or may not have been in existence or generally included in the dataset prior to the indexing event; but is considered “additional” or “newly added” to the dataset when indexed for the first time.
- the first data index 160 can be referred to as a fresh data index.
- the second data index 162 can include representations of data elements that have been indexed in previous storage periods.
- the second data index 162 can include data elements 308 - 316 , which have been indexed in previous storage periods.
- the computing system e.g., the indexing engine 120 of FIG. 1
- the computing system can transfer some or all of the additional data elements contained in the first data index 160 stored by the first set of storage media to the second data index 162 stored by the second set of storage media.
- any representation that has been stored in the first data index 160 for greater than a threshold amount of time can be transferred from the first data index 160 to the second data index 162 .
- the transferred data representations may still be maintained in the first data index 160 until expiration of the storage period.
- a storage period may be 30 days while the threshold amount of time may be 7 days.
- any representation that has been stored in the first data index 160 for 7 or more days may be transferred to the second data index 162 , yet also maintained in the first data index 160 until expiration of the storage period (e.g., or some other trigger such as expiration of a second threshold amount of time that is greater than the first).
- representations 304 and 306 may have been stored in the first data index 160 for greater than the threshold amount of time and therefore may be transferred to the second data index 162 while still being maintained in the first data index 160 .
- the first data index 160 and the second data index 162 may be partially overlapping.
- representations 300 and 302 may have been stored in the first data index 160 for less than the threshold amount of time. Therefore, representations 300 and 302 can be stored in the first data index 160 only.
- the computing system e.g., the indexing engine 120 of FIG. 1
- the computing system can recompute some or all of the second data index 162 .
- the second data index 162 can also include any representations that were previously included in the first data index 160 (e.g., including representations 300 - 306 ).
- re-computation may include updating or determining a new representation for every data element.
- a plurality of centroids 350 can be stored in the first set of storage media alongside the first data index 160 .
- the plurality of centroids 350 can respectively correspond to a plurality of partitions of the existing data elements included in the second data index 162 stored by the second set of storage media.
- the centroids 350 can be used to perform a hierarchical retrieval technique (e.g., such as a hierarchical nearest neighbor search).
- the hierarchical retrieval technique can include identifying one or more of the centroids 350 stored by the first set of storage media based on the query.
- the hierarchical retrieval technique can include accessing, from the second set of storage media, only the data elements included in the one or more of the partitions respectively associated with the one or more of the centroids 350 identified based on the query.
- Hierarchical retrieval techniques of this nature can identify results that are responsive to the query with reduced computational costs (e.g., by evaluating only a smaller subset of the indexed data elements included in the identified partition(s), rather than all indexed data elements). Further, because the centroids 350 are maintained in the first set of storage media having the lower latency, they can be accessed and/or updated faster and with reduced computational cost. In some implementations, during a storage period or upon the expiration of a storage period, the centroids 350 can be re-computed (e.g., using k-means partitioning). For example, the centroids 350 can be re-computed to account for the newly added representations 300 - 306 .
- FIG. 4 depicts a graphical diagram of an example hierarchical retrieval technique according to example embodiments of the present disclosure. Items illustrated above the horizontal dashed line in FIG. 4 are stored in the first set of storage media (e.g., RAM); while items illustrated below the horizontal dashed line are stored in the second set of storage media (e.g., SSD).
- the first set of storage media e.g., RAM
- the second set of storage media e.g., SSD
- centroids have been defined. For example, three centroids 402 , 404 , and 406 are shown. A number of representations of data elements are associated with each centroid. For example, representations 408 - 410 are associated with centroid 402 ; representations 412 - 414 and 420 are associated with centroid 402 ; and representations 416 - 418 and 422 are associated with centroid 406 .
- the representations may be stored in different data indices.
- representations 408 - 418 may be existing representations stored in a second data index stored by the second set of storage media; while representations 420 and 422 may be newly added representations that are stored in a first data index stored by the first set of storage media.
- the number of centroids and representations is greatly simplified for the purposes of illustration.
- a query 400 When a query 400 is received, it is first compared with some or all of the centroids. For example, comparison may include computation of a distance or difference in vector space (e.g., a cosine similarity). Some subset of the “closest” (e.g., smallest distance or difference) or most similar centroids may be identified. For example, centroids 404 and 406 may be identified. Then, only the representations associated with the identified centroids may be evaluated. For example, representations 412 - 422 may be evaluated (but representations 408 - 410 may not be evaluated). Some number of the closest representations may be identified (e.g., representations 412 , 414 , and 416 may be identified as responsive to the query 400 ).
- a distance or difference in vector space e.g., a cosine similarity
- centroids can be generated which further partition the centroids in the layer(s) below.
- additional layer(s) can be similarly stored in the first set of storage media.
- FIG. 5 depicts a flow chart diagram of an example method to index data elements according to example embodiments of the present disclosure.
- a computing system e.g., the indexing engine 120 of FIG. 1
- the computing system e.g., the indexing engine 120 of FIG. 1
- the computing system can maintain a second data index on a second set of storage media.
- the computing system e.g., the indexing engine 120 of FIG. 1
- the computing system can initiate a new storage period.
- the computing system e.g., the indexing engine 120 of FIG. 1
- the computing system can determine whether a new data element has been received or added to the dataset. If yes, method 500 can proceed to 508 . If no, method 500 can proceed to 510 .
- the computing system e.g., the indexing engine 120 of FIG. 1
- the computing system can index the new data element in the first data index.
- the computing system e.g., the indexing engine 120 of FIG. 1
- the computing system can determine whether the current storage period has expired. If no, method 500 can proceed to 512 .
- the computing system e.g., the indexing engine 120 of FIG. 1
- the computing system can evaluate representations included in the first data index for transfer for parallel storage in the second data index and can perform the transfer(s) where appropriate. For example, any representation(s) that have been stored in the first data index for greater than a threshold period of time (e.g., which may be less than a storage period) can be transferred for storage in the second data index, but may, in some implementations, also remain in the first data index.
- a threshold period of time e.g., which may be less than a storage period
- method 500 can return to 506 .
- method 500 can proceed to 514 .
- the computing system can transfer all representations from the first data index to the second data index.
- step 514 can include deleting the representations from the first data index.
- step 514 can include recomputing some or all of the second data index so as to include the representations previously included in the first data index.
- method 500 can return to 505 and initiate a new storage period.
- the technology discussed herein makes reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and from such systems.
- the inherent flexibility of computer-based systems allows for a great variety of possible configurations, combinations, and divisions of tasks and functionality between and among components.
- processes discussed herein can be implemented using a single device or component or multiple devices or components working in combination.
- Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
Abstract
Provided is a scalable and cost-efficient storage architecture for large-scale datasets, such as Internet-scale datasets that include very large numbers (e.g., billions) of data elements. More particularly, provided is a bifurcated storage architecture that includes a first data index stored by a first set of storage media and a second data index stored by a second set of storage media, where the first set of storage media has a lower latency than the second set of storage media.
Description
- The present disclosure relates generally to a scalable and cost-efficient information retrieval for large-scale datasets. More particularly, the present disclosure relates to a bifurcated information retrieval architecture that includes multiple data indices stored on multiple different sets of storage media having differing latency characteristics.
- Search engine indexing refers to the collecting, parsing, and storing of data within an index to facilitate fast and accurate information retrieval. Specifically, an index can be generated for a dataset that includes a number of data elements, such as webpages or other documents, images, videos, audio files, data files, entities, and/or other data elements in a dataset. One purpose of generating and storing an index is to optimize speed and performance in finding and returning relevant data elements that are potentially responsive to a search query.
- In some settings, a dataset can include a massive number (e.g., millions or billions) of data elements. One example is Internet-scale datasets which seek to index (approximately) all data elements (e.g., webpages, videos, etc.) across the entire Internet. In another example, large, globally popular data sharing platforms (e.g., video sharing platforms) may include massive numbers of data elements (e.g., hundreds of millions of videos).
- In general, there are a number of different storage mediums which offer different benefits and challenges when used to store a data index. As one example, storage media (e.g., such as Random Access Memory (RAM)) that offers low latency may enable faster retrieval of results from the index and may be more applicable to indexing and retrieval techniques that require dynamic changes or updates to the index. However, RAM and other low-latency media have significant operational cost and therefore it is typically infeasible to use these media to store the index of a massive dataset. As another example, other storage media (e.g., such as Solid State Drive (SSD) or “flash”) may have a relatively higher latency, but a more reasonable operational cost. Therefore, these media are more likely to be used to store the index of a massive dataset. However, SSD or other similar storage media may not be applicable to indexing and retrieval techniques that require dynamic changes or updates to the index.
- Aspects and advantages of embodiments of the present disclosure will be set forth in part in the following description, or can be learned from the description, or can be learned through practice of the embodiments.
- One example aspect of the present disclosure is directed to a computer-implemented method for indexing a dataset comprising a large number of data elements. The method includes, for each of a plurality of storage periods: maintaining, by a computing system, a first data index stored by a first set of storage media having a first latency associated therewith; and maintaining, by the computing system, a second data index stored by a second set of storage media having a second latency associated therewith, the second latency being greater than the first latency, the second data index containing existing data elements included in the dataset. During pendency of the storage period, the method includes receiving, by the computing system, one or more additional data elements that have been added to the dataset; and indexing, by the computing system, one or more representations of the one or more additional data elements in the first data index stored by the first set of storage media. During pendency of the storage period or upon expiration of the storage period, the method includes transferring, by the computing system, the one or more representations of the one or more additional data elements contained in the first data index stored by the first set of storage media to the second data index stored by the second set of storage media.
- Another example aspect of the present disclosure is directed to a computing system. The computing system includes a first set of storage media that stores a first data index, the first set of storage media having a first latency associated therewith. The computing system includes a second set of storage media that stores a second data index, the second set of storage media having a second latency associated therewith, the second latency being greater than the first latency, the second data index containing existing data elements included in a dataset. The computing system includes one or more processors and one or more non-transitory computer-readable media that store instructions that, when executed by the one or more processors, cause the computing system to perform operations. The operations include, during pendency of a storage period: receiving, by the computing system, one or more additional data elements that have been added to the dataset; and indexing, by the computing system, one or more representations of the one or more additional data elements in the first data index stored by the first set of storage media. The operations include, during pendency of the storage period or upon expiration of the storage period: transferring, by the computing system, the one or more representations of the one or more additional data elements contained in the first data index stored by the first set of storage media to the second data index stored by the second set of storage media.
- Another example aspect of the present disclosure is directed to one or more non-transitory computer-readable media that store instructions that, when executed by one or more processors, cause the one or more processors to perform operations. The operations include, for each of a plurality of storage periods: maintaining, by a computing system, a first data index stored by a first set of storage media having a first latency associated therewith; and maintaining, by the computing system, a second data index stored by a second set of storage media having a second latency associated therewith, the second latency being greater than the first latency, the second data index containing existing data elements included in a dataset. The operations include, during pendency of the storage period: receiving, by the computing system, one or more additional data elements that have been added to the dataset; and indexing, by the computing system, one or more representations of the one or more additional data elements in the first data index stored by the first set of storage media. The operations include, during pendency of the storage period or upon expiration of the storage period: transferring, by the computing system, the one or more representations of the one or more additional data elements contained in the first data index stored by the first set of storage media to the second data index stored by the second set of storage media.
- Other aspects of the present disclosure are directed to various systems, apparatuses, non-transitory computer-readable media, user interfaces, and electronic devices.
- These and other features, aspects, and advantages of various embodiments of the present disclosure will become better understood with reference to the following description and appended claims. The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate example embodiments of the present disclosure and, together with the description, serve to explain the related principles.
- Detailed discussion of embodiments directed to one of ordinary skill in the art is set forth in the specification, which makes reference to the appended FIGs., in which:
-
FIG. 1 depicts a block diagram of an example computing system according to example embodiments of the present disclosure. -
FIG. 2 depicts a block diagram of an example computing device according to example embodiments of the present disclosure. -
FIG. 3 depicts a graphical representation of a process for indexing data elements according to example embodiments of the present disclosure. -
FIG. 4 depicts a graphical diagram of an example hierarchical retrieval technique according to example embodiments of the present disclosure. -
FIG. 5 depicts a flow chart diagram of an example method to index data elements according to example embodiments of the present disclosure - Reference numerals that are repeated across plural FIG.s are intended to identify the same features in various implementations.
- Generally, the present disclosure is directed to a scalable and cost-efficient storage architecture for large-scale datasets, such as Internet-scale datasets that include very large numbers (e.g., billions) of data elements. More particularly, the present disclosure relates to a bifurcated storage architecture that includes a first data index stored by a first set of storage media and a second data index stored by a second set of storage media, where the first set of storage media has a lower latency than the second set of storage media.
- According to an aspect of the present disclosure, the indexing of the dataset can occur over a number of storage periods. During the pendency of each storage period, any new data elements that are added to the dataset can be indexed into the first data index, while the majority (e.g., all) of the existing data elements of dataset can be indexed in the second data index. Then, upon expiration of the storage period, the new data elements included in the first data index can be transferred from the first data index stored by the first set of storage media to the second data index stored by the second set of storage media. Additionally or alternatively, all of the data elements indexed in the second data index can be updated (e.g., recomputed or otherwise re-indexed).
- Thus, in some implementations, an information retrieval index can be split into two (e.g., partially overlapping) parts: fresh (e.g., new data elements introduced within the most recent storage period (e.g., the last 30 days)) and stable (e.g., all data elements existing in the dataset except those introduced within at least a portion of the most recent storage period (e.g., except elements introduced within the last 7 days).
- Furthermore, the fresh index can be stored on storage media having relatively lower latency and higher applicability to dynamic updates, but higher operational cost (e.g., RAM). On the other hand, the stable index can be stored on storage media having relatively higher latency and lower applicability to dynamic updates, but lower operational cost (e.g., SSD). One benefit of such a split is that the retrieval system needs to support (complex) instant updates of only the small fresh index. The retrieval system can then update the larger stable index periodically by recomputing new versions of the entire served dataset at once.
- Furthermore, according to another aspect, in some implementations, a plurality of centroids can be stored in the first set of storage media. The plurality of centroids can respectively correspond to a plurality of partitions of the existing data elements included in the second data index stored by the second set of storage media. For example, the centroids can be used to perform a hierarchical retrieval technique (e.g., such as a hierarchical nearest neighbor search).
- As an example, in some implementations, the hierarchical retrieval technique first can include identifying one or more of the centroids stored by the first set of storage media based on the query. Next, the hierarchical retrieval technique can include accessing, from the second set of storage media, only the data elements included in the one or more of the partitions respectively associated with the one or more centroids identified based on the query.
- Hierarchical retrieval techniques of this nature can identify results that are responsive to the query with reduced computational costs (e.g., by evaluating only a smaller subset of the indexed data elements included in the identified partition(s), rather than all indexed data elements). Further, because the centroids are maintained in the first set of storage media having the lower latency, they can be accessed and/or updated faster and with reduced computational cost.
- The proposed approach provides a number of technical effects and benefits. In particular, as discussed above, there are a number of different storage mediums which offer different benefits and challenges when used to store a data index. By maintaining the large majority of data elements in a set of storage media that have relatively lower operational cost, but also introducing new elements via storage in a set of storage media that is more amenable to dynamic changes, an improved balance can be struck between latency and operational cost.
- For example, while storing all representations in a second set of storage media that has relatively lower operational cost may be ideal; a problem arises in as much as these types of storage media may not natively support online updates. Therefore, by using a first set of storage media that is more amenable to dynamic updates to handle newly indexed data elements while periodically updating the full set of representations on the second set of storage media, the benefits of each style of storage media can be obtained in a more computationally efficient manner. Further, as discussed above, a hierarchical retrieval algorithm can be used to obtain the benefits of each style of storage media.
- Thus, the present disclosure provides an architecture for scalable and cost-efficient matching which stores a majority of indexed data on (e.g., remote) SSD. The proposed approach allows an information retrieval system to support low query-per-second (QPS) use-cases (e.g., detection and removal of objectionable content) with low operational cost (e.g., due to total SSD operational cost required being very low even at massive scale). The proposed approaches open up the previously inaccessible option of performing a matching or search query against all elements in a massive dataset. High QPS use cases may also remain efficient through the use of hierarchical retrieval techniques that efficiently leverage multiple different types of storage media.
- With reference now to the FIGS., example embodiments of the present disclosure will be discussed in further detail.
-
FIG. 1 shows anexample search system 114. Thesearch system 114 is an example of an information retrieval system implemented as one or more computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below can be implemented. - A
user 102 can interact with thesearch system 114 through aclient device 104. For example, theclient device 104 can be a computer coupled to thesearch system 114 through adata communication network 112, e.g., local area network (LAN) or wide area network (WAN), e.g., the Internet, or a combination of networks. - In some cases, the
search system 114 can be implemented on theclient device 104, for example, if a user installs an application that performs searches on theclient device 104. Theclient device 104 will generally include a memory, e.g., a random access memory (RAM) 106, for storing instructions and data and aprocessor 108 for executing stored instructions. The memory can include both read only and writable memory. - A
user 102 can use theclient device 104 to submit aquery 110 to asearch system 114. Asearch engine 130 within thesearch system 114 performs a search to identify resources matching the query. When theuser 102 submits aquery 110, thequery 110 may be transmitted through thenetwork 112 to thesearch system 114. The query can include natural language, image, video, audio, a representation of a data element, and/or other data types. In some implementations, a query can itself be transformed into a query representation (e.g., using a model similar to (e.g., trained jointly with) the model that transforms data elements into representations (e.g., embeddings), as described in further detail below. - The
search system 114 responds to thequery 110 by generatingsearch results 128, which are transmitted through the network to theclient device 104 for presentation to theuser 102, e.g., as a search results web page to be displayed by a web browser running on theclient device 104. In another example, rather than a web browser application, theclient device 104 may be running a dedicated application (e.g., mobile application) that is specifically designed to interact with thesearch system 114. - An example search result can include a web page title, a snippet of text or a portion of an image extracted from the web page, and the Uniform Resource Locator (URL) of the web page or other relevant resource, for example. The snippet of text from a web page or other resource can contain, for example, one or more contiguous (e.g., adjacent words or sentences) or non-contiguous portions of text. Another example search result can include a title of a stored video, a thumbnail or frame extracted from the video, and the Uniform Resource Locator (URL) of the stored video. Many other examples are possible within the context of an information retrieval system. For example, data elements can correspond to videos, images, webpages, files, entities, and/or other data elements.
- The
search system 114 includes a first search index stored in a first set ofstorage media 160 and a second search index stored in a second set ofstorage media 162. Thesearch system 114 also includessearch engine 130. In some instances, thefirst search index 160 stored in the first set of storage media can be referred to as a first database while thesecond search index 162 stored in the second set of storage media can be referred to as a second database. - In this specification, the term “database” will be used broadly to refer to any collection of data: the data does not need to be structured in any particular way, or structured at all, and it can be stored on storage devices in one or more locations. Thus, for example, databases can include multiple collections of data, each of which may be organized and accessed differently. Similarly, in this specification the term “engine” will be used broadly to refer to a software-based system or subsystem that can perform one or more specific functions. Generally, an engine will be implemented as one or more software modules or components, installed on one or more computers in one or more locations. In some cases, one or more computers will be dedicated to a particular engine; in other cases, multiple engines can be installed and running on the same computer or computers.
- When the
query 110 is received by thesearch engine 130, thesearch engine 130 identifies resources that satisfy thequery 110. For example, thesearch engine 130 can perform a retrieval algorithm with respect to data elements stored in thefirst search index 160 and/or thesecond search index 162. Specifically, as an example, thesearch engine 130 can generally include anindexing engine 120 that indexes resources (e.g., data elements included in a dataset), theindices ranking engine 152 or other software that generates scores for the resources that satisfy thequery 110 and that ranks the resources according to their respective scores. - More particularly, the
indices indexing engine 120 can include a machine-learned embedding generation model that can generate the embeddings for the data elements. An embedding can be generated for the data element as a whole or can be generated for a portion of the data element (e.g., one or more frames extracted from a larger video). - In other examples, the indexed representation(s) for each data element can correspond to other forms of encodings of the data elements. In other examples, the indexed representation(s) for each data element can correspond to the raw data elements themselves.
- According to an aspect of the present disclosure, the indexing of a dataset (e.g., by the
indexing engine 120 into theindices 160 and 162) can occur over a number of storage periods. During the pendency of each storage period, any new data elements that are added to the dataset can be indexed by theindexing engine 120 into thefirst data index 160, while the majority (e.g., all) of the existing data elements of dataset can be indexed in thesecond data index 162. - Then, upon expiration of the storage period, the new data elements included in the
first data index 160 can be transferred from thefirst data index 160 stored by the first set of storage media to thesecond data index 162 stored by the second set of storage media. Additionally or alternatively, all of the data elements indexed in thesecond data index 162 can be updated (e.g., recomputed or otherwise re-indexed). - Thus, in some implementations, an information retrieval index can be split into two (e.g., partially overlapping) parts: fresh data stored in first data index 160 (e.g., including new data elements introduced within the most recent storage period (e.g., the last 30 days)) and stable data stored in second data index 162 (e.g., including all data elements existing in the dataset except those introduced within at least a portion of the most recent storage period (e.g., except elements introduced within the last 7 days).
- Furthermore, the
first data index 160 can be stored on storage media having relatively lower latency but higher operational cost (e.g., RAM), while thesecond data index 162 can be stored on storage media having relatively higher latency but lower operational cost (e.g., SSD). One benefit of such a split is that thesearch system 114 needs to support (complex) instant updates of only the small freshfirst data index 160. The search system 114 (e.g., the indexing engine 120) can then update the larger stablesecond data index 162 periodically by recomputing a new version of the entire served dataset at once. -
FIG. 2 is a diagram of an example client or server entity (hereinafter called “client/server entity”), which may correspond to one or more ofclients 104 and/orsearch system 114, according to an implementation consistent with the principles of the invention. The client/server entity may include abus 210, aprocessor 220, amain memory 230, a read only memory (ROM) 240, astorage device 250, aninput device 260, anoutput device 270, and acommunication interface 280.Bus 210 may include a path that permits communication among the elements of the client/server entity. -
Processor 220 may include a conventional processor, microprocessor, or processing logic that interprets and executes instructions.Main memory 230 may include a random access memory (RAM) or another type of dynamic storage device that may store information and instructions for execution byprocessor 220.ROM 240 may include a conventional ROM device or another type of static storage device that may store static information and instructions for use byprocessor 220.Storage device 250 may include a magnetic and/or optical recording medium and its corresponding drive. -
Input device 260 may include a conventional mechanism that permits an operator to input information to the client/server entity, such as a keyboard, a mouse, a pen, voice recognition and/or biometric mechanisms, etc.Output device 270 may include a conventional mechanism that outputs information to the operator, including a display, a printer, a speaker, etc.Communication interface 280 may include any transceiver-like mechanism that enables the client/server entity to communicate with other devices and/or systems. For example,communication interface 280 may include mechanisms for communicating with another device or system via one or more communications networks. - As will be described in detail below, the client/server entity, consistent with the principles of the invention, may perform certain searching-related operations. The client/server entity may perform these operations in response to
processor 220 executing software instructions contained in a computer-readable medium, such asmemory 230. A computer-readable medium may be defined as a physical or logical memory device and/or carrier wave. - The software instructions may be read into
memory 230 from another computer-readable medium, such asdata storage device 250, or from another device viacommunication interface 280. The software instructions contained inmemory 230 may causeprocessor 220 to perform processes that will be described later. Alternatively, hardwired circuitry may be used in place of or in combination with software instructions to implement processes consistent with the principles of the invention. Thus, implementations consistent with the principles of the invention are not limited to any specific combination of hardware circuitry and software. -
FIG. 3 depicts a graphical representation of a process for indexing data elements according to example embodiments of the present disclosure. In particular, as shown inFIG. 3 , a computing system (e.g., theindexing engine 120 ofFIG. 1 ) can maintain afirst data index 160 stored in a first set of storage media and asecond data index 162 stored in a second set of storage media. As examples, the first set of storage media can be or include Random Access Memory (RAM) storage media; and the second set of storage media can be or include solid State Drive (SSD) storage media. - In some implementations, the
first data index 160 and second data index and 162 can be updated over a number of storage periods. As one example, a storage period can be one day, one week, one month, or other measures of time. In other examples, storage periods can be triggered by the accumulation of a threshold amount of data and/or other dynamic characteristics or attributes. In other examples, storage periods can be defined or dynamically managed based on various data retention requirements. - In some implementations, during pendency of a given storage period, any additional data elements that are added to the dataset can be indexed in the
first data index 160. For example, as illustrated inFIG. 3 , arepresentation 300 of a newly added data element is added to thefirst data index 160. As used herein, an additional or newly added data element refers to a data element that is being newly indexed into the index of the dataset; the data element may or may not have been in existence or generally included in the dataset prior to the indexing event; but is considered “additional” or “newly added” to the dataset when indexed for the first time. Thus, in some implementations, thefirst data index 160 can be referred to as a fresh data index. - The
second data index 162 can include representations of data elements that have been indexed in previous storage periods. For example, as illustrated inFIG. 3 , thesecond data index 162 can include data elements 308-316, which have been indexed in previous storage periods. - Referring still to
FIG. 3 , during pendency of the storage period or upon expiration of the storage period, the computing system (e.g., theindexing engine 120 ofFIG. 1 ) can transfer some or all of the additional data elements contained in thefirst data index 160 stored by the first set of storage media to thesecond data index 162 stored by the second set of storage media. - As one example, in some implementations, during pendency of the storage period, any representation that has been stored in the
first data index 160 for greater than a threshold amount of time (e.g., but less than the entirety of a storage period) can be transferred from thefirst data index 160 to thesecond data index 162. However, in some implementations, the transferred data representations may still be maintained in thefirst data index 160 until expiration of the storage period. As examples, a storage period may be 30 days while the threshold amount of time may be 7 days. - Thus, in some implementations, any representation that has been stored in the
first data index 160 for 7 or more days may be transferred to thesecond data index 162, yet also maintained in thefirst data index 160 until expiration of the storage period (e.g., or some other trigger such as expiration of a second threshold amount of time that is greater than the first). - As examples, as illustrated in
FIG. 3 ,representations first data index 160 for greater than the threshold amount of time and therefore may be transferred to thesecond data index 162 while still being maintained in thefirst data index 160. Thus, in some implementations, thefirst data index 160 and thesecond data index 162 may be partially overlapping. However,representations first data index 160 for less than the threshold amount of time. Therefore,representations first data index 160 only. - In some implementations, upon the expiration of the storage period, the computing system (e.g., the
indexing engine 120 ofFIG. 1 ) can recompute some or all of thesecond data index 162. For example, following re-computation, thesecond data index 162 can also include any representations that were previously included in the first data index 160 (e.g., including representations 300-306). In some implementations, re-computation may include updating or determining a new representation for every data element. - Furthermore, according to another aspect, in some implementations, a plurality of
centroids 350 can be stored in the first set of storage media alongside thefirst data index 160. The plurality ofcentroids 350 can respectively correspond to a plurality of partitions of the existing data elements included in thesecond data index 162 stored by the second set of storage media. For example, thecentroids 350 can be used to perform a hierarchical retrieval technique (e.g., such as a hierarchical nearest neighbor search). - For example, first, the hierarchical retrieval technique can include identifying one or more of the
centroids 350 stored by the first set of storage media based on the query. Next, the hierarchical retrieval technique can include accessing, from the second set of storage media, only the data elements included in the one or more of the partitions respectively associated with the one or more of thecentroids 350 identified based on the query. - Hierarchical retrieval techniques of this nature can identify results that are responsive to the query with reduced computational costs (e.g., by evaluating only a smaller subset of the indexed data elements included in the identified partition(s), rather than all indexed data elements). Further, because the
centroids 350 are maintained in the first set of storage media having the lower latency, they can be accessed and/or updated faster and with reduced computational cost. In some implementations, during a storage period or upon the expiration of a storage period, thecentroids 350 can be re-computed (e.g., using k-means partitioning). For example, thecentroids 350 can be re-computed to account for the newly added representations 300-306. - As one example,
FIG. 4 depicts a graphical diagram of an example hierarchical retrieval technique according to example embodiments of the present disclosure. Items illustrated above the horizontal dashed line inFIG. 4 are stored in the first set of storage media (e.g., RAM); while items illustrated below the horizontal dashed line are stored in the second set of storage media (e.g., SSD). - Specifically, in the simplified example of
FIG. 4 , a number of centroids have been defined. For example, threecentroids centroid 402; representations 412-414 and 420 are associated withcentroid 402; and representations 416-418 and 422 are associated withcentroid 406. The representations may be stored in different data indices. For example, representations 408-418 may be existing representations stored in a second data index stored by the second set of storage media; whilerepresentations - When a
query 400 is received, it is first compared with some or all of the centroids. For example, comparison may include computation of a distance or difference in vector space (e.g., a cosine similarity). Some subset of the “closest” (e.g., smallest distance or difference) or most similar centroids may be identified. For example,centroids representations - Although only a two-layer hierarchy is shown, larger or more complex hierarchies can be used instead. For example, additional layer(s) of centroids can be generated which further partition the centroids in the layer(s) below. These additional layer(s) can be similarly stored in the first set of storage media.
-
FIG. 5 depicts a flow chart diagram of an example method to index data elements according to example embodiments of the present disclosure. - At 502, a computing system (e.g., the
indexing engine 120 ofFIG. 1 ) can maintain a first data index on a first set of storage media. - At 504, the computing system (e.g., the
indexing engine 120 ofFIG. 1 ) can maintain a second data index on a second set of storage media. - At 505, the computing system (e.g., the
indexing engine 120 ofFIG. 1 ) can initiate a new storage period. - At 506, the computing system (e.g., the
indexing engine 120 ofFIG. 1 ) can determine whether a new data element has been received or added to the dataset. If yes,method 500 can proceed to 508. If no,method 500 can proceed to 510. - At 508, the computing system (e.g., the
indexing engine 120 ofFIG. 1 ) can index the new data element in the first data index. - At 510, the computing system (e.g., the
indexing engine 120 ofFIG. 1 ) can determine whether the current storage period has expired. If no,method 500 can proceed to 512. - At 512, the computing system (e.g., the
indexing engine 120 ofFIG. 1 ) can evaluate representations included in the first data index for transfer for parallel storage in the second data index and can perform the transfer(s) where appropriate. For example, any representation(s) that have been stored in the first data index for greater than a threshold period of time (e.g., which may be less than a storage period) can be transferred for storage in the second data index, but may, in some implementations, also remain in the first data index. After 512,method 500 can return to 506. - Referring again to 510, if it is determined at 510 that the current storage period has expired, then
method 500 can proceed to 514. - At 514, the computing system (e.g., the
indexing engine 120 ofFIG. 1 ) can transfer all representations from the first data index to the second data index. In some implementations, step 514 can include deleting the representations from the first data index. In some implementations, step 514 can include recomputing some or all of the second data index so as to include the representations previously included in the first data index. - After 514,
method 500 can return to 505 and initiate a new storage period. - The technology discussed herein makes reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and from such systems. The inherent flexibility of computer-based systems allows for a great variety of possible configurations, combinations, and divisions of tasks and functionality between and among components. For instance, processes discussed herein can be implemented using a single device or component or multiple devices or components working in combination. Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
- While the present subject matter has been described in detail with respect to various specific example embodiments thereof, each example is provided by way of explanation, not limitation of the disclosure. Those skilled in the art, upon attaining an understanding of the foregoing, can readily produce alterations to, variations of, and equivalents to such embodiments. Accordingly, the subject disclosure does not preclude inclusion of such modifications, variations and/or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art. For instance, features illustrated or described as part of one embodiment can be used with another embodiment to yield a still further embodiment. Thus, it is intended that the present disclosure cover such alterations, variations, and equivalents.
Claims (20)
1. A computer-implemented method for indexing a dataset comprising a large number of data elements, the method comprising:
for each of a plurality of storage periods:
maintaining, by a computing system, a first data index stored by a first set of storage media having a first latency associated therewith;
maintaining, by the computing system, a second data index stored by a second set of storage media having a second latency associated therewith, the second latency being greater than the first latency, the second data index containing existing data elements included in the dataset;
during pendency of the storage period:
receiving, by the computing system, one or more additional data elements that have been added to the dataset;
indexing, by the computing system, one or more representations of the one or more additional data elements in the first data index stored by the first set of storage media; and
transferring, by the computing system, the one or more representations of the one or more additional data elements contained in the first data index stored by the first set of storage media to the second data index stored by the second set of storage media.
2. The computer-implemented method of claim 1 , wherein:
the first set of storage media comprise Random Access Memory (RAM) storage media; and
the second set of storage media comprise Solid State Drive (SSD) storage media.
3. The computer-implemented method of claim 1 , further comprising:
storing, by the computing system, a plurality of centroids in the first set of storage media, wherein the plurality of centroids respectively correspond to a plurality of partitions of the existing data elements included in the second data index stored by the second set of storage media.
4. The computer-implemented method of claim 3 , further comprising:
performing, by the computing system, a nearest neighbor search to identify one or more of the data elements in the dataset as results responsive to a query, wherein performing the nearest neighbor search comprises:
identifying, by the computing system, one or more of the centroids stored by the first set of storage media based on the query; and
accessing, by the computing system and from the second set of storage media, only the representations of the data elements included in the one or more of the partitions respectively associated with the one or more centroids identified based on the query.
5. The computer-implemented method of claim 1 , wherein transferring, by the computing system, the one or more representations of the one or more additional data elements contained in the first data index to the second data index comprises recomputing, by the computing system, an entirety of the second data index so as to include the one or more representations of the one or more additional data elements.
6. The computer-implemented method of claim 1 , wherein the representations of the data elements of the dataset comprise learned embedding values expressed in a latent space.
7. The computer-implemented method of claim 1 , wherein the data elements of the dataset correspond to videos, images, webpages, files, or entities.
8. The computer-implemented method of claim 1 , wherein the first data index and the second data index are at least partially overlapping.
9. A computing system, comprising:
a first set of storage media that stores a first data index, the first set of storage media having a first latency associated therewith;
a second set of storage media that stores a second data index, the second set of storage media having a second latency associated therewith, the second latency being greater than the first latency, the second data index containing existing data elements included in a dataset;
one or more processors; and
one or more non-transitory computer-readable media that store instructions that, when executed by the one or more processors, cause the computing system to perform operations, the operations comprising:
during pendency of a storage period:
receiving, by the computing system, one or more additional data elements that have been added to the dataset;
indexing, by the computing system, one or more representations of the one or more additional data elements in the first data index stored by the first set of storage media; and
transferring, by the computing system, the one or more representations of the one or more additional data elements contained in the first data index stored by the first set of storage media to the second data index stored by the second set of storage media.
10. The computing system of claim 9 , wherein:
the first set of storage media comprise Random Access Memory (RAM) storage media; and
the second set of storage media comprise Solid State Drive (SSD) storage media.
11. The computing system of claim 9 , wherein the operations further comprise:
storing, by the computing system, a plurality of centroids in the first set of storage media, wherein the plurality of centroids respectively correspond to a plurality of partitions of the existing data elements included in the second data index stored by the second set of storage media.
12. The computing system of claim 11 , wherein the operations further comprise:
performing, by the computing system, a nearest neighbor search to identify one or more of the data elements in the dataset as results responsive to a query, wherein performing the nearest neighbor search comprises:
identifying, by the computing system, one or more of the centroids stored by the first set of storage media based on the query; and
accessing, by the computing system and from the second set of storage media, only the representations of the data elements included in the one or more of the partitions respectively associated with the one or more centroids identified based on the query.
13. The computing system of claim 9 , wherein transferring, by the computing system, the one or more representations of the one or more additional data elements contained in the first data index to the second data index comprises recomputing, by the computing system, an entirety of the second data index so as to include the one or more representations of the one or more additional data elements.
14. The computing system of claim 9 , wherein the representations of the data elements of the dataset comprise learned embedding values expressed in a latent space.
15. The computing system of claim 9 , wherein the data elements of the dataset correspond to videos, images, webpages, files, or entities.
16. The computing system of claim 9 , wherein the first data index and the second data index are at least partially overlapping.
17. One or more non-transitory computer-readable media that store instructions that, when executed by one or more processors, cause the one or more processors to perform operations, the operations comprising:
for each of a plurality of storage periods:
maintaining, by a computing system, a first data index stored by a first set of storage media having a first latency associated therewith;
maintaining, by the computing system, a second data index stored by a second set of storage media having a second latency associated therewith, the second latency being greater than the first latency, the second data index containing existing data elements included in a dataset;
during pendency of the storage period:
receiving, by the computing system, one or more additional data elements that have been added to the dataset;
indexing, by the computing system, one or more representations of the one or more additional data elements in the first data index stored by the first set of storage media; and
transferring, by the computing system, the one or more representations of the one or more additional data elements contained in the first data index stored by the first set of storage media to the second data index stored by the second set of storage media.
18. The one or more non-transitory computer-readable media of claim 17 , wherein:
the first set of storage media comprise Random Access Memory (RAM) storage media; and
the second set of storage media comprise Solid State Drive (SSD) storage media.
19. The one or more non-transitory computer-readable media of claim 17 , wherein the operations further comprise:
storing, by the computing system, a plurality of centroids in the first set of storage media, wherein the plurality of centroids respectively correspond to a plurality of partitions of the existing data elements included in the second data index stored by the second set of storage media.
20. The one or more non-transitory computer-readable media of claim 19 , wherein the operations further comprise:
performing, by the computing system, a nearest neighbor search to identify one or more of the data elements in the dataset as results responsive to a query, wherein performing the nearest neighbor search comprises:
identifying, by the computing system, one or more of the centroids stored by the first set of storage media based on the query; and
accessing, by the computing system and from the second set of storage media, only the representations of the data elements included in the one or more of the partitions respectively associated with the one or more centroids identified based on the query.
Priority Applications (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US17/886,860 US20240054102A1 (en) | 2022-08-12 | 2022-08-12 | Scalable and Cost-Efficient Information Retrieval Architecture for Massive Datasets |
PCT/US2023/029400 WO2024035594A1 (en) | 2022-08-12 | 2023-08-03 | Scalable and cost-efficient information retrieval architecture for massive datasets |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US17/886,860 US20240054102A1 (en) | 2022-08-12 | 2022-08-12 | Scalable and Cost-Efficient Information Retrieval Architecture for Massive Datasets |
Publications (1)
Publication Number | Publication Date |
---|---|
US20240054102A1 true US20240054102A1 (en) | 2024-02-15 |
Family
ID=87797694
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US17/886,860 Pending US20240054102A1 (en) | 2022-08-12 | 2022-08-12 | Scalable and Cost-Efficient Information Retrieval Architecture for Massive Datasets |
Country Status (2)
Country | Link |
---|---|
US (1) | US20240054102A1 (en) |
WO (1) | WO2024035594A1 (en) |
Family Cites Families (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7836037B2 (en) * | 2007-10-04 | 2010-11-16 | Sap Ag | Selection of rows and values from indexes with updates |
US9984110B2 (en) * | 2014-08-21 | 2018-05-29 | Dropbox, Inc. | Multi-user search system with methodology for personalized search query autocomplete |
US9183303B1 (en) * | 2015-01-30 | 2015-11-10 | Dropbox, Inc. | Personal content item searching system and method |
CN108694188B (en) * | 2017-04-07 | 2023-05-12 | 腾讯科技（深圳）有限公司 | Index data updating method and related device |
SG11202002588RA (en) * | 2019-09-12 | 2020-04-29 | Alibaba Group Holding Ltd | Log-structured storage systems |
-
2022
- 2022-08-12 US US17/886,860 patent/US20240054102A1/en active Pending
-
2023
- 2023-08-03 WO PCT/US2023/029400 patent/WO2024035594A1/en unknown
Also Published As
Publication number | Publication date |
---|---|
WO2024035594A1 (en) | 2024-02-15 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10963794B2 (en) | Concept analysis operations utilizing accelerators | |
US11238096B2 (en) | Linked data processor for database storage | |
Ramírez-Gallego et al. | An information theory-based feature selection framework for big data under apache spark | |
Zoumpatianos et al. | ADS: the adaptive data series index | |
US9026518B2 (en) | System and method for clustering content according to similarity | |
US8150723B2 (en) | Large-scale behavioral targeting for advertising over a network | |
CN107451225B (en) | Scalable analytics platform for semi-structured data | |
Wang et al. | Peacock: Learning long-tail topic features for industrial applications | |
US9639542B2 (en) | Dynamic mapping of extensible datasets to relational database schemas | |
US20160042298A1 (en) | Content discovery and ingestion | |
US20150142829A1 (en) | System, apparatus, program and method for data aggregatione | |
Shmueli-Scheuer et al. | Extracting user profiles from large scale data | |
WO2010124995A1 (en) | Method and system for prioritising operations on network objects | |
US20230038616A1 (en) | Reducing matching documents for a search query | |
EP3314464A2 (en) | Storage and retrieval of data from a bit vector search index | |
Wang et al. | Towards topic modeling for big data | |
US11651041B2 (en) | Method and system for storing a plurality of documents | |
WO2014062192A1 (en) | Performing a search based on entity-related criteria | |
US20220019902A1 (en) | Methods and systems for training a decision-tree based machine learning algorithm (mla) | |
Qin et al. | Scalable asynchronous gradient descent optimization for out-of-core models | |
US20240054102A1 (en) | Scalable and Cost-Efficient Information Retrieval Architecture for Massive Datasets | |
US20170031909A1 (en) | Locality-sensitive hashing for algebraic expressions | |
US11556549B2 (en) | Method and system for ranking plurality of digital documents | |
Zhang et al. | A learning-based framework for improving querying on web interfaces of curated knowledge bases | |
US20230161779A1 (en) | Multi-phase training of machine learning models for search results ranking |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:PAVETIC, FILIP;SIMCHA, DAVID;VOICU, ALEXANDER-TEODOR;AND OTHERS;SIGNING DATES FROM 20221206 TO 20230207;REEL/FRAME:062624/0213 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: RESPONSE TO NON-FINAL OFFICE ACTION ENTERED AND FORWARDED TO EXAMINER |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: FINAL REJECTION MAILED |