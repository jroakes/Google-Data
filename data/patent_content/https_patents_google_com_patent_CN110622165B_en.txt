CN110622165B - Security measures for determining privacy set intersections - Google Patents
Security measures for determining privacy set intersections Download PDFInfo
- Publication number
- CN110622165B CN110622165B CN201980001669.3A CN201980001669A CN110622165B CN 110622165 B CN110622165 B CN 110622165B CN 201980001669 A CN201980001669 A CN 201980001669A CN 110622165 B CN110622165 B CN 110622165B
- Authority
- CN
- China
- Prior art keywords
- computing system
- identifier
- identifiers
- blinded
- records
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/602—Providing cryptographic facilities or services
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/008—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols involving homomorphic encryption
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/32—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials
- H04L9/3218—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols including means for verifying the identity or authority of a user of the system or for message authentication, e.g. authorization, entity authentication, data integrity or data verification, non-repudiation, key authentication or verification of credentials using proof of knowledge, e.g. Fiat-Shamir, GQ, Schnorr, ornon-interactive zero-knowledge proofs
Abstract
Systems, methods, devices, and other techniques for protecting privacy when comparing privacy data sets from a first computing system and a second computing system. The second computing system identifies a first set of identifiers corresponding to records in a privacy database of the second computing system. The second computing system receives a blinded version of the set of identifiers corresponding to records in a privacy database of the first computing system. The second computing system determines an intersection or characteristic of an intersection of the records in the privacy database of the first computing system and the records in the privacy database of the second computing system based on a match between the first set of identifiers and the blinded version of the second set of identifiers.
Description
Technical Field
Systems, methods, devices, and other techniques are disclosed for securely determining a privacy set intersection or characteristics of a privacy set intersection for data items maintained by an untrusted and/or independent party.
Background
Organizations are typically delegated to manage and store sensitive and private data. For example, a research institution may collect data as part of a study or experiment conducted by the institution, and a healthcare organization may manage data related to the medical care and health of its patients.
The private data is often digitally stored on a computing system operated by or on behalf of an organization, and the organization may implement security policies designed to protect the confidentiality and integrity of its stored data. For many organizations, data security is a high priority because the data may contain confidential, sensitive, or other private information that may create value for the organization, a third party (e.g., customer, client, employee) interested in the organization, or both. Furthermore, a breach (break) of data security may cause a breach of trust of an organization among people who have delegated private data to the organization. Due to the sensitivity of data stored by some organizations, and the high concern that data is secured, organizations often store their data in a privacy database that is physically, logically, or both isolated from unauthorized participants.
Because organizations strive to maintain their privacy and confidentiality of sensitive data, data may be isolated (silos) from other organizations and entities. However, in some instances, organizations and other stakeholders may benefit from sharing aspects of their data with third parties, receiving data from third parties, or both.
Disclosure of Invention
Systems, methods, devices, and other techniques are disclosed for securely determining a privacy set intersection or characteristics of a privacy set intersection for data items maintained by an untrusted and/or independent party. The intersection of the private data sets is a data item common to each of the data sets. For example, data items of the same object or person represented in a privacy dataset maintained by several parties may be classified as being within an intersection of the privacy dataset.
Determining the intersection of the data sets of two parties may involve comparing the data items from each party's set with the items in the other party's set. However, in the absence of adequate security measures, the underlying content of the data item may be revealed to the party performing such comparison. Thus, if the data contains private information that cannot be revealed to other parties, conventional techniques for comparing data sets may be unacceptable. The techniques disclosed in this specification provide protocols and security measures that allow parties to compare private data items without revealing the underlying content of the data items to unauthorized parties. Furthermore, the technique may provide a malicious security assurance that prevents one party from arbitrarily deviating from the agreement to learn more private data of another party than is permitted. In other embodiments, the techniques may provide a covert (overt) security measure that ensures a statistically significant likelihood that one party attempting to spoof a protocol will be captured by another party. If one party attempts spoofing during the process of executing the privacy set intersection (Private Set Intersection, "PSI") protocol, the other party may terminate the protocol and prevent further interaction with the spoofing party indefinitely or for a specified period of time.
According to a first aspect, there is provided a method for protecting privacy when comparing privacy databases of a first computing system and a second computing system, the method comprising: identifying, by the second computing system, a first set of identifiers corresponding to records in a privacy database of the second computing system; for each identifier in the first set of identifiers: (i) generating, by the second computing system, an encrypted version of the identifier using a homomorphic encryption process, (ii) providing, from the second computing system to the first computing system, the encrypted version of the identifier, (iii) receiving, by the second computing system, from the first computing system, a blinded encrypted version of the identifier generated using the secret key of the first computing system, and (iv) decrypting, by the second computing system, the blinded encrypted version of the identifier to generate the blinded version of the identifier; receiving, by the second computing system, a blinded version of the second set of identifiers corresponding to records in the privacy database of the first computing system; determining, by the second computing system, an intersection or characteristic of an intersection of the records in the privacy database of the first computing system and the records in the privacy database of the second computing system based on a match between the blinded version of the first set of identifiers and the blinded version of the second set of identifiers; and providing, by the second computing system, an indication of the intersection or a characteristic of the intersection.
The method may include one or more of the following features. For each identifier in the first set of identifiers, the first computing system may generate a blinded encrypted version of the identifier by processing the encrypted version of the identifier and the secret key of the first computing system according to a pseudo-random function. The pseudo-random function may be an unintentional (pseudo-random) function. The second computing system may modify the encrypted version of the identifier by combining the encrypted version of the identifier with a secret key of the second computing system prior to providing the encrypted version of the identifier to the first computing system, and wherein the first computing system generates the blinded encrypted version of the identifier further based on the secret key of the second computing system by processing the modified encrypted version of the identifier according to a pseudo-random function. For each identifier in the first set of identifiers, the second computing system may modify the encrypted version of the identifier by homomorphically adding the secret key of the second computing system to the encrypted version of the identifier. The method may further comprise: mapping, by the second computing system, for each identifier in the first set of identifiers, a blinded version of the identifier to the identifier; and for each identified match between the blinded version of the identifier from the first set of identifiers and the blinded version of the identifier from the second set of identifiers: identifying, by the second computing system, a record in a privacy database of the second computing system corresponding to an identifier mapped to a blinded version of the identifier from the first set of identifiers; and classifying, by the second computing system, the identified records as being within an intersection of the records in the privacy database of the first computing system and the records in the privacy database of the second computing system. The second computing system may receive the blinded encrypted version of the first set of identifiers from the first computing system in a first order corresponding to a second order in which the second computing system provided the encrypted version of the first set of identifiers to the first computing system. The first order may be consistent with the second order such that the second computing system receives the blinded encrypted version of the first set of identifiers from the first computing system in the same order in which the second computing system provided the encrypted version of the first set of identifiers to the first computing system. The method may include determining, by the second computing system, characteristics of intersections of records in the privacy database of the first computing system with records in the privacy database of the second computing system, without determining which records are within the intersections. The characteristics of the intersection may represent a count of the number of common identifiers included in both the first set of identifiers corresponding to records in the privacy database of the second computing system and the second set of identifiers corresponding to records in the privacy database of the first computing system. The characteristic of the intersection may represent a sum of values stored in records within the intersection of records between the privacy database of the first computing system and the privacy database of the second computing system of the privacy database of the second computing system. The first subset of identifiers from the first set of identifiers may also be included in the second set of identifiers and the second subset of identifiers from the first set of identifiers is not included in the second set of identifiers. The method may further comprise: determining, by the second computing system, whether the first computing system blinded the encrypted version of the first set of identifiers without departing from the prescribed protocol; and in response to verifying that the first computing system deviated from the prescribed protocol when blinding the encrypted version of the first set of identifiers, taking action to stop execution of the prescribed protocol. The method may further comprise: inserting, by the second computing system, a virtual identifier into the first set of identifiers, the virtual identifier not corresponding to a record in a privacy database of the second computing system; and after receiving the blinded encrypted version of the first set of identifiers from the first computing system, verifying that the first computing system properly blinded the encrypted version of the virtual identifier. The first set of identifiers corresponding to records in a privacy database of the second computing system may identify a user of a party transacting with an entity associated with the second computing system; and a second set of identifiers corresponding to records in a privacy database of the first computing system may identify users of digital media items served with entities associated with the second computing system.
At least one aspect may provide a computing system comprising: a privacy database on one or more computers storing a plurality of data records, each data record including an identifier representing an identity of the data record or an identity of a user represented in the data record; one or more processors; and one or more computer-readable media having instructions stored thereon, wherein the instructions, when executed by the one or more processors, cause the one or more processors to perform operations according to the first aspect.
At least one aspect may provide one or more non-transitory computer-readable media having instructions stored thereon, wherein the instructions, when executed by one or more processors, cause the one or more processors to perform operations according to the first aspect.
In certain examples, implementations of the subject matter described in this specification can provide one or more of the following advantages. First, the intersection of private data items from untrusted and/or independent parties may be determined without either party learning the private content of the other party's data. Second, the sum of cardinalities or associated values of intersections of private data items from untrusted and/or independent parties may be determined without either party learning the private content of the other party's data and without either party learning which data items are within the intersections. Third, an untrusted and/or independent party may execute a protocol to determine the intersection or characteristics of the intersection of the private data items of the parties, while providing semi-honest (semi-honest) security assurance, malicious security assurance, or covert security assurance. The technique may allow either party to detect with high probability whether the other party has corrupted any or some of the steps of the PSI protocol, for example by inserting a virtual data item into the collection to be compared. Fourth, parties may execute PSI protocols to determine intersections, or characteristics of intersections, of private data items without requiring a common RSA modulus generated by a trusted third party. Additional features and advantages will be apparent to one of ordinary skill in the art from the entire specification, drawings, and claims.
Drawings
FIG. 1 is a conceptual diagram of a computing environment configured to securely determine intersections of private data items stored in a database of untrusted parties.
FIG. 2 depicts a computing environment including a first computing system and a second computing system configured to execute a protocol for securely determining a privacy set intersection of privacy data stored in a database of untrusted parties.
FIG. 3 depicts a flowchart of an example process for determining an intersection of private data items maintained by an untrusted party.
FIG. 4 depicts a flowchart of an example process for determining the cardinality of an intersection of private data items maintained by an untrusted party.
FIG. 5 depicts a flowchart of an example process for determining a sum of associated values for an intersection of private data items maintained by an untrusted party.
FIG. 6 depicts a flow diagram of an example protocol for determining privacy set intersections using an unintentional pseudorandom function.
FIG. 7 depicts a flow diagram of an example sub-protocol for determining privacy set intersections.
FIG. 8 depicts a swim lane diagram using a start-of-day protocol based on virtual covert security.
FIG. 9 depicts a swim lane diagram of per-segment protocols using virtual-based covert security.
FIG. 10 depicts a schematic diagram of an example computer system that may be used to perform operations associated with the computer-implemented methods and other techniques described herein.
Detailed Description
The present specification discloses computer-based systems, methods, devices, and other techniques that facilitate controlled exchange of information from a private data set between independent parties without revealing information that may allow either party to discern the privacy aspects of the data shared by the other party. More specifically, the techniques disclosed herein may be applied to determine intersections of items held in a privacy dataset of two or more parties without the underlying content of which any party reveals privacy data. For example, if two parties have records representing data of the same user, the data representing the user may be categorized within the privacy set intersections of the parties, and the fact that the user is represented in the privacy data sets of the two parties may be determined without revealing underlying content of the collection of each party. These and additional aspects of the disclosure are described in more detail with respect to the drawings.
Referring to fig. 1, a conceptual diagram of an environment 100 is shown in which an intersection of a privacy database 104a, 104b of two parties may be securely determined for the environment 100. The environment 100 includes a first computing system 102a and a second computing system 102b. The first computing system 102a is operated by or on behalf of a first party and the second computing system 102b is operated by or on behalf of a second party. Computing system 102a and computing system 102b may each be implemented on one or more computers in one or more locations. The first and second parties may be individuals, businesses, universities, governments, or other organizations or entities, respectively, that maintain private data about the party's activities. For example, an enterprise may maintain privacy data about sales, customer lists, trade secrets, and business, while a university may maintain privacy data about its teachers and students, such as assessment records, academic and discipline reports, and the like. The first and second parties are typically separate from each other and each manage their private data independently of the other party. However, both parties may benefit from comparing their datasets and identifying common items therein (i.e., determining a privacy set intersection) or determining characteristics of the intersection, such as the number of common items in the dataset or the sum of values associated with the common items.
For example, in fig. 1, the first party operating the first computing system 102a may be an online distributor of digital media items. As part of its distribution scheme, the first computing system 102a stores digital media items (e.g., images, video, audio files, or text) submitted by third party providers and places the digital media items in web pages, applications, or other interfaces that have been designed to incorporate third party digital media items. For example, a news website may provide slots (slots) in its web pages that are reserved for third-party digital media items, and whenever a web page from the site is served to a user, the distribution system (e.g., first computing system 102 a) may select a particular digital media item submitted by a third party to fill the slots. For example, the selected items may be considered related to the content of the news site and/or related to the interests of the user to whom the web page is being served.
The first computing system 102a maintains a privacy database 104a that stores records of digital media items served to a particular user. As shown in fig. 1, each record in the first party's privacy database 104a includes at least a device ID, a universal ID, a provider ID, and a date stamp, and each record corresponds to a particular instance of a third party digital media item that is supplied to the user. For example, the first record from the top of the database 104a representation indicates that digital media items submitted for distribution by provider a were served to the user device identified by device ID G10967 on day 7 months 15. The next record from the top indicates that the digital media item submitted for distribution by provider B was served to the user device identified by device ID B632519 on day 7 months 14. Although a few records are shown in fig. 1 for illustration, in practice, the privacy database 104a may include hundreds, thousands, millions, or even billions of records based on the scale of the distribution scheme.
Database 104a also includes a "universal ID" field. A universal ID is an identifier that is shared or otherwise commonly known by two or more parties to identify a particular person, place, or thing. In the example of database 104a, the universal ID identifies the user to whom a particular digital media item is to be served. In some implementations, the first computing system 102a translates or maps the device ID and/or other heuristics (heuristics) to a generic ID of the user recipient of the supplied digital media item. For example, the first computing system 102a may use the device ID and IP address of the user requesting the third party digital media item to identify the user and access the user's universal ID. Other parties that may interact with the same user may also refer to those users by their universal IDs. In some embodiments, the universal ID may be issued by a separate authority or assigned in a manner that is valid to either party. For example, the universal ID may be an IP address of a user browsing respective websites of two or more parties. The sites of each party may record individually which users have browsed their sites based on their IP address, thereby providing each party with a universal or common identifier of the users.
The second computing system 102b maintains a privacy database 104b that stores records of various transactions in which users engage with the second party. Each record corresponds to a particular transaction and includes, for example, a customer ID, a universal ID, a transaction amount, and a stamp indicating the time and/or date of the transaction. The customer ID represents an internal identifier of an entity (e.g., a customer, or vendor) that is a party to the transaction. The client ID is mapped to a generic ID of the entity so that both the first party and the second party can refer to the same entity by an identifier known to both parties.
Further, in the example of fig. 1, the second party corresponds to provider "B" in the privacy database 104a of the first party. That is, the second party is the party submitting the digital media item to the first party for distribution, and the first party supplies the digital media item of the second party for presentation to the end user, such as by inserting the item into a designated content slot in a website, mobile application, or other publisher content.
The first party, the second party, or both may desire to know how effective the first party is in driving the end user to initiate an actual transaction with the second party on behalf of the digital media item that the second party supplies. The effectiveness of digital media item placement may be quantified by a metric known as conversion rate. The conversion represents an instance of presenting the digital media item to the user to cause the user to initiate a transaction with a provider of the digital media item (e.g., the second party in fig. 1) or initiate other types of qualifying interactions. The conversions may be counted by identifying the user who initiated a transaction with the provider of the digital media item within a predetermined amount of time since the digital media item was served and presented to the user.
While the first party, the second party, or both may desire to identify the conversion, none of the parties have access to all of the data needed to determine the conversion. The first party knows, for example, which digital media items are provided to which end users on behalf of which content providers, but does not know which end users then initiate transactions with the content providers. Likewise, the second party knows which entities originated the transaction with the second party (e.g., purchase of goods or services from the second party), but does not know which of these entities correspond to the end user to whom the digital media item of the second party was supplied.
The techniques disclosed in this specification may permit a first party and a second party to compare records from their privacy database 104a and privacy database 104b so that they can determine information required to identify the conversion and/or determine the conversion rate without revealing underlying content of the privacy records and, in some embodiments, without revealing to the other party the identity of the end user represented in the databases 104a, 104 b. For example, the conversion may be determined by identifying eligible records in the privacy database 104a that have the same universal identifier (e.g., user identifier) as records in the privacy database 104 b. Records of databases 104a, 104b sharing the same universal identifier may be referred to as privacy set intersections. In particular, to determine the conversions, the first computing system 102a and the second computing system 102B may filter the databases 104a and 104B such that only records from each database representing possible conversions are compared to each other (e.g., records from the first database 104a corresponding to provider B/second party are compared to records from the second database 104B of transactions occurring within a predetermined time after the user was served the second party's digital media item). In fig. 1, three pairs of records from privacy database 104a and privacy database 104b appear in privacy set intersection 106. The first computing system 102a and/or the second computing system 102b may determine the privacy-set intersection 106 by comparing the blinded values of the universal identifiers from each database 104a, 104 b. If a match is determined among the blinded identifiers of a pair of records, then the system 102a or 102b classifies the corresponding record of the blinded identifier as being within the privacy set intersection 106. Each record within intersection 106 may, for example, represent a transformation.
Further, as explained in detail below with reference to fig. 4 and 5, in some embodiments, the first system 102a, the second system 102b, or both may determine one or more characteristics 108 of the intersection 106 while preventing either party from discerning which records are actually within the intersection 106. The characteristics 108 may include a cardinality of the intersection 106 that represents a count of the number of items within the intersection 106. In some implementations, the characteristics 108 include a sum of associated values of the items in the intersection 106, such as a sum of recorded transaction amounts in the intersection 106. Thus, the cardinality of the recorded intersection 106 shown in fig. 1 is "3" and the sum of the transactions of the records in the intersection 106 is $49.79. By determining the characteristics 108 of the intersection 106, useful information about the intersection 106 may be determined while further protecting the privacy of the data of the parties, as none of the parties determine the underlying content of the records of the other parties or identify which records are within the intersection 106.
The techniques disclosed herein are not limited to determining transitions. Determining privacy set intersections, or characteristics of such intersections, may generally be applied in any situation where two parties seek to compare sensitive data without violating privacy constraints associated with the data. For example, an employer who is building a health insurance plan for his employees may use the techniques herein to cooperate with a healthcare provider to obtain an indication of how many employees have sought medical services during a time period or the total cost of the employee on medical services during the time period.
Turning to fig. 2, a computing environment 200 is depicted for determining intersections or characteristics of intersections in a single-cube privacy dataset. The environment 200 includes a first computing system 202a and a second computing system 202b. The first computing system 202a is operated by or on behalf of a first party and the second computing system 202b is operated by or on behalf of a second party. The first system 202a and the second system 202b may be physically, geographically, and/or logically separated from each other, and each system 202a and 202b may include one or more computers operating in a centralized or distributed manner at one or more locations.
Each of the first computing system 202a and the second computing system 202b are configured to communicate with each other over a communication channel, such as a secure internet connection. The systems 202a, 202b may be configured differently from each other, but may include some common components to perform operations for determining privacy set intersections and/or characteristics of intersections. For illustration, these components 204a-214a will be described with respect to the first party computing system 202a, but it should be understood that the second party computing system 202b may include corresponding components 204b-214b configured to perform operations corresponding to the components 204a-214a of the first party computing system 202 a.
The first party computing system 202a may include a privacy database 204a, a cryptographic engine 206a, a key manager 208a, a security policy repository 210a, a processor 212a, and a communication interface 214a.
The privacy database 204a stores data items of a first party. All or some of the data items may be considered "private" in that they represent information of sensitive characters. The private data item may be related to, for example, personal information of the user, business confidential information, patient medical information, etc., and access to the private data item may be restricted. In some implementations, the privacy database 204a stores information such as records in a relational database in a structured manner. Database 204a may then include one or more tables storing records of private data items according to a defined schema, and may further include a database management system that manages modifications, accesses, and queries to the one or more tables. Database 204a may be implemented on one or more processors of system 202a and the data may be stored on one or more storage devices of system 202 a.
The cryptographic engine 206a is configured to perform cryptographic operations on data items from the privacy database 204 a. For example, the cryptographic engine 206a may apply homomorphic encryption to private data items, decrypt data items, and apply blinding operations to data items according to the processes and techniques described with respect to fig. 3-9. The cryptographic engine 206a may use one or more keys in performing cryptographic operations. The cryptographic engine 206a may retrieve the appropriate key for the given cryptographic operation from the key manager 208 a. Key manager 208a may generate, exchange, store, and/or destroy keys used by cryptographic engine 206 a. In some implementations, the key manager 208a is provided in a hardware security module that includes hardware-based security measures to mitigate (notify) or detect unauthorized access or tampering with keys maintained by the key manager 208 a.
The first computing system 202a may be configured to operate according to a specified security policy. The configuration files defining the one or more security policies may be stored in a security policy repository 210a on one or more storage devices of the system 202 a. In some implementations, the protocol that the system 202a adheres to during interaction with the second computing system 202b is controlled based on the parameters of the selected security policy. The system 202 may implement different security models based on the security policies selected by the first party system 202a for a given interaction with the second party system 202 b. For example, the first security policy may instruct the first system 202a to implement a "semi-honest" security model that ensures that parties to the interaction (e.g., the first party and the second party) only learn information about the permission type of the other party's private data if they faithfully follow the protocol steps. The second security policy may instruct the first system 202b to implement a "malicious" security model that ensures that the parties to the interaction only learn information about the permission type of the other party's private data, even if they deviate arbitrarily from the agreement. Conversely, a third security policy may instruct the first system 202c to implement a "covert" security model that ensures that the parties to the interaction only learn information about the permission type of the other party's private data if they faithfully follow the protocol steps, but if one party deviates from the protocol, a breach will be detected with some probability p (e.g., 99%, adjustable). For example, if one party tries to fraud the other party and deviate from the interaction agreement to be unauthorised to learn private information about the other party's data, a malicious party will be prevented from deviating from the agreement and from achieving its goal under a malicious security model, while the same party under a covert security model may be able to learn more than is permitted, but at risk of being detected. If detected, the other party may take remedial action to recover any corrupted information and may take punishment action, such as refusing future interactions with the malicious party.
The first party computing system 202a includes a processor 212a. A single processor 212a is depicted, but in other embodiments, the system 202a may include multiple processors. The processor 212a or processors may be embodied in one or more physical processing devices and may include a combination of hardware, software, and/or firmware. The processor 212 may execute computer readable instructions to implement any component of the first system 202a and may execute one or more computer programs operable to cause the first system 202a to perform the techniques disclosed herein for determining privacy set intersections of items in the privacy database 204a and the privacy database 204b and/or operable to cause the first system 202a to determine characteristics of the privacy set intersections.
The interface 214a is a communication interface that enables the first computing system 202a to communicate with the second computing system 202b and, optionally, with one or more additional computing systems. For example, the encrypted and blinded data items from the privacy database 204a may be transmitted to the second computing system 202b over a communication channel (e.g., one or more physical or wireless networks), and the encrypted and blinded data items from the privacy database 204b may be received from the second computing system 202b over the communication channel.
FIG. 3 is a flow diagram of an example process 300 for determining intersections of private data items maintained by independent and/or untrusted parties. Process 300 is performed by a first party computing system (e.g., system 102a or system 202 a) on behalf of a first party and a second party computing system (e.g., system 102b or system 202 b) on behalf of a second party.
At stage 302, the second party system selects a set of records from the privacy database as an object to compare with records from the privacy database of the first party system. In some implementations, the second party system selects the record by querying the privacy database for records matching one or more search criteria. For example, if the goal of process 300 is to identify a transition within a period of time, the second party system may select a record corresponding to a transaction that occurred within that period of time.
At stage 304, the second party system selects a particular record from the set identified at stage 302 and determines a generic identifier associated with the record or with the entity represented in the record. The universal identifier is an identifier used by the first and second party computing systems to refer to a similar thing. For example, an end user who is served digital media items by the content distribution platform of the first party computing system and then purchases goods or services from the second party may be identified by using the same universal identifier in the privacy databases of both the first party computing system and the second party computing system.
At stage 306, the second party system 306 encrypts the universal identifier. Encryption may be performed by a cryptographic engine of the second party system. Further, in some embodiments, the cryptographic engine encrypts the universal identifier using homomorphic techniques. An example homomorphic encryption technique is the cam-shap encryption scheme. By homomorphically encrypting the universal identifier, operations may be performed on ciphertext (i.e., an encrypted version of the universal identifier) that is stored in plaintext at the time of decryption. For example, by performing certain operations on a plaintext universal identifier, the same or corresponding results may be produced as if the operations were performed on a homomorphic encrypted version of the universal identifier and then decrypted.
At stage 308, the second party system sends the encrypted universal identifier to the first party system, and at stage 310, the first party system receives the encrypted universal identifier. Notably, the first party system does not possess the necessary keys to decrypt the universal identifier, and therefore the first party system cannot determine the plaintext value of the universal identifier.
At stage 312, the first party system performs a blinding operation on the encrypted universal identifier. The blinding operation may be performed by a cryptographic engine of the first party system. In general, a blinding operation is a cryptographic operation in which underlying content of an encrypted universal identifier is blinded or obscured so that data items of a first party system and a second party system can be compared in blind space instead of in plaintext. In some implementations, the first party system blinds the encrypted generic identifier using an unintentional pseudo-random function. The inadvertent pseudorandom function is based on a secret key owned by the first party system, but not by the second party system. Alternatively, the inadvertent pseudorandom function may be performed using a key that is combined based on: (i) A first secret portion contributed by the first party system but unknown to the second party system and (ii) a second secret portion contributed by the second party system but unknown to the first party system.
At stage 314, the first party system sends the blinded encrypted version of the universal identifier to the second party system, and at stage 316, the blinded encrypted version of the universal identifier is received by the second party system. At stage 318, the second party system (e.g., the cryptographic engine of the second party system) decrypts the blindly encrypted universal identifier using a secret decryption key private by the second party system to construct a blinded version of the universal identifier. Because the decryption is to invert the homomorphic encryption value, the result of decrypting the blinded encrypted version of the universal identifier corresponds to the result of not homomorphic encrypting the universal identifier at all, and thus decrypting the blinded encrypted version of the universal identifier is used to generate a blinded-only version of the universal identifier.
At stage 320, the second party system stores the correlation between the blinded or plaintext version of the record universal identifier selected at stage 304 and the blinded version of the universal identifier. At stage 322, the second party system checks whether the generic identifier of any additional records from the record set identified at stage 302 remains blinded. If so, the process 300 returns to stage 302 and blinds the universal identifier of the next selected record from the collection in the same manner. The second party system continues to provide the universal identifier to be blinded from the selected set of records until all records in the set are exhausted.
At the same time, at stage 324, the first party system selects a record from its privacy database to be compared with the selected record from the privacy database of the second party system. For the purpose of identification conversion, the first party system may select a collection of records representing, for example, end users provided with digital media items on behalf of the second party during a specified period of time. The first party system retrieves the universal identifier of the selected record (326) and blinds the universal identifier using the same blinding operation and key used to blinde the encrypted version of the universal identifier from the privacy database of the second party system (328). In some embodiments, the universal identifier is blinded using an unintentional pseudo-random function. At stage 330, the first party system sends the blinded generic identifier for each selected record from the first party's privacy database to the second party system, and at stage 332, the second party system receives the blinded generic identifiers.
After the blinded identifiers of the selected records are obtained from the privacy databases of both the first party system and the second party system, the second party system may determine a privacy set intersection of the records. At stage 334, the second party system compares the blinded identifiers from each party's privacy database and determines if there are any matches among the blinded identifiers. Each identified match means a corresponding record between the privacy databases of the first and second parties that refers to the same universal identifier. For example, each match may represent a transformation in which a user of the digital media item served to the second party by an online distribution platform associated with the first party later initiates a transaction with the second party within a specified period of time. To finalize which records are within the privacy set intersection, the second party system uses the relevance data stored at stage 320 at stage 336 to find a blinded generic identifier and/or database record from the second party's privacy database that corresponds to a blinded generic identifier that matches the blinded generic identifier from the first party's privacy database.
Notably, the second party system in process 300 of fig. 3 can identify individual records from the second party's privacy database that are within an intersection of records from the first party's privacy database by correlating the blinded identifier received from the first party system with the blinded version of the identifier. The second party system may determine the correlation as long as the second party system receives the blinded version (or blinded encrypted version) of the universal identifier from the first party system in the same or corresponding order in which the blinded version (or blinded encrypted version) of the universal identifier is provided to the first party system. However, in some cases, it may not be necessary to determine a particular record in the intersection. Alternatively, the parties may seek to determine characteristics of the intersection, rather than determining the particular records that make up the intersection. Determining characteristics of the intersection, such as the cardinality of records in the intersection or the sum of associated values, may be beneficial to further protect the sensitivity of the compared data because neither party identifies individual records within the intersection.
Fig. 4 depicts a flow chart of a process 400 for determining the cardinality of a privacy set intersection. In contrast to the process 300 of fig. 3, the second party cannot discern which records are within the privacy set intersection, even if the cardinality is determined. The second party is prevented from identifying the constituent records of the intersection because the first party system scrambles (shuffles) the second party's blinded identifier before the second party's blinded identifier is returned to the second party system. The second party is therefore unable to correlate the blinded identifier received from the first party system with the unblinded identifier provided to the first party system. The operation of process 400 may proceed as follows.
At stage 402, the second party system selects records from its privacy database that meet one or more selection criteria. For each selected record, the second party system retrieves a universal identifier associated with the record (404). The second party system then homomorphically encrypts each universal identifier (406) and sends an encrypted version of the universal identifier to the first party system (408). At stage 410, the first party system receives an encrypted version of the universal identifier of the second party. The first party system applies a blinding operation to each of the encrypted versions of the universal identifier of the second party to generate a blinded encrypted version of the universal identifier of the second party (412). The first party system randomly scrambles (414) the blinded encrypted version of the universal identifier of the second party and sends (416) the blinded encrypted version of the identifier to the second party system. At stage 418, the second party system receives the blinded encrypted version of the second party's universal identifier in a scrambled order. At the same time, at stage 420, the first party system selects records from its privacy database that meet one or more selection criteria, and retrieves the universal identifier associated with each record (422). The first party system then applies a blinding operation to each of the first party's universal identifiers to generate a blinded version of the first party's universal identifier (424). The first party system sends a blinded version of the universal identifier of the first party to the second party system (426), which is then received by the second party system (428). The second party system decrypts the blinded encrypted version of the second party's universal identifier to generate a blinded version of the second party's universal identifier (430), and then compares the blinded version of the first party's universal identifier to the blinded version of the second party's universal identifier (432). Any matches determined between the blinded versions of the universal identifiers of the first and second parties are determined to be in the privacy set intersection. As a result of the scrambling, the second party system cannot correlate the matching blinded version of the universal identifier with the unblinded version, but it can determine the cardinality of the intersection by counting the number of matching blinded identifiers (434).
FIG. 5 depicts a flowchart of an example process 500 for determining a sum of values associated with records in a privacy set intersection while preserving privacy. Process 500 may be performed by various computing systems of an untrusted party, such as system 102a, system 102b, or system 202a, system 202 b. In some implementations, the process 500 allows the second party to determine the sum of values associated with records in the privacy set intersection without requiring either party to identify the individual value or record from which the sum was determined. That is, rather than identifying each record in the intersection as described with respect to FIG. 3, and then determining the sum of the values associated with the identified records, process 500 determines the sum of the values in blind space so that parties need not identify which records constitute the privacy set intersection. These techniques may be usefully applied in the context of, for example, conversion to determine a total value for a transaction initiated by a user of a digital media item being served by a first party in an online distribution platform.
At stage 502, the second party system selects records from its privacy database that meet one or more selection criteria. For each selected record, the second party system retrieves a generic identifier associated with the record and an added value associated with the record (504). The second party system then homomorphically encrypts each universal identifier (506), homomorphically encrypts the added value associated with the record (508), and sends the encrypted version of the universal identifier and the associated value to the first party system (510). At stage 512, the first party system receives an encrypted version of the universal identifier of the second party and an encrypted version of the recorded association value of the second party. The first party system applies a blinding operation to each of the encrypted versions of the universal identifier of the second party to generate blind encrypted versions of the universal identifier of the second party (514), and applies a blinding operation to each of the encrypted versions of the recorded association values of the second party (516). The first party system randomly scrambles 518 the blinded encrypted version of the universal identifier of the second party, but maintains a correspondence between the identifiers and their associated values. The first party system then transmits the blinded encrypted version of the identifier and its corresponding blinded encrypted association value to the second party system (520). At stage 522, the second party system receives the blinded encrypted version of the universal identifier of the second party and the blinded encrypted association value in a scrambled order. At the same time, at stage 524, the first party system selects records from its privacy database that meet one or more selection criteria, and retrieves the universal identifier associated with each record (526). The first party system then applies a blinding operation to each of the first party's universal identifiers to generate a blinded version of the first party's universal identifier (528). The first party system sends a blinded version of the universal identifier of the first party to the second party system (530), which is then received by the second party system (532). The second party system decrypts the blinded encrypted version of the second party's universal identifier to generate a blinded version of the second party's universal identifier (534), and then compares the blinded version of the first party's universal identifier to the blinded version of the second party's universal identifier (536). Any matches determined between the blinded versions of the universal identifiers of the first and second parties are determined to be in the privacy set intersection. As a result of the scrambling, the second party system cannot correlate the matching blinded versions of the generic identifiers with their blinded versions, but it can determine the sum of the values associated with the records in the privacy set intersection. To determine the sum, the second party system decrypts the blinded encrypted version of the associated value to generate a blinded version of the associated value (538). The second party system sums the blinded versions of the associated values and then removes the blinding factor from the sum to determine a blinded sum of the recorded associated values in the privacy set intersection (540).
PSI protocol overview
Some implementations of the technology described herein use an unintentional pseudo-random function (PRF) to calculate Privacy Set Intersections (PSIs). More specifically, the technique may use PRF f k (m)＝g 1/(k+m) mod p, where p is a prime number and g is Z p Is a generator of a large prime order subgroup. The PRF can be computed securely and inadvertently by two parties, one holding the key k and the other holding the message m. The inadvertent PRF computation may form the core of the PSI protocol.
An overview of a PSI protocol 600 that uses the oPRF as a sub-protocol is shown in the flow chart depicted in fig. 6. Suppose A and B are each having an individual data set D a ＝(a 1 ,...,a n ) And D b ＝(b 1 ,…,b m ) And both want to learn about D a ∩D b 。
At stage 602, A and B generate random PRF key shares k, respectively A And k B . The goal is to evaluate f on each of their data sets k * Where k=k A +k B 。
At stage 604, A and B run m parallel oPRF evaluations, where A is taken as using k A And B as a key holder using a semi-blinded message (k B +b 1 ,k B +b 2 ,…,k B +b m ) Is a message holder of (a). At the end of these evaluations, both parties learn f k *(B)＝{g 1/(k_A+k_B+b_i) mod p, for all i ε [ m ]]}。
At stage 606, A and B then run n parallel oPRF evaluations in reverse, where B is taken as using k B And a as a key holder using a semi-blinded message (k A +a 1 ,k A +a 2 ,…,k A +a n ) Is a message holder of (a). After these evaluations, both parties learn f k *(A)＝{g 1/(k_A+k_B+a_j) mod p, e [ n ] for all j]}。
At stage 608, a and B determine the PSI by taking the intersection of the outputs from stage 604 and stage 606. That is, A calculates the items in the intersection as { a } j :f k *(a j )∈f k * (B) and B computes the items in the intersection as { B } i :f k *(b i )∈f k *(A)}。
An overview of the oPRF sub-protocol 700 is shown in the flow chart depicted in fig. 7. Assuming that S and R are two parties, where S holds PRF key k and R holds message m, and both parties want to calculate f k (m)。
At stage 702, S and R each generate a sufficiently large reliable RSA modulus n, respectively S And n R And transmit the moduli to each other. They are also each directed to n respectively S And n R Generating g for large complex order subgroups of modes S 、h S And g R 、h R And randomly generating the elements. S proving g S Is positioned at<h S >And R demonstrates g R Is positioned at<h R >。
At stage 704, S and R also select generator g of prime number p=kq+1, and ord g=q in z×p.
At stage 706, S is for modulus n S 2 generation of a Cameisch-Shoup Key (pk) S ，sk S ) And transfer pk to R S Encryption C (S, k) of k below. S further proving to R that S knows k at the encryption bottom layer, and that k has the correct size (n is used in the Camenisch-Shap style knowledge proof R As a commitment (modulus). The operation also commits the key k to S.
At stage 708, R is at pk S The encryption C (S, m) of its message m is generated below, and C (S, m+k) is homomorphically calculated. R is obtained by generating random blinding factor R with proper size 1 And r 2 And homomorphically calculate C (S, r 1 (m+k)+r 2 * q) to additionally blind the ciphertext. R combines ciphertext with R 1 And r 2 Is transmitted to S together with the promise of S. R then proves that both ciphertexts are correctly generated and that R has a certain size 1 M and r 2 Is such that (r) 1 (m+k)+r 2 * q) will not be at pk S Is wrapped around in the message space of (a). Parties may use a Cameisch-Shoup knowledge proof, where n is used S As a promise modulus.
At stage 710, S decrypts C (S, r 1 (m+k)+r 2 * q) to receive the value β, and calculate γ=β -1 mod q. Modulus removal r 2 * q, thus γ=1/r 1 (k+m) mod q. S then calculates σ=g γ And transmits this value to R along with the proof that it was properly generated.
At stage 712, R calculates g 1/(k+m) ＝σ* r _ 1 And will g 1/(k+m) As it used the same r as the previous promise 1 Is transmitted to S.
The process 700 does not rely on a common modulus between the parties S and R, and thus, alternatively, the parties use a combination of several schemes to ensure security. First, each party must choose a reliable RSA modulus and have the Pedersen commitment relative to the other party's modulus, which removes one of the primary trust assumptions. Each party still uses the cam-Shoup as its homomorphic encryption scheme, but has its own generated parameters, without a common modulus. Furthermore, the message space for encryption, the commitment of petersen, and the final PRF evaluation each have different sizes, so each attestation generated by a party should include an interval attestation component, showing that the commitment/encrypted value is the same across different message spaces. In particular, messages should not be reduced at any time modulo one of the large spaces.
To ensure that parties strictly adhere to a restricted value range during execution of the protocol and do not insert additional values on which to evaluate the PRF, each party promises to advance all values on which to evaluate the PRF, proving that they are of the correct size, and then later proving in the protocol that the party uses only the previously promised values.
Cameisch-Shoup encryption
The techniques and protocols used herein may employ cam-shap encryption. These encryption techniques may involve the following:
KeyGen: the RSA modulus n=pq is selected. For r<-Z n^2 Choosing a random nth residual g=r n mod n 2 . Select x<-n 2 /4 and assuming y=g S x . The secret key is (p, q, x) and the public key is (n, g, y). For an efficient implementation, p and q should have large prime factors and may even be reliable prime numbers.
Encrypt (m): ciphertext is tuple (u, e), where u=g r mod n 2 ，e＝(1+n) m .y r mod n 2 . r is at Z n/4 Is randomly selected, and m is at [ n ]]Is a kind of medium.
Decrypt (u, e): can be calculated (((e/u) x )-1)mod n 2 ) N effectively recovers m given p, q and x.
Message space size = Z n . With mod n, all messages are implicitly reduced.
ElGamal encryption
KeyGen: selecting random prime numbers p and Z p Is a random generator g of (a). Random r.epsilon. [ phi. (p) is chosen ]And set y=g r mod p. The secret key is r and the public key is (g, p, y).
Encrypt (m): random r' is chosen and u=g is calculated r’ mod p，e＝y r’ M mod p. Ciphertext is c= (u, e).
Decrypt (c): calculating m=e/u r mod p。
Knowledge of discrete logarithm proof
This is a three-round protocol that proves knowledge of the well-known G, y e some group G, and the discrete logarithm of the secret x, x=log (y). The following was demonstrated:
both sides know g and y. P knows x such that y=g x . Let k and k' be security parameters.
a. For randomly selected r<-[-ord(g)*2 k+k’ ,ord(g)*2 k+k’ ]P conveys u=g r 。
b.V transmits random c<-[2 k ]。
c.p calculates r '=r-cx and transmits r' to V
d.V verification g r’ ＝u/y
If the prover knows c in advance, the prover may first know c from [ -ord (g) ×2 k+k’ ,ord(g)*2 k+k’ ]Randomly and uniformly selecting r', and then setting u=g r’ /y c . As long as k 'is large enough, the distance between the distribution of k' and u and the true distribution is negligible. In this way, the protocol may always have honest verifier zero knowledge: the prover runs the protocol to step b, learns of c, and then returns and spoofs to generate u.
If the discrete logarithm is hard in G, the protocol is reasonable. In other words, if P consistently successfully convinces V, then the discrete logarithm x' can be extracted such that y=g x’ . However, this proof is not a proof of knowledge, as x' may be different in different extractions (although all answers are congruent modulo ord g), whereas a proof of knowledge will always extract the same value. In order to ensure that the same value is extracted each time, ord g should additionally be difficult to find. The techniques disclosed herein may utilize knowledge proof performed in a hidden order (order) loop group, e.g., as described by Cameisch-Shoup.
The protocol may be converted to a completely zero-knowledge protocol using Fiat-Shamir heuristics in the random prophetic (oracle) model, or by committing c to V in advance.
Commitment of Pedersen
The petersen commitment allows parties to commit to the index x in a group G in a manner that is perfectly hidden and constrained based on the hardness of the discrete logarithm.
Each party knows the common parameters G, h, G, where G and h are different generator of group G. G may generally be any population, provided that log g h is difficult to determine.
a. For commitment of message m, calculate random r<Ord (G), and output c=g m .h r
b. In order to violate the promise message m towards c, m and r are revealed.
As long as G and h are indeed generator elements (or weaker, if G e < h >), the commitment of petersen is perfectly hidden, since c is perfectly random in G (resp. < h >). This perfectly hidden nature is maintained even if the recipient knows all kinds of secret information about G. The commitment is additionally constrained (modulo ord < g >) as long as log g h is difficult to calculate.
If G is a prime order cyclic group where it is difficult to calculate the discrete logarithm, it is sufficient to choose G as any random element (e.g., by jointly throwing coins) and H as H (G), where H is a hash function.
Knowledge proof of equality of commitment values using Pedersen commitments
The primitives (2) + (3) are combined to obtain a proof of knowledge of the promised value. In particular, y=g can be demonstrated x Where x is the value of the commitment in commitment com. This technique can be applied even when y and c are in different clusters. It relies on the security of the strong RSA hypothesis.
The order of the group committing com should be hidden from the proving party. Specifically, let com be calculated by mod n, where n=pq, and p, q are reliable prime numbers, where p=2p '+1, q=2q' +1. More specifically, the group of com is Z n The inner order is a subgroup G of n ' =p ' q '. The beneficial properties of this population are if Z × n Is selected and raised to a power of 2, then there is a high probability that it is the generator of G.
For robustness to be maintained and unique values to be extracted, any performed operations should not wrap around in the hidden order group. In particular, x should be sufficiently smaller than n' so that c x does not wrap around in any cluster, with some additional slack to guarantee zero knowledge. Thus, if the challenge c is k in length and zero knowledge corresponding to security k 'is desired and the group containing y is m-th order, then n' should be >8.2 k+k’ .m。
The promise may be as follows: s (transmitting side) and R (receiving side) are assumed to be two sides. Let y, g, m be known to both parties, and x be known to S, so that y=g x mod m. Furthermore, in light of the above discussion, it is assumed that RN has been generated and it is assumed that G' is Z #) n An n' order subgroup within.
a. First, R proves that n is a reliable RSA modulus, following Cameisch-Michels section 5.2 (this step can be ignored, and only if R does not perform it correctly, it compromises the constraint guarantee on P)
b. S and R then perform a combined coin-throw operation to produce G ', h ', which are random generators of G '. Alternatively, the weaker constraint is that R select g ' and h ' and prove g ' E<h’>. This preserves the perfect hidden nature of S and only if R poorly selects g 'and h', e.g., so that log can be calculated h 'g' the constraint is compromised.
c.S transfer is directed to r<-[n/4]Com=g' x /h’ r
d.S selection of r1<-[-2^ k+k’ .m,2^ k+k’ .m]And r2<-[-2 k+k’ .n/4,2 k+k’ .n/4]And u1=g r1 、u2＝g’ r1 .h’ r2 Is transmitted to R
e.R random selection of c<-2 k And transmits it to S.
f.S calculating r 1 ’＝r 1 -cx and r 2 ’＝r 2 -cr, and r 1 ' and r 2 ' transfer to R
g.R verification g r1’ ＝u1/y c mod m and g' r1’ .h’ r2’ ＝u 2 /com c mod n, and further verify |r 1 ’|≤2 k+k’ M exceeds an integer. If so, then R concludes that com is x=log g y promises, and |x| <2 k+k’ .m。
The above protocol demonstrates that S knows the value x at the bottom of commitment com, which is also a discrete logarithm of y, and furthermore |x| |<2 k+k’ And m. Likewise, it is also an interval proof showing that x has a bounded size. This is followed by one property because of r 1 ' is bounded so any x obtained by extraction from 2 accepted proofs, like x= (r) 1 ’-r 1 ")/(c-c') will also be bounded.
The protocol has been shown to be cam isch-Shoup based on the strong RSA assumption, which provides a proof of knowledge, in particular when the interval proof component is included, which has a unique extraction.
Interval certification
Typically, interval evidence shows that discrete logarithms are bounded within a particular interval. Interval attestation may be similar to discrete logarithmic knowledge attestation except that the final attestation message is bounded. This has 2 k Where k is the length of challenge c, meaning that if the message<m, the proof will only convince that the verifier message is less than 2 k *m。
Combined coin throwing
Joint coin casting is a process in which two parties choose random values, neither of which can affect it. For an n-bit random value, each party selects a random shared r with a length of n bits 1 And r 2 And transmits a commitment (hash) to the other party it shares. After receiving the commitments of the other parties, they then each open up shares to the other party, and all set r=r 1 XOR r 2 。
Boneh-Boyen style PRF
Boneh-Boyen signature f k (m) =g1/(k+m) mod p is the PRF under the strong q-Diffie-Hellman-Inversion assumption, where m ε [ q ]]. That is, as long as m is derived from a specified finite field, f k (m) is indistinguishable from the random element mod p (and this property is for f k (m) a plurality of evaluations).
In particular, the message space q should be polynomial-sized, since the security reduction is iterated over virtually every element in the message space.
Detailed description of the oPRF protocol
Further details of the oprsf protocol that may be used in implementations consistent with the techniques described herein are as follows. The protocol uses the security parameter k (oprsf key), but implicitly k is decomposed into k '+k ", where k' is the challenge length and k" is the ZK quality parameter.
Permanent setup phase
At this stage, both parties generate common parameters that can be used across different runs of the entire PSI protocol.
Both sides determine a large prime number q, p=tq+1, and are represented by Z p Generating element g of q-order cyclic subgroup of the modulus. These may be pre-fixed parameters or may be generated as follows:
a) Parties participate in a combined coin throw to jointly select a starting candidate q 1 。
b) Both sides find alone >q 1 And mutually validating the result.
c) Both parties find the smallest t > =2, so that tq+1 is a prime number, and p=tq+1 is set.
d) Both parties perform steps a and b to jointly find the generator g of the q-order subgroup. Note that Z raised to a power t p Is a high probability that the random element of the subgroup is the generator of the subgroup (if not, g t ＝1)。
Each party selects size independently>2 3k *q 2 Is n respectively 1 And n 2 . Each party maintains factored privacy for its generated modulus. These moduli are used for both commitment and cam-shap encryption. Each party also generates a modulus n relative to it i Is a key (sk) for Cameisch-Shoup encryption i ,pk i ) The key consists of a verified random nth residual g, and for a secret x, y=g x 。
For modulus n 1 Generating element g of large subgroup selected by 1 st party 1 ' and h 1 ’mod n 1 ' wherein for randomly selected r<-n 1 /4，g 1 ’＝h 1 ’ r mod n 1 . Specifically, h 1 ' selected as the random value mod n 1 And raised to a power of 4. Furthermore, proof of direction 1, direction 2 r=log h_1’ g 1 ’mod n 1 Is a knowledge of (a). The same is done in the 2 nd side, and the generation element g is selected 2 ' and h 2 ’mod n 2 ', and demonstrate log h_2’ g 2 ’mod n 2 Is a knowledge of (a).
Each PSI protocol setup phase
This section discusses the operations performed to set each PSI protocol run. Upon reaching PSI operation, the input should be re-scrambled and the key re-selected to prevent an adversary from correlating information that is running across different PSIs.
The system scrambles and commits all the values and proves that they are of the correct size. This size proves to be stringent to reduce q-DHI. Scrambling requires no proof.
Party 1 selects random PRF key sharing k 1 And party 2 selects k 2 The size of each<=q. Both parties use the key k 1 +k 2 Calculation of PRF g at various values of m (1/k _ 1+k _ 2+m) mod p。
Direction 1, direction 2 transfer, n 1 K under corresponding cam-shap key 1 Is (are) encrypted, n 2 K below 1 Is a promise of (a). The 2 nd party does so, in other words, transmits n 2 K under CS key of (c) 2 Is (are) encrypted, n 1 K below 2 Is a promise of (a).
Party 1 proves k at the encrypted bottom layer 1 Is the same as its committed value, and k 1 <＝2 k Q. Specifically, it performs the following ZK protocol:
both parties know that:
·n 1 g is a random value mod n selected by party 1 1 2 ，g’＝g n _ 1 mod n 1 2 Verified nth 1 Residual, y=g x mod n 1 2 Corresponding to the public key of the cam channel public scheme of party 1.
·n 2 ，n 2 Generator g of subgroup of (2) 2 ’、h 2 ' as selected in step 3,
(u, e) =cam-shap key (n) 1 K under g', y) 1 Is used for the encryption of the (c),
·com＝n 2 k below 1 Is promised by (a)
Party 1 knows:
·k 1 r, r', such that
·u＝g’ r mod n 1 2
·e＝y r .(1+n 1 ) k _ 1 mod n 1 2
·com＝g 2 ’ k1 h 2 ’ r’ mod n 2
·|k 1 |<q。
a. Party 2 commitment n 1 Lower part of [2 ] k’ ]Challenge chal in
b. Selection of r from 1 st side 1 <-[-2 k .q,2 k .q]、r 2 <-[-2 k .n 1 /4,2 k .n 1 /4]And r 3 <-[-2 k .n 2 /4,2 k .n 2 /4]And transmit
i.u 1 ＝g’ r 2 mod n 1 2
ii.u 2 ＝(1+n 1 ) r1 .y r2 mod n 1 2
iii.u 3 ＝g 2 ’ r1 .h 2 ’ r3 mod n 2
c. Party 2 opens the commitment from step (a), revealing the chal.
d. The 1 st party responds as follows
i.r 1 ’＝r 1 -chal.k 1
ii.r 2 ’＝r 2 -chal.r
iii.r 3 ’＝r 3 -chal.r’
e. Party 2 verification
i.g r2’ ＝u 1 /u chal mod n 1 2
ii.(1+n 1 )^r 1 ’.y r2’ ＝u 2 /e chal mod n 1 2
iii.g 2 ’ r1’ .h 2 ’ r3’ ＝u 3 /com chal mod n 2
iv.|r 1 ’|<2 k .q
Party 2 performs the same protocol in step 7, but instead shows k under encryption and commitment it generates 2 Knowledge of (c) and equality.
Procedure for each oPRF evaluation
Given the above settings, each oPRF evaluation in the protocol may include execution of the following operations. Recall that party 2 first evaluates the oPRF on each of its promised inputs, and then party 1 does so on each of its inputs. In some implementations, each oPRF evaluation requires 33 exponent operations from the transmitting party, and 40 exponent operations from the receiving party (including all attestations, assuming Fiat-Shamir ROM heuristics are used instead of committing challenges).
In the discussion below, the party holding the key is referred to as S, and the recipient is R. Without loss of generality, S is assumed to be party 1 and R is assumed to be party 2, so S knows n 1 Factorization of (1), but is not aware of n 2 Factorization of (c), etc.
Annotation:
i) Suppose E (k) 1 ) = (u, e) is the cam-shap encryption of k1 generated by S in step 7
ii) assume n 1 Is the modulus of S, and g 1 ’、h 1 'is its generator, and y' is the other component of the Camenisch Shoup key of S transmitted in step 8 (previously proven to be used for E (k 1 ))。
iii) Let n2 be the modulus of R, and g 2 ’,h 2 ' is its generator
iv) assuming that p, g, q are as generated in step 1
v) suppose C (k) 2 )＝g 1 ’ k2 *h1’ r1 mod n 1 And C (m) =g 1 ’ m *h 1 ’ r2 mod n 1 Is k generated by R in steps 7 and 5, respectively 2 And m w.r.t. modulus n 1 Is a promise of (a).
vi) as previously described, the security parameter k is decomposed into k=k '+k ", where k' is the challenge length and k" is the ZK quality parameter.
1)
a) R generates 2 random values a<-[q]And b<-[2 k-2 *q]. Let b= (a x (k) 1 +k 2 +m)) + (b x q). R homomorphism generates E (B) = (u ', E'), encryption of B under the Camenisch-Shoup key of S is as follows:
for r 3 <-[n 1 /4]
u’＝u a *g” r3 mod n 1 2
e’＝e a *(1+n1) a*(k2+m) *((1+n1) q ) b *y’ r3 mod n 1 2 。
b) R creation is directed to modulus n 1 The commitments C (a), C (b) to a and b are as follows:
for r 4 ,r 5 <-[n 1 /4]
C(a)＝g 1 ’ a *h 1 ’ r4 mod n 1 ，C(b)＝g 1 ’ b *h 1 ’ r5 mod n 1
c) R creates C (a (k) 2 +m)) as follows:
for r 6 <-[n 1 /4]
C(a(k 2 +m))＝((C(k 2 )*C(m)) a )*(h 1 ’ r6 )mod n 1 。
Alternatively, C (a (k) 2 +m)) can be rewritten from previous values:
C(a(k 2 +m))＝(g 1 ’ (a(k2+m)) )*(h 1 ’ (a(r1+r2)+r6)) mod n 1
let r be 7 ＝a(r 1 +r 2 )+r 6
2) R groups E (B), C (a), C (B) and C (a (k) 2 +m)) to S and proves the following:
i)a、b、a(k 2 +m)、r 3 、r 4 、…、r 7 knowledge of (2)
ii)|a|<＝2 k * q and |b|<2 2k *q
iii) The same a is used for calculating C (a) and E (B), and also for calculating from C (k) 2 ) And C (m) calculating C (a (k) 2 +m))。
iv) the same B is used in C (B) and E (B).
v) in C (a (k) 2 +m)) and E (B) are the same (a (k) 2 +m))。
The following was demonstrated:
b) S promise challenge c<-2 k’ (challenge space, less than 2 k )。
c) R selects v 1 <-[-2 k .q,2 k .q]、v 2 <-[-2 2k .q,2 2k .q]、
v 3 <-[-2 k .n 1 ,2 k .n 1 ]、v 4 、…、v 7 <-[-2 k .n 1 /4,2 k .n 1 /4]、
v 8 <-[-2 2k .n 1 .q,2 2k .n 1 .q]
Note that v 8 Is larger in size. Since it requires hiding a (r) 1 +r 2 )+r 6 Which is larger than usual.
d) R calculation
i)u 0 ＝u v1 *g” v4 mod n 1 2
ii)u 1 ＝e v1 *(1+n 1 ) v3 *((1+n 1 ) q ) v2 *y’ v4 mod n 1 2
iii)u 2 ＝g 1 ’ v1 *h 1 ’ v5 mod n 1
iv)u 3 ＝g 1 ’ v2 *h 1 ’ v6 mod n 1
v)u 4 ＝(C(k 2 )*C(m)) v1 *h 1 ’ v7 mod n 1
vi)u 5 ＝g 1 ’ v3 *h 1 ’ v8 mod n 1
And u is to 0 、...、u 5 And transmitting to S.
e) S opens its promise to c
f) R calculates v 1 ’＝v 1 -c.a、v 2 ’＝v 2 -c.b、
v 3 ’＝v 3 -c.a(k 2 +m)、v 4 ’＝v 4 -c.r 3 、…、v 8 ’＝v 8 -c.r 7 。
g) S verification
i)u v1’ *g” v4’ ＝u 0 /u c mod n 1 2
ii)e v1’ *(1+n 1 )^(v 3 ’)*((1+n 1 ) q )^v 2 ’*y v4’ ＝u 1 /e c mod n 1 2
iii)g 1 ’ v1’ *h 1 ’ v5’ ＝u 2 /C(a) c mod n 1
iv)g 1 ’ v2’ *h 1 ’ v6’ ＝u 3 /C(b) c mod n 1
v)(C(k 2 )*C(m)) v1’ *h 1 ’ v7’ ＝u 4 /C(a(k 2 +m)) c mod n 1
vi)g 1 ’ v3’ *h 1 ’ v8’ ＝u 5 /C(a(k 2 +m)) c mod n 1
vii)|v 1 ’|<＝2 k * q and |v 2 ’|<2 2k *q
3) S decrypts E (B) = (u, E) and recovers B, confirming its absolute size<2 2k .q 2 And g=b is calculated -1 mod q. Note that if all the above steps are calculated correctly, then g=1/a (k 1 +k 2 +m) mod q. S calculation
i)σ*＝g G mod p
ii)C(B)＝g 2 ’ B h 2 ’ r mod n 2
Wherein r is<-n 2 And/4, and transmitting σ and C (B) to R. This also demonstrates that σ is calculated correctly. By showing sigma B This is done by =g mod p, where B is the same value as encrypted in E (B) and committed in C (B). Is proved as follows, wherein (n 1 G', y) and (p, q, x) are the cam-Shoup public and secret keys, respectively, of S. S will prove knowledge of B, x and r, and B is the same in σ, E (B) and C (B), and further x is the same in E (B) and y:
b) R promise challenge c<-[2 k’ ]
c) S selects v 1 <-[-2 3k .q 2 ,2 3k .q 2 ]、v 2 <-[-2 k .n 1 /4,2 k .n 1 /4]、
v 3 <-[-2 k .n 2 /4,2 k .n 2 /4]
d) S calculation
i)u 1 ＝σ* v1 mod p
ii)u 2 ＝(1+n 1 ) v1 *u v2 mod n 1 2
iii)u 3 ＝g’ v2 mod n 1 2
iv)u 4 ＝g 2 ’ v1 *h 2 ’ v3 mod n 2
And u is to 1 、…、u 4 Is transmitted to R
e) R opens promise to c
f) S calculation
i)v 1 ’＝v 1 -c.B
ii)v 2 ’＝v 2 -c.x
iii)v 3 ’＝v 3 -c.r
g) R verification
i)σ* v1’ ＝u 1 /g c mod p
ii)(1+n 1 ) v1’ *u v2’ ＝u 2 /e c mod n 1 2
iii)g’ v2’ ＝u 3 /y c mod n 1 2
iv)g 2 ’ v1’ *h 2 ’ v3’ ＝u 4 /C(B) c mod n 2
v)|v 1 ’|<2 3k .q 2
If these are maintained, then R accepts σ to be g (B^-1) mod p, where B is the value encrypted in E (B).
4) R calculation σ=σ a mod p, wherein a is the same value as committed in C (a) in step 10 b. It passes σ to S and uses a technique similar to that described above to prove that σ was correctly generated. (details omitted). Sigma=g 1/(k1+k2+m) mod p is the desired value.
Malicious radix
The techniques disclosed herein for securely determining cardinality (where both parties learn only the size of the intersection in a malicious setting) are similar to those used for secure PSI. Typically, the parties jointly and securely calculate the oprsf on each item in each party's list. However, before the protocol is completed, the party acting as the transmitting party will veritably scramble all the oPRF results. Thus, the recipient will receive the correct oPRF evaluation on its list and can find out which are in the intersection, but cannot discern which oPRF value corresponds to which of its original items due to scrambling.
The protocol may apply 7 rounds of verifiable scrambling of ElGamal ciphertext. The modified oPRF protocol is summarized below. In some embodiments that facilitate scrambling, the oPRF applies to all messages together, rather than one message at a time:
the sender S holds the oPRF key k and the receiver R has t messages m 1 、…、m t Is a list of (3).
S generates a key k for a Cameisch-Shoup cryptosystem S1 And generates a second key k for the ElGamal cryptosystem S2 . The ElGamal key will calculate the same group G (typically Z × of PRFs in it p Q-th order subgroup of (b).
S Calenisch-Shoue homomorphic encryption C (S) with its PRF key transferred to R 1 Knowledge proof of k)
For each m in its list i R is C (S) 1 ,B i ) Promise C (a) i ) And C (b) i ) And proof of knowledge in response, wherein B i ＝b i *q+a i (k+m i ). (so far this is the same as PSI oPRF except that all R messages are handled together).
S decrypts each ciphertext it receives and calculates σ i ＝g Bi^-1 mod p. It then encrypts ElGamal to C (S 2 ,σ* i ) Is transmitted to R and proves that they are derived from C (b i ) s is calculated correctly. More specifically, for each C (S 2 ,σ* i ) S is first to n 2 Under promise Com (B) i ) Transmitted to R, the following proof is then performed, where k=k '+k "is a security parameter, the challenge length is k' and the ZK mass is k".
1) Both sides know
a)(u 1 ,e 1 )＝C(S 1 ,B i ) The cam root key of S (n 1 Ciphertext under g, y)
b)(u 2 ,e 2 )＝C(S 2 ,σ* i ) Ciphertext under ElGamal key (p, g ', y') of S
c)c 1 ＝Com(B i ) Commitment parameter of R (n 2 ,g 2 ,h 2 ) Under promise of
2) S knows
a)Camenish Shoup secret key x 1
b) Value B i
c) For u 2 、e 2 ElGamal secret key x of (x) 2
d) For generating c 1 Random r of (2)
And want to prove
(i)e 1 ＝u 1 x1 .(1+n1) Bi mod n 1 2
(ii)y＝g x1 mod n 1 2
(iii)e 2 ＝u 2 r .(g’ -1 ) Bi mod p
(iv)c 1 ＝g 2 Bi .h 2 r mod n 2 The commitment is for robustness and extractability.
(v)|B i |<2 2k .q 2
3) R promise random challenge c<-2 k’
4) S selects a random value r 1 <-[-2 k .n 1 /4,2 k .n 1 /4]、r 2 <-[-2 3k .q 2 ,2 3k .q 2 ]And r 3 <-[-2 k .q,2 k .q]、r 4 <-[-2 k .n 2 /4,2 k .n 2 /4]And calculate
a)v 1 ＝u 1 r1 .(1+n 1 ) r2 mod n 1 2
b)v 2 ＝g r1 mod n 1 2
c)v 3 ＝g’ r3 mod p
d)v 4 ＝u 2 r3 .(g’ -1 ) r2 mod p
e)v 5 ＝g 2 r2 .h 2 r4 mod n 2
And v is to 1 、…、v 5 Is transmitted to R
5) R reveals random challenge c
6) S calculation
a)r 1 ’＝r 1 -c.x 1
b)r 2 ’＝r 2 -c.B i
c)r 3 ’＝r 3 -c.x 2
d)r 4 ’＝r 4 -c.r
And will r 1 ’、r 2 ’、r 3 ’、r 4 Is transmitted to R
7) And R verification:
a)u 1 r1’ .(1+n 1 ) r2’ ＝v 1 /e 1 c mod n 1 2
b)g r1’ ＝v 2 /y c mod n 1 2
c)g’ r3’ ＝v 3 /y’ c mod p
d)u 2 r3’ .(g’ -1 ) r2’ ＝v 4 /e 2 c mod p
e)g 2 r2’ .h 2 r4’ ＝v 5 /c 1 c mod n 2
f)|r 2 ’|<2 3k .q 2
And (5) deducing proof.
r 1 、r 1 ’、r 3 And r 3 ' the same value can span all messages m i But is used because it refers to the same key x 1 And x 2 。
R homomorphism calculation C (S2, sigma) i ) And compares it with the certificate (these ciphertexts are using the same a as the previous commitment) i And correctly determined) are transmitted together to S, wherein sigma i ＝σ* i ai mod p. More precisely, for each item i, R performs the following attestation:
1) Both parties know that:
a)u 1 ,v 1 ＝C(S 2 ,σ* i ) ElGamal encryption under the public key of S (p, g, y)
b)u 2 ,v 2 ＝C(S 2 ,σ i ) Another ElGamal encryption under the same key
c)c 1 ＝Com(a i ) Parameters of S (n 1 ,g 1 ,y 1 ) Lower pair a i Is promised by (a)
2) R knows:
a) Commitment c 1 Is a of the bottom layer of (2) i And make sigma i ＝σ* i ai
b) After re-randomization (u 2 ,v 2 ) R used in (1)
c) Promise Com (a) i ) R 'used in'
And want to prove
d)u 2 ＝u 1 ai .g r mod p
e)e 2 ＝e 1 ai .y r mod p
f)c 1 ＝g 1 ai .h 1 r’ mod n 2
g)|a i |<2 k .q
3) S promise challenge c
4) R selects a random value R 1 <-[-2 k .q,2 k .q]、r 2 <-[-2 k .q,2 k .q]、r 3 <-[-2 k .q,2 k .q]，
And calculate
a)v 1 ＝u 1 r1 .g r2 mod p
b)v 2 ＝e 1 r1 .y r2 mod p
c)v 3 ＝g 1 r1 .h 1 r2 mod n 1
And v is to 1 、v 2 And v 3 Is transmitted to S
5) S violates promise challenge c
6) R calculation
a)r 1 ’＝r 1 -c.a i
b)r 2 ’＝r 2 -c.r
c)r 3 ’＝r 3 -c.r’
7) S, verification:
a)u 1 r1’ .g r2’ ＝v 1 /u 2 c mod p
b)e 1 r1’ .y r2’ ＝v 2 /e 2 c mod p
c)g 1 r1’ .h 1 r2’ ＝v 3 /c 1 c mod n 1
and (5) deducing proof.
S selects the permutation pi and the ciphertext C (S 2 ,σ i ) Scrambling and decrypting the list to reveal list sigma to R π(i) . S then transmits the correctly scrambled and decrypted Groth certificate. Before returning the value, S should check the decrypted sigma π(i) Whether there is a repetition in the list of (c). S should abort the protocol and infer that R is spoofing, if any.
R concludes that it has received a scrambled PRF evaluation of its list.
The modified oPRF described above can adapt to the PSI protocol to provide secure computation of cardinality. In some implementations, the following additional features may be applied, all of which may be handled using the same or corresponding techniques as used for PSI.
Each oPRF calculation may be based on a split key calculation, where party 1 has a key k 1 And party 2 has the key k 2 And both securely calculate PRF k (m), wherein k=k 1 +k 2 . For this purpose, party 1 has, as before, a key k 1 And party 2 uses k 2 +m as its message. Together they calculate g securely 1/(k1+k2+m) 。
To avoid CRS, both parties create RSA moduli and party 1 commits to the modulus of party 2 and vice versa.
When performing equality proofs across the cam-shap ciphertext, elGamal ciphertext, and commitment, the parties may be careful because each of them may have different message spaces. In particular, interval attestation may be used to show that encrypted messages do not wrap around in the message space.
Malicious intersection sum (homomorphic sum of items in an intersection)
In some implementations of the intersection summation task, there is a list M with items A ＝(a 1 ,…,a n ) And M B ＝(b 1 ,…,b m ) In addition, an item in the list of B has a value T associated with it B ＝(t 1 ,…,t m ). The goal is to calculate Sum { t } i :b i ∈M A ∩M B I.e. the sum of the tags (i.e. associated values) of the items in the intersection of the two lists.
The malicious radix protocol may be modified to include the functionality described above. At a high level, the idea is to scramble the tags with the associated oPRF values, but first double encrypt them so that neither party knows which t i ' in the intersection. The exponent ElGamal encryption scheme may be used with threshold decryption.
A malicious blinder (blinder) may only need a single additional scrambling of the threshold encryption ciphertext of the tag value in the same order as the scrambling of the ID. The additional ciphertext list may reuse much of the work from the original scrambled evidence in the same way as the scrambled evidence. In summary, this may result in 4 or more exponentiations by the sender (3 n to verify encryption of the tag and n to validate the scrambling), and 6 or more exponentiations by the receiver (2 n to encrypt the tag values under the joint key, 2n to validate the correctness of these encryptions, and 2n to validate the scrambling).
Notably, the exponent ElGamal has a limited ciphertext space. If the sum of the tags is too large to be contained in a single exponent ElGamal ciphertext, the tags may be partitioned into multiple ciphertexts. Each item may thus be associated with multiple tags, all of which are scrambled synchronously, and also summed by component. This leaks some additional partial sum information: the sum of each tag component is revealed. However, in some settings, this leakage may be insignificant. Furthermore, each additional tag may require more than 3n exponentiations from the transmitting side and 6n exponentiations from the receiving side.
Threshold decrypted exponent ElGamal
Setup: the parties jointly select a prime number p=tq+1, and Z p The generator g of the q-order subgroup in (a).
KeyGen: each party Pi selects y alone i ＝g xi mod p, and set pk i ＝y i 、sk i ＝x i 。
Encrypt (m): to be in key { pk ] i ＝y i Under-set encrypted message m, assuming y=prod { Y } i }. Setting u=g r mod p and e=y r .g m mod p. Ciphertext is (u, e).
Decrypt(sk i U, e): by calculating a new ciphertext (u ', e'), a single party can use their secret key x i Partially decrypting the ciphertext, where u '=u and e' = e.u -xi mod p。
Once all parties have performed partial decryption with their keys, the remaining value is g m mod p, which can be recovered by computing discrete logarithms.
The exponent ElGamal can only be decrypted for relatively small messages, but if the message is long, it can be divided among multiple ciphertexts, all of which can be scrambled in a synchronous manner.
Candidate protocols for malicious blinders using the double encryption tag technique are provided below:
prior to oPRF evaluation:
both parties choose key sharing for the exponential ElGamal scheme (which is additive homomorphic and has valid decryption for small messages). The two keys should be in phaseIn the same group G, in particular, Z of prime numbers p selected in combination p Is a kind of medium.
Both parties share their generated public key y i 。
When B commits to their message set M B When B additionally transmits each tag t under the joint exponent ElGamal key Y derived by combining the two keys i Is (T) is (are) encrypted i And prove the correctness and knowledge of the underlying plaintext.
During the oPRF evaluation:
during oPRF evaluation, both parties are evaluating M A As in malicious radix protocols.
When evaluate M B In the case of the above oPRF, the parties may also act as in the malicious radix protocol until the transmitting party receives the encrypted C (S 2 ,σ i ) Is carried out by a method comprising the steps of. At this point, the transmitter scrambles and decrypts the values as previously described, and will { σ ] π(i) And transmitted to R. However, S uses the same permutation pi, additionally for the double encryption tag T i Scrambling and re-randomizing to list { T ] π(i) And transmitted to R. In so doing, the tag remains associated with the same message except that the actual permutation remains hidden due to the double encryption.
After the oPRF evaluation:
after two oPRF evaluations, a and B were compared at M A And M B PRF evaluation on the intersection to determine items in the intersection. For PRF values in the intersection, each party can add the associated scrambled, double-encryption tag T alone π(i) To create a double encrypted sum Enc (sum).
Both parties each veritably re-randomize Enc (sum). (here, this step is to enable the simulator to replace the sum with anything it wants)
Both parties then each verifiably partially decrypt the double encrypted sum and then calculate the discrete logarithm alone to recover the value "sum".
Security certification
Security credentials are similar to malicious onesProof of PSI and cardinality. In other words, a simulator is provided. Given a single ideal query, each for the size of the intersection, and the sum of the values in the intersection, the simulator can simulate an honest transcript. When the malicious party is A, the simulator only needs to provide the set M for the ideal function A Whereas if the malicious party is B, the simulator provides M B Sum { T ] i }。
At a high level, as in malicious PSI, the simulator extracts all messages from the value promised by the pre-oPRF phase, and if applicable, the tag value at the bottom of the ciphertext, and uses the message set and tag (optionally) as its single query for idealized functionality. It then pre-determines the oPRF results over all values so that the simulated oPRF interactions produce a set of cardinalities for the pairs. It then spoofs during the oPRF evaluation phase so that the oPRF always evaluates to a predetermined value so that the radix calculation is correct.
In addition, it is on the label T i Spoofing is performed in the authenticated scrambling of (2), replacing all encryption with 0 encryption. It uses a simulator of the scrambling protocol to implement the spoofing. Both sides calculate the encryption sum for these virtual values, with the result that encryption is always 0.
Finally, during the re-randomization step, it replaces the ciphertext that encrypts the (fake) sum with the ciphertext of the true sum received from the ideal function, and simulates the correct re-randomization proof. Each of these spoofs is undetectable by the simulated security and CPA security of the threshold encryption scheme.
Specific sequence of mixing: first spoofing is performed in a re-randomization step, using a new encryption of the real sum instead of the sum calculated from the actual oprrf protocol. Next, all the encryption in the output of the scrambled oPRF is replaced with an encryption of 0. The simulator of the scrambling protocol ensures that as long as the "sum" ciphertext is discarded downstream (downstream), which occurs due to the first spoofing, the simulation becomes indistinguishable from honest interactions.
Reverse blinder with virtual-based covert security
In some implementations, the disclosed technology relates to a method of determining a time of day (or other time period) in two parties (e.g., users) 1 And User 2 ) The execution of multiple privacy intersection-sum protocols between, while ensuring that neither party is spoofed and not captured. In more detail, the process is carried out,
·User 1 with stored user identifier u j Database M of (2) 1 。
External party (User) 2 ) Having means for storing pairs of user identifiers and associated integer values (u i ,t i ) Database M of (2) 2 . Wherein t is i May be with user u i Associated transaction data.
User 1's data is further broken down into "segments," which are M 1 Is included in the set of non-intersecting subsets of (a). M is M 1 Will be referred to as M 1,s 。
These two users wish to allow User 1 Learning the sum of each segment intersection of their dataset.
That is, for each s, user 1 It can be learned that:
Sum s ＝Σt i so that (u) i ,t i )∈M 2 And u i ∈M 1,s
Furthermore, security should be ensured against hidden opponents. That is, if one of the users is spoofing on some perceptible (appable) portion of the input, the other user should be able to detect the spoofing with a high probability.
The protocol includes three phases: a once-a-day setup phase, a per-segment phase, and a verification phase at the end of the day.
Daily setting
User at the beginning of the day 2 Upload { (u) i ,Pai 2 (t i ) An encrypted version of }, comprising a one-day encrypted transaction, with the key at user ID u i And (3) upper part. User (User) 1 Learning { f (u) i ) Used in User 2 Output of double key PRF for each of submitted UIDs, andand User 1 Creating pairs of all such f (u) in scrambling order i ) And re-randomized encrypted Pai 2 (t i ) Is a promise of (a). Any suitable commitment scheme may be employed, such as Merkle trees using SHA-256 hashes.
User by inserting virtual values into the protocol phase 2 User can be authenticated 1 And correctly performs its operation. By requiring a User 2 User for proving transmitted encrypted value 1 Can ensure User 2 Only data in good format is uploaded.
Stage 1:
for M 2 Each (u) i ,t i ) A for random selection i <-[q],b i <-[2 λ *q]User 2 homomorphism calculation Pai 1 (B i )＝Pai 1 (a i (k 1 +k 2 +u i )+b i q)＝Pai 1 (k 1 ) ai *Pai 1 (a 1 (k 2 +u i )+b i q) for each u i But not, and also calculates h i ＝g a _ i . User 2 also calculates Pai 2 (t i ) Encryption of the associated transaction value under the user 2's own Paillier key.
For random c k <2 2λ *q 2 And d k And e k <q, user 2 also generates a virtual tuple (Pai 1 (c k ),g d_k ,Pai 2 (e k )). It generates (X.times.M) 2 ) (1-X) such tuples, such that the virtual tuple forms M 2 And an X portion of a virtual combined database.
User 2 transmits all such (Pai 1 (B i ),h i ,Pai 2 (t i ) (real and virtual). With the security of Paillier encryption, virtual tuples will be indistinguishable from "real" tuples. H in real and virtual tuples i May have the same distribution g random 。
For each of the transfersTuple, if the tuple is authentic, user 2 stores the value (a i ,b i ,u i ,t i ,r enc ) And if the tuple is virtual, user 2 stores the value (c k ,d k ,e k ,r enc ) Wherein r is enc Is randomness for Paillier encryption (r is deleted for brevity) enc Index i and k) above). It stores the values in the same order as the scrambling pairs are transmitted to user 1.
Stage 2:
for each tuple received in phase 1 (Pai 1 (B i ),h i ,Pai 2 (v i ) User 1 decrypts to determine B) i And calculate f i ＝h i (1/B_i) And also selects a random value r j And homomorphically calculate Pai 2 (t i +r i ). User 1 also re-randomizes ciphertext Pai 2 (t i +r i ) And stores the randomness r 'for re-randomization' enc 。
User 1 pair tuple { (f) i ,Enc 2 (t i +r i ),r i ,r’ enc ) Scrambling, committing each entry individually, and transmitting the commitment to user 2 while maintaining a copy of the underlying value, including r used i And r' enc Values. It also keeps track of the order of scrambling.
Stage 3:
for each virtual generated in phase 1, the user will tuple (c k ,d k ,e k ,r enc ) And the scrambled position of the tuple in phase 1 is transmitted to user 1. This reveals to user 1 that the tuple is virtual.
Stage 4:
for each tuple (c) k ,d k ,e k ,r enc ) User 1 regenerates f k ＝g^(d k /c k ) And transmits the pair (f) to the user 2 k ,Pai 2 (e k +r k ),r k ,r’ enc ) Is a promised opening of the (c) program. These can be used by the user 2 to verifyIts virtual pair transmitted at index k is correctly manipulated and committed by user 1 (see stage 5 below)
User 1 also selects the subset J of X parts of the non-virtual tuples received from user 2 in stage 1. It requires the user 2 to provide these correctly generated credentials.
Stage 5:
for each virtual tuple, user 2 verifies that the opening provided by user 1 is correct, in other words, f i ＝g^(d k /c k ) And Pai 2 (t k +r k ) Is to use randomness r renc And use r' enc And re-randomize e k +r k Is used for the encryption of (a). User 2 also checks that the promise delivered by user 1 is correctly directed (f i ,Pai 2 (t i +r i ),r i ,r’ enc ) Open.
For each index i in set J, user 2 creates a proof that tuple i was correctly generated in stage 1. It is proved by a i And a i k 2 +a i u i +b i Knowledge of q does so such that
οPai 1 (a i (k 1 +k 2 +u i )+b i q)＝Pai 1 (k 1 )^a i *Pai 1 (a i k 2 +a i u i +b i q)
οh i ＝g a _ i And for index Pai 1 (k 1 ) The same index a of (2) i 。
οa i <2 λ *q
οa i k 2 +a i u i +b i q<2 2λ *q 2
These proofs may be standard sigma (sigma) protocols of exponential knowledge. The challenge need not be limited to a size of 0,1 because the Paillier key is generated by the verifier rather than the prover. During the setup phase attestation, because the verifier generated the Paillier key, it may be spoofed if the challenge is not in {0,1 }.
User 2 communicates all such credentials to user 1. These proofs do not restrict the user 2 from using the same k2 anywhere, or even using the same k2 as it transmitted in Pai2 (k 2) during setup. However, for a particular index i, using a different k2, such as k2+x, corresponds to keeping k2 unchanged and changing ui to ui+x, which is possible for user 2. Thus, by not checking that k2 is the same anywhere, no additional power is given to user 2. Stage 6:
User 1 verifies each proof received.
Each segment of protocol
Each segment of the protocol is similar in style to the one-day start protocol except that the user's role is reversed.
Stage 1:
for M 1,s Each u in (3) j A for random selection j <-[q],b j <-[2 λ *q]User 1 homomorphism calculates Pai 2 (B j )＝Pai 2 (a j (k 1 +k 2 +u j )+b j q)＝Pai 2 (k 2 ) aj *Pai 2 (a j (k 1 +u j )+b j q) for each u j But not, and also calculates h j ＝g a_j 。
For random c k <2 2λ *q 2 And d k <q, user 1 also generates a virtual tuple (Pai 2 (c k’ ),g d_k’ ) Is defined as part X of (c).
User 1 transmits all such (Pai 2 (Bj), hj) (real and virtual) in scrambled order to user 2.
For each tuple transferred, if the pair is authentic, user 2 also remembers the value (a j ,b j ,u j ,r enc ) And if the pair is virtual, remembering (c k’ ,d k’ ,r enc ) Wherein r is enc Is the randomness used for encryption. It stores the values in the same order as the scrambled pairs are transmitted to user 2.
Stage 2:
For each tuple received in phase 1 (Pai 2 (B j ),h j ) User 2 decrypts to obtain B j And calculate f j ＝h j (1/B_j) . It scrambles all such f in order j To the user 1.
Stage 3:
for each virtual generated in stage 1, user 1 will tuple (c k’ ,d k’ ,r enc ) To user 2, the tuple at which the index is revealed is virtual. User 1 further checks g dk/ck Appear at f received by user 1 in phase 2 j Is included in the list of (2).
For each remaining f received by user 1 in phase 2 j (i.e. not with virtual g) dk/ck Corresponding), user 1 looks up it in the beginning of the day commitment. For all f found j User 1 homomorphically adds the corresponding blinded Paillier ciphertext to obtain Pai 2 (Sum*)＝Pai 2 (Σ Intersection (t i +r i ))
User 1 additionally generates T Paillier ciphertext Pai corresponding to the virtual sum 2 (r* i )。
Pai that user 1 will be in a mutual arrangement 2 (Sum) and Pai 2 (r* i ) To the user 2. User 1 alone transmits T commitments { Com (r) i )}。
User 1 also transmits to user 2 an index list corresponding to the intersection, and a corresponding f i Value (but not Pai (t) i +r i )、r i Or r' enc Value) is opened.
Stage 4:
open for each virtual tuple received in stage 3 (c k’ ,d k’ ,r enc ) User 2 verifies that it received the corresponding virtual tuple (Pai in phase 1 2 (c k’ ,r enc ),g d_k )。
User 2 also verifies that the commitment corresponding to the intersection is open and checks that the intersection size is sufficiently large.
If so, user 2 decrypts each Paillier ciphertext received from user 1 and communicates the decryption back to user 1.
User 2 also selects the subset J of X parts of the non-virtual tuples received from user 1 in stage 1. It requires user 1 to provide proof that they are properly generated.
Stage 5:
user 1 verifies each virtual value r i Appears in the response transmitted by user 1 in the previous stage. If so, it transmits to user 1 the Com (r) i * ) Is open.
User 1 also communicates a proof that each of the tuples in the index set J was correctly generated. (the credentials transmitted by user 1 are similar to the credentials provided by user 2 in phase 4 of the day start protocol).
User 1 also transmits the Pai of the intersection 2 (t i +r i ) The promise of the value is open.
Finally, user 1 calculates Sum s ＝Sum*-Σ Intersection r i This is the sum of the segments, user 1 outputs for the protocol.
Stage 6:
user 2 verifies that the credentials and commitments transmitted by user 1 in the previous phase are open. It also decrypts each Pai 2 (t i +r i ) And verify sum=Σ Intersection (t i +r i ) As expected.
One-day ending protocol
After all segments have completed execution, an end of day protocol is executed.
Stage 1:
at the end of the day, user 1 opens the remaining, unused f from the day i Commitment (other than Pai (t) i +r i )、r i Or r' enc Is committed) and communicates the opening to user 2.
Stage 2:
user 2 verifies that the open is the correct open for the promise received at the beginning of the day.
It also verifies f in the open i The values are consistent with the intersections seen in each segment. User 2 checks for newly revealed f i Are not improperly omitted from a certain intersection by user 1.
Batch processing of Paillier ciphertext
Instead of transmitting separate Paillier ciphers for each database entry, a user may batch Paillier ciphers for multiple entries together by packing the Paillier ciphers for multiple entries into a single plaintext. This will greatly reduce traffic because each Paillier ciphertext can be packed to its maximum size rather than wasting a large amount of plaintext space. ZK attestation and virtual policies may also be transferred to batch settings. However, scrambling performed in the protocol must protect the proximity (proximity) of batch database entries, which leaks slightly more information than non-batch versions of the protocol. Furthermore, the virtual transferred during the protocol can only be batched with other virtual, otherwise the ZK proof and virtual insertion policy described above would no longer be possible to execute.
Fig. 10 is a schematic diagram of a computer system 1000. According to one implementation, the system 1000 may be used to perform the operations described with respect to any of the computer-implemented methods previously described. The system 1000 is intended to include various forms of digital computers, such as laptops, desktops, workstations, personal digital assistants, servers, blade servers, mainframes, and other appropriate computers. The system 1000 may also include mobile devices such as personal digital assistants, cellular telephones, smartphones, and other similar computing devices. In addition, the system may include portable storage media such as universal serial bus (Universal Serial Bus, USB) flash drives. For example, a USB flash drive may store an operating system and other applications. The USB flash drive may include an input/output component, such as a wireless transmitter or USB connector that may be plugged into a USB port in another computing device.
The system 1000 includes a processor 1010, a memory 1020, a storage device 1030, and an input/output device 1040. Each of the components 1010, 1020, 1030, and 1040 are interconnected using a system bus 1050. The processor 1010 is capable of processing instructions for execution within the system 1000. The processor may be designed using any of a variety of architectures. For example, the processor 1010 may be a CISC (Complex Instruction Set Computer ) processor, a RISC (Reduced Instruction Set Computer, reduced instruction set computer) processor, or a MISC (Minimal Instruction Set Computer, minimum instruction set computer) processor.
In one implementation, the processor 1010 is a single-threaded processor. In another implementation, the processor 1010 is a multi-threaded processor. The processor 1010 is capable of processing instructions stored in the memory 1020 or on the storage device 1030 to display graphical information for a user interface on the input/output device 1040.
Input/output devices 1040 provide input/output operations for system 400. In one implementation, the input/output devices 1040 include a keyboard and/or pointing device. In another implementation, the input/output device 1040 includes a display unit for displaying a graphical user interface.
The described features may be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. The apparatus may be implemented in a computer program product tangibly embodied in an information carrier, e.g., in a machine-readable storage device for execution by a programmable processor; and method steps may be performed by a programmable processor executing a program of instructions to perform functions of the described embodiments by operating on input data and generating output. The described features may be advantageously implemented in one or more computer programs executing on a programmable system including at least one programmable processor coupled to receive data and instructions from, and to transmit data and instructions to, a data storage system, at least one input device, and at least one output device. A computer program is a set of instructions that can be used, directly or indirectly, in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.
Suitable processors for the execution of a program of instructions include, by way of example, both general and special purpose microprocessors, and the sole processor or one of multiple processors of any kind of computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Typically, the computer will also include, or be operatively coupled to communicate with, one or more mass storage devices for storing data files; such devices include magnetic disks, such as internal hard disks and removable disks; magneto-optical disk; an optical disc. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, such as EPROM, EEPROM, and flash memory devices; magnetic disks, such as internal hard disks and removable disks; magneto-optical disk; CD-ROM and DVD-ROM discs. The processor and memory may be supplemented by, or incorporated in, ASICs (Application-specific integrated circuits).
To provide for interaction with a user, the features can be implemented on a computer having a display device such as a CRT (Cathode Ray Tube) or LCD (Liquid Crystal Display) monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer. Further, such activities may be conducted via a touch screen flat panel display and other suitable mechanisms.
The features may be implemented in a computer system that includes a back-end component, such as a data server, or that includes a middleware component, such as an application server or an Internet server, or that includes a front-end component, such as a client computer having a graphical user interface or an Internet browser, or any combination of them. The components of the system may be connected by any form or medium of digital data communication, such as a communication network. Examples of communication networks include local area networks (Local Area Network, "LANs"), wide area networks (Wide Area Network, "WANs"), peer-to-peer networks (with ad hoc or static members), grid computing infrastructure, and the internet.
The computer system may include a client and a server. The client and server are typically remote from each other and typically interact through a network such as the one described. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
While this specification contains many specifics of embodiments, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Furthermore, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the claimed combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Similarly, although operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous. Furthermore, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
Thus, particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. Additionally, the processes depicted in the accompanying drawings do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In some embodiments, multitasking and parallel processing may be advantageous.
Claims (20)
1. A method for protecting privacy when comparing privacy datasets of a first computing system and a second computing system, the method comprising:
Identifying, by the second computing system, a first set of identifiers corresponding to records in a privacy database of the second computing system;
for each identifier in the first set of identifiers:
(i) An encrypted version of the identifier is generated by the second computing system using a homomorphic encryption process,
(ii) Providing an encrypted version of the identifier from the second computing system to the first computing system,
(iii) Receiving, by the second computing system, from the first computing system, a blinded encrypted version of the identifier generated using the secret key of the first computing system, and
(iv) Decrypting, by the second computing system, the blinded encrypted version of the identifier to generate a blinded version of the identifier;
receiving, by the second computing system, a blinded version of the second set of identifiers corresponding to records in the privacy database of the first computing system;
determining, by the second computing system, an intersection or characteristic of an intersection of the records in the privacy database of the first computing system and the records in the privacy database of the second computing system based on a match between the blinded version of the first set of identifiers and the blinded version of the second set of identifiers; and
an indication of the intersection or a characteristic of the intersection is provided by the second computing system.
2. The method of claim 1, wherein, for each identifier in the first set of identifiers, the first computing system generates a blinded encrypted version of the identifier by processing the encrypted version of the identifier and a secret key of the first computing system according to a pseudo-random function.
3. The method of claim 2, wherein the pseudo-random function is an unintentional pseudo-random function.
4. A method according to claim 2 or 3, wherein the second computing system modifies the encrypted version of the identifier before providing the encrypted version of the identifier to the first computing system by combining the encrypted version of the identifier with a secret key of the second computing system, and wherein the first computing system generates the blinded encrypted version of the identifier by processing the modified encrypted version of the identifier according to a pseudo-random function, further based on the secret key of the second computing system.
5. The method of claim 4, wherein, for each identifier in the first set of identifiers, the second computing system modifies the encrypted version of the identifier by homomorphically adding the secret key of the second computing system to the encrypted version of the identifier.
6. The method of claim 1, further comprising:
mapping, by the second computing system, for each identifier in the first set of identifiers, a blinded version of the identifier to the identifier; and
for each identified match between a blinded version of an identifier from the first set of identifiers and a blinded version of an identifier from the second set of identifiers:
identifying, by the second computing system, a record in a privacy database of the second computing system corresponding to an identifier mapped to a blinded version of the identifier from the first set of identifiers; and
the identified records are classified by the second computing system as being within an intersection of the records in the privacy database of the first computing system and the records in the privacy database of the second computing system.
7. The method of claim 6, wherein the second computing system receives the blinded encrypted version of the first set of identifiers from the first computing system in a first order corresponding to a second order in which the second computing system provided the encrypted version of the first set of identifiers to the first computing system.
8. The method of claim 7, wherein the first order is consistent with the second order such that the second computing system receives the blinded encrypted version of the first set of identifiers from the first computing system in the same order in which the second computing system provided the encrypted version of the first set of identifiers to the first computing system.
9. The method of claim 1, comprising determining, by the second computing system, characteristics of intersections of records in the privacy database of the first computing system with records in the privacy database of the second computing system without determining which records are within the intersections.
10. The method of claim 9, wherein the characteristic of the intersection represents a count of a number of common identifiers included in a first set of identifiers corresponding to records in a privacy database of the second computing system and a second set of identifiers corresponding to records in a privacy database of the first computing system.
11. The method of claim 9, wherein the characteristic of the intersection represents a sum of values stored in records within the intersection of records between the privacy database of the first computing system and the privacy database of the second computing system at the privacy database of the second computing system.
12. The method of claim 1, wherein a first subset of identifiers from the first set of identifiers is also included in the second set of identifiers and a second subset of identifiers from the first set of identifiers is not included in the second set of identifiers.
13. The method of claim 1, further comprising:
determining, by the second computing system, whether the first computing system blinded the encrypted version of the first set of identifiers without departing from the prescribed protocol; and
in response to verifying that the first computing system deviated from the prescribed protocol when blinding the encrypted version of the first set of identifiers, an action is taken to stop execution of the prescribed protocol.
14. The method of claim 1, further comprising:
inserting, by the second computing system, a virtual identifier into the first set of identifiers, the virtual identifier not corresponding to a record in a privacy database of the second computing system; and
after receiving the blinded encrypted version of the first set of identifiers from the first computing system, verifying that the first computing system properly blinds the encrypted version of the virtual identifiers.
15. The method according to claim 1, wherein:
a first set of identifiers corresponding to records in a privacy database of a second computing system identifies a user who is a party to a transaction with an entity associated with the second computing system; and
a second set of identifiers corresponding to records in a privacy database of the first computing system identifies users of digital media items served to entities associated with the second computing system.
16. A computing system for securely determining a privacy set intersection or a characteristic of a privacy set intersection, comprising:
a privacy database on one or more computers storing a plurality of data records, wherein each data record includes an identifier representing an identity of the data record or an identity of a user represented in the data record;
one or more processors; and
one or more computer-readable media having instructions stored thereon, wherein the instructions, when executed by one or more processors, cause performance of operations comprising:
identifying, by the computing system, a first set of identifiers corresponding to records in a privacy database of the computing system;
for each identifier in the first set of identifiers:
(i) The homomorphic encryption process is used by the computing system to generate an encrypted version of the identifier,
(ii) Providing an encrypted version of the identifier from the computing system to the remote computing system,
(iii) Receiving, by the computing system from the remote computing system, a blinded encrypted version of the identifier generated using the secret key of the remote computing system, and
(iv) Decrypting, by the computing system, the blinded encrypted version of the identifier to generate a blinded version of the identifier;
Receiving, by the computing system, a blinded version of the second set of identifiers corresponding to records in a privacy database of the remote computing system;
determining, by the computing system, an intersection or characteristic of an intersection of the records in the privacy database of the remote computing system and the records in the privacy database of the computing system based on a match between the blinded version of the first set of identifiers and the blinded version of the second set of identifiers; and
an indication of the intersection or a characteristic of the intersection is provided by the computing system.
17. The computing system of claim 16, wherein, for each identifier in the first set of identifiers, the remote computing system generates a blinded encrypted version of the identifier by processing the encrypted version of the identifier and a secret key of the remote computing system according to a pseudo-random function.
18. The computing system of any of claims 16 or 17, wherein the operations further comprise:
for each identifier in the first set of identifiers, mapping, by the computing system, a blinded version of the identifier to the identifier; and
for each identified match between a blinded version of an identifier from the first set of identifiers and a blinded version of an identifier from the second set of identifiers:
Identifying, by the computing system, a record in a privacy database of the computing system corresponding to an identifier mapped to a blinded version of an identifier from the first set of identifiers; and
the identified records are classified by the computing system as being within an intersection of the records in the privacy database of the remote computing system and the records in the privacy database of the computing system.
19. The computing system of claim 16, wherein:
a first set of identifiers corresponding to records in a privacy database of the computing system identifies users who are parties to transactions with entities associated with the computing system; and
a second set of identifiers corresponding to records in a privacy database of the remote computing system identifies users of digital media items served with entities associated with the computing system.
20. A non-transitory computer-readable medium having instructions stored thereon, wherein the instructions, when executed by one or more processors, cause the one or more processors to perform operations comprising:
identifying, by the second computing system, a first set of identifiers corresponding to records in a privacy database of the second computing system;
For each identifier in the first set of identifiers:
(i) An encrypted version of the identifier is generated by the second computing system using a homomorphic encryption process,
(ii) Providing an encrypted version of the identifier from the second computing system to the first computing system,
(iii) Receiving, by the second computing system, from the first computing system, a blinded encrypted version of the identifier generated using the secret key of the first computing system, and
(iv) Decrypting, by the second computing system, the blinded encrypted version of the identifier to generate a blinded version of the identifier;
receiving, by the second computing system, a blinded version of the second set of identifiers corresponding to records in the privacy database of the first computing system;
determining, by the second computing system, an intersection or characteristic of an intersection of the records in the privacy database of the first computing system and the records in the privacy database of the second computing system based on a match between the blinded version of the first set of identifiers and the blinded version of the second set of identifiers; and
an indication of the intersection or a characteristic of the intersection is provided by the second computing system.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201862660108P | 2018-04-19 | 2018-04-19 | |
US62/660,108 | 2018-04-19 | ||
PCT/US2019/028295 WO2019204711A1 (en) | 2018-04-19 | 2019-04-19 | Security measures for determination of private set intersections |
Publications (2)
Publication Number | Publication Date |
---|---|
CN110622165A CN110622165A (en) | 2019-12-27 |
CN110622165B true CN110622165B (en) | 2023-05-30 |
Family
ID=66429634
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201980001669.3A Active CN110622165B (en) | 2018-04-19 | 2019-04-19 | Security measures for determining privacy set intersections |
Country Status (4)
Country | Link |
---|---|
US (1) | US11494506B2 (en) |
EP (1) | EP3580685B1 (en) |
CN (1) | CN110622165B (en) |
WO (1) | WO2019204711A1 (en) |
Families Citing this family (33)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP3408965B1 (en) * | 2017-03-03 | 2020-08-19 | Google LLC | Systems and methods for establishing a link between identifiers without disclosing specific identifying information |
US11405365B2 (en) * | 2019-03-13 | 2022-08-02 | Springcoin, Inc. | Method and apparatus for effecting a data-based activity |
CN110535622A (en) * | 2019-08-01 | 2019-12-03 | 阿里巴巴集团控股有限公司 | Data processing method, device and electronic equipment |
US10885203B2 (en) | 2019-08-01 | 2021-01-05 | Advanced New Technologies Co., Ltd. | Encrypted data exchange |
US11973743B2 (en) | 2019-12-13 | 2024-04-30 | TripleBlind, Inc. | Systems and methods for providing a systemic error in artificial intelligence algorithms |
US11431688B2 (en) | 2019-12-13 | 2022-08-30 | TripleBlind, Inc. | Systems and methods for providing a modified loss function in federated-split learning |
US10924460B2 (en) | 2019-12-13 | 2021-02-16 | TripleBlind, Inc. | Systems and methods for dividing filters in neural networks for private data computations |
CN111177762B (en) * | 2019-12-30 | 2022-11-08 | 北京同邦卓益科技有限公司 | Data processing method, device, server and federal learning system |
US11784800B2 (en) * | 2020-02-14 | 2023-10-10 | Google Llc | Secure multi-party reach and frequency estimation |
CN111641603B (en) * | 2020-05-15 | 2022-07-01 | 北京青牛技术股份有限公司 | Privacy set intersection data interaction method and system based on homomorphic encryption |
CN111753318B (en) * | 2020-06-04 | 2024-04-26 | 上海蚂蚁创将信息技术有限公司 | Multiparty security calculation method, device and system for private data |
CN111510464B (en) * | 2020-06-24 | 2020-10-02 | 同盾控股有限公司 | Epidemic situation information sharing method and system for protecting user privacy |
CN112052458B (en) * | 2020-07-28 | 2024-02-23 | 华控清交信息科技(北京)有限公司 | Information processing method, device, equipment and medium |
CN111931207B (en) * | 2020-08-07 | 2024-04-09 | 北京百度网讯科技有限公司 | Method, device, equipment and storage medium for obtaining privacy set intersection |
US11937078B2 (en) * | 2020-08-25 | 2024-03-19 | Crypto Lab Inc. | Mobile device for detecting route overlap and methods thereof |
CN111931253B (en) * | 2020-09-15 | 2021-01-15 | 腾讯科技（深圳）有限公司 | Data processing method, system, device and medium based on node group |
US11949778B1 (en) | 2020-09-16 | 2024-04-02 | Snap Inc. | Privacy-preserving multi-touch attribution |
US11507693B2 (en) | 2020-11-20 | 2022-11-22 | TripleBlind, Inc. | Systems and methods for providing a blind de-identification of privacy data |
CN112580072B (en) * | 2020-12-09 | 2021-07-30 | 深圳前海微众银行股份有限公司 | Data set intersection method and device |
CN112733163B (en) * | 2021-01-04 | 2023-02-03 | 北京航空航天大学 | Monitorable zero-knowledge proof method and device based on discrete logarithm equality proof |
CN112910631B (en) * | 2021-02-08 | 2022-11-22 | 上海海洋大学 | Efficient privacy set intersection calculation method and system based on cloud server assistance |
CN113132345B (en) * | 2021-03-04 | 2022-07-26 | 北京航空航天大学 | Agent privacy set intersection method with searchable function |
US20220382908A1 (en) * | 2021-05-25 | 2022-12-01 | Meta Platforms, Inc. | Private joining, analysis and sharing of information located on a plurality of information stores |
CN113515538B (en) * | 2021-06-08 | 2023-07-07 | 四川新网银行股份有限公司 | Inter-institution privacy data query and early warning method based on multiparty security calculation |
US11943354B2 (en) | 2021-07-20 | 2024-03-26 | Snap Inc. | Privacy safe joint identification protocol |
US11687667B2 (en) * | 2021-08-06 | 2023-06-27 | Amazon Technologies, Inc. | Privacy-preserving computing with third-party service |
CN113806795B (en) * | 2021-08-10 | 2024-03-01 | 中国科学院信息工程研究所 | Two-party privacy set union calculation method and device |
CN114372291A (en) * | 2022-01-13 | 2022-04-19 | 平安科技（深圳）有限公司 | Privacy joint reasoning method, device, equipment and storage medium |
US11625377B1 (en) * | 2022-02-03 | 2023-04-11 | TripleBlind, Inc. | Systems and methods for enabling two parties to find an intersection between private data sets without learning anything other than the intersection of the datasets |
CN114520721B (en) * | 2022-03-22 | 2024-03-29 | 杭州博盾习言科技有限公司 | Multiparty secure computing privacy exchange method, device, equipment and storage medium |
CN114726542B (en) * | 2022-04-08 | 2024-04-09 | 中国再保险(集团)股份有限公司 | Data transmission method and device based on privacy intersection |
CN115422581B (en) * | 2022-08-30 | 2024-03-08 | 北京火山引擎科技有限公司 | Data processing method and device |
CN116244753B (en) * | 2023-05-12 | 2023-08-15 | 建信金融科技有限责任公司 | Method, device, equipment and storage medium for intersection of private data |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN103401839A (en) * | 2013-07-02 | 2013-11-20 | 河海大学 | Attribute protection based multiple authorization center encryption method |
WO2017160317A1 (en) * | 2016-03-18 | 2017-09-21 | Entit Software Llc | Data objects associated with private set intersection (psi) |
CN107749865A (en) * | 2017-12-07 | 2018-03-02 | 安徽大学 | A kind of location privacy querying method based on homomorphic cryptography |
Family Cites Families (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9825760B2 (en) * | 2012-07-12 | 2017-11-21 | Elwha, Llc | Level-two decryption associated with individual privacy and public safety protection via double encrypted lock box |
GB2526059A (en) * | 2014-05-13 | 2015-11-18 | Ibm | Managing unlinkable identifiers for controlled privacy-friendly data exchange |
IL234613A0 (en) * | 2014-09-11 | 2014-12-02 | Google Inc | Encrypted aggregated transaction data exchange with transaction data provider |
US20170124152A1 (en) * | 2015-11-02 | 2017-05-04 | LeapYear Technologies, Inc. | Differentially private processing and database storage |
US10223547B2 (en) * | 2016-10-11 | 2019-03-05 | Palo Alto Research Center Incorporated | Method for differentially private aggregation in a star topology under a realistic adversarial model |
US10887293B2 (en) * | 2018-03-20 | 2021-01-05 | International Business Machines Corporation | Key identifiers in an obliviousness pseudorandom function (OPRF)-based key management service (KMS) |
US10887088B2 (en) * | 2018-03-20 | 2021-01-05 | International Business Machines Corporation | Virtualizing a key hierarchy using a partially-oblivious pseudorandom function (P-OPRF) |
-
2019
- 2019-04-19 CN CN201980001669.3A patent/CN110622165B/en active Active
- 2019-04-19 US US16/486,281 patent/US11494506B2/en active Active
- 2019-04-19 WO PCT/US2019/028295 patent/WO2019204711A1/en unknown
- 2019-04-19 EP EP19722411.6A patent/EP3580685B1/en active Active
Patent Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN103401839A (en) * | 2013-07-02 | 2013-11-20 | 河海大学 | Attribute protection based multiple authorization center encryption method |
WO2017160317A1 (en) * | 2016-03-18 | 2017-09-21 | Entit Software Llc | Data objects associated with private set intersection (psi) |
CN107749865A (en) * | 2017-12-07 | 2018-03-02 | 安徽大学 | A kind of location privacy querying method based on homomorphic cryptography |
Non-Patent Citations (3)
Title |
---|
可验证的安全矩阵行列式计算云外包协议;申银杰;《计算机与现代化》;20150515(第05期);第103-106页 * |
同态加密方案及安全两点直线计算协议;巩林明等;《软件学报》;20170324(第12期);第164-182页 * |
基于数字签名的轻量级RFID认证协议;刘亚丽等;《计算机科学》;20150215(第02期);第95-99页 * |
Also Published As
Publication number | Publication date |
---|---|
EP3580685A1 (en) | 2019-12-18 |
WO2019204711A1 (en) | 2019-10-24 |
CN110622165A (en) | 2019-12-27 |
US20220004654A1 (en) | 2022-01-06 |
US11494506B2 (en) | 2022-11-08 |
EP3580685B1 (en) | 2021-03-24 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN110622165B (en) | Security measures for determining privacy set intersections | |
US8526603B2 (en) | Public-key encrypted bloom filters with applications to private set intersection | |
CN107147720B (en) | Traceable effective public audit method and system in a kind of cloud storage data sharing | |
Wang et al. | Privacy-preserving public auditing for data storage security in cloud computing | |
EP2465246B1 (en) | Layered protection and validation of identity data delivered online via multiple intermediate clients | |
US20100083001A1 (en) | Auditor Assisted Extraction And Verification Of Client Data Returned From A Storage Provided While Hiding Client Data From The Auditor | |
US20050086472A1 (en) | Methods of generating a verifiable audit record and performing an audit | |
US10887104B1 (en) | Methods and systems for cryptographically secured decentralized testing | |
CN107423637B (en) | Integrity auditing method supporting traceability of electronic medical record data on cloud | |
CN104092686A (en) | Privacy protection and data safety access method based on SVW classifier | |
Vargas et al. | Mitigating risk while complying with data retention laws | |
Xu et al. | An efficient provable secure public auditing scheme for cloud storage. | |
CN114169888B (en) | Universal type cryptocurrency custody method supporting multiple signatures | |
CN116361823A (en) | Selective audit processing of blockchains for privacy protection | |
CN110445756B (en) | Method for realizing searchable encryption audit logs in cloud storage | |
ÖKSÜZ | Preserving Identity Leakage, Data Integrity and Data Privacy Using Blockchain in Education System | |
Abraham et al. | Proving possession and retrievability within a cloud environment: A comparative survey | |
Mohammadi et al. | A secure E-tendering system | |
Suwandi et al. | A Safe Approach to Sensitive Dropout Data Collection Systems by Utilizing Homomorphic Encryption | |
US11856095B2 (en) | Apparatus and methods for validating user data by using cryptography | |
CN113630260B (en) | Organization identity encryption and decryption method | |
Al-Hamdani | Elliptic curve for data protection | |
Zhang et al. | SDTA: Secure Decentralized Trading Alliance for Electronic Medical Data | |
Coles et al. | Expert SQL server 2008 encryption | |
Ma et al. | FFEC: Fast and forward-secure equivalence-based ciphertext comparability for multiple users in cloud environment |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination | ||
GR01 | Patent grant | ||
GR01 | Patent grant |