US11574067B2 - Efficient on-device public-private computation - Google Patents
Efficient on-device public-private computation Download PDFInfo
- Publication number
- US11574067B2 US11574067B2 US16/774,380 US202016774380A US11574067B2 US 11574067 B2 US11574067 B2 US 11574067B2 US 202016774380 A US202016774380 A US 202016774380A US 11574067 B2 US11574067 B2 US 11574067B2
- Authority
- US
- United States
- Prior art keywords
- entity
- computing device
- additional
- output
- computing system
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
- G06F21/6245—Protecting personal data, e.g. for financial or medical purposes
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/21—Design, administration or maintenance of databases
- G06F16/211—Schema design and management
- G06F16/212—Schema design and management with details for data modelling support
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/28—Databases characterised by their database models, e.g. relational or object models
- G06F16/284—Relational databases
- G06F16/285—Clustering or classification
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/28—Databases characterised by their database models, e.g. relational or object models
- G06F16/284—Relational databases
- G06F16/288—Entity relationship models
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
- G06N5/02—Knowledge representation; Symbolic representation
- G06N5/022—Knowledge engineering; Knowledge acquisition
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
- G06N5/04—Inference or reasoning models
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/044—Recurrent networks, e.g. Hopfield networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/045—Combinations of networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/082—Learning methods modifying the architecture, e.g. adding, deleting or silencing nodes or connections
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
Definitions
- the present disclosure relates generally to techniques for computing outputs over a combination of public and private data. More particularly, the present disclosure relates to systems and methods that perform efficient on-device public-private computation, such as, for example, on a combination of public and private graph data.
- Digital devices play a significant role in the lives of their users through the connections they provide, the information they allow to consume, and the online purchases made with them.
- the wealth of information on such devices can be potentially used to provide the owner of the device with ever improved services and a better user experience.
- respecting the privacy of the user is essential. As such, providing users with useful services while also respecting their privacy is an ongoing challenge in the fields of data mining and machine learning and a fundamental endeavor in the research community and in the industry.
- the computing system includes a central computing system configured to perform a first set of operations.
- the first set of operations include storing a set of public data, wherein a plurality of subsets of the public data are respectively associated with a plurality of entities.
- the first set of operations include, for each of the plurality of entities: processing the respective subset of the public data associated with the entity to produce a respective output for the entity and transmitting data descriptive of the respective output for the entity to one or more entity computing devices associated with the entity.
- the computing system includes a plurality of entity computing devices respectively associated with the plurality of entities, wherein at least one of the entity computing devices is configured to perform a second set of operations.
- the second set of operations include storing a set of private data that describes one or more connections between a corresponding entity of the plurality of entities and one or more connected entities of the plurality of entities.
- the second set of operations include receiving the respective output associated with the corresponding entity from the central computing system.
- the second set of operations include communicating with at least one other entity computing device associated with at least one connected entity of the one or more connected entities to receive from the at least one other entity computing device at least one additional output that is associated with the at least one connected entity of the one or more connected entities.
- the second set of operations include determining a combined output based at least in part on a combination of the respective output associated with the corresponding entity and received from the central computing system with the at least one additional output associated with the at least one connected entity.
- the method includes storing, by an entity computing device associated with a corresponding entity of a plurality of entities, a set of private data that describes one or more connections between the corresponding entity and one or more connected entities of the plurality of entities.
- the method includes receiving, by the entity computing device from a central computing system, a respective output associated with the corresponding entity.
- the respective output is a result of the central computing system processing a respective subset of a set of public data stored at the central computing system, wherein the respective subset of the set of public data is associated with the corresponding entity.
- the method includes communicating, by the entity computing device, with at least one other entity computing device associated with at least one connected entity of the one or more connected entities to receive from the at least one other entity computing device at least one additional output that is associated with the at least one connected entity of the one or more connected entities.
- the at least one additional output was received by the at least one other entity computing device from the central computing system.
- the at least one additional output is a result of the central computing system processing at least one additional subset of the set of public data stored at the central computing system.
- the at least one additional subset of the set of public data is associated with the at least one connected entity.
- the method includes determining, by the entity computing device, a combined output based at least in part on a combination of the respective output associated with the corresponding entity and received from the central computing system with the at least one additional output associated with the at least one connected entity.
- the method includes storing a set of public data, wherein a plurality of subsets of the public data are respectively associated with a plurality of entities.
- the method includes, for each of the plurality of entities: processing the respective subset of the public data associated with the entity to produce a respective output for the entity and transmitting data descriptive of the respective output for the entity to one or more entity computing devices associated with the entity.
- FIG. 1 depicts a graphical diagram of an example on-device public-private model of computation according to example embodiments of the present disclosure.
- FIG. 2 A depicts a block diagram of an example computing system according to example embodiments of the present disclosure.
- FIG. 2 B depicts a block diagram of an example computing device according to example embodiments of the present disclosure.
- FIG. 2 C depicts a block diagram of an example computing device according to example embodiments of the present disclosure.
- FIG. 3 depicts a flow chart diagram of an example method to perform public-private data computation according to example embodiments of the present disclosure.
- FIG. 4 depicts a flow chart diagram of an example method to perform public-private data computation according to example embodiments of the present disclosure.
- the present disclosure is directed to systems and methods that enhance user privacy by performing efficient on-device public-private computation on a combination of public and private data, such as, for example, public and private graph data.
- the on-device public-private computation framework described herein can enable a device associated with an entity to efficiently compute a combined output that takes into account and is explicitly based upon a combination of data that is associated with the entity and data that is associated with one or more other entities that are private connections of the entity, all without revealing to a centralized computing system a set of locally stored private data that identifies the one or more other entities that are private connections of the entity.
- a centralized system can compute an output for each of a number of entity computing devices based on a set of public data and can transmit each respective output to the corresponding device.
- the entity computing devices can communicate with each other (e.g., based on respective sets of locally stored private contacts data) to share their respective outputs with each other, thereby enabling each entity computing device to produce a combined output based on the outputs shared by their private contacts, all without sharing the private data with the centralized system in any way.
- example aspects of the present disclosure can be performed by a computing system that includes a central computing system that stores a set of public data and a plurality of entity computing devices that each store a respective set of private data.
- the set of public data can include a plurality of subsets of the public data that are respectively associated with a plurality of entities that are respectively associated with the plurality of entity computing devices.
- the set of public data stored at the central computing system can be a public graph and the subsets of the public data respectively associated with each entity can be respective portions of the public graph that are connected (e.g., within some number of connections) to a node of the public graph that corresponds to the entity (e.g., a “star” rooted at the node).
- all of the public data can be associated with one or more entities rather than just a subset.
- the respective set of private data stored by each entity computing device can describe one or more connections (e.g., social network connections, contact lists, customer lists, publication/subscription information, control theory connections, cryptographic connections, etc.) between a corresponding entity of the plurality of entities and one or more connected entities of the plurality of entities.
- connections e.g., social network connections, contact lists, customer lists, publication/subscription information, control theory connections, cryptographic connections, etc.
- the set of private data can be a private graph that describes social connections between the corresponding entity and the one or more connected entities.
- entities can include specific individual users, groups of one or more users, an account associated with an application (e.g., an individual account or an account shared by one or more users such as a corporate account), an organization, a particular device (e.g., an IoT or embedded device), or any other entity with which data may be associated (e.g., an IP address, a geolocation, a business listing, and/or other entities).
- an application e.g., an individual account or an account shared by one or more users such as a corporate account
- a particular device e.g., an IoT or embedded device
- any other entity with which data may be associated e.g., an IP address, a geolocation, a business listing, and/or other entities.
- the central computing system can process each respective subset of the public data associated with each entity to produce a respective output for the entity and can transmit each respective output to the corresponding entity computing device.
- the central computing system can perform a streaming algorithm on each respective subset of the public data to produce a sketch of the respective subset of the public data.
- Each resulting sketch can be a much smaller (e.g., in terms of data size) synopsis of the respective subset of the public data.
- the central machine can also run an algorithm (e.g., a streaming algorithm) on all of the public data to send it to all of the entity devices. Since the public data is publicly available, there is no privacy concern with processing and distributing it in different manners.
- each entity computing device can communicate with one or more other entity computing devices that are associated with one or more of the connected entities identified in the respective set of private data stored on the entity computing device.
- each entity computing device can communicate with the other entity computing devices associated with the connections described in the private data to obtain the respective output (e.g., sketch) received by such other entity computing devices from the central computing system.
- Each entity computing device can combine its own respective output (e.g., sketch) with those received from the other entity computing devices (possibly along with additional private data stored locally and/or additional private data received from the other entity computing devices) to produce a combined output.
- the other entity decides to share its additional private data to this specific entity, this can be done without intervention from the central computing system.
- the outputs can be composable. That is, the outputs can be easily and efficiently combined to produce the combined output.
- the combined output produced by each entity computing device can be a solution provided by a data processing (e.g., graph processing) technique applied to the subsets of public data respectively associated with such device's corresponding entity and some or all of the entities that are connected with such device's corresponding entity in the private data stored on such device.
- a data processing e.g., graph processing
- each entity can receive a data processing result that is specific to and based on the specific entity's private connections, but without sharing the private connection data with the central computing system in any way.
- One example application of the on-device public-private model of computation provided herein is to social-network based recommender systems whereby a user wants to receive recommendations based on the information available on the user's device, as well as the suggestions of the user's social contacts, without sharing such information or contacts with the central recommendation system.
- a user of a vehicle may wish to determine actions (e.g. routes, time of departure, speed, refueling timings) based upon information available to the user's vehicle, as well as information available to vehicles in the user's private network or local vicinity.
- the proposed framework allows a distributed computing architecture to solve many algorithmic problems while providing absolute (deterministic) guarantees of the privacy of on-device data and the user's contacts.
- the framework ensures that the private data and contacts are never revealed to the central system.
- This restrictive model of computation presents several interesting algorithmic challenges because any computation based on private information and contacts needs to be done on local devices of potentially limited capabilities.
- U.S. Provisional Patent Application No. 62/797,651 which is incorporated into and forms a part of this disclosure, complements this analysis with strong impossibility results for efficient private algorithms without allowing inter-device communication.
- U.S. Provisional Patent Application No. 62/797,651 also provides example experimental evaluation results, showing that example implementations of the proposed private algorithms provide results almost as accurate as those of the non-private ones while speeding up the on-device computations by orders of magnitude.
- a standard recommender system such as a service that suggests books to read.
- the system has a central recommendation provider.
- the user logs into the system and volunteers ratings for the books already read and, in exchange, receives suggestions for new books to read.
- the user would like to receive suggestions based on the books read by the user's close friends (for example some or all of the contacts in the user's mobile phone).
- close friends for example some or all of the contacts in the user's mobile phone.
- the user needs to authorize access to the list of contacts on the user's phone.
- the standard centralized system architecture does not allow such use cases, as all the data to be processed by the service provider to solve the task of obtaining the reviews (e.g., the book ratings and the social graph) must be stored and processed in a centralized system.
- the present disclosure provides a new framework for distributed computation that can be referred to as the on-device public-private model.
- This framework allows the user to employ all the information available on the user's device, as well as the user's social contacts, without sharing them with the central system.
- the present disclosure shows how to solve several machine learning and data mining problems in this framework without ever having to move the private data to the central system and without needing to reveal the private connections in the social graph.
- the proposed methods provide absolute (deterministic) guarantees of privacy, as no information based on the private data or the private contacts of the user is shared with the central authority.
- This framework is orthogonal to and can be in combination with other privacy-preserving schemes that are actively studied and that are reviewed in the related work: for instance, differential privacy, federated learning, and public-private data models. All these other methods allow strong privacy guarantees, and may complement the proposed techniques, but it should be observed that they do not directly model social-graph-based information or they involve a setting where private data or some information based on it may still need to be collected by the central authority (although in an anonymized or aggregated form).
- the present disclosure provides a model that allows general algorithmic problems to be solved while harnessing the social network or other private data of the users.
- the proposed framework can be seen as an extension to the recent public-private graph model, but contrary to the public-private graph model, does not require any private information to be shared with the central system.
- the proposed model also allows metadata on nodes of the network to address applications beyond graph analysis.
- the present disclosure shows how to achieve this without relying on insertion of noise to obfuscate the output, which might partially degrade it, while achieving, by design, even stronger notions of privacy: private data is only used to provide outputs to the data owner.
- Example implementations of the restrictive model of computation provided herein present several interesting algorithmic challenges: since no private information is shared, all computations based on private data must be performed on local devices of potentially limited capabilities. Despite the challenges introduced by the model, efficient algorithms are provided for fundamental data mining and machine learning problems, ranging from clustering to recommendation system applications.
- the proposed model can work as follows: the user is allowed to specify an arbitrary partitioning of the local device data as public or private. Moreover, the user is allowed to specify some contacts as private or public. Only the public data and the public contacts are shared to the central system in accordance with the choice of the user. Then, the user wants to obtain some information (e.g., the results of a recommendation system algorithm) on a dataset consisting of all the data to which the user has access, such as the user's private data, all the user's contacts (private or public), and the publicly available information. All of this must be achieved without revealing the private data and the private contacts to the central authority. A formal summary of these results is provided below after defining necessary preliminaries.
- example applications are provided for finding heavy hitter and solving clustering problems (like k-medians, k-means and k-centers).
- the systems and methods of the present disclosure provide a number of technical effects and benefits.
- the systems and methods of the present disclosure enhance user privacy.
- the proposed framework enables an entity to receive personalized (e.g., social network specific) processing results without needing to share a set of private data describing connections with a central computing system in any form.
- the proposed framework provides an improved computing system that provides personalized results with enhanced privacy, which represents an improvement to the computing system itself.
- aspects of the present disclosure can provide efficient on-device computation.
- aspects of the present disclosure are directed to a distributed framework in which a computationally powerful central system performs pre-processing on various subsets of public data in order to generate small summaries of the data.
- the small summaries can then be transmitted to entity devices.
- the entity devices can share the small summaries in a peer-to-peer fashion and can combine them in an efficient manner (e.g., through composing sketches).
- the devices may also agree to use another means of communication that involves an intermediary, such as communication via a trusted central authority other than the centralized computing system that holds the public data.
- the devices may use an end-to-end encrypted messaging application to exchange the packets instead of sharing private data with the centralized computing system that holds the public data.
- entity devices may have direct wired or wireless connections therebetween and it may be desired to keep those connections secret from the central computing system.
- Direct communications channels e.g. wireless connections
- Section 2 introduces the proposed models and reviews the prior public-private graph model that inspired the proposed model. Then, Section 3, present the main theoretical results for the proposed model.
- Section 3 present the main theoretical results for the proposed model.
- U.S. Provisional Patent Application No. 62/797,651 shows empirical evaluation of algorithms in the proposed model, reviews related work, and finally, presents certain conclusions.
- This section formally defines certain example aspects of the on-device public-private model of computation. Before defining the model, this section reviews an example centralized public-private model to distinguish it from the on-device version provided by the present disclosure.
- the systems of the present disclosure are equally applicable to directed graphs, weighted graphs, bipartite graphs, and/or hypergraphs.
- the aim of the query algorithm is to take in input for node u the private graph G u and to output the solution of the problem for G ⁇ G u by using the synopsis P(G), in time and space that is ideally near-linear in
- this model assumes that the query algorithm can access the entire synopsis by making queries to it that depend on the private data. Implicitly, this means that, in the centralized model, the private graph (or some information based on it) resides in the central machine.
- each private graph G u is stored exclusively on the device owned by the agent u to protect the agent's privacy.
- private edges of E u represent (potentially reciprocal) private connections of the user u, e.g., ⁇ E u implies that u E E ⁇ and that u and ⁇ know each other and they want their connection to be private to them and not shared to the central authority or any other user.
- the query algorithm must be executed on a device of potentially limited computation power and (crucially) cannot make queries to the central machine that depend on the private edges, as this would reveal the private connections to the shared machine.
- some implementations of the on-device model assume that the central machine, after pre-processing the public graph G, sends a single message ⁇ u to the device corresponding to the node u of (ideally) poly-log(n) bits (refer to FIG. 1 for a pictorial description of the model). In some implementations, no other communication is allowed with the central machine from the device thereafter. Indeed, the shared machine has no information about the private graph G u , and ⁇ u just depends on the public graph G and node u, thus preserving completely the privacy of the private contacts in G u .
- the device of u is allowed to directly or indirectly query the device of each private neighbor ⁇ E u to receive the same message ⁇ ⁇ sent to ⁇ by the central machine. This communication does not involve the central authority and so does not leak any information to it. Then, the query algorithm on the device uses the messages received to solve the problem.
- ⁇ might be a contact of u in u's favored secure messaging application.
- u may obtain ⁇ ⁇ using the same messaging app to contact ⁇ , without thus sharing the app contact list to the book recommendation system provider. Then, u will use the messages received to compute the recommendations on u's device.
- the proposed model is equally applicable to public-private (problem-specific) data associated with users as the public-private framework of data summarization.
- the proposed on-device framework can handle and process both graph data and non-graph metadata on nodes.
- each node has a problem-specific public metadata S u P that can be shared publicly to everyone and a problem-specific private metadata S u V that is only available to u.
- the public metadata can be stored in the central machine, while the private metadata must be processed locally. More sophisticated access controls (who-can-access-what) can be applied as well.
- example implementations of the proposed systems can perform algorithms that use polynomial time and space in the size of all public data for pre-processing and linear time in the private data of a user for the query algorithm.
- ⁇ can, in some implementations, be defined as the maximum size of a message exchanged in the protocol, while in the centralized algorithm,
- Lemma 1 Any on-device public-private graph algorithm with polynomial time pre-processing, ⁇ (1) message size and ⁇ (
- Lemma 2 There exist problems that admit a
- the server since the server does not have access to the private id id ⁇ , it does not know what part of the function ⁇ is important for ⁇ to send to it. This is equivalent to the indexing problem where Alice holds the public information on the server and Bob holds id ⁇ , with a one directional communication channel from Alice to Bob. In order to solve the indexing problem Alice needs to send ⁇ (n) bits to Bob.
- Lemma 3 Suppose for a given problem there exists a centralized public-private algorithm with synopsis P(G) decomposable in n data-structures, P(G) u for u ⁇ V such that
- This subsection introduces example algorithmic contributions involving a class of problems related to recommendation systems in the on-device public-private model.
- a social-network recommendation system there is a set of arbitrary items and a graph indicating the social network.
- the social graph includes a public part G and a private graph G u for each node u as described above.
- G u For each vertex u, we have a set S u P ⁇ of public items and a set S u V ⁇ of private items, respectively, that u likes.
- Example implementations of the present disclosure model the problem of implementing a social recommendation system that, given the information in the neighborhood reachable within distance d of a vertex u in the graph visible to u, G ⁇ G u , returns a subset of items I, with
- k to recommend to u. More formally, for a graph , let N u d (g) be the set of vertices reachable from u within a distance at most d on graph .
- S u d ⁇ ( G ) S u V ⁇ ⁇ ⁇ v ⁇ N u d ⁇ ( G ) ⁇ S v P be the set of items visible to u in , i.e., the private items of u plus all public items of nodes reachable from u at distance less than d in the graph . The notation will drop when referring to the public graph G.
- the on-device model approximates the output of certain functions specifying relevant items over the set S u d (G ⁇ G u ) to recommend.
- Example results are as follows.
- a uniform recommendation function is a randomized function that returns a subset of items uniformly at random without replacement from S u d (G ⁇ G u ).
- S u d (G ⁇ G u ) U ⁇ u d (G ⁇ G u ) S v .
- C u i (G ⁇ G u ) the number of distinct nodes ⁇ N u d (G ⁇ G u ) for each i that appears in the set S ⁇ defined above.
- a linear recommendation function is a randomized function that returns a subset of k items I, where the items in I are chosen from S u d (G ⁇ G u ) without replacement with probability proportional to C u i (G ⁇ G u ).
- M be a multiset of , i.e., a set of items with repetitions.
- heavy hitter is a function that returns a subset of items I from a multiset M with two properties. 1) I contains all items that appear in at least
- M the multiset that contains the union (with repetitions) of S ⁇ for distinct ⁇ N u d (G ⁇ G u ), e.g., all items visible to u counted with the number of users liked by them.
- Heavy hitters seeks to define all items as defined above.
- each item in represents a point in an arbitrary metric space
- the goal is to pick a set of k points r 1 , . . . , r k that minimizes the cost function.
- node u will share the message received from the central machine with their private neighbors and collect their messages.
- node u will compose the following sketches received I u d plus I ⁇ d ⁇ 1 ⁇
- example implementations of the present disclosure assume that there exists a k-minwise independent uniform hash function h: ⁇ [0,1] from the items to [0,1]. It is also assumed that the function has shared random seeds that are available to all devices and the central machine (i.e., it can be computed consistently in every device). The algorithm is reported in Algorithm 2 below, in which only the details missing from the general Algorithm 1 are added.
- Algorithm 2 To sketch a set of items S: hash the items in S and keep the k items with minimum values. Two sketches for sets A, B can be easily composed because one can sort the items in A ⁇ B and return the top k by h.
- Algorithm 2 shows how to use this property to iteratively construct I u d ′ for all nodes based on I u d ′ and how to initialize I u 0 , which is the sketch of S u P . Then I u d ′ is obtained by combining the sketches of I ⁇ d′-1 for the public neighbors of u and the previous sketch U u d′-1 of u. Finally, the last two sketches for d and d ⁇ 1 are sent to each device.
- Algorithm 2 obtains k uniform recommendations without replacement for each node in the on-device model with total pre-processing time ⁇ ( ⁇ u
- Algorithm 2 Algorithm for Uniform Recommendation Function Input: G, ⁇ u ⁇ V (S u P , S u V , G u ), d, k, a hash function h( ⁇ )
- Output: k uniform sample items for each node u 1. Obtaining I d′ 's during pre-processing 2. For d′ 0 3. for all u ⁇ V do 4. Sort items in i ⁇ S u P based on hash h(i) and let I u 0 be the first k items by h( ⁇ ). 5. for d′ ⁇ ⁇ 1 ... d ⁇ for u ⁇ V do 6.
- Î u d′ be the union of I u d′ ⁇ 1 ⁇ U v ⁇ N(u) I v d′ ⁇ 1 where N(u) refers to graph G. 7. Sort items in Î u d′ based on h(i) and let I u d′ be the first k items. 8. Query algorithm on u's device using same h( ⁇ ) function. 9. Let I u V be the top k items by h( ⁇ ) in S u V . 10. Compute Î u as union of I u V , I v d ⁇ 1 for v ⁇ E u , and I u d . 11. Extract k items from Î u by h( ⁇ ).
- This subsection provides an example technique to recommend k items without replacement from S u d (G ⁇ G u ) with probability proportional to C u i (G ⁇ G u ).
- Theorem 5 The previous algorithm obtains k linear recommendations without replacement for each node in the on-device model with total pre-processing time ⁇ ( ⁇ u
- each hash function maps a pair (u,i) of user and item to [0,1].
- the sketch I u d keeps H pairs, one per function, such that for each function, the pair stored is the one with minimum hash value over the items inserted in the sketch.
- the sketch is composable.
- the construction of the sketches in the pre-processing and query time is the same as in the linear case.
- the final sketch I u d constructed at query time is a list of
- Lemma 6 The previous algorithm obtains runs in the on-device model with total pre-processing time ⁇ ( ⁇ u
- Lemma 7 The algorithm defined above returns the heavy hitter items in the neighborhood of u, with probability 1 ⁇ .
- Pr [ ⁇ X i - C u i ⁇ j ⁇ I ⁇ C u j ⁇ 1 ⁇ 2 ⁇ log ⁇ 2 ⁇ s ⁇ ⁇ 2 ⁇ ⁇ 0.5 ⁇ ⁇ ⁇ 1 ⁇ 2 ⁇ log ⁇ 2 ⁇ s ⁇ ⁇ 2 ] Pr [ ⁇ X i - E ⁇ [ X i ] ⁇ ⁇ 0. ⁇ 5 ⁇ ⁇ ⁇ 1 ⁇ 2 ⁇ log ⁇ 2 ⁇ s ⁇ ⁇ 2 ] which by
- the example algorithm in this section is based on the notion of composable coresets. See Bateni et al., 2014. Distributed balanced clustering via mapping coresets. In Advances in Neural Information Processing Systems. 2491-2599.
- core-sets I ⁇ d ⁇ 1 corresponds to not necessarily disjoint sets. However, each point appears at most
- Theorem 8 The previous algorithm obtains a O( ⁇
- the total pre-processing time is
- composable coresets are designed to work with disjoint sets (i.e. a decomposition of the input set).
- disjoint sets i.e. a decomposition of the input set.
- the items (i.e. points) of ⁇ appear in both of these neighbors.
- we could explicitly keep the set of the items assigned to the representative items (which we refer to as A 1 , . . . , A t for simplicity of notation), we could directly indicate the duplicated items and remove their weights from the representative items. However, this might not be practical due to the large size of these sets.
- A be a collection of items and let A 1 , . . . , A t ⁇ A be a collection of subsets of A. Without loss of generality we assume
- ⁇ be an upper bound on the number sets that contains ⁇ , for any arbitrary ⁇ A.
- h( ⁇ ) be a universally shared hash function that hashes A ⁇ [0,1] uniformly at random.
- B i ⁇
- ⁇ A t & ⁇ j>i ⁇ A j ⁇ . This intuitively says that to construct B i s from A i s, we remove duplicated items from the larger sets and keep them in the smaller ones. Similarly, for i ⁇ 1, . . . , t ⁇ we define ⁇ circumflex over (B) ⁇ i ⁇
- Lemma 9 With probability at least 1 ⁇ ⁇ 1 , simultaneously, for all i ⁇ 1, . . . , t ⁇ we have
- FIG. 2 A depicts a block diagram of an example computing system 100 that performs on-device public-private computation according to example embodiments of the present disclosure.
- the system 100 includes an entity computing device 102 , a server computing system 130 , and a training computing system 150 that are communicatively coupled over a network 180 .
- System 100 is provided as one example. Various other and different computing systems can be used to implement aspects of the present disclosure.
- the entity computing device 102 can be any type of computing device, such as, for example, a personal computing device (e.g., laptop or desktop), a mobile computing device (e.g., smartphone or tablet), a gaming console or controller, a wearable computing device, an embedded computing device, or any other type of computing device.
- a personal computing device e.g., laptop or desktop
- a mobile computing device e.g., smartphone or tablet
- a gaming console or controller e.g., a gaming console or controller
- a wearable computing device e.g., an embedded computing device, or any other type of computing device.
- the entity computing device 102 includes one or more processors 112 and a memory 114 .
- the one or more processors 112 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 114 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 114 can store data 116 and instructions 118 which are executed by the processor 112 to cause the entity computing device 102 to perform operations.
- the entity computing device 102 can include one or more sets of private data 117 .
- the private data 117 can be a private graph.
- the private data 117 can describe one or more relationships (e.g., social relationships) between an entity associated with the entity computing device 102 and one or more other entities associated with one or more entity computing devices (e.g., device 103 ).
- the private data 117 can include problem-specific private metadata.
- the entity computing device 102 can include a data analyzer 119 .
- the data analyzer 119 can analyze or otherwise process various sets of data such as the private data 117 and/or data received from the server computing system 130 .
- the data analyzer 119 can perform a query function on various sets of data (e.g., data sketches).
- the data analyzer 119 can combine (e.g., compose) multiple outputs (e.g., sketches) to form a combined output (e.g., combined sketch).
- the entity computing device 102 can store or include one or more machine-learned models 120 .
- the machine-learned models 120 can be or can otherwise include various machine-learned models such as neural networks (e.g., deep neural networks) or other types of machine-learned models, including non-linear models and/or linear models.
- Neural networks can include feed-forward neural networks, recurrent neural networks (e.g., long short-term memory recurrent neural networks), convolutional neural networks or other forms of neural networks.
- the one or more machine-learned models 120 can be received from the server computing system 130 over network 180 , stored in the entity computing device memory 114 , and then used or otherwise implemented by the one or more processors 112 .
- the entity computing device 102 can implement multiple parallel instances of a single machine-learned model 120 .
- one or more machine-learned models 140 can be included in or otherwise stored and implemented by the server computing system 130 that communicates with the entity computing device 102 according to a client-server relationship.
- the machine-learned models 140 can be implemented by the server computing system 140 as a portion of a web service.
- one or more models 120 can be stored and implemented at the entity computing device 102 and/or one or more models 140 can be stored and implemented at the server computing system 130 .
- the entity computing device 102 can also include one or more user input component 122 that receives user input.
- the user input component 122 can be a touch-sensitive component (e.g., a touch-sensitive display screen or a touch pad) that is sensitive to the touch of a user input object (e.g., a finger or a stylus).
- the touch-sensitive component can serve to implement a virtual keyboard.
- Other example user input components include a microphone, a traditional keyboard, or other means by which a user can provide user input.
- the server computing system 130 includes one or more processors 132 and a memory 134 .
- the one or more processors 132 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 134 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 134 can store data 136 and instructions 138 which are executed by the processor 132 to cause the server computing system 130 to perform operations.
- the server computing system 130 can include one or more sets of public data 137 .
- the public data 137 can be a public graph.
- the public data 137 can include a plurality of portions that are respectively associated with a plurality of entities.
- the public data 137 can include problem-specific public metadata.
- the server computing system 130 can include a data analyzer 139 .
- the data analyzer 139 can analyze or otherwise process various sets of data such as the public data 137 or respective portions thereof.
- the data analyzer 139 can perform a pre-processing function on various sets of data (e.g., portions of the public data 137 ) to produce a respective output.
- pre-processing the data can include generating a sketch of the data.
- the server computing system 130 includes or is otherwise implemented by one or more server computing devices. In instances in which the server computing system 130 includes plural server computing devices, such server computing devices can operate according to sequential computing architectures, parallel computing architectures, or some combination thereof.
- the server computing system 130 can store or otherwise include one or more machine-learned models 140 .
- the models 140 can be or can otherwise include various machine-learned models.
- Example machine-learned models include neural networks or other multi-layer non-linear models.
- Example neural networks include feed forward neural networks, deep neural networks, recurrent neural networks, and convolutional neural networks.
- the entity computing device 102 and/or the server computing system 130 can train the models 120 and/or 140 via interaction with the training computing system 150 that is communicatively coupled over the network 180 .
- the training computing system 150 can be separate from the server computing system 130 or can be a portion of the server computing system 130 .
- the training computing system 150 includes one or more processors 152 and a memory 154 .
- the one or more processors 152 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 154 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 154 can store data 156 and instructions 158 which are executed by the processor 152 to cause the training computing system 150 to perform operations.
- the training computing system 150 includes or is otherwise implemented by one or more server computing devices.
- the training computing system 150 can include a model trainer 160 that trains the machine-learned models 120 and/or 140 stored at the entity computing device 102 and/or the server computing system 130 using various training or learning techniques, such as, for example, backwards propagation of errors.
- performing backwards propagation of errors can include performing truncated backpropagation through time.
- the model trainer 160 can perform a number of generalization techniques (e.g., weight decays, dropouts, etc.) to improve the generalization capability of the models being trained.
- the model trainer 160 can train the machine-learned models 120 and/or 140 based on a set of training data 162 .
- the training examples can be provided by the entity computing device 102 .
- the model 120 provided to the entity computing device 102 can be trained by the training computing system 150 on user-specific data received from the entity computing device 102 . In some instances, this process can be referred to as personalizing the model.
- Each of the data analyzer 119 , the data analyzer 139 , and the model trainer 160 includes computer logic utilized to provide desired functionality.
- Each of the data analyzer 119 , the data analyzer 139 , and the model trainer 160 can be implemented in hardware, firmware, and/or software controlling a general purpose processor.
- each of the data analyzer 119 , the data analyzer 139 , and the model trainer 160 includes program files stored on a storage device, loaded into a memory and executed by one or more processors.
- each of the data analyzer 119 , the data analyzer 139 , and the model trainer 160 includes one or more sets of computer-executable instructions that are stored in a tangible computer-readable storage medium such as RAM hard disk or optical or magnetic media.
- the network 180 can be any type of communications network, such as a local area network (e.g., intranet), wide area network (e.g., Internet), or some combination thereof and can include any number of wired or wireless links.
- communication over the network 180 can be carried via any type of wired and/or wireless connection, using a wide variety of communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), encodings or formats (e.g., HTML, XML), and/or protection schemes (e.g., VPN, secure HTTP, SSL).
- FIG. 2 A illustrates one example computing system that can be used to implement the present disclosure.
- the entity computing device 102 can include the model trainer 160 and the training dataset 162 .
- the models 120 can be both trained and used locally at the entity computing device 102 .
- the entity computing device 102 can implement the model trainer 160 to personalize the models 120 based on user-specific data.
- FIG. 2 B depicts a block diagram of an example computing device 10 that performs according to example embodiments of the present disclosure.
- the computing device 10 can be a entity computing device or a server computing device.
- the computing device 10 includes a number of applications (e.g., applications 1 through N). Each application contains its own machine learning library and machine-learned model(s). For example, each application can include a machine-learned model.
- Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
- each application can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components.
- each application can communicate with each device component using an API (e.g., a public API).
- the API used by each application is specific to that application.
- FIG. 2 C depicts a block diagram of an example computing device 50 that performs according to example embodiments of the present disclosure.
- the computing device 50 can be a entity computing device or a server computing device.
- the computing device 50 includes a number of applications (e.g., applications 1 through N). Each application is in communication with a central intelligence layer.
- Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
- each application can communicate with the central intelligence layer (and model(s) stored therein) using an API (e.g., a common API across all applications).
- the central intelligence layer includes a number of machine-learned models. For example, as illustrated in FIG. 2 C , a respective machine-learned model (e.g., a model) can be provided for each application and managed by the central intelligence layer. In other implementations, two or more applications can share a single machine-learned model. For example, in some implementations, the central intelligence layer can provide a single model (e.g., a single model) for all of the applications. In some implementations, the central intelligence layer is included within or otherwise implemented by an operating system of the computing device 50 .
- a respective machine-learned model e.g., a model
- two or more applications can share a single machine-learned model.
- the central intelligence layer can provide a single model (e.g., a single model) for all of the applications.
- the central intelligence layer is included within or otherwise implemented by an operating system of the computing device 50 .
- the central intelligence layer can communicate with a central device data layer.
- the central device data layer can be a centralized repository of data for the computing device 50 . As illustrated in FIG. 2 C , the central device data layer can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, the central device data layer can communicate with each device component using an API (e.g., a private API).
- an API e.g., a private API
- FIG. 3 depicts a flow chart diagram of an example method 300 to perform according to example embodiments of the present disclosure.
- FIG. 3 depicts steps performed in a particular order for purposes of illustration and discussion, the methods of the present disclosure are not limited to the particularly illustrated order or arrangement.
- the various steps of the method 300 can be omitted, rearranged, combined, and/or adapted in various ways without deviating from the scope of the present disclosure.
- the method 300 can be performed by a centralized computing system.
- the computing system can store a set of public data.
- a plurality of subsets of the public data are respectively associated with a plurality of entities.
- entities can include specific individual users, groups of one or more users, an account associated with an application (e.g., an individual account or an account shared by one or more users such as a corporate account), an organization, a particular device (e.g., an IoT or embedded device), or any other entity with which data may be associated (e.g., an IP address, a geolocation, a business listing, and/or other entities).
- the computing system can, for each entity, process the respective subset of the public data associated with the entity to produce a respective output for the entity.
- processing the respective subset of the public data associated with the entity to produce the respective output for the entity at 304 can include performing a streaming algorithm on the respective subset of the public data associated with the entity to produce a respective sketch for the entity.
- the public data can be a public graph and processing the public graph can include performing a graph processing technique on the public graph.
- performing the graph processing technique can include performing a uniform recommendation function; a linear recommendation function; a heavy hitter function; and/or a k-clustering function.
- the computing system can, for each entity, transmit data descriptive of the respective output for the entity to one or more entity computing devices associated with the entity.
- the method 300 can optionally return to block 302 .
- the computing system can iteratively perform various steps of method 300 as additional data is received.
- the respective output for a particular entity can be re-computed and re-transmitted as soon as additional public data associated with the particular entity is received.
- the respective output for a particular entity can be re-computed and re-transmitted periodically according to a schedule.
- FIG. 4 depicts a flow chart diagram of an example method 400 to perform according to example embodiments of the present disclosure.
- FIG. 4 depicts steps performed in a particular order for purposes of illustration and discussion, the methods of the present disclosure are not limited to the particularly illustrated order or arrangement.
- the various steps of the method 400 can be omitted, rearranged, combined, and/or adapted in various ways without deviating from the scope of the present disclosure.
- the method 400 can be performed by an entity computing device.
- the entity computing device can store a set of private data that describes one or more connections between a corresponding entity and one or more connected entities of a plurality of entities.
- the connections can include social network connections, contact lists, customer lists, publication/subscription information, control theory connections, cryptographic connections, etc.
- the private data can be a private graph.
- the entity computing device can receive a respective output associated with the corresponding entity from a central computing system.
- the respective output associated with the corresponding entity can be a respective sketch associated with the corresponding entity and generated through performance, for example, of a streaming algorithm.
- the entity computing device can communicate with at least one other entity computing device associated with at least one connected entity to receive from the at least one other entity computing device at least one additional output that is associated with the at least one connected entity.
- the at least one other entity computing device can have received the at least one additional output from the central computing system.
- the at least one additional output associated with the at least one connected entity can be at least one additional sketch associated with the at least one connected entity.
- the communication(s) with the other entity computing device(s) can be direct communications. In some implementations, the communication(s) with the other entity computing device(s) can be indirect communications. In some implementations, the communication(s) with the other entity computing device(s) can be encrypted (e.g., end-to-end encrypted).
- the entity computing device may also communicate with the at least one other entity computing device associated with the at least one connected entity to receive from the at least one other entity computing device an additional set of private data that is private to the at least one entity computing device.
- the entity computing device can determine a combined output based at least in part on a combination of the respective output associated with the corresponding entity and received from the central computing system with the at least one additional output associated with the at least one connected entity. For example, determining the combined output can include composing the respective sketch associated with the corresponding entity and received from the central computing system with the at least one additional sketch associated with the at least one connected entity to obtain a combined sketch.
- the combined output can also be produced based on an additional set of private data that was private to and received from the at least other one entity computing device and/or an additional set of private data that is stored locally on and private the entity computing device.
- the entity computing device can provide the combined output to the user and/or perform operations in response to the combined output.
- the combined output can be or describe one or more recommended items and, at 410 , the entity computing device can provide the one or more recommended items to the user (e.g., as part of a graphical display included in a user interface of the device).
- the method 400 can optionally return to block 402 or elsewhere.
- the entity computing device can iteratively perform various steps of method 400 as additional data is received.
- the respective outputs can be re-shared and re-combined as soon as additional data associated with the particular entity is received/generated.
- the respective outputs for a particular entity can be re-computed and re-transmitted periodically according to a schedule.
- the technology discussed herein makes reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and from such systems.
- the inherent flexibility of computer-based systems allows for a great variety of possible configurations, combinations, and divisions of tasks and functionality between and among components.
- processes discussed herein can be implemented using a single device or component or multiple devices or components working in combination.
- Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
Abstract
Description
be the set of items visible to u in
times in M where |M| is the total number of items counting repetitions; and 2) each item i∈I appears at least
times in M. For a node u and distance d, let M be the multiset that contains the union (with repetitions) of Sν for distinct ν∈Nu d(G∪Gu), e.g., all items visible to u counted with the number of users liked by them. Heavy hitters seeks to define all items as defined above.
for a particular fixed ρ. ρ=1 corresponds to k-median, ρ=2 to k-means and ρ→∞ to k-center.
Algorithm 1: General Algorithm |
Input: G, ∀u∈V(Su P, Su V, Gu), d, k |
Output: k items for each |
1. Pre-processing on central machine using G, ∀u∈VSu P. |
2. for all u ∈ V, for d′ ≤ d do |
3. Let |
4. Compute Iu d′:= sketch( |
5. Send to u, σu:= (Iu d−1, Iu d). |
6. Query algorithm on u's device using Gu, Su V. |
7. Receive σu from central machine. |
8. Send σu to v and receive σv from v for all v ∈ Eu. |
9. Compute Iu V:= sketch(Su V). |
10. Compose sketches Iu V, Iv d−1 for v ∈ Eu, and Iu d to obtain sketch Iu. |
11. Extract k items from Iu. |
Algorithm 2: Algorithm for Uniform Recommendation Function |
Input: G, ∀u∈V(Su P, Su V, Gu), d, k, a hash function h(·) |
Output: k uniform sample items for each |
1. Obtaining Id′'s during |
2. For d′ = 0 |
3. for all u ∈ V do |
4. Sort items in i ∈ Su P based on hash h(i) and let Iu 0 be the first k items |
by h(·). |
5. for d′ ∈ {1 ... d}for u ∈ V do |
6. Let Îu d′ be the union of Iu d′−1 ∪ Uv∈N(u) Iv d′−1 where N(u) refers to |
graph G. |
7. Sort items in Îu d′ based on h(i) and let Iu d′ be the first k items. |
8. Query algorithm on u's device using same h(·) function. |
9. Let Iu V be the top k items by h(·) in Su V. |
10. Compute Îu as union of Iu V, Iv d−1 for v ∈ Eu, and Iu d. |
11. Extract k items from Îu by h(·). |
and i′ with probability
Hence, in expectations, we need to make O(n) linear samplings with replacement to observe i′ once, which is not desirable.
fully independent hash functions. As in the linear recommendations case, each hash function maps a pair (u,i) of user and item to [0,1]. The sketch Iu d keeps H pairs, one per function, such that for each function, the pair stored is the one with minimum hash value over the items inserted in the sketch. The sketch is composable. The construction of the sketches in the pre-processing and query time is the same as in the linear case. The final sketch Iu d constructed at query time is a list of
items sampled independently, this time with replacement, from Nu d(G∪Gu) with probability proportional to Cu d(G∪Gu). Recommend an item if and only if it appears at least
times in the list Iu d.
independently, and hence, Xi is sum of independent random variables.
which by
is
which again by
and since
is
Using
which means if an item i is picked we have
as desired. Now assume
Using
which means that if
we pick i.
and query time is Õ(ƒ(|Su V|+k|Eu|)), where ƒ (·) indicates the running time of the offline algorithm Alg.
Note that, we have
Assuming δ≤0.5
Claims (19)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US16/774,380 US11574067B2 (en) | 2019-01-28 | 2020-01-28 | Efficient on-device public-private computation |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201962797651P | 2019-01-28 | 2019-01-28 | |
US16/774,380 US11574067B2 (en) | 2019-01-28 | 2020-01-28 | Efficient on-device public-private computation |
Publications (2)
Publication Number | Publication Date |
---|---|
US20200242268A1 US20200242268A1 (en) | 2020-07-30 |
US11574067B2 true US11574067B2 (en) | 2023-02-07 |
Family
ID=71731410
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US16/774,380 Active 2041-05-04 US11574067B2 (en) | 2019-01-28 | 2020-01-28 | Efficient on-device public-private computation |
Country Status (1)
Country | Link |
---|---|
US (1) | US11574067B2 (en) |
Families Citing this family (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11556730B2 (en) * | 2018-03-30 | 2023-01-17 | Intel Corporation | Methods and apparatus for distributed use of a machine learning model |
US11574067B2 (en) * | 2019-01-28 | 2023-02-07 | Google Llc | Efficient on-device public-private computation |
US11975218B2 (en) * | 2019-06-04 | 2024-05-07 | Elekta Ab (Publ) | Radiotherapy plan parameters with privacy guarantees |
US20210056476A1 (en) * | 2019-08-21 | 2021-02-25 | Oath Inc. | Method and system for secure data sharing |
US11269595B2 (en) * | 2019-11-01 | 2022-03-08 | EMC IP Holding Company LLC | Encoding and evaluating multisets using prime numbers |
US11687328B2 (en) * | 2021-08-12 | 2023-06-27 | C Squared Ip Holdings Llc | Method and system for software enhancement and management |
US11861336B2 (en) * | 2021-08-12 | 2024-01-02 | C Squared Ip Holdings Llc | Software systems and methods for multiple TALP family enhancement and management |
Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20170249434A1 (en) * | 2016-02-26 | 2017-08-31 | Daniela Brunner | Multi-format, multi-domain and multi-algorithm metalearner system and method for monitoring human health, and deriving health status and trajectory |
US20200020062A1 (en) * | 2018-07-12 | 2020-01-16 | Lexisnexis Risk Solutions Inc. | Systems and methods for entity network analytics |
US20200242268A1 (en) * | 2019-01-28 | 2020-07-30 | Google Llc | Efficient On-Device Public-Private Computation |
US20220129766A1 (en) * | 2018-12-24 | 2022-04-28 | Parexel International, Llc | Data storage and retrieval system including a knowledge graph employing multiple subgraphs and a linking layer including multiple linking nodes, and methods, apparatus and systems for constructing and using same |
US20220188661A1 (en) * | 2020-11-05 | 2022-06-16 | Birdview Films, LLC | Stateful, Real-Time, Interactive, and Predictive Knowledge Pattern Machine |
-
2020
- 2020-01-28 US US16/774,380 patent/US11574067B2/en active Active
Patent Citations (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20170249434A1 (en) * | 2016-02-26 | 2017-08-31 | Daniela Brunner | Multi-format, multi-domain and multi-algorithm metalearner system and method for monitoring human health, and deriving health status and trajectory |
US20200020062A1 (en) * | 2018-07-12 | 2020-01-16 | Lexisnexis Risk Solutions Inc. | Systems and methods for entity network analytics |
US11100600B2 (en) * | 2018-07-12 | 2021-08-24 | Lexisnexis Risk Solutions Inc. | Systems and methods for entity network analytics using geometric growth rate analysis |
US20220129766A1 (en) * | 2018-12-24 | 2022-04-28 | Parexel International, Llc | Data storage and retrieval system including a knowledge graph employing multiple subgraphs and a linking layer including multiple linking nodes, and methods, apparatus and systems for constructing and using same |
US20200242268A1 (en) * | 2019-01-28 | 2020-07-30 | Google Llc | Efficient On-Device Public-Private Computation |
US20220188661A1 (en) * | 2020-11-05 | 2022-06-16 | Birdview Films, LLC | Stateful, Real-Time, Interactive, and Predictive Knowledge Pattern Machine |
Non-Patent Citations (51)
Title |
---|
Abadi et al., "Deep Learning with Differential Privacy", arXiv:1607.00133v2, Oct. 24, 2016, 14 pages. |
Agarwal et al., "Approximating Extent Measures of Points", Journal of the ACM, vol. 51, No. 4, Jul. 2004, 30 pages. |
Agarwal et al., "Mergeable Summaries", 2012 ACM SIGMOD/PODS, May 21-23, 2012, Scottsdale, AZ, 12 pages. |
Ahmadian et al., "Better Guarantees for k-Means and Euclidean k-Medianby Prima-Dual Algorithms", Foundations of Computer Science (FOCS 2017), Oct. 15-17, 2017, Berkeley, CA, 12 pages. |
Ahn et al., "Analyzing Graph Structure via Linear Measurements", ACM-SIAM Symposium on Discrete Algorithms, Jan. 17-19, 2012, Kyoto, Japan, pp. 459-467. |
Ahn et al., "Graph Sketches: Sparsification, Spanners, and Subgraphs", ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, May 20-24, 2012, Scottsdale, AZ, 9 pages. |
Archer et al., "Indexing Public-Private Graphs", 26th International Conference on World Wide Web, Apr. 3-7, 2017, Perth, Australia, 10 pages. |
Backstrom et al., "Four Degrees of Separation", 4th Annual ACM Web Science Conference (WebSci '12), Jun. 22-24, 2012, Evanston, IL, 10 pages. |
Backstrom et al., "Wherefore Art Thou R3579x? Anonymized Social Networks, Hidden Patterns, and Structural Stenography", 16th International World Wide Web Conference, May 8-12, 2007, Banff, Alberta, Canada, 10 pages. |
Bansal et al., "Correlation Clustering", Machine Learning, vol. 56, 2004, pp. 89-113. |
Bateni et al., "Distributed Balanced Clustering Via Mapping Coresets" Twenty-eighth Conference on Neural Information Processing Systems, Dec. 8-13, 2014, Montreal, Canada, 9 pages. |
Blum et al., "Practical Privacy: the SuLQ framework" 24th ACM SIGMOD-SIGACT-SIGART Symposium of Principles of Database Systems, Jun. 13-15, 2005, Baltimore, MD, 11 pages. |
Bobadilla et al., "Recommender Systems Survey", Knowledge-Based Systems, vol. 46, 2013, pp. 109-132. |
Boldi et al., "HyperANF: Approximating the Neighbourhood Function of Very Large Graphs on a Budget", 20th International World Wide Web Conference, Mar. 28, 2011-Apr. 1, 2011, Hyderabad, India, pp. 625-634. |
Bonawitz et al., "Practical Secure Aggregation for Privacy-Preserving Machine Learning", 2017 ACM SIGSAC Conference on Computer and Communications Security, Oct. 30, 2017-Nov. 3, 2017, Dallas, TX, pp. 1175-1191. |
Chierichetti et al., "Efficient Algorithms for Public-Private Social Networks", 21st ACM SIGKDD Conference on Knowledge Discovery and Data Mining, Oct. 10-13, 2015, Sydney, Australia, 10 pages. |
Cho et al, "Friendship and Mobility: User Movement in Location-Based Social Networks", 17th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, Aug. 21-24, 2011, San Diego, CA, 9 pages. |
Cohen, "All-Distances Sketches, Revisited: HIP Estimators for Massive Graphs Analysis", 2014 ACM SIGMOD/PODS Conference, Jun. 22-27, 2017, Snowbird, Utah, 15 pages. |
Cohen, "Size-Estimation Framework with Applications to Transitive Closure Reachability", Journal of Computer and System Sciences, vol. 55, 1997, pp. 441-453. |
Demetrescu et al., "A New Approach to Dynamic All Pairs Shortest Paths", Journal of the ACM, vol. 51, No. 6, 2004, pp. 159-166. |
Dey et al., "Facebook Users Have Become Much More Private: A Large-Scale Study", 2012 IEEE International Conference on Persuasive Computing and Communications Workshops (PerCom Workshops), Mar. 19-23, 2012, Lugano, Switzerland, 7 pages. |
Dinur et al., "Revealing Information While Preserving Privacy", SIGMOD/PODS03: International Conference on Management of Data and Symposium on Principles Database and Systems, Jun. 9-12, 2003, San Diego, pp. 202-210. |
Dwork et al., "Calibrating Noise to Sensitivity in Private Data Analysis", 3rd Theory of Cryptography Conference, vol. 3876 LNCS, 2006, pp. 265-284. |
Dwork et al., "Privacy-Preserving Datamining on Vertically Partitioned Databases", Advances in Cryptology—CRYPTO 2004, LNCS, vol. 3152, 2004, pp. 528-544. |
Dwork et al., "The Algorithmic Foundations of Differential Privacy", Foundations and Trends in Theoretical Computer Science, vol. 9, Nos. 3-4, 2014, 281 pages. |
Erlingsson et al., "RAPPOR: Randomized Aggregatable Privacy-Preserving Ordinal Response", 21st ACM Conference on Computer and Communications Security, Nov. 3-7, 2014, Scottsdale, AZ, 14 pages. |
Fogaras et al., "Towards Scaling Fully Personalized PageRank: Algorithms, Lower Bounds, and Experiments", Internet Mathematics, vol. 2, No. 3, 2005, pp. 333-358. |
Garcia, "Leaking Privacy and Shadow Profiles in Online Social Networks", Science Advances, vol. 3, No. 8, Aug. 4, 2017, 6 pages. |
Gross et al., "Information Revelation and Privacy in Online Social Networks", 2005 ACM Workshop on Privacy in the Electronic Society, Nov. 7, 2005, Alexandria Virginia, 10 pages. |
Indyk et al., "Composable Core-sets for Diversity and Coverage Maximization", 2014 ACM SIGMOD/PODS Conference, Jun. 22-27, 2017, Snowbird, Utah, pp. 100-108. |
Jain, "Data clustering: 50 years beyond K-means", Pattern Recognition Letters, vol. 31, No. 8, 2010, pp. 651-666. |
Jowhari et al., "Tight Bounds for LP Samplers, Finding Duplicates in Streams, and Related Problems", thirtieth ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems, Jun. 12-16, 2011, Athens, Greece, 10 pages. |
Kalyanasundaram et al., "The Probabilistic Communication Complexity of Set Intersection", Siam Journal on Discrete Mathematics, vol. 5, No. 4, Nov. 1992, pp. 545-557. |
Kremer et al., "On Randomized One-Round Communication Complexity", Computational Complexity, vol. 8, No. 1, 1999, 21-49 An extended abstract of this work appeared in the proceedings of STOC 1995. |
Larsen et al., "Heavy hitters via cluster-preserving clustering", arXiv:1604.01357v1, Apr. 5, 2016, 39 pages. |
Leskovec et al,. "Graphs over Time: Densification Laws, Shrinking Diameters and Possible Explanations", KDD05: The Eleventh ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, Aug. 21-24, 2005, Chicago, Illinois, 11 pages. |
McAuley et al., "From Amateurs to Connoisseurs: Modeling the Evolution of User Expertise through Online Reviews", 22nd International World Wide Web Conference, May 13-17, 2013, Rio de Janeiro, Brazil, 11 pages. |
McGregor et al., "A Simple, Space-Efficient, Streaming Algorithm for Matchings in Low Arboricity Graphs", 1st Symposium on Simplicity in Algorithms (SOSA 2018), Oasics, vol. 61, 2018, pp. 14.1-14.4. |
McGregor, "Graph Stream Algorithms: A Survey", SIGMOD Record, vol. 43, No. 1, Mar. 2014, pp. 9-20. |
McMahan et al., "Communication-Efficient Learning of Deep Networks from Decentralized Data", 20th International Conference on Artificial Intelligence and Statistics, Apr. 20-22, 2017, Ft. Lauderdale, FL, 10 pages. |
Mirzasoleiman et al., "Fast Distributed Submodular Cover: Public-Private Data Summarization", Thirtieth Conference on Neural Information Processing Systems, Dec. 5-10, 2016, Barcelona, Spain, 9 pages. |
Palmer et al., "ANF: A Fast and Scalable Tool for Data Mining in Massive Graphs", ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, Jul. 23-26, 2002, Edmonton, Canada, 10 pages. |
Panigrahy et al., "How User Behavior is Related to Social Affinity", Fifth ACM International Conference on Web Search and Data Mining, Feb. 8-12, 2012, Seattle, WA, 10 Pages. |
Park et al., "Location-Based Recommendation System Using Bayesian User's Preference Model in Mobile Devices", 4th International Conference, UIC 2007, Jul. 11-13, 2007, Hong Kong, China, pp. 1130-1139. |
Qin et al., "Heavy Hitter Estimation over Set-Valued Data with Local Differential Privacy", 23rd ACM Conference on Computer and Communications Security, Oct. 24-28, 2016, Vienna, Austria, 12 pages. |
Razborov, "On the distributional complexity of disjointness", Theoretical Computer Science, vol. 106, No. 2, 1992, pp. 385-390. |
Sarma et al., "A Sketch-Based Distance Oracle for Web-Scale Graphs", Third ACM International Conference on Web Search and Data Mining, Feb. 3-6, 2010, New York City, New York, pp. 401-410. |
Silva et al., "Data Stream Clustering: A Survey", ACM Computing Surveys, vol. 46, No. 1, Oct. 2013, 37 pages. |
Walter et al., "A model of a trust-based recommendation system on a social network", Autonomous Agents and Multi-Agent Systems, vol. 16, No. 1, 2008, pp. 57-74. |
Yu et al., "My Friend Leaks My Privacy: Modeling and Analyzing Privacy in Social Networks", ACM Symposium on Access Control Models and Technologies (SACMAT), Jun. 13-15, 2018, Indianapolis, Indiana, pp. 93-104. |
Zheleva et al,. "To Join or Not to Join: The Illusion of Privacy in Social Networks with Mixed Public and Private User Profiles", The 18th International World Wide Web Conference, Apr. 20-24, 2009, Madrid, Spain, 10 pages. |
Also Published As
Publication number | Publication date |
---|---|
US20200242268A1 (en) | 2020-07-30 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11574067B2 (en) | Efficient on-device public-private computation | |
Tai et al. | Privacy-preserving decision trees evaluation via linear functions | |
EP3198904B1 (en) | Privacy-preserving cookies for personalization without user tracking | |
Sun et al. | A framework for recommending accurate and diverse items using bayesian graph convolutional neural networks | |
Bai et al. | Reliability evaluation of multistate networks: An improved algorithm using state-space decomposition and experimental comparison | |
Wang et al. | SecGDB: Graph encryption for exact shortest distance queries with efficient updates | |
Firouzi et al. | Fusion of IoT, AI, edge–fog–cloud, and blockchain: Challenges, solutions, and a case study in healthcare and medicine | |
US20140223575A1 (en) | Privacy protection in recommendation services | |
Almutairi et al. | K-means clustering using homomorphic encryption and an updatable distance matrix: secure third party data clustering with limited data owner interaction | |
Barrett et al. | The computational landscape of general physical theories | |
Gade et al. | Privacy-preserving distributed learning via obfuscated stochastic gradients | |
Niu et al. | Secure federated submodel learning | |
Li et al. | An efficient blind filter: Location privacy protection and the access control in FinTech | |
Zhang et al. | Towards efficient, credible and privacy-preserving service QoS prediction in unreliable mobile edge environments | |
Malik et al. | Concurrence percolation threshold of large-scale quantum networks | |
Jia | Construction of online social network data mining model based on blockchain | |
Sun et al. | A systematic review on privacy-preserving distributed data mining | |
Nita et al. | Homomorphic Encryption | |
Mann | Simulating quantum computations with Tutte polynomials | |
Akavia et al. | Secure search on the cloud via coresets and sketches | |
Wang et al. | FedDNA: Federated learning using dynamic node alignment | |
Sun et al. | Practical differentially private online advertising | |
Lin et al. | Sampling based Katz centrality estimation for large-scale social networks | |
Nita et al. | Advances to Homomorphic and Searchable Encryption | |
Shah et al. | Secure featurization and applications to secure phishing detection |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
FEPP | Fee payment procedure |
Free format text: ENTITY STATUS SET TO UNDISCOUNTED (ORIGINAL EVENT CODE: BIG.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:EPASTO, ALESSANDRO;MIRROKNI, VAHAB SEYED;ESFANDIARI, HOSSEIN;SIGNING DATES FROM 20190204 TO 20190212;REEL/FRAME:051746/0866 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: NON FINAL ACTION MAILED |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: RESPONSE TO NON-FINAL OFFICE ACTION ENTERED AND FORWARDED TO EXAMINER |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: NOTICE OF ALLOWANCE MAILED -- APPLICATION RECEIVED IN OFFICE OF PUBLICATIONS |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: PUBLICATIONS -- ISSUE FEE PAYMENT RECEIVED |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |