CN114846459A - Method and apparatus for an intelligent and extensible pattern matching framework - Google Patents
Method and apparatus for an intelligent and extensible pattern matching framework Download PDFInfo
- Publication number
- CN114846459A CN114846459A CN201980103019.XA CN201980103019A CN114846459A CN 114846459 A CN114846459 A CN 114846459A CN 201980103019 A CN201980103019 A CN 201980103019A CN 114846459 A CN114846459 A CN 114846459A
- Authority
- CN
- China
- Prior art keywords
- schema
- attribute
- record
- pattern
- parser
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/25—Integrating or interfacing systems involving database management systems
- G06F16/254—Extract, transform and load [ETL] procedures, e.g. ETL data flows in data warehouses
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/21—Design, administration or maintenance of databases
- G06F16/211—Schema design and management
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/25—Integrating or interfacing systems involving database management systems
- G06F16/252—Integrating or interfacing systems involving database management systems between a Database Management System and a front-end application
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/28—Databases characterised by their database models, e.g. relational or object models
- G06F16/284—Relational databases
Abstract
A method may include: (i) obtaining a first data record constructed according to a first schema, (ii) determining, for the first schema, one or more first schema attribute values for each schema attribute of a predefined schema attribute set, (iii) determining, for the second schema, one or more second schema attribute values for each schema attribute of the predefined schema attribute set, (iv) providing the first schema attribute values and the second schema attribute values to a schema matching engine, wherein the pattern matching engine contains pattern mapping techniques and rules, wherein each rule suggests a pattern mapping technique based on a pattern attribute from a predefined set of pattern attributes, (v) applies a rule to select a pattern mapping technique, (vi) transforms the first data record according to the selected pattern mapping technique, and (vii) providing the transformed first data record according to the data structure of the second schema.
Description
Background
Schema (schema) is a blueprint that defines the layout and format of data records contained in a database, in memory, or in a file. For example, a database table may contain one or more data records, and a schema may correspondingly define the logical grouping of one or more database tables. The schema may include all implementation details necessary to store the data record, such as the data type of the data record, constraints on the data record, foreign or primary keys associated with the data record, and so forth.
Sometimes, it may be of interest to transform a data record from being constructed according to a first schema to being constructed according to a second schema. For example, existing data records may be stored in a legacy database that constructs data structures according to a legacy schema. If a legacy database is replaced by a new database that constructs the data structure according to the new schema, then existing data records in the legacy database should be transformed to be constructed according to the new schema so that the existing data records can be properly stored in the new database.
Disclosure of Invention
The present disclosure relates generally to pattern matching engines of computing systems. The pattern matching engine may be configured to transform the data record from being constructed according to a first pattern to being constructed according to a second pattern. Depending on the (i) data record, (ii) the first schema, and/or (iii) the second schema, the schema matching engine may select one or more schema mapping techniques to perform when transforming the data record.
In a first aspect, a computer-implemented method is provided. The method includes obtaining, by a parser running on a computing system, a first schema and a first data record constructed according to the first schema. The method further comprises the following steps: for a first schema, one or more first schema attribute values are determined for each schema attribute in a predefined schema attribute set. The method further comprises the following steps: for a second schema, one or more second schema attribute values are determined for each schema attribute in the predefined schema attribute set. The method additionally comprises: the first schema attribute value and the second schema attribute value for each schema attribute in the predefined schema attribute set are provided by the parser to a schema matching engine running on the computing system. The pattern matching engine may include: (i) a plurality of schema mapping techniques for transforming the record from the initial schema to the target schema, and (ii) a set of rules, wherein each rule suggests at least one schema mapping technique from the plurality of schema mapping techniques based on at least one schema attribute from the predefined set of schema attributes. The method further comprises the following steps: applying, by a pattern matching engine, a set of rules to the first pattern attribute value and the second pattern attribute value to select at least one pattern mapping technique from a plurality of pattern mapping techniques. The method further comprises the following steps: the first data record is transformed by the pattern matching engine according to at least one selected pattern mapping technique. The method additionally includes providing, by the computing system, the transformed first data record in the data structure according to the second schema.
In a second aspect, a computing system is provided. The computing system includes a parser and a pattern matching engine. The pattern matching engine comprises: (i) a plurality of schema mapping techniques for transforming the record from the initial schema to the target schema, and (ii) a set of rules, wherein each rule suggests at least one schema mapping technique from the plurality of schema mapping techniques based on at least one schema attribute from the predefined set of schema attributes. The computing system also includes one or more processors configured to cause the computing system to perform operations. The operations may include obtaining, by a parser, a first schema and a first data record constructed according to the first schema. The operations may further include: for a first schema, one or more first schema attribute values are determined for each schema attribute in a predefined schema attribute set. The operations may further include: for a second schema, one or more second schema attribute values are determined for each schema attribute in the predefined schema attribute set. The operations may further include: the first schema attribute value and the second schema attribute value for each schema attribute in the predefined schema attribute set are provided to a schema matching engine by a parser. The operations may additionally include: applying, by a pattern matching engine, a set of rules to the first pattern attribute value and the second pattern attribute value to select at least one pattern mapping technique from a plurality of pattern mapping techniques. The operations may further include: the first data record is transformed by the pattern matching engine according to at least one selected pattern mapping technique. The operations may additionally include providing, by the computing system, the transformed first data record in the data structure according to the second schema.
In a third aspect, an article is provided. The article of manufacture may include a non-transitory computer-readable medium having stored thereon program instructions that, when executed by one or more processors of a computing system, cause the computing system to perform operations. The operations may include obtaining, by a parser running on a computing system, a first schema and a first data record constructed according to the first schema. The operations may further include: for a first schema, one or more first schema attribute values are determined for each schema attribute in a predefined schema attribute set. The operations may further include: for a second schema, one or more second schema attribute values are determined for each schema attribute in the predefined schema attribute set. The operations may further include: the first schema attribute value and the second schema attribute value for each schema attribute in the predefined schema attribute set are provided by the parser to a schema matching engine running on the computing system. The pattern matching engine comprises: (i) a plurality of schema mapping techniques for transforming the record from the initial schema to the target schema, and (ii) a set of rules, wherein each rule suggests at least one schema mapping technique from the plurality of schema mapping techniques based on at least one schema attribute from the predefined set of schema attributes. The operations may further include: applying, by a pattern matching engine, a set of rules to the first pattern attribute value and the second pattern attribute value to select at least one pattern mapping technique from a plurality of pattern mapping techniques. The operations may further include: the first data record is transformed by the pattern matching engine according to at least one selected pattern mapping technique. The operations may additionally include providing, by the computing system, the transformed first data record in the data structure according to the second schema.
Other aspects, embodiments, and implementations will become apparent to those of ordinary skill in the art by reading the following detailed description, with appropriate reference to the accompanying drawings.
Drawings
FIG. 1 illustrates a computing system according to an example embodiment.
FIG. 2 illustrates record attributes and schema attributes, according to an example embodiment.
Fig. 3 illustrates allocation rules and a pattern mapping technique according to an example embodiment.
Fig. 4A, 4B, and 4C illustrate a relationship between a parser and a pattern matching engine, according to an example embodiment.
Fig. 5 depicts a message flow in accordance with an example embodiment.
Fig. 6 illustrates a method according to an example embodiment.
Detailed Description
Example methods, devices, and systems are described herein. It should be understood that the words "example" and "exemplary" are used herein to mean "serving as an example, instance, or illustration. Any embodiment or feature described herein as "exemplary" or "exemplary" is not necessarily to be construed as preferred or advantageous over other embodiments or features. Other embodiments may be utilized, and other changes may be made, without departing from the scope of the subject matter presented herein.
Accordingly, the example embodiments described herein are not meant to be limiting. As generally described herein, and illustrated in the accompanying figures, aspects of the present disclosure may be arranged, substituted, combined, separated, and designed in a wide variety of different configurations, all of which are contemplated herein.
In addition, the features shown in each of the figures may be used in combination with each other, unless the context suggests otherwise. Thus, the drawings should generally be regarded as constituting aspects of one or more general embodiments, and it should be understood that not all illustrated features are essential to each embodiment.
I. Overview
Data records often need to be transformed from being constructed according to a first schema to being constructed according to a second schema. Also known as "mode mapping," such transformations can occur in a wide variety of settings. For example, if the machine learning model has specific pattern requirements for its input data, the data records should be transformed to be constructed according to the specific pattern requirements before being passed to the machine learning model. As another example, if a legacy database is replaced by a new database that constructs data according to a new schema, then existing data records in the legacy database should be transformed to be constructed according to the new schema. Other settings for the schema mapping may also exist.
In general, schema mapping is performed as follows: the pattern transformation system provides the user with a list of predetermined pattern mapping techniques to choose from. Next, the user manually selects a mode mapping technique from the list. The schema transformation system then applies the selected schema mapping technique to transform the data record from being constructed according to the first schema to being constructed according to the second schema.
One problem with the above process is that the schema transformation system does not provide the user with any context as to which schema mapping techniques are most appropriate with respect to the data records or the first schema and the second schema. In contrast, the user lacks the discretion to select the schema mapping technique without regard to the content of the data record or the structural details of the first schema and the second schema. This may result in a defective transformation of the data record. For example, a poorly selected schema mapping technique may map some data records to incorrect fields or may miss some data records, and so on.
While the user may manually attempt to investigate the content of the data record or the structural details of the first schema and the second schema to select an appropriate schema mapping technique, performing such a brute force may be overly complex. For example, the number of data records may be thousands or even millions, so manually inspecting the data records may be challenging. In addition, brute force methods that attempt to test all mode mapping techniques can be computationally expensive and impractical. Additionally, it may be too difficult for a user to manually determine aspects of content or structural details. For example, a user may find it very difficult to calculate an average string length across all data records.
Some of the techniques described herein address these issues with a schema transformation system that automatically analyzes the content of a data record and the structural details of a first schema and a second schema to inform decisions regarding which schema mapping techniques to select from a library of schema mapping techniques. It will be appreciated that the selected pattern matching technique is used to control the operation of the computing system to transform the first data record into a data structure according to the second pattern. Thus, various embodiments described herein provide for the generation of functional data (in the form of selected schema mapping techniques) that helps to produce a technical effect. Advantageously, the need for manual analysis of content and structure is removed, allowing the schema transformation system to quickly determine which schema mapping techniques are most appropriate. Furthermore, embodiments described herein provide an extensible framework that can incorporate new schema mapping techniques as they are developed, thereby further improving the capabilities of the schema transformation system. Other advantages are also contemplated and will be appreciated from the discussion herein.
Example computing System
FIG. 1 illustrates a computing system 100, according to an example embodiment. The computing system 100 may be an example schema transformation system that automatically analyzes the content of the data record and the structural details of the first schema and the second schema to inform decisions regarding which schema mapping techniques to select from a library of schema mapping techniques. In an example embodiment, computing system 100 includes parser 110, pattern matching engine 120, network interface 140, and controller 150, although in other embodiments computing system 100 may include other components. In some embodiments, the parser 110 and the pattern matching engine 120 may take the form of separate software modules executable by the computing system 100. In other embodiments, the parser 110 and the pattern matching engine 120 may be combined into a single software module executable by the computing system 100. In some embodiments, the computing system 100 may take the form of a desktop computing device, a server device, or a mobile computing device.
Network interface 140 may include one or more wireless interfaces and/or wired interfaces that may be configured to communicate via a network. The wireless interface may include one or more wireless transmitters, receivers, and/or transceivers, such as bluetooth, configurable to communicate via a wireless network TM A transceiver,
In some embodiments, the network interface 140 may be configured to provide reliable, secure, and/or authenticated communication. For each communication described herein, information to facilitate reliable communication (e.g., to ensure message delivery) may be provided, possibly as part of a message header and/or footer (e.g., packet/message sequence information, encapsulation header and/or footer, size/time information, and transmission verification information, such as Cyclic Redundancy Check (CRC) and/or parity values). The communication may be secured (e.g., encoded or encrypted) and/or decrypted/decoded using one or more cryptographic protocols and/or algorithms, such as, but not limited to, the Data Encryption Standard (DES), the Advanced Encryption Standard (AES), the Rivest-Shamir-adelman (rsa) algorithm, the Diffie-Hellman algorithm, secure socket protocols, such as Secure Socket Layer (SSL) or Transport Layer Security (TLS), and/or the Digital Signature Algorithm (DSA). Other cryptographic protocols and/or algorithms may also be used, or in addition to those listed herein, to secure communications (and then decrypt/decode the communications).
The controller 150 may include one or more processors 152 and data storage 154. Processor(s) 152 may include one or more general purpose processors and/or one or more special purpose processors (e.g., Digital Signal Processors (DSPs), Tensor Processing Units (TPUs), Graphics Processing Units (GPUs), Application Specific Integrated Circuits (ASICs), etc.). Processor(s) 152 may be configured to execute computer-readable instructions contained in data storage 154 and/or other instructions as described herein. The data storage 154 may include one or more non-transitory computer-readable storage media that may be read and/or accessed by the processor(s) 152. One or more non-transitory computer-readable storage media may include volatile and/or non-volatile storage components, such as optical, magnetic, organic, or other memory or disk storage, which may be integrated in whole or in part with at least one of the processor(s) 152. In some examples, data storage 154 may be implemented using a single physical device (e.g., one optical, magnetic, organic, or other memory or disk storage unit), while in other examples, data storage 154 may be implemented using two or more physical devices. In an example embodiment, the processor(s) 152 may be configured to execute instructions stored in the data storage 154 to perform one or more operations, e.g., operations of method 500 or 600 as described below.
To conceptually illustrate the record attributes and schema attributes, FIG. 2 is provided. In particular, FIG. 2 shows how parser 110 receives input data records 200 and input patterns 210 and then responsively analyzes input data records 200 and input patterns 210 to determine record attribute values for record attributes 230 and pattern attribute values for pattern attributes 240.
The record attributes 230 include attributes presented by the input data record 200. Thus, the record attribute value for a particular record attribute may indicate the extent to which the input data record 200 exhibits the particular record attribute. In an example, the record attributes 230 may include an average string length attribute 230A, a value range attribute 230B, and a unique value attribute 230C. The record attribute value associated with the record attribute 230 may be a string, number, boolean, or null value, as well as an object or array. For example, the record attribute value associated with the average string length attribute 230A may be a number, the record attribute value associated with the value range attribute 230B may be an array, and the record attribute value associated with the unique value attribute 230C may be a boolean value.
In some examples, the user may provide the record attributes 230 to the parser 110 before the parser 110 performs an operation on the input data record 200. When providing record attributes 230 to parser 110, a user may configure parser 110 with instructions regarding which elements of input data record 200 are to be located and what data is to be extracted from those located elements in order to determine record attribute values for record attributes 230.
Thus, during operation, the parser 110 may analyze the input data record 200 to determine record attribute values associated with the record attributes 230. For example, to obtain record attribute values for the average string length attribute 230A, the parser 110 may (i) locate all records in the input data records 200 that have a string data type and (ii) calculate an average length of all located records that have a string data type. As another example, to obtain record attribute values for value range attribute 230B, parser 110 may (i) locate all records in input data records 200 that have integer or floating point data types and (ii) calculate a mathematical range for all located records that have integer or floating point data types. As yet another example, to obtain record attribute values for the unique value attribute 230C, the parser 110 may (i) locate all records in the input data records 200 and (ii) determine whether any of the located records are multiple records.
Note that record attributes 230 are presented for purposes of example and are not intended to be limiting with respect to embodiments herein. Other recording attributes may also exist.
The schema properties 240 include properties that can be presented by the input schema 210. Thus, the schema attribute value for a particular schema attribute may indicate the degree to which the input schema 210 presents the particular schema attribute. In an example, schema attributes 240 include nested attributes 240A, language type attributes 240B, domain type attributes 240C, and schema type attributes 240D. Like the record attribute values, the schema attribute values associated with the schema attribute 240 may be character strings, numbers, Boolean or null values, as well as objects or arrays. For example, the schema attribute value associated with nested attribute 240A may be a Boolean value, the schema attribute value associated with language type attribute 240B may be a string, the schema attribute value associated with domain type attribute 240C may be a string, and the schema attribute value associated with schema type attribute 240D may also be a string.
In some examples, the user may provide the schema attributes 240 to the parser 110 before the parser 110 performs an operation on the input schema 210. When providing the schema attributes 240 to the parser 110, the user may configure the parser 110 with instructions regarding which elements in the input schema 210 are to be located and what data is to be extracted from those located elements in order to determine the schema attribute values for the schema attributes 240.
Thus, during operation, the parser 110 may analyze the input schema 210 to determine schema attribute values associated with the schema attributes 240. For example, to obtain a schema attribute value for nested attribute 240A, parser 110 may (i) locate all fields in input schema 210 and (ii) determine whether any of the located fields are associated with an object data type. As another example, to obtain the schema attribute values for the language type attributes 240B, the parser 110 may (i) locate all fields in the input schema 210 and (ii) apply a natural language processing model on the located fields to determine the most likely language associated with the input schema 210. As yet another example, to obtain a schema attribute value for the domain type attribute 240C, the parser 110 may (i) locate all fields in the input schema 210 and (ii) apply a natural language processing model on the located fields to determine the most likely topic domain associated with the input schema 210. As yet another example, to obtain a pattern attribute value for the pattern type attribute 240D, the parser 110 may (i) locate all fields in the input pattern 210 and (ii) apply a trained machine learning model on the located fields to determine the most likely pattern type associated with the input pattern 210.
Note that schema attributes 240 are used for purposes of example and are not intended to be limiting with respect to embodiments herein. Other schema attributes may also exist.
The pattern matching engine 120 may include a variety of pattern mapping techniques for transforming a data record from being constructed according to a first pattern to being constructed according to a second pattern. Additionally, the pattern matching engine 120 may contain a set of allocation rules, wherein each allocation rule in the set of allocation rules suggests at least one pattern mapping technique from the plurality of pattern mapping techniques based on (i) pattern attributes presented by the first pattern and the second pattern and/or (ii) record attributes presented by the first data record constructed according to the first pattern and the second data record constructed according to the second pattern.
To conceptually illustrate the allocation rules and pattern mapping techniques, FIG. 3 is provided. In particular, FIG. 3 illustrates how allocation rules 310 may utilize schema attributes and record attributes determined by parser 110 to select a schema mapping technique from schema mapping techniques 300.
The schema mapping technique 300 may transform a data record from one schema to another schema. Each of the pattern mapping techniques 300 may use a different method to perform the transformation. In an example embodiment, the schema mapping technique 300 includes a string distance technique 300A, a semantic distance technique 300B, a data type technique 300C, and a value distribution technique 300D. However, other schema mapping techniques are possible and are contemplated in the disclosure herein. Additionally, the schema mapping technique 300 may be extensible such that new schema mapping techniques may be added to the schema mapping technique 300. In an example, adding a new schema mapping technique to schema mapping technique 300 may involve configuring allocation rules 310 such that at least some combination of schema attributes or record attributes determined by parser 110 suggest the new schema mapping technique.
The string distance technique 300A may transform a data record from one mode to another by calculating a string similarity score between a field name in a first mode and a field name in a second mode. For example, if the first schema has one field named "Tree" and the second schema has one field named "Trees" and another field named "Chicago," the string distance technique 300A may be more inclined to transform data records from "Tree" to "Trees" than "Tree" to "Chicago" because "Tree" has greater string similarity to "Chicago" than "Trees".
The semantic distance technique 300B may transform a data record from one schema to another schema by calculating a semantic similarity score between field names in a first schema and field names in a second schema. For example, if a first schema has one field named "Trees" and a second schema has one field named "Treasure" and another field named "Forest," then the semantic distance technique 300B may be more inclined to transform a data record from "Trees" to "Forest" than "Trees" to "Treasure" because "Trees" has greater semantic similarity to "Treasure" than "Forest".
The data type technique 300C may transform a data record from one schema to another schema by calculating a data type similarity score between fields in a first schema and fields in a second schema. For example, if the first schema has one field with an integer data type and the second schema has one field with a floating point data type and another field with a timestamp data type, then data type technique 300C may prefer to transform records from fields with integer data types to floating point data types rather than to timestamp data types because integer and floating points have greater data type similarity than timestamps.
The value distribution technique 300D may transform a first data record from one mode to another mode by calculating a value similarity score between the values of the first data record and the values of a representative second data record constructed according to the second mode. For example, if a first data record contains one field with a value having a mean of 102 and a second data record contains one field with a value having a mean of 100 and another field with a value having a mean of 400, then the value distribution technique 300D may be more inclined to transform the data records from the field with the value having a mean of 102 to the field with the value having a mean of 100 than to the field with the value having a mean of 400 because 102 and 100 have a greater value similarity score than 400.
The allocation rules 310 may assist the pattern matching engine 120 in selecting one or more pattern mapping techniques from the pattern mapping techniques 300. In particular, a given allocation rule from allocation rules 310 may evaluate schema attributes or record attributes determined by parser 110 to suggest one or more schema mapping techniques from schema mapping techniques 300. Allocation rules 310 may be evaluated independently or jointly to suggest one or more pattern mapping techniques. In an example embodiment, the allocation rules 310 include a first pattern nesting rule 310A, a second pattern type rule 310B, and a first record average string length rule 310C. However, other allocation rules are also possible and are contemplated in the disclosure herein.
The first pattern nesting rule 310A is an example of an independent evaluation rule. The rule may utilize nested attributes 240A from schema attributes 240 to determine which schema mapping technique from schema mapping techniques 300 to suggest. For example, if the schema attribute value associated with nested attribute 240A indicates that the first schema is nested (e.g., has a field associated with an object data type), then first schema nesting rule 310A may suggest string distance technique 300A. Otherwise, if the schema attribute value associated with nested attribute 240A indicates that the first schema is not nested, then first schema nesting rule 310A may suggest semantic distance technique 300B.
The second pattern type rule 310B and the first record average string length rule 310C are examples of joint evaluation rules. These rules may utilize the average string length attribute 230A from the record attributes 230 and the schema type attribute 240A from the schema attributes 240 to determine which schema mapping technique from the schema mapping techniques 300 to suggest.
For example, if the schema attribute value associated with the schema type attribute 240A indicates that the second schema is a JavaScript object notation (JSON) schema and the record attribute value associated with the average string length attribute 230A indicates that the first data record has an average string length less than 8, the second schema type rule 310B and the first record average string length rule 310C may suggest the string distance technique 300A. Otherwise, if the schema attribute value associated with the schema type attribute 240A indicates that the second schema is a JSON schema and the record attribute value associated with the average string length attribute 230A indicates that the first data record has an average string length greater than 8, then the second schema type rule 310B and the first record average string length rule 310C may suggest the semantic distance technique 300B.
Alternatively, if the schema attribute value associated with the schema type attribute 240A indicates that the second schema is a relational schema and the record attribute value associated with the average string length attribute 230A indicates that the first data record has an average string length less than 8, the second schema type rule 310B and the first record average string length rule 310C may suggest the data type technique 300C. Otherwise, if the schema attribute value associated with the schema type attribute 240A indicates that the second schema is a relational schema and the record attribute value associated with the average string length attribute 230A indicates that the first data record has an average string length greater than 8, the second schema type rule 310B and the first record average string length rule 310C may suggest the value distribution technique 300D.
Note that while the allocation rule 300 is represented as a decision tree, this is for example only and is not intended to be limiting with respect to embodiments herein. In other examples, the allocation rule 300 may take the form of a predictive model. The predictive models may include, but are not limited to: artificial neural networks, bayesian networks, hidden markov models, markov decision processes, logistic regression functions, support vector machines, statistical machine learning algorithms, and/or heuristic machine learning systems. The predictive model may be designed to take as input the record attribute values for the record attributes 230 and the schema attribute values for the schema attributes 240 and may correspondingly output one or more schema mapping techniques from the schema mapping technique 310 suitable for transforming a data record from being constructed according to a first schema to being constructed according to a second schema.
Additionally, the allocation rules 300 may be configured to suggest a pattern mapping technique from the pattern mapping techniques 300 based on one or more previous pattern transformations performed by the pattern matching engine 120. For example, assume that the pattern matching engine 120 utilizes a semantic distance technique 300B to transform a data record from being constructed according to pattern A to being constructed according to pattern B. Then, at a later point in time, assume that the pattern matching engine 120 is responsible for transforming the data record from being constructed according to pattern C to being constructed according to pattern D. If the pattern matching engine 120 determines that (i) the pattern attributes associated with pattern C and the pattern attributes associated with pattern a are similar (e.g., have the same value, are within a threshold from each other, or, if the pattern attributes are represented as vectors, are within a threshold cosine similarity from each other (greater than.9) or a jaccard similarity) and (ii) the pattern attributes associated with pattern D and the pattern attributes associated with pattern B are similar, then the assignment rules 300 within the pattern matching engine 120 may be configured to suggest the same pattern mapping technique (in this case, the semantic distance technique 300B) that is utilized to transform data records from pattern a to pattern B as the pattern mapping technique used to transform data records from pattern C to pattern D.
Fig. 4A, 4B, and 4C illustrate the relationship between the parser 110 and the pattern matching engine 120, according to an example embodiment. In particular, fig. 4A, 4B, and 4C are provided to illustrate how the pattern matching engine 120: (i) receive a first data record constructed according to a first schema, (ii) receive record attribute values and schema attribute values from parser 110 and (iii) select one or more schema mapping techniques to transform the first data record from being constructed according to the first schema to being constructed according to a second schema using the record attribute values and/or the schema attribute values.
Fig. 4A illustrates how the pattern matching engine 120 receives a first data record 400 and an attribute value 408 and then responsively transforms the first data record 400 into a transformed data record 410, wherein the transformed data record 410 has the same pattern as the second data record 406 (i.e., the second pattern 404).
The first data record 400 is constructed according to a first schema 402. For simplicity, the contents of the first schema 402 are not shown, but the first schema 402 can be a JSON encoding schema. In general, JSON is a hierarchical nesting of objects and arrays. A JSON object is an unordered set of key/value pairs that start with a left brace ("{") and end with a right brace ("}"), where keys may correspond to fields and values may correspond to entries for those fields. The values may be strings, numbers, boolean or null values, and objects or arrays. The JSON array is an ordered set of values starting with the left bracket ("[") and ending with the right bracket ("]"). The values in the array are separated by commas.
Second data record 406 is constructed according to second schema 404. For simplicity, the contents of the second pattern 404 are not shown, but the second pattern 404 may also be a JSON encoding pattern. However, the second pattern 404 may be different from the first pattern 402. For example, the first data record 400 is shown with the keys "first name" and "last name", while the second data record 406 is shown with the key "name". This inconsistency is an example of the difference between the first pattern 402 and the second pattern 404.
Likewise or instead, the parser 110 may also be configured to analyze the first schema 402 and the second schema 404 to determine schema attribute values associated with the schema attributes 240. In particular, the parser 110 may analyze the first schema 402 to determine a first schema attribute value associated with the schema attribute 240, wherein the first schema attribute value indicates an extent to which the first schema 402 presents the schema attribute 240. The parser 110 may also analyze the second schema 404 to determine a second schema attribute value associated with the record attribute 240, wherein the second schema attribute value indicates a degree to which the second schema 404 presents the schema attribute 240. As an example, to obtain a second schema attribute value for nested attribute 240A, parser 110 may (i) locate all fields in second schema 404 and (ii) determine whether any of the located fields are associated with an object data type.
After analyzing the first data record 400, the second data record 406, the first schema 402, and the second schema 404, the parser 110 may provide the determined record attribute values associated with the record attributes 230 and the determined schema attribute values associated with the schema attributes 240 to the schema matching engine 120 in the form of attribute values 408.
The pattern matching engine 120 may receive the attribute values 408 from the parser 110 and may use the attribute values 408 and the allocation rules 310 to select one or more pattern mapping techniques to transform the first data record 400 into a transformed data record 410. In this example, the keys in the first data record 400 have similar string names as the keys in the second data record 418. For example, the second data record 406 uses the keys "name", "education", and "state" and the first data record 400 uses the keys "first name", "last name", "educational condition", and "state". The assignment rule 310 may determine the string similarity and may cause the pattern matching engine 120 to select the string distance technique 300A to transform the first data record 400 into the transformed data record 410.
Fig. 4B illustrates how the pattern matching engine 120 receives the first data record 412 and the attribute values 420 and then responsively transforms the first data record 412 into a transformed data record 422, wherein the transformed data record 422 has the same pattern as the second data record 418.
The first data record 412 is constructed according to a first schema 414. For simplicity, the contents of the first schema 414 are not shown, but the first schema 414 may be a relational schema. Typically, relational schema organizes data records into a series of interconnected tables. The table contains columns and rows. The rows of the table correspond to individual entries, and the columns correspond to the fields of those individual entries. The entry may be a string, a number, a boolean value, or a null value.
The second data record 418 is constructed according to the second schema 416. For simplicity, the contents of the second schema 416 are not shown, but the second schema 416 may also be a relational schema. However, the second mode 416 may be different from the first mode 414. For example, the first data record 412 is shown as being constructed on two tables, whereas the second data record 418 is shown as being constructed on only a single table. Further, the first data record 412 is shown as having the attribute "name" and the second data record 418 is shown as having the attribute "name". These inconsistencies are examples of the differences between the first pattern 414 and the second pattern 416.
Similar to fig. 4A, the parser 110 may be configured to analyze the first data record 412 and the second data record 418 to determine record attribute values associated with the record attributes 230. Likewise or instead, the parser 110 may also be configured to analyze the first schema 414 and the second schema 416 to determine schema attribute values associated with the schema attributes 240. After analyzing the first data record 412, the second data record 418, the first schema 414, and the second schema 416, the parser 110 may provide the determined record attribute values associated with the record attributes 230 and the determined schema attribute values associated with the schema attributes 240 to the schema matching engine 120 in the form of attribute values 420.
The pattern matching engine 120 may receive the attribute values 420 from the parser 110 and may use the attribute values 420 and the assignment rules 310 to select one or more pattern mapping techniques to transform the first data record 412 into a transformed data record 422. In this example, the columns in the first data record 412 have semantically similar names as the columns in the second data record 418. For example, the second data record 418 uses the column names "name", "years", and "profession" and the first data record 412 uses the column names "name", "age", and "work", the assignment rule 310 may determine this semantic similarity and may cause the pattern matching engine 120 to select the semantic distance technique 300B to transform the first data record 412 into the transformed data record 422.
Fig. 4C illustrates how the pattern matching engine 120 receives the first data record 400 and the attribute values 424 and then responsively transforms the first data record 400 into a transformed data record 426, wherein the transformed data record 426 has the same pattern as the second data record 418.
The first data record 400 was previously discussed in FIG. 4A and is constructed according to a first schema 402. The second data record 450 was previously discussed in FIG. 4B and is constructed according to the second schema 416. The second pattern 416 may be different from the first pattern 402. For example, the first data record 400 is shown constructed according to a JSON schema, while the second data record 418 is shown constructed according to a relational schema. Further, the first data record 400 is shown with the attributes "first name" and "last name", while the second data record 418 is shown with the attribute "first name". These inconsistencies are examples of the differences between the first pattern 402 and the second pattern 416.
Similar to fig. 4A and 4B, the parser 110 may analyze the first data record 400 and the second data record 418 to determine record attribute values associated with the record attributes 230. Likewise or instead, the parser 110 may also analyze the first schema 402 and the second schema 416 to determine schema attribute values associated with the schema attributes 240. After analyzing the first data record 400, the second data record 418, the first schema 402, and the second schema 416, the parser 110 may provide the determined record attribute values associated with the record attributes 230 and the determined schema attribute values associated with the schema attributes 240 to the schema matching engine 120 in the form of attribute values 424.
The pattern matching engine 120 may receive the attribute values 424 from the parser 110 and may use the attribute values 424 and the assignment rules 310 to select one or more pattern mapping techniques to transform the first data record 400 into a transformed data record 426. In this example, the key in the first data record 400 has a semantically similar name to the column in the second data record 418. For example, the second data record 418 uses the column names "name", "year", and "occupation" and the first data record 412 uses the key names "name" and "age". The allocation rules 310 may determine the semantic similarity and may cause the pattern matching engine 120 to select the semantic distance technique 300B to transform the first data record 400 into a transformed data record 426.
Example methods
Fig. 5 depicts a message flow 500 according to an example embodiment. Message flow 500 may be logically divided into three phases: a parsing phase 502, wherein the parser 110 receives and parses the first schema and the second schema and the first data record and the second data record; a prediction phase 504 in which the pattern matching engine 120 determines one or more pattern mapping techniques and then transforms the first data record according to the one or more determined pattern mapping techniques; and a feedback stage 506 in which the client device 508 provides feedback on the transformations made by the pattern matching engine 120 in the prediction stage 504. As an example, message flow 500 may utilize parser 110, pattern matching engine 120, and client device 508 during operation. However, additional components, steps, or blocks may be added to message flow 500 without departing from the scope of the present disclosure.
At block 510, parser 110 receives (i) a first schema and (ii) a first data record constructed according to the first schema. In some embodiments, parser 110 may determine the first schema by parsing the first data record. In some embodiments, parser 110 receives the first schema and the first data record from client device 508. For example, parser 110 may prompt client device 508 to enter appropriate data for the first schema and the first data record. This may be done through a web page or series of web pages hosted by resolver 110 and provided to client device 508 when requested. Alternatively, the parser 110 may receive the first schema and the first data record from another device, such as a database device or a cloud-based computing device.
At block 512, the parser 110 receives (i) the second schema and (ii) a second data record constructed according to the second schema. As similarly described in block 510, parser 110 may determine the second schema by parsing the second data record. Parser 110 receives the second schema and the second data record from client device 508, as similarly described in block 510. Alternatively, the parser 110 may receive the second schema and the second data record from another device, such as a database device or a cloud-based computing device.
Since the pattern matching engine 120 may be configured to transform all of the first data records without transforming the second data records, in some embodiments, the number of second data records may be less than the number of first data records.
At block 514, parser 110 determines record attribute values for one or more predefined record attributes and schema attribute values for one or more predefined schema attributes. For example, the parser 110 may analyze a first data record to determine a first record attribute value associated with the record attributes 230 and may analyze a second data record to determine a second record attribute value associated with the record attributes 230. As another example, the parser 110 may analyze a first schema to determine first schema attribute values associated with the schema attributes 240 and may analyze a second schema to determine second schema attribute values associated with the schema attributes 240.
At block 516, the parser 110 sends (i) the first schema attribute value, (ii) the second schema attribute value, (iii) the first record attribute value, and (iv) the second record attribute value to the schema matching engine 120. The parser 110 may additionally send the first data record to the pattern matching engine 120.
At block 518, the pattern matching engine 120 utilizes the attribute values received from the parser 110 at block 516 to determine one or more pattern mapping techniques from a library of pattern mapping techniques contained within the pattern matching engine 120. As described with reference to fig. 3, the pattern matching engine 120 may use one or more allocation rules/predictive models to determine one or more pattern mapping techniques. These predictive models may include, but are not limited to: artificial neural networks, bayesian networks, hidden markov models, markov decision processes, logistic regression functions, support vector machines, decision trees, statistical machine learning algorithms, and/or heuristic machine learning systems.
At block 520, the pattern matching engine 120 uses the one or more pattern mapping techniques determined in block 518 to transform the first data record from being constructed according to the first pattern to being constructed according to the second pattern.
In some embodiments, the pattern matching engine 120 may use different pattern mapping techniques on different portions of the first data record. For example, the first data records may contain a first plurality of first data records and a second plurality of first data records, where the second plurality is different from the first plurality. In some cases, the second plurality of first data records may be nested within the first plurality of first data records. In such embodiments, the pattern matching engine 120 may transform the first plurality of first data records according to a first pattern mapping technique from the one or more pattern mapping techniques determined in block 518, and may transform the second plurality of first data records according to a second pattern mapping technique from the one or more pattern mapping techniques determined in block 518. For example, the pattern matching engine 120 may transform the first plurality of first data records using a string distance technique 300A and may transform the second plurality of first data records using a value distribution technique 300D.
In some embodiments, after transformation, the pattern matching engine 120 may store the transformed first data record into persistent storage, wherein the data records stored in persistent storage are constructed according to the second pattern.
At block 520, the pattern matching engine 120 provides the transformed first data record of the data structure according to the second pattern to the client device 508. Providing the transformed first data record may include, for example, generating one or more Graphical User Interfaces (GUIs) that include representations of the transformed first data record and providing the one or more GUIs to the client device 508.
At block 524, the pattern matching engine 120 may receive feedback values from the client device 508 regarding the transformation made at block 520. Receiving feedback may be accomplished, for example, through a GUI provided to client device 508 by pattern matching engine 120 (possibly via network interface 140). The GUI may include feature(s) for providing feedback to the pattern matching engine 120. For example, the GUI may contain data entry fields that allow the client device 508 to rank the transformations made at block 520. As an example, the client device 508 may provide a level from 1-10, where a high level (e.g., 9 or 10) corresponds to a satisfactory transformation at block 520 (e.g., the transformed first data record strictly follows the second pattern), and a low level (e.g., 1 or 2) corresponds to an unsatisfactory transformation at block 520 (e.g., the transformed first data record does not strictly follow the second pattern).
In some embodiments, the client device 508 provides a plurality of feedback values for different sections of the transformed first data record. For example, the transformed first data records may include a first set of transformed first data records and a second set of transformed first data records, wherein the first set is different from the second set. Accordingly, the client device 508 may provide a first feedback value indicating a degree to which the first set of transformed first data records comply with the second pattern and a second feedback value indicating a degree to which the second set of transformed first data records comply with the second pattern. In particular, other methods of providing feedback also exist.
At block 526, the pattern matching engine 120 may adjust the allocation rules 300 based on the feedback received at block 524. For example, if (i) allocation rule 300 selects data type technique 300C as the pattern mapping technique for block 520 based on the analysis of the attribute values received at block 516, and (ii) the feedback provided at block 524 is that client device 508 is not satisfied with the transformation at block 520, pattern matching engine 120 may adjust allocation rule 300 such that allocation rule 300 will select another pattern mapping technique in addition to data type technique 300C based on the analysis of the attribute values received at block 516. Other adjustments are also possible. In some embodiments, the pattern matching engine 120 may store feedback provided by the client device 508 in persistent storage for later use.
Example operation
Fig. 6 illustrates a method 600 according to an example embodiment. The method 600 may include various blocks or steps. Blocks or steps may be performed individually or in combination. The blocks or steps may be performed in any order and/or sequentially or in parallel. In addition, blocks or steps may be omitted or added to the method 600. The blocks of method 600 may be performed by various elements of computing system 100 as illustrated and described with reference to fig. 1.
block 620 may involve determining, by the parser and for a first schema, one or more first schema attribute values for each schema attribute in the predefined schema attribute set.
block 640 may involve providing, by the parser, the first schema attribute value and the second schema attribute value for each schema attribute in the predefined schema attribute set to a schema matching engine running on the computing system. The pattern matching engine may comprise: (i) a plurality of schema mapping techniques for transforming a record from an initial schema to a target schema, and (ii) a set of rules. Each rule may suggest at least one schema mapping technique from a plurality of schema mapping techniques based on at least one schema attribute from a predefined set of schema attributes.
Some embodiments may involve: receiving, by the parser, a representative second data record constructed according to the second schema; for a first data record, determining one or more first record attribute values for each record attribute in a predefined set of record attributes; and for the second data record, determining one or more second record attribute values for each record attribute in the predefined set of record attributes. Such embodiments may further involve providing, by the parser, the first record attribute value and the second record attribute value for each record attribute in the predefined set of record attributes to a pattern matching engine, wherein the pattern matching engine further contains a second set of rules, and wherein each second rule suggests at least one pattern mapping technique from a plurality of pattern mapping techniques based on at least one record attribute from the predefined set of record attributes. Such embodiments may still further involve applying, by the pattern matching engine, a second set of rules to the first record attribute values and the second record attribute values to select the at least one pattern mapping technique.
In some embodiments, the number of representative second data records is less than the number of first data records.
Some embodiments involve storing, by the pattern matching engine, the transformed first data record into the persistent storage, wherein the data record stored in the persistent storage is constructed according to the second pattern.
In some embodiments, the predefined record attributes include mathematical range attributes. In some embodiments, the predefined record attributes include an average length attribute.
In some embodiments, providing the transformed first data record comprises: generating, by the computing system, one or more graphical user interfaces comprising a representation of the transformed first data record; and providing, by the computing system, the one or more graphical user interfaces to the client device.
Some embodiments may involve: receiving at least one feedback value from the client device indicating an extent to which the transformed first data record conforms to the second pattern; and storing the at least one feedback value in a persistent storage.
Some embodiments may involve: updating, by the pattern matching engine, the rule set based on the at least one feedback value such that the at least one rule suggests at least one pattern mapping technique that is different from a previously suggested pattern mapping technique.
In some embodiments, the transformed first data records may include a first plurality of transformed first data records and a second plurality of transformed first data records. In such embodiments, the at least one feedback value may comprise a first feedback value indicative of a degree to which the first plurality of transformed first data records comply with the second pattern, and the at least one feedback value may comprise a second feedback value indicative of a degree to which the second plurality of transformed first data records comply with the second pattern.
In some embodiments, the first data records may include a first plurality of first data records and a second plurality of first data records. In such embodiments, transforming the first data records according to the at least one selected schema mapping technique may include transforming a first plurality of the first data records according to a first schema mapping technique of the at least one selected schema mapping technique and transforming a second plurality of the first data records according to a second schema mapping technique of the at least one selected schema mapping technique.
In some embodiments, the second plurality of first data records is nested within the first plurality of first data records.
In some embodiments, the predefined schema attributes include domain attributes. In some embodiments, the predefined schema attributes include a schema type attribute.
In some embodiments, the plurality of schema mapping techniques includes a string similarity mapping technique. In some embodiments, the plurality of mode mapping techniques includes a value distribution mapping technique. In some embodiments, the plurality of schema mapping techniques includes semantic similarity mapping techniques.
Some embodiments may involve: obtaining, by the parser, a third schema and a third data record constructed according to the third schema; determining, by the parser and for a third schema, one or more third schema attribute values for each schema attribute in the predefined schema attribute set; and determining, by the parser and for a fourth schema, one or more fourth schema attribute values for each schema attribute in the predefined schema attribute set. Such embodiments may further involve: providing, by the parser, the third schema attribute value and the fourth schema attribute value for each schema attribute in the predefined schema attribute set to the schema matching engine; and determining, by the pattern matching engine: (i) the third schema attribute value is similar to the first schema attribute value; and (ii) the fourth schema attribute value is similar to the second schema attribute value. Such embodiments may further comprise: transforming, by the pattern matching engine, the third data record according to at least one selected pattern mapping technique; and providing, by the computing system, the transformed third data record of the data structure according to the fourth schema.
The particular arrangements shown in the drawings should not be considered limiting. It should be understood that other embodiments may include more or less of each element shown in a given figure. In addition, some of the illustrated elements may be combined or omitted. Still further, example embodiments may include elements not shown in the figures.
The steps or blocks representing the processing of information may correspond to circuitry that may be configured to perform particular logical functions of the methods or techniques described herein. Alternatively or additionally, the steps or blocks representing processing of information may correspond to modules, segments, or portions of program code (including associated data). The program code may include one or more instructions executable by a processor for implementing specific logical functions or actions in a method or technique. The program code and/or associated data may be stored on any type of computer-readable medium, such as a storage device including a disk, hard drive, or other storage medium.
The computer readable medium may also include non-transitory computer readable media, such as computer readable media that store data for short periods of time, like register memory, processor cache, and Random Access Memory (RAM). The computer-readable medium may also include a non-transitory computer-readable medium that stores program code and/or data for an extended period of time. Thus, a computer-readable medium may include secondary or permanent long-term storage devices, such as, for example, read-only memory (ROM), optical or magnetic disks, compact disk read-only memory (CD-ROM). The computer readable medium may also be any other volatile or non-volatile storage system. The computer readable medium may be considered, for example, a computer readable storage medium, or a tangible storage device.
While various examples and embodiments have been disclosed, other examples and embodiments will be apparent to those skilled in the art. The various disclosed examples and embodiments are for purposes of illustration and are not intended to be limiting, with the true scope being indicated by the following claims.
Claims (20)
1. A computer-implemented method, comprising:
obtaining, by a parser running on a computing system, a first schema and a first data record constructed according to the first schema;
determining, by the parser and for the first schema, one or more first schema attribute values for each schema attribute in a predefined schema attribute set;
determining, by the parser and for a second schema, one or more second schema attribute values for each schema attribute of the predefined set of schema attributes;
providing, by the parser, a first schema attribute value and a second schema attribute value for each schema attribute of the predefined set of schema attributes to a schema matching engine running on the computing system, wherein the schema matching engine comprises: (i) a plurality of schema mapping techniques for transforming a record from an initial schema to a target schema, and (ii) a set of rules, wherein each rule suggests at least one schema mapping technique from the plurality of schema mapping techniques based on at least one schema attribute from the set of predefined schema attributes;
applying, by the pattern matching engine, the set of rules to the first pattern attribute value and the second pattern attribute value to select at least one pattern mapping technique from the plurality of pattern mapping techniques;
transforming, by the pattern matching engine, the first data record according to at least one selected pattern mapping technique; and
providing, by the computing system, a transformed first data record of a data structure according to the second schema.
2. The computer-implemented method of claim 1, further comprising:
receiving, by the parser, a representative second data record constructed according to the second schema;
determining, by the parser and for the first data record, one or more first record attribute values for each record attribute in a predefined set of record attributes;
determining, by the parser and for the second data record, one or more second record attribute values for each record attribute in a predefined set of record attributes;
providing, by the parser, a first record attribute value and a second record attribute value for each record attribute in the predefined set of record attributes to the pattern matching engine, wherein the pattern matching engine further contains a second set of rules, wherein each second rule suggests at least one pattern mapping technique from the plurality of pattern mapping techniques based on at least one record attribute from the predefined set of record attributes; and
applying, by the pattern matching engine, the second set of rules to the first record attribute values and the second record attribute values to select the at least one pattern mapping technique.
3. The computer-implemented method of claim 2, wherein the number of representative second data records is less than the number of first data records.
4. The computer-implemented method of claim 2 or claim 3, further comprising:
storing, by the pattern matching engine, the transformed first data record into a persistent storage device, wherein the data record stored in the persistent storage device is constructed according to the second pattern.
5. The computer-implemented method of any of claims 2-4, wherein the predefined recording attribute comprises a mathematical range attribute.
6. The computer-implemented method of any of claims 2-5, wherein the predefined recording attribute comprises an average length attribute.
7. The computer-implemented method of any of claims 1-6, wherein providing the transformed first data record comprises:
generating, by the computing system, one or more graphical user interfaces comprising representations of the transformed first data records; and
providing, by the computing system, the one or more graphical user interfaces to a client device.
8. The computer-implemented method of claim 7, further comprising:
receiving at least one feedback value from the client device indicating an extent to which the transformed first data record conforms to the second pattern; and
storing the at least one feedback value in a persistent storage.
9. The computer-implemented method of claim 8, further comprising:
updating, by the pattern matching engine, the rule set based on the at least one feedback value such that at least one rule suggests at least one pattern mapping technique that is different from a previously suggested pattern mapping technique.
10. A computer-implemented method as defined in claim 8 or claim 9, wherein the transformed first data record comprises a first plurality of transformed first data records and a second plurality of transformed first data records, wherein the at least one feedback value comprises a first feedback value that indicates a degree to which the first plurality of transformed first data records comply with the second pattern, and wherein the at least one feedback value comprises a second feedback value that indicates a degree to which the second plurality of transformed first data records comply with the second pattern.
11. The computer-implemented method of any of claims 1-10, wherein the first data record includes a first plurality of first data records and a second plurality of first data records, and wherein transforming the first data record according to the at least one selected schema mapping technique includes: the first plurality of first data records is transformed according to a first one of the at least one selected schema mapping technique and the second plurality of first data records is transformed according to a second one of the at least one selected schema mapping technique.
12. The computer-implemented method of claim 11, wherein the second plurality of first data records are nested within the first plurality of first data records.
13. The computer-implemented method of any of claims 1-12, wherein the predefined schema attributes comprise domain attributes.
14. The computer-implemented method of any of claims 1-13, wherein the predefined schema attributes include a schema type attribute.
15. The computer-implemented method of any of claims 1-14, wherein the plurality of schema mapping techniques includes a string similarity mapping technique.
16. The computer-implemented method of any of claims 1-15, wherein the plurality of mode mapping techniques includes a value distribution mapping technique.
17. The computer-implemented method of any of claims 1-16, further comprising:
obtaining, by the parser, a third schema and a third data record constructed according to the third schema;
determining, by the parser and for the third schema, one or more third schema attribute values for each schema attribute in the predefined schema attribute set;
determining, by the parser and for a fourth schema, one or more fourth schema attribute values for each schema attribute in the predefined schema attribute set;
providing, by the parser, a third schema attribute value and a fourth schema attribute value for each schema attribute in the predefined set of schema attributes to the schema matching engine;
determining, by the pattern matching engine: (i) the third schema attribute value is similar to the first schema attribute value; and (ii) the fourth schema attribute value is similar to the second schema attribute value;
transforming, by the pattern matching engine, the third data record according to the at least one selected pattern mapping technique; and
providing, by the computing system, a transformed third data record of the data structure according to the fourth schema.
18. A computing system, comprising:
a resolver;
a pattern matching engine comprising: (i) a plurality of schema mapping techniques for transforming a record from an initial schema to a target schema, and (ii) a set of rules, wherein each rule suggests at least one schema mapping technique from the plurality of schema mapping techniques based on at least one schema attribute from a predefined set of schema attributes; and
one or more processors configured to cause the computing system to perform operations comprising:
obtaining, by the parser, a first schema and a first data record constructed according to the first schema;
determining, by the parser and for the first schema, one or more first schema attribute values for each schema attribute in a predefined schema attribute set;
determining, by the parser and for a second schema, one or more second schema attribute values for each schema attribute in the predefined schema attribute set;
providing, by the parser, a first schema attribute value and a second schema attribute value for each schema attribute in the predefined set of schema attributes to the schema matching engine;
applying, by the pattern matching engine, the set of rules to the first pattern attribute value and the second pattern attribute value to select at least one pattern mapping technique from the plurality of pattern mapping techniques;
transforming, by the pattern matching engine, the first data record according to at least one selected pattern mapping technique; and
providing, by the computing system, the transformed first data record.
19. The computing system of claim 18, wherein the operations further comprise:
receiving, by the parser, a representative second data record constructed according to the second schema;
determining, by the parser and for the first data record, one or more first record attribute values for each record attribute in a predefined set of record attributes;
determining, by the parser and for the second data record, one or more second record attribute values for each record attribute in a predefined set of record attributes;
providing, by the parser, a first record attribute value and a second record attribute value for each record attribute in the predefined set of record attributes to the pattern matching engine, wherein the pattern matching engine further contains a second set of rules, wherein each second rule suggests at least one pattern mapping technique from the plurality of pattern mapping techniques based on at least one record attribute from the predefined set of record attributes; and
applying, by the pattern matching engine, the second set of rules to the first record attribute values and the second record attribute values to select the at least one pattern mapping technique.
20. An article of manufacture comprising a non-transitory computer-readable medium having program instructions stored thereon that, when executed by one or more processors of a computing system, cause the computing system to perform operations comprising:
obtaining, by a parser running on the computing system, a first schema and a first data record constructed according to the first schema;
determining, by the parser and for the first schema, one or more first schema attribute values for each schema attribute in a predefined schema attribute set;
determining, by the parser and for a second schema, one or more second schema attribute values for each schema attribute in the predefined schema attribute set;
providing, by the parser, a first schema attribute value and a second schema attribute value for each schema attribute in the predefined set of schema attributes to a schema matching engine running on the computing system, wherein the schema matching engine comprises: (i) a plurality of schema mapping techniques for transforming a record from an initial schema to a target schema, and (ii) a set of rules, wherein each rule suggests at least one schema mapping technique from the plurality of schema mapping techniques based on at least one schema attribute from the set of predefined schema attributes;
applying, by the pattern matching engine, the set of rules to the first pattern attribute value and the second pattern attribute value to select at least one pattern mapping technique from the plurality of pattern mapping techniques;
transforming, by the pattern matching engine, the first data record according to at least one selected pattern mapping technique; and
providing, by the computing system, the transformed first data record.
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2019/060010 WO2021091550A1 (en) | 2019-11-06 | 2019-11-06 | Method and apparatus for smart and extensible schema matching framework |
Publications (1)
Publication Number | Publication Date |
---|---|
CN114846459A true CN114846459A (en) | 2022-08-02 |
Family
ID=69165510
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201980103019.XA Pending CN114846459A (en) | 2019-11-06 | 2019-11-06 | Method and apparatus for an intelligent and extensible pattern matching framework |
Country Status (4)
Country | Link |
---|---|
US (1) | US20220374399A1 (en) |
EP (1) | EP4035025A1 (en) |
CN (1) | CN114846459A (en) |
WO (1) | WO2021091550A1 (en) |
Families Citing this family (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20230342342A1 (en) * | 2022-04-26 | 2023-10-26 | Meta Platforms, Inc. | Methods, Apparatuses and Computer Program Products for Stable Identifier Assignment for Evolving Data Structures |
Family Cites Families (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6826568B2 (en) * | 2001-12-20 | 2004-11-30 | Microsoft Corporation | Methods and system for model matching |
US9430114B1 (en) * | 2011-11-03 | 2016-08-30 | Pervasive Software | Data transformation system, graphical mapping tool, and method for creating a schema map |
US9588956B2 (en) * | 2013-07-12 | 2017-03-07 | Ab Initio Technology Llc | Parser generation |
US9582556B2 (en) * | 2013-10-03 | 2017-02-28 | International Business Machines Corporation | Automatic generation of an extract, transform, load (ETL) job |
US11138220B2 (en) * | 2016-11-27 | 2021-10-05 | Amazon Technologies, Inc. | Generating data transformation workflows |
US10691652B2 (en) * | 2018-03-29 | 2020-06-23 | International Business Machines Corporation | Similarity-based clustering search engine |
-
2019
- 2019-11-06 EP EP19836658.5A patent/EP4035025A1/en active Pending
- 2019-11-06 WO PCT/US2019/060010 patent/WO2021091550A1/en unknown
- 2019-11-06 US US17/771,182 patent/US20220374399A1/en active Pending
- 2019-11-06 CN CN201980103019.XA patent/CN114846459A/en active Pending
Also Published As
Publication number | Publication date |
---|---|
WO2021091550A1 (en) | 2021-05-14 |
US20220374399A1 (en) | 2022-11-24 |
EP4035025A1 (en) | 2022-08-03 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10169337B2 (en) | Converting data into natural language form | |
US20210165955A1 (en) | Methods and systems for modeling complex taxonomies with natural language understanding | |
US11886998B2 (en) | Attention-based decoder-only sequence transduction neural networks | |
AU2015347304B2 (en) | Testing insecure computing environments using random data sets generated from characterizations of real data sets | |
US20180025092A1 (en) | Modular memoization, tracking and train-data management of feature extraction | |
WO2014093248A2 (en) | Query and index over documents | |
JP2011258184A (en) | Graphical model for representing text document for computer analysis | |
US10628403B2 (en) | Annotation system for extracting attributes from electronic data structures | |
US20220229984A1 (en) | Systems and methods for semi-supervised extraction of text classification information | |
CN109471889B (en) | Report accelerating method, system, computer equipment and storage medium | |
CN113505128A (en) | Method, device and equipment for creating data table and storage medium | |
US20220121679A1 (en) | Structure-based transformers with localization and encoding for chart question answering | |
US20230004598A1 (en) | Storing semi-structured data | |
CN113656547B (en) | Text matching method, device, equipment and storage medium | |
US11074276B2 (en) | Methods and systems for optimized visual summarization for sequences of temporal event data | |
CN106056425B (en) | Order data processing method and processing unit | |
CN115358397A (en) | Parallel graph rule mining method and device based on data sampling | |
CN114846459A (en) | Method and apparatus for an intelligent and extensible pattern matching framework | |
US11574020B1 (en) | Identifying similar content in a multi-item embedding space | |
JP6775366B2 (en) | Selection device and selection method | |
AU2015204339A1 (en) | Information processing apparatus and information processing program | |
US10963429B2 (en) | Method and system for content agnostic file indexing | |
US9256644B1 (en) | System for identifying and investigating shared and derived content | |
US11755671B2 (en) | Projecting queries into a content item embedding space | |
US11550777B2 (en) | Determining metadata of a dataset |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |