US6915307B1 - High performance object cache - Google Patents
High performance object cache Download PDFInfo
- Publication number
- US6915307B1 US6915307B1 US10/140,497 US14049702A US6915307B1 US 6915307 B1 US6915307 B1 US 6915307B1 US 14049702 A US14049702 A US 14049702A US 6915307 B1 US6915307 B1 US 6915307B1
- Authority
- US
- United States
- Prior art keywords
- value
- key
- cache
- data
- subkey
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/10—File systems; File servers
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99941—Database schema or data structure
- Y10S707/99943—Generating database or data structure, e.g. via user interface
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99941—Database schema or data structure
- Y10S707/99944—Object-oriented database structure
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99941—Database schema or data structure
- Y10S707/99944—Object-oriented database structure
- Y10S707/99945—Object-oriented database structure processing
Definitions
- the present invention relates to information delivery, and relates more specifically to a cache for information objects that are to be delivered efficiently and at high speed over a network to a client
- one or more servers are used to store information.
- Client computers or processes are separated from the servers and are connected to the servers using a network.
- the clients request information from one of the servers by providing a network address of the information.
- the server locates the information based on the provided network address and transmits it over the network to the client, completing the transaction.
- FIG. 1 is a simplified block diagram of the relationship between elements used in a Web system.
- One or more web clients 10 a , 10 b are connected to a global information network 20 called the Internet, either directly or through an intermediary such as an Internet Service Provider, or an online information service.
- a web server 40 is likewise connected to the Internet 20 by a network link 42 .
- the web server 40 has one or more internet network addresses and textual host names, associated in an agreed-upon format that is indexed at a central Domain Name Server (DNS).
- DNS Central Domain Name Server
- the server contains multimedia information resources, such as documents and images, to be provided to clients upon demand.
- the server 40 may additionally or alternatively contain software for dynamically generating such resources in response to requests.
- the clients 10 a , 10 b and server 40 communicate using one or more agreed-upon protocols that specify the format of the information that is communicated.
- a client 10 a looks up network address of a particular server using DNS and establishes a connection to the server using a communication protocol called the Hypertext Transfer Protocol (HTTP).
- HTTP Hypertext Transfer Protocol
- a Uniform Resource Locator (URL) uniquely identifies each information object stored on or dynamically generated by the server 40 .
- a URL is a form of network address that identifies the location of information stored in a network.
- a key factor that limits the performance of the World Wide Web is the speed with which the server 40 can supply information to a client via the Internet 20 .
- Performance is limited by the speed, reliability, and congestion level of the network route through the Internet, by geographical distance delays, and by server load level. Accordingly, client transaction time can be reduced by storing replicas of popular information objects in repositories geographically dispersed from the server.
- Each local repository for object replicas is generally referred to as a cache.
- a client may be able to access replicas from a topologically proximate cache faster than possible from the original web server, while at the same time reducing Internet server traffic.
- the cache is located in a proxy server 30 that is logically interposed between the clients 10 a , 10 b and the server 40 .
- the proxy server provides a “middleman” gateway service, acting as a server to the client, and a client to the server.
- a proxy server equipped with a cache is called a caching proxy server, or commonly, a “proxy cache”.
- the proxy cache 30 intercepts requests for resources that are directed from the clients 10 a , 10 b to the server 40 .
- the proxy responds to the clients 10 a , 10 b and serves the resource directly.
- the number and volume of data transfers along the link 42 are greatly reduced. As a result, network resources or objects are provided more rapidly to the clients 10 a , 10 b.
- a key problem in such caching is the efficient storage, location, and retrieval of objects in the cache.
- This document concerns technology related to the storage, location, and retrieval of multimedia objects within a cache.
- the object storage facility within a cache is called a “cache object store” or “object store”.
- a cache object store needs to be able to handle tens or hundreds of millions of different objects, while storing, deleting, and fetching the objects simultaneously. Accordingly, cache performance must not degrade significantly with object count. Performance is the driving goal of cache object stores.
- Finding an object in the cache is the most common operation and therefore the cache must be extremely fast in carrying out searches.
- the key factor that limits cache performance is lookup time. It is desirable to have a cache that can determine whether an object is in the cache (a “hit”) or not (a “miss”) as fast as possible.
- caches capable of storing millions of objects have been stored in traditional file system storage structures.
- Traditional file systems are poorly suited for multimedia object caches because they are tuned for particular object sizes and require multiple disk head movements to examine file system metadata.
- Object stores can obtain higher lookup performance by dedicating DRAM memory to the task of object lookup, but because there are tens or hundreds of millions of objects, the memory lookup tables must be very compact.
- Disk performance is typically constrained by the drive's rated seeks per second. To optimize performance of a cache, it is desirable to minimize disk seeks, by reading and writing contiguous blocks of data.
- Garbage collection must be efficient enough that it can run continually without providing a significant decrease in system performance, while removing objects that have the least impact on future cache performance.
- the native file system approach uses the file system of an operating system running on the server to create and manage a cache.
- File systems are designed for a particular application in mind: storing and retrieving user and system data files.
- File systems are designed and optimized for file management applications. They are optimized for typical data file sizes and for a relatively small number of files (both total and within one folder/directory).
- Traditional file systems are not optimized to minimize the number of seeks to open, read/write, and close files.
- Many file systems incur significant performance penalties to locate and open files when there are large numbers of files present.
- Typical file systems suffer fragmentation, with small disk blocks scattered around the drive surface, increasing the number of disk seeks required to access data, and wasting storage space.
- file systems being designed for user data file management, include facilities irrelevant to cache object stores, and indeed counter-productive to this application. Examples include: support for random access and selective modification, file permissions, support for moving files, support for renaming files, and support for appending to files over time. File systems are also invest significant energy to minimize any data loss, at the expense of performance, both at write time, and to reconstruct the file system after failure. The result is that file systems are relatively poorly for handling the millions of files that can be present in a cache of Web objects. File systems don't efficiently support the large variation in Internet multimedia object size—in particular they typically do not support very small objects or very large objects efficiently. File systems require a large number of disk seeks for metadata traversal and block chaining, poorly support garbage collection, and take time to ensure data integrity and to repair file systems on restart.
- the page cache extends file systems with a set of fixed sized memory buffers. Data is staged in and out of these buffers before transmission across the network. This approach wastes significant memory for large objects being sent across slow connections.
- the database system approach uses a database system as a cache.
- databases are structured to achieve goals that make them inappropriate for use as an object cache. For example, they are structured to optimize transaction processing. To preserve the integrity of each transaction, they use extensive locking. As a result, as a design goal they favor data integrity over performance factors such as speed. In contrast, it is acceptable for an object cache to lose data occasionally, provided that the cache does not corrupt objects, because the data always can be retrieved from the server that is original source of the data.
- Databases are often optimized for fast write performance, since write speed limits transaction processing speed. However, in an object cache, read speed is equally important. Further, databases are not naturally good at storing a vast variety of object sizes while supporting streaming, pipelined I/O in a virtual memory efficient manner. Databases commonly optimized for fixed record size sizes. Where databases support variable record sizes, they contain support for maintaining object relationships that are redundant, and typically employ slow, virtual memory paging techniques to support streaming, pipelined I/O.
- This document concerns technology directed to accomplishing the foregoing goals.
- this document describes methods and structures related to the time-efficient and space-efficient storage, retrieval, and maintenance of objects in a large object store.
- the technology described herein provides for a cache object store for a high-performance, high-load application having the following general characteristics:
- each key value may contain a first subkey value and a second subkey value.
- a mapping associates the first subkey values with storage locations.
- a particular first subkey value is mapped to storage location that contains second subkeys of a set of key values that correspond to the first subkey value.
- the storage location also includes additional information that may be used to locate objects associated with the set of key values.
- the invention also encompasses an apparatus, computer system, computer program product, and a computer data signal embodied in a carrier wave configured according to the foregoing aspects, and other aspects.
- FIG. 1 is a block diagram of a client/server relationship
- FIG. 2 is a block diagram of a traffic server
- FIG. 3A is a block diagram of transformation of an object into a key
- FIG. 3B is a block diagram of transformation of an object name into a key
- FIG. 4A is a block diagram of a cache
- FIG. 4B is a block diagram of a storage mechanism for Vectors of Alternates
- FIG. 4C is a block diagram of multi-segment directory table
- FIG. 5 is a block diagram of pointers relating to data fragments
- FIG. 6 is a block diagram of a storage device and its contents
- FIG. 7 is a block diagram showing the structure of a pool
- FIG. 8A is a flow diagram of a process of garbage collection
- FIG. 8B is a flow diagram of a process of writing information in a storage device
- FIG. 8C is a flow diagram of a process of synchronization
- FIG. 8D is a flow diagram of a “checkout_read” process
- FIG. 8E is a flow diagram of a “checkout_write” process
- FIG. 8F is a flow diagram of a “checkout_create” process
- FIG. 9A is a flow diagram of a cache lookup process
- FIG. 9B is a flow diagram of a “checkin” process
- FIG. 9C is a flow diagram of a cache lookup process
- FIG. 9D is a flow diagram of a cache remove process
- FIG. 9E is a flow diagram of a cache read process
- FIG. 9F is a flow diagram of a cache write process
- FIG. 9G is a flow diagram of a cache update process
- FIG. 10A is a flow diagram of a process of allocating and writing objects in a storage device
- FIG. 10B is a flow diagram of a process of scaled counter updating
- FIG. 11 is a block diagram of a computer system that can be used to implement the present invention.
- FIG. 12 is a flow diagram of a process of object re-validation.
- FIG. 2 is a block diagram of the general structure of certain elements of a proxy 30 .
- the proxy 30 is called a traffic server and comprises one or more computer programs or processes that operate on a computer workstation of the type described further below.
- a client 10 a directs a request 50 for an object to the proxy 30 via the Internet 20 .
- object means a network resource or any discrete element of information that is delivered from a server. Examples of objects include Web pages or documents, graphic images, files, text documents, and objects created by Web application programs during execution of the programs, or other elements stored on a server that is accessible through the Internet 20 .
- the client 10 a is connected to the proxy 30 through a network other than the Internet.
- the incoming request 50 arrives at an input/output (I/O) core 60 of the proxy 30 .
- the I/O core 60 functions to adjust the rate of data received or delivered by the proxy to match the data transmission speed of the link between the client 10 a and the Internet 20 .
- the I/O core 60 is implemented in the form of a circularly arranged set of buckets that are disposed between input buffers and output buffers that are coupled to the proxy 30 and the Internet 20 . Connections among the proxy 30 and one or more clients 10 a are stored in the buckets. Each bucket in the set is successively examined, and each connection in the bucket is polled. During polling, the amount of information that has accumulated in a buffer associated with the connection since the last poll is determined.
- a period value associated with the connection is adjusted.
- the connection is then stored in a different bucket that is generally identified by the sum of the current bucket number and the period value. Polling continues with the next connection and the next bucket. In this way, the elapsed time between successive polls of a connection automatically adjusts to the actual operating bandwidth or data communication speed of the connection.
- the I/O core 60 passes the request 50 to a protocol engine 70 that is coupled to the I/O core 60 and to a cache 80 .
- the protocol engine 70 functions to parse the request 50 and determine what type of substantive action is embodied in the request 50 . Based on information in the request 50 , the protocol engine 70 provides a command to the cache 80 to carry out a particular operation.
- the cache 80 is implemented in one or more computer programs that are accessible to the protocol engine 70 using an application programming interface (API).
- API application programming interface
- the protocol engine decodes the request 50 and performs a function call to the API of the cache 80 .
- the function call includes, as parameter values, information derived from the request 50 .
- the cache 80 is coupled to send and receive information to and from the protocol engine 70 and to interact with one or more non-volatile mass storage devices 90 a - 90 n .
- the storage devices 90 a - 90 n are high-capacity, fast disk drives.
- the cache 80 also interacts with data tables 82 that are described in more detail herein.
- the cache 80 stores objects on the storage devices 90 a - 90 n .
- Popular objects are also replicated into a cache.
- the cache has finite size, and is stored in main memory or RAM of the proxy 30 .
- Objects on disk are indexed by fixed sized locators, called keys. Keys are used to index into directories that point to the location of objects on disk, and to metadata about the objects. There are two types of keys, called “name keys” and “object keys”. Name keys are used to index metadata about a named object, and object keys are used to index true object content. Name keys are used to convert URLs and other information resource names into a metadata structure that contains object keys for the object data. As will be discussed subsequently, this two-level indexing structure facilitates the ability to associate multiple alternate objects with a single name, while at the same time maintaining a single copy of any object content on disk, shared between multiple different names or alternates.
- embodiments of the invention use a “fingerprint” of the content that makes up the object itself, to locate the object.
- Keys generated from the content of the indexed object are referred to herein as object keys.
- the object key 56 is a unique fingerprint or compressed representation of the contents of the object 52 .
- a copy of the object 52 is provided as input to a hash function 54 , and its output is the object key 56 .
- a file or other representation of the object 52 is provided as input to the hash function, which reads each byte of the file and generates a portion of the object key 56 , until the entire file has been read.
- an object key 56 is generated based upon the entire contents of the object 52 rather than its name. Since the keys are content-based, and serve as indexes into tables of the cache 80 , the cache is referred to as a content-indexed cache. Given a content fingerprint key, the content can easily be found.
- content indexing enables the cache 80 to detect duplicate objects that have different names but the same content. Such duplicates will be detected because objects having identical content will hash to the same key value even if the objects have different names.
- the server 40 is storing, in one subdirectory, a software program comprising an executable file that is 10 megabytes in size, named “IE4.exe”. Assume further that the server 40 is storing, in a different subdirectory, a copy of the same file, named “Internet Explorer.exe”.
- the server 40 is an anonymous FTP server that can deliver copies of the files over an HTTP connection using the FTP protocol.
- the cache stores a copy of each of the files in cache storage, and indexes each of the files under its name in the cache. As a result, the cache must use 20 megabytes of storage for two objects that are identical except for the name.
- the cache creates a name key and an object key.
- the name keys are created by applying a hash function to the name of the object.
- the object keys are created by applying a hash function to the content of the object.
- the cache detects the prior identical object key entry, and does not store a duplicate object key entry; instead, the cache stores a reference to the same object key entry in association with the name key, and deletes the new, redundant object. As a result, only 10 megabytes of object storage is required. Thus, the cache detects duplicate objects that have different names, and stores only one permanent copy of each such object.
- FIG. 3A is a block diagram of mechanisms used to generate an object key 56 for an object 52 .
- client 10 a requests an object 52 , and the object is not found in the cache 80 using the processes described herein, the cache retrieves the object from a server and generates a object key 56 for storing the object in the cache.
- Directories are the data structures that map keys to locations on disk. It is advisable to keep all or most of the contents of the directories in memory to provide for fast lookups. This requires directory entries to be small, permitting a large number of entries in a feasible amount of memory. Further, because 50% of the accesses are expected not to be stored in cache, we want to determine cache misses quickly, without expending precious disk seeks. Such fast miss optimizations dedicate scarce disk head movements to real data transfers, not unsuccessful speculative lookups. Finally, to make lookups fast via hashing search techniques, directory entries are fixed size.
- Keys are carefully structured to be fixed size and small, for the reasons described earlier. Furthermore, keys are partitioned into subkeys for the purposes of storage efficiency and fast lookups. Misses can be identified quickly by detecting differences in just a small portion of keys. For this reason, instead of searching a full directory table containing complete keys, misses are filtered quickly using a table of small subkeys called a “tag table”. Furthermore, statistical properties of large bit vectors can be exploited to create space-efficient keys that support large numbers of cache objects with small space requirements.
- the object key 56 comprises a set subkey 58 and a tag subkey 59 .
- the set subkey 58 and tag subkey 59 comprise a subset of the bits that make up the complete object key 56 .
- the subkeys 58 , 59 can be 16 bits, 27 bits, or any other portion of the complete key.
- the subkeys 58 , 59 are used in certain operations, which are described below, in which the subkeys yield results that are nearly as accurate as when the complete key is used. In this context, “accurate” means that use of the subkeys causes a hit in the cache to the correct object as often as when the complete key is used.
- This accuracy property is known as “smoothness” and is a characteristic of a certain preferred subset of hash functions.
- An example of a hash function suitable for use in an embodiment is the MD5 hash function, which is described in detail in B. Schneier, “Applied Cryptography” (New York: John Wiley & Sons, Inc., 2d ed. 1996), at pp. 429-431 and pp.436-441.
- the MD5 hash function generates a 128-bit key from an input data stream having an arbitrary length.
- the MD5 hash function and other one-way hash functions are used in the cryptography field to generate secure keys for messages or documents that are to be transmitted over secure channels.
- General hashing table construction and search techniques are described in detail in D. Knuth, “The Art of Computer Programming: Vol. 3, Sorting and Searching,” at 506-549 (Reading, Mass.: Addison-Wesley, 1973).
- requests for objects typically do not identify requested objects using the object keys for the objects. Rather, requests typically identify requested objects by name.
- the format of the name may vary from implementation to implementation based on the environment in which the cache is used.
- the object name may be a file system name, a network address, or a URL.
- the object key for a requested object is indexed under a “name key” that is generated based on the object name.
- a name key is used to locate the object key
- the object key is used to locate the object itself.
- FIG. 3B is a block diagram of mechanisms used to generate a name key 62 based on an object name 53 .
- the same hash function 54 that is used to generate object keys is used to generate name keys.
- the name keys will have the same length and smoothness characteristics of the object keys.
- the name key 62 comprises set and tag subkeys 64 , 66 .
- the subkeys 64 , 66 comprise a subset of the bits that make up the complete name key 62 .
- the first and second subkeys 64 , 66 can be 16 bits, 27 bits, or any other portion of the complete key.
- the cache 80 comprises certain data structures that are stored in the memory of a computer system or in its non-volatile storage devices, such as disks.
- FIG. 4 is a block diagram of the general structure of the cache 80 .
- the cache 80 generally comprises a Tag Table 102 , a Directory Table 110 , an Open Directory table 130 , and a set of pools 200 a through 200 n , coupled together using logical references as described further below.
- the Tag Table 102 and the Directory Table 110 are organized as set associative hash tables.
- the Tag Table 102 , the Directory Table 110 , and the Open Directory table 130 correspond to the tables 82 shown in FIG. 2 .
- the Tag Table 102 and Directory Table 110 operate in the same fashion when traversed based on a name key 62 .
- the Tag Table 102 is a set-associative array of sets 104 a , 104 b , through 104 n .
- the tag table is designed to be small enough to fit in main memory. Its purpose is to quickly detect misses, whereby using only a small subset of the bits in the key a determination can be made that the key is not stored in the cache.
- the designation 104 n is used to indicate that no particular number of sets is required in the Tag Table 102 . As shown in the case of set 104 n , each of the sets 104 a - 104 n comprises a plurality of blocks 106 .
- the object key 56 is 128 bits in length.
- the set subkey 58 is used to identify and select one of the sets 104 a - 104 n .
- the set subkey 58 is approximately 18 bits in length.
- the tag subkey 59 is used to reference one of the entries 106 within a selected set.
- the tag subkey 59 is approximately 16 bits in length, but may be as small as zero bits in cases in which there are many sets. In such cases, the tag table would be a bit vector.
- a remainder subkey 56 ′ consists of the remaining bits of the key 56 .
- the set subkey, tag subkey, and remainder subkey are sometimes abbreviated s, t, and r, respectively.
- each entry contains a relatively small amount of information enables the Tag Table to be stored in fast, volatile main memory such as RAM.
- main memory such as RAM
- the structure of the Tag Table 102 facilitates rapid operation of the cache.
- the blocks in the Directory Table 110 include much more information as described below, and consequently, portions of the Directory Table may reside on magnetic disk media as opposed to fast DRAM memory at any given time.
- the Directory Table 110 comprises a plurality of sets 110 a - 110 n .
- Each of the sets 110 a - 110 n has a fixed size, and each comprises a plurality of blocks 112 a - 112 n .
- each of the blocks 112 a - 112 n stores a third, remainder subkey value 116 , a disk location value 118 , and a size value 120 .
- the remainder subkey value 116 is a 27-bit portion of the 128-bit complete object key 56 , and the comprises bits of the complete object key 56 that are disjoint from the bits that comprise the set or tag subkeys 58 , 59 .
- the subkey values stored in the entry 106 of the Tag Table 102 matches or references one of the sets 110 a - 110 n , as indicated by the arrow in FIG. 4 that connects the entry 106 to the set 110 d .
- the set subkey value 1111 matches set 104 n of the Tag Table 102
- the tag subkey value 0000 matches entry 106 of set 104 n .
- the match of the tag subkey value 0000 indicates that there is a corresponding entry in set 110 d of the Directory Table 110 associated with the key prefix 11110000.
- the blocks within the selected set are searched linearly to find a block, such as block 112 a , that contains the remainder subkey value 116 that matches a corresponding portion of the object key 56 . If a match is found, then there is almost always a hit in the cache. There is a small possibility of a miss if the first, second and third subkeys don't comprise the entire key. If there is a hit, the referenced object is then located based on information contained in the block, retrieved from one of the cache storage devices 90 a - 90 n , and provided to the client 10 a , as described further below.
- each block within Directory Table 110 includes a full pointer to a disk location.
- the item referenced by the disk location value 118 varies depending on the source from which the key was produced. If the key was produced based on the content of an object, as described above, then the disk location value 118 indicates the location of a stored object 124 (or a first fragment thereof), as shown in FIG. 4 in the case of block 112 b .
- the disk location value 118 indicates the location of one or more Vectors of Alternates 122 , each of which stores one or more object keys for the object whose name was used to generate the name key.
- a single Tag Table 102 and a single Directory Table 110 are shown in FIG. 4 merely by way of example. However, additional tables that provide additional levels of storage and indexing may be employed in alternate embodiments.
- a hit or miss will occur in the Tag Table 102 very quickly. If there is a hit in the Tag Table 102 , then there is a very high probability that a corresponding entry will exist in the Directory Table 110 . The high probability results from the fact that a hit in the Tag Table 102 means that the cache holds an object whose full key shares X identical bits to the received key, where X is the number of bits of the concatenation of the set and tag subkeys 58 and 59 . Because misses can be identified quickly, the cache 80 operates rapidly and efficiently, because hits and misses are detected quickly using the Tag Table 102 in memory without requiring the entire Directory Table 110 to reside in main memory.
- the set subkey 58 is used to index one of the sets 104 a - 104 n in Tag Table 102 . Once the set associated with subkey 58 is identified, a linear search is performed through the elements in the set to identify an entry whose tag matches the tag subkey 59 .
- a linear search of all the elements 106 in that set is carried out.
- the search seeks a match of the tag subkey 59 to one the entries. If a match is found, then there is a hit in the Tag Table 102 for the requested object, and the cache 80 proceeds to seek a hit in the Directory Table 110 .
- the object key is a 12-bit key having a value of 111100001010
- the set subkey comprises the first four bits of the object key having a value of 1111
- the tag subkey comprises the next four bits of the object key having a value of 0000.
- the cache identifies set 15 (1111) as the set to examine in the Tag Table 102 .
- the cache searches for an entry within that set that contains a tag 0000. If there is no such entry, then a miss occurs in the Tag Table 102 . If there is such an entry, then the cache proceeds to check the remaining bits in Directory Table 110 for a match.
- the Directory Table 110 contains multiple sets each composed of a fixed number of elements. Each element contains the remainder tag and a disk pointer. Large caches will contain large numbers of objects, which will require large numbers of elements in the directory table. This can create tables too large to be cost-effectively stored in main memory. For example, if a cache was configured with 128 million directory table elements, and each element was represented by a modest 8 bytes of storage, 1 GByte of memory would be requires to store the directory table, which is more memory than is common on contemporary workstation computers. Because few of these objects will be actively accessed at any time, there is a desire to migrate the underutilized entries onto disk while leaving higher utilized entries in main memory.
- FIG. 4C is a diagram of a multi-level directory mechanism.
- the directory table 110 is partitioned into segments 111 a , 111 b , 111 c .
- there are two or three segments 111 a - 111 c although a larger number of segments may be used.
- the first segment 111 a is the smallest, and fits in main memory such as the main memory 1106 of the computer system shown in FIG. 11 and discussed in detail below.
- the second and third segments 111 b , 111 c are progressively larger.
- the second and third segments 111 b , 111 c are coupled through a paging mechanism to a mass storage device 1110 such as a disk.
- the second and third segments 111 b , 111 c dynamically page data in from the disk if requested data is not present in the main memory 1106 .
- the Directory Table 110 is implemented as a multi-level hash table. Portions of the Directory Table may reside out of main memory, on disk. Data for the Directory Table is paged in and out of disk on demand. A preferred embodiment of this mechanism uses direct disk I/O to carefully control the timing of paging to and from disk and the amount of information that is paged.
- the cache maps the Directory Table into virtual memory using the UNIX mmap( ) facility.
- a mmap request is provided to the operating system, with a pointer to a file or disk location as a parameter.
- the mmap request operates as a request to map the referenced file or disk location to a memory location. Thereafter, the operating system automatically loads portions of the referenced file or disk location from disk into memory as necessary.
- the Directory Table and Open Directory are stored using a “striping” technique.
- Each set of the tables is stored on a different physical disk drive.
- set 110 a of Directory Table 110 is stored on storage device 90 a
- set 110 b is stored on storage device 110 b
- the number of seek operations needed for a disk drive head to arrive at a set is reduced, thereby improving speed and efficiency of the cache.
- versions are selected as follows.
- the client 10 a establishes an HTTP connection to the server 40 through the Internet 20 .
- the client provides information about itself in an HTTP message that requests an object from the server.
- an HTTP request for an object contains header information that identifies the Web browser used by the client, the version of the browser, the language preferred by the client, and the type of media content preferred by the client.
- the server 40 receives the HTTP request, it extracts the header information, and selects a variant of the object 52 based upon the values of the header information.
- the selected alternate is returned to the client 10 a in a response message. This type of variant selection is promoted by the emerging HTTP/1.1 hypertext transfer protocol.
- each name key in the directory table 110 maps to one of the vectors of alternates 122 a - 122 n , which enable the cache 80 to select one version of an object from among a plurality of related versions.
- the object 52 may be a Web page and server 40 can store versions of the object in the English, French, and Japanese languages.
- Each Vector of Alternates 122 a - 122 n is a structure that stores a plurality of alternate records 123 a - 123 n .
- Each of the alternate records 123 a - 123 n is a structure that stores information that describes an alternative version of the requested object 52 .
- the information describes a particular browser version, a human language in which the object has been prepared, etc.
- the alternate records also each store a full object key that identifies an object that contains the alternative version.
- each of the alternate records 123 a - 123 n stores request information, response information, and an object key 56 .
- a cache composes explicit or implicit request context with the object name to reduce the number of elements in the vector.
- the User-Agent header of a Web client request (which indicates the particular browser application) may be concatenated with a web URL to form the name key.
- the number of alternates in each vector is reduced, at the cost of more entries in the directory table.
- the particular headers and implicit context concatenated with the information object name is configurable.
- These Vectors of Alternates 122 a - 122 n support the correct processing of HTTP/1.1 negotiated content.
- Request and response information contained in the headers of HTTP/1.1 messages is used to determine which of the alternate records 123 a - 123 n can be used to satisfy a particular request.
- the requests typically contain header information in addition to the name (or URL) of the desired object. As explained above, the name is used to locate the appropriate Vector of Alternates. Once the appropriate Vector of Alternates is found, the header information is used to select the appropriate alternate record for the request.
- the header information is received and analyzed.
- the cache 80 seeks to match values found in the header information with request information of one of the alternate records 123 a - 123 n .
- request information For example, when the cache 80 is used in the context of the World Wide Web, requests for objects are provided to a server containing the cache in the form of HTTP requests.
- the cache 80 examines information in an HTTP request to determine which of the alternate records 123 a - 123 n to use.
- the HTTP request might contain request information indicating that the requesting client 10 a is running the Netscape Navigator browser program, version 3.0, and prefers German text.
- the cache 80 searches the alternate records 123 a through 123 n for response information that matches the browser version and the client's locale from the request information. If a match is found, then the cache retrieves the object key from the matching alternate and uses the object key to retrieve the corresponding object from the cache.
- the cache optimizes the object chosen by matching the criteria specified in the client request.
- the client request may specify minimal acceptance criteria (e.g. the document must be a JPEG image, or the document must be Latin).
- the client request may also specify comparative weighting criteria for matches (e.g. will accept a GIF image with weight 0.5, but prefer a JPEG image at weight 0.75).
- the numeric weightings are accumulated across all constraint axes to create a final weighting that is optimized.
- the object key is used to retrieve the object in the manner described above. Specifically, a subkey portion of the object key is used to initiate another search of the Tag Table 102 and the Directory Table 110 , seeking a hit for the subkey value. If there is a hit in both the Tag and Directory Tables, then the block in the Directory Table arrived at using the subkey values will always reference a stored object (e.g. stored object 124 ). Thus, using the Vector of Alternates 122 , the cache 80 can handle requests for objects having multiple versions and deliver the correct version to the requesting client 10 a.
- the cache 80 includes any number of vectors and disk blocks, depending on the number of objects that are indexed and the number of alternative versions associated with the objects.
- FIG. 4B is a diagram showing a storage arrangement for exemplary Vectors of Alternates 122 a - 122 n .
- the system attempts to aggregate data object contiguously after the metadata. Because seeks are time-consuming but sequential reads are fast, performance is improved by consolidating data with metadata, and pre-fetching data after the metadata.
- each of the Vectors of Alternates 122 a - 122 n is stored in a location that is contiguous to the stored objects 124 a - 124 b that are associated with the alternate records 123 a - 123 n represented in the vector.
- a Vector of Alternates 122 a stores alternate records 123 a - 123 c .
- the alternate record 123 a stores request and response information indicating that a stored object 124 a associated with the alternate record is prepared in the English language.
- Another alternate record 123 b stores information indicating that its associated stored object 124 b is intended for use with the Microsoft Internet Explorer browser.
- the stored objects 124 a , 124 b referenced by the alternate records 123 a , 123 b are stored contiguously with the Vectors of alternates 122 a - 122 n.
- the Size value 120 within each alternate record indicates the total size in bytes of one of the associated Vectors of Alternates 122 a - 122 n and the stored object 124 .
- the cache 80 references a Vector of Alternates 122 a based on the disk location value 118 , the cache reads the number of bytes indicated by the Size value. For example, in the case of the Vectors of Alternates shown in FIG. 4B , the Size value would indicate the length of the Vector of Alternate 122 a plus the length of its associated stored object 124 a . Accordingly, by referencing the Size value, the cache 80 reads the vector as well as the stored object.
- the cache 80 “reads ahead” of the Vector of Alternates 122 and retrieves all of the objects 50 from the storage devices 90 a - 90 n .
- both the Vector of Alternates and the objects 50 are read from the storage device using a single seek operation by the storage device. Consequently, when there is a hit in the cache 80 , in the majority of cases (where there is a single alternate) the requested object 52 is retrieved from a storage device using a single seek.
- the Size value 120 indicates the size of the object as stored in the disk block. This value is used to facilitate single-seek retrieval of objects, as explained further herein.
- the cache 80 further comprises an Open Directory 130 .
- the Open Directory 130 stores a plurality of linked lists 132 a - 132 n , which are themselves composed of a plurality of list entries 131 a - 131 n .
- Each of the linked lists 132 a - 132 n is associated with one of the sets 110 a - 110 n in the Directory Table 110 .
- the Open Directory 130 is stored in volatile main memory.
- each list entry 131 a - 131 n of the Open Directory 130 stores an object key that facilitates associative lookup of an information object.
- each item within each linked list 132 a - 132 n stores a complete object key 56 for an object 52 .
- the Open Directory accounts for objects that are currently undergoing transactions, to provide mutual exclusion against conflicting operations. For example, the Open Directory is useful in safeguarding against overwriting or deleting an object that is currently being read.
- the Open Directory also buffers changes to the Directory Table 110 before they are given permanent effect in the Directory Table 110 .
- a synchronization operation is executed to move the changes reflected in the Open Directory 130 to the Directory Table 110 . This prevents corruption of the Directory Table 110 in the event of an unexpected system failure or crash.
- the Open Directory 130 when an object is requested from the cache 80 , the Open Directory 130 is consulted first; it is considered the most likely place to yield a hit, because it contains references to the most recently used information objects.
- the Open Directory in this form serves as a cache in main memory for popular data.
- Tag Table 102 and Directory Table 110 After the Open Directory 130 , Tag Table 102 and Directory Table 110 have been accessed to determine the location of a stored object 124 , the object must be read from storage and transmitted to the user that requested the object.
- certain data aggregation techniques are used when initially storing the data. When data is initially stored on disk according to the data aggregation techniques described herein, the efficiency of subsequent reads is improved greatly.
- FIG. 6 is a block diagram of a data storage arrangement for use with the cache 80 and the storage devices 90 a - 90 n .
- a storage device 90 a such as a disk drive, stores data in plurality of pools 200 a - 200 n .
- a pool is a segment or chunk of contiguous disk space, preferably up to 4 Gbytes in size. Pools can be allocated from pieces of files, or segments of raw disk partitions.
- Each pool such as pool 200 n , comprises a header 202 and a plurality of fixed size storage spaces referred to herein as “arenas” 204 a through 204 n .
- the size of the arenas is preferably configurable or changeable to enable optimization of performance of the cache 80 .
- each of the arenas 204 a - 204 n is a block approximately 512 Kbytes to 2 Mbytes in size.
- Data to be written to arenas is staged or temporarily stored or staged in a “write aggregation buffer” in memory.
- This buffer accumulates data, and when full, the buffer is written contiguously, in one seek, to an arena on disk.
- the write aggregation buffer improves the performance of writes, and permits sector alignment of data, so data items can be directly read from raw disk devices.
- the write aggregation buffer is large enough to hold the entire contents of an arena. Data is first staged and consolidated in the write aggregation buffer, before it is dropped into the (empty) arena on disk.
- the write aggregation buffer also contains a free top pointer that is used to allocate storage out of the aggregation buffer as it is filling, an identifier naming the arena it is covering, and a reference count for the number of active users of the arena.
- Each pool header 202 stores a Magic number, a Version No. value, a No. of Arenas value, and one or more arena headers 206 a - 206 n .
- the Magic number is used solely for internal consistency checks.
- the Version No. value stores a version number of the program or process that created the arenas 206 a - 206 n in the pool. It is used for consistency checks to ensure that the currently executing version of the cache 80 can properly read and write the arenas.
- the No. of Arenas value stores a count of the number of arenas that are contained within the pool.
- the pool header 202 For each of the arenas in the pool, the pool header 202 stores information in one of the arena headers 206 a - 206 n . Each arena header stores two one-bit values that indicate whether the corresponding arena is empty and whether the arena has become corrupted (e.g. due to physical disk surface damage, or application error).
- each arena comprises one or more data fragments 208 a - 208 n .
- Each fragment 208 a - 208 n comprises a fragment header 208 d and fragment data 208 e .
- the fragment data 208 e is the actual data for an object that is stored in the cache 80 .
- the data for an entire stored object may reside within a single fragment, or may be stored within multiple fragments that may reside in multiple arenas.
- the fragment header 208 d stores a Magic number value 206 c , a key value 206 a and a length value 206 b.
- the length value 206 b represents the length in bytes of the fragment, including both the fragment header 208 d and the fragment data 208 e .
- the key value 206 a is a copy of the object key, stored in its entirety, of the object whose data is in the fragment.
- the key value 206 c can be used to look up the directory block that points to the first fragment that holds data of the object whose data is contained in the fragment.
- the complete object key 56 is stored in association with the last fragment associated with a particular object.
- the object key 56 is computed incrementally as object data is read from the originating server 40 .
- the final value of the object key 56 cannot be known until the entire object 52 is read.
- the object key 56 is written at the end of the chain of fragments used to store the object, because the value of the key is not known until the last fragment is written, and because modifying existing data on disk is slow.
- the fragment header can store other metadata that describes the fragment or object.
- the write aggregation buffer contains a “free top pointer” 210 indicating the topmost free area of the buffer 204 a .
- the top pointer 210 identifies the current boundary between used and available space within the buffer 204 a .
- the top pointer 210 is stored to enable the cache 80 to determine where to write additional fragments in the buffer. Everything below (or, in FIG. 6 , to the left of) the top pointer 210 contains or has already been allocated to receive valid data.
- the area of the arena 204 a above the top pointer 210 (to the right in FIG. 6 ) is available for allocation for other information objects.
- each fragment includes a maximum of 32 kilobytes of data. Fragments start and end on standard 512-byte boundaries of the storage device 90 a . In the context of the World Wide Web, most objects are relatively small, generally less than 32K in size.
- Each arena may have one of two states at a given time: the empty state or the occupied state.
- the current state of an arena is reflected by the Empty value stored in each arena header 206 a - 206 n .
- the occupied state some portion of the arena is storing usable data.
- a list of all arenas that are currently empty or free is stored in memory.
- main memory of the workstation that runs the cache 80 stores an array of pointers to empty arenas.
- additional information can be stored in the header 206 a -n of each arena.
- the header may store values indicating the number of deleted information objects contained in the arena, and a timestamp indicating when garbage collection was carried out last on the arena.
- FIG. 7 is a block diagram relating to updating one of the arenas 204 a - 204 n of FIG. 6 .
- FIG. 7 shows an arena 204 a containing a first information object 208 b having a header 206 and data fragments 208 a - 208 c .
- Top pointer 210 points to the topmost active portion of the arena 204 a , which is the end of the data segment 208 c .
- the Directory Table is updated only after a complete information object has been written to an arena, including header and data, and only after the top pointer of the arena has been moved successfully. For example, a complete information object is written to the arena 204 a above the top pointer 210 , and the top pointer is moved to indicate the new top free location of the arena. Only then is the Directory Table updated.
- the delayed updating of the Directory Table is carried out to ensure that the Directory Table remains accurate even if a catastrophic system failure occurs during one of the other steps. For example, if a disk drive or other element of the system crashes before completion of one of the steps, no adverse effect occurs. In such a case, the arena 204 a will contain corrupt or incomplete data, but the cache 80 will effectively ignore such data because nothing in the Directory Table 110 , indexes or hash tables is referencing the corrupt data. In addition, using the Garbage Collection process described herein, the corrupt or incomplete data is eventually reclaimed.
- the directory table block 112 b that is arrived at based on the object key of object 52 includes a pointer directly to the fragment in which the object 52 is stored. This assumes that object 52 has been stored in a single fragment.
- fragments have a fixed maximum size (preferred value is 32 KB). Objects greater than 32 KB will be fragmented.
- the system must pre-reserve space in the write aggregation buffer for new objects. If the object store does not know the size of the incoming object, it may guess wrong. The server may also misrepresent the true (larger) size of the object. In both cases, the object store would create a chain of fragments to handle the overflow.
- FIG. 5 is a block diagram of a preferred structure for keeping track of related fragments.
- Block 141 a is the head of a chain of blocks that identify successive fragments that contain the object X.
- the chain is includes blocks 141 a , 141 b , 141 c , 141 d and 141 e , in that order, and is formed by pointers 128 a through 128 d.
- the head block 141 a comprises a subkey value 126 and a block pointer 128 a .
- the subkey value 126 is 96 bits in length and comprises a subset of the value of the object key 56 for object X.
- the value of the block pointer 128 a references the next block 141 b in the chain.
- Directory table block 141 b comprises a fragment pointer 130 a and a block pointer 128 b .
- the fragment pointer 130 a references a fragment 208 a that stores the first portion of the data for the object X.
- the block pointer 128 b of pointer block 141 b references the next pointer block 141 c in the chain.
- pointer block 141 c has a fragment pointer 130 b that references a fragment 208 b .
- the block pointer 128 c of pointer block 141 c references the next pointer block 141 d in the chain.
- pointer block 141 d has a fragment pointer 130 b that references a fragment 208 c.
- the object store needs a mechanism to chain fragments together.
- Traditional disk block chaining schemes require modifying pre-existing data on disk, to change the previous chain-link pointers to point the new next block values. Modification of pre-existing disk data is time-consuming and creates complexities relating to consistency in the face of unplanned process termination.
- the need to patch new fragment pointers into extant fragments is removed by using “iterative functional pointers”.
- Each fragment is assigned a key, and the key of the next fragment is assigned as a simple iterative function of the previous fragment's key. In this manner, fragments can be chained simply by defining the key of the next fragment, rather than by modifying the pointer of the previous fragment.
- the block pointer 128 a is computed by applying a function to the value of subkey 126 .
- the block pointer value 128 b is computed by applying a function to the value of the block pointer 128 a .
- the function used to compute the pointer values is not critical, and many different functions can be used.
- the only requirement is that the range of possible key values should be sufficiently large, and the iteration should be sufficiently selected, so that the chances of range collision or cyclic looping are small. In the very unlikely event of key collision, the object will be deleted from the cache.
- the last pointer block 141 d in the chain has a block pointer 128 d that points to a tail block 141 e .
- the tail block 141 e comprises a reference to the first block 141 a in the chain.
- the reference contained in the tail block 141 e a 96-bit subkey 132 of the object key of object X.
- the cache can use the 96-bit subkey 132 to locate the head block 128 a of the chain.
- the tail block 141 e and the looped pointer arrangement it provides, enables the cache 80 to locate all blocks in a chain, starting from any block in the chain.
- FIG. 5 Three fragments 208 a , 208 b , and 208 c are shown in FIG. 5 merely by way of example. In practice, an information object may occupy or reference any number of fragments, each of which would be identified by its own pointer block within the Directory Table 110 .
- the last fragment is read first to ensure that the content MD5 key stored there matches the directory key value. This test is done as a “sanity check” to ensure that the correct object has been located. If there is no match, a collision has occurred and an exception is raised.
- FIG. 10A is a flow diagram of a method of allocating space for objects newly entered into the cache and for writing such objects into the allocated space.
- the allocation and write method is generally indicated by reference numeral 640 .
- the steps shown in FIG. 10A are carried out when a miss has occurred in the Directory Table and Tag Table, for example, at step 898 of FIG. 8 F.
- an information object that has been requested by a client, but not found in the cache is looked up and retrieved from its original location.
- the origin is a server 40 , a cluster, or a disk.
- the method tests whether the object is of the type and size that can be stored in the cache, that is, whether it is “cacheable.”
- non-cacheable objects examples include Web pages that are dynamically generated by a server application, panes or portions of Web pages that are generated by client side applets, objects that are constructed based upon dynamic data taken from a database, and other non-static objects. Such objects cannot be stored in the cache because their form and contents changes each time that they are generated. If such objects were to be stored in the cache, they would be unreliable or incorrect in the event that underlying dynamic data were to change between cache accesses. The process determines whether the object is cacheable by examining information in the HTTP response from the server 40 or other source of the object.
- the method obtains the length of the object in bytes.
- the length of a Web page can be included in metadata that is carried in an HTTP transaction.
- the cache extracts the length of the information object from the response information in the HTTP message that contains the information object. If the length is not present, and estimate is generated. Estimates may be incorrect, and will lead to fragmented objects.
- block 648 space is allocated in a memory-resident write aggregation buffer, and the object to be written is streamed into the allocated buffer location.
- block 648 involves allocating space in a write aggregation buffer that has sufficient space and is available to hold the object.
- block 650 the cache tests whether the write aggregation buffer has remaining free space. If so, the allocation and write process is complete and the cache 80 can carry out other tasks. When the write aggregation buffer becomes full, then the test of block 650 is affirmative, and control is transferred to block 656 .
- the cache writes the aggregation buffer to the arena it is shadowing.
- the Directory is updated to reflect the location of the new information object.
- the foregoing sequence of steps is ordered in a way that ensures the integrity of information objects that are written to the cache.
- the Directory is updated only after a complete information object has been written to an arena, including header and data. For example, if a disk drive or other element of the system crashes before completion of step 652 or step 658 , no adverse effect occurs. In such a case, the arena will contain corrupt or incomplete data, but the cache will effectively ignore such data because nothing in the indexes or hash tables is referencing the corrupt data. In addition, using the garbage collection process described herein, the corrupt or incomplete data is eventually reclaimed.
- FIG. 8A is a flow diagram of a method of garbage collection that can be used with the cache 80 .
- FIG. 8B is a flow diagram of further steps in the method of FIG. 8A , and will be discussed in conjunction with FIG. 8 A.
- the garbage collection method is implemented as an independent process that runs in parallel with other processes that relate to the cache. This enables the garbage collection method to periodically clean up cache storage areas without interrupting or affecting the operation of the cache.
- “garbage collection” generally means a process of scanning target arenas, identifying active fragments or determining whether to delete fragments, writing the active fragments contiguously to new arenas, and updating the Directory Table to reference the new locations of the fragments.
- the method is of the “evacuation” type, in which old or unnecessary fragments are deleted and active fragments are written elsewhere, so that at the conclusion of garbage collection operations on a particular arena, the arena is empty.
- both the target arenas and the new arenas are stored and manipulated in volatile memory.
- garbage collection is complete, the changes carried out in garbage collection are written to corresponding arenas stored in non-volatile storage such as disk, in a process called synchronization.
- one of the pools 200 a - 200 n is selected for garbage collection operations.
- the cache stores or can access a value indicating the amount of disk space in a pool that is currently storing active data.
- the cache also stores constant “low water mark” and “high water mark” values, as indicated by block 803 .
- garbage collection is initiated and carried out repeatedly until the amount of active storage in the pool falls below the “low water mark” value.
- the “low water mark” value is selected to be greater than zero, and the “high water mark” value is chosen to be approximately 20% less than the total storage capacity of the pool. In this way, garbage collection is carried out at a time before the pool overflows or the capacity of the storage device 90 a is exceeded.
- one of the arenas is selected as a target for carrying out garbage collection.
- the arena is selected by a selection algorithm that considers various factors. As indicated by block 805 , the factors include, for example, whether the arena is the last arena accessed by the cache 80 , and the total number of accesses to the arena. In alternate embodiments, the factors may also include the number of information objects that have been deleted from each arena, how recently an arena has been used, how recently garbage collection was previously carried out on each arena, and whether an arena currently has read or write locks set on it. Once the arena is selected for garbage collection, all of the fragments inside the object are separately considered for garbage collection.
- one of the fragments within the selected arena is selected for garbage collection.
- the cache 80 takes into account several selection factors, as indicated by block 807 .
- the factors include: the time of the last access to the fragment; the number of hits that have occurred to an object that has data in the fragment; the time required to download data from the fragment to a client; and the size of the object of which the fragment is a part. Other factors are considered in alternate embodiments. Values for these factors are stored in a block 112 a - 112 n that is associated with the object for which the fragment stores data.
- block 808 the cache determines whether a fragment should be deleted. In the preferred embodiment, block 808 involves evaluation of certain performance factors and optimization considerations.
- Caches are used for two primary, and potentially conflicting, reasons.
- the first reason is improving client performance.
- To improve client performance it is desirable for a garbage collector to retain objects that minimize server download time. This tends to bias a garbage collector toward caching documents that have been received from slow external servers.
- the second reason is minimizing server network traffic. To minimize server traffic, it is desirable for a garbage collector to retain objects that are large. Often, these optimizations conflict.
- the garbage collector can estimate, for each object, how much server download time was avoided and how much server traffic was disabled, by serving the cached copy as opposed to fetching from the original server. This metric measures the inherent “value” of the cached object.
- the cache administrator then configures a parameter between 0 and 1, indicating the degree to which the cache should optimize for time savings or for traffic savings.
- the foregoing values are evaluated with respect to other objects in the arena, with respect to the amount of space the object is consuming, and with respect to objects recently subjected to garbage collection. Based on such evaluation, the cache 80 determines whether to delete the fragment, as shown in step 808 .
- step 812 it is deleted from the arena by marking it as deleted and overwriting the data in the fragment.
- the garbage collection process determines that one of the fragments is to be deleted, then the process deletes all fragments associated with the object. This may involve following a chain of fragments, of the type shown in FIG. 5 , to another arena or even another pool.
- step 810 the fragment is written to a new arena.
- FIG. 8B which is discussed below, shows preferred sub-steps involved in carrying out step 810 .
- step 814 the Directory Table 110 is updated to reflect the new location of the fragment.
- Step 814 involves using the value of the key 206 a in the fragment header 208 d associated with a fragment 208 n to be updated to look up a block 112 a - 112 n that is associated with the fragment.
- the disk location value 118 in the block is updated to reflect the new location of the fragment. If the fragment has been deleted, then any corresponding Directory Table entries are deleted.
- Step 816 indicates that the method is complete after the Directory Table 110 is updated. However, it should be understood that the steps of FIG. 8A are carried out for all pools, all arenas within each pool, and all fragments within each arena.
- FIG. 8B is a flow diagram of steps involved in carrying out step 810 , namely, writing a fragment that is to be preserved to a new arena.
- the process of writing evacuated fragments to new arenas is completely analogous to writing original fragments.
- the data is written into a write aggregation buffer, and dropped to disk arenas when full.
- step 590 the directory tables are updated to reflect the change in location of the fragment.
- step 590 involves writing update information in the Open Directory 130 rather than directly into the Directory Table 110 .
- the process can verify that the fragment data 208 e has been successfully written to one of the storage devices 90 a - 90 n , then the changes reflected in the Open Directory 130 are written into or synchronized with the Directory Table 110 .
- This process is used to ensure that the integrity of the Directory Table 110 is always preserved.
- buffered storage is used for the fragments; thus, when a fragment is updated or a new fragment is written, the fragment data is written to a buffer and then committed to a disk or other storage device at a future time.
- garbage collection it is possible that a fragment that has been moved to a new arena is not actually written on one of the storage devices when the garbage collection process is ready to update the Directory Table. Therefore, information about the change is stored in the Open Directory 130 until the change is committed to disk.
- step 592 the original arena is examined to test whether it has other fragments that might need to be reclaimed or moved to a new arena. If other objects are present, then control returns to step 806 of FIG. 8A , so that the next object can be processed. If no other objects are present in the current arena, then in step 594 , the top pointer of the current arena is reset.
- read and write operations carried out by the cache 80 and the garbage collection process are buffered in two ways.
- communications between the cache 80 and a client 10 a that is requesting an object from the browser are buffered through a flow-controlling, streaming, buffering data structure called a VConnection.
- the cache 80 is implemented in a set of computer programs prepared in an object-oriented programming language.
- the VConnection is an object declared by one of the programs, and the VConnection encapsulates a buffer in memory.
- the buffer is a FIFO buffer that is 32 Kbytes in size.
- the cache assigns the client to a VConnection.
- Data received from the client 10 a is passed to the cache 80 through the VConnection, and when the cache needs to send information to the client 10 a , the cache writes the information to the VConnection.
- the VConnection regulates the flow of data from the cache 80 to match the data transmission speed used by the client 10 a to communicate with the cache. In this way, use of the VConnection avoids an unnecessary waste of main memory storage. Such waste would arise if an object being sent to the client 10 a was copied to memory in its entirety, and then sent to the client; during transmission to a slow client, main memory would be tied up unnecessarily. Buffered I/O using these mechanisms tends to reduce the number of sequential read and write operations that are carried out on a disk.
- a synchronization process is carried out.
- the synchronization process commits changes reflected in the Open Directory 130 to the Directory Table 110 and to stable storage, such as non-volatile storage in one or more of the storage devices 90 a - 90 n .
- the goal is to maintain the consistency of the data on disk at all times. That is, at any given instant the state of the data structures on disk is 100% consistent and the cache can start up without requiring checking. This is accomplished through careful ordering of the writing and synchronization of data and meta-data to the disk.
- ‘data’ refers to the actual objects the cache is being asked to store. For instance, if the cache is storing an HTML document, the data is the document itself. ‘Meta-data’ refers to the additional information the cache needs to store in order to index the ‘data’ so that it can be found during a subsequent lookup( ) operation as well as the information it needs to allocate space for the ‘data’.
- the ‘meta-data’ is comprises the directory and the pool headers.
- the directory is the index the cache uses for associating a key (a name) with a particular location on disk (the data).
- the cache uses the pool headers to keep track of what disk space has been allocated within the cache.
- the cache uses two rules to maintain the consistency of the data structures on disk.
- the first rule is that meta-data is always written down after the data it points to.
- the rationale for the first rule is that the cache has no “permanent” knowledge of an object being in the cache until the meta-data is written. If the cache were to write down the meta-data before the data and then crash, the meta-data would associate an object name with invalid object data on disk. This is undesirable, since the cache would then have to use heuristics to try and determine which meta-data points to good data and which points to bad.
- the second rule is that a pool arena cannot be marked as empty in the pool header until all the directory meta-data that points to the arena has been deleted and written to disk. This is necessary so that a crash cannot cause an empty arena to exist for which directory meta-data points to it.
- the problem this can cause is that the empty arena can become filled with new data, since it is empty and therefore it is available for new data to be written into it.
- “old” directory meta-data points to the same location as the new data. It is possible for accesses to the old directory meta-data to return the new data instead of either returning the old data or failing.
- FIG. 8C is a flow diagram of a preferred synchronization method 820 that implements the foregoing two rules.
- an object is written to the cache.
- Block 822 involves the steps of block 824 and block 826 , namely, creating metadata in the Open Directory, and writing and syncing the object data to disk.
- blocks 828 through 820 ′ are carried out periodically. As indicated in block 828 , for each piece of meta-data in the open directory table, a determination is made whether the data that the metadata points to is already synchronized to disk, as shown in block 821 . If so, then in block 823 , the cache copies the metadata that points to the stable data from the Open Directory to the Directory Table. In block 825 , the changes are synchronized to disk.
- garbage collection is carried out on an arena.
- Block 827 may involve the steps shown in FIG. 8 A.
- garbage collection generally involves the steps shown in block 829 , block 831 , and block 820 ′.
- the cache deletes the directory metadata that points to the segment, and writes the directory metadata to disk.
- the pool header is modified in memory such that the arena is marked as empty.
- the pool header is written and synced to disk.
- the steps that involve writing information to disk preferably use a “flush” operation provided in the operating system of the workstation that is running the cache 80 .
- the “flush” operation writes any data in the buffers that are used to store object data to a non-volatile storage device 90 a - 90 c.
- the Directory Table is not updated with the changes in the Open Directory until the data that the changes describe is actually written to disk or other non-volatile storage. Also, the cache 80 postpones updating the arenas on disk until the changes undertaken by the garbage collection process are committed to disk. This ensures that the arenas continue to store valid data in the event that a system crash occurs before the Directory Table is updated from the Open Directory.
- the cache provides a way to re-validate old information objects in the cache so that they are not destroyed in the garbage collection process.
- FIG. 12 is a flow diagram of a preferred re-validation process.
- an external program or process delivers a request to the cache that asks whether a particular information object has been loaded by a client recently.
- the cache locates the information object in the cache.
- the cache reads a Read Counter value associated in the directory tables with the information object.
- the cache tests whether the Read Counter value is high.
- the cache If the Read Counter value is high, then the information object has been loaded recently. In that case, in block 1210 the cache sends a positive response message to the requesting process. Otherwise, as indicated in block 1212 , the information object has not been loaded recently. Accordingly, as shown in block 1214 , the cache sends a negative responsive message to the calling program or process.
- the cache updates an expiration date value stored in association with the information object to reflect the current date or time. By updating the expiration date, the cache ensures that the garbage collection process will not delete the object, because after the update it is not considered old. In this way, an old object is refreshed in the cache without retrieving the object from its origin, writing it in the cache, and deleting a stale copy of the object.
- FIG. 10B is a flow diagram of a method of scaled counter updating.
- the method of FIG. 10B is used to manage the Read Counter values that are stored in each block 112 a - 112 n of a set of the Directory Table, as shown in FIG. 3 A.
- the method of FIG. 10B is not limited to that context.
- the method of FIG. 10B is applicable to any application that involves management of each of a plurality of objects that has a counter, and in which it is desirable to track the most recently used or least recently used objects.
- a key advantage of the method of FIG. 10B in comparison to past approaches is that it enables large counter values to be tracked in a small storage area.
- each of the Read Counter values stored in blocks 112 a - 112 n is stored in three bit quantities.
- the Read Counter value of the block is incremented by one.
- the highest decimal number that can be represented by a three-bit quantity is 7. Accordingly, a Read Counter could overflow after being incremented seven times.
- the method of FIG. 10B is periodically executed.
- the EVENT column identifies successive events affecting a set of counter values, and briefly indicates the nature of the event.
- the COUNTERS heading indicates three counter values A, B, and C represented in separate columns. Each of the counter values A, B, C corresponds to a counter value that is stored in a different block 112 a - 112 n of the Directory Index 110 . Thus, each row of Table 1 indicates the contents of three counter values at successive snapshots in time.
- Event 1 of Table 1 represents an arbitrary starting point in time, in which the hash table entries containing the counter values A, B, C each have been accessed once. Accordingly, the value of each counter A, B, C is one.
- the cache has accessed the hash table entry that stores counter value A. Accordingly, counter A has been incremented and its value is 2; the other counters B, C are unchanged. Assume that several other hash table entry accesses then occur, each of which causes one of counters A, B, or C to be incremented. Thereafter, at event 3, the values of the counters A, B, C are 7, 3, and 1 respectively.
- counter A is storing the maximum value it can represent, binary 111 or decimal 7, and will overflow if an attempt is made to increment it to a value greater than 7.
- step 622 the value of all the counters is read.
- step 628 the method computes the value (maximum_value/2), truncating any remainder or decimal portion, and compares it to the sum of all the counters.
- the state of counters A, B, C after this step is shown by Event 4, “Decrement.” Note that counter C, which represents the least recently used hash table entry, has been decremented to zero. At this point, least recently used hash table entries can be reclaimed or eliminated by scanning the corresponding counter values and searching for zero values. The result of this step is indicated in Event 5 of Table 1, “Reclaim.”
- the values of counters A and B are unchanged, and the value of counter C is undefined because its corresponding hash table entry has been deleted from the hash table.
- the cache 80 is implemented in one or more computer programs that are accessible to external programs through an API that supports read and write operations.
- the read and write operations are carried out on the Open Directory 130 , which is the only structure of the cache 80 that is “visible” to external programs or processes.
- the read operation is invoked by an external program that wants to locate an object in the cache.
- the write operation is invoked by a program that wants to store an object in the cache.
- operations called lookup, remove, checkout, and checkin are supported.
- the lookup operation looks up an object in the Open Directory based upon a key.
- the remove operation removes an object from the Open Directory based upon a key.
- the checkout operation obtains a copy of a block from the Directory Table 110 in an orderly manner so as to ensure data consistency.
- the checkin operation returns a copy of a block (which may have been modified in other operations) to the Directory Table 110 .
- a single cache lookup operation combines aspects of these operations.
- FIG. 9A is a flow diagram of steps carried out in one embodiment of the LOOKUP operation, which is generally designated by reference numeral 902 .
- the LOOKUP operation is initiated by a command from the protocol engine 70 to the cache 80 when a request message from a client 10 a seeks to retrieve a particular object from the server 40 .
- the request message from the client 10 a identifies the requested object by its name.
- the name is a Uniform Resource Locator (URL).
- the cache 80 converts the name of the object to a key value. In the preferred embodiment, the conversion step is carried out as shown in FIG. 3 B.
- the object name 53 or URL is passed to a hash function, such as the MD5 one-way has function.
- the output of the hash function is an object name key 62 .
- the object name key 62 can be broken up into one or more subkey values 64 , 66 .
- step 906 the cache 80 looks up the request key value in the Open Directory 130 .
- the Open Directory is consulted first because it is expected to store the most recently requested objects and therefore is likely to contain the object in the client request.
- step 906 involves using one of the subkey values as a lookup key. For example, a 17-bit or 18-bit subkey value can be used for the lookup.
- step 908 the cache 80 tests whether the subkey value has been found in the Open Directory. If the subkey value has been found in the Open Directory, then in step 910 the cache 80 retrieves the object from one of the storage devices, and delivers the object to the client.
- the retrieval sub-step involves the sub-steps described above in connection with locating objects in pools, arenas, and fragments of non-volatile storage in the storage devices 90 a - 90 c .
- the delivery sub-step involves constructing an HTTP response to the client that includes data of the object, opening an HTTP connection to the client, and sending the HTTP request to the client.
- step 912 the cache 80 looks up the request subkey value in the Tag Table 102 .
- step 914 the cache 80 tests whether the subkey value was found in the Tag Table 102 . If no match was found, then in step 916 the cache 80 stores information about the fact that no match occurred, for later use as described below. The information can be a bit indicating that a miss in the Tag Table 102 occurred.
- step 918 the cache 80 looks up the subkey value in the Directory Table. If the test of step 914 was affirmative, then the cache 80 retrieves a subkey value matching the request subkey value from one of the entries 106 of the tag Table 102 . Its value is used as a key to look up the request key value in the Directory Table.
- step 920 the cache 80 tests whether the request key value was found in the Directory Table. If a hit occurs, and there was a miss in the Tag Table as indicated by the information stored in step 916 , then in step 922 the cache 80 updates the Open Directory with information related to the Directory Table hit. Control is then passed to step 910 in which the object is obtained and delivered to the client in the manner described above.
- step 924 the cache 80 obtains a copy of the requested object from the server that is its source. For example, in the Web context, the cache 80 opens an HTTP connection to the URL provided in the client's request, and downloads the object. The object is then provided to the client and stored in the cache for future reference.
- the LOOKUP operation is implemented as a method of an object in an object-oriented programming language that receives a key value as a parameter.
- FIG. 9E is a flow diagram of a preferred process of reading an object that is identified by an object name (such as a URL) from the cache.
- the process of FIG. 9E is called “open_read,” and represents the sole external interface of the cache 80 . It is advantageous, to ensure control and consistency of data in the cache, to enable external programs to access only operations that use or modify the Open Directory 130 .
- the process of FIG. 9E is implemented as a program or programmatic object that receives an object name, and information about the user's particular request, as input parameters.
- the read process returns a copy of an object associated with a key that is found in the cache using the lookup process.
- the read process, and other processes that are invoked or called by it are an alternative to the LOOKUP operation described above in connection with FIG. 9 A.
- step 964 the process checks out a Vector of Alternates so that alternates in the vector can be read.
- step 964 involves invoking the checkout_read process described herein in connection with FIG. 8D , providing a key derived from the object name as a parameter.
- Checking out a vector involves checking out a block from the Open Directory that has a pointer to the vector, and reaching the block from the cache.
- step 966 the process uses the request information to select one of the alternates from among the alternates in the vector. This selection is carried out in the manner described above in connection with the Vector of Alternates 122 . In an embodiment, the selection operation is carried out by another program or programmatic object that returns a success/failure indication depending upon whether a suitable alternate is located. If the selection is successful, then in step 968 the process checks the Vector of Alternates back in. In step 970 , the process reads the object that is pointed to by the selected alternate.
- step 964 or step 966 results in failure, then the requested document does not exist in the cache. Accordingly, in step 972 the process returns a “no document” error message to the calling program or process.
- FIG. 9F is a flow diagram of a process of writing an object into the cache.
- the write process preferably is implemented as an “open_write” method that is the sole interface of the cache 80 to external programs needing to store objects in the cache.
- the process of FIG. 9F is implemented as a program or method that receives an object name, request information, and response information as input parameters.
- the object name identifies an object to be written into the cache; in the preferred embodiment, the object name is a name key 62 derived from a URL using the mechanism shown in FIG. 3 B.
- the write process is initiated when a client 10 a has requested an object 52 from the cache 80 that is not found in the cache.
- the cache 80 opens an HTTP transaction with the server 40 that stores the object, and obtains a copy of the object from it.
- the request information that is provided to the cache write process is derived from the HTTP request that came from the client.
- the response information is derived from the response of the server 40 to the cache 80 that supplies the copy of the object.
- step 974 the process checks out a Vector of Alternates. This step involves computing a key value based upon the object name, looking up a set and a block in the Open Directory that map to the key value, and locating a Vector of Alternates, if any, that corresponds to the block. If no vector exists, as shown in step 984 , a new vector is created
- step 976 the process uses the request information to define a new alternate record 123 a - 123 n within the current alternate.
- the new alternate record references the location of the object, and contains a copy of the request information and the response information.
- the new alternate is added to the Vector of Alternates. Duplicate alternate records are permitted; the Vector of Alternates can contain more than one alternate record that contains the same request and response information. Testing existing alternate records to identify duplicates is considered unnecessary because only a small incremental amount of storage is occupied by duplicate alternate records.
- step 978 the modified vector is checked into the cache using the steps described above.
- step 980 the object is written to one of the data storage devices 90 a - 90 c in the manner described above, using the key value. If the key is found to be in use during step 980 , then the write operation fails. This avoids overwriting an object identified by a key that is being updated.
- FIG. 9G is a flow diagram of a cache update process.
- the update process is used to modify a Vector of Alternates to store different request information or response information.
- the update process is invoked by the protocol engine 70 when the cache 80 is currently storing an object 52 that matches a request from a client 10 a , but the protocol engine determines that the object has expired or is no longer valid. Under these circumstances, the protocol engine 70 opens an HTTP transaction to the server 40 that provided the original object 52 , and sends a message that asks the server whether the object has changed on the server. This process is called “revalidation” of the object 52 . If the server 40 responds in the negative, the server will provide a short HTTP message with a header indicating that no change has occurred, and providing new response information. In that case, the protocol engine 70 invokes the cache update process in order to move the new response information about the object 52 into the cache 80 .
- the server 40 If the server 40 responds affirmatively that the object 52 has changed since its expiration date or time in the cache 80 , then the update process is not invoked. Instead, the server 40 returns a copy of the updated object 52 along with a new expiration date and other response information. In that case, the protocol engine 70 invokes the cache write process and the create processes described above to add the new object 52 to the cache 80 .
- the update process receives input parameters including an object name, an “old” identifier, request information, and response information.
- the object name is a URL or a key derived from a URL.
- the request information and response information are derived from the client's HTTP request for the object 52 from the cache 80 , and from the response of the server 40 when the cache obtains an updated copy of the object from the cache.
- the “old” identifier is a value that uniquely identifies a pair of request information and response information.
- a cache miss causes the cache 80 to write a new object into the cache
- information from the client request is paired with response information from the server that provides a copy of the object.
- Each pair is given a unique identifier value.
- step 986 the process checks out a Vector of Alternates corresponding to the object name from the cache. Preferably, this is accomplished by invoking the checkout_write process described herein. This involves using the object name or URL to look up an object in the Open Directory, the Tag Table, and the Directory Index, so that a corresponding Vector of Alternates is obtained. If the checkout step fails, then in step 996 the process returns an appropriate error message.
- step 988 a copy or clone of the vector is created in main memory.
- a request/response identifier value is located within the vector by matching it to the Old Identifier value received as input to the process. The old identifier value is removed and a new identifier is written in its place. The new identifier uniquely identifies the new request and response information that is provided to the process as input.
- step 990 the new vector is written to one of the storage devices 90 a - 90 c , and in step 992 the new vector is checked in to the cache.
- FIG. 9C is a flow diagram of a preferred embodiment of a process of looking up information in the Open Directory 130 .
- the process of FIG. 9C is implemented as a program process or method that receives a subkey portion of a name key 62 as an input parameter.
- the protocol engine 70 receives an object name, such as a URL.
- a URL is provided in an HTTP request issued by a client to a server that is operating the cache.
- the protocol engine 70 applies a hash function to the object name.
- the hash function yields, as its result or output, a name key that identifies a set in the cache.
- step 948 the process attempts to check out one or more blocks that are identified by the subkey from the Directory Index.
- the block checkout step preferably involves invoking the checkout_read process described herein.
- step 950 the process returns an error message to the program or process that called it, indicating that a block matching the input subkey was not found in the cache. Control is passed to step 952 in which the process concludes.
- step 954 the block that was checked out is checked in again.
- step 956 the process returns a message to the calling program indicating that the requested block was found. Processing concludes at step 952 .
- a cache search operation involves calling more primitive processes that seek to check out a block identified by a key from the Open Directory. If the primitives do not find the block in the Open Directory, the Directory Index is searched.
- the data block is delivered to the client.
- the data block is delivered by opening an HTTP connection to the client and transmitting the data block to the client using an HTTP transaction. This step may involve buffering several data blocks before the transaction is opened.
- FIG. 9D is a flow diagram of a process of removing a block relating to an object from the cache.
- the cache remove process receives a key value as input.
- the process comprises steps 958 to 962 . These steps carry out operations that are substantially similar to the operations of steps 948 , 954 , and 952 of FIG. 9 C.
- step 960 the process sets the deletion flag, and checks the block in with the deletion flag set.
- the deletion flag As described herein in connection with the check-in process (steps 938 and 944 of FIG. 9 B), when the deletion flag is set, the block will be marked as deleted. Thereafter, the block is eventually removed from the Directory Index when the changes reflected in the Open Directory are synchronized to the Directory Index.
- FIG. 8D is a flow diagram of a checkout_read operation that is used in connection with the Directory Table 110 .
- the checkout_read operation is used to obtain a copy of a block from the Directory Table 110 that matches a particular key. Once the block is checked out from the Directory Table 110 , the block can be read and used by the process that checked it out, but by no other process. Thereafter, to make the block available to other processes, the block is checked back in.
- Complementary checkout check-in processes are used in order to ensure that only one process at a time can modify a Directory Table block, a mechanism that is essential to ensure that the Directory Table always stores accurate information about objects in the cache.
- the checkout and check-in processes is a primitive process that assists in searching the cache for a particular object.
- the checkout_read operation receives a key value as input.
- the input key value is a subkey portion of a name key 62 that corresponds to an object name.
- the object store will be modifying portions of memory and disk data structures, it needs to guarantee a brief period of mutual exclusion to a subset of the cache data structures in order to achieve consistent results.
- the cache data structures are partitioned into 256 virtual “slices”, selected by 8 bits of the key. Each slice has an associate mutex lock.
- the process seeks to obtain the lock for the input key. If a lock cannot be obtained, the process waits the brief time until it becomes available. A lock can be unavailable if another transaction is modifying the small about of memory state associated with a key that falls in the same slice.
- step 834 the process determines which set 110 a - 110 n of the Directory Table 110 corresponds to the key. The process then locates one of the block lists 132 a , 132 b of the Open Directory 130 that corresponds to the set of the Directory Table 110 , by associating the value of a subkey of the input key with one of the block lists.
- step 836 the process scans the blocks in the selected block list of the Open Directory 130 , seeking a match of the input key to a key stored in one of the blocks.
- step 838 the process tests whether the matching block is currently in the process of being created or destroyed by another process. If the matching block is currently in the process of being created or destroyed, then in step 840 an error message is returned to the protocol engine 70 indicating that the current block is not available.
- the process increments a read counter.
- the read counter is an internal variable, associated with the block, that indicates the number of processes or instances of programmatic objects that are reading the block. Such processes or objects are called “readers.”
- the process obtains a copy of the block, and returns it to the calling program or process.
- step 846 the process invokes a search of the Directory Table, seeking a match of the key to a set and block of the Directory Table using a process that is described further herein. If no match of the key is found in the search, then in step 848 the process returns an error message to the calling program or process, indicating that the requested object does not exist in the cache. Although the specific response to such a message is determined by the calling program or process, in the World Wide Web context, generally the proxy 30 contacts the server 40 that stores the object using an HTTP request, and obtains a copy of the requested object.
- step 850 a corresponding block is added to the Open Directory. This is carried out by creating a new Open Directory block in main memory; initializing the block by copying information from the corresponding Directory Index block; and adding a reference to the new block to the corresponding list of blocks 132 a , 132 b.
- FIG. 8E is a flow diagram of a checkout_write process or operation that is used in connection with the Open Directory 130 .
- the checkout_write operation is used to obtain a copy of a block from the Open Directory 130 that matches a key that is passed to the process, for the purpose of modifying or updating the contents of the block, or an object or vector that is associated with the block.
- checkout_write Once a block is checked out of the Open Directory 130 using checkout_write, other processes can modify the block or its associated object or vector. The block is then checked back in using the checkin process described herein. Using these operations, changes are stored in the Open Directory and then propagated to the Directory Table in an orderly manner.
- the checkout_write process receives a key value as input.
- the input key value is a subkey portion of a name key 62 that corresponds to an object name.
- the process seeks to obtain a lock on the designated key. If a lock cannot be obtained, the process waits until one is available.
- step 856 the process determines which set 110 a - 110 n of the Directory Table 110 corresponds to the key. The process then locates one of the block lists 132 a , 132 b of the Open Directory 130 that corresponds to the set of the Directory Table 110 . In step 858 , the process scans the blocks in the selected block list of the Open Directory 130 , seeking a match of the input key to a key stored in one of the blocks.
- step 864 the process tests whether the matching block is currently in the process of being created or destroyed by another process. If so, then in step 866 an error message is returned to the protocol engine 70 or cache 80 indicating that the current block is not available. If the matching block is not currently in the process of being created or destroyed, then the block can be used. Accordingly, in step 868 the process increments a write counter.
- the write counter is an internal variable, stored in association with the block, that indicates the number of processes or programmatic objects that are writing the block.
- step 870 the process obtains a copy of the block, returns it to the calling program or process, and also marks the copy as being modified. The marking ensures that any changes made to the block will be reflected in the Directory Index when the Open Directory is synchronized to the Directory Index.
- step 860 the process invokes a search of the Directory Index using a process that is described further herein. If no match is found in the search, then in step 862 the process returns an error message to the calling program or process, indicating that the requested object does not exist in the cache. In the World Wide Web context, typically the calling program would contact the originating server that stores the object using an HTTP request, and obtain a copy of the requested object.
- step 874 a corresponding block is added to the Open Directory. This is carried out by creating a new Open Directory block in main memory; initializing the block by copying information from the corresponding Directory Index block; and adding a reference to the new block to the corresponding list of blocks 132 a , 132 b . Control is then passed to step 868 , in which the write count is incremented and the process continues as described above in connection with steps 868 - 870 .
- FIG. 8F is a flow diagram of a checkout_create operation that is supported for use in connection with the Open Directory 130 .
- the checkout_create operation is used to create a new block in the Open Directory 130 for a name key that corresponds to a new object that is being added to the cache. Once the block is created in the Open Directory 130 , the object can be obtained by users from the cache through the Open Directory 130 .
- the checkout_create process receives a key value as input.
- the input key value is a subkey portion of a name key 62 that corresponds to an object name.
- the process seeks to obtain a lock on the designated key. If a lock cannot be obtained, the process waits until one is available.
- step 878 the process determines which set 110 a - 110 n of the Directory Table 110 corresponds to the key. The process then locates the set of the Open Directory 130 that corresponds to the set of the Directory Table 110 , using the set subkey bits of the input key. In step 880 , the process scans the blocks in the selected block list of the Open Directory 130 , seeking a match of the input key to a key stored in one of the blocks.
- step 882 the process tests whether the matching block has been marked as deleted, and currently has no other processes reading it or writing it. If the values of both the reader counter and the writer counter are zero, then the block has no other processes reading it or writing it. If the values of either the reader counter or the writer counter are nonzero, or if the matching block has not been marked as deleted, then the block is a valid previously existing block that cannot be created. In step 884 an error message is returned to the protocol engine 70 or cache 80 indicating that the current block is not available to be created.
- step 886 the process clears the matching block.
- step 888 the process initializes the cleared block by zeroing out particular fields and setting the block's key value to the key.
- block 890 the process increments the writer counter associated with the block, and marks the block as created.
- step 892 the process returns a copy of the block to the calling process or programmatic object, and marks the block as being modified.
- step 894 the process carries out a search of the Directory Index using a process that is described further herein. If a match occurs, then in step 896 , the process returns an error message to the calling program or process, indicating that the block to be created already exists in the cache and cannot be deleted.
- step 898 the process creates a new Open Directory block, and adds a reference to that block to the list 132 a , 132 b associated with the set value computed in step 878 .
- Control is passed to step 890 , in which the processing continues as described above in connection with steps 890 - 892 .
- FIG. 9B is a flow diagram of a block check-in process.
- the cache 80 carries out the process of FIG. 9B to check a block into the Open Directory 130 after the block is read, modified, or deleted.
- the process of FIG. 9B is implemented as a program process or object that receives an identifier of a block as a parameter. Because the key is present in the checked out block, we do not need to pass in the key as an argument.
- step 930 the process attempts to get a lock for the key associated with the block. If no lock is available, then the process enters a wait loop until a lock is available. When a lock is available, in step 932 the process tests whether the block is being checked in after the block has been modified. If so, then in step 934 the writer count for the block is decremented, indicating that a process has completed writing the block.
- step 936 the process tests whether the check-in process has been carried out successfully. If this test is affirmative, then in step 942 the process copies the information in the current block to the corresponding original block in the Open Directory. In this way, the Open Directory is updated with any changes that were carried out by the process that modified the copy of the block that was obtained in the checkout process. Thereafter, and if the test of step 936 is negative, the process tests whether a delete check-in flag is set. The delete check-in flag indicates that the block is to be deleted after check-in. The delete flag is an argument to the checkin operation. If the flag is set, then in step 944 the process marks the block as deleted. Processing concludes at step 940 .
- step 932 If the test of step 932 is negative, then the block is not being modified. As a result, the only other possible state is that the block has been read. Accordingly, in step 946 , the reader count is decremented.
- the methods described herein are carried out using a general-purpose programmable digital computer system of the type illustrated in FIG. 11 .
- Each of the methods can be implemented in several different ways.
- the methods can be implemented in the form of procedural computer programs, object-oriented programs, processes, applets, etc., in either a single-process or multi-threaded, multi-processing system.
- each of the processes is independent and re-entrant, so that each process can be instantiated multiple times when the cache is in operation.
- the garbage collection process runs concurrently with and independent of the allocation and writing processes.
- FIG. 11 is a block diagram that illustrates a computer system 1100 upon which an embodiment of the invention may be implemented.
- Computer system 1100 includes a bus 1102 or other communication mechanism for communicating information, and a processor 1104 coupled with bus 1102 for processing information.
- Computer system 1100 also includes a main memory 1106 , such as a random access memory (RAM) or other dynamic storage device, coupled to bus 1102 for storing information and instructions to be executed by processor 1104 .
- Main memory 1106 also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor 1104 .
- Computer system 1100 further includes a read only memory (ROM) 1108 or other static storage device coupled to bus 1102 for storing static information and instructions for processor 1104 .
- ROM read only memory
- a storage device 1110 such as a magnetic disk or optical disk, is provided and coupled to bus 1102 for storing information and instructions.
- Computer system 1100 may be coupled via bus 1102 to a display 1112 , such as a cathode ray tube (CRT), for displaying information to a computer user.
- a display 1112 such as a cathode ray tube (CRT)
- An input device 1114 is coupled to bus 1102 for communicating information and command selections to processor 1104 .
- cursor control 1116 is Another type of user input device
- cursor control 1116 such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor 1104 and for controlling cursor movement on display 1112 .
- This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.
- the invention is related to the use of computer system 1100 for caching information objects.
- caching information objects is provided by computer system 1100 in response to processor 1104 executing one or more sequences of one or more instructions contained in main memory 1106 .
- Such instructions may be read into main memory 1106 from another computer-readable medium, such as storage device 1110 .
- Execution of the sequences of instructions contained in main memory 1106 causes processor 1104 to perform the process steps described herein.
- hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention.
- embodiments of the invention are not limited to any specific combination of hardware circuitry and software.
- Non-volatile media includes, for example, optical or magnetic disks, such as storage device 1110 .
- Volatile media includes dynamic memory, such as main memory 1106 .
- Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus 1102 . Transmission media can also take the form of acoustic or light waves, such as those generated during radio-wave and infra-red data communications.
- Computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punch cards, paper tape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read.
- Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor 1104 for execution.
- the instructions may initially be carried on a magnetic disk of a remote computer.
- the remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem.
- a modem local to computer system 1100 can receive the data on the telephone line and use an infrared transmitter to convert the data to an infrared signal.
- An infrared detector coupled to bus 1102 can receive the data carried in the infrared signal and place the data on bus 1102 .
- Bus 1102 carries the data to main memory 1106 , from which processor 1104 retrieves and executes the instructions.
- the instructions received by main memory 1106 may optionally be stored on storage device 1110 either before or after execution by processor 1104 .
- Computer system 1100 also includes a communication interface 1118 coupled to bus 1102 .
- Communication interface 1118 provides a two-way data communication coupling to a network link 1120 that is connected to a local network 1122 .
- communication interface 1118 may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line.
- ISDN integrated services digital network
- communication interface 1118 may be a local area network (LAN) card to provide a data communication connection to a compatible LAN.
- LAN local area network
- Wireless links may also be implemented.
- communication interface 1118 sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.
- Network link 1120 typically provides data communication through one or more networks to other data devices.
- network link 1120 may provide a connection through local network 1122 to a host computer 1124 or to data equipment operated by an Internet Service Provider (ISP) 1126 .
- ISP 1126 in turn provides data communication services through the world wide packet data communication network now commonly referred to as the “Internet” 1128 .
- Internet 1128 uses electrical, electromagnetic or optical signals that carry digital data streams.
- the signals through the various networks and the signals on network link 1120 and through communication interface 1118 which carry the digital data to and from computer system 1100 , are exemplary forms of carrier waves transporting the information.
- Computer system 1100 can send messages and receive data, including program code, through the network(s), network link 1120 and communication interface 1118 .
- a server 1130 might transmit a requested code for an application program through Internet 1128 , ISP 1126 , local network 1122 and communication interface 1118 .
- one such downloaded application provides for caching information objects as described herein.
- the received code may be executed by processor 1104 as it is received, and/or stored in storage device 1110 , or other non-volatile storage for later execution. In this manner, computer system 1100 may obtain application code in the form of a carrier wave.
- an object cache has been described having distinct advantages over prior approaches.
- this document describes an object cache that offers high performance, as measured by low latency and high throughput for object store operations, and large numbers of concurrent operations.
- the mechanisms described herein are applicable to a large object cache that stores terabytes of information, and billions of objects, commensurate with the growth rate.
- the object cache takes advantage of memory storage space efficiency, so expensive semiconductor memory is used sparingly and effectively.
- the cache also offers disk storage space efficiency, so that large numbers of Internet object replicas can be stored within the finite disk capacity of the object store.
- the cache is alias free, so that multiple objects or object variants, with different names, but with the same content identical object content, will have the object content cached only once, shared among the different names.
- the cache described herein has support for multimedia heterogeneity, efficiently supporting diverse multimedia objects of a multitude of types with size ranging over six orders of magnitude from a few hundred bytes to hundreds of megabytes.
- the cache has fast, usage-aware garbage collection, so less useful objects can be efficiently removed from the object store to make room for new objects.
- the cache features data consistency, so programmatic errors and hardware failures do not lead to corrupted data.
- the cache has fast restartability, so an object cache can begin servicing requests within seconds of restart, without requiring a time-consuming database or file system check operation.
- the cache uses streaming I/O, so large objects can be efficiently pipelined from the object store to slow clients, without staging the entire object into memory.
- the cache has support for content negotiation, so proxy caches can efficiently and flexibly store variants of objects for the same URL, targeted on client browser, language, or other attribute of the client request.
- the cache is general purpose, so that the object store interface is sufficiently flexible to meet the needs of future media types and protocols.
Abstract
Description
-
- 1. there is a need for an object store that can store hundreds of millions of objects of disparate sizes, and a terabyte of content size in a memory efficient manner;
- 2. there is a need for an object store that can determine if a document is a “hit” or a “miss” quickly, without time-consuming file directory lookups;
- 3. there is a need for a cache that minimizes the number of disk seeks to read and write objects;
- 4. there is a need for an object store that permits efficient streaming of data to and from the cache;
- 5. there is a need for an object store that supports multiple different versions of targeted alternates for the same name;
- 6. there is a need for an object store that efficiently stores large numbers of objects without content duplication;
- 7. there is a need for an object store that can be rapidly and efficiently garbage collected in real-time, insightfully selecting the documents to be replaced to improve user response speed, and traffic reduction;
- 8. there is a need for an object store that that can restart to full operational capacity within seconds after software or hardware failure without data corruption and with minimal data loss.
-
- 1. High performance, measured in low latency and high throughput for object store operations, and large numbers of concurrent operations;
- 2. Large cache support, supporting terabyte caches and billions of objects, to handle the Internet's exponential content growth rate;
- 3. Memory storage space efficiency, so expensive semiconductor memory is used sparingly and effectively;
- 4. Disk storage space efficiency, so large numbers of Internet object replicas can be stored within the finite disk capacity of the object store;
- 5. Alias free, so that multiple objects or object variants, with different names, but with the same content identical object content, will have the object content cached only once, shared among the different names;
- 6. Support for multimedia heterogeneity, efficiently supporting diverse multimedia objects of a multitude of types with size ranging over six orders of magnitude from a few hundred bytes to hundreds of megabytes;
- 7. Fast, usage-aware garbage collection, so less useful objects can be efficiently removed from the object store to make room for new objects;
- 8. Data consistency, so programmatic errors and hardware failures do not lead to corrupted data;
- 9. Fast restartability, so an object cache can begin servicing requests within seconds of restart, without requiring a time-consuming database or file system check operation;
- 10. Streaming, so large objects can be efficiently pipelined from the object store to slow clients, without staging the entire object into memory;
- 11. Support for content negotiation, so proxy caches can efficiently and flexibly store variants of objects for the same URL, targeted on client browser, language, or other attribute of the client request; and
- 12. General-purpose applicability, so that the object store interface is sufficiently flexible to meet the needs of future media types and protocols.
keyn=keyN−1+1
or the function can be a complex function such as the MD5 hash function
keya =MD5(keya−1)
The only requirement is that the range of possible key values should be sufficiently large, and the iteration should be sufficiently selected, so that the chances of range collision or cyclic looping are small. In the very unlikely event of key collision, the object will be deleted from the cache.
TABLE 1 |
SUCCESSIVE COUNTER VALUES |
COUNTERS |
EVENT | A | B | C | ||
1: Start | 1 | 1 | 1 | ||
2: |
2 | 1 | 1 | ||
3: Increment | 7 | 3 | 1 | ||
4: Decrement | 6 | 2 | 0 | ||
5: Reclaim | 6 | 2 | — | ||
Sum=11
Maximum_Value=21
Maximum_Value/2=10
(Sum>Maximum_Value/2)=TRUE
Since the result is true, control is transferred to step 630, in which all the counter values are decremented by 1. The state of counters A, B, C after this step is shown by Event 4, “Decrement.” Note that counter C, which represents the least recently used hash table entry, has been decremented to zero. At this point, least recently used hash table entries can be reclaimed or eliminated by scanning the corresponding counter values and searching for zero values. The result of this step is indicated in Event 5 of Table 1, “Reclaim.” The values of counters A and B are unchanged, and the value of counter C is undefined because its corresponding hash table entry has been deleted from the hash table.
Claims (24)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/140,497 US6915307B1 (en) | 1998-04-15 | 2002-05-06 | High performance object cache |
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/060,866 US6128623A (en) | 1998-04-15 | 1998-04-15 | High performance object cache |
US09/543,238 US6453319B1 (en) | 1998-04-15 | 2000-04-05 | Maintaining counters for high performance object cache |
US10/140,497 US6915307B1 (en) | 1998-04-15 | 2002-05-06 | High performance object cache |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/543,238 Continuation US6453319B1 (en) | 1998-04-15 | 2000-04-05 | Maintaining counters for high performance object cache |
Publications (1)
Publication Number | Publication Date |
---|---|
US6915307B1 true US6915307B1 (en) | 2005-07-05 |
Family
ID=34703792
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/140,497 Expired - Lifetime US6915307B1 (en) | 1998-04-15 | 2002-05-06 | High performance object cache |
Country Status (1)
Country | Link |
---|---|
US (1) | US6915307B1 (en) |
Cited By (134)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20040088415A1 (en) * | 2002-11-06 | 2004-05-06 | Oracle International Corporation | Techniques for scalably accessing data in an arbitrarily large document by a device with limited resources |
US20040103211A1 (en) * | 2002-11-21 | 2004-05-27 | Jackson Eric S. | System and method for managing computer networks |
US20040133444A1 (en) * | 2002-09-20 | 2004-07-08 | Florence Defaix | Version control system for software development |
US20040167961A1 (en) * | 2003-02-26 | 2004-08-26 | Microsoft Corporation | Fragment response cache |
US20050027933A1 (en) * | 2003-07-29 | 2005-02-03 | International Business Machines Corporation | Methods and systems for managing persistent storage of small data objects |
US20050050105A1 (en) * | 2003-08-25 | 2005-03-03 | Oracle International Corporation | In-place evolution of XML schemas |
US20050050058A1 (en) * | 2003-08-25 | 2005-03-03 | Oracle International Corporation | Direct loading of opaque types |
US20050050092A1 (en) * | 2003-08-25 | 2005-03-03 | Oracle International Corporation | Direct loading of semistructured data |
US20050055343A1 (en) * | 2003-09-04 | 2005-03-10 | Krishnamurthy Sanjay M. | Storing XML documents efficiently in an RDBMS |
US20050132337A1 (en) * | 2003-12-11 | 2005-06-16 | Malte Wedel | Trace management in client-server applications |
US20050188048A1 (en) * | 2004-01-20 | 2005-08-25 | Microsoft Corporation | Systems and methods for processing dynamic content |
US20050198062A1 (en) * | 2004-03-05 | 2005-09-08 | Shapiro Richard B. | Method and apparatus for accelerating data access operations in a database system |
US20050235364A1 (en) * | 2004-04-15 | 2005-10-20 | Wilson Christopher S | Authentication mechanism permitting access to data stored in a data processing device |
US20050235063A1 (en) * | 2004-04-15 | 2005-10-20 | Wilson Christopher S | Automatic discovery of a networked device |
US20050231849A1 (en) * | 2004-04-15 | 2005-10-20 | Viresh Rustagi | Graphical user interface for hard disk drive management in a data storage system |
US20050235128A1 (en) * | 2004-04-15 | 2005-10-20 | Viresh Rustagi | Automatic expansion of hard disk drive capacity in a storage device |
US20050257013A1 (en) * | 2004-05-11 | 2005-11-17 | Kenneth Ma | Storage access prioritization using a data storage device |
US20050289175A1 (en) * | 2004-06-23 | 2005-12-29 | Oracle International Corporation | Providing XML node identity based operations in a value based SQL system |
US20060015859A1 (en) * | 2004-07-16 | 2006-01-19 | Sap Aktiengesellschaft | Method and apparatus for supporting context links for application program text |
US20060026357A1 (en) * | 2004-07-27 | 2006-02-02 | Texas Instruments Incorporated | Context save and restore with a stack-based memory structure |
US20060070605A1 (en) * | 2004-01-21 | 2006-04-06 | Toyota Jidosha Kabushiki Kaisha | Internal combustion engine with variable compression ratio |
US20060167884A1 (en) * | 2002-10-24 | 2006-07-27 | Sabel Rafi Ralph W | Method and apparatus for recording a transfer of a piece of data |
US20060195450A1 (en) * | 2002-04-08 | 2006-08-31 | Oracle International Corporation | Persistent key-value repository with a pluggable architecture to abstract physical storage |
US7103616B1 (en) * | 2003-02-19 | 2006-09-05 | Veritas Operating Corporation | Cookie-based directory name lookup cache for a cluster file system |
US20070094641A1 (en) * | 2001-12-28 | 2007-04-26 | Darr Timothy P | Product configuration using configuration patterns |
US20070174367A1 (en) * | 2005-12-22 | 2007-07-26 | Shapiro Alan J | Selective File Erasure Using Metadata Modifications |
US20070260592A1 (en) * | 2006-05-03 | 2007-11-08 | International Business Machines Corporation | Hierarchical storage management of metadata |
US7321900B1 (en) | 2001-06-15 | 2008-01-22 | Oracle International Corporation | Reducing memory requirements needed to represent XML entities |
US20080071859A1 (en) * | 2002-02-14 | 2008-03-20 | Level 3 Communications, Llc | Popularity-based selective replication in content delivery network |
US20080091714A1 (en) * | 2006-10-16 | 2008-04-17 | Oracle International Corporation | Efficient partitioning technique while managing large XML documents |
US7490093B2 (en) | 2003-08-25 | 2009-02-10 | Oracle International Corporation | Generating a schema-specific load structure to load data into a relational database based on determining whether the schema-specific load structure already exists |
US7594001B1 (en) * | 2001-07-06 | 2009-09-22 | Microsoft Corporation | Partial page output caching |
US20090240888A1 (en) * | 2005-08-11 | 2009-09-24 | Research In Motion Limited | System and method for obscuring hand-held device data traffic information |
US20090307239A1 (en) * | 2008-06-06 | 2009-12-10 | Oracle International Corporation | Fast extraction of scalar values from binary encoded xml |
US7672945B1 (en) | 2002-04-08 | 2010-03-02 | Oracle International Corporation | Mechanism for creating member private data in a global namespace |
US7720892B1 (en) * | 2006-06-30 | 2010-05-18 | Emc Corporation | Bulk updates and tape synchronization |
US20100153475A1 (en) * | 2008-12-16 | 2010-06-17 | Sap Ag | Monitoring memory consumption |
US7802180B2 (en) | 2004-06-23 | 2010-09-21 | Oracle International Corporation | Techniques for serialization of instances of the XQuery data model |
US7890604B2 (en) | 2004-05-07 | 2011-02-15 | Microsoft Corproation | Client-side callbacks to server events |
US7933928B2 (en) * | 2005-12-22 | 2011-04-26 | Oracle International Corporation | Method and mechanism for loading XML documents into memory |
US20110179365A1 (en) * | 2008-09-29 | 2011-07-21 | Teruya Ikegami | Gui evaluation system, gui evaluation method, and gui evaluation program |
US20120084784A1 (en) * | 2010-10-04 | 2012-04-05 | Idris Mir | System and method for managing memory resource(s) of a wireless handheld computing device |
US20120331228A1 (en) * | 2011-06-23 | 2012-12-27 | Incapsula, Inc | Dynamic content caching |
US20130018942A1 (en) * | 2007-03-30 | 2013-01-17 | Paul Jardetzky | System and method for bandwidth optimization in a network storage environment |
CN103118099A (en) * | 2013-01-25 | 2013-05-22 | 福建升腾资讯有限公司 | Hash algorithm based graphic image caching method |
US8694510B2 (en) | 2003-09-04 | 2014-04-08 | Oracle International Corporation | Indexing XML documents efficiently |
CN103744897A (en) * | 2013-12-24 | 2014-04-23 | 华为技术有限公司 | Associated search method and associated search system for fault information, and network management system |
US8775727B2 (en) | 2012-08-31 | 2014-07-08 | Lsi Corporation | Lookup engine with pipelined access, speculative add and lock-in-hit function |
US20140282420A1 (en) * | 2013-03-15 | 2014-09-18 | Vmware, Inc. | Test automation booster |
US8930538B2 (en) | 2008-04-04 | 2015-01-06 | Level 3 Communications, Llc | Handling long-tail content in a content delivery network (CDN) |
US9009206B1 (en) * | 2012-11-20 | 2015-04-14 | Netapp, Inc. | Method and system for optimizing traversal and storage of directory entries of a storage volume |
US9026578B2 (en) | 2004-05-14 | 2015-05-05 | Microsoft Corporation | Systems and methods for persisting data between web pages |
US9081787B2 (en) | 2011-11-21 | 2015-07-14 | International Business Machines Corporation | Customizable file-type aware cache mechanism |
US20150234898A1 (en) * | 2014-02-20 | 2015-08-20 | TmaxData Co., Ltd. | Apparatus and method for processing query in database with hybrid storage |
US9195489B2 (en) | 2011-11-21 | 2015-11-24 | International Business Machines Corporation | Image deployment in a cloud environment |
US9195599B2 (en) | 2013-06-25 | 2015-11-24 | Globalfoundries Inc. | Multi-level aggregation techniques for memory hierarchies |
US20160019275A1 (en) * | 2014-07-21 | 2016-01-21 | Palo Alto Research Center Incorporated | System for distributing nameless objects using self-certifying names |
US20160205034A1 (en) * | 2015-01-12 | 2016-07-14 | Palo Alto Research Center Incorporated | Resource allocation using ccn manifests |
US20160267152A1 (en) * | 2002-06-20 | 2016-09-15 | Guidance Software, Inc. | System and method for conducting searches at target devices |
US9473576B2 (en) | 2014-04-07 | 2016-10-18 | Palo Alto Research Center Incorporated | Service discovery using collection synchronization with exact names |
US9590887B2 (en) | 2014-07-18 | 2017-03-07 | Cisco Systems, Inc. | Method and system for keeping interest alive in a content centric network |
US9590948B2 (en) | 2014-12-15 | 2017-03-07 | Cisco Systems, Inc. | CCN routing using hardware-assisted hash tables |
US9609014B2 (en) | 2014-05-22 | 2017-03-28 | Cisco Systems, Inc. | Method and apparatus for preventing insertion of malicious content at a named data network router |
US20170099342A1 (en) * | 2015-10-04 | 2017-04-06 | Anthony Ko-Ping Chien | Dynamically Served Content |
US9621354B2 (en) | 2014-07-17 | 2017-04-11 | Cisco Systems, Inc. | Reconstructable content objects |
US9626413B2 (en) | 2014-03-10 | 2017-04-18 | Cisco Systems, Inc. | System and method for ranking content popularity in a content-centric network |
US9660825B2 (en) | 2014-12-24 | 2017-05-23 | Cisco Technology, Inc. | System and method for multi-source multicasting in content-centric networks |
US20170170955A1 (en) * | 2015-12-09 | 2017-06-15 | Palo Alto Research Center Incorporated | Key catalogs in a content centric network |
US9686194B2 (en) | 2009-10-21 | 2017-06-20 | Cisco Technology, Inc. | Adaptive multi-interface use for content networking |
US9699198B2 (en) | 2014-07-07 | 2017-07-04 | Cisco Technology, Inc. | System and method for parallel secure content bootstrapping in content-centric networks |
US9710514B1 (en) * | 2013-06-25 | 2017-07-18 | Marvell International Ltd. | Systems and methods for efficient storage access using metadata |
US9716622B2 (en) | 2014-04-01 | 2017-07-25 | Cisco Technology, Inc. | System and method for dynamic name configuration in content-centric networks |
US9729662B2 (en) | 2014-08-11 | 2017-08-08 | Cisco Technology, Inc. | Probabilistic lazy-forwarding technique without validation in a content centric network |
US9729616B2 (en) | 2014-07-18 | 2017-08-08 | Cisco Technology, Inc. | Reputation-based strategy for forwarding and responding to interests over a content centric network |
US20170237825A1 (en) * | 2014-08-27 | 2017-08-17 | Huawei Technologies Co., Ltd. | Resource Download Method, Electronic Device, and Apparatus |
US9742860B2 (en) * | 2012-02-28 | 2017-08-22 | International Business Machines Corporation | Bi-temporal key value cache system |
US9762692B2 (en) | 2008-04-04 | 2017-09-12 | Level 3 Communications, Llc | Handling long-tail content in a content delivery network (CDN) |
US9800637B2 (en) | 2014-08-19 | 2017-10-24 | Cisco Technology, Inc. | System and method for all-in-one content stream in content-centric networks |
US9832291B2 (en) | 2015-01-12 | 2017-11-28 | Cisco Technology, Inc. | Auto-configurable transport stack |
US9832123B2 (en) | 2015-09-11 | 2017-11-28 | Cisco Technology, Inc. | Network named fragments in a content centric network |
US9836540B2 (en) | 2014-03-04 | 2017-12-05 | Cisco Technology, Inc. | System and method for direct storage access in a content-centric network |
US9882964B2 (en) | 2014-08-08 | 2018-01-30 | Cisco Technology, Inc. | Explicit strategy feedback in name-based forwarding |
US9912776B2 (en) | 2015-12-02 | 2018-03-06 | Cisco Technology, Inc. | Explicit content deletion commands in a content centric network |
US9916457B2 (en) | 2015-01-12 | 2018-03-13 | Cisco Technology, Inc. | Decoupled name security binding for CCN objects |
US9930146B2 (en) | 2016-04-04 | 2018-03-27 | Cisco Technology, Inc. | System and method for compressing content centric networking messages |
US9946743B2 (en) | 2015-01-12 | 2018-04-17 | Cisco Technology, Inc. | Order encoded manifests in a content centric network |
US9954678B2 (en) | 2014-02-06 | 2018-04-24 | Cisco Technology, Inc. | Content-based transport security |
US9977809B2 (en) | 2015-09-24 | 2018-05-22 | Cisco Technology, Inc. | Information and data framework in a content centric network |
US9986034B2 (en) | 2015-08-03 | 2018-05-29 | Cisco Technology, Inc. | Transferring state in content centric network stacks |
US9992281B2 (en) | 2014-05-01 | 2018-06-05 | Cisco Technology, Inc. | Accountable content stores for information centric networks |
US9992097B2 (en) | 2016-07-11 | 2018-06-05 | Cisco Technology, Inc. | System and method for piggybacking routing information in interests in a content centric network |
US10003507B2 (en) | 2016-03-04 | 2018-06-19 | Cisco Technology, Inc. | Transport session state protocol |
US10003520B2 (en) | 2014-12-22 | 2018-06-19 | Cisco Technology, Inc. | System and method for efficient name-based content routing using link-state information in information-centric networks |
US10009266B2 (en) | 2016-07-05 | 2018-06-26 | Cisco Technology, Inc. | Method and system for reference counted pending interest tables in a content centric network |
US10033642B2 (en) | 2016-09-19 | 2018-07-24 | Cisco Technology, Inc. | System and method for making optimal routing decisions based on device-specific parameters in a content centric network |
US10043016B2 (en) | 2016-02-29 | 2018-08-07 | Cisco Technology, Inc. | Method and system for name encryption agreement in a content centric network |
US10051071B2 (en) | 2016-03-04 | 2018-08-14 | Cisco Technology, Inc. | Method and system for collecting historical network information in a content centric network |
US10063414B2 (en) | 2016-05-13 | 2018-08-28 | Cisco Technology, Inc. | Updating a transport stack in a content centric network |
US10069933B2 (en) | 2014-10-23 | 2018-09-04 | Cisco Technology, Inc. | System and method for creating virtual interfaces based on network characteristics |
US10069729B2 (en) | 2016-08-08 | 2018-09-04 | Cisco Technology, Inc. | System and method for throttling traffic based on a forwarding information base in a content centric network |
US10067948B2 (en) | 2016-03-18 | 2018-09-04 | Cisco Technology, Inc. | Data deduping in content centric networking manifests |
US10075401B2 (en) | 2015-03-18 | 2018-09-11 | Cisco Technology, Inc. | Pending interest table behavior |
US10075402B2 (en) | 2015-06-24 | 2018-09-11 | Cisco Technology, Inc. | Flexible command and control in content centric networks |
US10084764B2 (en) | 2016-05-13 | 2018-09-25 | Cisco Technology, Inc. | System for a secure encryption proxy in a content centric network |
US10091330B2 (en) | 2016-03-23 | 2018-10-02 | Cisco Technology, Inc. | Interest scheduling by an information and data framework in a content centric network |
US10098051B2 (en) | 2014-01-22 | 2018-10-09 | Cisco Technology, Inc. | Gateways and routing in software-defined manets |
US10103989B2 (en) | 2016-06-13 | 2018-10-16 | Cisco Technology, Inc. | Content object return messages in a content centric network |
US10104041B2 (en) | 2008-05-16 | 2018-10-16 | Cisco Technology, Inc. | Controlling the spread of interests and content in a content centric network |
US10122624B2 (en) | 2016-07-25 | 2018-11-06 | Cisco Technology, Inc. | System and method for ephemeral entries in a forwarding information base in a content centric network |
US10135948B2 (en) | 2016-10-31 | 2018-11-20 | Cisco Technology, Inc. | System and method for process migration in a content centric network |
US10148572B2 (en) | 2016-06-27 | 2018-12-04 | Cisco Technology, Inc. | Method and system for interest groups in a content centric network |
US10212248B2 (en) | 2016-10-03 | 2019-02-19 | Cisco Technology, Inc. | Cache management on high availability routers in a content centric network |
US10237189B2 (en) | 2014-12-16 | 2019-03-19 | Cisco Technology, Inc. | System and method for distance-based interest forwarding |
US10243851B2 (en) | 2016-11-21 | 2019-03-26 | Cisco Technology, Inc. | System and method for forwarder connection information in a content centric network |
US10257271B2 (en) | 2016-01-11 | 2019-04-09 | Cisco Technology, Inc. | Chandra-Toueg consensus in a content centric network |
US10264099B2 (en) | 2016-03-07 | 2019-04-16 | Cisco Technology, Inc. | Method and system for content closures in a content centric network |
US10263965B2 (en) | 2015-10-16 | 2019-04-16 | Cisco Technology, Inc. | Encrypted CCNx |
US20190155621A1 (en) * | 2016-05-06 | 2019-05-23 | Zte Corporation | Application Synchronization Method and Device |
US10305864B2 (en) | 2016-01-25 | 2019-05-28 | Cisco Technology, Inc. | Method and system for interest encryption in a content centric network |
US10305865B2 (en) | 2016-06-21 | 2019-05-28 | Cisco Technology, Inc. | Permutation-based content encryption with manifests in a content centric network |
US10313227B2 (en) | 2015-09-24 | 2019-06-04 | Cisco Technology, Inc. | System and method for eliminating undetected interest looping in information-centric networks |
US10320760B2 (en) | 2016-04-01 | 2019-06-11 | Cisco Technology, Inc. | Method and system for mutating and caching content in a content centric network |
US10333840B2 (en) | 2015-02-06 | 2019-06-25 | Cisco Technology, Inc. | System and method for on-demand content exchange with adaptive naming in information-centric networks |
US10355999B2 (en) | 2015-09-23 | 2019-07-16 | Cisco Technology, Inc. | Flow control with network named fragments |
US10425503B2 (en) | 2016-04-07 | 2019-09-24 | Cisco Technology, Inc. | Shared pending interest table in a content centric network |
US10447805B2 (en) | 2016-10-10 | 2019-10-15 | Cisco Technology, Inc. | Distributed consensus in a content centric network |
US10454820B2 (en) | 2015-09-29 | 2019-10-22 | Cisco Technology, Inc. | System and method for stateless information-centric networking |
US10701038B2 (en) | 2015-07-27 | 2020-06-30 | Cisco Technology, Inc. | Content negotiation in a content centric network |
US10742596B2 (en) | 2016-03-04 | 2020-08-11 | Cisco Technology, Inc. | Method and system for reducing a collision probability of hash-based names using a publisher identifier |
US10924573B2 (en) | 2008-04-04 | 2021-02-16 | Level 3 Communications, Llc | Handling long-tail content in a content delivery network (CDN) |
US10956412B2 (en) | 2016-08-09 | 2021-03-23 | Cisco Technology, Inc. | Method and system for conjunctive normal form attribute matching in a content centric network |
US11301422B2 (en) * | 2016-02-23 | 2022-04-12 | Samsung Electronics Co., Ltd. | System and methods for providing fast cacheable access to a key-value device through a filesystem interface |
US11354315B2 (en) | 2005-12-29 | 2022-06-07 | Amazon Technologies, Inc. | Method and apparatus for stress management in a searchable data service |
US20230093873A1 (en) * | 2021-09-24 | 2023-03-30 | Apple Inc. | Generation of transaction tags for enhanced searching |
Citations (8)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5611049A (en) | 1992-06-03 | 1997-03-11 | Pitts; William M. | System for accessing distributed data cache channel at each network node to pass requests and data |
US6085234A (en) | 1994-11-28 | 2000-07-04 | Inca Technology, Inc. | Remote file services network-infrastructure cache |
US6128623A (en) * | 1998-04-15 | 2000-10-03 | Inktomi Corporation | High performance object cache |
US6292880B1 (en) * | 1998-04-15 | 2001-09-18 | Inktomi Corporation | Alias-free content-indexed object cache |
US6332219B1 (en) * | 1999-03-29 | 2001-12-18 | International Business Machines Corporation | Cross-platform program, system, and method having a global registry object for mapping registry functions in a windows operating system environment |
US6446255B1 (en) * | 1999-03-29 | 2002-09-03 | International Business Machines Corporation | Global registry object for mapping registry functions and registry equivalent functions across multiple operating systems in a cross-platform program |
US6615278B1 (en) * | 1999-03-29 | 2003-09-02 | International Business Machines Corporation | Cross-platform program, system, and method having a global registry object for mapping registry equivalent functions in an OS/2 operating system environment |
US6615277B1 (en) * | 1999-03-29 | 2003-09-02 | International Business Machines Corporation | Cross-platform program, system, and method having a global registry object for mapping registry equivalent functions in an operating system environment |
-
2002
- 2002-05-06 US US10/140,497 patent/US6915307B1/en not_active Expired - Lifetime
Patent Citations (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5611049A (en) | 1992-06-03 | 1997-03-11 | Pitts; William M. | System for accessing distributed data cache channel at each network node to pass requests and data |
US6085234A (en) | 1994-11-28 | 2000-07-04 | Inca Technology, Inc. | Remote file services network-infrastructure cache |
US6128623A (en) * | 1998-04-15 | 2000-10-03 | Inktomi Corporation | High performance object cache |
US6292880B1 (en) * | 1998-04-15 | 2001-09-18 | Inktomi Corporation | Alias-free content-indexed object cache |
US6453319B1 (en) * | 1998-04-15 | 2002-09-17 | Inktomi Corporation | Maintaining counters for high performance object cache |
US6332219B1 (en) * | 1999-03-29 | 2001-12-18 | International Business Machines Corporation | Cross-platform program, system, and method having a global registry object for mapping registry functions in a windows operating system environment |
US6446255B1 (en) * | 1999-03-29 | 2002-09-03 | International Business Machines Corporation | Global registry object for mapping registry functions and registry equivalent functions across multiple operating systems in a cross-platform program |
US6615278B1 (en) * | 1999-03-29 | 2003-09-02 | International Business Machines Corporation | Cross-platform program, system, and method having a global registry object for mapping registry equivalent functions in an OS/2 operating system environment |
US6615277B1 (en) * | 1999-03-29 | 2003-09-02 | International Business Machines Corporation | Cross-platform program, system, and method having a global registry object for mapping registry equivalent functions in an operating system environment |
Cited By (214)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7321900B1 (en) | 2001-06-15 | 2008-01-22 | Oracle International Corporation | Reducing memory requirements needed to represent XML entities |
US7594001B1 (en) * | 2001-07-06 | 2009-09-22 | Microsoft Corporation | Partial page output caching |
US20070094641A1 (en) * | 2001-12-28 | 2007-04-26 | Darr Timothy P | Product configuration using configuration patterns |
US9992279B2 (en) * | 2002-02-14 | 2018-06-05 | Level 3 Communications, Llc | Managed object replication and delivery |
US20080071859A1 (en) * | 2002-02-14 | 2008-03-20 | Level 3 Communications, Llc | Popularity-based selective replication in content delivery network |
US10979499B2 (en) | 2002-02-14 | 2021-04-13 | Level 3 Communications, Llc | Managed object replication and delivery |
US20160044105A1 (en) * | 2002-02-14 | 2016-02-11 | Level 3 Communications, Llc | Managed object replication and delivery |
US8924466B2 (en) | 2002-02-14 | 2014-12-30 | Level 3 Communications, Llc | Server handoff in content delivery network |
US9167036B2 (en) | 2002-02-14 | 2015-10-20 | Level 3 Communications, Llc | Managed object replication and delivery |
US7617218B2 (en) * | 2002-04-08 | 2009-11-10 | Oracle International Corporation | Persistent key-value repository with a pluggable architecture to abstract physical storage |
US7672945B1 (en) | 2002-04-08 | 2010-03-02 | Oracle International Corporation | Mechanism for creating member private data in a global namespace |
US20060195450A1 (en) * | 2002-04-08 | 2006-08-31 | Oracle International Corporation | Persistent key-value repository with a pluggable architecture to abstract physical storage |
US10366097B2 (en) * | 2002-06-20 | 2019-07-30 | Open Text Holdings, Inc. | System and method for conducting searches at target devices |
US11556556B2 (en) * | 2002-06-20 | 2023-01-17 | Open Text Holdings, Inc. | System and method for conducting searches at target devices |
US20160267152A1 (en) * | 2002-06-20 | 2016-09-15 | Guidance Software, Inc. | System and method for conducting searches at target devices |
US20040133444A1 (en) * | 2002-09-20 | 2004-07-08 | Florence Defaix | Version control system for software development |
US7680932B2 (en) * | 2002-09-20 | 2010-03-16 | Mks Inc. | Version control system for software development |
US20060167884A1 (en) * | 2002-10-24 | 2006-07-27 | Sabel Rafi Ralph W | Method and apparatus for recording a transfer of a piece of data |
US20040088415A1 (en) * | 2002-11-06 | 2004-05-06 | Oracle International Corporation | Techniques for scalably accessing data in an arbitrarily large document by a device with limited resources |
US7308474B2 (en) * | 2002-11-06 | 2007-12-11 | Oracle International Corporation | Techniques for scalably accessing data in an arbitrarily large document by a device with limited resources |
US20080294770A1 (en) * | 2002-11-21 | 2008-11-27 | Arbor Networks | System and method for managing computer networks |
US7359930B2 (en) * | 2002-11-21 | 2008-04-15 | Arbor Networks | System and method for managing computer networks |
US20040103211A1 (en) * | 2002-11-21 | 2004-05-27 | Jackson Eric S. | System and method for managing computer networks |
US8667047B2 (en) | 2002-11-21 | 2014-03-04 | Arbor Networks | System and method for managing computer networks |
US7103616B1 (en) * | 2003-02-19 | 2006-09-05 | Veritas Operating Corporation | Cookie-based directory name lookup cache for a cluster file system |
US20040167961A1 (en) * | 2003-02-26 | 2004-08-26 | Microsoft Corporation | Fragment response cache |
US20050027933A1 (en) * | 2003-07-29 | 2005-02-03 | International Business Machines Corporation | Methods and systems for managing persistent storage of small data objects |
US7836248B2 (en) * | 2003-07-29 | 2010-11-16 | International Business Machines Corporation | Methods and systems for managing persistent storage of small data objects |
US7814047B2 (en) * | 2003-08-25 | 2010-10-12 | Oracle International Corporation | Direct loading of semistructured data |
US8219569B2 (en) | 2003-08-25 | 2012-07-10 | Oracle International Corporation | In-place evolution of XML schemes |
US7747580B2 (en) | 2003-08-25 | 2010-06-29 | Oracle International Corporation | Direct loading of opaque types |
US20050050105A1 (en) * | 2003-08-25 | 2005-03-03 | Oracle International Corporation | In-place evolution of XML schemas |
US20050050092A1 (en) * | 2003-08-25 | 2005-03-03 | Oracle International Corporation | Direct loading of semistructured data |
US20050050058A1 (en) * | 2003-08-25 | 2005-03-03 | Oracle International Corporation | Direct loading of opaque types |
US7490093B2 (en) | 2003-08-25 | 2009-02-10 | Oracle International Corporation | Generating a schema-specific load structure to load data into a relational database based on determining whether the schema-specific load structure already exists |
US8229932B2 (en) | 2003-09-04 | 2012-07-24 | Oracle International Corporation | Storing XML documents efficiently in an RDBMS |
US20050055343A1 (en) * | 2003-09-04 | 2005-03-10 | Krishnamurthy Sanjay M. | Storing XML documents efficiently in an RDBMS |
US8694510B2 (en) | 2003-09-04 | 2014-04-08 | Oracle International Corporation | Indexing XML documents efficiently |
US20080313504A1 (en) * | 2003-12-11 | 2008-12-18 | Sap Aktiengesellschaft | Trace management in client-server applications |
US7404180B2 (en) * | 2003-12-11 | 2008-07-22 | Sap Ag | Trace management in client-server applications |
US20050132337A1 (en) * | 2003-12-11 | 2005-06-16 | Malte Wedel | Trace management in client-server applications |
US8271957B2 (en) | 2003-12-11 | 2012-09-18 | Sap Ag | Trace management in client-server applications |
US7590704B2 (en) * | 2004-01-20 | 2009-09-15 | Microsoft Corporation | Systems and methods for processing dynamic content |
US20050188048A1 (en) * | 2004-01-20 | 2005-08-25 | Microsoft Corporation | Systems and methods for processing dynamic content |
US20060070605A1 (en) * | 2004-01-21 | 2006-04-06 | Toyota Jidosha Kabushiki Kaisha | Internal combustion engine with variable compression ratio |
US20050198062A1 (en) * | 2004-03-05 | 2005-09-08 | Shapiro Richard B. | Method and apparatus for accelerating data access operations in a database system |
US7681007B2 (en) | 2004-04-15 | 2010-03-16 | Broadcom Corporation | Automatic expansion of hard disk drive capacity in a storage device |
US20050235364A1 (en) * | 2004-04-15 | 2005-10-20 | Wilson Christopher S | Authentication mechanism permitting access to data stored in a data processing device |
US20050235063A1 (en) * | 2004-04-15 | 2005-10-20 | Wilson Christopher S | Automatic discovery of a networked device |
US20050231849A1 (en) * | 2004-04-15 | 2005-10-20 | Viresh Rustagi | Graphical user interface for hard disk drive management in a data storage system |
US20050235128A1 (en) * | 2004-04-15 | 2005-10-20 | Viresh Rustagi | Automatic expansion of hard disk drive capacity in a storage device |
US7890604B2 (en) | 2004-05-07 | 2011-02-15 | Microsoft Corproation | Client-side callbacks to server events |
US7555613B2 (en) * | 2004-05-11 | 2009-06-30 | Broadcom Corporation | Storage access prioritization using a data storage device |
US20050257013A1 (en) * | 2004-05-11 | 2005-11-17 | Kenneth Ma | Storage access prioritization using a data storage device |
US9026578B2 (en) | 2004-05-14 | 2015-05-05 | Microsoft Corporation | Systems and methods for persisting data between web pages |
US20050289175A1 (en) * | 2004-06-23 | 2005-12-29 | Oracle International Corporation | Providing XML node identity based operations in a value based SQL system |
US7802180B2 (en) | 2004-06-23 | 2010-09-21 | Oracle International Corporation | Techniques for serialization of instances of the XQuery data model |
US20060015859A1 (en) * | 2004-07-16 | 2006-01-19 | Sap Aktiengesellschaft | Method and apparatus for supporting context links for application program text |
US7665083B2 (en) * | 2004-07-16 | 2010-02-16 | Sap Ag | Method and apparatus for supporting context links for application program text |
US20060026357A1 (en) * | 2004-07-27 | 2006-02-02 | Texas Instruments Incorporated | Context save and restore with a stack-based memory structure |
US7606977B2 (en) * | 2004-07-27 | 2009-10-20 | Texas Instruments Incorporated | Context save and restore with a stack-based memory structure |
US7546437B2 (en) * | 2004-07-27 | 2009-06-09 | Texas Instruments Incorporated | Memory usable in cache mode or scratch pad mode to reduce the frequency of memory accesses |
US7900001B2 (en) * | 2005-08-11 | 2011-03-01 | Research In Motion Limited | System and method for obscuring hand-held device data traffic information |
US20090240888A1 (en) * | 2005-08-11 | 2009-09-24 | Research In Motion Limited | System and method for obscuring hand-held device data traffic information |
US7856451B2 (en) | 2005-12-22 | 2010-12-21 | Alan Joshua Shapiro | Selective file erasure using metadata modifications |
US20090292747A1 (en) * | 2005-12-22 | 2009-11-26 | Alan Joshua Shapiro | Selective file erasure using metadata modifications |
US8099437B2 (en) | 2005-12-22 | 2012-01-17 | Alan Joshua Shapiro | Method and apparatus for selective file erasure using metadata modifications |
US7933928B2 (en) * | 2005-12-22 | 2011-04-26 | Oracle International Corporation | Method and mechanism for loading XML documents into memory |
US8521781B2 (en) | 2005-12-22 | 2013-08-27 | Alan Joshua Shapiro | Apparatus and method for selective file erasure using metadata modifications |
US8782089B2 (en) | 2005-12-22 | 2014-07-15 | Alan Joshua Shapiro | Selective file erasure using metadata modifications and apparatus |
US20110125816A1 (en) * | 2005-12-22 | 2011-05-26 | Alan Joshua Shapiro | Method and apparatus for selective file erasure using metadata modifications |
US9171005B2 (en) | 2005-12-22 | 2015-10-27 | Alan Joshua Shapiro | System and method for selective file erasure using metadata modifcations |
US20070174367A1 (en) * | 2005-12-22 | 2007-07-26 | Shapiro Alan J | Selective File Erasure Using Metadata Modifications |
US7571176B2 (en) | 2005-12-22 | 2009-08-04 | Alan Joshua Shapiro | Selective file erasure using metadata modifications |
US11354315B2 (en) | 2005-12-29 | 2022-06-07 | Amazon Technologies, Inc. | Method and apparatus for stress management in a searchable data service |
US11580109B2 (en) * | 2005-12-29 | 2023-02-14 | Amazon Technologies, Inc. | Method and apparatus for stress management in a searchable data service |
US7574435B2 (en) | 2006-05-03 | 2009-08-11 | International Business Machines Corporation | Hierarchical storage management of metadata |
US20070260592A1 (en) * | 2006-05-03 | 2007-11-08 | International Business Machines Corporation | Hierarchical storage management of metadata |
US7720892B1 (en) * | 2006-06-30 | 2010-05-18 | Emc Corporation | Bulk updates and tape synchronization |
US20080091714A1 (en) * | 2006-10-16 | 2008-04-17 | Oracle International Corporation | Efficient partitioning technique while managing large XML documents |
US7933935B2 (en) | 2006-10-16 | 2011-04-26 | Oracle International Corporation | Efficient partitioning technique while managing large XML documents |
US20130018942A1 (en) * | 2007-03-30 | 2013-01-17 | Paul Jardetzky | System and method for bandwidth optimization in a network storage environment |
US9355103B2 (en) * | 2007-03-30 | 2016-05-31 | Netapp, Inc. | System and method for bandwidth optimization in a network storage environment |
US10218806B2 (en) | 2008-04-04 | 2019-02-26 | Level 3 Communications, Llc | Handling long-tail content in a content delivery network (CDN) |
US10924573B2 (en) | 2008-04-04 | 2021-02-16 | Level 3 Communications, Llc | Handling long-tail content in a content delivery network (CDN) |
US9762692B2 (en) | 2008-04-04 | 2017-09-12 | Level 3 Communications, Llc | Handling long-tail content in a content delivery network (CDN) |
US8930538B2 (en) | 2008-04-04 | 2015-01-06 | Level 3 Communications, Llc | Handling long-tail content in a content delivery network (CDN) |
US10104041B2 (en) | 2008-05-16 | 2018-10-16 | Cisco Technology, Inc. | Controlling the spread of interests and content in a content centric network |
US8429196B2 (en) | 2008-06-06 | 2013-04-23 | Oracle International Corporation | Fast extraction of scalar values from binary encoded XML |
US20090307239A1 (en) * | 2008-06-06 | 2009-12-10 | Oracle International Corporation | Fast extraction of scalar values from binary encoded xml |
US20110179365A1 (en) * | 2008-09-29 | 2011-07-21 | Teruya Ikegami | Gui evaluation system, gui evaluation method, and gui evaluation program |
US8826185B2 (en) * | 2008-09-29 | 2014-09-02 | Nec Corporation | GUI evaluation system, GUI evaluation method, and GUI evaluation program |
CN101753380A (en) * | 2008-12-16 | 2010-06-23 | Sap股份公司 | Monitoring memory consumption |
CN101753380B (en) * | 2008-12-16 | 2014-03-19 | Sap股份公司 | Monitoring memory consumption |
US20100153475A1 (en) * | 2008-12-16 | 2010-06-17 | Sap Ag | Monitoring memory consumption |
US8090752B2 (en) * | 2008-12-16 | 2012-01-03 | Sap Ag | Monitoring memory consumption |
US9686194B2 (en) | 2009-10-21 | 2017-06-20 | Cisco Technology, Inc. | Adaptive multi-interface use for content networking |
US8453154B2 (en) * | 2010-10-04 | 2013-05-28 | Qualcomm Incorporated | System and method for managing memory resource(s) of a wireless handheld computing device |
US20120084784A1 (en) * | 2010-10-04 | 2012-04-05 | Idris Mir | System and method for managing memory resource(s) of a wireless handheld computing device |
US9400851B2 (en) * | 2011-06-23 | 2016-07-26 | Incapsula, Inc. | Dynamic content caching |
US20120331228A1 (en) * | 2011-06-23 | 2012-12-27 | Incapsula, Inc | Dynamic content caching |
US9081788B2 (en) | 2011-11-21 | 2015-07-14 | International Business Machines Corporation | Customizable file-type aware cache mechanism |
US9195488B2 (en) | 2011-11-21 | 2015-11-24 | International Business Machines Corporation | Image deployment in a cloud environment |
US9081787B2 (en) | 2011-11-21 | 2015-07-14 | International Business Machines Corporation | Customizable file-type aware cache mechanism |
US9195489B2 (en) | 2011-11-21 | 2015-11-24 | International Business Machines Corporation | Image deployment in a cloud environment |
US9742860B2 (en) * | 2012-02-28 | 2017-08-22 | International Business Machines Corporation | Bi-temporal key value cache system |
US8775727B2 (en) | 2012-08-31 | 2014-07-08 | Lsi Corporation | Lookup engine with pipelined access, speculative add and lock-in-hit function |
US20150199354A1 (en) * | 2012-11-20 | 2015-07-16 | Netapp, Inc. | Method and system for optimizing traversal and storage of directory entries of a storage volume |
US9009206B1 (en) * | 2012-11-20 | 2015-04-14 | Netapp, Inc. | Method and system for optimizing traversal and storage of directory entries of a storage volume |
US9336255B2 (en) * | 2012-11-20 | 2016-05-10 | Netapp, Inc. | Techniques for traversal and storage of directory entries of a storage volume |
CN103118099B (en) * | 2013-01-25 | 2016-03-02 | 福建升腾资讯有限公司 | Based on the graph image caching method of hashing algorithm |
CN103118099A (en) * | 2013-01-25 | 2013-05-22 | 福建升腾资讯有限公司 | Hash algorithm based graphic image caching method |
US9146841B2 (en) * | 2013-03-15 | 2015-09-29 | Vmware, Inc. | Proxy server assisted product testing |
US20140282420A1 (en) * | 2013-03-15 | 2014-09-18 | Vmware, Inc. | Test automation booster |
US9710514B1 (en) * | 2013-06-25 | 2017-07-18 | Marvell International Ltd. | Systems and methods for efficient storage access using metadata |
US9195599B2 (en) | 2013-06-25 | 2015-11-24 | Globalfoundries Inc. | Multi-level aggregation techniques for memory hierarchies |
CN103744897A (en) * | 2013-12-24 | 2014-04-23 | 华为技术有限公司 | Associated search method and associated search system for fault information, and network management system |
US10098051B2 (en) | 2014-01-22 | 2018-10-09 | Cisco Technology, Inc. | Gateways and routing in software-defined manets |
US9954678B2 (en) | 2014-02-06 | 2018-04-24 | Cisco Technology, Inc. | Content-based transport security |
CN104866521B (en) * | 2014-02-20 | 2018-10-12 | 株式会社特迈数据 | Handle the device and method of the inquiry in the database with mixing memory |
US9904708B2 (en) * | 2014-02-20 | 2018-02-27 | TmaxData Co., Ltd. | Apparatus and method for processing query in database with hybrid storage |
CN104866521A (en) * | 2014-02-20 | 2015-08-26 | 株式会社特迈数据 | Apparatus For Processing Query In Database With Hybrid Storages |
US20150234898A1 (en) * | 2014-02-20 | 2015-08-20 | TmaxData Co., Ltd. | Apparatus and method for processing query in database with hybrid storage |
US10445380B2 (en) | 2014-03-04 | 2019-10-15 | Cisco Technology, Inc. | System and method for direct storage access in a content-centric network |
US9836540B2 (en) | 2014-03-04 | 2017-12-05 | Cisco Technology, Inc. | System and method for direct storage access in a content-centric network |
US9626413B2 (en) | 2014-03-10 | 2017-04-18 | Cisco Systems, Inc. | System and method for ranking content popularity in a content-centric network |
US9716622B2 (en) | 2014-04-01 | 2017-07-25 | Cisco Technology, Inc. | System and method for dynamic name configuration in content-centric networks |
US9473576B2 (en) | 2014-04-07 | 2016-10-18 | Palo Alto Research Center Incorporated | Service discovery using collection synchronization with exact names |
US9992281B2 (en) | 2014-05-01 | 2018-06-05 | Cisco Technology, Inc. | Accountable content stores for information centric networks |
US9609014B2 (en) | 2014-05-22 | 2017-03-28 | Cisco Systems, Inc. | Method and apparatus for preventing insertion of malicious content at a named data network router |
US10158656B2 (en) | 2014-05-22 | 2018-12-18 | Cisco Technology, Inc. | Method and apparatus for preventing insertion of malicious content at a named data network router |
US9699198B2 (en) | 2014-07-07 | 2017-07-04 | Cisco Technology, Inc. | System and method for parallel secure content bootstrapping in content-centric networks |
US9621354B2 (en) | 2014-07-17 | 2017-04-11 | Cisco Systems, Inc. | Reconstructable content objects |
US10237075B2 (en) | 2014-07-17 | 2019-03-19 | Cisco Technology, Inc. | Reconstructable content objects |
US9729616B2 (en) | 2014-07-18 | 2017-08-08 | Cisco Technology, Inc. | Reputation-based strategy for forwarding and responding to interests over a content centric network |
US9929935B2 (en) | 2014-07-18 | 2018-03-27 | Cisco Technology, Inc. | Method and system for keeping interest alive in a content centric network |
US9590887B2 (en) | 2014-07-18 | 2017-03-07 | Cisco Systems, Inc. | Method and system for keeping interest alive in a content centric network |
US10305968B2 (en) | 2014-07-18 | 2019-05-28 | Cisco Technology, Inc. | Reputation-based strategy for forwarding and responding to interests over a content centric network |
US9535968B2 (en) * | 2014-07-21 | 2017-01-03 | Palo Alto Research Center Incorporated | System for distributing nameless objects using self-certifying names |
US20160019275A1 (en) * | 2014-07-21 | 2016-01-21 | Palo Alto Research Center Incorporated | System for distributing nameless objects using self-certifying names |
US9882964B2 (en) | 2014-08-08 | 2018-01-30 | Cisco Technology, Inc. | Explicit strategy feedback in name-based forwarding |
US9729662B2 (en) | 2014-08-11 | 2017-08-08 | Cisco Technology, Inc. | Probabilistic lazy-forwarding technique without validation in a content centric network |
US9800637B2 (en) | 2014-08-19 | 2017-10-24 | Cisco Technology, Inc. | System and method for all-in-one content stream in content-centric networks |
US10367871B2 (en) | 2014-08-19 | 2019-07-30 | Cisco Technology, Inc. | System and method for all-in-one content stream in content-centric networks |
US20170237825A1 (en) * | 2014-08-27 | 2017-08-17 | Huawei Technologies Co., Ltd. | Resource Download Method, Electronic Device, and Apparatus |
US10462258B2 (en) * | 2014-08-27 | 2019-10-29 | Huawei Technologies Co., Ltd. | Resource download method, electronic device, and apparatus |
US10979532B2 (en) | 2014-08-27 | 2021-04-13 | Huawei Technologies, Co., Ltd. | Resource download method, electronic device, and apparatus |
US10715634B2 (en) | 2014-10-23 | 2020-07-14 | Cisco Technology, Inc. | System and method for creating virtual interfaces based on network characteristics |
US10069933B2 (en) | 2014-10-23 | 2018-09-04 | Cisco Technology, Inc. | System and method for creating virtual interfaces based on network characteristics |
US9590948B2 (en) | 2014-12-15 | 2017-03-07 | Cisco Systems, Inc. | CCN routing using hardware-assisted hash tables |
US10237189B2 (en) | 2014-12-16 | 2019-03-19 | Cisco Technology, Inc. | System and method for distance-based interest forwarding |
US10003520B2 (en) | 2014-12-22 | 2018-06-19 | Cisco Technology, Inc. | System and method for efficient name-based content routing using link-state information in information-centric networks |
US9660825B2 (en) | 2014-12-24 | 2017-05-23 | Cisco Technology, Inc. | System and method for multi-source multicasting in content-centric networks |
US10091012B2 (en) | 2014-12-24 | 2018-10-02 | Cisco Technology, Inc. | System and method for multi-source multicasting in content-centric networks |
US10440161B2 (en) | 2015-01-12 | 2019-10-08 | Cisco Technology, Inc. | Auto-configurable transport stack |
US9832291B2 (en) | 2015-01-12 | 2017-11-28 | Cisco Technology, Inc. | Auto-configurable transport stack |
US9954795B2 (en) * | 2015-01-12 | 2018-04-24 | Cisco Technology, Inc. | Resource allocation using CCN manifests |
US9946743B2 (en) | 2015-01-12 | 2018-04-17 | Cisco Technology, Inc. | Order encoded manifests in a content centric network |
US9916457B2 (en) | 2015-01-12 | 2018-03-13 | Cisco Technology, Inc. | Decoupled name security binding for CCN objects |
US20160205034A1 (en) * | 2015-01-12 | 2016-07-14 | Palo Alto Research Center Incorporated | Resource allocation using ccn manifests |
US10333840B2 (en) | 2015-02-06 | 2019-06-25 | Cisco Technology, Inc. | System and method for on-demand content exchange with adaptive naming in information-centric networks |
US10075401B2 (en) | 2015-03-18 | 2018-09-11 | Cisco Technology, Inc. | Pending interest table behavior |
US10075402B2 (en) | 2015-06-24 | 2018-09-11 | Cisco Technology, Inc. | Flexible command and control in content centric networks |
US10701038B2 (en) | 2015-07-27 | 2020-06-30 | Cisco Technology, Inc. | Content negotiation in a content centric network |
US9986034B2 (en) | 2015-08-03 | 2018-05-29 | Cisco Technology, Inc. | Transferring state in content centric network stacks |
US9832123B2 (en) | 2015-09-11 | 2017-11-28 | Cisco Technology, Inc. | Network named fragments in a content centric network |
US10419345B2 (en) | 2015-09-11 | 2019-09-17 | Cisco Technology, Inc. | Network named fragments in a content centric network |
US10355999B2 (en) | 2015-09-23 | 2019-07-16 | Cisco Technology, Inc. | Flow control with network named fragments |
US10313227B2 (en) | 2015-09-24 | 2019-06-04 | Cisco Technology, Inc. | System and method for eliminating undetected interest looping in information-centric networks |
US9977809B2 (en) | 2015-09-24 | 2018-05-22 | Cisco Technology, Inc. | Information and data framework in a content centric network |
US10454820B2 (en) | 2015-09-29 | 2019-10-22 | Cisco Technology, Inc. | System and method for stateless information-centric networking |
US20170099342A1 (en) * | 2015-10-04 | 2017-04-06 | Anthony Ko-Ping Chien | Dynamically Served Content |
US10263965B2 (en) | 2015-10-16 | 2019-04-16 | Cisco Technology, Inc. | Encrypted CCNx |
US9912776B2 (en) | 2015-12-02 | 2018-03-06 | Cisco Technology, Inc. | Explicit content deletion commands in a content centric network |
US20170170955A1 (en) * | 2015-12-09 | 2017-06-15 | Palo Alto Research Center Incorporated | Key catalogs in a content centric network |
US10097346B2 (en) * | 2015-12-09 | 2018-10-09 | Cisco Technology, Inc. | Key catalogs in a content centric network |
US10581967B2 (en) | 2016-01-11 | 2020-03-03 | Cisco Technology, Inc. | Chandra-Toueg consensus in a content centric network |
US10257271B2 (en) | 2016-01-11 | 2019-04-09 | Cisco Technology, Inc. | Chandra-Toueg consensus in a content centric network |
US10305864B2 (en) | 2016-01-25 | 2019-05-28 | Cisco Technology, Inc. | Method and system for interest encryption in a content centric network |
US11301422B2 (en) * | 2016-02-23 | 2022-04-12 | Samsung Electronics Co., Ltd. | System and methods for providing fast cacheable access to a key-value device through a filesystem interface |
US10043016B2 (en) | 2016-02-29 | 2018-08-07 | Cisco Technology, Inc. | Method and system for name encryption agreement in a content centric network |
US10742596B2 (en) | 2016-03-04 | 2020-08-11 | Cisco Technology, Inc. | Method and system for reducing a collision probability of hash-based names using a publisher identifier |
US10051071B2 (en) | 2016-03-04 | 2018-08-14 | Cisco Technology, Inc. | Method and system for collecting historical network information in a content centric network |
US10003507B2 (en) | 2016-03-04 | 2018-06-19 | Cisco Technology, Inc. | Transport session state protocol |
US10264099B2 (en) | 2016-03-07 | 2019-04-16 | Cisco Technology, Inc. | Method and system for content closures in a content centric network |
US10067948B2 (en) | 2016-03-18 | 2018-09-04 | Cisco Technology, Inc. | Data deduping in content centric networking manifests |
US10091330B2 (en) | 2016-03-23 | 2018-10-02 | Cisco Technology, Inc. | Interest scheduling by an information and data framework in a content centric network |
US10320760B2 (en) | 2016-04-01 | 2019-06-11 | Cisco Technology, Inc. | Method and system for mutating and caching content in a content centric network |
US10348865B2 (en) | 2016-04-04 | 2019-07-09 | Cisco Technology, Inc. | System and method for compressing content centric networking messages |
US9930146B2 (en) | 2016-04-04 | 2018-03-27 | Cisco Technology, Inc. | System and method for compressing content centric networking messages |
US10425503B2 (en) | 2016-04-07 | 2019-09-24 | Cisco Technology, Inc. | Shared pending interest table in a content centric network |
US10649793B2 (en) * | 2016-05-06 | 2020-05-12 | Zte Corporation | Application synchronization method and device |
US20190155621A1 (en) * | 2016-05-06 | 2019-05-23 | Zte Corporation | Application Synchronization Method and Device |
US10693852B2 (en) | 2016-05-13 | 2020-06-23 | Cisco Technology, Inc. | System for a secure encryption proxy in a content centric network |
US10084764B2 (en) | 2016-05-13 | 2018-09-25 | Cisco Technology, Inc. | System for a secure encryption proxy in a content centric network |
US10404537B2 (en) | 2016-05-13 | 2019-09-03 | Cisco Technology, Inc. | Updating a transport stack in a content centric network |
US10063414B2 (en) | 2016-05-13 | 2018-08-28 | Cisco Technology, Inc. | Updating a transport stack in a content centric network |
US10103989B2 (en) | 2016-06-13 | 2018-10-16 | Cisco Technology, Inc. | Content object return messages in a content centric network |
US10305865B2 (en) | 2016-06-21 | 2019-05-28 | Cisco Technology, Inc. | Permutation-based content encryption with manifests in a content centric network |
US10581741B2 (en) | 2016-06-27 | 2020-03-03 | Cisco Technology, Inc. | Method and system for interest groups in a content centric network |
US10148572B2 (en) | 2016-06-27 | 2018-12-04 | Cisco Technology, Inc. | Method and system for interest groups in a content centric network |
US10009266B2 (en) | 2016-07-05 | 2018-06-26 | Cisco Technology, Inc. | Method and system for reference counted pending interest tables in a content centric network |
US9992097B2 (en) | 2016-07-11 | 2018-06-05 | Cisco Technology, Inc. | System and method for piggybacking routing information in interests in a content centric network |
US10122624B2 (en) | 2016-07-25 | 2018-11-06 | Cisco Technology, Inc. | System and method for ephemeral entries in a forwarding information base in a content centric network |
US10069729B2 (en) | 2016-08-08 | 2018-09-04 | Cisco Technology, Inc. | System and method for throttling traffic based on a forwarding information base in a content centric network |
US10956412B2 (en) | 2016-08-09 | 2021-03-23 | Cisco Technology, Inc. | Method and system for conjunctive normal form attribute matching in a content centric network |
US10033642B2 (en) | 2016-09-19 | 2018-07-24 | Cisco Technology, Inc. | System and method for making optimal routing decisions based on device-specific parameters in a content centric network |
US10897518B2 (en) | 2016-10-03 | 2021-01-19 | Cisco Technology, Inc. | Cache management on high availability routers in a content centric network |
US10212248B2 (en) | 2016-10-03 | 2019-02-19 | Cisco Technology, Inc. | Cache management on high availability routers in a content centric network |
US10447805B2 (en) | 2016-10-10 | 2019-10-15 | Cisco Technology, Inc. | Distributed consensus in a content centric network |
US10721332B2 (en) | 2016-10-31 | 2020-07-21 | Cisco Technology, Inc. | System and method for process migration in a content centric network |
US10135948B2 (en) | 2016-10-31 | 2018-11-20 | Cisco Technology, Inc. | System and method for process migration in a content centric network |
US10243851B2 (en) | 2016-11-21 | 2019-03-26 | Cisco Technology, Inc. | System and method for forwarder connection information in a content centric network |
US20230093873A1 (en) * | 2021-09-24 | 2023-03-30 | Apple Inc. | Generation of transaction tags for enhanced searching |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6915307B1 (en) | High performance object cache | |
US6453319B1 (en) | Maintaining counters for high performance object cache | |
US6289358B1 (en) | Delivering alternate versions of objects from an object cache | |
US6209003B1 (en) | Garbage collection in an object cache | |
US6292880B1 (en) | Alias-free content-indexed object cache | |
US6128627A (en) | Consistent data storage in an object cache | |
US6754799B2 (en) | System and method for indexing and retrieving cached objects | |
US7269608B2 (en) | Apparatus and methods for caching objects using main memory and persistent memory | |
US6389460B1 (en) | Method and apparatus for efficient storage and retrieval of objects in and from an object storage device | |
EP1540498B1 (en) | Apparatus and method for proxy cache | |
US8433735B2 (en) | Scalable system for partitioning and accessing metadata over multiple servers | |
US20020032691A1 (en) | High performance efficient subsystem for data object storage | |
US7284030B2 (en) | Apparatus and method for processing data in a network | |
US5950198A (en) | Processes and apparatuses for generating file correspondency through replication and synchronization between target and source computers | |
US7539818B2 (en) | Network object cache engine | |
US8682856B2 (en) | Method and system for processing query messages over a network | |
US7647417B1 (en) | Object cacheability with ICAP | |
US7805416B1 (en) | File system query and method of use | |
US7203709B2 (en) | Transaction-aware caching for access control metadata | |
US20030200197A1 (en) | Transaction-aware caching for document metadata | |
JP2006107446A (en) | Batch indexing system and method for network document | |
US7249219B1 (en) | Method and apparatus to improve buffer cache hit rate | |
US20040117437A1 (en) | Method for efficient storing of sparse files in a distributed cache | |
Iyengar | Design and performance of a general-purpose software cache | |
Zhang et al. | Efficient search in large textual collections with redundancy |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: YAHOO| INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INKTOMI CORPORATION;REEL/FRAME:018361/0511Effective date: 20060612 |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:YAHOO| INC.;REEL/FRAME:033868/0257Effective date: 20140630 |
|
AS | Assignment |
Owner name: INKTOMI CORPORATION, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:MATTIS, PETER;PLEVYAK, JOHN;HAINES, MATTHEW;AND OTHERS;SIGNING DATES FROM 19980708 TO 19980709;REEL/FRAME:034221/0643 |
|
FPAY | Fee payment |
Year of fee payment: 12 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |