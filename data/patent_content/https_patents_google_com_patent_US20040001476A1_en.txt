US20040001476A1 - Mobile application environment - Google Patents
Mobile application environment Download PDFInfo
- Publication number
- US20040001476A1 US20040001476A1 US10/179,929 US17992902A US2004001476A1 US 20040001476 A1 US20040001476 A1 US 20040001476A1 US 17992902 A US17992902 A US 17992902A US 2004001476 A1 US2004001476 A1 US 2004001476A1
- Authority
- US
- United States
- Prior art keywords
- mervlet
- application
- server
- network
- attributes
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Abandoned
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/54—Interprogram communication
- G06F9/546—Message passing systems or structures, e.g. queues
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L63/00—Network architectures or network communication protocols for network security
- H04L63/20—Network architectures or network communication protocols for network security for managing network security; network security policies in general
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L67/00—Network arrangements or protocols for supporting network services or applications
- H04L67/01—Protocols
- H04L67/12—Protocols specially adapted for proprietary or special-purpose networking environments, e.g. medical networks, sensor networks, networks in vehicles or remote metering networks
- H04L67/125—Protocols specially adapted for proprietary or special-purpose networking environments, e.g. medical networks, sensor networks, networks in vehicles or remote metering networks involving control of end-device applications over a network
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04W—WIRELESS COMMUNICATION NETWORKS
- H04W12/00—Security arrangements; Authentication; Protecting privacy or anonymity
- H04W12/30—Security of mobile devices; Security of mobile applications
- H04W12/37—Managing security policies for mobile devices or for controlling mobile applications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04W—WIRELESS COMMUNICATION NETWORKS
- H04W12/00—Security arrangements; Authentication; Protecting privacy or anonymity
- H04W12/60—Context-dependent security
- H04W12/66—Trust-dependent, e.g. using trust scores or trust relationships
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04W—WIRELESS COMMUNICATION NETWORKS
- H04W80/00—Wireless network protocols or protocol adaptations to wireless operation
Definitions
- the present invention relates generally to a mobile application environment.
- it relates to a mobile application environment that can load balance mobile applications capable of creating dynamic web pages across heterogeneous mobile communication networks using a messaging system compatible with multiple low level transport protocols to optimize their user perceived performance.
- mobile devices pose several challenges for application developers. For example, mobile devices typically have more limited hardware resources than conventional computers. In addition, mobile devices tend to have widely varying hardware configurations, including differences in computation power, memory size, display capability, means for inputting data, etc. Mobile communication networks also experience limited network bandwidth and network availability. Consequently, mobile devices may be connected, intermittently connected or disconnected from a network.
- the first generation mobile devices typically were request-only devices or devices that could merely request services and information from more intelligent and resource rich server computers.
- the servers used standard software architectures, such as the Java 2 Enterprise Edition (J2EE) platform.
- J2EE Java 2 Enterprise Edition
- the server platforms could define and support a programming model that allows thin-client applications to invoke logic instructions that execute on the servers.
- a mobile application environment for a mervlet application forms part of a mobile communication network comprising at least one access network.
- the environment comprises the mervlet, which includes instructions to create a web page with dynamically generated content.
- the mervlet is capable of executing on at least one of a local node and a remote node of the network.
- the environment also comprises a set of application attributes for the mervlet, including performance attributes characterizing the user interface of the mervlet.
- the environment further comprises a set of security attributes for the mervlet defining a security context in which to execute the mervlet.
- the environment comprises a mervlet engine that is operative to manage a lifecycle of the mervlet.
- the engine includes a core interpreter module operative to execute the mervlet in the security context defined by its security attributes.
- the engine also includes a policy module operative to determine whether to relocate the mervlet and the application attributes between said local and remote network nodes and the security attributes among computing devices in the network and to switch the access network using the application attributes to improve a user perceived performance of the mervlet.
- the environment next includes a cache manager agent operative to manage cache memory of the local and remote network nodes for receiving and storing the mervlet.
- the environment includes a messaging system operative to deliver content of the mervlet and the mervlet itself across the network.
- FIG. 1 is a block diagram showing the system components of a Mervlet application environment according to the present invention
- FIG. 2 is a flow chart showing the details of the operation of the Mervlet application environment of FIG. 1;
- FIG. 3 is block diagram showing a high level view of a mobile communication network for the Mervlet application environment of FIG. 1;
- FIG. 4 is a block diagram showing the structure of a Mervlet application and its attributes for the Mervlet application environment of FIG. 1;
- FIG. 5 is a block diagram showing the lifecycle of a Mervlet application for the Mervlet application environment of FIG. 1;
- FIG. 6 is a block diagram showing the steps in and overall structure of the Mervlet engine for the Mervlet application environment of FIG. 1;
- FIG. 7 is a block diagram showing a timeline for user interface events for the Mervlet application environment of FIG. 1;
- FIG. 8 is a table summarizing the performance attributes and system attributes for the Mervlet application environment of FIG. 1;
- FIG. 9 is a flowchart showing details of the application provisioning optimization for load balancing a Mervlet for the Mervlet application environment of FIG. 1;
- FIG. 10 is a flowchart showing details of the network switching optimization for load balancing a Mervlet for the Mervlet application environment of FIG. 1;
- FIG. 11 is a block diagram showing the interface between a reliable message system and a Mervlet engine for the Mervlet application environment of FIG. 1;
- FIG. 12 is a diagram showing the structure of a message for the reliable messaging system of FIG. 11;
- FIG. 13 is a chart showing details of the operation of the reliable messaging system of FIG. 11.
- FIG. 14 is a table showing different configurations and the associated performance costs for the reliable messaging system of FIG. 11.
- a Mervlet 10 is an executable application program capable of creating dynamic web pages for mobile computing devices.
- a Mervlet 10 comprises uninterpreted code that includes both user interface logic for creating a web page and application logic for generating dynamic content for the page.
- a Mervlet 10 can further comprise local static data and can access data files, such as ASCII text files.
- a Mervlet 10 has a unique set of application attributes that are associated with it. These attributes make it possible to dynamically load balance a Mervlet 10 at load time and runtime across a communications network.
- a Mervlet 10 also can run in its own security context on various devices in a network using the same set of security attributes associated with the Mervlet. Accordingly, a Mervlet 10 has the features of a relocatable dynamic web document.
- Mervlets execute under the control of a Mervlet runtime engine 12 , which includes customized tag libraries 14 , a set of components for system services 16 and a core interpreter 18 .
- the Mervlet engine 12 may be configured to be self-recoverable so that it is able to restart execution of a set of Mervlets that were running at the time of a system failure.
- the Mervlet engine 12 can use a messaging system 20 to deliver content across a network to a client device from a Mervlet that is executing remotely or to deliver Mervlets themselves for load balancing.
- the Mervlet engine can use point to point asynchronous messaging to communicate requests to and replies from a Mervlet and also to transmit the Mervlet itself.
- the Mervlet application environment supports a reliable messaging system that can recover from transient network and device failures and guarantee the delivery of a message to its endpoint.
- the reliable messaging system can be configurable to allow a user to choose a device for buffering messages for different recovery options.
- Those skilled in the art will readily recognize that other messaging systems could be used, including systems that use remote procedure calls transported by HTTP, SMTP or a similar transport protocol.
- the Mervlet engine 12 can also interface with a configurable cache manager 22 for caching Mervlets locally on a device to hide network disconnections. If a device cache is programmable, then Mervlet specific caching policies can be downloaded to the device. The caching mechanism allows the cache manager to dynamically change its cache management policies.
- a mobile device or user client device (UCD) 30 forming part of a communications network generates a request for a Mervlet 10 in step 10 .
- the UCD 30 runs the Mervlet application environment and can display information using a web browser, such as Internet Explorer and Pocket Internet Explorer from Microsoft Corp. and Netscape Navigator from Netscape Communications Corp.
- the UCD 30 generates a request for the Mervlet 10 using a Uniform Resource Identifier (“URI”).
- URI Uniform Resource Identifier
- the URI encodes the name and address of an object, including a Mervlet, in a registered name space on the network to allow access to the object using an Internet access protocol.
- the requesting UCD 30 may be able to execute the Mervlet 10 locally or obtain content from the Mervlet 10 when it is executing remotely.
- the requested Mervlet 10 may be stored locally on the requesting UCD 30 or on a remote node of the network with sufficient memory and processing capacities to execute the Mervlet (“primary server”) 32 , which may be another UCD 34 or a computer server class device 36 .
- the requesting UCD 30 can locate a primary server 32 using existing resource discovery techniques, such as JINI from Sun Microsystems, in step 12 .
- the primary server 32 must be able to execute the Mervlet 10 or locate a secondary server, not shown, on the network to execute the Mervlet 10 . In the latter case, the primary server 32 must send the Mervlet 10 to the secondary server and forward the request from the requesting UCD 30 .
- the UCD 30 and the primary server 32 may communicate over one or more access networks 38 .
- the requesting UCD 30 first checks to see if the Mervlet 10 is stored in a local cache on the device in step 14 . If it is, then the Mervlet 10 is executed there and then in step 16 . Otherwise, the requesting UCD 30 communicates with the primary server 32 to get “access” to the requested Mervlet 10 in step 18 . The primary server 32 then invokes a load balancing policy on the Mervlet 10 in step 20 to optimize the user perceived performance of the Mervlet 10 . For example, the primary server 32 may decide to run the Mervlet 10 locally (step 22 ) or to relocate it to the requesting UCD 30 (step 24 ). In some cases, the UCD 30 may make an explicit request to run the Mervlet 10 at its site. However, the primary server 32 can ignore that request. If the Mervlet 10 is executed on the primary server 32 in step 22 , the result is transmitted back to the UCD 30 via the messaging system of the Mervlet application environment.
- the primary server 32 can determine whether to run the Mervlet 10 locally or on the requesting UCD 30 based on several attributes, including: 1) the memory and processing capacities on the UCD and server nodes, 2) the load on each of the two nodes and the network bandwidth and latency, and 3) a set of attributes relating to the performance of the Mervlet. For example, the server may determine to run the Mervlet on the UCD if the Mervlet is highly user interactive, for example a gaming application, and the UCD has sufficient hardware resources to execute the Mervlet. On the other hand, if the Mervlet is data or computationally intensive rather than interactive, for example a personalization application, then the server may determine to run the Mervlet itself. However, those skilled in the art will clearly recognize that other load balancing decisions are also possible based on the parameters that the system monitors. For example, the primary server 32 and the UCD 30 can implement a network switching policy to switch access networks 38 between the devices for improved communication.
- a Mervlet 10 defines the user interface for a web page to display dynamically generated content on a mobile device.
- the structure of a Mervlet 10 is shown in FIG. 4.
- the Mervlet 10 uses platform independent user interface logic 40 such as markup language instructions to control the formatting and display a web page. It can also handle requests and replies from a web browser.
- a Mervlet can support web pages using static HTML, DHTML, XHTML, XML and similar formatting tags that can be interpreted by a web browser.
- the Mervlet 10 uses XML-like tags to encapsulate application logic 42 that generates the dynamic content for the web page.
- the application logic 42 itself can reside in server-based resources that the web page accesses with these tags, such as JavaBeans or customized Mervlet tag libraries.
- Mervlet tag libraries may be native to the application environment on a particular device or they may move with a Mervlet when a Mervlet is relocated during load balancing. Therefore, the Mervlet 10 separates the user interface of a dynamic web page from content generation for a reusable component-based design that is platform independent.
- the Mervlet 10 can make network connections via the messaging system 20 and can access local data files. Therefore, the application model for a Mervlet includes user interface logic 40 , application logic 42 , file access 46 and network access 44 .
- a set of novel application attributes 50 comprising performance attributes 52 and system attributes 54 are associated with the Mervlet 10 for dynamically load balancing the Mervlet in a network.
- the Mervlet 10 may be dynamically relocated at load time and run time across a mobile communications network using its application attributes 50 , as described further below.
- the Mervlet 10 also can execute in its own security context based on a set of associated security attributes 56 .
- a containment model determines what resources are available to a user.
- a class loader and affiliated classes are modified with a policy mechanism discussed in “A flexible security model for using internet content,” Islam et al, IEEE Software, 1997, which is incorporated herein by reference, with the exception that a protection domain may be set by the UCD.
- the class loader creates a security context in which to run the Mervlet 10 .
- Mervlets are signed and verified by a device before they are run.
- a policy module configured using the security attributes 56 implements policy for who to trust and what operations are allowed.
- the Mervlet engine 12 can monitors at runtime any access by the Mervlet 10 and kills the Mervlet if it attempts to run outside of its security context.
- the security context for a Mervlet 10 can be moved and recreated on different devices in a network by relocating the security attributes 56 along with the Mervlet 10 .
- JSP JavaServer Pages
- Sun Microsystems which is available via URL http://java.sun.com/products/jsp/whitepaper.html and is incorporated herein by reference.
- a Mervlet 10 can be implemented as a Java application component derived from the JSP model. Such a Mervlet implementation can access the J2ME CDC environment and the resource files used by Java classes, except that it does not have access to JNDI, JMS, JTA, JAF, Java Mail, RMI, JDBC and IIOP classes. In addition, the JSP derived Mervlet does not have access to AWT or SWING classes. The J2ME based implementation of the Mervlet also disallows scripts inside a web page processed by the Mervlet. These restrictions may exist on all nodes of a network that implement the Mervlet application environment in order to optimize the Mervlet implementation for thin client devices having limited hardware resources. Accordingly, Mervlets are platform-independent and can leverage existing Java platform technologies while meeting thin client requirements.
- the J2ME based implementation of the Mervlet application environment changes the semantics of traditional JSP and Servlet execution, such as determining when and where to execute Mervlets, instead of solely making changes to the JSP application programming interfaces (“APIs”). This implementation will now be described in greater detail below.
- a Mervlet 10 is compiled and executed on a Mervlet engine 12 , as shown in FIG. 1.
- the engine 12 can process requests from a client application such as a web browser to the Mervlet 10 and generate responses from the Mervlet 10 to the client browser.
- the Mervlet engine 12 interprets the Mervlet tags for the application logic 42 and generates corresponding dynamic content by accessing a resource or tag library, which could be native to the device or relocatable with a Mervlet 10 .
- the engine 12 then sends the results back in the form of an HTML or XML page to the requesting web browser. Any static formatting tags are passed directly to the requesting web browser.
- the Mervlet engine 12 can run on the J2ME CDC platform for thin client devices and the J2EE platform for server class devices.
- the J2ME platform traditionally requires a 32 bit CPU and at least 2 megabytes of memory.
- the J2EE platform traditionally requires at least an Intel Pentium III class processor, 128 megabytes of RAM memory, and 300 megabytes of persistent storage.
- One possible configuration for a Mervlet application environment according to the present invention that supports a Mervlet engine 12 that consumes up to 6 megabytes at runtime would include at least a 32 bit CPU, 10 megabytes of RAM memory, and 40 megabytes of persistent storage.
- these values for the Mervlet application environment are meant to be illustrative, rather than limiting.
- the Mervlet engine 12 can replace the web container and Servlet engine models in J2EE. Therefore, the Mervlet engine 12 can provide a Mervlet 10 with access to Java Virtual Machine (JVM), PersonalJava Virtual Machine (PJVM) or other type of Virtual Machine (VM).
- JVM Java Virtual Machine
- PJVM PersonalJava Virtual Machine
- VM Virtual Machine
- VM which runs on top of the native operating system of a device, acts like an abstract computing machine, receiving Java bytecodes and interpreting them by dynamically converting them into a form for execution by the native operating system.
- a Mervlet engine 12 manages the lifecycle of a Mervlet 10 via a set of application programming interfaces (APIs), as shown in FIG. 5.
- the actions that the Mervlet engine performs include finding the Mervlet requested by a client application on a network in step 30 .
- the requested Mervlet may be stored either on the requesting client or on a primary server.
- the Mervlet engine creates an instance of the Mervlet, loads it into the engine's memory and initializes it in step 32 . Once initialized, the Mervlet is ready to receive information and the Mervlet engine can pass requests and process replies from the Mervlet in step 34 .
- the Mervlet engine destroys the Mervlet and removes its presence from the engine memory and any data in persistent storage associated with the Mervlet in step 36 .
- the Mervlet engine can restart a Mervlet after a crash in step 38 .
- the Mervlet engine may also notify a Mervlet at any time that it needs to save its state in step 40 .
- the ability of the Mervlet engine to recover from a crash using these actions is described in further detail below in connection with the fault tolerance for the Mervlet application environment.
- the following are an exemplary set of APIs for implementing Mervlets on a Mervlet engine based on the J2ME platform.
- the Mervlet APIs are derived from the standard Java classes for interfaces for Java Servlets.
- the Mervlet implementation creates a “javax.mervlet” subclass of the “javax.servlet” class.
- the class “Mervlet” has three important methods: public void init( ) throws “MervletException”; public void service( ) throws “MervletException”; and public void destroy( ) throws “MervletException”;
- the method “init( )” is called by the Mervlet engine to initialize the Mervlet. It must be called after the Mervlet is found and a class loader has been invoked on the Mervlet. The method “init( )” must be called before any calls to the method “Service( )” are allowed. The method “service( )” is called on the Mervlet to allow the Mervlet engine to pass requests and process replies from the Mervlet. The Mervlet is destroyed by calling the method “destroy ( )” on the Mervlet.
- the method Restore( ) is called by a Mervlet engine prior to the method init( ) to restore its own state when attempting to recover Mervlets following a crash.
- the method Save( ) may be called by a Mervlet engine at any time to notify a Mervlet to save its application state. However, Mervlets should not assume that the method Save( ) will be called prior to a crash.
- the class “MervletContext” specifies resources available to a Mervlet. It is an extension of the class “ServeletContext” and includes the following additional resources: i) files for use with the Mervlet; ii) a set of attributes relating to the performance of the Mervlet, including user interface and I/O characteristics as described further below; and iii) resource rights for the Mervlet.
- the class “MervletContext” also includes methods to get and set each of these resources.
- the classes “MervletRequest” and “MerveletResponse” are extensions of the classes “ServeletRequest” and “ServeletResponse” respectively.
- the Mervlet engine generates requests and responses using the following abstract messaging method: void Reliable_async_send(Endpoint to, Endpoint From, DataStream Data, Reliability Type, CallbackMethod cm).
- FIG. 6 the functional block diagram showing the operation of the Mervlet engine 12 in response to a request for a Mervlet 10 from a client application or browser 60 on a user client device 30 is now described.
- the Mervlet engine 12 on the requesting client 30 must find the Mervlet 10 .
- the engine itself is constructed from simple Mervlet components.
- a “MervletFinder” module 62 intercepts all calls in the client 30 that request to load Mervlets.
- the module MervletFinder 62 searches the local cache on the client 30 for the Mervlet 10 that has been requested using known hash functions exported by the cache.
- the module MervletFinder 62 allocates memory for the Mervlet and reads in the Mervlet from the local cache. The module MervletFinder 62 then calls the method “init( )” on the Mervlet 10 , passing the configuration data for the requested Mervlet to initialize the newly created instance of the Mervlet. When the Mervlet 10 is finished, it calls the method “destroy( )” on itself. If the Mervlet engine 12 wants to remove the Mervlet 10 , it can call the method “destroy( )” on it.
- the module MervletFinder 62 determines that the requested Mervlet 10 is not on the client 30 because there was no match in the local cache, then it queries a primary server device 32 for the Mervlet 10 .
- the query to the server 32 contains the name of the Mervlet 10 , the CPU utilization on the client device 30 , the MIPS rating of the client device 30 , the available memory and the persistent storage on the client device 30 , and any performance attributes of the Mervlet 10 if available. This information may be used by the primary server 32 to determine whether to relocate the Mervlet 10 to the client 30 or switch access networks 38 for communication between the server 32 and client 30 using a load balancing scheme described below in further detail.
- the Mervlet engine 12 also includes a module “InterceptingMervlet” 64 , which intercepts requests for the Mervlet 10 arriving at the primary server 32 . When requests arrive for the Mervlet 10 from the network, the module InterceptingMervelt 64 dispatches the messages to the Mervlet 10 on the server 32 . In response to a request for the Mervlet 10 , the module InterceptingMervlet 64 also calls a module “PolicyMervlet” 66 and passes the system performance parameters for the requesting client 30 to it. The module PolicyMervlet 66 then determines how to load balance the Mervlet 10 to optimize its user perceived performance. The module PolicyMervlet 66 is set by a system administrator. In addition, the primary server 32 may entertain multiple requests from clients simultaneously and hence the modules PolicyMervlet 66 and InterceptingMervlet 64 are multi-threaded.
- the primary server 32 and the client 30 can load balance the Mervlet 10 as follows.
- the server 32 can choose to execute the Mervlet 10 on the server machine and let the requesting client interact 30 with the Mervlet remotely.
- the server 32 can decide to send the Mervlet 10 to the client 30 for execution on the client device.
- the module PolicyMervlet 66 determines whether to relocate the Mervlet 10 using an application provisioning scheme, which is described below in further detail.
- either the server 32 or the client 30 may choose to switch access networks 38 for communicating with each other using a network switching scheme, which is described in further detail below.
- the module PolicyMervlet 66 retrieves the Mervlet 10 from the server's cache and allocates memory for it using a method “new( )”. Then, the method “init( )” is invoked on the Mervlet 10 using the appropriate Mervlet context.
- the initialized instance of the Mervlet 10 assumes the credentials of the requesting client when the semantics of security are the same as those in J2EE. After the instance of the requested Mervlet 10 has been initialized, it can access local data on the server.
- the Mervlet 10 can also communicate with client applications on the client 30 through the messaging system 20 , as described below in further detail. Accordingly, the Mervlet engine 12 sends the output from the Mervlet 10 directly to the requesting client 30 . Finally, the Mervlet 10 can be destroyed by calling the method “destroy( )” on the Mervlet.
- the module PolicyMervlet 66 determines that the requested Mervlet 10 should run on the requesting client 30 , then the Mervlet is marshaled and sent to the remote machine.
- the engine 12 packages the Mervlet into a Mervlet archive (“MAR”) file 68 .
- the MAR file 68 preferably comprises 1) the Mervlet 10 and any associated tag libraries 14 , 2) the security context attributes 56 and application attributes 50 for the Mervlet, 3) any data files associated with the Mervlet 10 , and 4) a MAR file manifest describing the contents of the MAR file.
- the MAR file 68 has all the information necessary for the Mervlet engine 12 on the client 30 to create the appropriate Mervlet context to pass to the method “init( )” of the Mervlet 10 when it is started.
- the MAR file 68 may be compressed, hashed and then signed. A downloader may uncompress and verify that the content has not been corrupted and verify the signature.
- the load balancing scheme is based on user interactions with a user client device 30 that is requesting the Mervlet 10 from a server 32 .
- the module PolicyMervlet 66 of the Mervlet engine 12 uses measures of the event wait times for the user interface (“UI”) of the client to optimize the perceived performance of the Mervlet 10 .
- the Mervlet application environment according to the present invention allows load balancing to be performed at application request time and at application runtime.
- the load balancing scheme allows two types of optimizations: application provisioning and network switching.
- An application provisioning policy allows the server to determine which node of the network to run a Mervlet on.
- a network switching policy allows either the requesting client or the server to choose a new access network for communication between the server and the client. This model allows a developer to create a large class of algorithms for load balancing.
- FIG. 7 a timeline for user interface events on a client device is shown in FIG. 7.
- a user moves through alternate think and wait times during user interactions with a Mervlet.
- the user sends a request to a Mervlet and waits for a reply.
- the Mervlet typically waits in a loop for requests from the user.
- the Mervlet may perform computations and data access to fulfill the user's request. It will then send back the reply.
- the timeline shown in FIG. 7 completes one such interaction.
- the wait time W is the time associated with processing a request.
- the wait time W can be broken down into communication time C and server computation time S.
- user experience is based on the mean and variance of the wait times when interacting with the application. Therefore, the performance of a Mervlet can be optimized if its wait times are generally below a predetermined threshold value.
- the load balancing scheme according to the present invention can optimize the mean and variance of the wait times for a Mervlet by relocating the Mervlet from the server closer to the user or switching the access network between the client and the server when appropriate.
- the module PolicyMervlet 66 of the Mervlet engine 12 utilizes a set of application attributes 50 comprising performance attributes 52 and system attributes 54 , which are summarized in FIG. 8 and described in more detail below.
- the application attributes 50 used to load balance a Mervlet 10 include a set of performance attributes 52 that characterize the Mervlet based on two criteria: 1) how interactive the application is, and 2) how computationally and data intensive the application is.
- developers want to provide the system with the ability to move interactive applications closer to the user, to move data intensive applications closer to the source of the data, and to allow a computationally intensive application to run on more powerful devices such as server class machines.
- developers write Java applications as either server applications on J2EE, for example JSPs and Servlets, or as applets for clients. For example, one would traditionally write a game as an applet and a banking application as a server based application.
- Mervlet developers only need to write the application once, and then the PolicyMervlet 66 can utilize measured performance attributes 52 to relocate the Mervlet 10 closer to the user or switch access networks to provide better mean and variance wait times for the Mervlet.
- users wait for events when they interact with a client device 30 and request information from a Mervlet 10 , for example when they post web page forms and click on URLs for information. These actions, including the act of filling in a form and waiting for a response and the act of clicking on a link and getting a page, are referred to as user interface events.
- the Mervlet 10 runs on the client device 30 , all of the wait time W is spent in the application. If the Mervlet 10 is executing remotely from the client device 30 on a server 32 , part of the wait time W is spent communicating with the requesting client, C, while the remainder of the wait time is spent in the Mervlet itself for processing of the client request, S.
- the Mervlet application environment measures the following performance attributes of the Mervlet for each form and URL sending a request to it: the mean and variance of the wait time W, the server computation time S and the communication time C.
- an HTML based client can intercept all “gets” and “posts” from the browser on the client to a Mervlet. This is handled by the module InterceptingMervlet of the Mervlet engine.
- a “get” or “post” is performed, a first timestamp T1 is taken.
- the “get” or “post” returns and the reply generated by the Mervlet is displayed on the browser, a second timestamp T2 is taken.
- the reply message from the Mervlet includes a parameter value indicative of the time spent in computation in the server S. Accordingly, the following calculations can be made:
- T1 First time stamp
- T2 Second time stamp.
- the server 32 maintains a running average of the mean and variance of the server computation time, wait time and communication time, denoted by A(S), A(C), A(W), and V(S), V(C), and V(W) respectively.
- a running average of the mean and variance of the W and C parameters are calculated for each access network used to communicate between the requesting client and the server.
- a ( W ) A ( C )+ A ( S );
- V ( W ) V ( C )+ V ( S )+ Cov ( V,S ),
- V ( W ) V ( C )+ V ( S )
- a load balancing policy for a Mervlet 10 can improve a user's perception of the Mervlet's performance by reducing A(C) and V(C).
- a framework for an algorithm to implement the application provisioning optimization could determine whether the wait time W for the Mervlet 10 is unacceptable by verifying if A(W) is greater than a predetermined threshold value. Also, it could determine whether the communication time C is having an appreciable impact on the wait time W by verifying that A(C) is greater than the A(S). If W is unacceptable and C is appreciable, then the algorithm could attempt to relocate the Mervlet to another device. Otherwise, the Mervlet continues to run on the present device.
- an algorithm framework that could be used to implement the network switching optimization determines whether the mean wait time for a Mervlet 10 using a first access network, A(W-network 1 ), is greater than the mean wait time using a second access network, A(W-network 2 ). If so, the algorithm will switch to the second network, network 2 , for communication to and from the Mervlet.
- the total service time for a Mervlet to generate a reply to a single request from a client application is measured by the server computation time S.
- a Mervlet may spend server computation time S performing internal calculations and also accessing external data files, such that:
- a timer on the server is started when the Mervlet engine on the server calls the method “service( )” on a Mervlet in response to a request from a client applications.
- the timer is stopped.
- the duration for the timer measures the server computation time, S.
- the I/O libraries for the Mervlet engine are instrumented to record the time spent in data I/O, D, and the data I/O rate, DTP.
- the time spent for internal calculations, I can be calculated from the equation above.
- the Mervlet engine can also record the average total time for the Mervlet to run to completion, TotalTime, using a timer on the server. These parameters are made available to Mervlet developers to refine the load balancing algorithms discussed in more detail below.
- the performance attributes 52 for measuring user interface events of a Mervlet 10 are determined by modifying java.net to intercepts all http requests.
- the following method is used to collect information on HTML based forms and URL processing, as described above: void recordEvent( EventType et, Event e, TimeStamp t)
- the data type for the parameter AccessType can be either read or write type. This method writes the measured performance attributes to a file.
- the PolicyMervlet 66 also uses system attributes 54 in addition to application attributes 54 for load balancing and network switching decisions.
- the system attributes 54 relate generally to the resources and processing power of the computing devices used by the Mervlet application environment. In particular, as shown in FIG. 8, the following attributes are recorded for each client 30 and server 32 : the MIPS rating, mean and variance of CPU utilization, the size of memory and persistent storage, and the mean and variance of network latency and bandwidth for each network type available at the device.
- System_network_bandwidth determines network bandwidth between a client 30 and the primary server 32 using access network “a”. The bandwidth is calculated by sending a packet of known size S to the primary server 32 from the client 30 , getting the same size packet back, and then dividing the packet size S by the time it took to get the packet. This computation preferably is performed in the operating system for greater accuracy. Void sys network_load_latency(accessnetwork a, latency I)
- the method sys_network_load_latency(accessnetwork a, latency l) uses Internet Control Message Protocol (ICMP) to determine network latency.
- ICMP Internet Control Message Protocol
- a client periodically sends an ICMP packet to a server and uses the returned values to keep an average value for latency over time.
- a system administrator can set the frequency with which this operation is performed.
- Network_uptime (Netuptime nu, accesslink a) determines the percentage of time that a network connection between a client and a server is up. If an ICMP packet returns, then the system assumes that the network is up, otherwise it is down.
- the application provisioning optimization is run from the server.
- the network switching optimization can be run from the server and the client. There are a variety of ways the client and the server can dynamically profile the application attributes.
- the system attributes of a requesting client can be obtained in the messages from the client by the load balancing algorithms at the server.
- the server can store its own system attributes.
- the client can keep information on A(W), A(C), A(S), V(W), V(C) and V(S) locally based on the currently running Mervlet application.
- a client device may have a plurality of network interfaces. During think times, a separate application on the client may collect information on A(C) on the different networks. This operation preferably is performed in an energy conserving fashion and with care not to overload the battery for the client.
- A(W) can be collected for each network by adding A(S) and V(C) for the Mervlet across each network interface.
- Each of the measured A(W) values can be stored in a vector, which is used for application provisioning and network switching decisions.
- a client may collect information on A(C) from other clients on a common network that are using the same base stations or access points for communicating with the server.
- W, C and S can be measured per application or per user per application and stored in a client cache.
- the client cache can be synchronized with other clients, for example, through the server. It is assumed that the server knows which clients share the same access point or base station. The server will aggregate information for all the clients that share the same base station.
- the client cache is then sent to the server periodically at a frequency that is set by a system administrator. The period is set by a systems administrator.
- the server aggregates the data and sends this information plus a smoothing interval to the client when the client requests it.
- the smoothing interval is a predetermined value indicative of the time that must pass between successive load balancing optimizations.
- the client cache can also be synchronized directly between clients.
- each client broadcasts the cached information to other clients through an ad-hoc network such as Bluetooth, IRDA or 802.11b.
- Such a broadcast messages do not have to propagate through the network for communicating between the client and the server. Instead, the clients individually aggregate data.
- a smoothing interval may be fixed by the system administrator or the clients can employ a distributed consensus algorithm to come to an agreed upon smoothing interval.
- a server can obtain the measured performance attributes, including the measured mean and variance of wait, communication and server times, for a Mervlet whenever the Mervlet is run on the server.
- a system administrator can select the number of times that a Mervlet must run, for example ten iterations, before there is enough measured data about the performance attributes to use the dynamic profiles.
- Performance attribute values for a Mervlet may be collected either per user or per user per application or per user per application per device. If a device measures and stores performance attributes per application, a load balancing algorithm may use this information independent of the user. In addition, a device may measure and store performance attributes per user per application to allow load balancing algorithms to be tuned to the profiles of different users.
- the collecting of the performance and system attributes should be non obtrusive from a memory and processing perspective. Since the memory requirements for saving the data for each of the application attributes are relatively minimal, writing this data to memory and reading the system clock should be non obtrusive. For example, assuming that user interface events occur from about 500 milliseconds to about one second, a Java implementation of the Mervlet application environment that support a system clock with about 1 millisecond granularity would allow for the measurement of user interface related events with negligible overhead.
- the Mervlet application environment can load balance a Mervlet at application load time and runtime using two different optimizations based on its application attributes and system attributes: application provisioning and network switching. Specifically, when a user requests a Mervlet, the module PolicyMervlet of the Mervlet engine will decide where to run the Mervlet and which access network to use for communication. Likewise, during runtime, the Mervlet engine may determine to relocate the Mervlet or switch access networks to improve user perceived performance.
- FIG. 9 an example of an implementation of an application provisioning optimization is shown using a decision tree. This application provisioning algorithm is run from the server and is equally applicable at load time and runtime of an application.
- the application provisioning algorithm is based on mean wait times W, including mean communication times C and server computation times S, of an application. By moving the Mervlet from a server 32 to a requesting client device 30 , it is possible to reduce the communication time C to about zero.
- the algorithm determines if the client requesting content from the Mervlet has sufficient memory to run the Mervlet using information about the client obtained from the request in step 50 . Likewise, the algorithm determines if there the client has sufficient processing power, as measured by its MIPS rating, to run the application in step 52 .
- the algorithm determines whether the computation load on the server, as measured by its CPU utilization, is greater than a predetermined Load_threshold value in step 54 . Also, it determines whether the relocation overhead associated with moving the Mervlet from the server to the client is less than a predetermined RO_threshold value in step 54 .
- the relocation overhead can be calculated based on the size of the Mervlet using a relationship set by the by system administrator. If both conditions are met, then the algorithm instructs the server to move the Mervlet to the client for execution thereon in step 56 . This sequence helps improve the perceived performance of the Mervlet when the server becomes too busy to timely process the Mervlet by moving the Mervlet on the client.
- the algorithm determines whether the mean wait time for the Mervlet is greater than a predetermined AW_threshold value in step 58 . If this condition is met and the mean server computation time, as measured by difference between the mean wait time and the mean communication time, is less than a predetermined AS_threshold value and the relocation overhead is less than the predetermined RO_threshold value in step 58 , the algorithm instructs the server to move the Mervlet to the client for execution thereon in step 60 . This step helps improve the perceived performance of the Mervlet when the wait times for user interface events of the Mervlet are too great by relocating the Mervlet to the client as long as the server computation time following the move is not too great.
- the algorithm may determine to relocate the Mervlet if the mean wait time is greater than a predetermined threshold value and the mean communication time is greater than the mean server computation time.
- the algorithm determines whether the variance wait time for the Mervlet is greater than a predetermined VW_threshold value in step 62 . If this condition is met and the variance server computation time, as measured by difference between the variance wait time and the variance communication time, is less than a predetermined VS_threshold value and the relocation overhead is less than the predetermined RO_threshold value in step 62 , the algorithm instructs the server to move the Mervlet to the client for execution thereon in step 64 . This step helps improve the perceived performance of the Mervlet when the wait times for user interface events of the Mervlet are too great by relocating the Mervlet to the client as long as the server computation time following the move is not too great. Otherwise, the Mervlet is run on the server in step 66 .
- the application provisioning algorithm can discount A(S) in its decision making if A(S) is much smaller then A(C). Otherwise, if S is about the same as C, then a scaling factor, SF, can be used to estimate A(S) on the device.
- the SF is the ration of the SpecInt on the server divided by the SpecInt on the device, where SpecInt is a known benchmark for comparing processors speeds.
- the request When a request is received from a client device at a server for a Mervlet, the request has the following structure:
- the performance attributes of the Mervlet are kept in a file on the client and are indexed by a Mervlet URI, and optionally by the user.
- the application provisioning algorithm can choose the device the Mervlet is to run on using the application attributes obtained from the client or the server or a combination thereof.
- a server If a server is attempting to load balance a new Mervlet or a Mervlet whose performance attributes are not fresh, it can obtain values for the performance attributes from a recent run of the Mervlet on another device in the network or it can use cached values of performance attributes for a similar application on a similar device and network that it has stored.
- the freshness criterion is set by the system administrator.
- the requesting client determines if its performance has been degraded beyond a certain threshold and then sends this information to the server. Specifically, while the Mervlet is executing on a server and a client is accessing it from a client device, the client monitors mean and variance wait times for all user interface events from the client. If either A(W) or V(W) reaches a predetermined threshold, then the client sends a message to the server containing the following information:
- the server determines if the Mervlet should run on the client instead. If so, the Mervlet and its performance attributes are moved to the client. The server may save the state of the Mervlet before it is shutdown and relocated to allow the client to resume its execution using the save state.
- FIG. 10 An implementation of a network switching algorithm is shown using a decision tree in FIG. 10. This network switching algorithm can be run from the server and the client. Assuming that a client and server can communicate using a plurality of access networks, the network switching algorithm can switch access networks in order to the lower the mean and variance wait times. A user can install various network switching algorithms on a client device from a server or from another device.
- step 70 the network switching algorithm determines whether the mean wait time for the Mervlet is greater than a predetermined AW_threshold value and if the mean communication time for the Mervlet is greater than a predetermined AC_threshold value using the current access network. If these conditions are met and the network switching overhead is less than the predetermined SO_threshold value, the network switching algorithm will attempt to switch access networks in steps 74 - 82 .
- the network switching overhead can be calculated based on the size of the Mervlet using a relationship set by the system administrator. Otherwise, the current access network remains in use in step 72 .
- step 74 the algorithm calculates the mean and variance wait times for the application across all available access networks. It then identifies the minimum mean wait time for the group of available access networks. If the minimum mean wait time is less than a predetermined AW_threshold value and only one access network NN matches it in step 76 , then the algorithm instructs the device to switch to the access network NN in step 78 .
- step 80 If the minimum mean wait time is less than a predetermined mean threshold value and two or more access networks match it in step 80 , then the algorithm selects the access network from among the identified group having the lowest variance wait time in step 82 . Otherwise, if none of these conditions for switching access networks is met, the current access network remains in use in step 84 .
- the algorithm can switch access networks if it finds an access network whose mean wait time is less than the mean wait time for the currently used access network by a predetermined threshold value, T-meanwait. If the mean wait times are approximately the same on all access networks, but there exists an access network where the variance of the wait time is less than the variance wait time for the currently used network by a predetermined threshold, T-varianceMeanwait, then the algorithm can switch to this network.
- Utilization smoothing is a technique that can prevent thrashing during load balancing.
- the Mervlet application environment only allows N network switching events per time period T. These parameters can vary with individual implementations of the system and can be set by a system administrator of a network. The following algorithm for clients can be used to determine the smoothing interval for the network switching algorithm.
- Each client has a list of switches made in the time period T by each of its peers.
- the peer group is created dynamically or can be requested from the server.
- the switching algorithm is run only if the number of switching events in time period T is less than N. However, when the link itself fails, the algorithm may be configured to switch networks immediately.
- a server may keep a list of switches made recently and send this information to each client requesting updates of application attributes.
- the Mervlet application environment allows a system administrator to choose the types of failures that the system should tolerate using two components: a Mervlet engine 10 that can recover from crash and a reliable messaging system 20 that guarantees that messages in transit will be delivered with at least once semantics.
- the reliable messaging system 20 may be configured as follows: no fault tolerance, recoverable from client and network faults, and recoverable from client, network and server faults.
- the network connection to between a server and a UCD may be lost. If required, on reconnection, the server will automatically run the decision algorithm to determine where to run the Mervlet.
- the system administrator can choose whether or not to fault tolerant system components. The tradeoff is that fault tolerance has performance implications that must be weighed against the reliability that is required.
- the fault tolerance methodology characterizes the various faults in a mobile system based on cost associated with component recovery and its associated cost. It then allows a system administrator to choose the components to recover from.
- the Mervlet engine 12 periodically stores its state on persistent storage, including a list of all currently executing Mervlets 10 and the most recent Mervlet context for each. The list may also contain the priority of each application. In addition, the engine 12 can at any time call the method Save( ) on a Mervlet 10 to save its application state into persistent storage.
- the Mervlet engine 12 can restore its own state to restart the set of Mervlets that it was executing on a device at the time of a crash.
- the Mervlet engine 12 will restart each Mervlet 10 on its list one at a time.
- the order for restarting the Mervlets may depend on their priorities.
- a Mervlet 10 can register the method Restore(ApplicationContext) with the runtime engine 12 when the Mervlet is restarted following a device failure.
- the data object ApplicationContext includes data from the runtime engine's list that identifies the application and its context.
- the method Restore(ApplicationContext) can implement Mervlet specific recovery operations, including reading the state of local communication buffers to identify the communication state of the reliable messaging system 20 for the Mervlet on the client 30 . It can also query the communication state of the reliable messaging system 20 for the Mervlet on the server 32 . The method can return control to the Mervlet engine 12 after a Mervlet 10 has been restored.
- the messaging system 20 of the Mervlet application environment can utilize various messaging protocols to deliver the contents of a Mervlet and Mervlets themselves in a network and is not limited to the HTTP protocol.
- types of messaging protocols that have been found useful include one-way and request-response protocols, which could be synchronous or asynchronous.
- the messaging system 20 may be fault tolerant to ensure that transactions in progress will be preserved. However, a reliable messaging system is not responsible for recovering Mervlets themselves following device failures.
- a reliable messaging system 70 shown in FIG. 11, has a queue 72 on the client side such that all outgoing communication from a client 30 is buffered.
- the buffer has a user configurable size.
- each message is tagged with a unique sequence number and a reply is sought for each element. If a reply is not received, the message is retransmitted until a reply is received. When the reply is received, the appropriate buffered message is released from the system.
- the reliable messaging system 70 may be implemented such that a reply is tied either to the underlying operating software of a device or to a higher level event in the Mervlet 10 .
- the generic form is used where the reply is tied to the underlying software.
- the buffering mechanism is tied to the request being received by the Mervlet engine for lower overhead.
- the “to” field identifies the receiver.
- the “from” field identifies the sender.
- the “data” field is the serialized data being sent.
- the “type” is either application level or system level. A callback method is called when an acknowledgement is received. Using this API, the system can guarantee at least one delivery of a message.
- the message format for the reliable messaging system 70 is shown in FIG. 12. It has a total of six fields, where the first four are fixed size, the data segment is variable size, and the checksum is variable and computed over all the fields. It is possible to relocate a Mervlet in a network using the reliable messaging system 70 by including the Mervlet itself in the data payload of individual messages.
- the maximum buffer space is set to a predetermined value, MAX_BUF, by the system administrator. If there is sufficient buffer space available, the message is buffered and a buffer manager of the reliable messaging system 70 attaches a sequence number to the message in step 106 . All messages are sent with unique sequence numbers between two pairs of machines.
- the call can return to the client application.
- the call does not return to the client application until the message has been buffered to a persistent storage. After the call returns, the client application is assured that the message will be delivered to the appropriate Mervlet even if the client device or network fails.
- a buffer management thread wakes up and sends the buffered messages to the server 32 in step 108 and waits for replies to messages previously sent. Each message has a predetermined timeout value associated with it. If a message reply has not been received within the timeout period, then the message is resent. This process continues until a reply has been received.
- the buffer management thread is only triggered when an access network 38 is up and a path to a primary server 32 has been established.
- the system administrator can choose how the reliable messaging system 70 should process and deliver the message to the Mervlet on the server. For example, the system can immediately deliver the message to the Mervlet in step 112 and then store the message to a persistent storage in step 114 , such as a hard disk. This increases the time the message is not in a “safe” state, but it gives the Mervlet quick access to the message.
- the reliable messaging system 70 on the server 32 can log it in a persistent storage in step 116 and then deliver it to the Mervlet in step 118 .
- the Mervlet then processes the message (step 122 ) and generates a reply (step 124 ). It also signals to the reliable messaging system 70 that it has responded.
- the system logs the reply in step 126 and then attempts to send it to the requesting client in step 128 . At this point, the request message is removed from the persistent storage buffer on the server in step 130 .
- the client on receiving the reply (step 132 ) immediately stores the reply in a buffer on persistent storage (step 134 ). It then finds the matching request message that was sent to the server and removes it from the buffer in step 136 . Next, the client attempts to deliver the reply to the appropriate callback method from the client application in step 138 . Once the callback method is called, the reply is released in step 140 . On the server, the buffer for the reply will be released when the next message is received from the same client with a higher sequence number in step 120 . If a duplicate message is received by the server, then it is discarded. The size of the acknowledgement buffer is set by the systems administrator to ACK_BUF.
- the reliable messaging system 70 manages the connection between a client device 30 and a server 32 .
- the system periodically wakes up and performs the following task. It checks to see if the primary server 32 can be contacted through any of the clients access networks, such Bluetooth, 802.11b (Wi-Fi) wireless, IRDA, and General Packet Radio Service (GPRS) mobile telephone networks 802.11b. It does this by sending an ICMP Ping to the primary server 32 .
- the first access network that provides a match is used for further communication between the client 30 and the server 32 .
- the reliable messaging system 70 also wakes up its buffer management thread and tells it which protocol to use to communicate with the server 32 .
- Fault tolerance comes at a cost since all writes to a disk cost time and disk space.
- FIG. 14 several configurations for the implementation of the reliable messaging system 70 are shown.
- the first row describes a technique where messages being logged on the server 32 and client 30
- the second describes messages are logged solely on the client 30
- the third row describes a technique where no messages are logged.
- the first two options offer the following alternatives for fault tolerance. If a user desires to lower the runtime costs and is willing to spend more time in recovering an application, then the second option may be considered.
- the first option has higher runtime costs because messages are logged on the client and the server, but the benefit to the user is that the recovery for the application using the reliable messaging system is made more robust.
- a server 32 When a server 32 recovers from a failure, it looks at the buffer list on its persistent storage, which was stored in step 106 shown in FIG. 13. The reliable messaging system 70 assumes that data on the persistent storage of the device is not destroyed, but data in main memory of the device is destroyed. If the list contains a message from a client 30 , then the reliable messaging system 70 assumes that the request has not been processed and attempts to deliver the message to the appropriate Mervlet on the server. Likewise, if the server 32 finds a buffered reply after recovery from a crash, the system sends it to the appropriate destination client 30 .
- a client device 30 may be “disconnected” from a server 32 or other devices for two reasons: a network failure or a voluntary move by the system administrator or user, for example to reduce network bandwidth usage.
- the Mervlet application environment provides two features to support disconnected operation: asynchronous reliable messaging and Mervlet caching.
- Asynchronous reliable messaging allows messages to be queued at either the client 30 or the server 32 when a network connection is not present between the client and server.
- an application sends a message, it is buffered or queued locally, as described above. Messages are sent only when a network connection is established. When a network connection is re-established, the asynchronous reliable messaging system will resend the messages waiting in the buffer queue.
- the reliable messaging system 70 can also save the message queues in persistent storage so that device and server failures can be tolerated, as described above.
- the second mechanism for disconnected mode computing calls for storing Mervlets in a local cache on the client device 30 .
- the cache memory is managed by a cache manager 22 , shown in FIG. 1.
- the cache is accessible to a browser or other client application even without a network connection. If the client 30 is disconnected, the Mervlet on the cache can still serve the local browser. In addition, the local browser can still request Mervlets from the local cache.
- the cache can be managed in a variety of ways, but preferably it allows intelligent pre-fetching using techniques such as hoarding.
- the Mervlet caching mechanism allows the client 30 to delegate a variety of cache management decisions to a server 32 in situations where the server has more knowledge about future Mervlet accesses, for example in a collaborative setting or in a setting where information is being proactively pushed to the client device 30 . Therefore, a cache management policy can be set by the client 30 , by the server 32 or a combination of both.
- a server 32 can update the cache replacement and write policy for each of the Mervlets 10 stored on the cache of the client device 30 .
- the cache manager 22 can implement caching algorithms that treat code and data separately if they so desire. Also, the cache may consider device characteristics and individual user usage profiles into cache management algorithms.
- One implementation of the cache manager 22 calls methods on a pre_fetch class to implement prefetching, a cache_miss class to implement handling of cache misses and a cache_write class to implement data writes to the cache.
- a pre-fetch operation may be server initiated or client initiated.
- the server 32 sends a pre-fetch notification to the client 30 , which sends back the cache state vector.
- the server then sends a new set of documents and optionally a new replacement policy to the client.
- the server 32 also makes a request to run a Mervlet 10 on the client device 30 .
- the Mervlet 10 is executed on the client 30 , it sends back the cache state vector to the server 32 .
- the server 32 then sends a set of cache objects to the Mervlet 10 and a replacement policy.
- the Mervlet 10 calls back to the server 32 to load the class for the new replacement policy.
- the cache manager 22 on the client 30 sends a request to the primary server 32 indicating that a document is missing and a vector of the local cache state when a miss occurs.
- the vector includes the size of cache and any changes to the hash table for the cache since last update to server.
- the primary server 32 the sends back the requested document. It may also send back other pre-fetched documents and a replacement policy.
- the client 30 uses this new replacement policy on its cache.
- the server 32 sends them back and optionally a replacement policy. Once again, the client will proactively download the new class that implements replacement.
- the write policy for a local cache on the client 30 may be changed by the cache manager 22 using a new class that is downloaded from a server 32 .
- the server 32 can attach a policy on how to handle dirty or written objects when an object is forced to leave the cache.
- the caching system is configurable be selecting whether the system may perform caching or not. This is a dynamic or runtime choice.
- the caching system itself is dynamically extensible in three areas: replacement policy, prefetch policy and modified data management policy.
Abstract
Description
- The present invention relates generally to a mobile application environment. In particular, it relates to a mobile application environment that can load balance mobile applications capable of creating dynamic web pages across heterogeneous mobile communication networks using a messaging system compatible with multiple low level transport protocols to optimize their user perceived performance.
- The need for mobile computing and network connectivity are among the main driving forces behind the evolution of computing devices today. The desktop personal computer (PC) has been transformed into the portable notebook computer. More recently, a variety of mobile handheld consumer electronic and embedded devices, including Personal Digital Assistants (PDAs), cellular phones and intelligent pagers have acquired relatively significant computing ability. In addition, other types of mobile consumer devices, such as digital television settop boxes, also have evolved greater computing capabilities. Now, network connectivity is quickly becoming an integral part of these consumer devices as they begin speaking with each other and traditional server computers in the form of data communication over various communication networks, such as a wired or wireless LAN, cellular, Bluetooth, 802.11 b (Wi-Fi) wireless, and General Packet Radio Service (GPRS) mobile telephone networks.
- The evolution of mobile computing devices has had a significant impact on the way people share information and is changing both personal and work environments. Traditionally, since a PC was fixed on a desk and not readily movable, it was possible to work or process data only at places where a PC with appropriate software was found. Nowadays, however, the users of mobile computing devices can capitalize on the mobility of these devices to access and share information from remote locations at their convenience. A highly anticipated and powerful method for sharing information across a network of computers and mobile devices is via a Web interface for displaying dynamically generated content.
- However, mobile devices pose several challenges for application developers. For example, mobile devices typically have more limited hardware resources than conventional computers. In addition, mobile devices tend to have widely varying hardware configurations, including differences in computation power, memory size, display capability, means for inputting data, etc. Mobile communication networks also experience limited network bandwidth and network availability. Consequently, mobile devices may be connected, intermittently connected or disconnected from a network.
- Therefore, the first generation mobile devices typically were request-only devices or devices that could merely request services and information from more intelligent and resource rich server computers. The servers used standard software architectures, such as the Java 2 Enterprise Edition (J2EE) platform. The server platforms could define and support a programming model that allows thin-client applications to invoke logic instructions that execute on the servers.
- Today, with the advent of more powerful computing platforms aimed at mobile computing devices, such as PocketPC and Java 2 Platform, Micro Edition (J2ME), mobile devices have gained the ability to host and process information and to participate in more complex interactive transactions. However, conventional mobile application platforms remain generally less robust than their server-based counterparts and fail to fully exploit the resources available on mobile devices. These platforms fail to satisfactorily load balance mobile applications at load time and runtime to optimize their user perceived performance, which can vary with the load on the network and the individual devices in the network. Also, they do not provide the services necessary to support multiple low level transport protocols for compatibility across heterogeneous mobile communication networks. Moreover, mobile devices using known application platforms cannot widely run server-based applications once disconnected from a network.
- Therefore, in the area of mobile application environments for mobile devices there continues to be a need for a more robust application environment that offers improved services to support interactive mobile applications with richer functionality.
- In one aspect of the invention, a mobile application environment for a mervlet application is provided. The mobile application environment forms part of a mobile communication network comprising at least one access network. The environment comprises the mervlet, which includes instructions to create a web page with dynamically generated content. The mervlet is capable of executing on at least one of a local node and a remote node of the network. The environment also comprises a set of application attributes for the mervlet, including performance attributes characterizing the user interface of the mervlet. The environment further comprises a set of security attributes for the mervlet defining a security context in which to execute the mervlet. In addition, the environment comprises a mervlet engine that is operative to manage a lifecycle of the mervlet. The engine includes a core interpreter module operative to execute the mervlet in the security context defined by its security attributes. The engine also includes a policy module operative to determine whether to relocate the mervlet and the application attributes between said local and remote network nodes and the security attributes among computing devices in the network and to switch the access network using the application attributes to improve a user perceived performance of the mervlet. The environment next includes a cache manager agent operative to manage cache memory of the local and remote network nodes for receiving and storing the mervlet. Finally, the environment includes a messaging system operative to deliver content of the mervlet and the mervlet itself across the network.
- The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate embodiments of the invention and, together with the description, serve to explain the advantages and principles of the invention. In the drawings,
- FIG. 1 is a block diagram showing the system components of a Mervlet application environment according to the present invention;
- FIG. 2 is a flow chart showing the details of the operation of the Mervlet application environment of FIG. 1;
- FIG. 3 is block diagram showing a high level view of a mobile communication network for the Mervlet application environment of FIG. 1;
- FIG. 4 is a block diagram showing the structure of a Mervlet application and its attributes for the Mervlet application environment of FIG. 1;
- FIG. 5 is a block diagram showing the lifecycle of a Mervlet application for the Mervlet application environment of FIG. 1;
- FIG. 6 is a block diagram showing the steps in and overall structure of the Mervlet engine for the Mervlet application environment of FIG. 1;
- FIG. 7 is a block diagram showing a timeline for user interface events for the Mervlet application environment of FIG. 1;
- FIG. 8 is a table summarizing the performance attributes and system attributes for the Mervlet application environment of FIG. 1;
- FIG. 9 is a flowchart showing details of the application provisioning optimization for load balancing a Mervlet for the Mervlet application environment of FIG. 1;
- FIG. 10 is a flowchart showing details of the network switching optimization for load balancing a Mervlet for the Mervlet application environment of FIG. 1;
- FIG. 11 is a block diagram showing the interface between a reliable message system and a Mervlet engine for the Mervlet application environment of FIG. 1;
- FIG. 12 is a diagram showing the structure of a message for the reliable messaging system of FIG. 11;
- FIG. 13 is a chart showing details of the operation of the reliable messaging system of FIG. 11; and
- FIG. 14 is a table showing different configurations and the associated performance costs for the reliable messaging system of FIG. 11.
- Reference will now be made in detail to an implementation of the present invention as illustrated in the accompanying drawings. The preferred embodiments of the present invention are described below using a Java based software system. However, it will be readily understood that the Java based software system is not the only vehicle for implementing the present invention, and the present invention may be implemented under other types of software systems.
- 1. Overview of the Mervlet Application Environment
- In an application environment according to the present invention, shown in FIG. 1, application developers create mobile applications (“Mervlets”). A Mervlet10 is an executable application program capable of creating dynamic web pages for mobile computing devices. A Mervlet 10 comprises uninterpreted code that includes both user interface logic for creating a web page and application logic for generating dynamic content for the page. A Mervlet 10 can further comprise local static data and can access data files, such as ASCII text files. Moreover, unlike conventional application programs, a
Mervlet 10 has a unique set of application attributes that are associated with it. These attributes make it possible to dynamically load balance aMervlet 10 at load time and runtime across a communications network. A Mervlet 10 also can run in its own security context on various devices in a network using the same set of security attributes associated with the Mervlet. Accordingly, aMervlet 10 has the features of a relocatable dynamic web document. - Mervlets execute under the control of a
Mervlet runtime engine 12, which includes customizedtag libraries 14, a set of components forsystem services 16 and acore interpreter 18. TheMervlet engine 12 may be configured to be self-recoverable so that it is able to restart execution of a set of Mervlets that were running at the time of a system failure. - The
Mervlet engine 12 can use amessaging system 20 to deliver content across a network to a client device from a Mervlet that is executing remotely or to deliver Mervlets themselves for load balancing. For example, the Mervlet engine can use point to point asynchronous messaging to communicate requests to and replies from a Mervlet and also to transmit the Mervlet itself. In addition, the Mervlet application environment supports a reliable messaging system that can recover from transient network and device failures and guarantee the delivery of a message to its endpoint. The reliable messaging system can be configurable to allow a user to choose a device for buffering messages for different recovery options. Those skilled in the art will readily recognize that other messaging systems could be used, including systems that use remote procedure calls transported by HTTP, SMTP or a similar transport protocol. - The
Mervlet engine 12 can also interface with aconfigurable cache manager 22 for caching Mervlets locally on a device to hide network disconnections. If a device cache is programmable, then Mervlet specific caching policies can be downloaded to the device. The caching mechanism allows the cache manager to dynamically change its cache management policies. - Referring next to FIGS. 2 and 3, in operation, a mobile device or user client device (UCD)30 forming part of a communications network generates a request for a Mervlet 10 in
step 10. TheUCD 30 runs the Mervlet application environment and can display information using a web browser, such as Internet Explorer and Pocket Internet Explorer from Microsoft Corp. and Netscape Navigator from Netscape Communications Corp. TheUCD 30 generates a request for theMervlet 10 using a Uniform Resource Identifier (“URI”). The URI encodes the name and address of an object, including a Mervlet, in a registered name space on the network to allow access to the object using an Internet access protocol. The requestingUCD 30 may be able to execute theMervlet 10 locally or obtain content from theMervlet 10 when it is executing remotely. - The requested
Mervlet 10 may be stored locally on the requestingUCD 30 or on a remote node of the network with sufficient memory and processing capacities to execute the Mervlet (“primary server”) 32, which may be anotherUCD 34 or a computer server class device 36. The requestingUCD 30 can locate aprimary server 32 using existing resource discovery techniques, such as JINI from Sun Microsystems, instep 12. Theprimary server 32 must be able to execute theMervlet 10 or locate a secondary server, not shown, on the network to execute theMervlet 10. In the latter case, theprimary server 32 must send theMervlet 10 to the secondary server and forward the request from the requestingUCD 30. TheUCD 30 and theprimary server 32 may communicate over one ormore access networks 38. - The requesting
UCD 30 first checks to see if theMervlet 10 is stored in a local cache on the device instep 14. If it is, then theMervlet 10 is executed there and then instep 16. Otherwise, the requestingUCD 30 communicates with theprimary server 32 to get “access” to the requestedMervlet 10 instep 18. Theprimary server 32 then invokes a load balancing policy on theMervlet 10 instep 20 to optimize the user perceived performance of theMervlet 10. For example, theprimary server 32 may decide to run theMervlet 10 locally (step 22) or to relocate it to the requesting UCD 30 (step 24). In some cases, theUCD 30 may make an explicit request to run theMervlet 10 at its site. However, theprimary server 32 can ignore that request. If theMervlet 10 is executed on theprimary server 32 instep 22, the result is transmitted back to theUCD 30 via the messaging system of the Mervlet application environment. - The
primary server 32 can determine whether to run theMervlet 10 locally or on the requestingUCD 30 based on several attributes, including: 1) the memory and processing capacities on the UCD and server nodes, 2) the load on each of the two nodes and the network bandwidth and latency, and 3) a set of attributes relating to the performance of the Mervlet. For example, the server may determine to run the Mervlet on the UCD if the Mervlet is highly user interactive, for example a gaming application, and the UCD has sufficient hardware resources to execute the Mervlet. On the other hand, if the Mervlet is data or computationally intensive rather than interactive, for example a personalization application, then the server may determine to run the Mervlet itself. However, those skilled in the art will clearly recognize that other load balancing decisions are also possible based on the parameters that the system monitors. For example, theprimary server 32 and theUCD 30 can implement a network switching policy to switchaccess networks 38 between the devices for improved communication. - A system implementation that supports the high level execution model described above will now be described. In particular, several key properties of the Mervlet application environment will be explained, including: 1) the application model for a Mervlet, 2) the Mervlet runtime engine, 3) load balancing schemes for optimizing the user perceived performance of a Mervlet across a network, 4) configurable fault tolerance schemes for a recoverable Mervlet engine and reliable messaging system, and 5) configurable disconnected mode operation schemes.
- 2. Mervlet Application
- A
Mervlet 10 defines the user interface for a web page to display dynamically generated content on a mobile device. The structure of aMervlet 10 is shown in FIG. 4. In particular, theMervlet 10 uses platform independentuser interface logic 40 such as markup language instructions to control the formatting and display a web page. It can also handle requests and replies from a web browser. For example, a Mervlet can support web pages using static HTML, DHTML, XHTML, XML and similar formatting tags that can be interpreted by a web browser. In addition, theMervlet 10 uses XML-like tags to encapsulateapplication logic 42 that generates the dynamic content for the web page. Theapplication logic 42 itself can reside in server-based resources that the web page accesses with these tags, such as JavaBeans or customized Mervlet tag libraries. Mervlet tag libraries may be native to the application environment on a particular device or they may move with a Mervlet when a Mervlet is relocated during load balancing. Therefore, theMervlet 10 separates the user interface of a dynamic web page from content generation for a reusable component-based design that is platform independent. - The
Mervlet 10 can make network connections via themessaging system 20 and can access local data files. Therefore, the application model for a Mervlet includesuser interface logic 40,application logic 42,file access 46 and network access 44. - In addition, a set of novel application attributes50 comprising performance attributes 52 and system attributes 54 are associated with the
Mervlet 10 for dynamically load balancing the Mervlet in a network. For example, theMervlet 10 may be dynamically relocated at load time and run time across a mobile communications network using its application attributes 50, as described further below. - The
Mervlet 10 also can execute in its own security context based on a set of associated security attributes 56. A containment model determines what resources are available to a user. Using a variant of theJava 2 security model, a class loader and affiliated classes are modified with a policy mechanism discussed in “A flexible security model for using internet content,” Islam et al, IEEE Software, 1997, which is incorporated herein by reference, with the exception that a protection domain may be set by the UCD. The class loader creates a security context in which to run theMervlet 10. Mervlets are signed and verified by a device before they are run. A policy module configured using the security attributes 56 implements policy for who to trust and what operations are allowed. TheMervlet engine 12 can monitors at runtime any access by theMervlet 10 and kills the Mervlet if it attempts to run outside of its security context. The security context for a Mervlet 10 can be moved and recreated on different devices in a network by relocating the security attributes 56 along with theMervlet 10. - These features are peculiar to the Mervlet application model and elude other types of technologies for creating dynamic web pages such as JavaServer Pages (“JSP”) discussed in “JavaServer PagesTM—White Paper,” Sun Microsystems, which is available via URL http://java.sun.com/products/jsp/whitepaper.html and is incorporated herein by reference.
- A Mervlet10 can be implemented as a Java application component derived from the JSP model. Such a Mervlet implementation can access the J2ME CDC environment and the resource files used by Java classes, except that it does not have access to JNDI, JMS, JTA, JAF, Java Mail, RMI, JDBC and IIOP classes. In addition, the JSP derived Mervlet does not have access to AWT or SWING classes. The J2ME based implementation of the Mervlet also disallows scripts inside a web page processed by the Mervlet. These restrictions may exist on all nodes of a network that implement the Mervlet application environment in order to optimize the Mervlet implementation for thin client devices having limited hardware resources. Accordingly, Mervlets are platform-independent and can leverage existing Java platform technologies while meeting thin client requirements.
- The J2ME based implementation of the Mervlet application environment according to the present invention changes the semantics of traditional JSP and Servlet execution, such as determining when and where to execute Mervlets, instead of solely making changes to the JSP application programming interfaces (“APIs”). This implementation will now be described in greater detail below.
- 3. The Mervlet Engine
- A
Mervlet 10 is compiled and executed on aMervlet engine 12, as shown in FIG. 1. Theengine 12 can process requests from a client application such as a web browser to theMervlet 10 and generate responses from theMervlet 10 to the client browser. In particular, theMervlet engine 12 interprets the Mervlet tags for theapplication logic 42 and generates corresponding dynamic content by accessing a resource or tag library, which could be native to the device or relocatable with aMervlet 10. Theengine 12 then sends the results back in the form of an HTML or XML page to the requesting web browser. Any static formatting tags are passed directly to the requesting web browser. - The
Mervlet engine 12 can run on the J2ME CDC platform for thin client devices and the J2EE platform for server class devices. The J2ME platform traditionally requires a 32 bit CPU and at least 2 megabytes of memory. The J2EE platform traditionally requires at least an Intel Pentium III class processor, 128 megabytes of RAM memory, and 300 megabytes of persistent storage. One possible configuration for a Mervlet application environment according to the present invention that supports aMervlet engine 12 that consumes up to 6 megabytes at runtime would include at least a 32 bit CPU, 10 megabytes of RAM memory, and 40 megabytes of persistent storage. However, it should be understood that these values for the Mervlet application environment are meant to be illustrative, rather than limiting. In the context of J2EE, theMervlet engine 12 can replace the web container and Servlet engine models in J2EE. Therefore, theMervlet engine 12 can provide aMervlet 10 with access to Java Virtual Machine (JVM), PersonalJava Virtual Machine (PJVM) or other type of Virtual Machine (VM). VM, which runs on top of the native operating system of a device, acts like an abstract computing machine, receiving Java bytecodes and interpreting them by dynamically converting them into a form for execution by the native operating system. - A
Mervlet engine 12 manages the lifecycle of aMervlet 10 via a set of application programming interfaces (APIs), as shown in FIG. 5. The actions that the Mervlet engine performs include finding the Mervlet requested by a client application on a network instep 30. The requested Mervlet may be stored either on the requesting client or on a primary server. After the Mervlet is found, the Mervlet engine creates an instance of the Mervlet, loads it into the engine's memory and initializes it instep 32. Once initialized, the Mervlet is ready to receive information and the Mervlet engine can pass requests and process replies from the Mervlet instep 34. Once the Mervlet is no longer needed, the Mervlet engine destroys the Mervlet and removes its presence from the engine memory and any data in persistent storage associated with the Mervlet in step 36. - The Mervlet engine can restart a Mervlet after a crash in
step 38. The Mervlet engine may also notify a Mervlet at any time that it needs to save its state instep 40. The ability of the Mervlet engine to recover from a crash using these actions is described in further detail below in connection with the fault tolerance for the Mervlet application environment. - The following are an exemplary set of APIs for implementing Mervlets on a Mervlet engine based on the J2ME platform. The Mervlet APIs are derived from the standard Java classes for interfaces for Java Servlets. The Mervlet implementation creates a “javax.mervlet” subclass of the “javax.servlet” class.
- There are ten classes to consider for the “javax.mervlet” implementation of the Mervlet API. Five of the ten classes that remain unchanged from the Servlet implementation are listed below.
- Mervlet Exception, which is identical to ServletException
- MervletInputStream, which is identical to ServletInputStream
- MervletOutputStream, which is identical to ServletOutputStream
- RequestDispatcher, which remains unchanged
- MervletConfig, which is identical to ServletConfig
- There are also five classes that require modified semantics as described below.
- Mervlet
- MervletContext
- MervletRequest
- MervletResponse
- SingleThreadModel
- The class “Mervlet” has three important methods:
public void init( ) throws “MervletException”; public void service( ) throws “MervletException”; and public void destroy( ) throws “MervletException”; - The method “init( )” is called by the Mervlet engine to initialize the Mervlet. It must be called after the Mervlet is found and a class loader has been invoked on the Mervlet. The method “init( )” must be called before any calls to the method “Service( )” are allowed. The method “service( )” is called on the Mervlet to allow the Mervlet engine to pass requests and process replies from the Mervlet. The Mervlet is destroyed by calling the method “destroy ( )” on the Mervlet.
- In the case where a parameter is required, a Mervlet context is constructed and passed in to the method. Therefore, developers can extend the class “Mervlet” and override the methods “init( )” and “service( )”, for example, as follows:
public void init(MervletConfig) throws “MervLetException”; and public void service(MervletRequest, MervLetResponse) throws IOException, MervletException. - In addition, the following two additional methods are available as part of class “Mervlet” for load balancing a Mervlet relocation or recovering from system failures:
void Restore(MervletContext m) void Save( ) - The method Restore( ) is called by a Mervlet engine prior to the method init( ) to restore its own state when attempting to recover Mervlets following a crash. The method Save( ) may be called by a Mervlet engine at any time to notify a Mervlet to save its application state. However, Mervlets should not assume that the method Save( ) will be called prior to a crash.
- The class “MervletContext” specifies resources available to a Mervlet. It is an extension of the class “ServeletContext” and includes the following additional resources: i) files for use with the Mervlet; ii) a set of attributes relating to the performance of the Mervlet, including user interface and I/O characteristics as described further below; and iii) resource rights for the Mervlet. The class “MervletContext” also includes methods to get and set each of these resources.
- The classes “MervletRequest” and “MerveletResponse” are extensions of the classes “ServeletRequest” and “ServeletResponse” respectively. The Mervlet engine generates requests and responses using the following abstract messaging method:
void Reliable_async_send(Endpoint to, Endpoint From, DataStream Data, Reliability Type, CallbackMethod cm). - The data format for this method is the same as that for HTTP-mime encoded interfaces. Other implementations are possible with different exchange formats.
- The class “SingleThreadModel” from the Servlet model is not implemented because the Mervlet engine is multithreaded.
- Referring next to FIG. 6, the functional block diagram showing the operation of the
Mervlet engine 12 in response to a request for aMervlet 10 from a client application orbrowser 60 on auser client device 30 is now described. First, theMervlet engine 12 on the requestingclient 30 must find theMervlet 10. The engine itself is constructed from simple Mervlet components. In order to locate or find the requested Mervlet, a “MervletFinder”module 62 intercepts all calls in theclient 30 that request to load Mervlets. Themodule MervletFinder 62 searches the local cache on theclient 30 for theMervlet 10 that has been requested using known hash functions exported by the cache. If theMervlet 10 is found, themodule MervletFinder 62 allocates memory for the Mervlet and reads in the Mervlet from the local cache. Themodule MervletFinder 62 then calls the method “init( )” on theMervlet 10, passing the configuration data for the requested Mervlet to initialize the newly created instance of the Mervlet. When theMervlet 10 is finished, it calls the method “destroy( )” on itself. If theMervlet engine 12 wants to remove theMervlet 10, it can call the method “destroy( )” on it. - If the
module MervletFinder 62 determines that the requestedMervlet 10 is not on theclient 30 because there was no match in the local cache, then it queries aprimary server device 32 for theMervlet 10. The query to theserver 32 contains the name of theMervlet 10, the CPU utilization on theclient device 30, the MIPS rating of theclient device 30, the available memory and the persistent storage on theclient device 30, and any performance attributes of theMervlet 10 if available. This information may be used by theprimary server 32 to determine whether to relocate theMervlet 10 to theclient 30 orswitch access networks 38 for communication between theserver 32 andclient 30 using a load balancing scheme described below in further detail. - The
Mervlet engine 12 also includes a module “InterceptingMervlet” 64, which intercepts requests for theMervlet 10 arriving at theprimary server 32. When requests arrive for theMervlet 10 from the network, themodule InterceptingMervelt 64 dispatches the messages to theMervlet 10 on theserver 32. In response to a request for theMervlet 10, themodule InterceptingMervlet 64 also calls a module “PolicyMervlet” 66 and passes the system performance parameters for the requestingclient 30 to it. Themodule PolicyMervlet 66 then determines how to load balance theMervlet 10 to optimize its user perceived performance. Themodule PolicyMervlet 66 is set by a system administrator. In addition, theprimary server 32 may entertain multiple requests from clients simultaneously and hence the modules PolicyMervlet 66 andInterceptingMervlet 64 are multi-threaded. - In particular, the
primary server 32 and theclient 30 can load balance theMervlet 10 as follows. Theserver 32 can choose to execute theMervlet 10 on the server machine and let the requesting client interact 30 with the Mervlet remotely. Alternatively, theserver 32 can decide to send theMervlet 10 to theclient 30 for execution on the client device. Themodule PolicyMervlet 66 determines whether to relocate theMervlet 10 using an application provisioning scheme, which is described below in further detail. In addition, either theserver 32 or theclient 30 may choose to switchaccess networks 38 for communicating with each other using a network switching scheme, which is described in further detail below. - If the
server 32 decides to run the requestedMervlet 10 on the server machine, then themodule PolicyMervlet 66 retrieves theMervlet 10 from the server's cache and allocates memory for it using a method “new( )”. Then, the method “init( )” is invoked on theMervlet 10 using the appropriate Mervlet context. The initialized instance of theMervlet 10 assumes the credentials of the requesting client when the semantics of security are the same as those in J2EE. After the instance of the requestedMervlet 10 has been initialized, it can access local data on the server. TheMervlet 10 can also communicate with client applications on theclient 30 through themessaging system 20, as described below in further detail. Accordingly, theMervlet engine 12 sends the output from theMervlet 10 directly to the requestingclient 30. Finally, theMervlet 10 can be destroyed by calling the method “destroy( )” on the Mervlet. - If the
module PolicyMervlet 66 determines that the requestedMervlet 10 should run on the requestingclient 30, then the Mervlet is marshaled and sent to the remote machine. In order to relocate theMervlet 10, theengine 12 packages the Mervlet into a Mervlet archive (“MAR”)file 68. TheMAR file 68 preferably comprises 1) theMervlet 10 and any associatedtag libraries 14, 2) the security context attributes 56 and application attributes 50 for the Mervlet, 3) any data files associated with theMervlet 10, and 4) a MAR file manifest describing the contents of the MAR file. Therefore, theMAR file 68 has all the information necessary for theMervlet engine 12 on theclient 30 to create the appropriate Mervlet context to pass to the method “init( )” of theMervlet 10 when it is started. TheMAR file 68 may be compressed, hashed and then signed. A downloader may uncompress and verify that the content has not been corrupted and verify the signature. - We now explain how the Mervlet application environment may load balance a Mervlet application and recover from system failures.
- 3. Application Load Balancing Scheme
- One feature of the Mervlet application environment, which will now be described in greater detail, allows the
Mervlet engine 12 to load balance aMervlet 10 to optimize the performance of the Mervlet. - The load balancing scheme is based on user interactions with a
user client device 30 that is requesting theMervlet 10 from aserver 32. In particular, themodule PolicyMervlet 66 of theMervlet engine 12 uses measures of the event wait times for the user interface (“UI”) of the client to optimize the perceived performance of theMervlet 10. The Mervlet application environment according to the present invention allows load balancing to be performed at application request time and at application runtime. - The load balancing scheme according to the present invention allows two types of optimizations: application provisioning and network switching. An application provisioning policy allows the server to determine which node of the network to run a Mervlet on. A network switching policy allows either the requesting client or the server to choose a new access network for communication between the server and the client. This model allows a developer to create a large class of algorithms for load balancing.
- In order to explain the performance optimization made possible using the load balancing scheme, a timeline for user interface events on a client device is shown in FIG. 7. A user moves through alternate think and wait times during user interactions with a Mervlet. At the end of each think time T, the user sends a request to a Mervlet and waits for a reply. The Mervlet typically waits in a loop for requests from the user. On receiving a request, the Mervlet may perform computations and data access to fulfill the user's request. It will then send back the reply. The timeline shown in FIG. 7 completes one such interaction.
- The wait time W is the time associated with processing a request. The wait time W can be broken down into communication time C and server computation time S. Typically, user experience is based on the mean and variance of the wait times when interacting with the application. Therefore, the performance of a Mervlet can be optimized if its wait times are generally below a predetermined threshold value. The load balancing scheme according to the present invention can optimize the mean and variance of the wait times for a Mervlet by relocating the Mervlet from the server closer to the user or switching the access network between the client and the server when appropriate.
- In order to load balance a
Mervlet 10, themodule PolicyMervlet 66 of theMervlet engine 12 utilizes a set of application attributes 50 comprising performance attributes 52 and system attributes 54, which are summarized in FIG. 8 and described in more detail below. - 3.1 Mervlet Performance Attributes
- The application attributes50 used to load balance a Mervlet 10 include a set of performance attributes 52 that characterize the Mervlet based on two criteria: 1) how interactive the application is, and 2) how computationally and data intensive the application is. Intuitively, developers want to provide the system with the ability to move interactive applications closer to the user, to move data intensive applications closer to the source of the data, and to allow a computationally intensive application to run on more powerful devices such as server class machines. Typically, developers write Java applications as either server applications on J2EE, for example JSPs and Servlets, or as applets for clients. For example, one would traditionally write a game as an applet and a banking application as a server based application. On the other hand, Mervlet developers only need to write the application once, and then the
PolicyMervlet 66 can utilize measured performance attributes 52 to relocate theMervlet 10 closer to the user or switch access networks to provide better mean and variance wait times for the Mervlet. - 3.1.1 Characterizing Mervlet Interactions
- In particular, users wait for events when they interact with a
client device 30 and request information from aMervlet 10, for example when they post web page forms and click on URLs for information. These actions, including the act of filling in a form and waiting for a response and the act of clicking on a link and getting a page, are referred to as user interface events. When theMervlet 10 runs on theclient device 30, all of the wait time W is spent in the application. If theMervlet 10 is executing remotely from theclient device 30 on aserver 32, part of the wait time W is spent communicating with the requesting client, C, while the remainder of the wait time is spent in the Mervlet itself for processing of the client request, S. - In order to load balance a
Mervlet 10, the Mervlet application environment measures the following performance attributes of the Mervlet for each form and URL sending a request to it: the mean and variance of the wait time W, the server computation time S and the communication time C. - For example, an HTML based client can intercept all “gets” and “posts” from the browser on the client to a Mervlet. This is handled by the module InterceptingMervlet of the Mervlet engine. When a “get” or “post” is performed, a first timestamp T1 is taken. When the “get” or “post” returns and the reply generated by the Mervlet is displayed on the browser, a second timestamp T2 is taken. Also, the reply message from the Mervlet includes a parameter value indicative of the time spent in computation in the server S. Accordingly, the following calculations can be made:
- W=T2−T1;
- and
- W=S+C,
- where
- S=Server computation time;
- C=Communication time;
- W=Wait time;
- T1=First time stamp; and
- T2=Second time stamp.
- The
server 32 maintains a running average of the mean and variance of the server computation time, wait time and communication time, denoted by A(S), A(C), A(W), and V(S), V(C), and V(W) respectively. In addition, a running average of the mean and variance of the W and C parameters are calculated for each access network used to communicate between the requesting client and the server. - If the C and S parameters are continuous random variables, the following relationships can be assumed:
- A(W)=A(C)+A(S);
- and
- V(W)=V(C)+V(S)+Cov(V,S),
- where
- Statistical Covariance for V and S=Cov(V,S).
- Moreover, if V and S are statistically independent variables, then the following relationship holds:
- V(W)=V(C)+V(S)
- Therefore, a load balancing policy for a Mervlet10 can improve a user's perception of the Mervlet's performance by reducing A(C) and V(C).
- For example, a framework for an algorithm to implement the application provisioning optimization could determine whether the wait time W for the
Mervlet 10 is unacceptable by verifying if A(W) is greater than a predetermined threshold value. Also, it could determine whether the communication time C is having an appreciable impact on the wait time W by verifying that A(C) is greater than the A(S). If W is unacceptable and C is appreciable, then the algorithm could attempt to relocate the Mervlet to another device. Otherwise, the Mervlet continues to run on the present device. - Likewise, an algorithm framework that could be used to implement the network switching optimization determines whether the mean wait time for a
Mervlet 10 using a first access network, A(W-network1), is greater than the mean wait time using a second access network, A(W-network2). If so, the algorithm will switch to the second network, network2, for communication to and from the Mervlet. - Those skilled in the art will recognize that other optimization algorithms for load balancing a
Mervlet 10 are possible using the performance attributes 52. The load balancing scheme provides the opportunity for an application designer to create different algorithms to improve user experience and optimize the perceived performance for user interface events. - 3.1.2 Characterizing Server Computation Time and Data Access
- As noted above, the total service time for a Mervlet to generate a reply to a single request from a client application is measured by the server computation time S. A Mervlet may spend server computation time S performing internal calculations and also accessing external data files, such that:
- S=D+I,
- where
- S=Server computation time;
- D=Time spent for data I/O; and
- I=Time spent for internal calculations.
- In order to obtain values indicative of the server computation time, S, a timer on the server is started when the Mervlet engine on the server calls the method “service( )” on a Mervlet in response to a request from a client applications. When the Mervlet generates a reply to the request, the timer is stopped. The duration for the timer measures the server computation time, S. The I/O libraries for the Mervlet engine are instrumented to record the time spent in data I/O, D, and the data I/O rate, DTP. The time spent for internal calculations, I, can be calculated from the equation above.
- The Mervlet engine can also record the average total time for the Mervlet to run to completion, TotalTime, using a timer on the server. These parameters are made available to Mervlet developers to refine the load balancing algorithms discussed in more detail below.
- 3.1.3 Performance Attribute Instrumentation
- The following are an exemplary set of APIs for intercepting user interface and file I/O events of a
Mervlet 10 using J2ME libraries. These APIs require the following modifications to the libraries java.net, jave.io, and java.util. - The performance attributes52 for measuring user interface events of a
Mervlet 10, including the wait time W, the server computation time S and communication time C, are determined by modifying java.net to intercepts all http requests. The following method is used to collect information on HTML based forms and URL processing, as described above:void recordEvent( EventType et, Event e, TimeStamp t) - Each request/reply pair with a form is recorded and all the events in the form are counted using this method.
- Additionally, the following method for data file read and writes is provided:
void _recordFileIO(AccessType type, int data, Timestamp time) - The data type for the parameter AccessType can be either read or write type. This method writes the measured performance attributes to a file.
- 3.2 System Attributes
- The
PolicyMervlet 66 also uses system attributes 54 in addition to application attributes 54 for load balancing and network switching decisions. The system attributes 54 relate generally to the resources and processing power of the computing devices used by the Mervlet application environment. In particular, as shown in FIG. 8, the following attributes are recorded for eachclient 30 and server 32: the MIPS rating, mean and variance of CPU utilization, the size of memory and persistent storage, and the mean and variance of network latency and bandwidth for each network type available at the device. - 3.2.1 System Attributes through Instrumentation
- In order to measure the system attributes54, a new library for the J2ME platform, java.sys.perf, makes available the following methods:
void System_cpu_util(UtiI U) - The method System_cpu_util(Util U) reads/dev/kem on UNIX to get CPU utilization information on UNIX systems. Those skilled in the art will recognize that similar calls exist on other operating systems.
void System_network_bandwidth (bandwidth b, accessnetwork a) - The method System_network_bandwidth (bandwidth b, accessnetwork a) determines network bandwidth between a
client 30 and theprimary server 32 using access network “a”. The bandwidth is calculated by sending a packet of known size S to theprimary server 32 from theclient 30, getting the same size packet back, and then dividing the packet size S by the time it took to get the packet. This computation preferably is performed in the operating system for greater accuracy.Void sys network_load_latency(accessnetwork a, latency I) - The method sys_network_load_latency(accessnetwork a, latency l) uses Internet Control Message Protocol (ICMP) to determine network latency. A client periodically sends an ICMP packet to a server and uses the returned values to keep an average value for latency over time. A system administrator can set the frequency with which this operation is performed.
Void Network_uptime(Netuptime nu, accesslink a) - The method Network_uptime(Netuptime nu, accesslink a) determines the percentage of time that a network connection between a client and a server is up. If an ICMP packet returns, then the system assumes that the network is up, otherwise it is down.
- 3.3 Collection and Dissemination of Application Attributes
- In order to make load balancing decisions, measured application attributes must be made available to the load balancing algorithms. The application provisioning optimization is run from the server. The network switching optimization can be run from the server and the client. There are a variety of ways the client and the server can dynamically profile the application attributes.
- For example, the system attributes of a requesting client can be obtained in the messages from the client by the load balancing algorithms at the server. The server can store its own system attributes.
- The client can keep information on A(W), A(C), A(S), V(W), V(C) and V(S) locally based on the currently running Mervlet application. In addition, a client device may have a plurality of network interfaces. During think times, a separate application on the client may collect information on A(C) on the different networks. This operation preferably is performed in an energy conserving fashion and with care not to overload the battery for the client. A(W) can be collected for each network by adding A(S) and V(C) for the Mervlet across each network interface. Each of the measured A(W) values can be stored in a vector, which is used for application provisioning and network switching decisions.
- Alternatively, a client may collect information on A(C) from other clients on a common network that are using the same base stations or access points for communicating with the server. W, C and S can be measured per application or per user per application and stored in a client cache. The client cache can be synchronized with other clients, for example, through the server. It is assumed that the server knows which clients share the same access point or base station. The server will aggregate information for all the clients that share the same base station. The client cache is then sent to the server periodically at a frequency that is set by a system administrator. The period is set by a systems administrator. The server aggregates the data and sends this information plus a smoothing interval to the client when the client requests it. The smoothing interval is a predetermined value indicative of the time that must pass between successive load balancing optimizations.
- The client cache can also be synchronized directly between clients. In this case, each client broadcasts the cached information to other clients through an ad-hoc network such as Bluetooth, IRDA or 802.11b. Such a broadcast messages do not have to propagate through the network for communicating between the client and the server. Instead, the clients individually aggregate data. A smoothing interval may be fixed by the system administrator or the clients can employ a distributed consensus algorithm to come to an agreed upon smoothing interval.
- A server can obtain the measured performance attributes, including the measured mean and variance of wait, communication and server times, for a Mervlet whenever the Mervlet is run on the server. A system administrator can select the number of times that a Mervlet must run, for example ten iterations, before there is enough measured data about the performance attributes to use the dynamic profiles.
- 3.3.1 Collecting Modes
- Performance attribute values for a Mervlet may be collected either per user or per user per application or per user per application per device. If a device measures and stores performance attributes per application, a load balancing algorithm may use this information independent of the user. In addition, a device may measure and store performance attributes per user per application to allow load balancing algorithms to be tuned to the profiles of different users.
- It may be desired to minimize the overhead associated with the mechanism for recording events. Accordingly, the collecting of the performance and system attributes should be non obtrusive from a memory and processing perspective. Since the memory requirements for saving the data for each of the application attributes are relatively minimal, writing this data to memory and reading the system clock should be non obtrusive. For example, assuming that user interface events occur from about 500 milliseconds to about one second, a Java implementation of the Mervlet application environment that support a system clock with about 1 millisecond granularity would allow for the measurement of user interface related events with negligible overhead.
- 3.4 Load Balancing Algorithms
- The Mervlet application environment can load balance a Mervlet at application load time and runtime using two different optimizations based on its application attributes and system attributes: application provisioning and network switching. Specifically, when a user requests a Mervlet, the module PolicyMervlet of the Mervlet engine will decide where to run the Mervlet and which access network to use for communication. Likewise, during runtime, the Mervlet engine may determine to relocate the Mervlet or switch access networks to improve user perceived performance.
- 3.4.1 Application Provisioning Optimizations
- Referring next to FIG. 9, an example of an implementation of an application provisioning optimization is shown using a decision tree. This application provisioning algorithm is run from the server and is equally applicable at load time and runtime of an application.
- The application provisioning algorithm is based on mean wait times W, including mean communication times C and server computation times S, of an application. By moving the Mervlet from a
server 32 to a requestingclient device 30, it is possible to reduce the communication time C to about zero. First, the algorithm determines if the client requesting content from the Mervlet has sufficient memory to run the Mervlet using information about the client obtained from the request instep 50. Likewise, the algorithm determines if there the client has sufficient processing power, as measured by its MIPS rating, to run the application instep 52. - Next, the algorithm determines whether the computation load on the server, as measured by its CPU utilization, is greater than a predetermined Load_threshold value in
step 54. Also, it determines whether the relocation overhead associated with moving the Mervlet from the server to the client is less than a predetermined RO_threshold value instep 54. The relocation overhead can be calculated based on the size of the Mervlet using a relationship set by the by system administrator. If both conditions are met, then the algorithm instructs the server to move the Mervlet to the client for execution thereon instep 56. This sequence helps improve the perceived performance of the Mervlet when the server becomes too busy to timely process the Mervlet by moving the Mervlet on the client. - Otherwise, the algorithm determines whether the mean wait time for the Mervlet is greater than a predetermined AW_threshold value in step58. If this condition is met and the mean server computation time, as measured by difference between the mean wait time and the mean communication time, is less than a predetermined AS_threshold value and the relocation overhead is less than the predetermined RO_threshold value in step 58, the algorithm instructs the server to move the Mervlet to the client for execution thereon in
step 60. This step helps improve the perceived performance of the Mervlet when the wait times for user interface events of the Mervlet are too great by relocating the Mervlet to the client as long as the server computation time following the move is not too great. - Alternatively, the algorithm may determine to relocate the Mervlet if the mean wait time is greater than a predetermined threshold value and the mean communication time is greater than the mean server computation time.
- Likewise, the algorithm determines whether the variance wait time for the Mervlet is greater than a predetermined VW_threshold value in
step 62. If this condition is met and the variance server computation time, as measured by difference between the variance wait time and the variance communication time, is less than a predetermined VS_threshold value and the relocation overhead is less than the predetermined RO_threshold value instep 62, the algorithm instructs the server to move the Mervlet to the client for execution thereon instep 64. This step helps improve the perceived performance of the Mervlet when the wait times for user interface events of the Mervlet are too great by relocating the Mervlet to the client as long as the server computation time following the move is not too great. Otherwise, the Mervlet is run on the server instep 66. - Alternatively, the application provisioning algorithm can discount A(S) in its decision making if A(S) is much smaller then A(C). Otherwise, if S is about the same as C, then a scaling factor, SF, can be used to estimate A(S) on the device. The SF is the ration of the SpecInt on the server divided by the SpecInt on the device, where SpecInt is a known benchmark for comparing processors speeds.
- Those skilled in the art will recognize that other implementations for the Mervlet provisioning algorithm are possible using the wait times for an application. For example, other algorithms that omit the step of comparing mean and variance of the wait time are possible.
- 5 3.4.1.1 Application Provisioning at Request Time
- When a request is received from a client device at a server for a Mervlet, the request has the following structure:
- URI
- MIPS Rating for Client
- Mean and Variance of CPU Utilization for Client
- Available Device Memory and Persistent Storage for Client (smoothed over a time period)
- {Performance Attributes, Data Size for Application }
- The performance attributes of the Mervlet are kept in a file on the client and are indexed by a Mervlet URI, and optionally by the user.
- The module PolicyMervlet on the server then looks into the server's own performance database and retrieves the following data:
- Mean and Variance of CPU Utilization for Server
- Mean and Variance of Network Bandwidth and Latency for Each Access Link Attached to Server
- {Performance Attributes, Data Size for Application }
- The application provisioning algorithm can choose the device the Mervlet is to run on using the application attributes obtained from the client or the server or a combination thereof.
- If a server is attempting to load balance a new Mervlet or a Mervlet whose performance attributes are not fresh, it can obtain values for the performance attributes from a recent run of the Mervlet on another device in the network or it can use cached values of performance attributes for a similar application on a similar device and network that it has stored. The freshness criterion is set by the system administrator.
- 3.4.1.2 Application Provisioning at Runtime
- In order to load balance a currently running Mervlet, the requesting client determines if its performance has been degraded beyond a certain threshold and then sends this information to the server. Specifically, while the Mervlet is executing on a server and a client is accessing it from a client device, the client monitors mean and variance wait times for all user interface events from the client. If either A(W) or V(W) reaches a predetermined threshold, then the client sends a message to the server containing the following information:
- MIPS Rating for Client
- Mean and Variance of CPU Utilization for Client Available Device Memory and Persistent Storage for Client (smoothed over a time period)
- {Performance Attributes}
- The server then determines if the Mervlet should run on the client instead. If so, the Mervlet and its performance attributes are moved to the client. The server may save the state of the Mervlet before it is shutdown and relocated to allow the client to resume its execution using the save state.
- 3.4.2 Network Switching Optimizations
- An implementation of a network switching algorithm is shown using a decision tree in FIG. 10. This network switching algorithm can be run from the server and the client. Assuming that a client and server can communicate using a plurality of access networks, the network switching algorithm can switch access networks in order to the lower the mean and variance wait times. A user can install various network switching algorithms on a client device from a server or from another device.
- First, in
step 70, the network switching algorithm determines whether the mean wait time for the Mervlet is greater than a predetermined AW_threshold value and if the mean communication time for the Mervlet is greater than a predetermined AC_threshold value using the current access network. If these conditions are met and the network switching overhead is less than the predetermined SO_threshold value, the network switching algorithm will attempt to switch access networks in steps 74-82. The network switching overhead can be calculated based on the size of the Mervlet using a relationship set by the system administrator. Otherwise, the current access network remains in use in step 72. - Next, in step74, the algorithm calculates the mean and variance wait times for the application across all available access networks. It then identifies the minimum mean wait time for the group of available access networks. If the minimum mean wait time is less than a predetermined AW_threshold value and only one access network NN matches it in step 76, then the algorithm instructs the device to switch to the access network NN in step 78.
- If the minimum mean wait time is less than a predetermined mean threshold value and two or more access networks match it in step80, then the algorithm selects the access network from among the identified group having the lowest variance wait time in step 82. Otherwise, if none of these conditions for switching access networks is met, the current access network remains in use in step 84.
- Alternatively, the algorithm can switch access networks if it finds an access network whose mean wait time is less than the mean wait time for the currently used access network by a predetermined threshold value, T-meanwait. If the mean wait times are approximately the same on all access networks, but there exists an access network where the variance of the wait time is less than the variance wait time for the currently used network by a predetermined threshold, T-varianceMeanwait, then the algorithm can switch to this network.
- 3.5 Utilization Smoothing
- Utilization smoothing is a technique that can prevent thrashing during load balancing. In particular, the Mervlet application environment only allows N network switching events per time period T. These parameters can vary with individual implementations of the system and can be set by a system administrator of a network. The following algorithm for clients can be used to determine the smoothing interval for the network switching algorithm.
- Each client has a list of switches made in the time period T by each of its peers. The peer group is created dynamically or can be requested from the server. Each time a client switches networks it broadcasts that information to its neighbors using an adhoc network. The switching algorithm is run only if the number of switching events in time period T is less than N. However, when the link itself fails, the algorithm may be configured to switch networks immediately. Alternatively, a server may keep a list of switches made recently and send this information to each client requesting updates of application attributes.
- 4. Fault Tolerance Scheme
- The Mervlet application environment allows a system administrator to choose the types of failures that the system should tolerate using two components: a
Mervlet engine 10 that can recover from crash and areliable messaging system 20 that guarantees that messages in transit will be delivered with at least once semantics. Thereliable messaging system 20 may be configured as follows: no fault tolerance, recoverable from client and network faults, and recoverable from client, network and server faults. - For example, during request processing from multiple clients or a response from a server, the network connection to between a server and a UCD may be lost. If required, on reconnection, the server will automatically run the decision algorithm to determine where to run the Mervlet. In addition, the system administrator can choose whether or not to fault tolerant system components. The tradeoff is that fault tolerance has performance implications that must be weighed against the reliability that is required. The fault tolerance methodology characterizes the various faults in a mobile system based on cost associated with component recovery and its associated cost. It then allows a system administrator to choose the components to recover from.
- 4.1 Recoverable Mervlet Engine
- The
Mervlet engine 12 periodically stores its state on persistent storage, including a list of all currently executing Mervlets 10 and the most recent Mervlet context for each. The list may also contain the priority of each application. In addition, theengine 12 can at any time call the method Save( ) on a Mervlet 10 to save its application state into persistent storage. - The
Mervlet engine 12 can restore its own state to restart the set of Mervlets that it was executing on a device at the time of a crash. TheMervlet engine 12 will restart each Mervlet 10 on its list one at a time. The order for restarting the Mervlets may depend on their priorities. A Mervlet 10 can register the method Restore(ApplicationContext) with theruntime engine 12 when the Mervlet is restarted following a device failure. The data object ApplicationContext includes data from the runtime engine's list that identifies the application and its context. The method Restore(ApplicationContext) can implement Mervlet specific recovery operations, including reading the state of local communication buffers to identify the communication state of thereliable messaging system 20 for the Mervlet on theclient 30. It can also query the communication state of thereliable messaging system 20 for the Mervlet on theserver 32. The method can return control to theMervlet engine 12 after aMervlet 10 has been restored. - 4.2 Reliable Messaging System
- The
messaging system 20 of the Mervlet application environment can utilize various messaging protocols to deliver the contents of a Mervlet and Mervlets themselves in a network and is not limited to the HTTP protocol. For example, types of messaging protocols that have been found useful include one-way and request-response protocols, which could be synchronous or asynchronous. Themessaging system 20 may be fault tolerant to ensure that transactions in progress will be preserved. However, a reliable messaging system is not responsible for recovering Mervlets themselves following device failures. - In particular, a
reliable messaging system 70, shown in FIG. 11, has a queue 72 on the client side such that all outgoing communication from aclient 30 is buffered. The buffer has a user configurable size. Also, each message is tagged with a unique sequence number and a reply is sought for each element. If a reply is not received, the message is retransmitted until a reply is received. When the reply is received, the appropriate buffered message is released from the system. - The
reliable messaging system 70 may be implemented such that a reply is tied either to the underlying operating software of a device or to a higher level event in theMervlet 10. For general application communication, the generic form is used where the reply is tied to the underlying software. For system level reliable communication, the buffering mechanism is tied to the request being received by the Mervlet engine for lower overhead. - In order to implement the
reliable messaging system 70, the following API is provided:void Reliable_async_send(Endpoint to, Endpoint From, MessageData Data, Reliability Type, Callbackmethod cm) - The “to” field identifies the receiver. The “from” field identifies the sender. The “data” field is the serialized data being sent. The “type” is either application level or system level. A callback method is called when an acknowledgement is received. Using this API, the system can guarantee at least one delivery of a message.
- The message format for the
reliable messaging system 70 is shown in FIG. 12. It has a total of six fields, where the first four are fixed size, the data segment is variable size, and the checksum is variable and computed over all the fields. It is possible to relocate a Mervlet in a network using thereliable messaging system 70 by including the Mervlet itself in the data payload of individual messages. - In operation, as shown in FIG. 13, each time a client application sends a message to a Mervlet on a server in
step 102 by calling the method Reliable_async_send, thereliable messaging system 70 on theclient 30 checks to see if there is free buffer space on a persistent storage of the client, such as a flash memory or micro-drive, instep 104. The maximum buffer space is set to a predetermined value, MAX_BUF, by the system administrator. If there is sufficient buffer space available, the message is buffered and a buffer manager of thereliable messaging system 70 attaches a sequence number to the message instep 106. All messages are sent with unique sequence numbers between two pairs of machines. Once the message is buffered, the call can return to the client application. The call does not return to the client application until the message has been buffered to a persistent storage. After the call returns, the client application is assured that the message will be delivered to the appropriate Mervlet even if the client device or network fails. - Periodically, a buffer management thread wakes up and sends the buffered messages to the
server 32 instep 108 and waits for replies to messages previously sent. Each message has a predetermined timeout value associated with it. If a message reply has not been received within the timeout period, then the message is resent. This process continues until a reply has been received. The buffer management thread is only triggered when anaccess network 38 is up and a path to aprimary server 32 has been established. - On receipt of a request message on the server in
step 110, the system administrator can choose how thereliable messaging system 70 should process and deliver the message to the Mervlet on the server. For example, the system can immediately deliver the message to the Mervlet instep 112 and then store the message to a persistent storage instep 114, such as a hard disk. This increases the time the message is not in a “safe” state, but it gives the Mervlet quick access to the message. Alternatively, on receiving the message, thereliable messaging system 70 on theserver 32 can log it in a persistent storage instep 116 and then deliver it to the Mervlet instep 118. The Mervlet then processes the message (step 122) and generates a reply (step 124). It also signals to thereliable messaging system 70 that it has responded. The system logs the reply instep 126 and then attempts to send it to the requesting client instep 128. At this point, the request message is removed from the persistent storage buffer on the server in step 130. - The client on receiving the reply (step132) immediately stores the reply in a buffer on persistent storage (step 134). It then finds the matching request message that was sent to the server and removes it from the buffer in
step 136. Next, the client attempts to deliver the reply to the appropriate callback method from the client application instep 138. Once the callback method is called, the reply is released instep 140. On the server, the buffer for the reply will be released when the next message is received from the same client with a higher sequence number in step 120. If a duplicate message is received by the server, then it is discarded. The size of the acknowledgement buffer is set by the systems administrator to ACK_BUF. - 4.2.1 Finding a Connection to the Primary Server
- The
reliable messaging system 70 manages the connection between aclient device 30 and aserver 32. The system periodically wakes up and performs the following task. It checks to see if theprimary server 32 can be contacted through any of the clients access networks, such Bluetooth, 802.11b (Wi-Fi) wireless, IRDA, and General Packet Radio Service (GPRS) mobile telephone networks 802.11b. It does this by sending an ICMP Ping to theprimary server 32. The first access network that provides a match is used for further communication between theclient 30 and theserver 32. Thereliable messaging system 70 also wakes up its buffer management thread and tells it which protocol to use to communicate with theserver 32. - 4.2.2 Configurability
- Fault tolerance comes at a cost since all writes to a disk cost time and disk space. Referring next to FIG. 14, several configurations for the implementation of the
reliable messaging system 70 are shown. The first row describes a technique where messages being logged on theserver 32 andclient 30, the second describes messages are logged solely on theclient 30, and the third row describes a technique where no messages are logged. The first two options offer the following alternatives for fault tolerance. If a user desires to lower the runtime costs and is willing to spend more time in recovering an application, then the second option may be considered. The first option has higher runtime costs because messages are logged on the client and the server, but the benefit to the user is that the recovery for the application using the reliable messaging system is made more robust. - 4.3 Handling Failures
- When a
server 32 recovers from a failure, it looks at the buffer list on its persistent storage, which was stored instep 106 shown in FIG. 13. Thereliable messaging system 70 assumes that data on the persistent storage of the device is not destroyed, but data in main memory of the device is destroyed. If the list contains a message from aclient 30, then thereliable messaging system 70 assumes that the request has not been processed and attempts to deliver the message to the appropriate Mervlet on the server. Likewise, if theserver 32 finds a buffered reply after recovery from a crash, the system sends it to theappropriate destination client 30. - In order to successfully recover the entire Mervlet application environment from a crash, the following sequence of recovery operations is used:
- 1) The
reliable messaging system 70 comes to a consistent state. - 2) The caching infrastructure, described below, is brought to consistent state.
- 3) The
Mervlet engine 12 comes to a consistent state. - 4) The
individual Mervlets 10 are sequentially brought to a consistent state. - 5. Disconnected Mode Computing
A client device 30 may be “disconnected” from aserver 32 or other devices for two reasons: a network failure or a voluntary move by the system administrator or user, for example to reduce network bandwidth usage. The Mervlet application environment provides two features to support disconnected operation: asynchronous reliable messaging and Mervlet caching. - Asynchronous reliable messaging allows messages to be queued at either the
client 30 or theserver 32 when a network connection is not present between the client and server. When an application sends a message, it is buffered or queued locally, as described above. Messages are sent only when a network connection is established. When a network connection is re-established, the asynchronous reliable messaging system will resend the messages waiting in the buffer queue. Thereliable messaging system 70 can also save the message queues in persistent storage so that device and server failures can be tolerated, as described above. - The second mechanism for disconnected mode computing calls for storing Mervlets in a local cache on the
client device 30. The cache memory is managed by acache manager 22, shown in FIG. 1. The cache is accessible to a browser or other client application even without a network connection. If theclient 30 is disconnected, the Mervlet on the cache can still serve the local browser. In addition, the local browser can still request Mervlets from the local cache. - The cache can be managed in a variety of ways, but preferably it allows intelligent pre-fetching using techniques such as hoarding. The Mervlet caching mechanism allows the
client 30 to delegate a variety of cache management decisions to aserver 32 in situations where the server has more knowledge about future Mervlet accesses, for example in a collaborative setting or in a setting where information is being proactively pushed to theclient device 30. Therefore, a cache management policy can be set by theclient 30, by theserver 32 or a combination of both. At runtime, aserver 32 can update the cache replacement and write policy for each of theMervlets 10 stored on the cache of theclient device 30. - Moreover, those skilled in the art will recognize that the
cache manager 22 can implement caching algorithms that treat code and data separately if they so desire. Also, the cache may consider device characteristics and individual user usage profiles into cache management algorithms. - One implementation of the
cache manager 22 calls methods on a pre_fetch class to implement prefetching, a cache_miss class to implement handling of cache misses and a cache_write class to implement data writes to the cache. - A pre-fetch operation may be server initiated or client initiated. For a server-initiated pre-fetch, the
server 32 sends a pre-fetch notification to theclient 30, which sends back the cache state vector. The server then sends a new set of documents and optionally a new replacement policy to the client. Theserver 32 also makes a request to run aMervlet 10 on theclient device 30. When theMervlet 10 is executed on theclient 30, it sends back the cache state vector to theserver 32. Theserver 32 then sends a set of cache objects to theMervlet 10 and a replacement policy. Next, theMervlet 10 calls back to theserver 32 to load the class for the new replacement policy. - In order to handle a cache miss, the
cache manager 22 on theclient 30 sends a request to theprimary server 32 indicating that a document is missing and a vector of the local cache state when a miss occurs. The vector includes the size of cache and any changes to the hash table for the cache since last update to server. Theprimary server 32 the sends back the requested document. It may also send back other pre-fetched documents and a replacement policy. Theclient 30 uses this new replacement policy on its cache. The following pseudo code that illustrates this method:Void handle_cache_miss( ) Send(primary_server, hash_vector_diff, Uri); Receive(cache_objs, new_policy) if(new_policy) load_class(new_policy); return; - If the
client 30 requests a list ofnew Mervlets 10 for its cache, theserver 32 sends them back and optionally a replacement policy. Once again, the client will proactively download the new class that implements replacement. - The write policy for a local cache on the
client 30 may be changed by thecache manager 22 using a new class that is downloaded from aserver 32. For each element in the cache, theserver 32 can attach a policy on how to handle dirty or written objects when an object is forced to leave the cache. Accordingly, the caching system is configurable be selecting whether the system may perform caching or not. This is a dynamic or runtime choice. In addition, the caching system itself is dynamically extensible in three areas: replacement policy, prefetch policy and modified data management policy. - Although the invention has been described and illustrated with reference to specific illustrative embodiments thereof, it is not intended that the invention be limited to those illustrative embodiments. Those skilled in the art will recognize that variations and modifications can be made without departing from the true scope and spirit of the invention as defined by the claims that follow. It is therefore intended to include within the invention all such variations and modifications as fall within the scope of the appended claims and equivalents thereof.
Claims (1)
Priority Applications (8)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/179,929 US20040001476A1 (en) | 2002-06-24 | 2002-06-24 | Mobile application environment |
EP03723869A EP1516244A4 (en) | 2002-06-24 | 2003-03-31 | Mobile application environment |
CNA2007100854740A CN101039331A (en) | 2002-06-24 | 2003-03-31 | Products for mobile application environment |
CNA2007100854736A CN101039330A (en) | 2002-06-24 | 2003-03-31 | Products for mobile application environment |
PCT/US2003/009934 WO2004001585A1 (en) | 2002-06-24 | 2003-03-31 | Mobile application environment |
CNB038099985A CN1326035C (en) | 2002-06-24 | 2003-03-31 | Mobile application environment |
AU2003230776A AU2003230776A1 (en) | 2002-06-24 | 2003-03-31 | Mobile application environment |
JP2004515623A JP2005531061A (en) | 2002-06-24 | 2003-03-31 | Execution environment for mobile applications |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/179,929 US20040001476A1 (en) | 2002-06-24 | 2002-06-24 | Mobile application environment |
Publications (1)
Publication Number | Publication Date |
---|---|
US20040001476A1 true US20040001476A1 (en) | 2004-01-01 |
Family
ID=29778841
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/179,929 Abandoned US20040001476A1 (en) | 2002-06-24 | 2002-06-24 | Mobile application environment |
Country Status (2)
Country | Link |
---|---|
US (1) | US20040001476A1 (en) |
CN (2) | CN101039330A (en) |
Cited By (51)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20030217106A1 (en) * | 2002-03-25 | 2003-11-20 | Eytan Adar | System and method for profiling clients within a system for harvesting community knowledge |
US20040044663A1 (en) * | 2002-09-03 | 2004-03-04 | Huba Horompoly | Method for asynchronous message control over a wireless network |
US20040068499A1 (en) * | 2002-10-02 | 2004-04-08 | Eytan Adar | System and method for modifying new message retransmission within a system for harvesting community knowledge |
US20040123239A1 (en) * | 2002-10-01 | 2004-06-24 | Andreas Roessler | Document object model caching and validation |
US20040205124A1 (en) * | 2003-03-27 | 2004-10-14 | Limprecht Rodney T. | Availability and scalability in a messaging system in a manner transparent to the application |
US20040258053A1 (en) * | 2003-06-16 | 2004-12-23 | Mentat Inc. | Pre-fetch communication systems and methods |
US20050027907A1 (en) * | 2003-07-29 | 2005-02-03 | Samsung Electronics Co., Ltd. | Method and apparatus for synchronizing timeout values between host and scanning device |
US20050097186A1 (en) * | 2003-10-08 | 2005-05-05 | International Business Machines Corporation | Method, system, and computer program product for managing interaction between remote devices and server resources |
US20060026168A1 (en) * | 2004-05-20 | 2006-02-02 | Bea Systems, Inc. | Data model for occasionally-connected application server |
US20060048748A1 (en) * | 2004-09-07 | 2006-03-09 | Udo Utz | Throttle device |
WO2006035191A1 (en) * | 2004-09-29 | 2006-04-06 | British Telecommunications Public Limited Company | Service discovery and provision for peer - to - peer networks of mobile devices |
US20060117073A1 (en) * | 2004-05-20 | 2006-06-01 | Bea Systems, Inc. | Occasionally-connected application server |
US20060129632A1 (en) * | 2004-12-14 | 2006-06-15 | Blume Leo R | Remote content rendering for mobile viewing |
US20060129972A1 (en) * | 2004-11-30 | 2006-06-15 | Tyburski John C | Application developer and method for generating platform independent code |
US20070100942A1 (en) * | 2003-05-29 | 2007-05-03 | Hong Lin | Method and system for multimedia message service communication |
US7216164B1 (en) * | 2002-10-09 | 2007-05-08 | Cisco Technology, Inc. | Methods and apparatus for determining the performance of a server |
US20080002635A1 (en) * | 2006-07-03 | 2008-01-03 | Palo Alto Research Center Incorporated | Selection of information for transmission and storage in an ad-hoc network based upon local synopsis exchange |
US20080071888A1 (en) * | 2006-09-19 | 2008-03-20 | Searete Llc, A Limited Liability Corporation Of The State Of Delaware | Configuring software agent security remotely |
US20080072032A1 (en) * | 2006-09-19 | 2008-03-20 | Searete Llc, A Limited Liability Corporation Of The State Of Delaware | Configuring software agent security remotely |
US20080307103A1 (en) * | 2007-06-06 | 2008-12-11 | Sony Computer Entertainment Inc. | Mediation for auxiliary content in an interactive environment |
US20080307412A1 (en) * | 2007-06-06 | 2008-12-11 | Sony Computer Entertainment Inc. | Cached content consistency management |
US20080313282A1 (en) * | 2002-09-10 | 2008-12-18 | Warila Bruce W | User interface, operating system and architecture |
US20090091571A1 (en) * | 2007-10-09 | 2009-04-09 | Sony Computer Entertainment America Inc. | Increasing the number of advertising impressions in an interactive environment |
US20090182782A1 (en) * | 2008-01-11 | 2009-07-16 | Karve Alexei A | System and method for restartable provisioning of software components |
US20090210631A1 (en) * | 2006-09-22 | 2009-08-20 | Bea Systems, Inc. | Mobile application cache system |
US20090300110A1 (en) * | 2007-01-12 | 2009-12-03 | Marc Chene | Mobile core client architecture |
US7694008B2 (en) | 2005-05-04 | 2010-04-06 | Venturi Wireless | Method and apparatus for increasing performance of HTTP over long-latency links |
US20100250789A1 (en) * | 2009-03-27 | 2010-09-30 | Qualcomm Incorporated | System and method of managing memory at a portable computing device and a portable computing device docking station |
US20100251243A1 (en) * | 2009-03-27 | 2010-09-30 | Qualcomm Incorporated | System and method of managing the execution of applications at a portable computing device and a portable computing device docking station |
US20100250817A1 (en) * | 2009-03-27 | 2010-09-30 | Qualcomm Incorporated | System and method of managing data communication at a portable computing device and a portable computing device docking station |
US20100251361A1 (en) * | 2009-03-27 | 2010-09-30 | Qualcomm Incorporated | System and method of managing security between a portable computing device and a portable computing device docking station |
US20100250816A1 (en) * | 2009-03-27 | 2010-09-30 | Qualcomm Incorporated | System and method of managing displays at a portable computing device and a portable computing device docking station |
WO2011028177A1 (en) * | 2009-09-04 | 2011-03-10 | Murali Krishnan Vijendran | A context aware content management and delivery system for mobile devices |
US20110191460A1 (en) * | 2006-11-14 | 2011-08-04 | Francoise Sailhan | System and a Method Relating to Network Management |
US8245128B1 (en) * | 2002-07-17 | 2012-08-14 | Oracle International Corporation | Intelligent client agent for a hybrid online/offline application |
US20140286179A1 (en) * | 2013-03-20 | 2014-09-25 | Empire Technology Development, Llc | Hybrid routers in multicore architectures |
US9009296B1 (en) * | 2009-08-07 | 2015-04-14 | Google Inc. | System and method of determining latency |
US20150106428A1 (en) * | 2013-10-15 | 2015-04-16 | Red Hat, Inc. | System and method for collaborative processing of service requests |
US20150180958A1 (en) * | 2002-07-31 | 2015-06-25 | Sony Computer Entertainment America Llc | Systems and methods for seamless host migration |
US9152196B2 (en) | 2009-03-27 | 2015-10-06 | Qualcomm Incorporated | System and method of managing power at a portable computing device and a portable computing device docking station |
US9276979B2 (en) | 2010-09-01 | 2016-03-01 | Vuclip (Singapore) Pte. Ltd. | System and methods for resilient media streaming |
US9280660B2 (en) | 2013-03-15 | 2016-03-08 | Cognizant Business Services Limited | Mobile information management methods and systems |
US20160142507A1 (en) * | 2013-07-02 | 2016-05-19 | Telefonaktiebolaget L M Ericsson (Publ) | Caching content |
US9516068B2 (en) | 2002-07-31 | 2016-12-06 | Sony Interactive Entertainment America Llc | Seamless host migration based on NAT type |
US9762631B2 (en) | 2002-05-17 | 2017-09-12 | Sony Interactive Entertainment America Llc | Managing participants in an online session |
WO2019220447A1 (en) * | 2018-05-17 | 2019-11-21 | Neragon Networks Ltd | Mobile ad-hoc wireless networks |
US10639550B2 (en) * | 2017-04-18 | 2020-05-05 | Bullguard Ltd | System and method for dynamically allocating resources to a game process |
US10695671B2 (en) | 2018-09-28 | 2020-06-30 | Sony Interactive Entertainment LLC | Establishing and managing multiplayer sessions |
US10765952B2 (en) | 2018-09-21 | 2020-09-08 | Sony Interactive Entertainment LLC | System-level multiplayer matchmaking |
USRE48700E1 (en) | 2002-04-26 | 2021-08-24 | Sony Interactive Entertainment America Llc | Method for ladder ranking in a game |
US11792147B2 (en) * | 2021-11-29 | 2023-10-17 | Aidan Lok | Communications networks |
Families Citing this family (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
DE102019206923B3 (en) * | 2019-05-13 | 2020-08-13 | Volkswagen Aktiengesellschaft | Method for running an application on a distributed system architecture |
Citations (39)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5909540A (en) * | 1996-11-22 | 1999-06-01 | Mangosoft Corporation | System and method for providing highly available data storage using globally addressable memory |
US5928323A (en) * | 1996-05-30 | 1999-07-27 | Sun Microsystems, Inc. | Apparatus and method for dynamically generating information with server-side software objects |
US6092178A (en) * | 1998-09-03 | 2000-07-18 | Sun Microsystems, Inc. | System for responding to a resource request |
US6115745A (en) * | 1997-11-25 | 2000-09-05 | International Business Machines Corporation | Scheduling of distributed agents in a dialup network |
US6195680B1 (en) * | 1998-07-23 | 2001-02-27 | International Business Machines Corporation | Client-based dynamic switching of streaming servers for fault-tolerance and load balancing |
US6223217B1 (en) * | 1994-02-08 | 2001-04-24 | Object Technology Licensing Corporation | Distributed object networking service |
US6356929B1 (en) * | 1999-04-07 | 2002-03-12 | International Business Machines Corporation | Computer system and method for sharing a job with other computers on a computer network using IP multicast |
US20020054090A1 (en) * | 2000-09-01 | 2002-05-09 | Silva Juliana Freire | Method and apparatus for creating and providing personalized access to web content and services from terminals having diverse capabilities |
US6397217B1 (en) * | 1999-03-04 | 2002-05-28 | Futuretense, Inc. | Hierarchical caching techniques for efficient dynamic page generation |
US20020101880A1 (en) * | 2001-01-30 | 2002-08-01 | Byoung-Jo Kim | Network service for adaptive mobile applications |
US20020103814A1 (en) * | 2000-12-12 | 2002-08-01 | Edouard Duvillier | High speed, non-log based database recovery technique |
US20020128984A1 (en) * | 2001-02-26 | 2002-09-12 | 4Thpass Inc. | Method and system for transmission-based billing of applications |
US20020131404A1 (en) * | 2000-11-28 | 2002-09-19 | 4Thpass Inc. | Method and system for maintaining and distributing wireless applications |
US20020165900A1 (en) * | 2001-03-21 | 2002-11-07 | Nec Corporation | Dynamic load-distributed computer system using estimated expansion ratios and load-distributing method therefor |
US20020166117A1 (en) * | 2000-09-12 | 2002-11-07 | Abrams Peter C. | Method system and apparatus for providing pay-per-use distributed computing resources |
US6487607B1 (en) * | 1998-02-26 | 2002-11-26 | Sun Microsystems, Inc. | Methods and apparatus for remote method invocation |
US20020178262A1 (en) * | 2001-05-22 | 2002-11-28 | David Bonnell | System and method for dynamic load balancing |
US20020184618A1 (en) * | 2001-06-04 | 2002-12-05 | Vasanth Bala | Networked client-server architecture for transparently transforming and executing applications |
US6516350B1 (en) * | 1999-06-17 | 2003-02-04 | International Business Machines Corporation | Self-regulated resource management of distributed computer resources |
US20030056026A1 (en) * | 2001-09-17 | 2003-03-20 | Ed Anuff | Graphical user interface for performing administration on web components of web sites in a portal framework |
US20030061365A1 (en) * | 2001-03-14 | 2003-03-27 | Microsoft Corporation | Service-to-service communication for network services |
US20030069974A1 (en) * | 2001-10-08 | 2003-04-10 | Tommy Lu | Method and apparatus for load balancing web servers and virtual web servers |
US20030084177A1 (en) * | 2001-10-26 | 2003-05-01 | Nokia Corporation | Mobile client provisioning web service |
US20030084165A1 (en) * | 2001-10-12 | 2003-05-01 | Openwave Systems Inc. | User-centric session management for client-server interaction using multiple applications and devices |
US6560616B1 (en) * | 1999-03-26 | 2003-05-06 | Microsoft Corporation | Robust modification of persistent objects while preserving formatting and other attributes |
US20030110131A1 (en) * | 2001-12-12 | 2003-06-12 | Secretseal Inc. | Method and architecture for providing pervasive security to digital assets |
US6581094B1 (en) * | 1999-11-02 | 2003-06-17 | Sun Microsystems, Inc. | Apparatus and method for identifying a digital device based on the device's uniform device descriptor file that specifies the attributes of the device in a XML document in a networked environment |
US20030119546A1 (en) * | 2001-12-21 | 2003-06-26 | Hayduk Matthew A. | Portable communication device that may permit one wireless network to communicate with another wireless networks and method therefor |
US20030131075A1 (en) * | 2001-05-08 | 2003-07-10 | Narad Networks, Inc. | Language and interface for unified network service creation, provision and deployment |
US20030135509A1 (en) * | 2002-01-11 | 2003-07-17 | Davis Andrew Thomas | Edge server java application framework having application server instance resource monitoring and management |
US20030232616A1 (en) * | 2001-02-23 | 2003-12-18 | Mobilitec, Inc. | Rule-based system and method for managing the provisioning of user applicatins on limited-resource and/or wireless devices |
US6697849B1 (en) * | 1999-08-13 | 2004-02-24 | Sun Microsystems, Inc. | System and method for caching JavaServer Pages™ responses |
US6708276B1 (en) * | 1999-08-03 | 2004-03-16 | International Business Machines Corporation | Architecture for denied permissions in Java |
US6789126B1 (en) * | 2000-05-09 | 2004-09-07 | Sun Microsystems, Inc. | Addressing message gates in a distributed computing environment |
US6823382B2 (en) * | 2001-08-20 | 2004-11-23 | Altaworks Corporation | Monitoring and control engine for multi-tiered service-level management of distributed web-application servers |
US6922695B2 (en) * | 2001-09-06 | 2005-07-26 | Initiate Systems, Inc. | System and method for dynamically securing dynamic-multi-sourced persisted EJBS |
US6934532B2 (en) * | 2000-02-09 | 2005-08-23 | Apriva, Inc. | Communication systems, components, and methods operative with programmable wireless devices |
US7072934B2 (en) * | 2000-01-14 | 2006-07-04 | Saba Software, Inc. | Method and apparatus for a business applications server management system platform |
US7133526B2 (en) * | 2002-05-21 | 2006-11-07 | Wavelink Corporation | System and method for providing WLAN security through synchronized update and rotation of WEP keys |
-
2002
- 2002-06-24 US US10/179,929 patent/US20040001476A1/en not_active Abandoned
-
2003
- 2003-03-31 CN CNA2007100854736A patent/CN101039330A/en active Pending
- 2003-03-31 CN CNA2007100854740A patent/CN101039331A/en active Pending
Patent Citations (39)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6223217B1 (en) * | 1994-02-08 | 2001-04-24 | Object Technology Licensing Corporation | Distributed object networking service |
US5928323A (en) * | 1996-05-30 | 1999-07-27 | Sun Microsystems, Inc. | Apparatus and method for dynamically generating information with server-side software objects |
US5909540A (en) * | 1996-11-22 | 1999-06-01 | Mangosoft Corporation | System and method for providing highly available data storage using globally addressable memory |
US6115745A (en) * | 1997-11-25 | 2000-09-05 | International Business Machines Corporation | Scheduling of distributed agents in a dialup network |
US6487607B1 (en) * | 1998-02-26 | 2002-11-26 | Sun Microsystems, Inc. | Methods and apparatus for remote method invocation |
US6195680B1 (en) * | 1998-07-23 | 2001-02-27 | International Business Machines Corporation | Client-based dynamic switching of streaming servers for fault-tolerance and load balancing |
US6092178A (en) * | 1998-09-03 | 2000-07-18 | Sun Microsystems, Inc. | System for responding to a resource request |
US6397217B1 (en) * | 1999-03-04 | 2002-05-28 | Futuretense, Inc. | Hierarchical caching techniques for efficient dynamic page generation |
US6560616B1 (en) * | 1999-03-26 | 2003-05-06 | Microsoft Corporation | Robust modification of persistent objects while preserving formatting and other attributes |
US6356929B1 (en) * | 1999-04-07 | 2002-03-12 | International Business Machines Corporation | Computer system and method for sharing a job with other computers on a computer network using IP multicast |
US6516350B1 (en) * | 1999-06-17 | 2003-02-04 | International Business Machines Corporation | Self-regulated resource management of distributed computer resources |
US6708276B1 (en) * | 1999-08-03 | 2004-03-16 | International Business Machines Corporation | Architecture for denied permissions in Java |
US6697849B1 (en) * | 1999-08-13 | 2004-02-24 | Sun Microsystems, Inc. | System and method for caching JavaServer Pages™ responses |
US6581094B1 (en) * | 1999-11-02 | 2003-06-17 | Sun Microsystems, Inc. | Apparatus and method for identifying a digital device based on the device's uniform device descriptor file that specifies the attributes of the device in a XML document in a networked environment |
US7072934B2 (en) * | 2000-01-14 | 2006-07-04 | Saba Software, Inc. | Method and apparatus for a business applications server management system platform |
US6934532B2 (en) * | 2000-02-09 | 2005-08-23 | Apriva, Inc. | Communication systems, components, and methods operative with programmable wireless devices |
US6789126B1 (en) * | 2000-05-09 | 2004-09-07 | Sun Microsystems, Inc. | Addressing message gates in a distributed computing environment |
US20020054090A1 (en) * | 2000-09-01 | 2002-05-09 | Silva Juliana Freire | Method and apparatus for creating and providing personalized access to web content and services from terminals having diverse capabilities |
US20020166117A1 (en) * | 2000-09-12 | 2002-11-07 | Abrams Peter C. | Method system and apparatus for providing pay-per-use distributed computing resources |
US20020131404A1 (en) * | 2000-11-28 | 2002-09-19 | 4Thpass Inc. | Method and system for maintaining and distributing wireless applications |
US20020103814A1 (en) * | 2000-12-12 | 2002-08-01 | Edouard Duvillier | High speed, non-log based database recovery technique |
US20020101880A1 (en) * | 2001-01-30 | 2002-08-01 | Byoung-Jo Kim | Network service for adaptive mobile applications |
US20030232616A1 (en) * | 2001-02-23 | 2003-12-18 | Mobilitec, Inc. | Rule-based system and method for managing the provisioning of user applicatins on limited-resource and/or wireless devices |
US20020128984A1 (en) * | 2001-02-26 | 2002-09-12 | 4Thpass Inc. | Method and system for transmission-based billing of applications |
US20030061365A1 (en) * | 2001-03-14 | 2003-03-27 | Microsoft Corporation | Service-to-service communication for network services |
US20020165900A1 (en) * | 2001-03-21 | 2002-11-07 | Nec Corporation | Dynamic load-distributed computer system using estimated expansion ratios and load-distributing method therefor |
US20030131075A1 (en) * | 2001-05-08 | 2003-07-10 | Narad Networks, Inc. | Language and interface for unified network service creation, provision and deployment |
US20020178262A1 (en) * | 2001-05-22 | 2002-11-28 | David Bonnell | System and method for dynamic load balancing |
US20020184618A1 (en) * | 2001-06-04 | 2002-12-05 | Vasanth Bala | Networked client-server architecture for transparently transforming and executing applications |
US6823382B2 (en) * | 2001-08-20 | 2004-11-23 | Altaworks Corporation | Monitoring and control engine for multi-tiered service-level management of distributed web-application servers |
US6922695B2 (en) * | 2001-09-06 | 2005-07-26 | Initiate Systems, Inc. | System and method for dynamically securing dynamic-multi-sourced persisted EJBS |
US20030056026A1 (en) * | 2001-09-17 | 2003-03-20 | Ed Anuff | Graphical user interface for performing administration on web components of web sites in a portal framework |
US20030069974A1 (en) * | 2001-10-08 | 2003-04-10 | Tommy Lu | Method and apparatus for load balancing web servers and virtual web servers |
US20030084165A1 (en) * | 2001-10-12 | 2003-05-01 | Openwave Systems Inc. | User-centric session management for client-server interaction using multiple applications and devices |
US20030084177A1 (en) * | 2001-10-26 | 2003-05-01 | Nokia Corporation | Mobile client provisioning web service |
US20030110131A1 (en) * | 2001-12-12 | 2003-06-12 | Secretseal Inc. | Method and architecture for providing pervasive security to digital assets |
US20030119546A1 (en) * | 2001-12-21 | 2003-06-26 | Hayduk Matthew A. | Portable communication device that may permit one wireless network to communicate with another wireless networks and method therefor |
US20030135509A1 (en) * | 2002-01-11 | 2003-07-17 | Davis Andrew Thomas | Edge server java application framework having application server instance resource monitoring and management |
US7133526B2 (en) * | 2002-05-21 | 2006-11-07 | Wavelink Corporation | System and method for providing WLAN security through synchronized update and rotation of WEP keys |
Cited By (113)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20030217106A1 (en) * | 2002-03-25 | 2003-11-20 | Eytan Adar | System and method for profiling clients within a system for harvesting community knowledge |
US9053458B2 (en) | 2002-03-25 | 2015-06-09 | Hewlett-Packard Development Company, L.P. | System and method for profiling clients within a system for harvesting community knowledge |
USRE48803E1 (en) | 2002-04-26 | 2021-11-02 | Sony Interactive Entertainment America Llc | Method for ladder ranking in a game |
USRE48802E1 (en) | 2002-04-26 | 2021-11-02 | Sony Interactive Entertainment America Llc | Method for ladder ranking in a game |
USRE48700E1 (en) | 2002-04-26 | 2021-08-24 | Sony Interactive Entertainment America Llc | Method for ladder ranking in a game |
US10659500B2 (en) | 2002-05-17 | 2020-05-19 | Sony Interactive Entertainment America Llc | Managing participants in an online session |
US9762631B2 (en) | 2002-05-17 | 2017-09-12 | Sony Interactive Entertainment America Llc | Managing participants in an online session |
US8245128B1 (en) * | 2002-07-17 | 2012-08-14 | Oracle International Corporation | Intelligent client agent for a hybrid online/offline application |
US9516068B2 (en) | 2002-07-31 | 2016-12-06 | Sony Interactive Entertainment America Llc | Seamless host migration based on NAT type |
US20150180958A1 (en) * | 2002-07-31 | 2015-06-25 | Sony Computer Entertainment America Llc | Systems and methods for seamless host migration |
US9729621B2 (en) * | 2002-07-31 | 2017-08-08 | Sony Interactive Entertainment America Llc | Systems and methods for seamless host migration |
US20040044663A1 (en) * | 2002-09-03 | 2004-03-04 | Huba Horompoly | Method for asynchronous message control over a wireless network |
US10372796B2 (en) | 2002-09-10 | 2019-08-06 | Sqgo Innovations, Llc | Methods and systems for the provisioning and execution of a mobile software application |
US8307331B2 (en) * | 2002-09-10 | 2012-11-06 | SQGo, LLC | User interface, operating system and architecture |
US9390191B2 (en) | 2002-09-10 | 2016-07-12 | SQGo, LLC | Methods and systems for the provisioning and execution of a mobile software application |
US10552520B2 (en) | 2002-09-10 | 2020-02-04 | Sqgo Innovations, Llc | System and method for provisioning a mobile software application to a mobile device |
US10839141B2 (en) | 2002-09-10 | 2020-11-17 | Sqgo Innovations, Llc | System and method for provisioning a mobile software application to a mobile device |
US20100274869A1 (en) * | 2002-09-10 | 2010-10-28 | Warila Bruce W | User interface, operating system and architecture |
US9311284B2 (en) | 2002-09-10 | 2016-04-12 | SQGo, LLC | Methods and systems for enabling the provisioning and execution of a platform-independent application |
US20080313282A1 (en) * | 2002-09-10 | 2008-12-18 | Warila Bruce W | User interface, operating system and architecture |
US10831987B2 (en) | 2002-09-10 | 2020-11-10 | Sqgo Innovations, Llc | Computer program product provisioned to non-transitory computer storage of a wireless mobile device |
US10810359B2 (en) | 2002-09-10 | 2020-10-20 | Sqgo Innovations, Llc | System and method for provisioning a mobile software application to a mobile device |
US9135227B2 (en) | 2002-09-10 | 2015-09-15 | SQGo, LLC | Methods and systems for enabling the provisioning and execution of a platform-independent application |
US9342492B1 (en) | 2002-09-10 | 2016-05-17 | SQGo, LLC | Methods and systems for the provisioning and execution of a mobile software application |
US7712025B2 (en) * | 2002-10-01 | 2010-05-04 | Sap Aktiengesellschaft | Document object model caching and validation |
US20040123239A1 (en) * | 2002-10-01 | 2004-06-24 | Andreas Roessler | Document object model caching and validation |
US20040068499A1 (en) * | 2002-10-02 | 2004-04-08 | Eytan Adar | System and method for modifying new message retransmission within a system for harvesting community knowledge |
US7246121B2 (en) * | 2002-10-02 | 2007-07-17 | Hewlett-Packard Development Company, L.P. | System and method for modifying new message retransmission within a system for harvesting community knowledge |
US7216164B1 (en) * | 2002-10-09 | 2007-05-08 | Cisco Technology, Inc. | Methods and apparatus for determining the performance of a server |
US7693952B2 (en) * | 2003-03-27 | 2010-04-06 | Microsoft Corporation | Availability and scalability in a messaging system in a manner transparent to the application |
US8135794B2 (en) * | 2003-03-27 | 2012-03-13 | Microsoft Corporation | Availability and scalability in a messaging system in a manner transparent to the application |
US20040205124A1 (en) * | 2003-03-27 | 2004-10-14 | Limprecht Rodney T. | Availability and scalability in a messaging system in a manner transparent to the application |
US20100192025A1 (en) * | 2003-03-27 | 2010-07-29 | Microsoft Corporation | Availability and scalability in a messaging system in a manner transparent to the application |
US20080227433A1 (en) * | 2003-05-29 | 2008-09-18 | Hong Lin | Method and system for multimedia message service communication |
US20070100942A1 (en) * | 2003-05-29 | 2007-05-03 | Hong Lin | Method and system for multimedia message service communication |
US7359395B2 (en) * | 2003-06-16 | 2008-04-15 | Packeteer, Inc. | Pre-fetch communication systems and methods |
US20040258053A1 (en) * | 2003-06-16 | 2004-12-23 | Mentat Inc. | Pre-fetch communication systems and methods |
US20050027907A1 (en) * | 2003-07-29 | 2005-02-03 | Samsung Electronics Co., Ltd. | Method and apparatus for synchronizing timeout values between host and scanning device |
US20050097186A1 (en) * | 2003-10-08 | 2005-05-05 | International Business Machines Corporation | Method, system, and computer program product for managing interaction between remote devices and server resources |
US20060117073A1 (en) * | 2004-05-20 | 2006-06-01 | Bea Systems, Inc. | Occasionally-connected application server |
US7650432B2 (en) | 2004-05-20 | 2010-01-19 | Bea Systems, Inc. | Occasionally-connected application server |
US20060053368A1 (en) * | 2004-05-20 | 2006-03-09 | Bea Systems, Inc. | Conduit manager for occasionally-connected application server |
US20060030292A1 (en) * | 2004-05-20 | 2006-02-09 | Bea Systems, Inc. | Client programming for mobile client |
US20060026168A1 (en) * | 2004-05-20 | 2006-02-02 | Bea Systems, Inc. | Data model for occasionally-connected application server |
US20060031256A1 (en) * | 2004-05-20 | 2006-02-09 | Bea Systems, Inc. | Template language for mobile client |
US20060031228A1 (en) * | 2004-05-20 | 2006-02-09 | Bea Systems, Inc. | Adaptive user interface for occasionally-connected application server |
US20060031264A1 (en) * | 2004-05-20 | 2006-02-09 | Bea Systems, Inc. | Synchronization protocol for occasionally-connected application server |
US20060048748A1 (en) * | 2004-09-07 | 2006-03-09 | Udo Utz | Throttle device |
WO2006035191A1 (en) * | 2004-09-29 | 2006-04-06 | British Telecommunications Public Limited Company | Service discovery and provision for peer - to - peer networks of mobile devices |
US20080072220A1 (en) * | 2004-09-29 | 2008-03-20 | Saffre Fabrice T | Sharing Data Processing Resources |
US20060129972A1 (en) * | 2004-11-30 | 2006-06-15 | Tyburski John C | Application developer and method for generating platform independent code |
US20060129632A1 (en) * | 2004-12-14 | 2006-06-15 | Blume Leo R | Remote content rendering for mobile viewing |
US7694008B2 (en) | 2005-05-04 | 2010-04-06 | Venturi Wireless | Method and apparatus for increasing performance of HTTP over long-latency links |
US20100100687A1 (en) * | 2005-05-04 | 2010-04-22 | Krishna Ramadas | Method and Apparatus For Increasing Performance of HTTP Over Long-Latency Links |
US9043389B2 (en) | 2005-05-04 | 2015-05-26 | Venturi Ip Llc | Flow control method and apparatus for enhancing the performance of web browsers over bandwidth constrained links |
US7945692B2 (en) | 2005-05-04 | 2011-05-17 | Venturi Wireless | Method and apparatus for increasing performance of HTTP over long-latency links |
US8296353B2 (en) | 2005-05-04 | 2012-10-23 | Venturi Wireless, Inc. | Flow control method and apparatus for enhancing the performance of web browsers over bandwidth constrained links |
US7835351B2 (en) * | 2006-07-03 | 2010-11-16 | Palo Alto Research Center Incorporated | Selection of information for transmission and storage in an ad-hoc network based upon local synopsis exchange |
US20080002635A1 (en) * | 2006-07-03 | 2008-01-03 | Palo Alto Research Center Incorporated | Selection of information for transmission and storage in an ad-hoc network based upon local synopsis exchange |
US7752255B2 (en) * | 2006-09-19 | 2010-07-06 | The Invention Science Fund I, Inc | Configuring software agent security remotely |
US20080072032A1 (en) * | 2006-09-19 | 2008-03-20 | Searete Llc, A Limited Liability Corporation Of The State Of Delaware | Configuring software agent security remotely |
US20080071888A1 (en) * | 2006-09-19 | 2008-03-20 | Searete Llc, A Limited Liability Corporation Of The State Of Delaware | Configuring software agent security remotely |
US8645973B2 (en) | 2006-09-22 | 2014-02-04 | Oracle International Corporation | Mobile applications |
US9398077B2 (en) | 2006-09-22 | 2016-07-19 | Oracle International Corporation | Mobile applications |
US20090300656A1 (en) * | 2006-09-22 | 2009-12-03 | Bea Systems, Inc. | Mobile applications |
US20090210631A1 (en) * | 2006-09-22 | 2009-08-20 | Bea Systems, Inc. | Mobile application cache system |
US20110191460A1 (en) * | 2006-11-14 | 2011-08-04 | Francoise Sailhan | System and a Method Relating to Network Management |
US10193960B2 (en) | 2007-01-12 | 2019-01-29 | ProntoForms Inc. | Mobile core client architecture |
US20090300110A1 (en) * | 2007-01-12 | 2009-12-03 | Marc Chene | Mobile core client architecture |
US9113282B2 (en) | 2007-01-12 | 2015-08-18 | Truecontext Corporation | Mobile core client architecture |
US20080307103A1 (en) * | 2007-06-06 | 2008-12-11 | Sony Computer Entertainment Inc. | Mediation for auxiliary content in an interactive environment |
US20080307412A1 (en) * | 2007-06-06 | 2008-12-11 | Sony Computer Entertainment Inc. | Cached content consistency management |
WO2008154424A1 (en) * | 2007-06-06 | 2008-12-18 | Sony Computer Entertainment Inc. | Cached content consistency management |
US10547670B2 (en) | 2007-10-05 | 2020-01-28 | Sony Interactive Entertainment America Llc | Systems and methods for seamless host migration |
US11228638B2 (en) | 2007-10-05 | 2022-01-18 | Sony Interactive Entertainment LLC | Systems and methods for seamless host migration |
US10063631B2 (en) | 2007-10-05 | 2018-08-28 | Sony Interactive Entertainment America Llc | Systems and methods for seamless host migration |
US9272203B2 (en) | 2007-10-09 | 2016-03-01 | Sony Computer Entertainment America, LLC | Increasing the number of advertising impressions in an interactive environment |
US11660529B2 (en) | 2007-10-09 | 2023-05-30 | Sony Interactive Entertainment LLC | Increasing the number of advertising impressions in an interactive environment |
US20090091571A1 (en) * | 2007-10-09 | 2009-04-09 | Sony Computer Entertainment America Inc. | Increasing the number of advertising impressions in an interactive environment |
US10974137B2 (en) | 2007-10-09 | 2021-04-13 | Sony Interactive Entertainment LLC | Increasing the number of advertising impressions in an interactive environment |
US10343060B2 (en) | 2007-10-09 | 2019-07-09 | Sony Interactive Entertainment LLC | Increasing the number of advertising impressions in an interactive environment |
US9795875B2 (en) | 2007-10-09 | 2017-10-24 | Sony Interactive Entertainment America Llc | Increasing the number of advertising impressions in an interactive environment |
US8416247B2 (en) | 2007-10-09 | 2013-04-09 | Sony Computer Entertaiment America Inc. | Increasing the number of advertising impressions in an interactive environment |
US20090182782A1 (en) * | 2008-01-11 | 2009-07-16 | Karve Alexei A | System and method for restartable provisioning of software components |
US8776018B2 (en) | 2008-01-11 | 2014-07-08 | International Business Machines Corporation | System and method for restartable provisioning of software components |
US20100250789A1 (en) * | 2009-03-27 | 2010-09-30 | Qualcomm Incorporated | System and method of managing memory at a portable computing device and a portable computing device docking station |
US20100251361A1 (en) * | 2009-03-27 | 2010-09-30 | Qualcomm Incorporated | System and method of managing security between a portable computing device and a portable computing device docking station |
US9201593B2 (en) | 2009-03-27 | 2015-12-01 | Qualcomm Incorporated | System and method of managing displays at a portable computing device and a portable computing device docking station |
US20100251243A1 (en) * | 2009-03-27 | 2010-09-30 | Qualcomm Incorporated | System and method of managing the execution of applications at a portable computing device and a portable computing device docking station |
US9128669B2 (en) | 2009-03-27 | 2015-09-08 | Qualcomm Incorporated | System and method of managing security between a portable computing device and a portable computing device docking station |
US9152196B2 (en) | 2009-03-27 | 2015-10-06 | Qualcomm Incorporated | System and method of managing power at a portable computing device and a portable computing device docking station |
US20100250817A1 (en) * | 2009-03-27 | 2010-09-30 | Qualcomm Incorporated | System and method of managing data communication at a portable computing device and a portable computing device docking station |
US20100250816A1 (en) * | 2009-03-27 | 2010-09-30 | Qualcomm Incorporated | System and method of managing displays at a portable computing device and a portable computing device docking station |
US9444711B1 (en) | 2009-08-07 | 2016-09-13 | Google Inc. | System and method of determining latency |
US9009296B1 (en) * | 2009-08-07 | 2015-04-14 | Google Inc. | System and method of determining latency |
US9954970B1 (en) | 2009-08-07 | 2018-04-24 | Google Llc | System and method of determining latency |
WO2011028177A1 (en) * | 2009-09-04 | 2011-03-10 | Murali Krishnan Vijendran | A context aware content management and delivery system for mobile devices |
US9276979B2 (en) | 2010-09-01 | 2016-03-01 | Vuclip (Singapore) Pte. Ltd. | System and methods for resilient media streaming |
US9280660B2 (en) | 2013-03-15 | 2016-03-08 | Cognizant Business Services Limited | Mobile information management methods and systems |
US9473426B2 (en) * | 2013-03-20 | 2016-10-18 | Empire Technology Development Llc | Hybrid routers in multicore architectures |
US20140286179A1 (en) * | 2013-03-20 | 2014-09-25 | Empire Technology Development, Llc | Hybrid routers in multicore architectures |
TWI565265B (en) * | 2013-03-20 | 2017-01-01 | 英派爾科技開發有限公司 | Hybrid routers in multicore architectures |
US20160142507A1 (en) * | 2013-07-02 | 2016-05-19 | Telefonaktiebolaget L M Ericsson (Publ) | Caching content |
US20150106428A1 (en) * | 2013-10-15 | 2015-04-16 | Red Hat, Inc. | System and method for collaborative processing of service requests |
US9602629B2 (en) * | 2013-10-15 | 2017-03-21 | Red Hat, Inc. | System and method for collaborative processing of service requests |
US10639550B2 (en) * | 2017-04-18 | 2020-05-05 | Bullguard Ltd | System and method for dynamically allocating resources to a game process |
US11523325B2 (en) | 2018-05-17 | 2022-12-06 | Neragon Networks Ltd. | Mobile ad-hoc wireless networks |
WO2019220447A1 (en) * | 2018-05-17 | 2019-11-21 | Neragon Networks Ltd | Mobile ad-hoc wireless networks |
US11849307B2 (en) | 2018-05-17 | 2023-12-19 | Neragon Networks Ltd. | Mobile ad-hoc wireless networks |
US10765952B2 (en) | 2018-09-21 | 2020-09-08 | Sony Interactive Entertainment LLC | System-level multiplayer matchmaking |
US10695671B2 (en) | 2018-09-28 | 2020-06-30 | Sony Interactive Entertainment LLC | Establishing and managing multiplayer sessions |
US11364437B2 (en) | 2018-09-28 | 2022-06-21 | Sony Interactive Entertainment LLC | Establishing and managing multiplayer sessions |
US11792147B2 (en) * | 2021-11-29 | 2023-10-17 | Aidan Lok | Communications networks |
Also Published As
Publication number | Publication date |
---|---|
CN101039331A (en) | 2007-09-19 |
CN101039330A (en) | 2007-09-19 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20040001476A1 (en) | Mobile application environment | |
US7454458B2 (en) | Method and system for application load balancing | |
Flinn | Cyber foraging: Bridging mobile and cloud computing | |
Gray et al. | D'Agents: Applications and performance of a mobile‐agent system | |
US9794365B2 (en) | Re-establishing push notification channels via user identifiers | |
Puliafito et al. | MAP: Design and implementation of a mobile agents' platform | |
US7707573B1 (en) | Systems and methods for providing and installing software | |
Mascolo et al. | Mobile computing middleware | |
EP1449078B1 (en) | A method and system for offloading execution and resources for resource-constrained networked devices | |
EP1516244A1 (en) | Mobile application environment | |
Johansen et al. | A tacoma retrospective | |
US20170222891A1 (en) | Automatic asynchronous handoff identification | |
KR20110076954A (en) | Optimized polling in low resource devices | |
US20030236826A1 (en) | System and method for making mobile applications fault tolerant | |
Yau et al. | A context-sensitive middleware for dynamic integration of mobile devices with network infrastructures | |
WO2012001634A1 (en) | Method and apparatus for providing energy-aware connection and code offloading | |
Chu et al. | Challenges: wireless Web services | |
Chowdhury et al. | A fault-tolerant approach to alleviate failures in offloading systems | |
Ravi et al. | Portable smart messages for ubiquitous java-enabled devices | |
Balasubramanian et al. | Towards middleware for fault-tolerance in distributed real-time and embedded systems | |
Al-Bar et al. | Camel: a mobile applications framework | |
Samaras et al. | Tracker: A universal location management system for mobile agents | |
Kao et al. | Automatic adaptation of mobile applications to different user devices using modular mobile agents | |
Madiraju et al. | An agent module for a system on mobile devices | |
JP2005293316A (en) | Terminal, program providing device and program acquisition method |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: DOCOMO COMMUNICATIONS LABORATORIES USA, INC., CALIFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:ISLAM, NAYEEM;SHOAIB, SHAHID;REEL/FRAME:013344/0135Effective date: 20020912 |
|
AS | Assignment |
Owner name: NTT DOCOMO, INC.,JAPANFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:DOCOMO COMMUNICATIONS LABORATORIES USA, INC.;REEL/FRAME:017228/0646Effective date: 20051107Owner name: NTT DOCOMO, INC., JAPANFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:DOCOMO COMMUNICATIONS LABORATORIES USA, INC.;REEL/FRAME:017228/0646Effective date: 20051107 |
|
STCB | Information on status: application discontinuation |
Free format text: ABANDONED -- FAILURE TO RESPOND TO AN OFFICE ACTION |
|
AS | Assignment |
Owner name: GOOGLE INC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:NTT DOCOMO, INC.;REEL/FRAME:039885/0615Effective date: 20160122 |