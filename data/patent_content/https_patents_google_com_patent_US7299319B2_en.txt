US7299319B2 - Method and apparatus for providing hardware assistance for code coverage - Google Patents
Method and apparatus for providing hardware assistance for code coverage Download PDFInfo
- Publication number
- US7299319B2 US7299319B2 US10/807,094 US80709404A US7299319B2 US 7299319 B2 US7299319 B2 US 7299319B2 US 80709404 A US80709404 A US 80709404A US 7299319 B2 US7299319 B2 US 7299319B2
- Authority
- US
- United States
- Prior art keywords
- instruction
- data
- code
- access
- processor
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active - Reinstated, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/34—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment
- G06F11/3466—Performance evaluation by tracing or monitoring
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/3668—Software testing
- G06F11/3672—Test management
- G06F11/3676—Test management for coverage analysis
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2201/00—Indexing scheme relating to error detection, to error correction, and to monitoring
- G06F2201/865—Monitoring of software
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2201/00—Indexing scheme relating to error detection, to error correction, and to monitoring
- G06F2201/88—Monitoring involving counting
Definitions
- the present invention is related to the following applications entitled “Method and Apparatus for Counting Instruction Execution and Data Accesses”, Ser. No. 10/675,777, filed on Sep. 30, 2003; “Method and Apparatus for Selectively Counting Instructions and Data Accesses”, Ser. No. 10/674,604, filed on Sep. 30, 2003; “Method and Apparatus for Generating Interrupts Upon Execution of Marked Instructions and Upon Access to Marked Memory Locations”, Ser. No. 10/675,831, filed on Sep. 30, 2003; “Method and Apparatus for Counting Data Accesses and Instruction Executions that Exceed a Threshold”, Ser. No.
- the present invention relates generally to an improved data processing system.
- the present invention provides a method and apparatus for obtaining performance data in a data processing system.
- the present invention provides a method and apparatus for hardware assistance to software tools in obtaining code coverage data in a data processing system.
- Performance tools are used to monitor and examine a data processing system to determine resource consumption as various software applications are executing within the data processing system. For example, a performance tool may identify the most frequently executed modules and instructions in a data processing system, or may identify those modules which allocate the largest amount of memory or perform the most I/O requests. Hardware performance tools may be built into the system or added at a later point in time.
- a trace tool may use more than one technique to provide trace information that indicates execution flows for an executing program.
- One technique keeps track of particular sequences of instructions by logging certain events as they occur. This technique is called a event-based profiling technique.
- a trace tool may log every entry into, and every exit from, a module, subroutine, method, function, or system component.
- a trace tool may log the requester and the amounts of memory allocated for each memory allocation request. Typically, a time-stamped record is produced for each such event.
- Corresponding pairs of records similar to entry-exit records also are used to trace execution of arbitrary code segments, starting and completing I/O or data transmission, and for many other events of interest.
- Another trace technique involves periodically sampling a program's execution flows to identify certain locations in the program in which the program appears to spend large amounts of time. This technique is based on the idea of periodically interrupting the application or data processing system execution at regular intervals. This technique is referred to as a sample-based profiling technique. At each interruption, information is recorded for a predetermined length of time or for a predetermined number of events of interest. For example, the program counter of the currently executing thread, which is an executable portion of the larger program being profiled, may be recorded at each interval. These values may be resolved against a load map and symbol table information for the data processing system at post-processing time and a profile of where the time is being spent may be obtained from this analysis.
- Determining testing coverage is a difficult problem with currently available software tools.
- code coverage When testing code for programs, no easy mechanism is present to determine what code is executed and what code is not executed. This type of identification is also referred to as code coverage.
- Software techniques and tools are present for identifying code coverage. These techniques and tools, however, usually involve changing the code that is being tested. Having to change or instrument code is undesirable because such a process may be tedious and time consuming.
- Other types of techniques and tools are based on generating test cases from static analysis of the program. This type of methodology cannot guarantee full coverage in testing.
- Creating tools such as these to find answers related to specific situations or problems can take much effort and can be very difficult to calibrate as the software tools themselves affect the system under test.
- the present invention recognizes that hardware assistance for tool development and problem analysis can significantly ease the amount of effort needed to develop software performance tools. Further, with the increasing density of processors, hardware assistance can be included to provide additional debug and analysis features.
- the present invention provides a method, apparatus, and computer instructions for generating coverage data during execution of code in the data processing system.
- a determination is made as to whether an access indicator is associated with an instruction in response to executing the instruction in the code by a processor in the data processing system. If the access indicator is associated with the instruction, a state of the access indicator is changed, by the processor, when the instruction is executed. In this manner, coverage data for executed instructions is generated by the processor during execution of the code.
- FIG. 1 is a block diagram of a data processing system in which the present invention may be implemented
- FIG. 2 is a block diagram of a processor system for processing information in accordance with a preferred embodiment of the present invention
- FIG. 3 is a diagram illustrating components used in processing instructions associated with indicators in accordance with a preferred embodiment of the present invention
- FIG. 4 is a diagram illustrating data flow for signals used to set indicators identifying memory locations that have been accessed in accordance with a preferred embodiment of the present invention
- FIG. 5 is a diagram illustrating one mechanism for associating an access indicator with an instruction or memory location in accordance with a preferred embodiment of the present invention
- FIG. 6 is a diagram illustrating a bundle in accordance with a preferred embodiment of the present invention.
- FIG. 7 is a block diagram illustrating components used for generating metadata, such as indicators, in accordance with a preferred embodiment of the present invention.
- FIG. 8 is an exemplary block diagram of data flow in which a page table is used to translate the memory address specified by the program into a physical address in accordance with an exemplary embodiment of the present invention
- FIG. 9 is an exemplary page table entry in accordance with an exemplary embodiment of the present invention.
- FIG. 10 is a flowchart of a process for marking access to instructions in accordance with the preferred embodiment of the present invention.
- FIG. 11 is a flowchart of a process for illustrating a process followed by an instruction cache to set instruction access indicators in accordance with the preferred embodiment of the present invention
- FIG. 12 is a flowchart of a process for illustrating marking access to a subroutine in accordance with the preferred embodiment of the present invention.
- FIG. 13 is a flowchart of a process for identifying access to code segments in accordance with the preferred embodiment of the present invention.
- FIG. 14 is a block diagram illustrating components used to analyze code coverage data in accordance with a preferred embodiment of the present invention.
- FIG. 15 is a flowchart of a process for collecting code coverage data and displaying paths that are covered and not covered within a program in accordance with the preferred embodiment of the present invention.
- FIG. 16 is a flowchart of a process for marking access to memory locations containing data in accordance with the preferred embodiment of the present invention.
- FIG. 17 is a flowchart of a process for illustrating a process followed by a data cache in accordance with the preferred embodiment of the present invention.
- FIG. 18 is a flowchart of a process for obtaining call stack information when a dynamic memory allocation occurs during runtime in accordance with the preferred embodiment of the present invention.
- FIG. 19 is a flowchart of a process for sending information regarding data access that occurs during execution of a program when memory is deallocated in accordance with the preferred embodiment of the present invention.
- FIG. 20 is a flowchart of a process for generating a call flow tree to identify areas that have not been initialized or accessed in accordance with the preferred embodiment of the present invention
- FIG. 21 is a diagram illustrating a graphical report showing coverage of data areas in accordance with a preferred embodiment of the present invention.
- FIG. 22 is a flowchart of a process for generating the display information in accordance with the preferred embodiment of the present invention.
- FIG. 23 is a flowchart of a process for prefetching of data into a cache using metadata in accordance with the preferred embodiment of the present invention.
- FIG. 24 is a flowchart of a process for illustrating metadata including an identification of what data is to be prefetched from the starting point in accordance with the preferred embodiment of the present invention.
- FIG. 25 is a flowchart of a process for illustrating metadata including an identification of what data is to be prefetched from the starting point in accordance with the preferred embodiment of the present invention.
- Client 100 is an example of a computer, in which code or instructions implementing the processes of the present invention may be located.
- Client 100 employs a peripheral component interconnect (PCI) local bus architecture.
- PCI peripheral component interconnect
- AGP Accelerated Graphics Port
- ISA Industry Standard Architecture
- Processor 102 and main memory 104 are connected to PCI local bus 106 through PCI bridge 108 .
- PCI bridge 108 also may include an integrated memory controller and cache memory for processor 102 . Additional connections to PCI local bus 106 may be made through direct component interconnection or through add-in boards.
- local area network (LAN) adapter 110 small computer system interface SCSI host bus adapter 112 , and expansion bus interface 114 are connected to PCI local bus 106 by direct component connection.
- audio adapter 116 graphics adapter 118 , and audio/video adapter 119 are connected to PCI local bus 106 by add-in boards inserted into expansion slots.
- Expansion bus interface 114 provides a connection for a keyboard and mouse adapter 120 , modem 122 , and additional memory 124 .
- SCSI host bus adapter 112 provides a connection for hard disk drive 126 , tape drive 128 , and CD-ROM drive 130 .
- Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.
- An operating system runs on processor 102 and is used to coordinate and provide control of various components within data processing system 100 in FIG. 1 .
- the operating system may be a commercially available operating system such as Windows XP, which is available from Microsoft Corporation.
- An object oriented programming system such as Java may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on client 100 . “Java” is a trademark of Sun Microsystems, Inc. Instructions for the operating system, the object-oriented programming system, and applications or programs are located on storage devices, such as hard disk drive 126 , and may be loaded into main memory 104 for execution by processor 102 .
- FIG. 1 may vary depending on the implementation.
- Other internal hardware or peripheral devices such as flash read-only memory (ROM), equivalent nonvolatile memory, or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in FIG. 1 .
- the processes of the present invention may be applied to a multiprocessor data processing system.
- client 100 if optionally configured as a network computer, may not include SCSI host bus adapter 112 , hard disk drive 126 , tape drive 128 , and CD-ROM 130 .
- the computer to be properly called a client computer, includes some type of network communication interface, such as LAN adapter 110 , modem 122 , or the like.
- client 100 may be a stand-alone system configured to be bootable without relying on some type of network communication interface, whether or not client 100 comprises some type of network communication interface.
- client 100 may be a personal digital assistant (PDA), which is configured with ROM and/or flash ROM to provide non-volatile memory for storing operating system files and/or user-generated data.
- PDA personal digital assistant
- processor 102 uses computer implemented instructions, which may be located in a memory such as, for example, main memory 104 , memory 124 , or in one or more peripheral devices 126 - 130 .
- FIG. 2 a block diagram of a processor system for processing information is depicted in accordance with a preferred embodiment of the present invention.
- Processor 210 may be implemented as processor 102 in FIG. 1 .
- processor 210 is a single integrated circuit superscalar microprocessor. Accordingly, as discussed further herein below, processor 210 includes various units, registers, buffers, memories, and other sections, all of which are formed by integrated circuitry. Also, in the preferred embodiment, processor 210 operates according to reduced instruction set computer (“RISC”) techniques. As shown in FIG. 2 , system bus 211 is connected to a bus interface unit (“BIU”) 212 of processor 210 . BIU 212 controls the transfer of information between processor 210 and system bus 211 .
- BIU bus interface unit
- BIU 212 is connected to an instruction cache 214 and to data cache 216 of processor 210 .
- Instruction cache 214 outputs instructions to sequencer unit 218 .
- sequencer unit 218 selectively outputs instructions to other execution circuitry of processor 210 .
- the execution circuitry of processor 210 includes a number of processor units that are used to execute instructions. These processor units are also called execution units.
- the execution units include, for example, a branch unit 220 , a fixed-point unit A (“FXUA”) 222 , a fixed-point unit B (“FXUB”) 224 , a complex fixed-point unit (“CFXU”) 226 , a load/store unit (“LSU”) 228 , and a floating-point unit (“FPU”) 230 .
- FXUA 222 , FXUB 224 , CFXU 226 , and LSU 228 input their source operand information from general-purpose architectural registers (“GPRs”) 232 and fixed-point rename buffers 234 .
- FXUA 222 and FXUB 224 input a “carry bit” from a carry bit (“CA”) register 242 .
- FXUA 222 , FXUB 224 , CFXU 226 , and LSU 228 output results (destination operand information) of their operations for storage at selected entries in fixed-point rename buffers 234 .
- CFXU 226 inputs and outputs source operand information and destination operand information to and from special-purpose register processing unit (“SPR unit”) 240 .
- SPR unit special-purpose register processing unit
- FPU 230 inputs its source operand information from floating-point architectural registers (“FPRs”) 236 and floating-point rename buffers 238 .
- FPU 230 outputs results (destination operand information) of its operation for storage at selected entries in floating-point rename buffers 238 .
- LSU 228 In response to a Load instruction, LSU 228 inputs information from data cache 216 and copies such information to selected ones of rename buffers 234 and 238 . If such information is not stored in data cache 216 , then data cache 216 inputs (through BIU 212 and system bus 211 ) such information from a system memory 260 connected to system bus 211 . Moreover, data cache 216 is able to output (through BIU 212 and system bus 211 ) information from data cache 216 to system memory 260 connected to system bus 211 . In response to a Store instruction, LSU 228 inputs information from a selected one of GPRs 232 and FPRs 236 and copies such information to data cache 216 .
- Sequencer unit 218 inputs and outputs information to and from GPRs 232 and FPRs 236 .
- branch unit 220 inputs instructions and signals indicating a present state of processor 210 .
- branch unit 220 outputs (to sequencer unit 218 ) signals indicating suitable memory addresses storing a sequence of instructions for execution by processor 210 .
- sequencer unit 218 inputs the indicated sequence of instructions from instruction cache 214 . If one or more of the sequence of instructions is not stored in instruction cache 214 , then instruction cache 214 inputs (through BIU 212 and system bus 211 ) such instructions from system memory 260 connected to system bus 211 .
- sequencer unit 218 In response to the instructions input from instruction cache 214 , sequencer unit 218 selectively dispatches the instructions to selected ones of execution units 220 , 222 , 224 , 226 , 228 , and 230 .
- Each execution unit executes one or more instructions of a particular class of instructions.
- FXUA 222 and FXUB 224 execute a first class of fixed-point mathematical operations on source operands, such as addition, subtraction, ANDing, ORing and XORing.
- CFXU 226 executes a second class of fixed-point operations on source operands, such as fixed-point multiplication and division.
- FPU 230 executes floating-point operations on source operands, such as floating-point multiplication and division.
- rename buffers 234 As information is stored at a selected one of rename buffers 234 , such information is associated with a storage location (e.g. one of GPRs 232 or CA register 242 ) as specified by the instruction for which the selected rename buffer is allocated. Information stored at a selected one of rename buffers 234 is copied to its associated one of GPRs 232 (or CA register 242 ) in response to signals from sequencer unit 218 . Sequencer unit 218 directs such copying of information stored at a selected one of rename buffers 234 in response to “completing” the instruction that generated the information. Such copying is called “writeback”.
- a storage location e.g. one of GPRs 232 or CA register 242
- Sequencer unit 218 directs such copying of information stored at a selected one of rename buffers 234 in response to “completing” the instruction that generated the information. Such copying is called “writeback”.
- rename buffers 238 As information is stored at a selected one of rename buffers 238 , such information is associated with one of FPRs 236 . Information stored at a selected one of rename buffers 238 is copied to its associated one of FPRs 236 in response to signals from sequencer unit 218 . Sequencer unit 218 directs such copying of information stored at a selected one of rename buffers 238 in response to “completing” the instruction that generated the information.
- Processor 210 achieves high performance by processing multiple instructions simultaneously at various ones of execution units 220 , 222 , 224 , 226 , 228 , and 230 . Accordingly, each instruction is processed as a sequence of stages, each being executable in parallel with stages of other instructions. Such a technique is called “pipelining.” In a significant aspect of the illustrative embodiment, an instruction is normally processed as six stages, namely fetch, decode, dispatch, execute, completion, and writeback.
- sequencer unit 218 selectively inputs (from instruction cache 214 ) one or more instructions from one or more memory addresses storing the sequence of instructions discussed further hereinabove in connection with branch unit 220 , and sequencer unit 218 .
- sequencer unit 218 decodes up to four fetched instructions.
- sequencer unit 218 selectively dispatches up to four decoded instructions to selected (in response to the decoding in the decode stage) ones of execution units 220 , 222 , 224 , 226 , 228 , and 230 after reserving rename buffer entries for the dispatched instructions' results (destination operand information).
- operand information is supplied to the selected execution units for dispatched instructions.
- Processor 210 dispatches instructions in order of their programmed sequence.
- execution units execute their dispatched instructions and output results (destination operand information) of their operations for storage at selected entries in rename buffers 234 and rename buffers 238 as discussed further hereinabove. In this manner, processor 210 is able to execute instructions out-of-order relative to their programmed sequence.
- sequencer unit 218 indicates an instruction is “complete.”
- Processor 210 “completes” instructions in order of their programmed sequence.
- sequencer 218 directs the copying of information from rename buffers 234 and 238 to GPRs 232 and FPRs 236 , respectively. Sequencer unit 218 directs such copying of information stored at a selected rename buffer.
- processor 210 updates its architectural states in response to the particular instruction.
- Processor 210 processes the respective “writeback” stages of instructions in order of their programmed sequence. Processor 210 advantageously merges an instruction's completion stage and writeback stage in specified situations.
- each instruction requires one machine cycle to complete each of the stages of instruction processing. Nevertheless, some instructions (e.g., complex fixed-point instructions executed by CFXU 226 ) may require more than one cycle. Accordingly, a variable delay may occur between a particular instruction's execution and completion stages in response to the variation in time required for completion of preceding instructions.
- a completion buffer 248 is provided within sequencer 218 to track the completion of the multiple instructions which are being executed within the execution units. Upon an indication that an instruction or a group of instructions have been completed successfully, in an application specified sequential order, completion buffer 248 may be utilized to initiate the transfer of the results of those completed instructions to the associated general-purpose registers.
- processor 210 also includes processor monitoring unit 240 , which is connected to instruction cache 214 as well as other units in processor 210 . Operation of processor 210 can be monitored utilizing performance monitor unit 240 , which in this illustrative embodiment is a software-accessible mechanism capable of providing detailed information descriptive of the utilization of instruction execution resources and storage control. Although not illustrated in FIG.
- performance monitor unit 240 is coupled to each functional unit of processor 210 to permit the monitoring of all aspects of the operation of processor 210 , including, for example, reconstructing the relationship between events, identifying false triggering, identifying performance bottlenecks, monitoring pipeline stalls, monitoring idle processor cycles, determining dispatch efficiency, determining branch efficiency, determining the performance penalty of misaligned data accesses, identifying the frequency of execution of serialization instructions, identifying inhibited interrupts, and determining performance efficiency.
- Performance monitor unit 240 includes an implementation-dependent number (e.g., 2-8) of counters 241 - 242 , labeled PMC 1 and PMC 2 , which are utilized to count occurrences of selected events. Performance monitor unit 240 further includes at least one monitor mode control register (MMCR). In this example, two control registers, MMCRs 243 and 244 are present that specify the function of counters 241 - 242 . Counters 241 - 242 and MMCRs 243 - 244 are preferably implemented as SPRs that are accessible for read or write via MFSPR (move from SPR) and MTSPR (move to SPR) instructions executable by CFXU 26 .
- MFSPR move from SPR
- MTSPR move to SPR
- counters 241 - 242 and MMCRs 243 - 244 may be implemented simply as addresses in I/O space.
- control registers and counters may be accessed indirectly via an index register. This embodiment is implemented in the IA-64 architecture in processors from Intel Corporation.
- processor 210 also includes interrupt unit 250 , which is connected to instruction cache 214 . Additionally, although not shown in FIG. 2 , interrupt unit 250 is connected to other processor units within processor 210 . Interrupt unit 250 may receive signals from other processor units and initiate an action, such as starting an error handling or trap process. In these examples, interrupt unit 250 is employed to generate interrupts and exceptions that may occur during execution of a program.
- the present invention provides an ability to monitor the execution of specific instructions, as well as, the access of specific memory locations during the execution of a program. This type of determination also is referred to as code coverage.
- a spare field may be used to hold an indicator that is associated with a specific instruction or memory location. This indicator may be set in response to execution of the instruction or access to the memory location. Examination of these indicators may be used to determine what code has been executed and what code has not been executed. A similar identification may be made as to what memory locations have or have not been accessed during execution of the code. Alternatively, the indicator may be stored in another location in association with the instruction or memory location.
- an indicator may be associated with the data or memory locations in which the data is located.
- Data access indicators are associated with memory locations, while instruction access indicators are associated with instructions. These indicators are typically initialized as being unset prior to execution of a program.
- the instruction access indicator associated with that instruction is set. Access to a memory location results in an indicator associated with that memory location being set.
- an identification of code coverage may be made. This examination may take place using processes implemented in a software tool designed to test code coverage. In this manner, code coverage, with respect to instructions and data access to memory locations, may be made without requiring statistical analysis or instrumentation of code.
- Instruction cache 300 receives bundles 302 .
- Instruction cache 300 is an example of instruction cache 214 in FIG. 2 .
- a bundle is a grouping of instructions. This type of grouping of instructions is typically found in an IA-64 processor, which is available from Intel Corporation.
- Instruction cache 300 processes instructions for execution.
- instruction cache 300 dispatches instructions to different execution units for execution.
- Signal 304 is received from completion buffer 306 when execution of the instruction has occurred.
- Completion buffer 306 is an example of a completion buffer, such as completion buffer 248 in FIG. 2 .
- Signal 304 identifies the instruction for which execution has completed. This identification may take different forms. For example, entry numbers corresponding to entries in completion buffer 306 may be used to identify the instruction for which execution has completed. With this approach, instruction cache 300 knows where the specified instruction resides in its cache. Depending upon the processor implementation, other indicators may be used to identify which instruction has completed, such as, the position in cache 300 .
- instruction cache 300 When signal 304 is received, instruction cache 300 sets the instruction access indicator associated with the instruction that has been executed. In response to receiving signal 304 , instruction cache 300 marks or sets instruction access indicator 308 , which is associated with the instruction that has completed execution. This indicator may be in various locations, depending on the particular implementation. For example, instruction access indicator 308 may be located in a spare bit or field in the instruction, in a shadow memory, or in a page table.
- the data and indicators are processed by a data cache, such as data cache 216 in FIG. 2 , rather than by an instruction cache.
- the processor may have a combined data and instruction cache in which case, the indicators set as appropriate.
- this signal may be generated by other processor units depending on the particular processor architecture and configuration.
- this unit may be the processing unit actually processing the instruction.
- the dispatching of an instruction to a processor unit for execution may be an acceptable point in time to indicate that the instruction has been executed. In other words, if an instruction is not speculatively executed, a dispatcher in the processor may mark the instruction as executed.
- Data cache 400 receives signal 402 from completion buffer 404 when an instruction has been executed.
- Signal 402 also includes an indication that data in a memory location has been accessed by the executed instruction.
- data access indicator 406 is set. This data access indicator is associated with the memory location accessed by the completed instruction. Metadata is used to map the association of indicators to memory locations in the case in which the data access indicators are not included in the memory locations themselves. The position of the instruction/data in the cache unit identifies the location in physical memory of the instruction/data. All currently available cache units have this capability. The cache unit also knows the location of the where to update the access indicators.
- FIG. 5 a diagram illustrating one mechanism for associating an access indicator with an instruction or memory location is depicted in accordance with a preferred embodiment of the present invention.
- Processor 500 receives instructions from cache 502 .
- the indicators are not stored with the instructions or in the memory locations in which data is found. Instead, the indicators are stored in a separate area of storage, access indicator shadow cache 504 .
- the storage may be any storage device, such as for example, a system memory, a flash memory, a cache, or a disk.
- processor 500 When processor 500 receives and then executes an instruction from cache 502 , processor 500 sets an instruction access indicator in access indicator shadow cache 504 , corresponding to the instruction from cache 502 . A similar process is performed with respect to accesses of memory locations containing data. In one embodiment, a full shadow word is provided for each corresponding word that does not affect the actual data segments. In other words, processor 500 allows for the architecture or configuration of cache 502 to remain unchanged. In these examples, the mapping described is word for word. However, some other type of mapping may be used, such as a shadow bit per data word in which a bit in access indicator shadow cache 504 corresponds to one word of data.
- the compilers using this feature, create the debug information in a separate work area from the data area themselves in a manner similar to debug symbols.
- the extra information, access indicators is prepared by the loader so that it will be available to incorporate into access indicator shadow cache 504 when instructions are loaded into cache 502 .
- These cache areas may be intermingled and either marked as such or understood by the mode of operation.
- Processor 500 sets the access indicators when related data accesses and instruction executions occur.
- the process is programmed by a debugger or an analysis program to know whether to use the shadow information while the process is executing instructions.
- Bundle 600 contains instruction slot 602 , instruction 604 , instruction slot 606 and template 608 . As illustrated, bundle 600 contains 128 bits. Each instructions slot contains 41 bits, and template 608 contains 5 bits. Template 608 is used to identify stops within the current bundle and to map instructions within the slots to different types of execution units.
- Spare bits within bundle 600 are used to hold indicators of the present invention.
- indicators 610 , 612 , and 614 are located within instruction slots 602 , 604 , and 606 , respectively. These indicators may take various forms and may take various sizes depending on the particular implementation.
- Indicators may use a single bit or may use multiple bits. In these illustrative examples, a single bit may be used to indicate that an instruction has been executed. A similar use of fields may be used for indicators that mark data or memory locations. When execution always starts at the first instruction in a bundle, as in the IA64 architecture, two bits may be used to indicate the last instruction executed. This is only needed for templates that have branch instructions. If basic blocks are being flagged, then only branch instructions and the instruction following a branch need be marked.
- FIG. 7 a block diagram illustrating components used for generating metadata and access indicators is depicted in accordance with a preferred embodiment of the present invention.
- the compiler supports directives embedded in the source that indicate the metadata to be generated.
- the metadata is used to indicate what operation is to be performed, such as identifying which instructions or memory locations are to be associated with particular access indicators.
- the metadata defines the mapping of access indicators to individual instructions, groups of instructions, and memory locations.
- the metadata may map access indicators to individual memory locations or to different groupings of memory locations with different sizes depending on the particular implementation. These access indicators are used by the hardware components in the processor to reflect updates made by these components when a memory location is accessed or an instruction is executed.
- Compiler 700 may generate instructions 702 for execution and metadata and access indicators 704 for monitoring code coverage. As instruction or data cache pages are loaded into memory, the operating system program loader/linker and/or the performance monitoring program, reads metadata and access indicators 704 generated by compiler 700 and loads metadata and access indicators 704 into memory. Processor 708 may accept metadata and access indicators 704 in the format as generated by compiler 700 and populate shadow memory 705 with metadata and access indicators 704 .
- the performance monitoring program instead of the compiler, the performance monitoring program generates the metadata and access indicators.
- the format simply has a metadata and/or an access indicator shadow cache entry for each of its block or sector references and moves metadata and access indicators 704 to its corresponding shadow entry or entries.
- the internal format of the cache itself may be modified to contain metadata and access indicators 704 .
- the loader updates the instruction stream to contain the appropriate metadata and/or access indicators and work areas or compiler 700 has generated the code to contain metadata and access indicators 704 .
- the processor receives metadata and access indicators 704 .
- metadata and access indicators 704 may be placed into shadow memory 705 in association with instructions 702 .
- Compiler 700 produces information in a table or debug data section. The performance monitoring program loads this information into shadow data areas in shadow memory 705 .
- the debug areas may be automatically populated by the operating system or performance monitoring program and the processor working together.
- Instructions 702 may then be executed by processor 708 .
- Compiler 700 may set a register such as mode register 710 in processor 708 . When this register is set, processor 708 looks at metadata and access indicators 704 in shadow memory 705 when executing instructions 702 to determine whether metadata and access indicators 704 are associated with instructions that are being executed in instructions 702 .
- Mode register 710 is used to turn on and off the feature of marking access to instructions in these illustrative embodiments.
- the metadata within metadata and access indicator 704 may be used to set mode register 710 in addition to defining instructions or groups of instructions that are to be associated with access indicators.
- each instruction associated with an access indicator has its associated access indicator set when that instruction is executed.
- this access indicator is set when any instruction in the group is executed in these illustrative examples.
- Metadata and access indicators 704 may be placed within the instruction or within the data, rather than in shadow memory 705 . However, by placing metadata and access indicators 704 in shadow memory 705 , the generation of metadata and access indicators 704 may be performed dynamically when metadata and access indicators 704 are placed in shadow memory 705 .
- compiler 700 may generate metadata and access indicators 704 after instructions 702 have been compiled for execution by processor 708 .
- Setting mode register 710 causes processor 708 to look for metadata and access indicators 704 in performance instrumentation shadow memory 705 without having to modify instructions 702 .
- the presence of an access indicator associated with an instruction or memory location causes processor 708 to set the access indicator when the execution of the instruction in instructions 702 occurs and/or data is accessed to the memory location in memory locations 712 .
- FIG. 8 illustrates an exemplary block diagram of data flow in which a page table is used to translate the memory address specified by the program into a physical address in accordance with an exemplary embodiment of the present invention.
- a program address 810 (for data or instruction) is translated to a virtual address by way of the address space register 820 using one of the various means of specifying the active address space.
- the resultant virtual address is used by the processor to search page table 830 for a page descriptor in page table 830 that matches the virtual address.
- the contents of the matching page descriptor commonly contain the physical address and attributes associated with the virtual page. These contents are used to translate the virtual address to a physical address and to determine the attributes of the page (e.g., access rights).
- the page table is expanded to include additional fields for each entry for storing access indicators, such as instruction access indicators and data access indicators.
- access indicators such as instruction access indicators and data access indicators.
- the access indicator information in these fields may be cached in processor resources similar to a Translation Look-aside Buffer (TLB) or an Effective to Real Address Translation Buffer (ERAT).
- TLB Translation Look-aside Buffer
- ERAT Effective to Real Address Translation Buffer
- PILAB Performance Indicator Look-Aside Buffer
- the page table may be consulted to obtain this information.
- FIG. 9 illustrates an exemplary page table entry in accordance with an exemplary embodiment of the present invention.
- the page table entry 900 includes field 910 for storing a virtual page address, field 920 for storing a physical page address, and code coverage fields 930 - 950 for storing data relating to determining code coverage.
- These fields are ones used by testing or performance monitoring applications for determining the code coverage of a computer application that is being tested.
- These code coverage fields may include, for example, an instruction access indicator, a data access indicator, or prefetch information.
- the values of these additional fields 930 - 950 may be set by different components in a processor based on information provided to these units by a testing or performance monitoring application.
- the access indicators may be associated with these instructions and/or data portions within the page table.
- the virtual address of the instruction or data portion may be used to identify an entry in the page table and the values stored in additional fields 930 and 940 may be checked to see if an access indicator is associated with the physical page or a portion of the physical page. That is, if the offset associated with the virtual address falls within an offset range identified in field 930 has an access indicator stored therein, then the instruction corresponding to the virtual address has an associated access indicator. This indicator is set in the event that the instruction is executed.
- Access type field 940 is used to identify the type of access that has occurred with respect to accesses to a memory location.
- Prefetch information field 950 may include information, such as pointers, offsets, and addresses. Thus, for example, when an instruction or portion of data must be retrieved from physical storage, the page table is consulted to identify the physical storage location of the instruction or portion of data. At the same time, fields 930 - 950 may be queried and the indicator in access field 930 may be set to indicate that the page has been fetched from physical storage and loaded into the memory or cache.
- FIG. 9 shows only a single field for storing an access indicator, a single field for identifying an access type, and a single field for storing prefetch information
- the present invention is not limited to such. Rather, any number of fields for storing a plurality of access indicators, and the like, associated with the physical page may be used without departing from the spirit and scope of the present invention.
- FIG. 10 a flowchart of a process for marking access to instructions is depicted in accordance with the preferred embodiment of the present invention.
- the process illustrated in FIG. 10 may be implemented into an instruction cache, such as instruction cache 214 in FIG. 2 .
- the process begins by receiving a bundle (step 1000 ). Next, an instruction in the bundle for execution is identified (step 1002 ). Next, the instruction is executed (step 1004 ). In these illustrative examples, part of processing the instruction in step 1004 includes executing the instruction. Then, an indicator associated with the instruction is set to indicate execution of the instruction (step 1006 ). Then, a determination is made as to whether more unprocessed instructions are present in the bundle (step 1008 ).
- step 1002 If more unprocessed instructions are present in the bundle, then the process proceeds to step 1002 as described above. If additional unprocessed instructions are not present in the bundle, then the process terminates.
- one bit is set if the bundle does not have a branch and the bit indicates the last instruction executed when a branch is taken.
- the instruction cache contains all of the information and has direct access to areas containing instruction access indicators to be updated to reflect changes when instructions are executed.
- Information regarding completed execution is provided by a completion buffer or processor units accessing the completion buffer.
- FIG. 11 a flowchart of a process for illustrating a process followed by an instruction cache to set instruction access indicators is depicted in accordance with the preferred embodiment of the present invention.
- the process illustrated in FIG. 11 may be implemented into an instruction cache, such as instruction cache 214 in FIG. 2 .
- the process begins by receiving a signal indicating instruction execution has completed (step 1100 ).
- a signal is received from a completion buffer, such as completion buffer 248 in FIG. 2 .
- This completion buffer includes information identifying the instruction for which execution has completed.
- update information in storage is saved (step 1102 ), with the process terminating thereafter.
- an entry in the instruction cache may be saved into storage. The entry is identified using information received in the signal from the completion buffer. For example, the signal may indicate that the instruction corresponding to item number seven has completed execution.
- the information for this instruction may be located in a register created in the instruction cache to provide a fast path for performing operations. In saving information in the cache, this information is placed in another location, such as a page table or a shadow memory.
- This update also includes the setting of an instruction access indicator if such an indicator is associated with the instruction.
- code coverage with respect to instructions may be identified through the assistance of hardware components in a processor.
- This hardware assistance allows for instructions that have been executed to be identified through instruction access indicators that are set when instructions are executed.
- instruction access indicators that are set when instructions are executed.
- the example described above provides a fine granularity in which each executed instruction is marked. If a coarser granularity is desired, this process may be applied to portions of code, such as code segments or subroutines.
- FIG. 12 a flowchart of a process for illustrating marking access to a subroutine is depicted in accordance with the preferred embodiment of the present invention.
- the process illustrated in FIG. 12 may be implemented into an instruction cache, such as instruction cache 214 in FIG. 2 .
- the process begins by identifying an executed instruction (step 1200 ). Next, a determination is made as to whether the instruction is located at a start address of a subroutine selected for monitoring (step 1202 ). If the instruction is not the start of a subroutine, then a determination is made as to whether an instruction access indicator for an instruction at a start address for the subroutine was previously set (step 1204 ). If a determination is made that the instruction access indicator for the instruction at the start address was previously set, then a determination is made as to whether the identified instruction is one for a return address for the subroutine (step 1206 ). If the instruction is for a return address, then the instruction access indicator for that return instruction is set in metadata associated with the subroutine (step 1208 ), with the process terminating thereafter.
- step 1202 if the identified instruction is for the start of a subroutine, then the process proceeds to step 1208 as described above.
- FIG. 13 a flowchart of a process for identifying access to code segments is depicted in accordance with the preferred embodiment of the present invention.
- the process illustrated in FIG. 13 may be implemented into an instruction cache, such as instruction cache 214 in FIG. 2 .
- the process begins by identifying instruction that is to be executed (step 1300 ). Next, a determination is made as to whether the identified instruction is a branch instruction (step 1302 ). If the instruction is a branch instruction, then the instruction access indicator associated with that instruction is set (step 1304 ) with the process terminating thereafter. As described above, this indicator may be implemented in a number of different ways. For example, the indicator may be located in an extra field or an unused field in the instruction, in a shadow memory, or a page table.
- step 1306 a determination is made as to whether the previous instruction is a branch instruction (step 1306 ). If the previous instruction is a branch instruction, then the process proceeds to step 1304 to mark an instruction access indicator as described above. In step 1306 , if the previous instruction is not a branch instruction then the process terminates. In essence, step 1306 in conjunction with step 1304 marks an instruction subsequent to a branch instruction when a branch does occur.
- the mechanism of the present invention provides hardware assistance for marking code segments that have been executed. By examining the instruction access indicators that have been marked, execution of code segments may be identified in determining code coverage.
- FIG. 14 a block diagram illustrating components used to analyze code coverage data is depicted in accordance with a preferred embodiment of the present invention.
- code coverage information generated by the hardware assistance mechanism of the present invention, software tools may be employed to produce a report or graphical presentation to identify areas of code that have not been executed in contrast to those that have been executed.
- This code coverage information also may include access to memory locations that occur during execution of the code. With this information, new testing of the code may be initiated to generate updated reports or presentations to show changes in code coverage.
- code coverage application 1400 obtains access indicator data 1402 generated by the execution of code 1404 .
- This code may be, for example, a program, an application, or code for a portion of a program or application.
- Access indicator data includes instruction access indicators and/or data access indicators.
- These indicators are initially unset when the execution of code 1404 begins.
- the indicators are set when instructions are executed or data in memory locations are accessed during the execution of instructions.
- the execution of an instruction may cause both the instruction access indicator and the data access indicator for a memory location to be set. After execution of code 1404 , a portion or all of the indicators may be set.
- Code coverage application 1400 analyzes access indicator data 1402 to identify paths of instructions that have been covered or not covered during the execution of code 1404 .
- This execution data is displayed using graphic interface (GUI) 1406 .
- GUI graphic interface
- the display of this data may include highlighting or the use of different colors or graphical indicators to identify instructions that have been executed and to identify memory locations for data that has been accessed.
- GUI 1406 also may be used by the user to set new parameters for use in testing code 1404 . When code 1404 is again tested, the new access or coverage information is then analyzed and displayed in GUI 1406 to allow the user to see how code coverage has changed.
- code coverage application 1400 may be a daemon that runs periodically to sample the coverage and provide updated reports or presentations. The user may change various parameters or may define a set of scenarios that may be used in executing code 1404 .
- code 1500 is an example of source code that has been executed using hardware assistance to mark instruction access indicators for instructions actually executed by the processor.
- sections 1502 , 1504 , and 1506 have been executed, while sections 1508 , 1510 , 1512 , and 1514 are instructions that have not been executed.
- Code 1500 may be presented such that executed instructions are presented using one color, such as green, while unexecuted instructions are presented in another color, such as red. In this manner, the user may easily identify executed and unexecuted instructions. In another embodiment, only the executed or unexecuted instructions are displayed. Further, graphical indicators may be associated or placed next to instructions that have been executed. Many different types of presentation techniques may be used to display code coverage information. For example, the graphical user interface also may employ the use of highlighting, different fonts, and displaying only executed instructions in the display. Any type of presentation system may be used to allow the user to identify executed and unexecuted lines of code.
- FIG. 16 a flowchart of a process for collecting code coverage data and displaying paths that are covered and not covered within a program is depicted in accordance with the preferred embodiment of the present invention.
- the process illustrated in FIG. 16 may be implemented in a code coverage or testing application.
- the process illustrated in FIG. 16 is directed towards the collection of code coverage data with respect to the execution of instructions.
- the process begins by receiving test parameters for use by the program (step 1600 ).
- the following is an example of a command line that may be entered: Test -code -data Application.
- Test is the testing program
- Application is the application to be tested
- -code indicates code coverage
- -data indicates data coverage.
- the program is executed (step 1602 ). Execution of the program in step 1602 causes the generation of code coverage data in the form of access indicators, such as instruction access indicators, being set during execution of instructions for the program by the processor.
- step 1604 a determination is made as to whether collection of code coverage data using hardware assistance execution instructions is complete. If the collection of code coverage data is not complete, the process returns to step 1602 to continue to execute the program. Otherwise, executed instructions are identified (step 1606 ). Step 1606 is implemented in these illustrative examples by identifying instructions with instruction access indicators that have been set. Next, instructions not executed are identified (step 1608 ). Step 1608 is implemented in these illustrative examples by identifying instructions with instruction access indicators that have not been set. Then, execution data identifying paths of execution covered and paths of execution not covered are displayed (step 1610 ). In these examples, the display is in a GUI in which execution paths covered and not covered may be graphically presented to a user for analysis.
- step 1612 a determination is made as to whether new parameters are present for use in executing the program. If there are not new parameters the process terminates. If there are new parameters then the process proceeds to step 1600 as described above.
- the presentation of coverage data is displayed after execution of the program.
- the display of data may occur periodically during the execution of the program and may allow the user to change parameters during execution to see how code coverage changes.
- the mechanism of the present invention also provides a mechanism for determining coverage in the form of data access.
- Indicators may be stored with metadata in which the metadata selects specific pieces of data for instrumentation.
- the indication of whether data has been accessed may be stored in a number of different places. For example, a word may be extended by extra bits, a shadow cache area may be provided, and a page table may be designed to include this information.
- the compilers are updated to support producing a metadata debug section (similar to a symbols section) and the operating system in conjunction with the linker/loader and a performance monitoring or testing coverage device driver allow for specialized operational modes. These techniques mimic an extra bit or word per word of memory.
- a bit is set to indicate that the specified data areas have been executed.
- a variety of ways are present for indicating this support. For example, a bit may be provided for each data byte or a bit for each data word.
- the compiler generated metadata may provide this mapping for the hardware to use. The mapping may have data type dependencies. When a data field is accessed, the appropriate bit for a data access indicator is set. The same bit may be set for different data accesses, depending upon the mapping.
- FIG. 17 a flowchart of a process for marking access to memory locations containing data is depicted in accordance with the preferred embodiment of the present invention. This process is initiated whenever data access occurs in these illustrative examples.
- the process illustrated in FIG. 17 may be implemented in a data cache, such as data cache 216 in FIG. 2 .
- the process begins by detecting access to the data in a memory location (step 1700 ).
- This data access is identified by the data cache in these examples through a signal generated by a completion buffer to indicate that data has been accessed in executing an instruction.
- the instruction executed is identified and its data operand is known by the instruction cache unit, which receives a signal from the completion buffer and sends a signal to the data cache unit indicating the data operand of the instruction has been accessed.
- the completion buffer could send an indication of the data being accessed to the data cache directly. This approach would require the data information to be known by the completion buffer.
- data access indicator associated with memory location containing the data to indicate access is set (step 1702 ).
- the data access indicators may be located in a shadow memory or in a page table.
- the setting of the indicator occurs when the processor is in a selected or special mode to cause a bit to be set for data having a length, such as a byte, a word, or a double word.
- memory location access is processed (step 1704 ), with the process terminating thereafter.
- testing coverage is a difficult issue in which understanding data access and data use may be helpful. In other words, it is helpful to know if an allocated array has been used or if a static piece of data has been exercised. In addition, testing data boundaries also is important in testing coverage. For example, determining whether enough space has been allocated for an array is useful. This determination may be performed by determining whether access outside of an array has occurred.
- the mechanism of the present invention provides for the construction and maintenance of call flow trees that may be accessed by an executing program for use in dynamic data area coverage.
- a routine is called to build trees.
- One methodology for determining the call stack is to walk the stack to determine the calling sequence at the time of the malloc.
- Another methodology it to use the hardware information generated through setting data access indicators. Techniques similar to that described in United States patent application entitled “Method and Apparatus for Determining Computer Program Flows Autonomically Using Hardware Assisted Thread Stack Tracking and Cataloged Symbolic Data”, Ser. No. 10/803,663, filed on Mar. 18, 2004, which is incorporated herein by reference.
- call stack This technique is used to identify the calling sequence; hereafter called call stack.
- This tree is maintained in memory and may be accessed through calls such as application programming interface (API) calls to a device driver which reads the call stack information for the current thread.
- API application programming interface
- the process for maintaining the hardware thread maintained call stack and to convert the addresses to symbolic names also is described in United States patent application entitled “Method and Apparatus for Determining Computer Program Flows Autonomically Using Hardware Assisted Thread Stack Tracking and Cataloged Symbolic Data”, Ser. No. 10/803,663, filed on Mar. 18, 2004.
- the call stack retrieved from the device driver is sent to the arcflow program, which walks the stack into its thread oriented trees.
- FIG. 18 a flowchart of a process for illustrating a process followed by a data cache is depicted in accordance with the preferred embodiment of the present invention.
- the process illustrated in FIG. 18 may be implemented in a data cache, such as data cache 216 in FIG. 2 .
- the process begins by a signal indicating that instruction execution accessing data in a memory location has completed is received (step 1800 ). This signal is typically received from a completion buffer. Update information in storage is saved (step 1802 ), with the process terminating thereafter. Information stored in registers in the data cache is saved. This information may be saved in a page table, as well as setting a data access indicator in another storage, such as in a shadow cache. The information saved in a page table typically contains any changes made by the data accessed by the instruction. While the information saved in the other storage involves setting a data access indicator to indicate that access has occurred to the memory location.
- FIG. 19 a flowchart of a process for obtaining call stack information when a dynamic memory allocation occurs during runtime is depicted in accordance with the preferred embodiment of the present invention.
- the process illustrated in FIG. 19 may be implemented software.
- the process begins by detecting a dynamic memory allocation (step 1900 ).
- the dynamic memory allocation is requested during runtime when an instruction requires an allocation of memory.
- call stack information is obtained (step 1902 ).
- allocated memory is identified (step 1904 ).
- memory for reporting is marked (step 1906 ), with the process terminating thereafter.
- the memory is marked for reporting to let the hardware, such as a data cache, know when to mark access to data within the allocated memory.
- the memory allocation may be such that the memory allocation routine allocates more memory than specified in order to allow for checking for errors. For example, memory allocation routine may allocate an additional byte and flag the start address, the end address, and one byte beyond the end address. In other words, these flagged sections will have data access indicators set if access occurs to these marked addresses. In these examples, one byte beyond the end address is marked such that an access to this memory location causes a data access indicator to be set. In this manner, a determination is made as to whether sufficient memory has been allocated for use. If this data access indicator is set during execution of a program, then insufficient memory may have been allocated since access occurs beyond the area of memory that was allocated.
- FIG. 20 a flowchart of a process for sending information regarding data access that occurs during execution of a program when memory is deallocated is depicted in accordance with the preferred embodiment of the present invention.
- the process illustrated in FIG. 20 may be implemented in software.
- the process begins by memory deallocation being detected (step 2000 ), such as, a free request.
- step 2000 information identifying access to data in allocated memory is collected (step 2002 ).
- step 2004 access data and call stack information is sent for processing (step 2004 ), with the process terminating thereafter.
- This data is sent to a software tool for processing.
- Step 2004 may involve placing the data in a location accessible by the software tool.
- the data is sent in real time as the memory is deallocated. Other times that the information may be collected and sent for processing include sampling that is performed by a monitor process. In other cases, the information may be sent after the program has completed execution.
- the information identifying access to data may include information other than an identification of the memory location. For example, the information also may include an identification of the code that requested the allocation of the memory and the size of the memory that was allocated. Further, the number of accesses to the memory location may be recorded using hardware assist mechanisms described in the cross referenced applications.
- FIG. 21 a flowchart of a process for generating a call flow tree to identify areas that have not been initialized or accessed is depicted in accordance with the preferred embodiment of the present invention.
- the process illustrated in FIG. 21 may be implemented in a software tool used to identify code coverage.
- This process uses the information collected in FIGS. 19 and 20 to generate a call flow tree to identify areas that have not been initialized or accessed.
- This call flow tree also includes information on memory locations that have been accessed, as well as, memory locations that have not been accessed.
- the process begins when access data and call stack information is received (step 2100 ).
- the received data and call stack information is processed (step 2102 ).
- call flow tree identifying callers and code allocating memory is generated (step 2104 ).
- leaf node ID data containing data access information is generated (step 2106 ), with the process terminating thereafter.
- the access information for the data area is placed into a leaf node that is associated with the node that allocated the memory in which the data was accessed.
- the mechanisms of the present invention provide information on areas of data that have not been initialized, not accessed, or accessed.
- the original source code may be marked or presented in a manner to indicate which data areas have been accessed, and which data areas have not been accessed.
- the portions of the source code in which dynamic memory allocation occurs may be flagged such that memory areas allocated during execution have data access indicators marked when access occurs in those memory areas.
- the instructions in the code may be marked to cause the hardware to set indicators when static data structures are accessed.
- FIG. 22 a diagram illustrating a graphical report showing coverage of data areas is depicted in accordance with a preferred embodiment of the present invention.
- report 2200 shows data access coverage in area 2202 .
- This area shows static data areas.
- Sections 2204 , 2206 , and 2208 in area 2202 are memory locations in which data access has occurred. These sections are identified by locating data access indicators that have been set during execution of the code.
- Call flow tree 2210 is an example of a call flow tree in which node D represents a section of code that dynamically allocated memory as shown in area 2212 .
- This information in area 2212 is information located in a leaf node associated with node D in call flow tree 2210 .
- Section 2214 in area 2212 shows portions of area 2212 that were accessed.
- FIG. 23 a flowchart of a process for generating the display information is depicted in accordance with the preferred embodiment of the present invention.
- the process illustrated in FIG. 23 may be implemented into a software tool for determining coverage of data access.
- the process begins by obtaining data access information for static and dynamic data (step 2300 ).
- This information includes obtaining data access indicators that were allocated for execution of the code.
- Other information obtained includes call flow trees generated during dynamic allocation of memory as described above.
- the coverage map for access to static and dynamic data is generated (step 2302 ). Then, the coverage map is displayed (step 2304 ) with the process terminating thereafter.
- the coverage map is similar to report 2200 in FIG. 22 .
- the reporting program may have support to allow offsets to be used in the reporting structures. For example, the c: ⁇ program files ⁇ appl.exe(func1:100) may be used to indicate that the malloc was issued from location 100 in func1.
- Processor bus speeds and memory access is significantly slower than processor speeds. It is more the case that the performance of a data processing system is gated or limited by memory access, rather than by the speed of the processor.
- the result of this phenomenon is the use of multi-level caching, as well as, attempts at prefetching data into these caches for quicker access to data. Attempts at prefetching, however, are usually code or stride driven and do not handle data dependant dynamic access well.
- Most existing approaches require the compilers or programmers to create prefetch hints in the code stream. Once the object code is generated, these hints give information that allows prefetching. This system, however, provides little opportunity to change the code. Examples include chasing references in Java objects for garbage collection or pointer chasing.
- a prefetch indicator may be associated with data.
- the prefetch indicator data may indicate that the data is to be treated as a pointer to be prefetched.
- the prefetch indicator itself may be a pointer to the data structure.
- FIG. 24 a flowchart of a process for prefetching of data into a cache using metadata is depicted in accordance with the preferred embodiment of the present invention.
- the process illustrated in FIG. 24 may be implemented in a load/store unit in these examples.
- the data prefetched is a pointer in these examples.
- the process begins by loading an instruction (step 2400 ). Next, a determination is made as to whether metadata for prefetch is associated with instruction (step 2402 ).
- the metadata is a prefetch indicator that is associated with an instruction.
- the instruction cache determines when and if the instruction cache will speculatively prefetch. For example, the instruction cache may determine that it has no outstanding cache misses and it has cache entries that may be replaced that have not been used for quite some time. In this case, the instruction cache speculatively prefetches. However, if the instruction cache has outstanding misses and/or no convenient cache lines to replace, it may not speculatively prefetch.
- a threshold may be set for the number of cache misses and/or for a number of replaceable cache lines to determine whether the instruction cache will prefetch data when a prefetch indicator is present. For example, a prefetch may occur if outstanding cache misses are less than a selected threshold. Prefetching also may occur in these illustrative examples if replacement of cache lines is desired and if the number of cache lines chosen to be replaced are greater than a selected threshold.
- the load store unit may issue request to speculatively load into the cache unit, but the cache unit determines if it will actually prefetch.
- a load store unit may make the determination as to whether to speculatively load into the cache unit depending upon the hardware implementation. If the hardware decides to prefetch data, then data is prefetched into a cache using the metadata associated with the instruction (step 2406 ). In these examples, the data is a pointer. This pointer is a pointer to a data structure or a block of data. Next, the instruction is sent to a unit for processing (step 2408 ), with the process terminating thereafter.
- step 2404 if hardware decides not to prefetch data then the process returns to step 2408 as described above.
- step 2302 if metadata for prefetch is not associated with instruction, then the process proceeds to step 2408 as described above.
- the hardware may send the instruction to a unit for processing before, at the same time, or after the hardware issues an indication that a prefetch should occur.
- the mechanism of the present invention provides an ability to prefetch data from a memory location within the data structure.
- a stride or offset in conjunction with the pointer may be used to identify the data to be prefetched.
- an address may be used to identify the location of the data that is desired.
- FIG. 25 a flowchart of a process for illustrating metadata including an identification of what data is to be prefetched from the starting point is depicted in accordance with the preferred embodiment of the present invention.
- the process illustrated in FIG. 25 may be implemented into a load store unit, such as load store unit 228 in FIG. 2 .
- the process begins detecting metadata which indicates a prefetch (step 2500 ).
- the metadata may include an identification of what data is to be prefetched from a data structure identified by the pointer. This metadata may include a prefetch indicator in the form of a pointer.
- the metadata also may include an identification of the data itself through the use of an offset or address.
- a determination is made as to whether a prefetch should occur based on the state of the cache unit (step 2502 ).
- the prefetches of these examples are speculative with the processes being performed selectively depending on the state of the cache unit. For example, if a number of cache misses exceeding some value has occurred, the prefetch does not occur and the process terminates.
- step 2502 if the prefetch is to occur, a selected point in memory for the prefetch is located (step 2504 ). This selected point memory may be identified in the metadata using a pointer and an offset or stride, or a memory address.
- data is prefetched from a selected point in the memory into the cache (step 2506 ), with the process terminating thereafter. Referring to step 2502 , if the prefetch does not occur, the process terminates.
- the present invention provides an improved method, apparatus, and computer instructions for providing hardware assistance for code coverage.
- the mechanisms of the present invention allow for an ability to monitor the execution of instructions and access to memory locations during execution of a program.
- Access indicators are provided for indicating instruction execution or access to data in memory locations. The setting of these indicators are performed by hardware, such as different components in a processor. In this manner, software tools may obtain and analyze coverage data with better coverage and avoiding changing the code being tested.
- microcode in these examples, are the lowest level instructions that directly control a processor. A single machine language instruction typically translates into several microcode instructions. Microcode may be in hardware or software form. In many modern processors, the microcode is hard-wired into the processors.
- processor architectures may distribute the functions specified in this application across different units with a variety of mechanisms used to communicate information across the units.
- specific processor units have been described as implementing the functions of the present invention, these different functions may be incorporated into other processor units within the hardware.
- the steps described in the figures may be implemented as either hardware circuitry or as instructions for specific use by the different processor units within a processor, such as microcode for use by an execution unit.
Abstract
Description
Claims (17)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/807,094 US7299319B2 (en) | 2004-03-22 | 2004-03-22 | Method and apparatus for providing hardware assistance for code coverage |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/807,094 US7299319B2 (en) | 2004-03-22 | 2004-03-22 | Method and apparatus for providing hardware assistance for code coverage |
Publications (2)
Publication Number | Publication Date |
---|---|
US20050210452A1 US20050210452A1 (en) | 2005-09-22 |
US7299319B2 true US7299319B2 (en) | 2007-11-20 |
Family
ID=34987856
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/807,094 Active - Reinstated 2025-02-26 US7299319B2 (en) | 2004-03-22 | 2004-03-22 | Method and apparatus for providing hardware assistance for code coverage |
Country Status (1)
Country | Link |
---|---|
US (1) | US7299319B2 (en) |
Cited By (17)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20050183075A1 (en) * | 2004-02-12 | 2005-08-18 | International Business Machines Corporation | Method and apparatus for removal of asynchronous events in complex application performance analysis |
US20050210439A1 (en) * | 2004-03-22 | 2005-09-22 | International Business Machines Corporation | Method and apparatus for autonomic test case feedback using hardware assistance for data coverage |
US20080270995A1 (en) * | 2004-02-12 | 2008-10-30 | International Business Machines Corporation | Method for Automatic Detection of Build Regressions |
US20090300587A1 (en) * | 2008-05-27 | 2009-12-03 | Microsoft Corporation | Determining domain data coverage in testing database applications |
US20090307656A1 (en) * | 2008-06-06 | 2009-12-10 | International Business Machines Corporation | Optimized Scalar Promotion with Load and Splat SIMD Instructions |
US7653899B1 (en) | 2004-07-23 | 2010-01-26 | Green Hills Software, Inc. | Post-execution software debugger with performance display |
US20100153926A1 (en) * | 2008-12-15 | 2010-06-17 | International Business Machines Corporation | Operating system aided code coverage |
US7926041B2 (en) | 2004-03-22 | 2011-04-12 | International Business Machines Corporation | Autonomic test case feedback using hardware assistance for code coverage |
US8015552B1 (en) * | 2004-07-23 | 2011-09-06 | Green Hills Software, Inc. | Post-execution software debugger with coverage display |
US8132159B1 (en) | 2004-07-23 | 2012-03-06 | Green Hills Software, Inc. | Post-execution software debugger with event display |
US8136096B1 (en) | 2004-07-23 | 2012-03-13 | Green Hills Software, Inc. | Backward post-execution software debugger |
US8271955B1 (en) | 2004-07-23 | 2012-09-18 | Green Hille Software, Inc. | Forward post-execution software debugger |
US8381037B2 (en) * | 2003-10-09 | 2013-02-19 | International Business Machines Corporation | Method and system for autonomic execution path selection in an application |
US8615619B2 (en) | 2004-01-14 | 2013-12-24 | International Business Machines Corporation | Qualifying collection of performance monitoring events by types of interrupt when interrupt occurs |
US8689190B2 (en) | 2003-09-30 | 2014-04-01 | International Business Machines Corporation | Counting instruction execution and data accesses |
US8782664B2 (en) | 2004-01-14 | 2014-07-15 | International Business Machines Corporation | Autonomic hardware assist for patching code |
US9727318B2 (en) * | 2014-02-18 | 2017-08-08 | Facebook, Inc. | Techniques to identify and purge unused code |
Families Citing this family (20)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7506330B2 (en) * | 2004-02-12 | 2009-03-17 | International Business Machines Corporation | Method and apparatus for identifying differences in runs of a computer program due to code changes |
US8161461B2 (en) * | 2005-03-24 | 2012-04-17 | Hewlett-Packard Development Company, L.P. | Systems and methods for evaluating code usage |
US20060225051A1 (en) * | 2005-04-05 | 2006-10-05 | Cisco Technology, Inc. | Method and system for code coverage |
US8438365B2 (en) * | 2006-10-06 | 2013-05-07 | Calos Fund Limited Liability Company | Efficient data loading in a data-parallel processor |
US7992059B2 (en) | 2007-09-11 | 2011-08-02 | International Business Machines Corporation | System and method for testing a large memory area during processor design verification and validation |
US20090070570A1 (en) * | 2007-09-11 | 2009-03-12 | Shubhodeep Roy Choudhury | System and Method for Efficiently Handling Interrupts |
US8019566B2 (en) * | 2007-09-11 | 2011-09-13 | International Business Machines Corporation | System and method for efficiently testing cache congruence classes during processor design verification and validation |
US8006221B2 (en) | 2007-09-11 | 2011-08-23 | International Business Machines Corporation | System and method for testing multiple processor modes for processor design verification and validation |
US7752499B2 (en) * | 2007-09-11 | 2010-07-06 | International Business Machines Corporation | System and method for using resource pools and instruction pools for processor design verification and validation |
US8099559B2 (en) * | 2007-09-11 | 2012-01-17 | International Business Machines Corporation | System and method for generating fast instruction and data interrupts for processor design verification and validation |
US8181068B2 (en) * | 2008-03-26 | 2012-05-15 | International Business Machines Corporation | Apparatus for and method of life-time test coverage for executable code |
US20120023483A1 (en) * | 2010-07-20 | 2012-01-26 | Dan Welchman | System and method for use in indicating execution of application code |
US8769497B2 (en) * | 2010-07-20 | 2014-07-01 | General Electric Company | System and method for use in indicating execution of application code |
US8645912B2 (en) | 2010-08-31 | 2014-02-04 | General Electric Company | System and method for use in replaying software application events |
DE102011006215A1 (en) * | 2010-11-09 | 2012-05-10 | Siemens Aktiengesellschaft | Method and device for determining a quality rating of a software code with determination of the evaluation coverage |
US10360140B2 (en) * | 2013-11-27 | 2019-07-23 | Entit Software Llc | Production sampling for determining code coverage |
US9213563B2 (en) * | 2013-12-30 | 2015-12-15 | Unisys Corporation | Implementing a jump instruction in a dynamic translator that uses instruction code translation and just-in-time compilation |
WO2016061820A1 (en) * | 2014-10-24 | 2016-04-28 | Google Inc. | Methods and systems for automated tagging based on software execution traces |
US10091076B2 (en) | 2015-08-25 | 2018-10-02 | Google Llc | Systems and methods for configuring a resource for network traffic analysis |
US10761973B2 (en) | 2016-03-28 | 2020-09-01 | Micro Focus Llc | Code coverage thresholds for code segments based on usage frequency and change frequency |
Citations (102)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4291371A (en) | 1979-01-02 | 1981-09-22 | Honeywell Information Systems Inc. | I/O Request interrupt mechanism |
US4316245A (en) | 1973-11-30 | 1982-02-16 | Compagnie Honeywell Bull | Apparatus and method for semaphore initialization in a multiprocessing computer system for process synchronization |
US5103394A (en) | 1984-04-30 | 1992-04-07 | Hewlett-Packard Company | Software performance analyzer |
US5113507A (en) | 1988-10-20 | 1992-05-12 | Universities Space Research Association | Method and apparatus for a sparse distributed memory system |
US5212794A (en) | 1990-06-01 | 1993-05-18 | Hewlett-Packard Company | Method for optimizing computer code to provide more efficient execution on computers having cache memories |
US5276833A (en) | 1990-07-02 | 1994-01-04 | Chips And Technologies, Inc. | Data cache management system with test mode using index registers and CAS disable and posted write disable |
US5287481A (en) | 1991-12-19 | 1994-02-15 | Opti, Inc. | Automatic cache flush with readable and writable cache tag memory |
US5394529A (en) | 1990-06-29 | 1995-02-28 | Digital Equipment Corporation | Branch prediction unit for high-performance processor |
US5537572A (en) | 1992-03-31 | 1996-07-16 | Vlsi Technology, Inc. | Cache controller and method for dumping contents of a cache directory and cache data random access memory (RAM) |
US5581778A (en) | 1992-08-05 | 1996-12-03 | David Sarnoff Researach Center | Advanced massively parallel computer using a field of the instruction to selectively enable the profiling counter to increase its value in response to the system clock |
US5652858A (en) | 1994-06-06 | 1997-07-29 | Hitachi, Ltd. | Method for prefetching pointer-type data structure and information processing apparatus therefor |
US5659679A (en) | 1995-05-30 | 1997-08-19 | Intel Corporation | Method and apparatus for providing breakpoints on taken jumps and for providing software profiling in a computer system |
US5691920A (en) | 1995-10-02 | 1997-11-25 | International Business Machines Corporation | Method and system for performance monitoring of dispatch unit efficiency in a processing system |
US5710881A (en) | 1993-11-09 | 1998-01-20 | Hewlett Packard Company | Data merging method and apparatus for shared memory multiprocessing computer systems |
US5752062A (en) | 1995-10-02 | 1998-05-12 | International Business Machines Corporation | Method and system for performance monitoring through monitoring an order of processor events during execution in a processing system |
US5768500A (en) | 1994-06-20 | 1998-06-16 | Lucent Technologies Inc. | Interrupt-based hardware support for profiling memory system performance |
US5774724A (en) | 1995-11-20 | 1998-06-30 | International Business Machines Coporation | System and method for acquiring high granularity performance data in a computer system |
US5794028A (en) | 1996-10-17 | 1998-08-11 | Advanced Micro Devices, Inc. | Shared branch prediction structure |
US5797019A (en) | 1995-10-02 | 1998-08-18 | International Business Machines Corporation | Method and system for performance monitoring time lengths of disabled interrupts in a processing system |
US5805879A (en) | 1996-02-23 | 1998-09-08 | Cyrix Corporation | In a pipelined processor, setting a segment access indicator during execution stage using exception handling |
US5822763A (en) | 1996-04-19 | 1998-10-13 | Ibm Corporation | Cache coherence protocol for reducing the effects of false sharing in non-bus-based shared-memory multiprocessors |
US5822790A (en) | 1997-02-07 | 1998-10-13 | Sun Microsystems, Inc. | Voting data prefetch engine |
US5887159A (en) | 1996-12-11 | 1999-03-23 | Digital Equipment Corporation | Dynamically determining instruction hint fields |
US5928334A (en) | 1997-03-28 | 1999-07-27 | International Business Machines Corporation | Hardware verification tool for multiprocessors |
US5930508A (en) | 1996-12-16 | 1999-07-27 | Hewlett-Packard Company | Method for storing and decoding instructions for a microprocessor having a plurality of function units |
US5937437A (en) | 1996-10-28 | 1999-08-10 | International Business Machines Corporation | Method and apparatus for monitoring address translation performance |
US5940618A (en) | 1997-09-22 | 1999-08-17 | International Business Machines Corporation | Code instrumentation system with non intrusive means and cache memory optimization for dynamic monitoring of code segments |
US5938778A (en) | 1997-11-10 | 1999-08-17 | International Business Machines Corporation | System and method for tracing instructions in an information handling system without changing the system source code |
US5938760A (en) | 1996-12-17 | 1999-08-17 | International Business Machines Corporation | System and method for performance monitoring of instructions in a re-order buffer |
US5950009A (en) | 1997-03-10 | 1999-09-07 | International Business Machines Coporation | Method and apparatus for profile-based reordering of program portions in a computer program |
US5950003A (en) | 1995-08-24 | 1999-09-07 | Fujitsu Limited | Profile instrumentation method and profile data collection method |
US5966537A (en) | 1997-05-28 | 1999-10-12 | Sun Microsystems, Inc. | Method and apparatus for dynamically optimizing an executable computer program using input data |
US5966538A (en) | 1997-10-31 | 1999-10-12 | Hewlett-Packard Company | Method and apparatus for automatically determining which compiler options should be used when compiling a computer program |
US5970439A (en) | 1997-03-13 | 1999-10-19 | International Business Machines Corporation | Performance monitoring in a data processing system |
US5987250A (en) | 1997-08-21 | 1999-11-16 | Hewlett-Packard Company | Transparent instrumentation for computer program behavior analysis |
US6006033A (en) | 1994-08-15 | 1999-12-21 | International Business Machines Corporation | Method and system for reordering the instructions of a computer program to optimize its execution |
US6026235A (en) | 1997-05-20 | 2000-02-15 | Inprise Corporation | System and methods for monitoring functions in natively compiled software programs |
US6070009A (en) | 1997-11-26 | 2000-05-30 | Digital Equipment Corporation | Method for estimating execution rates of program execution paths |
US6094709A (en) | 1997-07-01 | 2000-07-25 | International Business Machines Corporation | Cache coherence for lazy entry consistency in lockup-free caches |
US6101524A (en) | 1997-10-23 | 2000-08-08 | International Business Machines Corporation | Deterministic replay of multithreaded applications |
US6119075A (en) | 1997-11-26 | 2000-09-12 | Digital Equipment Corporation | Method for estimating statistics of properties of interactions processed by a processor pipeline |
US6134676A (en) | 1998-04-30 | 2000-10-17 | International Business Machines Corporation | Programmable hardware event monitoring method |
US6189142B1 (en) | 1998-09-16 | 2001-02-13 | International Business Machines Corporation | Visual program runtime performance analysis |
US6189072B1 (en) | 1996-12-17 | 2001-02-13 | International Business Machines Corporation | Performance monitoring of cache misses and instructions completed for instruction parallelism analysis |
US6189141B1 (en) | 1998-05-04 | 2001-02-13 | Hewlett-Packard Company | Control path evaluating trace designator with dynamically adjustable thresholds for activation of tracing for high (hot) activity and low (cold) activity of flow control |
US6192513B1 (en) | 1998-11-02 | 2001-02-20 | Hewlett-Packard Company | Mechanism for finding spare registers in binary code |
US6206584B1 (en) | 1991-06-21 | 2001-03-27 | Rational Software Corporation | Method and apparatus for modifying relocatable object code files and monitoring programs |
US6223338B1 (en) | 1998-09-30 | 2001-04-24 | International Business Machines Corporation | Method and system for software instruction level tracing in a data processing system |
US6233679B1 (en) | 1997-02-12 | 2001-05-15 | Telefonaktiebolaget Lm Ericsson (Publ) | Method and system for branch prediction |
US6237141B1 (en) | 1997-10-06 | 2001-05-22 | Sun Microsystems, Inc. | Method and apparatus for dynamically optimizing byte-coded programs |
US6243804B1 (en) | 1998-07-22 | 2001-06-05 | Scenix Semiconductor, Inc. | Single cycle transition pipeline processing using shadow registers |
US6256775B1 (en) | 1997-12-11 | 2001-07-03 | International Business Machines Corporation | Facilities for detailed software performance analysis in a multithreaded processor |
US6286132B1 (en) | 1998-01-07 | 2001-09-04 | Matsushita Electric Industrial Co., Ltd. | Debugging support apparatus, a parallel execution information generation device, a computer-readable recording medium storing a debugging support program, and a computer-readable recording medium storing a parallel execution information generation program |
US20010032305A1 (en) | 2000-02-24 | 2001-10-18 | Barry Edwin F. | Methods and apparatus for dual-use coprocessing/debug interface |
US6324689B1 (en) | 1998-09-30 | 2001-11-27 | Compaq Computer Corporation | Mechanism for re-writing an executable having mixed code and data |
US6330662B1 (en) | 1999-02-23 | 2001-12-11 | Sun Microsystems, Inc. | Apparatus including a fetch unit to include branch history information to increase performance of multi-cylce pipelined branch prediction structures |
US20020019976A1 (en) | 1998-12-08 | 2002-02-14 | Patel Mukesh K. | Java hardware accelerator using thread manager |
US6351844B1 (en) | 1998-11-05 | 2002-02-26 | Hewlett-Packard Company | Method for selecting active code traces for translation in a caching dynamic translator |
US6374364B1 (en) | 1998-01-20 | 2002-04-16 | Honeywell International, Inc. | Fault tolerant computing system using instruction counting |
US6381679B1 (en) | 1995-10-27 | 2002-04-30 | Hitachi, Ltd. | Information processing system with prefetch instructions having indicator bits specifying cache levels for prefetching |
US20020073406A1 (en) | 2000-12-12 | 2002-06-13 | Darryl Gove | Using performance counter profiling to drive compiler optimization |
US6430741B1 (en) | 1999-02-26 | 2002-08-06 | Hewlett-Packard Company | System and method for data coverage analysis of a computer program |
US6442585B1 (en) | 1997-11-26 | 2002-08-27 | Compaq Computer Corporation | Method for scheduling contexts based on statistics of memory system interactions in a computer system |
US6446029B1 (en) | 1999-06-30 | 2002-09-03 | International Business Machines Corporation | Method and system for providing temporal threshold support during performance monitoring of a pipelined processor |
US20020124237A1 (en) | 2000-12-29 | 2002-09-05 | Brinkley Sprunt | Qualification of event detection by thread ID and thread privilege level |
US20020129309A1 (en) | 2000-12-18 | 2002-09-12 | Floyd Michael S. | Method and system for triggering a debugging unit |
US20020147965A1 (en) | 2001-02-01 | 2002-10-10 | Swaine Andrew Brookfield | Tracing out-of-order data |
US20020157086A1 (en) | 1999-02-04 | 2002-10-24 | Lewis Brad R. | Methods and systems for developing data flow programs |
US6480938B2 (en) | 2000-12-15 | 2002-11-12 | Hewlett-Packard Company | Efficient I-cache structure to support instructions crossing line boundaries |
US20020199179A1 (en) | 2001-06-21 | 2002-12-26 | Lavery Daniel M. | Method and apparatus for compiler-generated triggering of auxiliary codes |
US6505292B1 (en) | 1997-11-17 | 2003-01-07 | Advanced Micro Devices, Inc. | Processor including efficient fetch mechanism for L0 and L1 caches |
US20030014741A1 (en) | 2001-07-12 | 2003-01-16 | International Business Machines Corporation | Restructuring of executable computer code and large data sets |
US20030040955A1 (en) | 1999-07-02 | 2003-02-27 | The Nasdaq Stock Market, Inc., A Delaware Corporation | Market monitoring architecture for detecting alert conditions |
US6539458B2 (en) | 2000-04-28 | 2003-03-25 | Telefonaktiebolaget Lm Ericsson (Publ) | Hierarchical memory for efficient data exchange control |
US6542985B1 (en) | 1999-09-23 | 2003-04-01 | Unisys Corporation | Event counter |
US20030066055A1 (en) | 2001-04-26 | 2003-04-03 | Spivey John Michael | Profiling computer programs |
US6549959B1 (en) | 1999-08-30 | 2003-04-15 | Ati International Srl | Detecting modification to computer memory by a DMA device |
US6549998B1 (en) | 2000-01-14 | 2003-04-15 | Agere Systems Inc. | Address generator for interleaving data |
US20030101367A1 (en) | 2001-10-25 | 2003-05-29 | International Business Machines Corporation | Critical adapter local error handling |
US20030131343A1 (en) | 2001-10-19 | 2003-07-10 | French Ronan J. | Framework for system monitoring |
US6594820B1 (en) | 1999-09-28 | 2003-07-15 | Sun Microsystems, Inc. | Method and apparatus for testing a process in a computer system |
US20030135719A1 (en) * | 2002-01-14 | 2003-07-17 | International Business Machines Corporation | Method and system using hardware assistance for tracing instruction disposition information |
US6631514B1 (en) | 1998-01-06 | 2003-10-07 | Hewlett-Packard Development, L.P. | Emulation system that uses dynamic binary translation and permits the safe speculation of trapping operations |
US6636950B1 (en) | 1998-12-17 | 2003-10-21 | Massachusetts Institute Of Technology | Computer architecture for shared memory access |
US6647301B1 (en) | 1999-04-22 | 2003-11-11 | Dow Global Technologies Inc. | Process control system with integrated safety control system |
US6662295B2 (en) | 1997-09-10 | 2003-12-09 | Ricoh Company, Ltd. | Method and system dynamically presenting the branch target address in conditional branch instruction |
US6681387B1 (en) | 1999-12-01 | 2004-01-20 | Board Of Trustees Of The University Of Illinois | Method and apparatus for instruction execution hot spot detection and monitoring in a data processing unit |
US6687794B2 (en) | 2001-10-18 | 2004-02-03 | International Business Machines Corporation | Prefetching mechanism for data caches |
US20040049712A1 (en) * | 2002-09-11 | 2004-03-11 | Betker Michael Richard | Processor system with cache-based software breakpoints |
US6721875B1 (en) * | 2000-02-22 | 2004-04-13 | Hewlett-Packard Development Company, L.P. | Method and apparatus for implementing a single-syllable IP-relative branch instruction and a long IP-relative branch instruction in a processor which fetches instructions in bundle form |
US6735666B1 (en) | 2000-02-22 | 2004-05-11 | Wind River Systems, Inc. | Method of providing direct user task access to operating system data structures |
US6772322B1 (en) | 2000-01-21 | 2004-08-03 | Intel Corporation | Method and apparatus to monitor the performance of a processor |
US20040153612A1 (en) | 2001-05-22 | 2004-08-05 | Stephane Mutz | Method and system for accelerated access to a memory |
US6782454B1 (en) | 2000-09-29 | 2004-08-24 | Sun Microsystems, Inc. | System and method for pre-fetching for pointer linked data structures |
US20040194076A1 (en) | 2003-03-25 | 2004-09-30 | Comp Lynn A. | Combining compilation and instruction set translation |
US20040205302A1 (en) | 2003-04-14 | 2004-10-14 | Bryan Cantrill | Method and system for postmortem identification of falsely shared memory objects |
US6848029B2 (en) | 2000-01-03 | 2005-01-25 | Dirk Coldewey | Method and apparatus for prefetching recursive data structures |
US6925424B2 (en) | 2003-10-16 | 2005-08-02 | International Business Machines Corporation | Method, apparatus and computer program product for efficient per thread performance information |
US6961925B2 (en) | 1998-12-23 | 2005-11-01 | Cray Inc. | Parallelism performance analysis based on execution trace information |
US6973417B1 (en) * | 1999-11-05 | 2005-12-06 | Metrowerks Corporation | Method and system for simulating execution of a target program in a simulated target system |
US6973542B1 (en) | 2000-07-18 | 2005-12-06 | International Business Machines Corporation | Detecting when to prefetch inodes and then prefetching inodes in parallel |
US7181723B2 (en) | 2003-05-27 | 2007-02-20 | Intel Corporation | Methods and apparatus for stride profiling a software application |
Family Cites Families (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7194732B2 (en) * | 2003-06-26 | 2007-03-20 | Hewlett-Packard Development Company, L.P. | System and method for facilitating profiling an application |
US20050091456A1 (en) * | 2003-10-23 | 2005-04-28 | Huck Jerome C. | Determining an arrangement of data in a memory for cache efficiency |
US7162594B2 (en) * | 2003-11-19 | 2007-01-09 | Buffalo Inc. | Memory module indicator device |
-
2004
- 2004-03-22 US US10/807,094 patent/US7299319B2/en active Active - Reinstated
Patent Citations (103)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4316245A (en) | 1973-11-30 | 1982-02-16 | Compagnie Honeywell Bull | Apparatus and method for semaphore initialization in a multiprocessing computer system for process synchronization |
US4291371A (en) | 1979-01-02 | 1981-09-22 | Honeywell Information Systems Inc. | I/O Request interrupt mechanism |
US5103394A (en) | 1984-04-30 | 1992-04-07 | Hewlett-Packard Company | Software performance analyzer |
US5113507A (en) | 1988-10-20 | 1992-05-12 | Universities Space Research Association | Method and apparatus for a sparse distributed memory system |
US5212794A (en) | 1990-06-01 | 1993-05-18 | Hewlett-Packard Company | Method for optimizing computer code to provide more efficient execution on computers having cache memories |
US5394529A (en) | 1990-06-29 | 1995-02-28 | Digital Equipment Corporation | Branch prediction unit for high-performance processor |
US5276833A (en) | 1990-07-02 | 1994-01-04 | Chips And Technologies, Inc. | Data cache management system with test mode using index registers and CAS disable and posted write disable |
US6206584B1 (en) | 1991-06-21 | 2001-03-27 | Rational Software Corporation | Method and apparatus for modifying relocatable object code files and monitoring programs |
US5287481A (en) | 1991-12-19 | 1994-02-15 | Opti, Inc. | Automatic cache flush with readable and writable cache tag memory |
US5537572A (en) | 1992-03-31 | 1996-07-16 | Vlsi Technology, Inc. | Cache controller and method for dumping contents of a cache directory and cache data random access memory (RAM) |
US5581778A (en) | 1992-08-05 | 1996-12-03 | David Sarnoff Researach Center | Advanced massively parallel computer using a field of the instruction to selectively enable the profiling counter to increase its value in response to the system clock |
US5710881A (en) | 1993-11-09 | 1998-01-20 | Hewlett Packard Company | Data merging method and apparatus for shared memory multiprocessing computer systems |
US5652858A (en) | 1994-06-06 | 1997-07-29 | Hitachi, Ltd. | Method for prefetching pointer-type data structure and information processing apparatus therefor |
US5768500A (en) | 1994-06-20 | 1998-06-16 | Lucent Technologies Inc. | Interrupt-based hardware support for profiling memory system performance |
US6006033A (en) | 1994-08-15 | 1999-12-21 | International Business Machines Corporation | Method and system for reordering the instructions of a computer program to optimize its execution |
US5659679A (en) | 1995-05-30 | 1997-08-19 | Intel Corporation | Method and apparatus for providing breakpoints on taken jumps and for providing software profiling in a computer system |
US5950003A (en) | 1995-08-24 | 1999-09-07 | Fujitsu Limited | Profile instrumentation method and profile data collection method |
US5691920A (en) | 1995-10-02 | 1997-11-25 | International Business Machines Corporation | Method and system for performance monitoring of dispatch unit efficiency in a processing system |
US5797019A (en) | 1995-10-02 | 1998-08-18 | International Business Machines Corporation | Method and system for performance monitoring time lengths of disabled interrupts in a processing system |
US5752062A (en) | 1995-10-02 | 1998-05-12 | International Business Machines Corporation | Method and system for performance monitoring through monitoring an order of processor events during execution in a processing system |
US6381679B1 (en) | 1995-10-27 | 2002-04-30 | Hitachi, Ltd. | Information processing system with prefetch instructions having indicator bits specifying cache levels for prefetching |
US5774724A (en) | 1995-11-20 | 1998-06-30 | International Business Machines Coporation | System and method for acquiring high granularity performance data in a computer system |
US5805879A (en) | 1996-02-23 | 1998-09-08 | Cyrix Corporation | In a pipelined processor, setting a segment access indicator during execution stage using exception handling |
US5822763A (en) | 1996-04-19 | 1998-10-13 | Ibm Corporation | Cache coherence protocol for reducing the effects of false sharing in non-bus-based shared-memory multiprocessors |
US5794028A (en) | 1996-10-17 | 1998-08-11 | Advanced Micro Devices, Inc. | Shared branch prediction structure |
US5937437A (en) | 1996-10-28 | 1999-08-10 | International Business Machines Corporation | Method and apparatus for monitoring address translation performance |
US5887159A (en) | 1996-12-11 | 1999-03-23 | Digital Equipment Corporation | Dynamically determining instruction hint fields |
US5930508A (en) | 1996-12-16 | 1999-07-27 | Hewlett-Packard Company | Method for storing and decoding instructions for a microprocessor having a plurality of function units |
US5938760A (en) | 1996-12-17 | 1999-08-17 | International Business Machines Corporation | System and method for performance monitoring of instructions in a re-order buffer |
US6189072B1 (en) | 1996-12-17 | 2001-02-13 | International Business Machines Corporation | Performance monitoring of cache misses and instructions completed for instruction parallelism analysis |
US5822790A (en) | 1997-02-07 | 1998-10-13 | Sun Microsystems, Inc. | Voting data prefetch engine |
US6233679B1 (en) | 1997-02-12 | 2001-05-15 | Telefonaktiebolaget Lm Ericsson (Publ) | Method and system for branch prediction |
US5950009A (en) | 1997-03-10 | 1999-09-07 | International Business Machines Coporation | Method and apparatus for profile-based reordering of program portions in a computer program |
US5970439A (en) | 1997-03-13 | 1999-10-19 | International Business Machines Corporation | Performance monitoring in a data processing system |
US5928334A (en) | 1997-03-28 | 1999-07-27 | International Business Machines Corporation | Hardware verification tool for multiprocessors |
US6285974B1 (en) | 1997-03-28 | 2001-09-04 | International Business Machines Corporation | Hardware verification tool for multiprocessors |
US6026235A (en) | 1997-05-20 | 2000-02-15 | Inprise Corporation | System and methods for monitoring functions in natively compiled software programs |
US5966537A (en) | 1997-05-28 | 1999-10-12 | Sun Microsystems, Inc. | Method and apparatus for dynamically optimizing an executable computer program using input data |
US6094709A (en) | 1997-07-01 | 2000-07-25 | International Business Machines Corporation | Cache coherence for lazy entry consistency in lockup-free caches |
US5987250A (en) | 1997-08-21 | 1999-11-16 | Hewlett-Packard Company | Transparent instrumentation for computer program behavior analysis |
US6662295B2 (en) | 1997-09-10 | 2003-12-09 | Ricoh Company, Ltd. | Method and system dynamically presenting the branch target address in conditional branch instruction |
US5940618A (en) | 1997-09-22 | 1999-08-17 | International Business Machines Corporation | Code instrumentation system with non intrusive means and cache memory optimization for dynamic monitoring of code segments |
US6237141B1 (en) | 1997-10-06 | 2001-05-22 | Sun Microsystems, Inc. | Method and apparatus for dynamically optimizing byte-coded programs |
US6101524A (en) | 1997-10-23 | 2000-08-08 | International Business Machines Corporation | Deterministic replay of multithreaded applications |
US5966538A (en) | 1997-10-31 | 1999-10-12 | Hewlett-Packard Company | Method and apparatus for automatically determining which compiler options should be used when compiling a computer program |
US5938778A (en) | 1997-11-10 | 1999-08-17 | International Business Machines Corporation | System and method for tracing instructions in an information handling system without changing the system source code |
US6505292B1 (en) | 1997-11-17 | 2003-01-07 | Advanced Micro Devices, Inc. | Processor including efficient fetch mechanism for L0 and L1 caches |
US6119075A (en) | 1997-11-26 | 2000-09-12 | Digital Equipment Corporation | Method for estimating statistics of properties of interactions processed by a processor pipeline |
US6442585B1 (en) | 1997-11-26 | 2002-08-27 | Compaq Computer Corporation | Method for scheduling contexts based on statistics of memory system interactions in a computer system |
US6070009A (en) | 1997-11-26 | 2000-05-30 | Digital Equipment Corporation | Method for estimating execution rates of program execution paths |
US6256775B1 (en) | 1997-12-11 | 2001-07-03 | International Business Machines Corporation | Facilities for detailed software performance analysis in a multithreaded processor |
US6631514B1 (en) | 1998-01-06 | 2003-10-07 | Hewlett-Packard Development, L.P. | Emulation system that uses dynamic binary translation and permits the safe speculation of trapping operations |
US6286132B1 (en) | 1998-01-07 | 2001-09-04 | Matsushita Electric Industrial Co., Ltd. | Debugging support apparatus, a parallel execution information generation device, a computer-readable recording medium storing a debugging support program, and a computer-readable recording medium storing a parallel execution information generation program |
US6374364B1 (en) | 1998-01-20 | 2002-04-16 | Honeywell International, Inc. | Fault tolerant computing system using instruction counting |
US6134676A (en) | 1998-04-30 | 2000-10-17 | International Business Machines Corporation | Programmable hardware event monitoring method |
US6189141B1 (en) | 1998-05-04 | 2001-02-13 | Hewlett-Packard Company | Control path evaluating trace designator with dynamically adjustable thresholds for activation of tracing for high (hot) activity and low (cold) activity of flow control |
US6243804B1 (en) | 1998-07-22 | 2001-06-05 | Scenix Semiconductor, Inc. | Single cycle transition pipeline processing using shadow registers |
US6189142B1 (en) | 1998-09-16 | 2001-02-13 | International Business Machines Corporation | Visual program runtime performance analysis |
US6223338B1 (en) | 1998-09-30 | 2001-04-24 | International Business Machines Corporation | Method and system for software instruction level tracing in a data processing system |
US6324689B1 (en) | 1998-09-30 | 2001-11-27 | Compaq Computer Corporation | Mechanism for re-writing an executable having mixed code and data |
US6192513B1 (en) | 1998-11-02 | 2001-02-20 | Hewlett-Packard Company | Mechanism for finding spare registers in binary code |
US6351844B1 (en) | 1998-11-05 | 2002-02-26 | Hewlett-Packard Company | Method for selecting active code traces for translation in a caching dynamic translator |
US20020019976A1 (en) | 1998-12-08 | 2002-02-14 | Patel Mukesh K. | Java hardware accelerator using thread manager |
US6636950B1 (en) | 1998-12-17 | 2003-10-21 | Massachusetts Institute Of Technology | Computer architecture for shared memory access |
US6961925B2 (en) | 1998-12-23 | 2005-11-01 | Cray Inc. | Parallelism performance analysis based on execution trace information |
US20020157086A1 (en) | 1999-02-04 | 2002-10-24 | Lewis Brad R. | Methods and systems for developing data flow programs |
US6330662B1 (en) | 1999-02-23 | 2001-12-11 | Sun Microsystems, Inc. | Apparatus including a fetch unit to include branch history information to increase performance of multi-cylce pipelined branch prediction structures |
US6430741B1 (en) | 1999-02-26 | 2002-08-06 | Hewlett-Packard Company | System and method for data coverage analysis of a computer program |
US6647301B1 (en) | 1999-04-22 | 2003-11-11 | Dow Global Technologies Inc. | Process control system with integrated safety control system |
US6446029B1 (en) | 1999-06-30 | 2002-09-03 | International Business Machines Corporation | Method and system for providing temporal threshold support during performance monitoring of a pipelined processor |
US20030040955A1 (en) | 1999-07-02 | 2003-02-27 | The Nasdaq Stock Market, Inc., A Delaware Corporation | Market monitoring architecture for detecting alert conditions |
US6549959B1 (en) | 1999-08-30 | 2003-04-15 | Ati International Srl | Detecting modification to computer memory by a DMA device |
US6542985B1 (en) | 1999-09-23 | 2003-04-01 | Unisys Corporation | Event counter |
US6594820B1 (en) | 1999-09-28 | 2003-07-15 | Sun Microsystems, Inc. | Method and apparatus for testing a process in a computer system |
US6973417B1 (en) * | 1999-11-05 | 2005-12-06 | Metrowerks Corporation | Method and system for simulating execution of a target program in a simulated target system |
US6681387B1 (en) | 1999-12-01 | 2004-01-20 | Board Of Trustees Of The University Of Illinois | Method and apparatus for instruction execution hot spot detection and monitoring in a data processing unit |
US6848029B2 (en) | 2000-01-03 | 2005-01-25 | Dirk Coldewey | Method and apparatus for prefetching recursive data structures |
US6549998B1 (en) | 2000-01-14 | 2003-04-15 | Agere Systems Inc. | Address generator for interleaving data |
US6772322B1 (en) | 2000-01-21 | 2004-08-03 | Intel Corporation | Method and apparatus to monitor the performance of a processor |
US6735666B1 (en) | 2000-02-22 | 2004-05-11 | Wind River Systems, Inc. | Method of providing direct user task access to operating system data structures |
US6721875B1 (en) * | 2000-02-22 | 2004-04-13 | Hewlett-Packard Development Company, L.P. | Method and apparatus for implementing a single-syllable IP-relative branch instruction and a long IP-relative branch instruction in a processor which fetches instructions in bundle form |
US20010032305A1 (en) | 2000-02-24 | 2001-10-18 | Barry Edwin F. | Methods and apparatus for dual-use coprocessing/debug interface |
US6539458B2 (en) | 2000-04-28 | 2003-03-25 | Telefonaktiebolaget Lm Ericsson (Publ) | Hierarchical memory for efficient data exchange control |
US6973542B1 (en) | 2000-07-18 | 2005-12-06 | International Business Machines Corporation | Detecting when to prefetch inodes and then prefetching inodes in parallel |
US6782454B1 (en) | 2000-09-29 | 2004-08-24 | Sun Microsystems, Inc. | System and method for pre-fetching for pointer linked data structures |
US20020073406A1 (en) | 2000-12-12 | 2002-06-13 | Darryl Gove | Using performance counter profiling to drive compiler optimization |
US6480938B2 (en) | 2000-12-15 | 2002-11-12 | Hewlett-Packard Company | Efficient I-cache structure to support instructions crossing line boundaries |
US20020129309A1 (en) | 2000-12-18 | 2002-09-12 | Floyd Michael S. | Method and system for triggering a debugging unit |
US20020124237A1 (en) | 2000-12-29 | 2002-09-05 | Brinkley Sprunt | Qualification of event detection by thread ID and thread privilege level |
US20020147965A1 (en) | 2001-02-01 | 2002-10-10 | Swaine Andrew Brookfield | Tracing out-of-order data |
US20030066055A1 (en) | 2001-04-26 | 2003-04-03 | Spivey John Michael | Profiling computer programs |
US20040153612A1 (en) | 2001-05-22 | 2004-08-05 | Stephane Mutz | Method and system for accelerated access to a memory |
US20020199179A1 (en) | 2001-06-21 | 2002-12-26 | Lavery Daniel M. | Method and apparatus for compiler-generated triggering of auxiliary codes |
US20030014741A1 (en) | 2001-07-12 | 2003-01-16 | International Business Machines Corporation | Restructuring of executable computer code and large data sets |
US6687794B2 (en) | 2001-10-18 | 2004-02-03 | International Business Machines Corporation | Prefetching mechanism for data caches |
US20030131343A1 (en) | 2001-10-19 | 2003-07-10 | French Ronan J. | Framework for system monitoring |
US20030101367A1 (en) | 2001-10-25 | 2003-05-29 | International Business Machines Corporation | Critical adapter local error handling |
US20030135719A1 (en) * | 2002-01-14 | 2003-07-17 | International Business Machines Corporation | Method and system using hardware assistance for tracing instruction disposition information |
US20040049712A1 (en) * | 2002-09-11 | 2004-03-11 | Betker Michael Richard | Processor system with cache-based software breakpoints |
US20040194076A1 (en) | 2003-03-25 | 2004-09-30 | Comp Lynn A. | Combining compilation and instruction set translation |
US20040205302A1 (en) | 2003-04-14 | 2004-10-14 | Bryan Cantrill | Method and system for postmortem identification of falsely shared memory objects |
US7181723B2 (en) | 2003-05-27 | 2007-02-20 | Intel Corporation | Methods and apparatus for stride profiling a software application |
US6925424B2 (en) | 2003-10-16 | 2005-08-02 | International Business Machines Corporation | Method, apparatus and computer program product for efficient per thread performance information |
Non-Patent Citations (48)
Title |
---|
"Cache Miss Director-A Means of Prefetching Cache Missed Lines", Aug. 1, 1982, IBM Technical Disclosure Bulletin, vol. 25, Issue 3A, pp. 1286. |
"Hardware Cycle Based memory Residency", IBM, May 22, 2003, ip.com, IPCOM000012728D, pp. 1-2. |
"Method for the dynamic prediction of nonsequential memory accesses", Sep. 25, 2002, pp. 1-4, ip.com IPCOM000009888D. |
Aho et al., "Compilers: Principles, Techniques, and Tools", Addison-Wesley, 1988, pp. 488-497. |
Chang et al., "Using Profile Information to Assist Classic Code Optimizations", Software Pract. Exper. Dec. 21, 1991, pp. 1301-1321. |
Cohen et al., "Hardware-Assisted Characterization of NAS Benchmarks", Cluster Computing, vol. 4, No. 3, Jul. 2001, pp. 189-196. |
Conte et al., "Accurate and Practical Profile-Driven Compilation Using the Profile Buffer", Proceedings of the 29th Annual ACM/IEEE International Symposium on Microarchitecture, Paris, France, 1996, pp. 36-45. |
Conte et al., "Using Branch Handling Hardware to Support Profile-Driven Optimization", Proceedings of the 27th Annual International Symposium on Microarchitecture, San Jose CA, 1994, pp. 12-21. |
Fisher, "Trace Scheduling: A Technique for Global Microcode Compaction", IEEE Transactions on Computers, vol. C30, No. 7, Jul. 1981, pp. 478-490. |
Hyde, "The Art of Assembly Language", 2001, Linux Edition, pp. 247-248, retrieved Mar. 1, 2005 from http://webster.cs.ucr.edu/AoA/Linux/PDFs/0<SUB>-</SUB>PDFindexLinux.html. |
IBM Research Disclosure Bulletin 444188, "Enable Debuggers as an Objective Performance Measurement Tool for Software Development Cost Reduction", Apr. 2001, pp. 686-688. |
INTEL. "Intel IA-64 Architecture Software Developer's Manual", Revision 1.1, vol. 4, No. 245320.002, Jul. 2001. |
Iwasawa et al., "Parallelization Method of Fortran DO Loops by Parallelizing Assist System", Transactions of Information Processings Society of Japan, vol. 36, No. 8, Aug. 1995, pp. 1995-2006. |
Jeong et al., "Cost Sensitive Cache Replacement Algorithms", Jun. 2002, Second Workshop on Cashing, Coherence and Consistency, NY, pp. 1-14. |
Kikuchi, "Parallelization Assist System", Joho Shori, vol. 34, No. 9, Sep. 1993, pp. 1158-1169. |
Ramirez et al., "The Effect of Code Reordering on Branch Prediction", Proceedings of the International Conference on Parallel Architectures and Compilation Techniques, Oct. 2000, pp. 189-198. |
Rothman et al., "Analysis of Shared Memory Misses and Reference Patterns", 2000, IEEE, pp. 187-198. |
Schmidt et al., "Profile-Directed Restructuring of Operating System Code", IBM Systems Journal, 1998, vol. 37, No. 2, pp. 270-297. |
Talla et al., "Evaluating Signal Processing and Multimedia Applications on SIMD, VLIW and Super Scalar Architectures", International Conference on Computer Design, Austin, Sep. 17-20, 2000, pp. 163-172. |
Talla et al., "Execution Characteristics of Multimedia Applications on a Pentium II Processor", IEEE International Performance, Computing, and Communications Conference, 19<SUP>th</SUP>, Phoenix, Feb. 20-22, 2000, pp. 516-524. |
Tanenbaum, "Structured Computer Organization", 1984, Prentice-Hall, Inc., 2<SUP>nd </SUP>Edition, pp. 10-12. |
Torrellas et al., "False Sharing and Spatial Locality in Multiprocessor Caches", Jun. 1994, IEEE Transactions on Computers, vol. 43, No. 6, pp. 651-663. |
U.S. Appl. No. 08/538,071, filed Oct. 2, 1995, Gover et al. Method and System for Selecting and Distinguishing an Event Sequence using an Effective Address in a Processing System. |
U.S. Appl. No. 09/435,069, filed Nov. 4, 1999, Davidson et al. Method and Apparatus for Instruction Sampling for Performance Monitoring and Debug. |
U.S. Appl. No. 10/674,604, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Selectively Counting Instructions and Data Accesses, |
U.S. Appl. No. 10/674,606, filed Sep. 30, 2003, Levine et al. Method and Apparatus to Autonomically Take an Execution on Specified Instructions. |
U.S. Appl. No. 10/674,642, filed Sep. 30, 2003, Levine et al. Method and Apparatus to Autonomically Count Instruction Execution for Applications. |
U.S. Appl. No. 10/675,721, filed Sep. 30, 2003, Levine et al. Method and Apparatus to Autonomically Select Instructions for Selective Counting. |
U.S. Appl. No. 10/675,751, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Debug Support for Individual Instructions and Memory Locations. |
U.S. Appl. No. 10/675,776, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Counting Execution of Specific Instructions and Accesses to Specific Data Locations. |
U.S. Appl. No. 10/675,777, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Counting Instruction Execution and Data Accesses. |
U.S. Appl. No. 10/675,778, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Counting Data Accesses and Instruction Executions that Exceed a Threshold. |
U.S. Appl. No. 10/675,783, filed Sep. 30, 2003, Levine et al. Method and Apparatus to Autonomically Profile Applications. |
U.S. Appl. No. 10/675,831, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Generating Interrupts Upon Execution of Marked Instructions and Upon Access to Marked Memory Locations. |
U.S. Appl. No. 10/675,872, filed Sep. 30, 2003, DeWitt, Jr. et al. Method and Apparatus for Counting Instruction and Memory Location Ranges. |
U.S. Appl. No. 10/757,192, filed Jan. 14, 2004, DeWitt, Jr. et al. Method and Apparatus for Providing Pre and Post Handlers for Recording Events. |
U.S. Appl. No. 10/757,192, filed Mar. 18, 2004, DeWitt, Jr. et al. Method and Apparatus for Determining Computer Program Flows Autonomically Using Hardware Assisted Thread Stack Tracking and Cataloged Symbolic Data. |
U.S. Appl. No. 10/757,197, filed Jan. 14, 2004, DeWitt, Jr. et al. Method and Apparatus for Optimizing Code Execution Using Annotated Trace Information having Performance Indicator and Counter Information. |
U.S. Appl. No. 10/757,227, filed Jan. 14, 2004, DeWitt, Jr. et al. Method and Apparatus for Autonomically Moving Cache Entries to Dedicated Storage when False Cache Line Sharing is Detected. |
U.S. Appl. No. 10/757,250, filed Jan. 14, 2004, Levine et al. Method and Apparatus for Maintaining Performance Monitoring Structures in a Page Table for use in Monitoring Performance of a Computer Program. |
U.S. Appl. No. 10/806,576, filed Mar. 22, 2004, Dimpsey et al. Method and Apparatus for Hardware Assistance for Data Access Coverage. |
U.S. Appl. No. 10/806,633, filed Mar. 22, 2004, Dimpsey et al. Method and Apparatus for Providing Hardware Assistance for Data Access Coverage on Dynamically Allocated Data. |
U.S. Appl. No. 10/806,866, filed Mar. 22, 2004, Dimpsey et al. Method and Apparatus for Prefetching Data from a Data Structure. |
U.S. Appl. No. 10/806,871, filed Mar. 22, 2004, Dimpsey et al. Method and Apparatus for Hardware Assistance for Prefetching Data. |
U.S. Appl. No. 10/806,917, filed Mar. 22. 2004, Dimpsey et al. Method and Apparatus for Automatic Test Case Feedback Using Hardware Assistance for Data Coverage. |
U.S. Appl. No. 10/808,716, filed Mar. 22, 2004, Dimpsey et al. Method and Apparatus for Autonomic Test Case Feedback Using Hardware Assistance for Code Coverage. |
Wikipedia "JavaServer Pages" downloaded Jan. 24, 2006 http://en.wikipedia.org/wiki/JavaServer<SUB>-</SUB>Pages. |
Yang et al., "Improving Performance by Branch Reordering", Proceedings of the ACM SIGPLAN 1998 Conference onProgramming Language Design and Implementation, Montreal Canada, 1008, pp. 130-141. |
Cited By (29)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8689190B2 (en) | 2003-09-30 | 2014-04-01 | International Business Machines Corporation | Counting instruction execution and data accesses |
US8381037B2 (en) * | 2003-10-09 | 2013-02-19 | International Business Machines Corporation | Method and system for autonomic execution path selection in an application |
US8782664B2 (en) | 2004-01-14 | 2014-07-15 | International Business Machines Corporation | Autonomic hardware assist for patching code |
US8615619B2 (en) | 2004-01-14 | 2013-12-24 | International Business Machines Corporation | Qualifying collection of performance monitoring events by types of interrupt when interrupt occurs |
US20080270995A1 (en) * | 2004-02-12 | 2008-10-30 | International Business Machines Corporation | Method for Automatic Detection of Build Regressions |
US8843898B2 (en) | 2004-02-12 | 2014-09-23 | International Business Machines Corporation | Removal of asynchronous events in complex application performance analysis |
US20050183075A1 (en) * | 2004-02-12 | 2005-08-18 | International Business Machines Corporation | Method and apparatus for removal of asynchronous events in complex application performance analysis |
US8196115B2 (en) | 2004-02-12 | 2012-06-05 | International Business Machines Corporation | Method for automatic detection of build regressions |
US8266595B2 (en) | 2004-02-12 | 2012-09-11 | International Business Machines Corporation | Removal of asynchronous events in complex application performance analysis |
US20080320448A1 (en) * | 2004-03-22 | 2008-12-25 | International Business Machines Corporation | Method and Apparatus for Autonomic Test Case Feedback Using Hardware Assistance for Data Coverage |
US7926041B2 (en) | 2004-03-22 | 2011-04-12 | International Business Machines Corporation | Autonomic test case feedback using hardware assistance for code coverage |
US7421684B2 (en) * | 2004-03-22 | 2008-09-02 | International Business Machines Corporation | Method and apparatus for autonomic test case feedback using hardware assistance for data coverage |
US20050210439A1 (en) * | 2004-03-22 | 2005-09-22 | International Business Machines Corporation | Method and apparatus for autonomic test case feedback using hardware assistance for data coverage |
US8171457B2 (en) * | 2004-03-22 | 2012-05-01 | International Business Machines Corporation | Autonomic test case feedback using hardware assistance for data coverage |
US7653899B1 (en) | 2004-07-23 | 2010-01-26 | Green Hills Software, Inc. | Post-execution software debugger with performance display |
US8789023B2 (en) | 2004-07-23 | 2014-07-22 | Green Hills Software, Inc. | Backward post-execution software debugger |
US8136096B1 (en) | 2004-07-23 | 2012-03-13 | Green Hills Software, Inc. | Backward post-execution software debugger |
US8271955B1 (en) | 2004-07-23 | 2012-09-18 | Green Hille Software, Inc. | Forward post-execution software debugger |
US8914777B2 (en) | 2004-07-23 | 2014-12-16 | Green Hills Software | Forward post-execution software debugger |
US8132159B1 (en) | 2004-07-23 | 2012-03-06 | Green Hills Software, Inc. | Post-execution software debugger with event display |
US8584097B2 (en) | 2004-07-23 | 2013-11-12 | Green Hills Software, Inc. | Post-execution software debugger with event display |
US8015552B1 (en) * | 2004-07-23 | 2011-09-06 | Green Hills Software, Inc. | Post-execution software debugger with coverage display |
US20090300587A1 (en) * | 2008-05-27 | 2009-12-03 | Microsoft Corporation | Determining domain data coverage in testing database applications |
US20090307656A1 (en) * | 2008-06-06 | 2009-12-10 | International Business Machines Corporation | Optimized Scalar Promotion with Load and Splat SIMD Instructions |
US8255884B2 (en) | 2008-06-06 | 2012-08-28 | International Business Machines Corporation | Optimized scalar promotion with load and splat SIMD instructions |
US8572586B2 (en) | 2008-06-06 | 2013-10-29 | International Business Machines Corporation | Optimized scalar promotion with load and splat SIMD instructions |
US20100153926A1 (en) * | 2008-12-15 | 2010-06-17 | International Business Machines Corporation | Operating system aided code coverage |
US8312433B2 (en) | 2008-12-15 | 2012-11-13 | International Business Machines Corporation | Operating system aided code coverage |
US9727318B2 (en) * | 2014-02-18 | 2017-08-08 | Facebook, Inc. | Techniques to identify and purge unused code |
Also Published As
Publication number | Publication date |
---|---|
US20050210452A1 (en) | 2005-09-22 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US7926041B2 (en) | Autonomic test case feedback using hardware assistance for code coverage | |
US8171457B2 (en) | Autonomic test case feedback using hardware assistance for data coverage | |
US7620777B2 (en) | Method and apparatus for prefetching data from a data structure | |
US7299319B2 (en) | Method and apparatus for providing hardware assistance for code coverage | |
US7574587B2 (en) | Method and apparatus for autonomically initiating measurement of secondary metrics based on hardware counter values for primary metrics | |
US7496908B2 (en) | Method and apparatus for optimizing code execution using annotated trace information having performance indicator and counter information | |
US7526757B2 (en) | Method and apparatus for maintaining performance monitoring structures in a page table for use in monitoring performance of a computer program | |
US7114036B2 (en) | Method and apparatus for autonomically moving cache entries to dedicated storage when false cache line sharing is detected | |
US7093081B2 (en) | Method and apparatus for identifying false cache line sharing | |
US7296130B2 (en) | Method and apparatus for providing hardware assistance for data access coverage on dynamically allocated data | |
US7373637B2 (en) | Method and apparatus for counting instruction and memory location ranges | |
US8689190B2 (en) | Counting instruction execution and data accesses | |
US7181599B2 (en) | Method and apparatus for autonomic detection of cache “chase tail” conditions and storage of instructions/data in “chase tail” data structure | |
US20050155022A1 (en) | Method and apparatus for counting instruction execution and data accesses to identify hot spots | |
US8135915B2 (en) | Method and apparatus for hardware assistance for prefetching a pointer to a data structure identified by a prefetch indicator | |
US20050155018A1 (en) | Method and apparatus for generating interrupts based on arithmetic combinations of performance counter values | |
US20050071611A1 (en) | Method and apparatus for counting data accesses and instruction executions that exceed a threshold | |
US20050071816A1 (en) | Method and apparatus to autonomically count instruction execution for applications | |
US20050071608A1 (en) | Method and apparatus for selectively counting instructions and data accesses | |
US20050210450A1 (en) | Method and appartus for hardware assistance for data access coverage | |
US20050071610A1 (en) | Method and apparatus for debug support for individual instructions and memory locations |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:DIMPSEY, ROBERT TOD;LEVINE, FRANK ELIOT;URQUHART, ROBERT JOHN;REEL/FRAME:014632/0852;SIGNING DATES FROM 20040319 TO 20040322 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026664/0866Effective date: 20110503 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |
|
FEPP | Fee payment procedure |
Free format text: MAINTENANCE FEE REMINDER MAILED (ORIGINAL EVENT CODE: REM.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
LAPS | Lapse for failure to pay maintenance fees |
Free format text: PATENT EXPIRED FOR FAILURE TO PAY MAINTENANCE FEES (ORIGINAL EVENT CODE: EXP.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20191120 |
|
PRDP | Patent reinstated due to the acceptance of a late maintenance fee |
Effective date: 20201001 |
|
FEPP | Fee payment procedure |
Free format text: PETITION RELATED TO MAINTENANCE FEES FILED (ORIGINAL EVENT CODE: PMFP); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYFree format text: PETITION RELATED TO MAINTENANCE FEES GRANTED (ORIGINAL EVENT CODE: PMFG); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYFree format text: SURCHARGE, PETITION TO ACCEPT PYMT AFTER EXP, UNINTENTIONAL (ORIGINAL EVENT CODE: M1558); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 12TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1553); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 12 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |