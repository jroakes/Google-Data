JP2021521490A - Private information retrieval by inferior linear public key operation - Google Patents
Private information retrieval by inferior linear public key operation Download PDFInfo
- Publication number
- JP2021521490A JP2021521490A JP2020562672A JP2020562672A JP2021521490A JP 2021521490 A JP2021521490 A JP 2021521490A JP 2020562672 A JP2020562672 A JP 2020562672A JP 2020562672 A JP2020562672 A JP 2020562672A JP 2021521490 A JP2021521490 A JP 2021521490A
- Authority
- JP
- Japan
- Prior art keywords
- data blocks
- total
- untrust
- storage device
- data
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
- G06F21/6245—Protecting personal data, e.g. for financial or medical purposes
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F17/00—Digital computing or data processing equipment or methods, specially adapted for specific functions
- G06F17/10—Complex mathematical operations
- G06F17/16—Matrix or vector computation, e.g. matrix-matrix or matrix-vector multiplication, matrix factorization
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/602—Providing cryptographic facilities or services
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/008—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols involving homomorphic encryption
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/30—Public key, i.e. encryption algorithm being computationally infeasible to invert or user's encryption keys not requiring secrecy
Abstract
方法（５００）は、非公開バッチ合計検索命令（２００）を実行して、アントラストストレージデバイス（１５０）からのデータブロック（１０２）のｃ個の合計Ｏを計算することによって、クライアントデバイス（１２０）上のクライアント状態（２５０）を初期化する工程を備える。方法は、また、データブロックのｃ個の合計Ｏの各々を通じて繰り返してクエリブロックＢｑを含まないｃ個の合計Ｏのうちの１つを識別し、サービスに対して、アントラストストレージデバイスを、パーティションに疑似ランダムに区分けするように、および、各パーティションを合計して対応する暗号化されたデータブロック合計（３０２）を決定するよう命令することによって、アントラストストレージデバイスに記憶されているクエリブロックＢｑを取り出すためのクエリ命令（３００）も備える。Method (500) executes a private batch total search instruction (200) to calculate the total O of c data blocks (102) from the untrusted storage device (150) to the client device (120). ) A step of initializing the above client state (250) is provided. The method also repeatedly identifies one of the c total O that does not include the query block Bq through each of the c total O of the data block and partitions the untrusted storage device for the service. Query block Bq stored in the untrusted storage device by instructing it to be pseudo-randomly divided and to sum each partition to determine the corresponding encrypted data block sum (302). It also includes a query instruction (300) for retrieving.
Description
本開示は、劣線形暗号化演算による非公開（プライベート）情報検索に関する。 The present disclosure relates to private information retrieval by a sublinear cryptographic operation.
企業および個人は、複数のメモリロケーションに亘るメモリにデータを記憶するために分配ストレージシステム（すなわち、クラウドストレージサービス）を使用する。記憶されたデータに対して検索クエリを行うなどのクラウドストレージサービスによって提供される基本的な機能を使用するために、企業は、クラウドストレージサービスへのプレーンテキストアクセスを要求される。結果として、多くの政府および衛生、財政、および法律などの繊細で非公開の分野では、増加する利便性およびコストの有意性に反して、クラウドストレージサービスの使用を躊躇する。例えば、ユーザによるデータアクセスのパターンは、データおよび／またはユーザについての相当量の情報を提供することができる。 Enterprises and individuals use distributed storage systems (ie, cloud storage services) to store data in memory across multiple memory locations. Enterprises are required to have plaintext access to cloud storage services in order to use the basic functionality provided by cloud storage services, such as making search queries on stored data. As a result, many government and sensitive and private areas such as hygiene, finance, and law hesitate to use cloud storage services, despite the increasing convenience and significance of cost. For example, a pattern of data access by a user can provide a significant amount of information about the data and / or the user.
非公開情報検索（ＰＩＲ）のスキームは、１以上のストレージデバイスをホストしているサーバに対してユーザまたは取り出したデータについてのいかなる知識も明らかにすることなく、ユーザが１以上のストレージデバイスからデータを取り出すことを可能にする。 The Private Information Retrieval (PIR) scheme allows a user to data from one or more storage devices without revealing any knowledge about the user or retrieved data to a server hosting one or more storage devices. Allows you to retrieve.
ＰＩＲについて、サーバストレージデバイスは、一般的には、保護されておらず、非公開情報は、ストレージデバイス全体からデータをダウンロードするためにすべて許可されたサブスクライバのグループと共に、公開ストレージデバイスまたはサーバストレージデバイスのいずれかから取り出される。ユーザは、単にサーバストレージデバイスからコンテンツのすべてをダウンロードしてもよく、これによって、アクセスのパターンが明らかにされない一方で、複数のストレージデバイスに広がっているクラウドストレージサービスからすべてのコンテンツをダウンロードしなければならず、これは、長くかかり過ぎる。さらに、複数のユーザに対してアクセスを可能にさせる従来のＰＩＲのスキームは、一般的に、ユーザ間において衝突または競合なく同時におよび独立してクエリ照会を行わせるために、状態無し（ステートレス）をユーザに対して要求する。ユーザが状態を保持しないので、これらの従来のＰＩＲのスキームは、ｎ個のブロックのデータベースに対してΩ（ｎ）の暗号化演算をサーバに要求するので、計算コストが高くなる。 For PIR, server storage devices are generally unprotected and private information is public or server storage devices, along with a group of subscribers who are all allowed to download data from the entire storage device. It is taken out from any of. Users may simply download all of their content from their server storage devices, which does not reveal access patterns, but must download all of their content from cloud storage services that are spread across multiple storage devices. Must be, this takes too long. In addition, traditional PIR schemes that allow access to multiple users are generally stateless in order to allow users to query queries simultaneously and independently without conflicts or conflicts. Request from the user. Since the user does not hold the state, these conventional PIR schemes require the server to perform an Ω (n) encryption operation on a database of n blocks, resulting in high computational costs.
複数クライアントを伴うシングル‐サーバの非公開情報検索（ＰＩＲ）システムにおいて、サーバは、ストレージ資源上のデータのプレーンテキストのブロックのセットを記憶する。サーバがデータブロックを生成し記憶する担当である一方で、ストレージ資源からの特定のデータブロックを取り出すクライアントは、どのブロックがクライアントによって取り出されたかをサーバが識別することができないという保証を望む。例えば、プレーンテキストデータブロックは、サーバが複数の異なる用途のために生成および分配する機械学習モデルを含んでもよい。クライアントがプレーンテキスト形式で機械学習モデルを取り出した場合、サーバおよびサーバに関連付けられている最終的なエンティティは、ＰＩＲによって提供された保証がない場合、クライアントについての重要な非公開情報を学習することができてしまう。 In a single-server private information retrieval (PIR) system with multiple clients, the server stores a set of plaintext blocks of data on storage resources. While the server is responsible for generating and storing data blocks, a client that retrieves a particular block of data from a storage resource wants assurance that the server cannot identify which block was retrieved by the client. For example, a plaintext data block may include a machine learning model that the server generates and distributes for multiple different uses. When a client retrieves a machine learning model in plain text format, the server and the final entity associated with the server learn important private information about the client without the guarantee provided by PIR. Will be created.
各々が共同でプレーンテキストデータをホストして複数のクライアントによるアクセスを提供することを担当する２つ以上のサーバを使用する既存のＰＩＲの手順では、サーバは、非結託サーバ、つまり、サーバはサーバ間で情報を共有しないという想定が存在する。しかしながら、プレーンテキストデータを共同でホストする、サーバに関連付けられている異なるエンティティは、互いに競合同士であることができるので、実世界のシナリオにおいては、マルチ‐サーバによるＰＩＲの手順は、実現不可能である。他方、シングル‐サーバを使用する既存のＰＩＲの手順で は、クライアントデバイスが同時にプレーンテキストのデータブロックに独立してアクセスできることを保証するために、クライアントデバイスが状態を保持しないことを必要とする。しかしながら、スマートフォンなどの近代的なクライアントデバイスは、アプリケーションに１００メガバイトのデータを記憶させることを可能にするので、クライアントについてのステートレス要件は、意味のないものであり、かつ、シングルサーバが行わなければならない暗号化処理の数に起因して計算量が多い。 In existing PIR procedures, where each uses two or more servers that are responsible for jointly hosting plaintext data and providing access to multiple clients, the server is a non-collusion server, that is, the server is a server. There is an assumption that information will not be shared between them. However, in real-world scenarios, the multi-server PIR procedure is not feasible because the different entities associated with the server that co-host plaintext data can compete with each other. Is. On the other hand, existing PIR procedures using a single-server require that the client device not hold state to ensure that the client device can access plaintext data blocks independently at the same time. However, modern client devices such as smartphones allow applications to store 100 megabytes of data, so stateless requirements for clients are meaningless and must be done by a single server. The amount of calculation is large due to the number of encryption processes that must be performed.
本実施形態は、各クライアントが他のクライアントの状態とは独立して状態を保つことを可能にする非同期クライアントストレージモデルを使用するシングル‐サーバＰＩＲのルーチンに向けられたものである。したがって、クライアントデバイスは、サーバによって管理されているストレージ資源に記憶されているプレーンテキストのデータブロックに対してクエリ照会を行った後に、他のクライアントデバイスの状態とは独立してそれ自体の状態を更新してもよい。同様に、クライアント状態が消失したとき、状態を再び取得するためにそのクライアンだけがサーバとの計算を行う必要がある。クライアントがローカルのストレージを使用して互いから独立して状態を保つことが可能になった結果、シングル‐サーバＰＩＲルーチンは、サーバに対して秘匿的な態様においてデータブロックが取り出されることを保証するために必要とされる暗号化処理の数を最小化することによって、計算効率を著しく向上させた。例えば、１００万の暗号化処理（べき乗）は、分単位のＣＰＵ時間を必要とし、他方で、１００万のプレーンテキスト処理（例えば、加算／ＸＯＲ）は、１秒未満の時間を必要とする。 This embodiment is directed to a single-server PIR routine that uses an asynchronous client storage model that allows each client to remain state independent of the state of other clients. Therefore, a client device queries its own state independently of the state of other client devices after querying a plaintext data block stored in a storage resource managed by the server. You may update it. Similarly, when a client state disappears, only that client needs to do calculations with the server to get the state again. As a result of allowing clients to remain independent of each other using local storage, single-server PIR routines ensure that data blocks are retrieved in a manner that is confidential to the server. By minimizing the number of encryption processes required for this, the calculation efficiency has been significantly improved. For example, one million encryption processes (powers) require CPU time in minutes, while one million plain text processes (eg, add / XOR) require less than one second.
忘却型ランダムアクセスメモリ（ＲＡＭ）の手順では、ローカルのクライアントストレージを使用して効率を向上させる一方で、忘却型ＲＡＭの手順では、しばしば、複数のクライアントからのクエリ照会を行う能力を容易に犠牲にしている。例えば、ローカルのクライアントストレージを使用する忘却型ＲＡＭの手順では、クエリ照会を行っているクライアントが状態を更新する必要があるだけでなく、他のすべてのクエリ照会を行っていないクライアントもまた状態を更新しなければならないように、クライアントが同期した状態を有することを必要とする。結果として、クライアント状態の同期を保つために、クライアント同士が互いに通信することを必要とするか、または、サーバが各クライアントの状態を追跡しなければならず、これにより、サーバに対するより大きなストレージを導く。さらに、ほとんどの忘却型ＲＡＭの手順では、クライアントがストレージ資源に対して並行してアクセスすることは可能ではなく、または、パラレル忘却型ＲＡＭの手順に対してクライアント‐クライアント通信が必要とされる。 The forget-me-not random access memory (RAM) procedure uses local client storage to improve efficiency, while the forget-me-not RAM procedure often easily sacrifices the ability to query queries from multiple clients. I have to. For example, an oblivion RAM procedure that uses local client storage not only requires the querying client to update its state, but also all other non-querying clients. It requires the client to have a synchronized state so that it must be updated. As a result, the clients either need to communicate with each other or the server must track the state of each client in order to keep the client state in sync, which gives more storage to the server. Guide. Moreover, most oblivion RAM procedures do not allow clients to access storage resources in parallel, or require client-client communication for parallel oblivion RAM procedures.
他方、二重効率ＰＩＲの手順では、すべてのクライアントが非公開鍵を共有し、互いに正直であるということを信頼するという犠牲を払って、より高速な計算時間を実現する。例えば、二重効率ＰＩＲの手順では、円滑なローカルの復号可能コード（例えば、リード‐マラー符号）の使用を通じて各ストレージ資源の要素に対しての処理を行うことを回避するが、各クライアントが単一の非公開鍵を共有してストレージ資源に対してクエリ照会を行うことを必要とする専用のクライアントモデルの使用を必要とする。複数のクライアントが単一の非公開鍵を共有するシナリオにおいて、単一のクライアントによる非公開鍵のサーバに対する漏洩は、サーバがすべてのクライアントのクエリ照会を行われたすべての指標を判別することを可能にする。さらに、二重効率ＰＩＲの手順では、ｑ個のクエリを確実に操作することを可能にするために多くの（Ｎ，ｑ）データベースのサイズを記憶しなければならない。ｑ個のクエリの後、データベースは、単一のクライアントによって非公開で再び初期化されなければならず、新たな鍵がすべてのクライアントに提供されなければならない。クライアントが状態を保持することを可能にすることによって、本開示のシングル‐サーバＰＩＲルーチンは、多くのクライアントに亘って再び初期化することを回避し、特定のクライアントがｑ個のクエリを実行した後、そのクライアントだけが効率的なクエリ照会を継続するためにサーバに対して状態を更新しなければならない一方で、他のクライアントは、状態を維持し、自由にクエリ照会を継続する。 The dual-efficiency PIR procedure, on the other hand, achieves faster computation times at the expense of all clients sharing private keys and trusting to be honest with each other. For example, a dual-efficiency PIR procedure avoids processing each element of a storage resource through the use of smooth local decryption code (eg, Reed-Muller code), but each client simply It requires the use of a dedicated client model that requires sharing one private key and querying storage resources. In a scenario where multiple clients share a single private key, a single client leaking the private key to the server determines that the server determines all the metrics that all clients have queried. to enable. In addition, the dual efficiency PIR procedure must remember the size of many (N, q) databases to be able to reliably manipulate q queries. After q queries, the database must be privately reinitialized by a single client and new keys must be provided to all clients. By allowing clients to retain state, the single-server PIR routines of the present disclosure avoid reinitialization across many clients, with a particular client executing q queries. Later, only that client has to update the state to the server in order to continue the efficient query query, while the other clients maintain the state and continue the query query freely.
本開示の１つの態様は、非公開情報検索（ＰＩＲ）を使用してアントラストストレージデバイス上のデータブロックを秘匿的に取り出すための方法を提供する。方法は、クライアントデバイスのデータ処理ハードウェアが、非公開バッチ合計検索命令を実行して、アントラストストレージデバイスからのデータブロックのｃ個の合計Ｏを計算することによって、クライアントデバイス上のクライアント状態を初期化する工程であって、計算された合計Ｏの各々は、クライアントデバイスのメモリハードウェアに記憶されており、かつ、対応するサブセットＳの丁度ｋ個のデータブロックの合計を含む、初期化する工程を備える。方法は、データ処理ハードウェアが、クエリ命令を実行してアントラストストレージデバイスに記憶されているクエリブロックＢｑを取り出す工程であって、メモリハードウェアに記憶されているデータブロックのｃ個の合計Ｏの各々を繰り返し処理してクエリブロックＢｑを含まないｃ個の合計Ｏのうちの１つを識別し、アントラストストレージデバイスを管理しているサービスに対して、アントラストストレージデバイスのｎ個のデータブロックを、各々がｋ+１個のデータブロックを含むｎ／（ｋ+１）個のパーティションに疑似ランダムに区分けするよう命令し、および、ｎ／（ｋ+１）個のパーティションの各々におけるｋ+１個のデータブロックを合計して、ｎ／（ｋ+１）個のパーティションの各々について、対応する暗号化されたデータブロック合計を決定し、ｎ／（ｋ+１）個のパーティションの１つは、クエリブロックＢｑを含まない識別されたデータブロックのｃ個の合計Ｏを含む固定のパーティションを備え、固定のパーティションを含むｎ／（ｋ+１）個のパーティションの暗号化されたデータブロック合計をアントラストストレージデバイスを管理しているサービスから取り出し、暗号化されたデータブロック合計を復号化して、クライアントデバイスのメモリハードウェアに記憶されている識別されたデータブロックのｃ個の合計Ｏから減算してクエリブロックＢｑを得る、ことによる、クエリブロックＢｑを取り出す工程と、をさらに備える。方法は、さらに、データ処理ハードウェア（１２４）が、クエリ（ｑ）の数がクエリしきい値を超えているかどうかを決定する工程と、データ処理ハードウェア（１２４）が、クエリ（ｑ）の数がクエリしきい値を超えている場合、クライアント状態を再び初期化する工程と、を備える。 One aspect of the disclosure provides a method for secretly retrieving data blocks on an untrusted storage device using Private Information Retrieval (PIR). The method is that the data processing hardware of the client device executes a private batch total search instruction to calculate the total O of c data blocks from the untrusted storage device to determine the client state on the client device. In the process of initialization, each of the calculated totals O is stored in the memory hardware of the client device and is initialized to include the total of exactly k data blocks of the corresponding subset S. Have a process. The method is a step in which the data processing hardware executes a query instruction to retrieve the query block B q stored in the untrust storage device, and is the total of c data blocks stored in the memory hardware. Each of the O is iteratively processed to identify one of the c total O that does not include the query block B q, and n of the untrust storage devices are managed for the service that manages the untrust storage devices. The data blocks of are ordered to be quasi-randomly divided into n / (k + 1) partitions, each containing k + 1 data blocks, and each of the n / (k + 1) partitions. Sum the k + 1 data blocks in to determine the corresponding encrypted data block total for each of the n / (k + 1) partitions and n / (k + 1) partitions. One has a fixed partition containing a total O of c of the identified data blocks not containing the query block B q, and is encrypted n / (k + 1) partitions containing the fixed partition. The total data block is retrieved from the service managing the untrusted storage device, the total encrypted data block is decrypted, and c of the identified data blocks stored in the memory hardware of the client device. obtaining a query block B q is subtracted from the total O, possibly, further comprising a step of taking out the query block B q, a. The method further includes a step in which the data processing hardware (124) determines whether the number of queries (q) exceeds the query threshold, and the data processing hardware (124) is the query (q). If the number exceeds the query threshold, it includes a step of reinitializing the client state.
本開示の実施形態は、以下の任意の特徴の１以上を備えてもよい。いくつかの実施形態において、非公開バッチ合計検索命令を実行して、データブロックのｃ個の合計Ｏを計算することは、クライアントデバイスにアントラストストレージデバイスに記憶されているすべてのデータブロックをクラス分けする工程であって、アントラストストレージデバイスは、ｎ個のデータブロックを記憶する、クラス分け工程と、アントラストストレージデバイスからクラス分けされた選択されたデータブロックをデータブロックのｃ個のサブセットＳのうちの対応するサブセットＳに割り当てる工程と、対応するサブセットＳに割り当てられた選択されたデータブロックを合計することによって、データブロックのｃ個の合計Ｏの各々を計算する工程と、を備える。他の実施形態において、非公開バッチ合計検索命令を実行して、データブロックのｃ個の合計Ｏを計算することは、アントラストストレージデバイスからｍ個のデータブロックをダウンロードして、メモリハードウェア上のストレージのためのデータブロックのｃ個の合計Ｏを計算する工程を備える。ここで、クライアントデバイスによってダウンロードされたｍ個のデータブロックの数は、ｋ個のデータブロックの数とデータブロックのｃ個の合計Ｏの数との積に等しい。 The embodiments of the present disclosure may include one or more of any of the following features: In some embodiments, executing a private batch total search instruction to calculate the total O of c data blocks classifies all data blocks stored on the untrusted storage device on the client device. In the step of dividing, the untrust storage device stores n data blocks, a classification step, and c subsets S of the selected data blocks classified from the untrust storage device. It includes a step of allocating to the corresponding subset S of the data blocks and a step of calculating each of the c total O of the data blocks by summing the selected data blocks assigned to the corresponding subset S. In another embodiment, executing a private batch total search instruction to calculate the total O of c data blocks downloads m data blocks from the untrust storage device and is on the memory hardware. It comprises a step of calculating the total O of c pieces of data blocks for storage of. Here, the number of m data blocks downloaded by the client device is equal to the product of the number of k data blocks and the total number of c data blocks O.
さらに他の実施形態では、非公開バッチ合計検索命令を実行して、データブロックのｃ個の合計Ｏを計算することは、クライアントデバイスからアントラストストレージデバイスを管理しているサービスに対して非公開情報検索要求を送信して、ｔ個のデータブロックをｋ個のバケットの各々から取り出す工程であって、非公開情報要求は、各々のｔ個のデータブロックをサービスに暗号化させ、および、アントラストストレージデバイス上に対応する非公開情報検索結果として記憶させる、工程と、加法準同型暗号のベクトルを生成する工程と、加法準同型暗号のベクトルをアントラストストレージデバイスにアップロードする工程であって、加法準同型暗号のベクトルは、アントラストストレージデバイスを管理しているサービスに、加法準同型暗号のベクトルを使用して非公開情報検索結果に対して加法準同型暗号計算を実行させ、加法準同型暗号計算は、データブロックの対応するｃ個の合計Ｏに対する暗号化テキスト値に対応する、工程と、アントラストストレージデバイスを管理しているサービスから暗号化テキストを受信し暗号化して、データブロックの対応するｃ個の合計Ｏを得る工程と、を備える。加法準同型暗号計算は、ドット積演算を含む。追加的に、または、代替え的に、ｔは１に等しくてもよい。 In yet another embodiment, executing a private batch total search instruction to calculate the total O of c data blocks is private to the service managing the untrust storage device from the client device. In the process of sending an information retrieval request and extracting t data blocks from each of the k buckets, the private information request causes the service to encrypt each t data blocks and unlocks them. The process of storing as the corresponding non-public information search result on the trust storage device, the process of generating the vector of the additive homomorphic encryption, and the process of uploading the vector of the additive homomorphic encryption to the untrust storage device. The additive homomorphic encryption vector causes the service managing the untrust storage device to perform an additive homomorphic encryption calculation on the private information search results using the additive homomorphic encryption vector. The encryption calculation receives and encrypts the encrypted text from the service that manages the process and the untrust storage device, which corresponds to the encrypted text value for the corresponding c total O of the data block, and encrypts the data block. It comprises a step of obtaining a total of c corresponding O's. The additive homomorphic encryption calculation includes a dot product operation. Additional or alternative, t may be equal to 1.
いくつかの例では、アントラストストレージデバイスを管理しているサービスに対して、アントラストストレージデバイスのｎ個のデータブロックを、ｎ／（ｋ+１）個のパーティションに疑似ランダムに区分けするよう命令することは、アントラストストレージデバイスのｎ個のデータブロックをｎ／（ｋ+１）個のパーティションへと疑似ランダムに区分けするための命令を含む、疑似ランダム置換区分け鍵（κ）のベクトルを生成する工程と、クライアントデバイスからアントラストストレージデバイスを管理しているサービスに対して、疑似ランダム置換区分け鍵（κ）のベクトルを含む要求を送信する工程であって、要求は、サービスにアントラストストレージデバイスのｎ個のデータブロックをｎ／（ｋ+１）個のパーティションへと疑似ランダムに区分けさせ、ｎ／（ｋ+１）個のパーティションの１つは、クエリブロックＢｑを含まないデータブロックの識別されたｃ個の合計Ｏを含む固定のパーティションを含む、工程と、を備える。疑似ランダムパーティションは、各行が対応するパーティションを備え、各列が各パーティションにおけるｋ+１個のブロックの対応する１つについて増加的に生成された疑似ランダム置換を備える、２次元行列を含む。 In some examples, the service managing the untrusted storage device is instructed to pseudo-randomly divide the n data blocks of the untrusted storage device into n / (k + 1) partitions. To generate a vector of pseudo-random permutation key (κ) containing instructions for pseudo-randomly dividing n data blocks of an untrusted storage device into n / (k + 1) partitions. And the process of sending a request containing a vector of pseudo-random permutation key (κ) from the client device to the service that manages the untrust storage device, and the request is the untrust storage to the service. The n data blocks of the device are pseudo-randomly divided into n / (k + 1) partitions, and one of the n / (k + 1) partitions is a data block that does not include the query block B q. The process comprises a fixed partition containing a total of c identified O's. Pseudo-random partitions include a two-dimensional matrix in which each row has a corresponding partition and each column has a pseudo-random substitution generated incrementally for the corresponding one of k + 1 blocks in each partition.
本開示のシステムの態様は、非公開情報検索（ＰＩＲ）を使用してアントラストストレージデバイス上のデータブロックを秘匿的に取り出すための方法を提供する。システムは、クライアントデバイスのデータ処理ハードウェアと、データ処理ハードウェアと通信している、クライアントデバイスのメモリハードウェアと、を備える。メモリハードウェアは、データ処理ハードウェアによって実行されたとき、データ処理ハードウェアに、非公開バッチ合計検索命令を実行して、アントラストストレージデバイスからのデータブロックのｃ個の合計Ｏを計算することによって、クライアントデバイス上のクライアント状態を初期化する工程であって、計算された合計Ｏの各々は、クライアントデバイスのメモリハードウェアに記憶されており、かつ、対応するサブセットＳの丁度ｋ個のデータブロックの合計を含む、初期化する工程を含む処理を行わせる命令を記憶する。処理は、また、クエリ命令を実行してアントラストストレージデバイスに記憶されているクエリブロックＢｑを取り出す工程であって、メモリハードウェアに記憶されているデータブロックのｃ個の合計Ｏの各々を繰り返し処理してクエリブロックＢｑを含まないｃ個の合計Ｏのうちの１つを識別し、アントラストストレージデバイスを管理しているサービスに対して、アントラストストレージデバイスのｎ個のデータブロックを、各々がｋ+１個のデータブロックを含むｎ／（ｋ+１）個のパーティションに疑似ランダムに区分けするよう命令し、および、ｎ／（ｋ+１）個のパーティションの各々におけるｋ+１個のデータブロックを合計して、ｎ／（ｋ+１）個のパーティションの各々について、対応する暗号化されたデータブロック合計を決定し、ｎ／（ｋ+１）個のパーティションの１つは、クエリブロックＢｑを含まない識別されたデータブロックのｃ個の合計Ｏを含む固定のパーティションを備え、固定のパーティションを含むｎ／（ｋ+１）個のパーティションの暗号化されたデータブロック合計をアントラストストレージデバイスを管理しているサービスから取り出し、暗号化されたデータブロック合計を復号化して、クライアントデバイスのメモリハードウェアに記憶されている識別されたデータブロックのｃ個の合計Ｏから減算してクエリブロックＢｑを得る、ことによる、クエリブロックＢｑを取り出す工程と、を含む。方法は、さらに、クエリ（ｑ）の数がクエリしきい値を超えているかどうかを決定する工程と、クエリ（ｑ）の数がクエリしきい値を超えている場合、クライアント状態を再び初期化する工程と、を含む。 Aspects of the system of the present disclosure provide a method for secretly retrieving data blocks on an untrusted storage device using Private Information Retrieval (PIR). The system comprises data processing hardware of the client device and memory hardware of the client device communicating with the data processing hardware. When the memory hardware is executed by the data processing hardware, it executes a private batch total search instruction on the data processing hardware to calculate the total O of c data blocks from the untrusted storage device. In the process of initializing the client state on the client device, each of the calculated totals O is stored in the memory hardware of the client device, and exactly k data of the corresponding subset S. Store instructions to perform processing including the step of initialization, including the sum of blocks. The processing is also a step of executing a query instruction to retrieve the query block B q stored in the untrust storage device, and each of the c total O of the data blocks stored in the memory hardware is selected. Iterately identifies one of the c total O that does not include the query block B q, and assigns n data blocks of the untrust storage device to the service that manages the untrust storage device. , Instructed to quasi-randomly divide into n / (k + 1) partitions, each containing k + 1 data blocks, and k + 1 in each of the n / (k + 1) partitions. The data blocks are summed to determine the corresponding encrypted data block total for each of the n / (k + 1) partitions, and one of the n / (k + 1) partitions is Encrypted data block total of n / (k + 1) partitions including fixed partition, with fixed partition containing c total O of identified data blocks not including query block B q Is taken from the service managing the untrusted storage device, the total encrypted data blocks are decrypted, and the total O of the identified data blocks stored in the memory hardware of the client device is subtracted. The process of extracting the query block B q by obtaining the query block B q is included. The method also involves determining if the number of queries (q) exceeds the query threshold and, if the number of queries (q) exceeds the query threshold, reinitializes the client state. Including the process of
本開示のこの態様は、以下の任意の特徴の１以上を含んでもよい。いくつかの実施形態では、非公開バッチ合計検索命令を実行して、データブロックのｃ個の合計Ｏを計算することは、クライアントデバイスにアントラストストレージデバイスに記憶されているすべてのデータブロックをクラス分けする工程であって、アントラストストレージデバイスは、ｎ個のデータブロックを記憶する、クラス分け工程と、アントラストストレージデバイスからクラス分けされた選択されたデータブロックをデータブロックのｃ個のサブセットＳのうちの対応するサブセットＳに割り当てる工程と、対応するサブセットＳに割り当てられた選択されたデータブロックを合計することによって、データブロックのｃ個の合計Ｏの各々を計算する工程と、を備える。他の実施形態では、非公開バッチ合計検索命令を実行して、データブロックのｃ個の合計Ｏを計算することは、アントラストストレージデバイスからｍ個のデータブロックをダウンロードして、メモリハードウェア上のストレージのためのデータブロックのｃ個の合計Ｏを計算する工程を備える、ここで、クライアントデバイスによってダウンロードされたｍ個のデータブロックの数は、ｋ個のデータブロックの数とデータブロックのｃ個の合計Ｏの数との積に等しい。 This aspect of the present disclosure may include one or more of any of the following features: In some embodiments, executing a private batch total search instruction to calculate the total O of c data blocks classifies all data blocks stored on the untrusted storage device on the client device. In the step of dividing, the untrust storage device stores n data blocks, a classification step, and c subsets S of the selected data blocks classified from the untrust storage device. It includes a step of allocating to the corresponding subset S of the data blocks and a step of calculating each of the c total O of the data blocks by summing the selected data blocks assigned to the corresponding subset S. In another embodiment, executing a private batch total search instruction to calculate the total O of c data blocks downloads m data blocks from the untrust storage device and is on the memory hardware. It comprises the step of calculating the total O of c data blocks for storage of, where the number of m data blocks downloaded by the client device is the number of k data blocks and the c of the data blocks. Equal to the product of the total number of O's.
さらに、他の実施形態では、非公開バッチ合計検索命令を実行して、データブロックのｃ個の合計Ｏを計算することは、クライアントデバイスからアントラストストレージデバイスを管理しているサービスに対して非公開情報検索要求を送信して、ｔ個のデータブロックをｋ個のバケットの各々から取り出す工程であって、非公開情報要求は、各々のｔ個のデータブロックをサービスに暗号化させ、および、アントラストストレージデバイス上に対応する非公開情報検索結果として記憶させる、工程と、加法準同型暗号のベクトルを生成する工程と、加法準同型暗号のベクトルをアントラストストレージデバイスにアップロードする工程であって、加法準同型暗号のベクトルは、アントラストストレージデバイスを管理しているサービスに、加法準同型暗号のベクトルを使用して非公開情報検索結果に対して加法準同型暗号計算を実行させ、加法準同型暗号計算は、データブロックの対応するｃ個の合計Ｏに対する暗号化テキスト値に対応する、工程と、アントラストストレージデバイスを管理しているサービスから暗号化テキストを受信し暗号化して、データブロックの対応するｃ個の合計Ｏを得る工程と、を備える。加法準同型暗号計算は、ドット積演算を含む。追加的にまたは代替え的に、ｔは１に等しくてもよい。 Further, in other embodiments, executing a private batch total search instruction to calculate c total O of data blocks is not for the service managing the untrust storage device from the client device. A process of sending a public information search request and retrieving t data blocks from each of the k buckets, where the private information request causes the service to encrypt each t data blocks, and The process of storing as the corresponding non-public information search result on the untrust storage device, the process of generating the vector of the additive homomorphic encryption, and the process of uploading the vector of the additive homomorphic encryption to the untrust storage device. , The additive homomorphic encryption vector causes the service managing the untrust storage device to perform the additive homomorphic encryption calculation on the private information search results using the additive homomorphic encryption vector. Homomorphic encryption receives and encrypts the encrypted text from the process and the service that manages the untrust storage device, which corresponds to the encrypted text value for the corresponding c total O of the data block, and blocks the data. It comprises a step of obtaining a total of c corresponding O's. The additive homomorphic encryption calculation includes a dot product operation. Additional or alternative, t may be equal to 1.
いくつかの例では、アントラストストレージデバイスを管理しているサービスに対して、アントラストストレージデバイスのｎ個のデータブロックを、ｎ／（ｋ+１）個のパーティションに疑似ランダムに区分けするよう命令することは、アントラストストレージデバイスのｎ個のデータブロックをｎ／（ｋ+１）個のパーティションへと疑似ランダムに区分けするための命令を含む、疑似ランダム置換区分け鍵（κ）のベクトルを生成する工程と、クライアントデバイスからアントラストストレージデバイスを管理しているサービスに対して、疑似ランダム置換区分け鍵（κ）のベクトルを含む要求を送信する工程であって、要求は、サービスにアントラストストレージデバイスのｎ個のデータブロックをｎ／（ｋ+１）個のパーティションへと疑似ランダムに区分けさせ、ｎ／（ｋ+１）個のパーティションの１つは、クエリブロックＢｑを含まないデータブロックの識別されたｃ個の合計Ｏを含む固定のパーティションを含む、工程と、を備える。疑似ランダムパーティションは、各行が対応するパーティションを備え、各列が各パーティションにおけるｋ+１個のブロックの対応する１つについて増加的に生成された疑似ランダム置換を備える、２次元行列を含む。 In some examples, the service managing the untrusted storage device is instructed to pseudo-randomly divide the n data blocks of the untrusted storage device into n / (k + 1) partitions. To generate a vector of pseudo-random permutation key (κ) containing instructions for pseudo-randomly dividing n data blocks of an untrusted storage device into n / (k + 1) partitions. And the process of sending a request containing a vector of pseudo-random permutation key (κ) from the client device to the service that manages the untrust storage device, and the request is the untrust storage to the service. The n data blocks of the device are pseudo-randomly divided into n / (k + 1) partitions, and one of the n / (k + 1) partitions is a data block that does not include the query block B q. The process comprises a fixed partition containing a total of c identified O's. Pseudo-random partitions include a two-dimensional matrix in which each row has a corresponding partition and each column has a pseudo-random substitution generated incrementally for the corresponding one of k + 1 blocks in each partition.
本開示の１以上の実施形態の詳細は、添付の図面および以下の説明に記載されている。他の態様、特徴、および利点は、説明および図面、ならびに特許請求の範囲から明らかになるであろう。 Details of one or more embodiments of the present disclosure are set forth in the accompanying drawings and the following description. Other aspects, features, and advantages will become apparent from the description and drawings, as well as the claims.
様々な図面における同様の参照記号は、同様の要素を示す。
本明細書の実施形態は、各々が非同期の状態を有する複数のクライアントデバイスが、サービスプロバイダによって管理される信頼されていない（アントラスト）メモリに記憶されているデータブロックを秘匿的に取り出すことを可能にするシングル‐サーバ非公開情報検索（ＰＩＲ）ルーチンに向けられている。アントラストメモリは、クライアントデバイスがアクセスできるクラウド環境で実行される分散ストレージシステムのストレージ資源を含んでもよい。アントラストメモリに記憶されているデータブロックは、公に知られており、かつ、暗号化されていない（例えば、プレーンテキスト）。したがって、独立したストレージ（例えば、非同期の状態）を有する複数のクライアントデバイスを備えたシングル‐サーバのＰＩＲルーチンは、アントラストメモリから、公に知られ、かつ、暗号化されていないデータアクセスのパターンを効果的に隠す。１つの例では、ストレージ資源（例えば、アントラストメモリ）を管理するサービスプロバイダは、クライアントデバイスに提供するための機械学習モデルを生成してもよい。ここで、サーバプロバイダは、生成された機械学習モデルをストレージ資源上のデータブロックとして記憶してもよく、クライアントデバイスは、クライアントに関する非公開情報を使用して特定の機械学習モデルに対してクエリ照会することができる。シングル‐サーバのＰＩＲルーチンは、機械学習モデルを提供するサービスプロバイダが、クライアントデバイスによって取り出された機械学習モデルを学習することを防ぐ。別の例では、出荷時設定へのリセットが行われているクライアントデバイスは、クライアントデバイスが企業グループまたは個人に関連付けられているかどうかを検査することがしばしばある。クライアントデバイスの製造元（またはクライアントデバイス上で実行されるオペレーティングシステムまたはその他のソフトウェアのプロバイダ）は、企業識別子と関連付けられているクライアント識別子のセットをプレーンテキストとして記憶することができる。クライアントデバイスが特定の企業グループに属している場合、出荷時設定へのリセットを完了するために追加の操作が必要になる場合がある一方で、クライアントデバイスが企業グループに属しない場合は、シングル‐サーバのＰＩＲルーチンは、クライアントデバイスに関連付けられたクライアント識別子が製造元に決して漏洩されないことを確実にする。
Similar reference symbols in various drawings indicate similar elements.
An embodiment of the present specification is that a plurality of client devices, each having an asynchronous state, secretly retrieve a block of data stored in untrusted (untrusted) memory managed by a service provider. Directed to enabling single-server private information retrieval (PIR) routines. An trust memory may include storage resources of a distributed storage system running in a cloud environment accessible to client devices. The data blocks stored in the untrust memory are publicly known and unencrypted (eg, plain text). Therefore, a single-server PIR routine with multiple client devices with independent storage (eg, asynchronous state) is a publicly known and unencrypted pattern of data access from untrusted memory. Effectively hide. In one example, a service provider managing storage resources (eg, untrusted memory) may generate a machine learning model to provide to client devices. Here, the server provider may store the generated machine learning model as a block of data on the storage resource, and the client device queries the specific machine learning model using private information about the client. can do. The single-server PIR routine prevents the service provider providing the machine learning model from learning the machine learning model retrieved by the client device. In another example, a client device that has been reset to factory settings often checks to see if the client device is associated with a corporate group or individual. The manufacturer of the client device (or the provider of the operating system or other software running on the client device) can store the set of client identifiers associated with the company identifier as plain text. If the client device belongs to a particular corporate group, additional actions may be required to complete the factory reset, while if the client device does not belong to a corporate group, single- The server's PIR routine ensures that the client identifier associated with the client device is never leaked to the manufacturer.
非同期の状態は、アントラストメモリに記憶されたデータに対してクエリ照会を実行した後、クライアントデバイスが互いに独立して状態を更新できるようにするために、他のクライアントデバイスから独立したストレージを有する各クライアントデバイスを参照する。同様に、クライアントデバイスが状態を解放することを決定した場合、他のすべてのクライアントデバイスのクエリは、アントラストメモリを管理するサーバから隠されたままである。シングル‐サーバのＰＩＲルーチンを構築し、後により効率的なオンラインクエリを提供するために、クライアントデバイスは、最初に非公開バッチ合計取得ルーチンを実行して状態を初期化し、その後、制約付き疑似ランダム区分け命令を実行し、これにより、クライアントデバイスがアントラストメモリに記憶されているデータブロックに対してクエリ照会を実行するときに、クライアントデバイスがアントラストメモリを管理するサービスへ固定のパーティションを通信することを可能にする。 Asynchronous state has storage independent of other client devices to allow client devices to update their state independently of each other after querying the data stored in untrust memory. Browse each client device. Similarly, if a client device decides to release the state, all other client device queries remain hidden from the server that manages the untrusted memory. To build a single-server PIR routine and later provide more efficient online queries, the client device first runs a private batch total capture routine to initialize the state, and then constrained pseudo-random. Executes a partition instruction, which causes the client device to communicate a fixed partition to the service that manages the untrust memory when the client device performs a query query against the data blocks stored in the untrust memory. Make it possible.
図１および図２は、分配システム１４０上の公に知られ、かつ、暗号化されていないｎ個のデータブロック（Ｂ）１０２を記憶するための例示的なシステム１００であって、非同期の状態２５０を保持している複数のクライアントデバイス１２０，１２０ａ−ｎが、クライアントデバイス１２０によるデータブロック（Ｂ）１０２上の検索機能を維持しつつ、アクセスのパターンを秘密にしてデータブロック（Ｂ）を秘匿的に取り出す非公開情報検索（ＰＩＲ）を使用することを可能にするシステム１００を示す。つまり、クライアントデバイス１２０は、データブロック１０２を所有しておらず、データブロック１０２のコンテンツは、構成されて公に利用可能である。クライアント１０に関連付けられているクライアントデバイス１２０（例えば、コンピュータ）は、ネットワーク１３０を通じてスケーラブル／エラスティックな非一時的な抽象化ストレージ１５０を有する分配システム１４０と通信する。クライアントデバイス１２０は、関連付けられているメモリハードウェア１２２および関連付けられているデータ処理ハードウェア１２４を含んでもよい。クライアントデバイス１２０の各々は、抽象化ストレージ１５０に記憶されているデータブロック（Ｂ）１０２に対して問い合わせるためのクエリ命令３００を実行するとき、１以上のデータブロック（Ｂ）１０２を記憶するために関連付けられているメモリハードウェア１２２を活用して状態２５０を保持する。抽象化ストレージ１５０（例えば、ファイルシステム、データストア等）は、ストレージ資源１１４の上に重ねられ、１以上のクライアントデバイス１２０によるストレージ資源１１４のスケーラブルな使用を可能にする。
1 and 2 are
いくつかの実施形態では、分配システム１４０は、抽象化ストレージ１５０へのアクセスを管理するコンピューティングデバイス１１２（例えば、サーバ）を実行する。例えば、サーバは、データブロックを生成し、プレーンテキスト形式で抽象化ストレージ上に記憶し、クライアントデバイス１２０は、抽象化ストレージ１５０からデータブロック１０２をプレーンテキスト形式で取り出す。本例示は、ネットワーク１３０を通じて分配システム１４０に関連付けられているアントラスト（信頼されていない）側と通信するクライアントデバイス１２０に関連付けられているトラスト（信頼されている）側を有するシステム１００を示すが、システム１００は、代替的に、トラストコンピューティングデバイス（ＣＰＵ）およびアントラストデータストレージを有する大規模イントラネットに実装されてもよい。分配システム１４０またはデータストレージに関連付けられているアントラスト側は、「ｈｏｎｅｓｔ−ｂｕｔ−ｃｕｒｉｏｕｓ」として考慮されており、これは、コンピューティングデバイス１１２は、正直にプロトコルに従うが、分配システム１４０によって漏洩した情報を使用して追加的な洞察を得るためにいずれかの多項式時間乱択アルゴリズムを行う。
In some embodiments, the
いくつかの実施形態では、分配システム１００は、資源１１０，１１０ａ−ｚを含む。資源１１０は、ハードウェア資源およびソフトウェア資源を含む。ハードウェア資源１１０は、コンピューティングデバイス１１２（データ処理デバイスおよびデータ処理ハードウェアとしても参照される）または非一時的メモリ１１４（メモリハードウェアおよびストレージ資源としても参照される）を含んでもよい。ソフトウェア資源１１は、ソフトウェアアプリケーション、ソフトウェアサービス、アプリケーションプログラミングインタフェース（ＡＰＩ）またはこれに類するものを含んでもよい。ソフトウェア資源１１０は、ハードウェア資源１１０内に常駐してもよい。例えば、ソフトウェア資源１１０は、メモリハードウェア１１４内に記憶されてもよく、またはハードウェア資源１１０（例えば、コンピューティングデバイス１１２）は、ソフトウェア資源１１０を実行してもよい。
In some embodiments, the
ソフトウェアアプリケーション（すなわち、ソフトウェア資源１１０）は、コンピューティングデバイスにタスクを実行させるコンピュータソフトウェアを参照する。いくつかの例では、ソフトウェアアプリケーションは、「アプリケーション」、「アプリ」、または「プログラム」として参照されてもよい。アプリケーションの例は、限定するものではないが、システム診断アプリケーション、システム管理アプリケーション、システムメンテナンスアプリケーション、ワード処理アプリケーション、スプレッドシートアプリケーション、メッセージングアプリケーション、メディアストリーミングアプリケーション、ソーシャルネットワーキングアプリケーション、およびゲーミングアプリケーションを含む。 A software application (ie, software resource 110) refers to computer software that causes a computing device to perform a task. In some examples, software applications may be referred to as "applications," "apps," or "programs." Examples of applications include, but are not limited to, system diagnostic applications, system management applications, system maintenance applications, word processing applications, spreadsheet applications, messaging applications, media streaming applications, social networking applications, and gaming applications.
メモリハードウェア１１４，１２２は、プログラム（例えば、命令のシーケンス）またはデータ（例えば、プログラムの状態情報）をコンピューティングデバイス１１２および／またはクライアントデバイス１２０（すなわち、クライアントデバイス１２０のデータ処理ハードウェア１２４）による使用のために一時的または永続的に記憶するために使用される物理的なデバイスであってもよい。メモリハードウェア１１４，１２２は、揮発的および／または不揮発的なアドレス可能な半導体メモリであってもよい。不揮発性メモリの例は、限定するものではないが、フラッシュメモリ、リードオンリーメモリ（ＲＯＭ）／プログラム可能リードオンリーメモリ（ＰＲＯＭ）／消去可能なプログラム可能リードオンリーメモリ（ＥＰＲＯＭ）／電気的に消去可能なプログラム可能リードオンリーメモリ（ＥＥＰＲＯＭ）（例えば、ブートプログラム等のファームウェアに対して通常に使用される）を含む。揮発性メモリの例は、限定するものではないが、ディスクまたはテープと同様に、ランダムアクセスメモリ（ＲＡＭ）、忘却型ランダムアクセスメモリ（ＯＲＡＭ）、ダイナミックアクセスメモリ（ＤＲＡＭ）、スタティックランダムアクセスメモリ（ＳＲＡＭ）、相変化メモリ（ＰＣＭ）を含む。
The
ネットワーク１３０は、ローカルエリアネットワーク（ＬＡＮ）、ワイドエリアネットワーク（ＷＡＮ）および／またはインターネット等の様々なタイプのネットワークを含んでもよい。ネットワーク１３０は、長い範囲のネットワーク（例えば、インターネットまたはＷＡＮ）を表してもよいが、いくつかの実施形態では、ネットワーク１３０は、ローカルエリアネットワーク（ＬＡＮ）等のより短い範囲のネットワークを含む。いくつかの実施形態では、ネットワーク１３０は、標準通信技術および／またはプロトコルを使用する。つまり、ネットワーク１３０は、イーサーネット（登録商標）、ワイヤレスフィディリティー（ＷｉＦｉ）（例えば、８０２．１１）、ワールドワイドインターオペラビリティフォーマイクロウェーブアクセス（ＷｉＭａｘ）、３Ｇ、ロングタームエボリューション（ＬＴＥ）、デジタルサブスクライバーライン（ＤＳＬ）、非同期転送モード（ＡＴＭ）、インフィニバンド、ＰＣＩエクスプレスアドバンストスイッチング、ブルートゥース（登録商標）、ブルートゥースローエナジー（ＢＬＥ）等の技術を使用したリンクを含むことができる。同様に、ネットワーク１３０に使用されるネットワーキングプロトコルは、マルチプロトコルラベルスイッチング（ＭＰＬＳ）、伝送制御プロトコル／インターネットプロトコル（ＴＣＰ／ＩＰ）、ユーザデータグラムプロトコル（ＵＤＰ）、ハイパーテキスト転送プロトコル（ＨＴＴＰ）、簡易メール転送プロトコル（ＳＭＴＰ）、ファイル転送プロトコル（ＦＴＰ）等を含むことができる。ネットワーク１３０を通じたデータ交換は、ハイパーマックアップ言語（ＨＴＭＬ）、拡張可能なマーク付け言語（ＸＭＬ）等を含む技術および／または形式を使用して表されることができる。加えて、リンクのすべてまたはいくつかは、セキュアソケットレイヤ（ＳＳＬ）、転送レイヤセキュリティ（ＴＬＳ）、仮想プライベートネットワーク（ＶＰＮ）、インターネットプロトコルセキュリティ（ＩＰｓｅｃ）等の従来の暗号化技術を使用して暗号化されることができる。他の例では、ネットワーク１３０は、上述した技術に替えて、または、加えて、カスタムおよび／または専用のデータ通信技術を使用する。
データブロック１０２は、データの原子単位系に対応し、各々が、それぞれＢバイトのサイズを有する。例えば、分配システム上のストレージに対するＢの代表値は、６４キロバイト（ＫＢ）から２５６バイト（Ｂ）であってもよい。ｎの表記は、ストレージ資源１１４に関連付けられ、および、ＰＩＲを使用して抽象化ストレージ１５０に記憶されているデータブロック１０２の数を表示する。ｎ個のデータブロック（Ｂ）１０２の各々は、メモリハードウェア１１４に亘って重ねられている抽象化ストレージ１５０の対応するメモリ位置１１８，１１８ａ−ｎ（図１Ｂ）に記憶されている。とりわけ、ｎ個のデータブロック（Ｂ）１０２は、ＰＩＲストレージに関連付けられており、ここで、ｎ個のデータブロック（Ｂ）１０２は、１以上のストレージ資源１１４に記憶され、および、暗号化されておらず、公に利用可能である。例えば、暗号化されていない、公のデータブロック（Ｂ）は、分配システム１４０によって生成された機械学習モデルに関連付けられ、および、クライアントデバイス１２０によってダウンロードのために入手可能であってもよい。
The data block 102 corresponds to the atomic unit system of data, each having a size of B bytes. For example, the representative value of B for storage on the distribution system may be 64 kilobytes (KB) to 256 bytes (B). The notation n indicates the number of data blocks 102 associated with the
分配システム１４０の抽象化ストレージ１５０（例えば、データベース）によって記憶された公に知られているプレーンテキストのデータブロック１２０に対してより効率的なクエリ照会を提供するために、各クライアントデバイス１２０は、非公開バッチ合計検索（ＢＳＲ）命令を実行することによって対応する状態２５０を初期化し、これによって、クライアントデバイス１２０は、クライアントデバイス１２０のメモリハードウェア１２２においてストレージのための抽象化ストレージ１５０からデータブロック１２０Ｏのｃ個の合計を計算する。ここで、計算されたｃ個の合計Ｏの各々は、対応するサブセットＳの丁度ｋ個のデータブロック１２０の合計を含む。いくつかの実施形態では、各クライアントデバイス１２０は、データブロック１０２のｃ個の合計Ｏ１，Ｏ２，．．．，ＯＣの各々を計算する前に、ランダム置換（π１，π１，．．，πｋ）を生成し、対応するサブセットＳ１，Ｓ２，．．．，ＳＣにおけるｋ番目の各ブロックに対して適用する 。クライアントデバイス１２０は、後の時間においてデータブロック１０２に対してより効率的なクエリ照会を提供するために、停止期間（例えば、夜間）に状態２５０を初期化し、非公開ＢＳＲ命令２００を実行してもよい。しきい値の数のクエリ照会を行った後に、各クライアントデバイス１２０は、他のクライアントデバイス１２０の状態２５０とは独立したその状態２５０を他のクライアントデバイス１２０によるクエリ照会を妨げることなく再び初期化する。
To provide a more efficient query query to the publicly known plain text data block 120 stored by the abstract storage 150 (eg, database) of the
クライアントデバイス１２０は、限定するものではないが、データベースのサイズ（例えば、データブロック１０２のｎの数）、計算要件、および／または、帯域要件を含む１以上の要素に基づいて、様々な非公開ＢＳＲ命令２００を選択してもよい。例えば、非公開ＢＳＲ命令２００は、抽象化ストレージ１５０からすべてのｎ個のデータブロック１０２をクラス分けして、データブロックのｃ個の合計Ｏの各々を計算するための対応するｃ個のサブセットＳに選択したデータブロック１０２を割り当てるクラス分け非公開ＢＳＲ２００ａ，２００（図２Ａ）を含んでもよい。他の例では、非公開ＢＳＲ命令２００は、データブロックＯのｃ個の合計を計算するためにｍ個のデータブロック１０２を抽象化ストレージ１５０からダウンロードするバッチ非公開ＢＳＲ命令２００ｂ，２００（図２Ｂ）を含んでもよい。さらに他の例では、非公開ＢＳＲ命令２００は、抽象化ストレージ１５０をｋ個のバケットに区分けし、ｃ個の合計を計算されるデータブロック１０２の各々のＯのために、ｋ個のバケットの各々からｔ個のデータブロックをダウンロードしてメモリハードウェア１２２上のストレージのために（すなわち、状態２５０内に）データブロック１２０の対応するＯの合計を計算するバッチコード非公開ＢＳＲ命令２００ｃ，２００（図２Ｃ〜図２Ｅ）を含んでもよい。一般的に、小さなサイズのデータベースに対しては、クラス分け非公開ＢＳＲ命令２００ａが最も効率的である一方で、より大きなサイズのデータベースに対しては、バッチコード非公開ＢＳＲ命令２００ｃが最も効率的である。バッチ非公開ＢＳＲ命令２００ｂは、中程度の大きさのデータベースに対して最も効率的なクエリ照会を提供する。
The
状態２５０を初期化した後、クライアントデバイス１２０は、抽象化ストレージ２００に記憶されているクエリブロックＢｑを秘匿的に取り出すためにクエリ命令３００を実行する。ここで、クライアントデバイス１２０は、対応する状態２５０を繰り返し検索して、クエリブロックＢｑを含まないｃ個の合計Ｏの１つを識別する。クエリブロックＢｑを含まないｃ個の合計Ｏを識別するに際し、クライアントデバイス１２０は、ｎ個のデータブロックの抽象化ストレージを疑似ランダムに区分けして各々がｋ+１個のデータブロックを含むｎ／（ｋ+１）個のパーティション３５０にするよう命令する要求３２０を抽象化ストレージ１５０を管理しているサーバ（例えば、サーバ）１６０に対して送信してもよく、ｎ／（ｋ+１）個のパーティションの各々におけるｋ+１個のデータブロックを合計して、ｎ／（ｋ+１）個のパーティションの各々に対する対応する暗号化されたデータブロック合計３０２を決定する。ｎ／（ｋ+１）個のパーティションのパーティション３５０は、二次元配列を含んでもよい。有利には、区分け要求３２０は、ｎ／（ｋ+１）個のパーティションの１つの識別されたｃ個の合計Ｏを含む固定のパーティションを組み込んでもよく、ここで、識別されたｃ個の合計Ｏは、二次元配列のランダムな行（例えば、ｒ番目の行）に組み込まれる。秘匿的に、サービス１６０は、クエリブロックＢｑ（例えば、+１ブロック）と共に、データブロック１０２（すなわち、ｋ個のデータブロック）の識別されたｃ個の合計Ｏに対する固定のパーティションを含む暗号化されたデータブロック合計３０２を返す。暗号化されたデータブロック合計３０２の受信に応答して、クライアントデバイス１２０は、（例えば、データ処理ハードウェア１２４を通じて）復号化し、暗号化されたデータブロック合計３０２をデータブロック１０２の識別されたｃ個の合計Ｏから減算し、クエリブロックＢｑを得る。つまり、命令３００を実行することによって、クライアントデバイス１２０は、クライアントデバイス１２０による分配システム１４０に対して実行されたクエリ照会のシーケンスと共に、データブロック１０２のコンテンツを明らかにすることなく、データブロックＢｑを取り出すことができる。サービス１６０は、データ処理ハードウェア１１２において実行されてもよい。
After initializing the
図１Ｂを参照して、いくつかの実施形態において、分配ストレージシステム１４０は、緩く結合されたメモリホスト１１０，１１０ａ−ｚ（例えば、コンピュータまたはサーバ）を含み、各々は、データをキャッシュするために使用されてもよいストレージ資源１１４（例えば、メモリハードウェア、メモリハードウェア、フラッシュメモリ、ダイナミックランダムアクセスメモリ（ＤＲＡＭ）、相変化メモリ（ＰＣＭ）および／またはディスク）と通信するコンピューティング資源１１２（例えば、１以上のプロセッサまたは中央処理装置（ＣＰＵ））を有する。抽象化ストレージ１５０は、ストレージ資源１１４の上に重ねられてストレージ資源１１４の１以上のクライアントデバイス１２０，１２０ａ−ｎによるスケーラブルな使用を可能にする。クライアントデバイス１２０は、ネットワーク１３０を通じて（例えば、遠隔手続き呼出し（ＲＰＣ）を通じて）メモリホスト１１０と通信してもよい。コンピューティング資源１１２は、サービス１６０を実行してもよい。
With reference to FIG. 1B, in some embodiments, the distributed
いくつかの実施形態では、分配ストレージシステム１４０は、「シングル−サイド」であり、これは、クライアントデバイス１２０がデータブロック１０２に対してクエリ（ｑ）を実行する命令３００を実行したとき、クライアントデバイス１２０からのクエリに応答するための抽象化ストレージ１５０からデータブロック１０２を取り出すいかなるサービスジョブの必要性も省く。「シングル−サイド」は、メモリホスト１１０において処理される要求のほとんどに対してメモリホスト１１０のＣＰＵ１１２においてソフトウェアによって行われるよりもハードウェアにおいて行われる方法を参照する。シングル−サイド分配キャッシュシステムに関するさらなる概念および特徴は、ここで参照によりその全体を本明細書に援用する米国特許第９，１６４，７０２号において確認することができる。
In some embodiments, the distributed
分配システム１４０は、データブロック１０２を遠隔メモリホスト１１０（例えば、抽象化ストレージ２００）のストレージ資源１１４（例えば、メモリハードウェア）の周辺で秘匿的に移動させ、ネットワークインターフェイスコントローラ（ＮＩＣ）１１６の機能を有するＲＰＣを通じて、または、リモートダイレクトメモリアクセス（ＲＤＭＡ）を通じて、遠隔メモリホスト１１０からデータブロック１０２を取得する。ネットワークインターフェイスコントローラ１１６（ネットワークインタフェースカード、ネットワークアダプタ、またはＬＡＮアダプタとしても知られている）は、コンピューティングデバイス／資源１１２をネットワーク１３０に接続させるコンピュータハードウェア要素であってもよい。メモリホスト１１０ａ−ｚおよびクライアントデバイス１２０の両方は、各々がネットワーク通信のためのネットワークインタフェースコントローラ１１６を有してもよい。ハードウェア資源１１０の物理的なプロセッサにおいて実行される命令３００は、メモリ１１４のリモートダイレクトメモリアクセス可能な領域／ロケーション１１８Ａ−Ｎの１つのセットをネットワークインタフェースコントローラ１１６と共に登録する。各メモリロケーション１１８は、対応するデータブロック１０２を記憶するように構成される。
The
図２Ａは、クライアントデバイス１２０上で実行され、各々の合計が丁度ｋ個のデータブロックを含むデータブロック１０２のＯのｃ個の合計を計算するためにＰＩＲ抽象化ストレージ１１４，１５０（例えば、抽象化ストレージ／データベース）のコンテンツ全体をクラス分けする、クラス分け非公開ＢＳＲ命令２００ａの例を提供する。ｎ個のデータブロック１０２のクラス分けを初期化するために、クライアントデバイス１０２は、ストリーム要求２０２をＰＩＲ抽象化ストレージ１５０を管理するサービス１６０に送信してもよい。ｎ個のデータブロック１０２のすべてがクラス分けされるので、命令２００ａは、サーバ１６０に対してどのデータブロック１０２がクライアントデバイス１２０によってアクセスされたかを隠す必要がない。クライアントデバイス１２０は、クラス分けにおいて選択されたデータブロック１０２をデータブロック１０２のｃ個のサブセットの中からサブセットＳ１，Ｓ２，．．．，Ｓｃの対応するサブセットに対して割り当ててもよい。次いで、クライアントデバイス１２０は、対応するサブセットＳ１，Ｓ２，．．．，Ｓｃに割り当てられた選択されたｋ個のデータブロックを合計することによって、ｃ個の合計Ｏ１，Ｏ２，．．．，Ｏｃ（例えば、出力）の各々を計算する。サブセットＳの各々について、クライアントデバイス１２０は、サブセットＳに含められているデータブロックＢ１，Ｂ２，．．．，Ｂｋの各々に対して、対応するランダム置換をさらに適用してもよい。クライアントデバイスのメモリハードウェア１２２に記憶されているデータブロックの総数ｍは、サブセットＳの総数ｃに各サブセットに割り当てられたデータブロックｋの数を乗じたものに等しい。クラス分け非公開ＢＳＲ命令２００ａは、クライアントデバイス１２０において帯域Ｏ（ｎ），加算Ｏ（ｍ），およびローカルメモリＯ（ｃ）を使用してもよい。
FIG. 2A is run on
図２Ｂは、クライアントデバイス１２０上で実行され、各々がｋ個のデータブロックを含む合計であるデータブロック１０２のＯのｃ個の合計を計算するために丁度ｍ個のデータブロックをＰＩＲ抽象化ストレージ１１４，１５０からダウンロードするダウンロード要求２０４をクライアントデバイス１２０に送信させるバッチ非公開ＢＳＲ命令２００ｂの例を提供する。したがって、クラス分け非公開ＢＳＲ命令２００ｂがＰＩＲ抽象化ストレージ１１４，１５０からすべてのｎ個のデータブロックをクラス分けする一方で、バッチ非公開ＢＳＲ命令２００ｂは、クライアント状態２５０のｃ個のサブセットＳを組み立てるのに必要なｍ個のデータブロック１０２だけをダウンロードする。クライアントデバイスによってダウンロードされたデータブロックの数であるｍは、データブロックの数ｋとデータブロックのＯを合計した数であるｃとの積に等しいので、命令２００ｂは、丁度ｋ個のデータブロックをデータブロック１０２のｃ個のサブセットの中からサブセットＳ１，Ｓ２，．．．，Ｓｃの対応するサブセットに対して割り当てる。次いで、クライアントデバイス１２０は、対応するサブセットＳ１，Ｓ２，．．．，Ｓｃ（例えば、入力）に割り当てられた選択されたｋ個のデータブロックを合計することによって、ｃ個の合計Ｏ１，Ｏ２，．．．，Ｏｃ（例えば、出力）の各々を計算する。サブセットＳの各々について、クライアントデバイス１２０は、サブセットＳに含められているデータブロックＢ１，Ｂ２，．．．，Ｂｋの各々に対して、対応するランダム置換をさらに適用してもよい。バッチ非公開ＢＳＲ命令２００ｂは、計算の帯域Ｏ（ｍｌｏｇｎ＋λ＋ｍＢ）およびＯ（ｎ）を使用してもよい。
FIG. 2B is a PIR abstraction storage of exactly m data blocks running on the
図２Ｃ〜図２Ｅは、クライアントデバイス１２０上で実行され、ｎ個のデータブロックのＰＩＲ抽象化ストレージ１１４，１５０をｋ個のバケット２６０へと区分け／分割／セグメント化し、クライアントデバイス１２０上のストレージのために計算されるデータブロック１０２のｃ個の合計Ｏの各々のためにｔ個のデータブロックをｋ個のバケット２６０の各々からダウンロードしてデータブロック１０２の対応する合計Ｏを計算するバッチコード非公開ＢＳＲ命令２００ｂの例を提供する。より小さなバケット２６０は、クライアントデバイス１２０がバッチコード非公開ＢＳＲ命令２００ｂの実行の間に状態２５０を初期化するとき、抽象化ストレージ１５０を小分けして帯域を増加させる。クライアントデバイス１２０によって区分けされた分配システム１４０におけるｋ個のバケット２６０の数は、保守および／または帯域要件に基づいて調整可能である。示す例では、抽象化ストレージ１５０のｎ個のデータブロック１０２は、４つのバケット２６０，２６０ａ―ｄに区分けされ、４つのバケット２６０，２６０ａ−ｄは、集合的にＮ（例えば、１６）個のデータブロック１０２Ａ−１０２Ｎを含む。さらに、ｋ個のバケット２６０の各々の中のデータブロック１０２は、符号化関数を使用して暗号化される。
2C-2E are executed on the
図２Ｃは、バッチコード２６２をサービス１６０に送信することによって命令２００ｂを初期化し、これによって、サービス１６０に抽象化ストレージ１５０をｋ個のバケット２５０ａ−ｄへと区分けさせ、かつ、符号化関数を使用してすべてのｋ個のバケットに現れるＮ個のブロック１０２を符号化させるクライアントデバイスを示す。バッチコード２６２は、最大ｍ個のアイテムを伴うサブセットＳのいずれに対しても、ｋ個のバケット２６０の各々における最大ｔ個のアイテムを読み出すことによって、対応するサブセットＳに割り当てられたブロックのセットが取り出されることを確実にする。ここで、実施形態は、ｔを１に等しく設定する。いくつかの例では、 バッチコード２６２は、カッコーバッチコードを含む。クライアントデバイス１２０は、データ処理ハードウェア１２４と通信している暗号化モジュール３０５を含み、バッチコード２６２を提供する。暗号化モジュール３０５は、データ処理ハードウェア１２４上で実行するソフトウェアを含むか、または、データ処理ハードウェア１２４と通信する分離したハードウェアを含んでもよい。例えば、図２Ｃは、第１および第２のサブセットＳ１，Ｓ２（例えば、ｃは２つのサブセットＳに等しい）のための丁度ｋ個のデータブロックを取り出すために初期化しているクライアントデバイス１２０の状態２５０をさらに示す。２つのサブセットのみが例として示されるが、他の例では、２つを超えるサブセットが含まれてもよい。
FIG. 2C initializes the instruction 200b by sending the
図２Ｄは、バッチコード非公開ＢＳＲ命令２００ｃを実行するに際し、第１のサブセットＳ１のためのｋ個のバケット２６０ａ−２６０ｄの各々からｔ個のデータブロック１０２をダウンロードするためにサービス２６０にＰＩＲ要求を送信するクライアントデバイス１２０を示す。示されていないが、クライアントデバイス１２０は、第２のサブセットＳ２に入力するためのｋ個のバケットの各々からｔ個のデータブロック１０２をダウンロードするために対応するＰＩＲ要求２６４も送信する。ＰＩＲ要求２６４の受信に応答して、サービスは、ｋ個のバケット２６０から取り出されたｔ個のデータブロック１０２の各々を暗号化して、第１のサブセットＳ１に関連付けられている対応する非公開情報検索結果ｒ１，ｒ２，ｒ３，ｒ４として記憶する。したがって、結果は、分配システム１４０のストレージ資源１１４上に記憶される。示される例では、ｔは、１に等しく、サービス１６０は、ブロック２をバケット１ ２６０ａからＰＩＲ結果ｒ１としてランダムにダウンロードし、暗号化し、および、記憶し；ブロック７をバケット２ ２６０ｂからＰＩＲ結果ｒ２としてランダムにダウンロードし、暗号化し、および、記憶し；ブロック１２をバケット３ ２６０ｃからＰＩＲ結果ｒ３としてランダムにダウンロードし、暗号化し、および、記憶し；ならびに、ブロック１５をバケット４ ２６０ｄからＰＩＲ結果ｒ４としてランダムにダウンロードし、暗号化し、および、記憶する。
FIG. 2D shows a PIR to service 260 to download t data blocks 102 from each of the
第１のサブセットＳ１のためのバケット２６０の各々からｔ個のデータブロック１０２をダウンロードするためにＰＩＲ要求３０４を送信した後、クライアントデバイスは、加法準同型暗号のベクトル２６６生成し、その加法準同型暗号のベクトル（ｅ１，ｅ２，ｅ３，ｅ４）２６６を分配システム１４０（例えば、抽象化ストレージ１５０）にアップロードする。いくつかの例では、計算される合計Ｏｉがバケット２６０のｉ番目から合計Ｏｉの一部としてブロック１０２を必要とする場合に限り、準同型暗号ｅｊは、１の暗号であり、そうでない場合、準同型暗号ｅｊは、ゼロ（０）の暗号である。加法準同型暗号のベクトル（ｅ１，ｅ２，ｅ３，ｅ４）２６６は、サービス１６０に、第１のサブセットＳ１に関連付けられている非公開情報検索結果ｒ１，ｒ２，ｒ３，ｒ４に対して加法準同型暗号のベクトル（ｅ１，ｅ２，ｅ３，ｅ４）２６６を使用して、加法準同型暗号計算２６８を実行させる。加法準同型暗号計算２６８は、データブロックの対応するｃ個の合計Ｏに対する暗号化テキスト値に対応する。加法準同型暗号は、サービス１６０に加法準同型暗号計算２６８を行わせ、これによって、ｋ個のバケット２６０からダウンロードされた符号化された結果が合計され、よって、暗号化演算を行うことに関連する計算コストを軽減させる。示される例において、加法準同型暗号計算２６８は、ドット積演算を含む。次いで、サービス１６０は、対応するデータブロックのｃ個の合計Ｏ（例えば、図２Ｄの例における合計Ｏ１）に対する暗号化テキスト値をクライアントデバイス１２０に返し、クライアントデバイス１２０は、暗号化テキスト値を復号化してデータブロックのｃ個の合計Ｏ（例えば、図２Ｄの例における合計Ｏ１）をローカルのメモリハードウェア１２２上のストレージのために計算して、状態２５０を初期化する。この処理は、計算されるデータブロックのｃ個の合計Ｏの各々に対して繰り返される。
After sending a PIR request 304 to download t data blocks 102 from each of the buckets 260 for the first subset S1, the client device generates a vector 266 of additive homomorphic encryption and its additive homomorphic encryption. Homomorphic encryption vectors (e 1 , e 2 , e 3 , e 4 ) 266 are uploaded to the distribution system 140 (eg, abstract storage 150). In some instances, only if the sum Oi is computed requires the
図３Ａ〜図３Ｃは、図２Ａ〜図２Ｅの非公開ＢＳＲ命令２００の実行を通じて状態１５０を初期化した後に抽象化ストレージ１５０からクエリブロックＢｑを取り出すクライアントデバイス１２０上で実行するクエリ命令３００の例を提供する。図３Ａは、クエリブロックＢｑを含まないｃ個の合計Ｏのうちの１つを識別するために、メモリハードウェア１２２に記憶されているデータブロック１−２のｃ個の合計Ｏの各々を繰り返し処理するクライアントデバイス１２０を示す。示される例では、３番目の合計Ｏ３がクエリブロックＢｑを含まないことを識別すると、クライアントデバイス１２０は、ｃ個の合計Ｏを繰り返し処理することを中止する。合計Ｏ１，Ｏ２およびＯｃのすべてはクエリブロックｑを含む。抽象化ストレージ１５０は、ｎ個のデータブロック１０２，１０２ａ−ｎのデータベースを含む。本開示における抽象化ストレージ１５０のデータベースは、部分合計の効率的な構造、アイテムの更新、および効率的な値の選択を可能にする１からｎのオーダーの整数のオンラインの部分合計データ構造を含んでもよい。
3A-3C show the
図３Ｂは、クエリブロックＢｑを含まないｃ個の合Ｏ（例えば、合計Ｏ３）を識別した後、鍵κのベクトルを生成（ＰＲＰａｒｔｉｔｉｏｎ．ＧｅｎｅｒａｔｅＫｅｙ（ｎ，ｋ＋１，Ｓ））するクライアントデバイス１２０を示す。図４Ａは、鍵κのベクトルを生成するための例示的なアルゴリズム４００ａを提供する（ＰＲＰａｒｔｉｔｉｏｎ．ＧｅｎｅｒａｔｅＫｅｙ（ｎ，ｋ＋１，Ｓ））。クエリ命令２００の実行の間にクライアントデバイス１２０によって生成された鍵κのベクトルは、アントラストストレージデバイスのｎ個のデータブロックを各々がｋ+１個のデータブロック１０２を含むｎ／ｋ+１個のパーティション３５０へとランダムに区分けするための命令を含む。より詳細には、ｎ／（ｋ+１）個のパーティション３５０は、パーティションの１つが、クエリブロックＢｑを含まないデータブロックの識別されたｃ個の合計Ｏ（例えば、合計Ｏ３）を含む固定のパーティションである、制約付き疑似ランダムパーティションの２次元行列を含む。したがって、鍵κのベクトルは、抽象化ストレージ１５０および抽象化ストレージ１５０を管理しているサービス１６０から記憶していない態様で、クエリブロックＢｑを含まないデータブロックの識別されたｃ個の合計Ｏ（例えば、合計Ｏ３）に対応するサブセットＳ（例えば、サブセットＳ３）を固定のパーティションとしてパーティション３５０のｒ（ランダム）番目の行に埋め込む。有意には、クライアントデバイス１２０は、抽象化ストレージ１５０を区分けするための鍵κのベクトルをいずれの計算も必要とすることなく分配システム１４０においてローカルに生成してもよい。
FIG. 3B shows the
クライアントデバイス１２０は、制約付き疑似ランダム区分けを実行するようにサービス１６０に命令して空間効率的な表現で所与のサイズのデータのランダムなサブセットのサンプリングを行う。つまり、鍵κのベクトルは、［ｎ］個の整数（例えば、ランダム鍵／シードκおよびセット｛Ｆ（κ，１），．．．，Ｆ（κ，ｋ）｝を使用して、データブロック１０２）の抽象化ストレージ１５０（例えば、データベース）内の置換の疑似ランダムファミリーを使用する。結果として、要求３２０は、サービス１６０に、［ｎ］個の整数をｋ+１のサイズのｎ／（ｋ+１）個のセットの整数に、各行が対応するパーティションを２次元行列として区分けさせる。２次元行列は、初期は、空であり疑似ランダム置換は、行を選択してランダムに選択された順序でサブセットＳ入力を埋め込む。［ｎ］個の整数の残りの要素は、空の行列にランダムに分配されるべきである。ｎ／（ｋ+１）個のパーティションのうちの１つは、丁度ｋ個のデータブロック１０２の入力サブセットＳに固定される。この固定された入力サブセットＳは、クライアントデバイス１２０のメモリハードウェア１２２上にローカルに記憶されたデータブロック１０２の計算されたｃ個の合計Ｏのうちの１つに対応する。とりわけ、ＣＰＰ命令３００の実行は、ピボット，．．．，ピボット+（ｎ／ｋ）−１において生成された置換のｎ／（ｋ+１）個のパーティションのうちの１つが所望の固定のサブセットＳの入力であるようにピボットを選択することによって、固定のサブセットＳの入力がＢＳＲ命令によって以前に計算されたｃ個の合計Ｏのうちの１つに対応することを確実にする。したがって、サブセットＳの固定の入力は、ｎ／（ｋ+１）個の指標における置換の計算に対応する。
The
いくつかの例では、固定の要素ｓに関連付けられているピボットを見つけるために、生成されたサブセットにおいてｓが出現することを確実にするように、ピボットは、π−１（ｓ）-ｒに設定されてもよく、このとき、ｒは、｛０，．．．，（ｎ／ｋ）-１｝からランダムに一様に選択される。固定の要素の周辺において生成されたサイズ（ｎ／ｋ）−１のランダムなサブセットがサブセットの入力からのいずれの他の要素も含まないときだけ、サンプリングは成功する。ランダムサブセットがサブセット要素の入力を含まない確率は、以下のように記載されることができる。 In some examples, the pivot is set to π-1 (s) -r to ensure that s appears in the generated subset to find the pivot associated with the fixed element s. It may be set, and at this time, r is {0 ,. .. .. , (N / k) -1} are randomly and uniformly selected. Sampling is successful only if a random subset of size (n / k) -1 generated around a fixed element does not contain any other element from the input of the subset. The probability that a random subset does not include the input of subset elements can be described as:
この手法に基づいて、置換鍵は、すべての列サブセットが行列の行のうちの１つに埋め込まれた固定されたサブセットＳの入力からの丁度１つの要素を含むように、行列の各列におけるサブセットを表してもよい。さらに、すべての列サブセットは、対として交わりを有しないものでなくてはならない。いくつかの例では、命令３００は、すべての取り得る残りのアイテムに亘る疑似ランダム置換のためのランダム鍵を生成する。疑似ランダム置換ｌｉ：＝Ｆ（Ｋ，ｉ）の計算は、ｌｉ番目に大きな残りの要素にマッピングを行う。置換πから指定されたｋのサイズのサブセットは、単純にｌ１番目，．．．，ｌｋ番目に大きな残りの要素を含むセットであり、これによって、すべての将来的なサンプルのサブセットが以前に固定されたいずれのサブセット列とも交わりを有しないことを確実にする。交わりを有しないサンプルのサブセットを確実にする能力により、各サブセット列は、定数のサンプルを使用して生成されることができる。
Based on this technique, the replacement key is in each column of the matrix so that all column subsets contain exactly one element from the input of the fixed subset S embedded in one of the rows of the matrix. It may represent a subset. In addition, all column subsets must have no mating pairs. In some examples,
すべての未使用な要素の明示的な記憶が線形のストレージを必要とする一方で、命令３００は、サブセット入力からの残りの未使用のアイテムの知識を必要とするだけである。とりわけ、残りのサブセット入力要素の各々について、順位として凹んだ値がより小さい未使用のアイテムの数に関する知識が必要とされる。指標ｉまでの特定の合計がサブセット入力のｉ番目に大きな要素の順位と等しいというように、サブセット入力のアイテムは、記憶された順序で記憶される。データ構造を初期化するとき、記憶されたサブセット入力の隣り合った要素の間の差分が記憶され、 部分合計クエリを行うことによって順位が取り出されることを確実にする。未使用の要素のセットから１つの要素を除去することは、入力サブセットのすべての要素の順位を下げることを必要とし、これは、除去された要素よりも１つ大きい。これは、除去される要素よりも大きな入力サブセットにおける最も小さなアイテムの指標から単純に１を減算することによって実現できる。結果として、より大きな入力サブセットのすべての要素の順位もまた１つ小さくなる。除去された要素よりも大きな入力サブセットから最も小さな要素を見つけることは、単一のＰａｒｔｉａｌＳｕｍｓ．Ｓｅｌｅｃｔ演算を必要とする一方で、順位を取り出し、エントリを更新することは、それぞれ、単一のＰａｒｔｉａｌＳｕｍｓ．Ｓｕｍ演算およびＰａｒｔｉａｌＳｕｍｓ．Ｕｐｄａｔｅ演算を必要とする。全体のデータ構造が入力サブセットのアイテムの各々について単一のエントリの記憶だけを必要とすることは、入力サブセットのサイズにおいて記憶要件が線形であることを意味する。
The
続いて図３Ｂを参照すると、クライアントデバイス１２０は、疑似ランダム置換区分け鍵κのベクトルを含む要求３２０をサービス１６０に送信する。サービス１６０によって受信されるとき、要求３２０は、サービス１６０に抽象化ストレージ１５０のｎ個のデータブロック１０２をｎ／（ｋ+１）個のパーティション３５０へと疑似ランダム区分け（ＰＲＰａｒｔｉｔｉｏｎ．ＧｅｔＰａｒｔｉｔｉｏｎ（κ））を行わせ、ｎ／（ｋ+１）個のパーティション３５０の１つは、クエリブロックＢｑを含まないデータブロック１０２の識別されたｃ個の合計Ｏ（例えば、合計Ｏ３）を含む固定のパーティションを含む。図４Ｂは、疑似ランダム置換区分け鍵κのベクトルを使用して抽象化ストレージ１５０をｎ／（ｋ+１）個のパーティション３５０に疑似ランダム区分けする例示的なアルゴリズム４００ｂを提供する。示される例では、ｎ／（ｋ+１）個のパーティション３５０の３番目のパーティションＰ３は、クエリブロックＢｑと、クエリブロックＢｑを含まないデータブロック１０２の識別されたｃ個の合計Ｏ（例えば、合計Ｏ３）とを含む固定のパーティションを含む。ここで、３番目のパーティションＰ３は、データブロック１０２の識別されたｃ個の合計Ｏのｋ個のブロックと、クエリブロックＢｑを含む１つの追加的なブロックとを含む。３番目のパーティションＰ３は、ｎ／（ｋ+１）個のパーティション３５０を表す２次元行列の３番目の行に対応する。サービス１６０によるＰＩＲ抽象化ストレージ１５０（例えば、データベース）の疑似ランダム区分けは、サービス１６０が、パーティション３５０の各々におけるｋ+１個のデータブロックを合計して、パーティションＰ１，Ｐ２，．．．，Ｐ（ｎ／（ｋ+１））の各々について、対応するデータブロックの暗号化された合計Ｔ１，Ｔ２，．．．，Ｔ（ｎ／（ｋ+１））３０２を決定することをさらに含む。
Subsequently, referring to FIG. 3B, the
図３Ｃは、データブロック１０２の識別されたｃ個の合計Ｏのｋ個のブロックと、１つのクエリブロックＢｑとを含む１つの追加的なブロックとを含む３番目のパーティションＰ３のためのデータブロックの暗号化された合計Ｔ３３０２を秘匿的に返す。データブロックの暗号化された合計Ｔ３３０２の受信に応答して、クライアントデバイス１２０は、データブロックの暗号化された合計Ｔ３３０２を復号化し、クエリブロックＢｑを含まないデータブロック１０２の識別されたｃ個の合計Ｏ（例えば、合計Ｏ３）を取り出し、ｋ個のデータブロック１０２の識別されたｃ個の合計Ｏ３からデータブロックの復号化された合計Ｔ３３０２を減算してクエリブロックＢｑを得る。
Figure 3C is a k blocks of c pieces of total O identified data blocks 102, for the third partition P 3 comprising one additional block comprising one query block B q Confidentially returns the encrypted
図４Ｃは、上述の説明の非公開ＢＳＲ命令２００，２００ａ，２００ｂ，２００ｃの１つを実行することによって、クライアント状態２５０を初期化する例示的なアルゴリズム４００ｃを提供する。図４Ｄは、クエリブロックＢｑを取り出すためのクエリ（ｑ）を実行するための例示的なアルゴリズム４００ｄを提供する。例示的なアルゴリズム４００ｄは、疑似ランダム区分け鍵κのベクトルをクライアントデバイス１２０においてローカルに生成するＰＲＰａｒｔｉｔｉｏｎ．ＧｅｎｅｒａｔｅＫｅｙ（ｎ，ｋ＋１，Ｓ）工程と、疑似ランダム区分け鍵κのベクトルを使用してＰＩＲストレージを疑似ランダム区分けするための後続のＰＲＰａｒｔｉｔｉｏｎ．ＧｅｔＰａｒｔｉｔｉｏｎ（κ）工程とを含む。
FIG. 4C provides an
他の実施形態では、制約付き疑似ランダム区分けは、疑似ランダム関数を使用する秘匿制約付き区分けに置き換えられる。ｍサイズのブロックの順序付き対象を抽象化ストレージ１５０のｎ個のデータブロック１０２から抽出することによって、サブルーチンが秘匿制約付きパーティションを生成してもよく、ｍ個の別個の値に遭遇するまで疑似ランダム関数（ＰＲＦ）を連続した入力に対して計算するためにいずれかのシード／鍵κが与えられる。シード／鍵κによって生成されるセットＴκが与えられ、ルーチンは、Ｔκのｒ番目の要素をいずれかの値に固定してもよく、再び配向されたサブセットのｒ番目の値は、ｉであり、残りのｍ−１個の要素は、ランダムである。よって、ランダムκをサンプリングし、Ｔκを生成し、および、ｒ番目の要素をｎ／（ｋ+１）個のパーティション３５０を表す２次元行列に固定することによって、ランダム制約付きサブセットが生成されることができる。ここで、ランダムに生成された制約付きサブセットと固定の要素を超えた制約付きサブセットとが関わったかどうかを決定する検査のみが必要とされるので、サンプリングは、制約付きサブセットからの残りの未使用アイテムの知識のみを必要とする。言い換えれば、サンプリングは、残りの制約付きサブセット要素の各々よりも値の小さな未使用数の数の知識だけを必要とする。この知識は、各制約付きサブセット要素のクランクに対応する。よって、制約付きサブセットおよびすべての未使用アイテムにおける対応する順位だけが明示的なストレージを必要とする。したがって、サブセット列が固定となると、すべてのサブセット入力要素の順位は、もう使用されていないすべての固定のアイテムを反映させるために更新されなければならない。つまり、制約付きサブセットのすべての要素の順位は、列におけるより小さなすべてのアイテムだけ下がらなくてはならない。結果として、秘匿制約付き区分けを生成するためのサブルーチンは、順位を維持するためにＯ（ｋ）ストレージのみを必要とする。
In other embodiments, the constrained pseudo-random segment is replaced by a concealed constrained partition that uses a pseudo-random function. By extracting the ordered objects of m-sized blocks from n data blocks 102 of
秘匿制約付き区分けを生成するためのルーチンは、鍵を生成するための鍵生成工程（ＯＣＰ．ＧｅｎｅｒａｔｅＫｅｙ）および固定されたパーティションを抽出するためのパーティション抽出工程（ＯＣＰ．ＥｘｔｒａｃｔＰａｒｔｉｔｉｏｎ）を含んでもよい。図４Ｅは、鍵を生成するためのＯＣＰ．ＧｅｎｅｒａｔｅＫｅｙ工程の例示的なアルゴリズム４００ｅを提供し、図４Ｆは、固定されたパーティションを抽出するための例示的なアルゴリズム４００ｆを提供する。いくつかの実施形態では、クエリ命令３００を実行してデータブロックＢｑを取り出すための例示的なアルゴリズム４００ｄは、本開示の範囲から逸脱することなく、疑似ランダム区分けに替えて疑似ランダム関数を使用する秘匿制約付き区分けに置き換えてもよい。ここで、アルゴリズム４００ｄは、鍵を生成するために、ＰＲＰａｒｔｉｔｉｏｎ．ＧｅｎｅｒａｔｅＫｅｙ（ｎ，ｋ＋１，Ｓ）工程（図４Ａ）をＯＣＰ．ＧｅｎｅｒａｔｅＫｅｙ工程（図４Ｆ）に置き換えてもよく、ＰＩＲストレージを秘匿的に区分けし、ＰＲＦ鍵に基づいて固定されたパーティションを抽出するために、続くＰＲＰａｒｔｉｔｉｏｎ．ＧｅｔＰａｒｔｉｔｉｏｎ（κ）工程（図４Ｂ）をパーティション抽出工程ＯＣＰ．ＥｘｔｒａｃｔＰａｒｔｉｔｉｏｎ（図４Ｆ）に置き換えてもよい。
The routine for generating the concealment-constrained partition may include a key generation step (OCP. GenerateKey) for generating a key and a partition extraction step (OCP. ExtractPartition) for extracting a fixed partition. FIG. 4E shows an OCP for generating a key. An
図５は、非公開情報検索（ＰＩＲ）を使用して、アントラストストレージデバイス１１４，１５０上にプレーンテキストとして記憶された公に知られたデータブロック１０２を取り出す方法５００のための演算の例示的な構成のフローチャートである。アントラストストレージデバイスは、分配システム１４０上の抽象化ストレージ１５０を実装する１以上のストレージデバイス１１４，１５０を含んでもよい。アントラストストレージデバイス１１４，１５０は、複数のクライアントデバイスがアクセスのために利用可能な公に知られ、かつ、暗号化されていないデータブロックを記憶するいずれかのデータストアまたはデータベースであってもよい。ＰＩＲの態様は、アントラストストレージデバイス１５０またはストレージデバイス１５０を管理しているサービス１６０がアクセスのパターンまたはストレージデバイス１５０から取り出されたデータを学習しないことを確実にする。各クライアントデバイス１２０のデータ処理ハードウェア１２４は、メモリハードウェア１２２上に記憶されている命令を実行することによって、方法５００の演算を実行してもよい。演算５０２において、方法５０２は、非公開バッチ合計検索命令２００を実行して、アントラストストレージデバイス５０からのデータブロック１０２のｃ個の合計Ｏを計算することによって、クライアントデバイス１２０のクライアント状態２５０初期化する工程を含み、計算された合計Ｏの各々は、クライアントデバイス１２０のメモリハードウェア１２２上に記憶され、かつ、対応するサブセットＳの丁度ｋ個のデータブロック１０２の合計を含む。
FIG. 5 is an illustration of an operation for
演算５０４において、方法５００は、クエリ命令３００を実行して、クエリブロックＢｑを含まないｃ個の合計Ｏのうちの１つを識別するためにメモリハードウェア１２４上に記憶されているデータブロック１０２のｃ個の合計Ｏの各々を通じて繰り返すことによって、アントラストストレージデバイス１５０上に記憶されたクエリブロックＢｑを取り出す工程を含む。演算５０６において、クエリ命令３００の実行は、アントラストストレージデバイス１５０を管理しているサービス１６０に対して、アントラストストレージデバイス１５０のｎ個のデータブロックを各々がｋ+１個のデータブロック１０２を含むｎ／（ｋ+１）個のパーティション３５０に疑似ランダムに区分けするよう命令する工程と、ｎ／（ｋ+１）個のパーティション３５０の各々におけるｋ+１個のデータブロック１０２を合計して対応するデータブロックの暗号化された合計３０２を決定する工程と、をさらに含み、ｎ／（ｋ+１）個のパーティション３５０のうちの１つは、クエリブロックＢｑを含まないデータブロックの識別されたｃ個の合計Ｏを含む固定されたパーティションを含む。演算５０６は、図４Ａおよび図４Ｂのアルゴリズム４００ａ，４００ｂによって制約付き疑似ランダム区分けまたは図４Ｅおよび図４Ｆのアルゴリズム４００ｅ，４００ｆによって秘匿制約付き区分けに基づいてパーティション３５０を生成してもよい。
In
演算５０８において、クエリ命令３００の実行は、固定のパーティションを含むｎ／（ｋ+１）個のパーティションのためのデータブロックの暗号化された合計３０２をアントラストストレージデバイス１５０を管理するサービスから検索する工程をさらに含む。演算５１０において、クエリ命令３００の実行は、データブロックの暗号化された合計３０２を復号化して、クライアントデバイス１２０のメモリハードウェア１２２上に記憶されているデータブロックの識別されたｃ個の合計Ｏから減算して、クエリブロックＢｑを得る工程をさらに含む。方法は、クエリ（ｑ）の数がクエリしきい値を超えるかどうかを決定し、クエリ（ｑ）の数がクエリしきい値を超えているとき、クライアント状態２５０を再び初期化する工程を含んでもよい。
In
図６は、本文書において記載されるシステムおよび方法を実装するあめに使用される例示的なコンピューティングデバイス６００（例えば、データ処理ハードウェア）の図解である。コンピューティングデバイス６００は、ラップトップ、デスクトップ、ワークステーション、パーソナルデジタルアシスタント、ブレードサーバ、メインフレームおよび他の適切なコンピュータなどの様々な形式のデジタルコンピュータを表すことを意図する。ここで示す構成要素、それらの接続および関係、ならびにそれらの機能は、例示的な目的でのみ示されており、本文書において記載され、および／または主張する発明の実施形態に限定することを意図するものではない。
FIG. 6 is an illustration of an exemplary computing device 600 (eg, data processing hardware) used in a candy to implement the systems and methods described in this document. The
コンピューティングデバイス６００は、プロセッサ６１０、メモリ６２０、ストレージデバイス６３０、メモリ６２０および高速拡張ポート６５０に接続されている高速インタフェース／制御部６４０、ならびに低速バス６７０およびストレージデバイス６３０に接続されている低速インタフェース／制御部６６０を含む。構成要素６１０，６２０，６３０，６４０，６５０，および６６０の各々は、様々なバスを使用して、または、他の適切な態様で相互接続されており、および、これらは、共通のマザーボードに装着されてもよい。プロセッサ６１０は、高速インタフェース６４０に結合されているディスプレイ６８０などの外部入出力デバイス上にグラフィカルユーザインタフェース（ＧＵＩ）のためのグラフィカルな情報を表示するためのメモリ６２０内またはストレージデバイス６３０上に記憶されている命令を含むコンピューティングデバイス６００内の実行のための命令を処理することができる。他の実施形態では、複数のメモリおよびメモリのタイプとともに、複数のプロセッサおよび／または複数のバスが適切に使用されてもよい。また、複数のコンピューティングデバイス６００は、必要な作業部分（例えば、サーババンク、ブレードサーバのグループ、またはマルチプロセッサシステム）を提供する各デバイスに接続されていてもよい。
The
メモリ６２０は、コンピューティングデバイス６００内に非一時的に情報を記憶する。メモリ６２０は、コンピュータ読み取り可能媒体、揮発性メモリユニット、または不揮発性メモリユニットであってもよい。非一時的メモリ６２０は、プログラム（例えば、命令のシーケンス）またはデータ（例えば、プログラム状態情報）をコンピューティングデバイス６００による使用のために一時的または持続的に記憶するための物理的なデバイスであってもよい。不揮発性メモリの例は、これに限定されるものではないが、フラッシュメモリおよびリードオンリーメモリ（ＲＯＭ）／プログラム可能リードオンリーメモリ（ＰＲＯＭ）／消去可能なプログラム可能リードオンリーメモリ（ＥＰＲＯＭ）／電気的に消去可能なプログラム可能リードオンリーメモリ（ＥＥＰＲＯＭ）（例えば、ブートプログラム等のファームウェアに対して通常に使用される）を含む。揮発性メモリの例は、限定するものではないが、ディスクまたはテープと同様に、ランダムアクセスメモリ（ＲＡＭ）、ダイナミックアクセスメモリ（ＤＲＡＭ）、スタティックランダムアクセスメモリ（ＳＲＡＭ）、相変化メモリ（ＰＣＭ）を含む。ストレージデバイス６３０（例えば、メモリハードウェア）は、コンピューティングデバイス６００のための大容量ストレージを提供することができる。いくつかの実施形態では、ストレージデバイス６３０は、コンピュータ読み取り可能媒体である。様々な異なる実施形態では、ストレージデバイス６３０は、ストレージエリアネットワークまたは他の構成におけるデバイスを含む、フロッピー（登録商標）ディスクドライブ、ハードディスクドライブ、光ディスクドライブ、またはテープデバイス、フラッシュメモリまたは他の類似するソリッドステートメモリデバイス、またはデバイスのアレイであってもよい。追加的な実施形態では、コンピュータブログラム製品は、情報搬送においてタンジブルに具現化されている。命令を含むコンピュータプログラム製品は、実行されるとき、上述したように、１以上の方法が行われる。情報搬送は、メモリ６２０、ストレージデバイス６３０、またはプロセッサ６１０上のメモリなどのコンピュータまたは機械読み取り可能媒体である。
The
高速制御部６４０は、コンピューティングデバイス６００のための帯域に集中した作業を管理する一方で、低速制御部６６０は、より低い帯域に集中した作業を管理する。そのような役割の割り当ては例示目的のみである。いくつかの実施形態では、高速制御部６４０は、メモリ６２０、ディスプレイ６８０（例えば、グラフィックプロセッサまたは加速器）および様々な拡張カード（図示せず）を受け入れてもよい高速拡張ポート６５０に結合されている。いくつかの実施形態では、低速制御部６６０は、ストレージデバイス６３０および低速拡張ポート６７０に結合されている。様々な通信ポート（例えば、ＵＳＢ、ブルートゥース、イーサーネット、無線イーサーネット）を含んでもよい低速拡張ポート６７０は、ぃーボード、ポインティングデバイス、スキャナ、またはスイッチまたはルータ（例えば、ネットワークアダプタを通じた）などのネットワーキングデバイスなどの１以上の入出力デバイスに結合されてもよい。
The high-speed control unit 640 manages the band-concentrated work for the
コンピューティングデバイス６００は、図に示されるように、いくつかの異なる形態において実装されてもよい。例えば、標準サーバ６００ａとしてまたはそのようなサーバ６００ａのグループにおいて複数回実装されてもよく、ラップトップコンピュータ６００ｂとして、または、ラックサーバシステム６００ｃの一部として実装されてもよい。
The
ソフトウェアアプリケーション（すなわち、ソフトウェア資源）は、コンピューティングデバイスにタスクを行わせるコンピュータソフトウェアを参照する。いくつかの例において、ソフトウェアプリケーションは、「アプリケーション」、「アプリ」、または「プログラム」として参照されてもよい。アプリケーションの例は、限定するものではないが、システム診断アプリケーション、システム管理アプリケーション、システムメンテナンスアプリケーション、ワード処理アプリケーション、スプレッドシートアプリケーション、メッセージングアプリケーション、メディアストリーミングアプリケーション、ソーシャルネットワーキングアプリケーション、およびゲーミングアプリケーションを含む。 A software application (ie, a software resource) refers to computer software that causes a computing device to perform a task. In some examples, software applications may be referred to as "applications," "apps," or "programs." Examples of applications include, but are not limited to, system diagnostic applications, system management applications, system maintenance applications, word processing applications, spreadsheet applications, messaging applications, media streaming applications, social networking applications, and gaming applications.
ここで記載したシステムおよび技術の様々な実施形態は、デジタル電気および／または光学回路、集積回路、特別に設計されたＡＳＩＣ（特定用途向け集積回路）、コンピュータハードウェア、ファームウェア、ソフトウェア、および／またはこれらの組み合わせにおいて実現されることができる。これらの様々は実施形態は、特定または汎用目的であってもよく、データおよび命令をそこから受信するために、および、データおよび命令をそれに対して送信するために、ストレージシステムに結合される少なくとも１つのプログラム可能プロセッサ、少なくとも１つの入力デバイス、および少なくとも１つの出力デバイスを含むプログラム可能システム上で実行可能および／または解釈可能な１以上のコンピュータプログラムにおける実施形態を含むことができる。 Various embodiments of the systems and techniques described herein include digital electrical and / or optical circuits, integrated circuits, specially designed ASICs (application specific integrated circuits), computer hardware, firmware, software, and / or. It can be realized in these combinations. These various embodiments may be for specific or general purpose purposes and are at least coupled to the storage system in order to receive data and instructions from it and to send data and instructions to it. It can include embodiments in one or more computer programs that are executable and / or interpretable on a programmable system that includes one programmable processor, at least one input device, and at least one output device.
これらのコンピュータプログラム（プログラム、ソフトウェアアプリケーション、またはコードとしても知られている）は、プログラム可能なプロセッサのための機械命令を含み、高級手続き型および／またはオブジェクト指向プログラミング言語および／またはアセンブリ／機械言語において実装されることができる。ここで使用される「機械読み取り可能媒体」および「コンピュータ読み取り可能媒体」の用語は、機械命令を機械読み取り可能信号として受信する機械読み取り可能媒体を含む、プログラム可能プロセッサに機械命令および／またはデータを提供するために使用されるいずれのコンピュータプログラム製品、非一時的コンピュータ読み取り可能媒体、装置および／またはデバイス（例えば、磁気ディスク、光ディスク、メモリ、機械命令および／またはプログラマブルロジックデバイス（ＰＬＤ））も参照する。「機械読み取り可能信号」の用語は、機械命令および／またはデータをプログラム可能プロセッサに提供するために使用されるいずれの信号にも参照する。 These computer programs (also known as programs, software applications, or code) include machine instructions for programmable processors, high-level procedural and / or object-oriented programming languages and / or assembly / machine languages. Can be implemented in. As used herein, the terms "machine-readable medium" and "computer-readable medium" refer to machine instructions and / or data to a programmable processor, including machine-readable media that receive machine instructions as machine-readable signals. See also any computer program product, non-temporary computer readable medium, device and / or device used to provide (eg, magnetic disks, optical disks, memory, machine instructions and / or programmable logic devices (PLDs)). do. The term "machine readable signal" refers to any signal used to provide machine instructions and / or data to a programmable processor.
本明細書における処理およびロジックフローは、入力データを演算して出力を生成する関数を実行する１以上のコンピュータプログラムを実行する１以上のプログラム可能プロセッサによって行われることができる。処理およびロジックフローは、特定目的のロジック回路、例えば、ＦＰＧＡ（フィールドプログラマブルゲートアレイ）またはＡＳＩＣ（特定用途向け集積回路）によって行われることもできる。コンピュータプログラムの実行のために適したプロセッサは、例として汎用および特定目的のマイクロプロセッサ、ならびにデジタルコンピュータのいずれかの種類の１以上のプロセッサを含む。一般的に、プロセッサは、リードオンリーメモリ、ランダムアクセスメモリ、またはその両方から命令およびデータを受信する。コンピュータの基本要素は、命令を実行するためのプロセッサならびに命令およびデータを記憶するための１以上のメモリデバイスである。一般的に、コンピュータは、また、データを記憶するための１以上の大容量ストレージデバイス例えば、磁気ディスク、磁気光ディスク、または光ディスクを含む。すなわち、その大容量ストレージデバイスからデータを受信し、または、データを転送し、またはその両方を行うように、その大容量ストレージデバイスに動作可能に結合されている。しかしながら、コンピュータは、そのようなデバイスを有する必要がない。コンピュータプログラム命令およびデータを記憶するためのコンピュータ読み取り可能媒体は、すべての形式の不揮発性メモリ、例として、例えば、ＥＰＲＯＭ、ＥＥＰＲＯＭ、およびフラッシュメモリデバイスを含む半導体メモリデバイス；磁気ディスク、例えば、内部ハードディスクまたは取り出し可能ディスク；磁気光ディスク；ならびにＣＤＲＯＭおよびＤＶＤ‐ＲＯＭディスクを含む。プロセッサおよびメモリは、特定目的ロジック回路によって補足され、または、これに取り入れられることができる。 The processing and logic flow herein can be performed by one or more programmable processors that execute one or more computer programs that execute functions that compute input data and produce output. Processing and logic flow can also be performed by logic circuits of specific purpose, such as FPGAs (Field Programmable Gate Arrays) or ASICs (Application Specific Integrated Circuits). Suitable processors for running computer programs include, for example, general purpose and purpose-built microprocessors, as well as one or more processors of any kind of digital computer. Generally, the processor receives instructions and data from read-only memory, random access memory, or both. The basic elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. In general, a computer also includes one or more mass storage devices for storing data, such as magnetic disks, magnetic optical disks, or optical disks. That is, it is operably coupled to the mass storage device to receive data from the mass storage device, transfer data, or both. However, the computer does not need to have such a device. Computer-readable media for storing computer program instructions and data are semiconductor memory devices including all types of non-volatile memory, eg, EPROM, EEPROM, and flash memory devices; magnetic disks, eg, internal hard disks. Or include removable disks; magnetic optical disks; as well as CDROM and DVD-ROM disks. Processors and memory can be supplemented or incorporated into purpose-built logic circuits.
ユーザとの対話を提供するために、本開示の１以上の態様は、ディスプレイデバイス、例えば、ユーザに情報を表示するためのＣＲＴ（陰極線管）、ＬＣＤ（液晶ディスプレイ）モニタ、またはタッチスクリーン、任意選択的に、ユーザがこれによってコンピュータに入力を提供することができるためのキーボードおよびポインティングデバイス、例えば、マウスまたはトラックボールを有するコンピュータ上に実装されることができる。他の種類のデバイスもまたユーザとの対話を提供するために使用されることができ、例えば、ユーザに提供されるフィードバックは、例えば、ビジュアルフィードバック、オーディオフィードバック、または触覚フィードバックのセンサによるフィードバックのいずれかの形式であることができ；ユーザによる入力は、音響、発言、または触覚による入力を含むいずれかの形式により受信されることができる。さらに、コンピュータは、例えば、ウェブブラウザから受信した要求に応答して、ウェブページをユーザのクライアントデバイス上のウェブブラウザに送信することによって、ユーザによって使用されているデバイスと文書の送受信を行うことによってユーザと対話することができる。 To provide user interaction, one or more aspects of the disclosure include a display device, eg, a CRT (cathode tube), LCD (liquid crystal display) monitor, or touch screen for displaying information to the user, optionally. Optionally, it can be implemented on a computer that has a keyboard and pointing device, such as a mouse or trackball, for the user to be able to provide input to the computer. Other types of devices can also be used to provide user interaction, for example, the feedback provided to the user may be, for example, visual feedback, audio feedback, or tactile feedback sensor feedback. The user's input can be received in any form, including acoustic, speech, or tactile input. In addition, the computer sends and receives documents to and from the device being used by the user, for example, by sending a web page to the web browser on the user's client device in response to a request received from the web browser. Can interact with the user.
いくつかの実施形態が記載された。それでも、本開示の精神および範囲から逸脱することなく様々は変形が行われてもよいことが理解されるであろう。したがって、他の実施形態は、以下の請求の範囲内のものである。 Several embodiments have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the present disclosure. Therefore, other embodiments are within the scope of the following claims.
Claims (22)
前記データ処理ハードウェア（１２４）が、クエリ命令（３００）を実行して前記アントラストストレージデバイス（１５０）に記憶されているクエリブロックＢｑを取り出す工程であって、
前記メモリハードウェア（１２４）に記憶されているデータブロック（１０２）のｃ個の合計Ｏの各々を繰り返し処理して前記クエリブロックＢｑを含まないｃ個の合計Ｏのうちの１つを識別し、
前記アントラストストレージデバイス（１５０）を管理しているサービス（１６０）に対して、前記アントラストストレージデバイス（１５０）のｎ個のデータブロックを、各々がｋ+１個のデータブロック（１０２）を含むｎ／（ｋ+１）個のパーティション（３５０）に疑似ランダムに区分けするよう命令し、および、前記ｎ／（ｋ+１）個のパーティション（３５０）の各々における前記ｋ+１個のデータブロック（１０２）を合計して、前記ｎ／（ｋ+１）個のパーティション（３５０）の各々について、対応する暗号化されたデータブロック合計（３０２）を決定し、前記ｎ／（ｋ+１）個のパーティション（３５０）の１つは、前記クエリブロックＢｑを含まない識別された前記データブロックのｃ個の合計Ｏを含む固定のパーティションを備え、
前記固定のパーティションを含む前記ｎ／（ｋ+１）個のパーティションの暗号化された前記データブロック合計（３０２）を前記アントラストストレージデバイス（１５０）を管理している前記サービスから取り出し、
暗号化された前記データブロック合計（３０２）を復号化して、前記クライアントデバイス（１２０）の前記メモリハードウェア（１２２）に記憶されている識別された前記データブロックのｃ個の合計Ｏから減算して前記クエリブロックＢｑを得る、ことによる、前記クエリブロックＢｑを取り出す工程と、
前記データ処理ハードウェア（１２４）が、クエリ（ｑ）の数がクエリしきい値を超えているかどうかを決定する工程と、
前記データ処理ハードウェア（１２４）が、前記クエリ（ｑ）の数が前記クエリしきい値を超えている場合、前記クライアント状態（２５０）を再び初期化する工程と、を備える方法（５００）。 The data processing hardware (124) of the client device (120) executes the private batch total search command (200) to generate c total O of the data blocks (102) from the untrust storage device (150). In the step of initializing the client state (250) on the client device (120) by calculation, each of the calculated totals O is sent to the memory hardware (122) of the client device (120). The initialization step, which is stored and includes the sum of exactly k data blocks (102) of the corresponding subset S.
A step in which the data processing hardware (124) executes a query instruction (300) to retrieve the query block B q stored in the untrust storage device (150).
Each of the c total O of the data block (102) stored in the memory hardware (124) is iteratively processed to identify one of the c total O not including the query block B q. death,
For the service (160) that manages the untrust storage device (150), n data blocks of the untrust storage device (150), each k + 1 data block (102). It is instructed to divide into n / (k + 1) partitions (350) including, and the k + 1 data in each of the n / (k + 1) partitions (350). The blocks (102) are summed to determine the corresponding encrypted data block sum (302) for each of the n / (k + 1) partitions (350), and the n / (k + 1) said. ) One of the partitions (350) comprises a fixed partition containing a total O of c of the identified data blocks not including the query block B q.
The encrypted total data blocks (302) of the n / (k + 1) partitions including the fixed partition are retrieved from the service managing the untrust storage device (150).
The encrypted data block total (302) is decrypted and subtracted from the c total O of the identified data blocks stored in the memory hardware (122) of the client device (120). obtain the query block B q Te, possibly, taking out the query block B q,
A step in which the data processing hardware (124) determines whether the number of queries (q) exceeds the query threshold.
A method (500) comprising: the data processing hardware (124) reinitializing the client state (250) when the number of queries (q) exceeds the query threshold.
前記クライアントデバイス（１２０）に前記アントラストストレージデバイス（１５０）に記憶されているすべてのデータブロック（１０２）をクラス分けする工程であって、前記アントラストストレージデバイス（１５０）は、ｎ個のデータブロックを記憶する、前記クラス分け工程と、
前記アントラストストレージデバイス（１５０）からクラス分けされた選択されたデータブロック（１０２）をデータブロックのｃ個のサブセットＳのうちの対応するサブセットＳに割り当てる工程と、
前記対応するサブセットＳに割り当てられた選択された前記データブロック（１０２）を合計することによって、データブロックのｃ個の合計Ｏの各々を計算する工程と、を備える、請求項１に記載の方法（５００）。 Executing the private batch total search instruction (200) to calculate the total O of c data blocks
In the step of classifying all the data blocks (102) stored in the untrust storage device (150) into the client device (120), the untrust storage device (150) has n data. The classification process for storing blocks and
A step of allocating the selected data block (102) classified from the untrust storage device (150) to the corresponding subset S of the c subsets S of the data blocks.
The method of claim 1, comprising a step of calculating each of the c totals O of the data blocks by summing the selected data blocks (102) assigned to the corresponding subset S. (500).
前記アントラストストレージデバイス（１５０）のｎ個のデータブロック（１０２）をｋ個のバケット（２６０）に区分けする工程と、
計算されるデータブロック（１０２）のｃ個の合計Ｏの各々について、前記ｋ個のバケット（１６０）の各々からｔ個のデータブロック（１０２）をダウンロードして、前記メモリハードウェア（１２２）上のストレージのためのデータブロック（１０２）の前記対応する合計Ｏを計算する工程と、を備える、請求項１〜４のいずれか１項に記載の方法（５００）。 Executing the private batch total search instruction (200) to calculate the total O of c pieces of the data block (102)
A step of dividing the n data blocks (102) of the untrust storage device (150) into k buckets (260), and
For each of the c total O of the calculated data blocks (102), t data blocks (102) are downloaded from each of the k buckets (160) and are placed on the memory hardware (122). The method (500) according to any one of claims 1 to 4, comprising the step of calculating the corresponding total O of the data block (102) for storage of.
前記クライアントデバイス（１２０）から前記アントラストストレージデバイス（１５０）を管理している前記サービス（１６０）に対して非公開情報検索要求（２６４）を送信して、前記ｔ個のデータブロック（１０２）を前記ｋ個のバケット（２６０）の各々から取り出す工程であって、前記非公開情報要求（２６４）は、各々のｔ個のデータブロック（１０２）を前記サービス（１６０）に暗号化させ、および、前記アントラストストレージデバイス（１５０）上に対応する非公開情報検索結果として記憶させる、工程と、
加法準同型暗号のベクトル（２６６）を生成する工程と、
前記加法準同型暗号のベクトル（２６６）を前記アントラストストレージデバイス（１５０）にアップロードする工程であって、前記加法準同型暗号のベクトル（２６６）は、前記アントラストストレージデバイス（１５０）を管理している前記サービス（１６０）に、前記加法準同型暗号のベクトル（２６６）を使用して前記非公開情報検索結果に対して加法準同型暗号計算（２６８）を実行させ、前記加法準同型暗号計算（２６８）は、データブロックの対応するｃ個の合計Ｏに対する暗号化テキスト値に対応する、工程と、
前記アントラストストレージデバイス（１５０）を管理している前記サービス（１６０）から前記暗号化テキストを受信し暗号化して、前記データブロック（１０２）の対応するｃ個の合計Ｏを得る工程と、を備える、請求項５に記載の方法（５００）。 Downloading t data blocks (102) from each of the k buckets (160) for each of the c total O of the calculated data blocks (102)
A private information retrieval request (264) is transmitted from the client device (120) to the service (160) that manages the untrust storage device (150), and the t data blocks (102). Is out of each of the k buckets (260), the private information request (264) encrypts each t data blocks (102) by the service (160), and , The process of storing as the corresponding non-public information retrieval result on the untrust storage device (150).
The process of generating an additive homomorphic encryption vector (266) and
The step of uploading the additive homomorphic encryption vector (266) to the untrust storage device (150), wherein the additive homomorphic encryption vector (266) manages the untrust storage device (150). The service (160) is made to perform an additive homomorphic encryption calculation (268) on the non-public information search result by using the additive homomorphic encryption vector (266), and the additive homomorphic encryption calculation is performed. (268) corresponds to the encrypted text value for the corresponding c total O of the data blocks.
A step of receiving and encrypting the encrypted text from the service (160) that manages the untrust storage device (150) to obtain the corresponding c total O of the data block (102). The method according to claim 5 (500).
前記アントラストストレージデバイス（１５０）のｎ個のデータブロックをｎ／（ｋ+１）個のパーティション（３５０）へと疑似ランダムに区分けするための命令を含む、疑似ランダム置換区分け鍵（κ）のベクトルを生成する工程と、
前記クライアントデバイス（１２０）から前記アントラストストレージデバイス（１５０）を管理している前記サービス（１６０）に対して、前記疑似ランダム置換区分け鍵（κ）のベクトルを含む要求（３２０）を送信する工程であって、前記要求（３２０）は、前記サービス（１６０）に前記アントラストストレージデバイス（１５０）のｎ個のデータブロック（１０２）をｎ／（ｋ+１）個のパーティション（３５０）へと疑似ランダムに区分けさせ、前記ｎ／（ｋ+１）個のパーティション（３５０）の１つは、前記クエリブロックＢｑを含まない前記データブロック（１０２）の識別されたｃ個の合計Ｏを含む前記固定のパーティションを含む、工程と、を備える、請求項１〜９のいずれか１項に記載の方法（５００）。 For the service (160) that manages the untrust storage device (150), n data blocks of the untrust storage device (150) are divided into n / (k + 1) partitions (350). To instruct the partition to be pseudo-random
Pseudo-random permutation keyed (κ) containing instructions for pseudo-randomly dividing n data blocks of the untrust storage device (150) into n / (k + 1) partitions (350). The process of generating a vector and
A step of transmitting a request (320) including a vector of the pseudo-random permutation partition key (κ) from the client device (120) to the service (160) that manages the untrust storage device (150). That is, the request (320) causes the service (160) to convert n data blocks (102) of the untrust storage device (150) into n / (k + 1) partitions (350). Pseudo-randomly divided, one of the n / (k + 1) partitions (350) contains the identified c total O of the data block (102) that does not include the query block B q. The method (500) according to any one of claims 1 to 9, comprising the steps comprising the fixed partition.
前記データ処理ハードウェア（１２４）と通信している、前記クライアントデバイス（１２０）のメモリハードウェア（１２２）と、を備えるシステム（６００）であって、前記メモリハードウェア（１２２）は、前記データ処理ハードウェア（１２４）によって実行されたとき、前記データ処理ハードウェア（１２４）に、
非公開バッチ合計検索命令（２００）を実行して、アントラストストレージデバイス（１５０）からのデータブロック（１０２）のｃ個の合計Ｏを計算することによって、前記クライアントデバイス（１２０）上のクライアント状態（２５０）を初期化する工程であって、計算された合計Ｏの各々は、前記クライアントデバイス（１２０）のメモリハードウェア（１２２）に記憶されており、かつ、対応するサブセットＳの丁度ｋ個のデータブロック（１０２）の合計を含む、前記初期化する工程と、
クエリ命令（３００）を実行して前記アントラストストレージデバイス（１５０）に記憶されているクエリブロックＢｑを取り出す工程であって、
前記メモリハードウェア（１２４）に記憶されているデータブロック（１０２）のｃ個の合計Ｏの各々を繰り返し処理して前記クエリブロックＢｑを含まないｃ個の合計Ｏのうちの１つを識別し、
前記アントラストストレージデバイス（１５０）を管理しているサービス（１６０）に対して、前記アントラストストレージデバイス（１５０）のｎ個のデータブロックを、各々がｋ+１個のデータブロック（１０２）を含むｎ／（ｋ+１）個のパーティション（３５０）に疑似ランダムに区分けするよう命令し、および、前記ｎ／（ｋ+１）個のパーティション（３５０）の各々における前記ｋ+１個のデータブロック（１０２）を合計して、前記ｎ／（ｋ+１）個のパーティション（３５０）の各々について、対応する暗号化されたデータブロック合計（３０２）を決定し、前記ｎ／（ｋ+１）個のパーティション（３５０）の１つは、前記クエリブロックＢｑを含まない識別された前記データブロックのｃ個の合計Ｏを含む固定のパーティションを備え、
前記固定のパーティションを含む前記ｎ／（ｋ+１）個のパーティションの暗号化された前記データブロック合計（３０２）を前記アントラストストレージデバイス（１５０）を管理している前記サービスから取り出し、
暗号化された前記データブロック合計（３０２）を復号化して、前記クライアントデバイス（１２０）の前記メモリハードウェア（１２２）に記憶されている識別された前記データブロックのｃ個の合計Ｏから減算して前記クエリブロックＢｑを得る、ことによる、前記クエリブロックＢｑを取り出す工程と、
クエリ（ｑ）の数がクエリしきい値を超えているかどうかを決定する工程と、
前記クエリ（ｑ）の数が前記クエリしきい値を超えている場合、前記クライアント状態（２５０）を再び初期化する工程と、を含む処理を行わせる命令を記憶する、システム（６００）。 The data processing hardware (124) of the client device (120) and
A system (600) comprising a memory hardware (122) of the client device (120) communicating with the data processing hardware (124), wherein the memory hardware (122) is the data. When executed by the processing hardware (124), the data processing hardware (124),
The client state on the client device (120) by executing the private batch total search instruction (200) to calculate the total O of c data blocks (102) from the untrusted storage device (150). In the step of initializing (250), each of the calculated totals O is stored in the memory hardware (122) of the client device (120), and exactly k of the corresponding subsets S. The initialization step, including the sum of the data blocks (102) of
A step of executing the query instruction (300) to retrieve the query block B q stored in the untrust storage device (150).
Each of the c total O of the data block (102) stored in the memory hardware (124) is iteratively processed to identify one of the c total O not including the query block B q. death,
For the service (160) that manages the untrust storage device (150), n data blocks of the untrust storage device (150), each k + 1 data block (102). It is instructed to divide into n / (k + 1) partitions (350) including, and the k + 1 data in each of the n / (k + 1) partitions (350). The blocks (102) are summed to determine the corresponding encrypted data block sum (302) for each of the n / (k + 1) partitions (350), and the n / (k + 1) said. ) One of the partitions (350) comprises a fixed partition containing a total O of c of the identified data blocks not including the query block B q.
The encrypted total data blocks (302) of the n / (k + 1) partitions including the fixed partition are retrieved from the service managing the untrust storage device (150).
The encrypted data block total (302) is decrypted and subtracted from the c total O of the identified data blocks stored in the memory hardware (122) of the client device (120). obtain the query block B q Te, possibly, taking out the query block B q,
The process of determining whether the number of queries (q) exceeds the query threshold, and
A system (600) that stores an instruction to perform a process including a step of reinitializing the client state (250) when the number of the queries (q) exceeds the query threshold.
前記クライアントデバイス（１２０）に前記アントラストストレージデバイス（１５０）に記憶されているすべてのデータブロック（１０２）をクラス分けする工程であって、前記アントラストストレージデバイス（１５０）は、ｎ個のデータブロックを記憶する、前記クラス分け工程と、
前記アントラストストレージデバイス（１５０）からクラス分けされた選択されたデータブロック（１０２）をデータブロックのｃ個のサブセットＳのうちの対応するサブセットＳに割り当てる工程と、
前記対応するサブセットＳに割り当てられた選択された前記データブロック（１０２）を合計することによって、データブロックのｃ個の合計Ｏの各々を計算する工程と、を備える、請求項１２に記載のシステム（６００）。 Executing the private batch total search instruction (200) to calculate the total O of c data blocks
In the step of classifying all the data blocks (102) stored in the untrust storage device (150) into the client device (120), the untrust storage device (150) has n data. The classification process for storing blocks and
A step of allocating the selected data block (102) classified from the untrust storage device (150) to the corresponding subset S of the c subsets S of the data blocks.
12. The system of claim 12, comprising a step of calculating each of the c totals O of the data blocks by summing the selected data blocks (102) assigned to the corresponding subset S. (600).
前記アントラストストレージデバイス（１５０）のｎ個のデータブロック（１０２）をｋ個のバケット（２６０）に区分けする工程と、
計算されるデータブロック（１０２）のｃ個の合計Ｏの各々について、前記ｋ個のバケット（１６０）の各々からｔ個のデータブロック（１０２）をダウンロードして、前記メモリハードウェア（１２２）上のストレージのためのデータブロック（１０２）の前記対応する合計Ｏを計算する工程と、を備える、請求項１２〜１５のいずれか１項に記載のシステム（６００）。 Executing the private batch total search instruction (200) to calculate the total O of c pieces of the data block (102)
A step of dividing the n data blocks (102) of the untrust storage device (150) into k buckets (260), and
For each of the c total O of the calculated data blocks (102), t data blocks (102) are downloaded from each of the k buckets (160) and are placed on the memory hardware (122). The system (600) according to any one of claims 12 to 15, comprising the step of calculating the corresponding total O of the data block (102) for storage of.
前記クライアントデバイス（１２０）から前記アントラストストレージデバイス（１５０）を管理している前記サービス（１６０）に対して非公開情報検索要求（２６４）を送信して、前記ｔ個のデータブロック（１０２）を前記ｋ個のバケット（２６０）の各々から取り出す工程であって、前記非公開情報要求（２６４）は、各々のｔ個のデータブロック（１０２）を前記サービス（１６０）に暗号化させ、および、前記アントラストストレージデバイス（１５０）上に対応する非公開情報検索結果として記憶させる、工程と、
加法準同型暗号のベクトル（２６６）を生成する工程と、
前記加法準同型暗号のベクトル（２６６）を前記アントラストストレージデバイス（１５０）にアップロードする工程であって、前記加法準同型暗号のベクトル（２６６）は、前記アントラストストレージデバイス（１５０）を管理している前記サービス（１６０）に、前記加法準同型暗号のベクトル（２６６）を使用して前記非公開情報検索結果に対して加法準同型暗号計算（２６８）を実行させ、前記加法準同型暗号計算（２６８）は、データブロックの対応するｃ個の合計Ｏに対する暗号化テキスト値に対応する、工程と、
前記アントラストストレージデバイス（１５０）を管理している前記サービス（１６０）から前記暗号化テキストを受信し暗号化して、前記データブロック（１０２）の対応するｃ個の合計Ｏを得る工程と、を備える、請求項１６に記載のシステム（６００）。 Downloading t data blocks (102) from each of the k buckets (160) for each of the c total O of the calculated data blocks (102)
A private information retrieval request (264) is transmitted from the client device (120) to the service (160) that manages the untrust storage device (150), and the t data blocks (102). Is out of each of the k buckets (260), the private information request (264) encrypts each t data blocks (102) by the service (160), and , The process of storing as the corresponding non-public information retrieval result on the untrust storage device (150).
The process of generating an additive homomorphic encryption vector (266) and
The step of uploading the additive homomorphic encryption vector (266) to the untrust storage device (150), wherein the additive homomorphic encryption vector (266) manages the untrust storage device (150). The service (160) is made to perform an additive homomorphic encryption calculation (268) on the non-public information search result by using the additive homomorphic encryption vector (266), and the additive homomorphic encryption calculation is performed. (268) corresponds to the encrypted text value for the corresponding c total O of the data blocks.
A step of receiving and encrypting the encrypted text from the service (160) that manages the untrust storage device (150) to obtain the corresponding c total O of the data block (102). The system (600) according to claim 16.
前記アントラストストレージデバイス（１５０）のｎ個のデータブロックをｎ／（ｋ+１）個のパーティション（３５０）へと疑似ランダムに区分けするための命令を含む、疑似ランダム置換区分け鍵（κ）のベクトルを生成する工程と、
前記クライアントデバイス（１２０）から前記アントラストストレージデバイス（１５０）を管理している前記サービス（１６０）に対して、前記疑似ランダム置換区分け鍵（κ）のベクトルを含む要求（３２０）を送信する工程であって、前記要求（３２０）は、前記サービス（１６０）に前記アントラストストレージデバイス（１５０）のｎ個のデータブロック（１０２）をｎ／（ｋ+１）個のパーティション（３５０）へと疑似ランダムに区分けさせ、前記ｎ／（ｋ+１）個のパーティション（３５０）の１つは、前記クエリブロックＢｑを含まない前記データブロック（１０２）の識別されたｃ個の合計Ｏを含む前記固定のパーティションを含む、工程と、を備える、請求項１２〜２０のいずれか１項に記載のシステム（６００）。 For the service (160) that manages the untrust storage device (150), n data blocks of the untrust storage device (150) are divided into n / (k + 1) partitions (350). To instruct the partition to be pseudo-random
Pseudo-random permutation keyed (κ) containing instructions for pseudo-randomly dividing n data blocks of the untrust storage device (150) into n / (k + 1) partitions (350). The process of generating a vector and
A step of transmitting a request (320) including a vector of the pseudo-random permutation partition key (κ) from the client device (120) to the service (160) that manages the untrust storage device (150). The request (320) transfers n data blocks (102) of the untrust storage device (150) to n / (k + 1) partitions (350) to the service (160). Pseudo-randomly divided, one of the n / (k + 1) partitions (350) contains the identified c total O of the data block (102) that does not include the query block B q. The system (600) according to any one of claims 12 to 20, comprising the steps comprising the fixed partition.
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2018/031369 WO2019216872A1 (en) | 2018-05-07 | 2018-05-07 | Private information retrieval with sublinear public-key operations |
Publications (2)
Publication Number | Publication Date |
---|---|
JP2021521490A true JP2021521490A (en) | 2021-08-26 |
JP7000601B2 JP7000601B2 (en) | 2022-01-19 |
Family
ID=62245440
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
JP2020562672A Active JP7000601B2 (en) | 2018-05-07 | 2018-05-07 | Search for private information by sublinear public key operation |
Country Status (6)
Country | Link |
---|---|
US (2) | US11593516B2 (en) |
EP (1) | EP3776317B1 (en) |
JP (1) | JP7000601B2 (en) |
KR (1) | KR102308066B1 (en) |
CN (1) | CN112400171B (en) |
WO (1) | WO2019216872A1 (en) |
Families Citing this family (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2021087073A1 (en) | 2019-10-30 | 2021-05-06 | Via Science, Inc. | Secure outsourcing of a multiplication |
CN115269938B (en) * | 2022-09-22 | 2023-02-14 | 深圳市洞见智慧科技有限公司 | Homomorphic encryption-based keyword track hiding query method, system and related device |
US11977657B1 (en) * | 2023-02-22 | 2024-05-07 | Lorica Cybersecurity Inc. | Method and system for confidential repository searching and retrieval |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JP2006210964A (en) * | 2005-01-24 | 2006-08-10 | National Institute Of Information & Communication Technology | Method and device for transferring information by elgamal encryption |
JP2007124520A (en) * | 2005-10-31 | 2007-05-17 | Ntt Data Corp | Data searching system, information processing apparatus, data searching method and program |
JP2008500598A (en) * | 2004-05-20 | 2008-01-10 | 株式会社エヌ・ティ・ティ・ドコモ | Method and apparatus for confidential information retrieval and lost communication with good communication efficiency |
US20170277906A1 (en) * | 2016-03-22 | 2017-09-28 | International Business Machines Corporation | Privacy enhanced central data storage |
Family Cites Families (11)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5890151A (en) * | 1997-05-09 | 1999-03-30 | International Business Machines Corporation | Method and system for performing partial-sum queries on a data cube |
US8880905B2 (en) * | 2010-10-27 | 2014-11-04 | Apple Inc. | Methods for processing private metadata |
US8635465B1 (en) * | 2012-03-28 | 2014-01-21 | Emc Corporation | Counter-based encryption of stored data blocks |
CN102629924A (en) * | 2012-03-30 | 2012-08-08 | 上海交通大学 | Private information retrieval method in environment of a plurality of servers |
US9164702B1 (en) | 2012-09-07 | 2015-10-20 | Google Inc. | Single-sided distributed cache system |
WO2015152935A1 (en) * | 2014-04-04 | 2015-10-08 | Hewlett-Packard Development Company, L.P. | Storing and retrieving ciphertext in data storage |
US10268834B2 (en) * | 2014-06-26 | 2019-04-23 | Telefonaktiebolaget Lm Ericsson (Publ) | Privacy-preserving querying mechanism on privately encrypted data on semi-trusted cloud |
US9946719B2 (en) * | 2015-07-27 | 2018-04-17 | Sas Institute Inc. | Distributed data set encryption and decryption |
US10402372B2 (en) * | 2015-07-27 | 2019-09-03 | Sas Institute Inc. | Distributed data storage grouping |
US10503596B2 (en) * | 2015-07-31 | 2019-12-10 | Pure Storage, Inc. | Accessing an encoded data slice in a dispersed storage network |
CN107992582B (en) * | 2017-12-07 | 2021-01-29 | 深圳先达数据信息技术有限公司 | Private information retrieval method based on sawtooth decoding |
-
2018
- 2018-05-07 KR KR1020207034943A patent/KR102308066B1/en active IP Right Grant
- 2018-05-07 US US17/053,648 patent/US11593516B2/en active Active
- 2018-05-07 EP EP18727515.1A patent/EP3776317B1/en active Active
- 2018-05-07 CN CN201880095465.6A patent/CN112400171B/en active Active
- 2018-05-07 JP JP2020562672A patent/JP7000601B2/en active Active
- 2018-05-07 WO PCT/US2018/031369 patent/WO2019216872A1/en unknown
-
2023
- 2023-02-10 US US18/167,490 patent/US20230185960A1/en active Pending
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JP2008500598A (en) * | 2004-05-20 | 2008-01-10 | 株式会社エヌ・ティ・ティ・ドコモ | Method and apparatus for confidential information retrieval and lost communication with good communication efficiency |
JP2006210964A (en) * | 2005-01-24 | 2006-08-10 | National Institute Of Information & Communication Technology | Method and device for transferring information by elgamal encryption |
JP2007124520A (en) * | 2005-10-31 | 2007-05-17 | Ntt Data Corp | Data searching system, information processing apparatus, data searching method and program |
US20170277906A1 (en) * | 2016-03-22 | 2017-09-28 | International Business Machines Corporation | Privacy enhanced central data storage |
Non-Patent Citations (1)
Title |
---|
MAYBERRY, T., BLASS, E.-O. AND CHAN, A. H.: "Efficient Private File Retrieval by Combining ORAM and PIR", CRYPTOLOGY EPRINT ARCHIVE, JPN6021048470, January 2014 (2014-01-01), pages 1 - 11, XP061015343, ISSN: 0004657820, DOI: 10.14722/ndss.2014.23033 * |
Also Published As
Publication number | Publication date |
---|---|
US20210192076A1 (en) | 2021-06-24 |
KR20200142588A (en) | 2020-12-22 |
KR102308066B1 (en) | 2021-09-30 |
EP3776317A1 (en) | 2021-02-17 |
WO2019216872A1 (en) | 2019-11-14 |
CN112400171B (en) | 2024-04-09 |
EP3776317B1 (en) | 2022-07-06 |
JP7000601B2 (en) | 2022-01-19 |
US20230185960A1 (en) | 2023-06-15 |
CN112400171A (en) | 2021-02-23 |
US11593516B2 (en) | 2023-02-28 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11574073B2 (en) | Encrypted search cloud service with cryptographic sharing | |
JP7124182B2 (en) | Forgetful access with differential privacy | |
US20220277099A1 (en) | Encrypting data records and processing encrypted records without exposing plaintext | |
US9680809B2 (en) | Secure data storage on a cloud environment | |
CN107430668B (en) | Secure distributed backup for personal devices and cloud data | |
US20230185960A1 (en) | Private Information Retrieval with Sublinear Public-Key Operations | |
Pitchai et al. | Searchable encrypted data file sharing method using public cloud service for secure storage in cloud computing | |
US11599806B2 (en) | Depth-constrained knowledge distillation for inference on encrypted data | |
CN110622142B (en) | Efficient casual cloud storage | |
Santos et al. | Enhancing medical data security on public cloud | |
Lam et al. | Gpu-based private information retrieval for on-device machine learning inference | |
CN116521969A (en) | Data retrieval method, server, system and related equipment | |
Mishra et al. | Improved cloud security approach with threshold cryptography | |
Gao et al. | XPORAM: A Practical Multi-client ORAM Against Malicious Adversaries | |
Jain et al. | Privacy Preserving Mining using Data Encryption scheme for Hadoop Ecosystem |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
A621 | Written request for application examination |
Free format text: JAPANESE INTERMEDIATE CODE: A621Effective date: 20201130 |
|
TRDD | Decision of grant or rejection written | ||
A01 | Written decision to grant a patent or to grant a registration (utility model) |
Free format text: JAPANESE INTERMEDIATE CODE: A01Effective date: 20211207 |
|
A61 | First payment of annual fees (during grant procedure) |
Free format text: JAPANESE INTERMEDIATE CODE: A61Effective date: 20211223 |
|
R150 | Certificate of patent or registration of utility model |
Ref document number: 7000601Country of ref document: JPFree format text: JAPANESE INTERMEDIATE CODE: R150 |