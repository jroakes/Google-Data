US7031958B2 - Patterned based query optimization - Google Patents
Patterned based query optimization Download PDFInfo
- Publication number
- US7031958B2 US7031958B2 US10/360,397 US36039703A US7031958B2 US 7031958 B2 US7031958 B2 US 7031958B2 US 36039703 A US36039703 A US 36039703A US 7031958 B2 US7031958 B2 US 7031958B2
- Authority
- US
- United States
- Prior art keywords
- query
- execution
- access plan
- access
- queries
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime, expires
Links
- 238000005457 optimization Methods 0.000 title claims description 35
- 238000000034 method Methods 0.000 claims abstract description 27
- 230000004044 response Effects 0.000 claims abstract description 10
- 230000015654 memory Effects 0.000 claims description 16
- 238000003860 storage Methods 0.000 claims description 12
- 238000012544 monitoring process Methods 0.000 claims description 5
- 230000003068 static effect Effects 0.000 claims description 2
- 238000012545 processing Methods 0.000 abstract description 12
- 238000004519 manufacturing process Methods 0.000 abstract description 5
- 230000006399 behavior Effects 0.000 description 4
- 230000008901 benefit Effects 0.000 description 4
- 238000010586 diagram Methods 0.000 description 3
- 238000013459 approach Methods 0.000 description 2
- 230000006870 function Effects 0.000 description 2
- 238000005304 joining Methods 0.000 description 2
- 238000012549 training Methods 0.000 description 2
- 230000008859 change Effects 0.000 description 1
- 230000002452 interceptive effect Effects 0.000 description 1
- 230000002093 peripheral effect Effects 0.000 description 1
- 230000008569 process Effects 0.000 description 1
- 238000012360 testing method Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2453—Query optimisation
- G06F16/24534—Query rewriting; Transformation
- G06F16/24542—Plan optimisation
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99933—Query processing, i.e. searching
Definitions
- the present invention generally relates to data processing and more particularly to query optimization.
- Databases are computerized information storage and retrieval systems.
- a relational database management system is a computer database management system (DBMS) that uses relational techniques for storing and retrieving data.
- the most prevalent type of database is the relational database, a tabular database in which data is defined so that it can be reorganized and accessed in a number of different ways.
- a distributed database is one that can be dispersed or replicated among different points in a network.
- An object-oriented programming database is one that is congruent with the data defined in object classes and subclasses.
- a requesting entity e.g., an application or the operating system
- requests may include, for instance, simple catalog lookup requests or transactions and combinations of transactions that operate to read, change and add specified records in the database.
- SQL Structured Query Language
- IBM International Business Machines'
- Microsoft's SQL Server and database products from Oracle, Sybase, and Computer Associates.
- the term “query” denominates a set of commands for retrieving data from a stored database. Queries take the form of a command language that lets programmers and programs select, insert, update, find out the location of data, and so forth.
- the DBMS includes a query optimizer component configured to determine the manner in which queries will be processed.
- the primary task of the optimizer is to determine the most efficient way to execute each particular query against a database.
- the optimizer typically determines an access plan for use in executing the query against the database.
- the access plan contains low-level information indicating precisely what steps the system is to take to execute the query (e.g., using an index, a hash table, bit map, etc.).
- Conventional optimizers are generally configured to determine the best access plan for each query it encounters, based on cost comparisons (i.e., estimated resource requirements, typically in terms of time and space) of available access plans.
- the optimizer may explore various ways to execute the query. For example, the optimizer may determine if an index may be used to speed a search, whether a search condition should be applied to a first table prior to joining the first table to a second table or whether to join the tables first.
- the optimizer may incur a substantial cost by placing a significant burden on system resources and/or requiring a significant amount of time.
- One approach to reduce this burden is to limit the number of times the optimizer is run by using the same access plan every time the same query is encountered. This approach is typically limited to situations where the same query is executed multiple times. In many cases, however, for a different, but similar query (e.g., queries with similar selection criteria or WHERE clauses), the optimizer may determine the same access plan.
- conventional optimizers are not designed to recognize similarities in queries and will, thus, wastefully optimize the similar query, although the same access plan will likely be returned.
- the present invention generally provides methods, articles of manufacture and systems for optimizing query execution by selecting access plans based on prior query executions.
- a method of optimizing execution of a query generally includes receiving the query, selecting, from a set of one or more access plans used for prior executions of the query or a similar query, an access plan for use in executing the query, and executing the query according to the selected access plan.
- a method of optimizing execution of a query generally includes receiving the query and determining if the query fits within an established group of queries. The method also includes, in response to determining the query fits within an established group of queries, selecting, from a group of access plans used for prior executions of queries within the established group, an access plan for use in executing the query, and executing the query according to the selected access plan.
- the article of manufacture generally includes a computer-readable medium containing a program which, when executed by a processor, performs operations for optimizing execution of a query.
- the operations generally include receiving the query, selecting, from a set of one or more access plans used for prior executions of the query or a similar query, an access plan for use in executing the query, and executing the query according to the selected access plan.
- the system generally includes a database, a query optimizer, one or more records, each containing a set of access plans used in prior executions of a query or a group of similar queries, and a query execution component.
- the query execution component is generally configured to receive a query and execute the query against the database according to an access plan selected from one of the records or an access plan generated by the query optimizer.
- FIG. 1 is a computer system illustratively utilized in accordance with the present invention.
- FIG. 2A is a relational view of software components of one embodiment of the present invention.
- FIGS. 2B and 2C illustrate an exemplary grouped query record and an exemplary query execution record, respectively.
- FIG. 3 is a flow chart illustrating exemplary operations for optimizing execution of a query according to aspects of the present invention.
- FIG. 4 is a flow chart illustrating exemplary operations for creating or updating a query group according to aspects of the present invention.
- FIG. 5 is a flow chart illustrating exemplary operations for choosing an access plan according to aspects of the present invention.
- FIG. 6 is a flow chart illustrating exemplary operations for choosing an access plan for specific optimization modes according to aspects of the present invention.
- FIG. 7 is an exemplary graphical user interface (GUI) screen for specifying pattern-based optimization options according to aspects of the present invention.
- GUI graphical user interface
- the present invention generally is directed to systems, methods and articles of manufacture for improving the efficiency of executing a query.
- an access plan may be selected from a series of access plans used for prior executions of the same or a group of similar queries.
- the series of access plans used for prior query executions may define a pattern that may be used to accurately predict the behavior (e.g., execution time) of a future query.
- a query group may be established to identify a set of similar queries, for which the optimizer is likely to determine the same access plans.
- an access plan associated with the query group may be selected for executing the query, thus avoiding the processing overhead of wastefully running the optimizer only to determine a previously used access plan.
- an access plan generally refers to any type of information indicating what steps the system is to take to execute a query including, but not limited to, information such as indexes to use, an order of applying search conditions, joining tables, etc. Further, in some instances, an access plan may include multiple sets of steps, where each set of steps may be regarded as an individual access plan. However, to facilitate understanding, the following description will refer to the multiple sets of steps, taken as a whole, as a single access plan.
- One embodiment of the invention is implemented as a program product for use with a computer system such as, for example, the computer system 110 of the data processing environment 100 shown in FIG. 1 and described below.
- the program(s) of the program product defines functions of the embodiments (including the methods described herein) and can be contained on a variety of signal-bearing media.
- Illustrative signal-bearing media include, but are not limited to: (i) information permanently stored on non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive); (ii) alterable information stored on writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive); or (iii) information conveyed to a computer by a communications medium, such as through a computer or telephone network, including wireless communications. The latter embodiment specifically includes information downloaded from the Internet and other networks.
- Such signal-bearing media when carrying computer-readable instructions that direct the functions of the present invention, represent embodiments of the present invention.
- routines executed to implement the embodiments of the invention may be part of an operating system or a specific application, component, program, module, object, or sequence of instructions.
- the software of the present invention typically is comprised of a multitude of instructions that will be translated by the native computer into a machine-readable format and hence executable instructions.
- programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices.
- various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However, it should be appreciated that any particular nomenclature that follows is used merely for convenience, and thus the invention should not be limited to use solely in any specific application identified and/or implied by such nomenclature.
- the data processing environment 100 includes a computer system 110 and a plurality of networked devices 146 .
- the computer system 110 may represent any type of computer, computer system or other programmable electronic device, including a client computer, a server computer, a portable computer, an embedded controller, a PC-based server, a minicomputer, a midrange computer, a mainframe computer, and other computers adapted to support the methods, apparatus, and article of manufacture of the invention.
- the computer system 110 is an eServer iSeries 400 available from International Business Machines of Armonk, N.Y.
- the computer system 110 could include a number of operators and peripheral systems as shown, for example, by a mass storage interface 137 operably connected to a direct access storage device (DASD) 138 , by a video interface 140 operably connected to a display 142 , and by a network interface 144 operably connected to the networked devices 146 .
- the display 142 may be any video output device for outputting viewable information.
- the networked devices 146 may be any combination of any type networked devices, such as networked servers, networked printers, and network accessed storage (NAS) devices.
- NAS network accessed storage
- Computer system 110 is shown comprising at least one processor 112 , which obtains instructions and data via a bus 114 from a main memory 116 .
- the processor 112 could be any processor adapted to support the methods of the invention.
- the main memory 116 is any memory sufficiently large to hold the necessary programs and data structures.
- Main memory 116 could be one or a combination of memory devices, including Random Access Memory, nonvolatile or backup memory, (e.g., programmable or Flash memories, read-only memories, etc.).
- main memory 116 may be considered to include memory physically located elsewhere in a computer system 110 , for example, any storage capacity used as virtual memory or stored on a mass storage device (e.g., DASD 138 ) or on another computer coupled to the computer system 110 via bus 114 .
- a mass storage device e.g., DASD 138
- the main memory 116 is shown configured with an operating system 118 .
- the operating system 118 is the software used for managing the operation of the computer system 110 . Examples of the operating system 118 include UNIX, Microsoft Windows®, and the like.
- the main memory 116 further includes at least one application 120 and a query execution component 130 .
- the application 120 and the query execution component 130 are software products comprising a plurality of instructions that are resident at various times in various memory and storage devices in the computer system 110 . When read and executed by one or more processors 112 in the computer system 110 , the application 120 and the query execution component 130 cause the computer system 110 to perform the steps necessary to execute steps or elements embodying the various aspects of the invention.
- the application 120 (and more generally, any requesting entity, including the operating system 118 ) is configured to run (i.e., issue/execute) queries against a database 139 (illustratively shown as resident in the DASD 138 ) via the query execution component 130 .
- the queries issued by the application 120 may be created and/or specified by a user via a query building interface 122 , which may be included with the application 120 .
- the queries may be generated (e.g., by a user) via the query building interface 122 by specifying query conditions, for example, through one or more a graphical user interface (GUI) screens.
- the application 120 may send the generated queries to the query execution component 130 for execution.
- the query execution component 130 may include a query optimizer 132 for optimizing received queries prior to execution.
- the query execution component 130 may be generally configured to examine information regarding optimizations performed on prior executions of a query, or a similar query, prior to running the query optimizer 132 .
- Information regarding optimizations performed on prior executions of queries may be stored in a grouped query table 150 and/or a query execution table 160 .
- the tables 150 and 160 may include access plans used for previously executed queries along with corresponding execution times.
- FIG. 2A illustrates a relational view of the application 120 , query execution component 130 , database 139 , grouped query table 150 , and query execution table 160 , according to one embodiment of the invention.
- the query execution component 130 may be configured to determine whether to run the optimizer 132 to generate an access plan or to select an access plan from the grouped query table 150 or query execution table 160 , thus avoiding running the query optimizer 132 and the associated processing overhead.
- the grouped query table 150 may include a set of grouped query records 151 , each of which contains a set of access plans used for prior executions of a group of similar queries.
- the queries within a query group may be related in that their optimizations are in all likelihood the same or similar.
- the optimizer 132 would likely determine the same access plan, or set of access plans for each query within a query group.
- queries within a query group may share a common set of criteria (e.g., SQL WHERE clauses), that causes the query optimizer 132 to generate the same or similar access plans.
- the grouped query table 160 may include a set of query records 161 , each of which contains a set of access plans used for prior executions of the same query.
- each grouped query record 151 may correspond to a number of related queries
- each query execution record 161 may correspond to a single query.
- an advantage to query grouping is that a relatively small grouped query table 150 may be used to select access plan for executing a relatively large number of queries.
- a further advantage to query grouping is that a grouped query table 150 may be generated (as described in greater detail below) by monitoring the execution of a relatively small number of queries.
- An advantage to a query execution table 160 is that, because each query execution record 161 contains a set of access plans used for prior executions of the same query, a more accurate prediction of the behavior of executing the query with a selected one of the access plans may be made.
- various embodiments of the present invention may include both the grouped query table 150 and the query execution table 160 , just the grouped query table 150 , or just the query execution table 160 . Further, for some embodiments, query grouping may be enabled/disabled via a user-selectable option.
- FIGS. 2B and 2C illustrate an exemplary grouped query record 151 and query execution record 161 , respectively.
- the grouped query record 151 may include a group ID field 152 , optional query ID field 153 , an execution count field 154 , query text field 155 , tables field 156 , and where clause field 157 .
- the grouped query record 151 may also include a set of access plan fields 158 ( 158 1 . . . N ) to hold a series of access plans used for previous executions of queries from the group.
- the grouped query record may also include a set of execution time fields 159 ( 159 1 . . . N ) to hold execution times corresponding to the previously used access plans.
- the execution time of field 159 1 corresponds to a prior execution of a query using the access plan of field 158 1 .
- the group ID field 152 may identify the establish query group corresponding to the record 151 .
- the optional query ID field 153 may be used to further classify queries within a query group and/or as a cross reference to a related query execution record 161 .
- the query execution component 130 locate a grouped query record for a query based on the query ID.
- the query execution component 130 may receive a query and generate a group ID (e.g., via a lookup table) based on a where clause contained in the query.
- the query execution component 130 may retrieve a grouped query record 151 for use in selecting an access plan for executing a query based on a search of the query test field 155 , tables field 156 or where clause field 157 .
- the query execution component 130 may search the where clause field 157 of grouped query records 151 in the grouped query table 150 for a match to a where clause of a query.
- the query execution component 130 may then select an access plan 158 from a grouped query record 151 with a where clause field 157 that matches a where clause of the query.
- the execution count field 154 may indicate the number of times (N) queries within the group have been executed, and generally correlates to the number of entries (generally defined as an access plan and a corresponding execution time) in the grouped query record 151 . As will be described in greater detail below, for some embodiments, a minimum number of executions may be required before an access plan is selected from the grouped query record 151 . The minimum number of executions may be determined, for example, in an effort to ensure a sufficient execution history is established for a query group prior to performing pattern-based optimization.
- the optimizer may be run to generate an access plan and the query may be executed using the generated access plan. Subsequently, the generated access plan and corresponding execution time may be entered into the grouped query record 151 and the execution count field 154 incremented.
- the period prior to reaching the minimum number of execution times may be regarded as a training period during which query execution history is captured in the form of access plan and execution time entries into the grouped query record 151 .
- the access plan fields 158 may include multiple entries with the same access plan but different corresponding execution time fields 159 .
- the same access plan may result in different execution times.
- this historical information may be useful when selecting an access plan.
- the query execution record 161 may contain similar fields ( 162 – 169 ) to the grouped query record 151 , which may serve the same purposes as described above.
- a particular query record 161 may be identified by a query ID field 163 , and may be cross-referenced to a grouped query record 151 via an optional group ID 162 .
- the query execution record 161 may also be identified by a query text field 165 , which may be searched to determine a match with the text of an issued query.
- a query execution record 161 may be accessed rather than a grouped query record 151 .
- query grouping may not be implemented or may be disabled. Accordingly, the query execution record 161 may not have tables or where clause fields (e.g., fields 156 or 157 ), which may be used to relate queries within a query group.
- the grouped query table 150 and/or the query execution table 160 may be automatically generated and initialized “offline” (e.g., prior to performing pattern-based optimization) using existing information available on the system.
- query groups may be established by examination of query statements (e.g., static SQL) contained in one or more user programs, such as the applications 120 or to examine query statements 171 contained in a system-wide statement cache 170 .
- the query execution component 130 may access these query statements and generate an initial set of grouped query records 151 based on common criteria in statements (e.g., where clauses), which may provide an initial framework for capturing execution history and possibly speed the process of group- enabled pattern-based optimization.
- FIG. 3 is a flow diagram of exemplary operations 300 (e.g., that may be performed by the query execution component 130 ) for performing pattern-based optimization that may be optionally group-enabled.
- the operations 300 begin at step 302 , for example, in response to a user invoking the application 120 .
- the query execution component 130 receives a query from a requesting entity, such as the application 120 .
- the query execution component 130 determines if the received query is new (e.g., a record corresponding to the query does not exist in either the query execution table 160 or grouped query table 150 ). If the query is new, processing proceeds to steps 308 – 314 to create the necessary framework to begin capturing execution history. For example, at step 308 , a query execution record 161 is added to the query execution table 160 .
- a determination is made as to whether query grouping is enabled. If query grouping is enabled, a query group is created or updated at step 314 (suitable operations for creating or updating the query group are shown in FIG. 4 ), prior to choosing an access plan, at step 316 .
- step 306 processing proceeds directly to step 316 , to choose an access plan.
- an access plan may be chosen from a query execution record 161 , grouped query record 151 , or may be generated by the optimizer. Suitable operations for choosing an access plan are described in greater detail below, with reference to FIG. 5 . Regardless, once the access plan is chosen, the query is executed, at step 318 .
- the execution time of the query may be monitored. Accordingly, at step 320 , the query execution table 160 may be updated, for example, with an entry of the chosen access plan and monitored execution time to a query execution record 161 corresponding to the executed query. If grouping is enabled, as determined at step 322 , a grouped query record 151 in the grouped query table 150 may be updated in a similar manner, at step 324 . Thus, the execution history of a query, or group of similar queries may be updated with each execution. Of course, there may be a limit to the number of entries that may be stored in a single record and/or entries may be overwritten. Regardless, the operations 300 are exited at step 326 , for example, by returning query results to the application 120 .
- FIG. 4 illustrates exemplary operations 400 for creating or updating the grouped query table 150 in response to receiving a new query.
- the operations 400 begin, for example, by receiving the new query.
- a determination is made as to whether the new query fits within an existing query group. For example, as previously described, queries within a group may be related by a same or similar WHERE clause. Therefore, WHERE clause fields 157 of grouped query records 151 may be searched for a match to determine if the query fits within an existing group. If the query fits within an existing query group, an entry is added to the grouped query table 150 , at step 406 . As previously described, adding the entry may comprise appending, to an existing grouped query record 151 , an additional access plan field 158 and corresponding execution time field 159 for holding an access plan to be chosen for the new query and corresponding execution time.
- a new grouped query record 151 is generated based on the query. For example, values for grouped query fields 152 – 157 may be generated at steps 408 – 416 . A new record populated with the generated values may be added to the grouped query table, at step 418 . Whether a new grouped query record was created or an existing query record was updated, the operations 400 are terminated at step 420 , for example, by returning to a main routine (e.g., operations 300 ), to choose an access plan.
- a main routine e.g., operations 300
- FIG. 5 is a flow diagram of exemplary operations 500 that may be performed by the query execution component 130 for choosing an access plan for executing a query, according to one embodiment of the present invention.
- the operations 500 may correspond to step 316 of FIG. 3 .
- the operations 500 begin at step 502 , for example, after receiving a query (determining if the query is new, updating the query execution table 160 and/or updating the grouped query table 150 ).
- a determination may be made as to whether there is sufficient execution history for the query to select an access plan from the located record. As previously described, this determination may be based on the number of times the query (or similar queries in a query group) have been executed, which may be indicated by the execution count field 154 or 164 . For example, the execution count may be compared against a predetermined threshold value. If the execution count has not reached the threshold value, it may be determined that there is not sufficient execution history for the query (to accurately predict the behavior of executing the query with a previously used access plan) and the optimizer 132 is run, at step 512 , to generate an access plan. Accordingly, the optimizer 132 may be run on successive executions until there is sufficient execution history for the query.
- the optimizer 132 may also be run if it is determined none of the access plans in the record have a corresponding execution time below a predetermined maximum execution time. In other words, none of the access plans in the record may have resulted in an acceptable execution time.
- an access plan may be selected from the grouped query record 151 or query execution record 161 located in steps 508 or 506 , respectively, thus avoiding the cost of running the optimizer.
- each record may comprise a set of access plans used for prior executions of the query (or other similar queries within a query group).
- a number of different algorithms may be used to select an access plan from the set of access plans and the access plan selected may be determined by the particular algorithm used.
- a user may be able to specify a particular mode of optimization to obtain a desired affect, such as reliable (i.e., safe) or fast execution of the query.
- a determination is made as to whether a particular optimization mode has been specified. If a particular optimization mode has not been specified, at step 516 , an access plan is chosen according to a default algorithm, which may be any suitable algorithm (e.g., an access plan with the lowest average corresponding execution times may be chosen). If a particular optimization mode has been specified, at step 518 , an access plan is chosen according to the specified optimization mode ( FIG. 6 illustrates exemplary operations for choosing an access plan according to two exemplary optimization modes). Regardless, at step 520 , the operations are terminated by returning the selected access plan.
- FIG. 6 is a flow diagram of exemplary operations 600 that may be performed by the query execution component 130 for choosing an access plan according to a particular optimization mode. While the query execution component 130 may be configured to implement a variety of optimization modes, to facilitate understanding, the operations 600 are limited to choosing between a FAST mode (for optimizing execution time) and a SAFE mode (for optimizing the likelihood of execution within a specified execution time). Further, for the purposes of the following description, it is assumed that either the FAST or SAFE mode has been previously chosen, for example, by a user. The operations 600 begin at step 602 .
- step 604 a determination is made as to whether FAST or SAFE optimization mode has been specified. If the FAST mode has been specified, processing proceeds to step 606 , where a determination is made as to whether grouping is enabled. If grouping is enabled, the fastest access plan from the grouped query table 150 is selected, at step 608 . In other words, referring back to FIG. 2B , the access plan 158 with the shortest corresponding execution time field 159 from a grouped query record 151 corresponding to the query may be selected.
- the fastest access plan from the query execution table 160 may be selected in a similar manner, at step 608 (e.g., the access plan 168 corresponding to the shortest execution time field 169 from a query execution record 151 for the query may be selected).
- the SAFE mode may be specified for various situations when it is more important that the query execute within a specified time than that the query execute within the fastest possible time. In other words, certain access plans may result in the shortest execution time in certain situations, and result in an unacceptable execution time in other situations. Fortunately, this situation may be readily determined from a grouped query record 151 or a query execution record 161 .
- either type record may include entries (access plan and execution time) for 30 prior executions of the same query using 3 different access plans (plans 1 , 2 , and 3 ). Based on the entries, it may be determined that plan 1 results in the fastest execution time (e.g., 5s) under some conditions and an unacceptable execution time (e.g., >1m) under other conditions (which may be indicative of a problem). On the other hand, it may also be determined, based on the entries, that while plans 2 and 3 never result in the fastest execution times (e.g., less than 5s), they also never result in unacceptably high execution times (e.g., above 30s).
- plans 1 results in the fastest execution time (e.g., 5s) under some conditions and an unacceptable execution time (e.g., >1m) under other conditions (which may be indicative of a problem).
- plans 2 and 3 never result in the fastest execution times (e.g., less than 5s), they also never result in unacceptably high execution times (e.g., above 30s
- the query execution component 130 may be configured in a SAFE mode to use plans 2 or 3 to avoid any problems that may be associated with plan 1 .
- a safe execution time is determined.
- the safe execution time may be a user-specified value correspond to a predetermined acceptable execution time.
- a determination is made as to whether grouping is enabled. If grouping is enabled, a safe access plan is selected from the grouped query table 150 , at step 616 . If grouping is not enabled, a safe access plan is selected from the query execution table 150 , at step 616 .
- a safe access plan may be any access plan that does not have any corresponding execution times greater than the determined safe execution time. If more than one access plan has no corresponding execution times greater than the determined safe execution time, any suitable algorithm may be used to choose between the two. For example, the access plan with the shortest corresponding execution time, the shortest maximum corresponding execution time, or the shortest average of corresponding execution times may be selected.
- the operations 600 are exited, for example, by returning the selected safe or fastest access plan for use in executing the query.
- a user may configure certain aspects of pattern-based query optimization by specifying one or more options.
- the user may specify the options through any suitable interface, such as a command line or one or more GUI screens.
- FIG. 7 illustrates an exemplary GUI screen 700 that may be presented to a user for specifying pattern-based query optimization options.
- the GUI screen 700 may include a window 710 with a check box 712 for enabling query grouping and a pull down menu 714 for specifying a required number of executions before an access plan may be chosen based on the pattern-based optimization techniques described above.
- enabling query grouping may reduce the number of times the optimizer 132 is run by allowing a query to be executed using access plans generated for prior executions of similar queries. While reducing the number of required executions may also reduce the number of times the optimizer is run by reducing the “training period” for establishing a sufficient execution history for using pattern-based optimization, if set too low, the captured pattern of access plans may be too limited to accurately predict the behavior of executed queries.
- the GUI screen 700 may also include a window 720 for specifying a particular optimization mode.
- the window 720 may include radio buttons 722 for specifying a FAST, SAFE, or DEFAULT optimization mode, which may each be implemented as described above.
- the window 720 may also include an edit box 724 for specifying a safe execution time, to be used for selecting an access plan in the SAFE execution mode.
- the GUI screen 700 is for illustrative purposes only, and the exact options presented may vary for different embodiments. For example, some embodiments may not implement query grouping, some embodiments may not implement specific optimizations modes, etc.
- an execution history, or pattern of optimizations, for a query may be captured as a set of access plans used for prior executions of the query, or a group of similar queries.
- an access plan selected from the set of access plans rather than generating a new access plan by running a query optimizer, the number of times the query optimizer is run may be reduced, thereby reducing processing overhead and speeding query execution. Further, by monitoring execution times for previously used access plans, inefficient access plans may be identified and, therefore, avoided.
Abstract
Description
Claims (23)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/360,397 US7031958B2 (en) | 2003-02-06 | 2003-02-06 | Patterned based query optimization |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/360,397 US7031958B2 (en) | 2003-02-06 | 2003-02-06 | Patterned based query optimization |
Publications (2)
Publication Number | Publication Date |
---|---|
US20040158551A1 US20040158551A1 (en) | 2004-08-12 |
US7031958B2 true US7031958B2 (en) | 2006-04-18 |
Family
ID=32824000
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/360,397 Expired - Lifetime US7031958B2 (en) | 2003-02-06 | 2003-02-06 | Patterned based query optimization |
Country Status (1)
Country | Link |
---|---|
US (1) | US7031958B2 (en) |
Cited By (24)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20050097091A1 (en) * | 2003-09-06 | 2005-05-05 | Oracle International Corporation | SQL tuning base |
US20050262046A1 (en) * | 2004-05-05 | 2005-11-24 | International Business Machines Corporation | Method and system for query directives and access plan hints |
US20060004695A1 (en) * | 2004-06-03 | 2006-01-05 | International Business Machines Corporation | Apparatus and method for autonomically generating a query implementation that meets a defined performance specification |
US20060074874A1 (en) * | 2004-09-30 | 2006-04-06 | International Business Machines Corporation | Method and apparatus for re-evaluating execution strategy for a database query |
US20060106839A1 (en) * | 2004-10-29 | 2006-05-18 | International Business Machines Corporation | Maintain optimal query performance by presenting differences between access plans |
US20060136368A1 (en) * | 2004-12-22 | 2006-06-22 | Ianywhere Solutions, Inc. | Database System and Methodology for Generalized Order Optimization |
US20060149724A1 (en) * | 2005-01-03 | 2006-07-06 | Ritter Gerd M | Methods relating to data repository querying |
US20070078829A1 (en) * | 2005-10-05 | 2007-04-05 | Microsoft Corporation | Safe mode for inverse query evaluations |
US20070143246A1 (en) * | 2005-12-15 | 2007-06-21 | International Business Machines Corporation | Method and apparatus for analyzing the effect of different execution parameters on the performance of a database query |
US20070185933A1 (en) * | 2006-02-03 | 2007-08-09 | International Business Machines Corporation | Predictive data object retrieval |
US20080172356A1 (en) * | 2007-01-17 | 2008-07-17 | Microsoft Corporation | Progressive parametric query optimization |
US20080183671A1 (en) * | 2007-01-26 | 2008-07-31 | Sap Ag | Managing Queries in a Distributed Database System |
US7467131B1 (en) * | 2003-09-30 | 2008-12-16 | Google Inc. | Method and system for query data caching and optimization in a search engine system |
US20090216748A1 (en) * | 2007-09-20 | 2009-08-27 | Hal Kravcik | Internet data mining method and system |
US20100057687A1 (en) * | 2008-09-04 | 2010-03-04 | Microsoft Corporation | Predicting future queries from log data |
US20100082507A1 (en) * | 2008-09-30 | 2010-04-01 | Archana Sulochana Ganapathi | Predicting Performance Of Executing A Query In Isolation In A Database |
US20100299337A1 (en) * | 2009-05-19 | 2010-11-25 | Sap Ag | Computer System for Processing a Query |
US20100306591A1 (en) * | 2009-06-01 | 2010-12-02 | Murali Mallela Krishna | Method and system for performing testing on a database system |
US8620902B2 (en) | 2011-06-01 | 2013-12-31 | Lexisnexis, A Division Of Reed Elsevier Inc. | Computer program products and methods for query collection optimization |
US20140258210A1 (en) * | 2013-03-06 | 2014-09-11 | Tata Consultancy Services Limited | Business intelligence reports with navigable reference indicators |
WO2017165914A1 (en) * | 2016-03-31 | 2017-10-05 | Wisetech Global Limited | "methods and systems for database optimisation" |
US9910892B2 (en) | 2008-07-05 | 2018-03-06 | Hewlett Packard Enterprise Development Lp | Managing execution of database queries |
US10042888B2 (en) | 2014-11-28 | 2018-08-07 | International Business Machines Corporation | Searching in a database |
US11256694B2 (en) | 2020-04-27 | 2022-02-22 | Hewlett Packard Enterprise Development Lp | Tolerance level-based tuning of query processing |
Families Citing this family (74)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CA2374298A1 (en) * | 2002-03-01 | 2003-09-01 | Ibm Canada Limited-Ibm Canada Limitee | Computation of frequent data values |
US20040019587A1 (en) * | 2002-07-25 | 2004-01-29 | You-Chin Fuh | Method and device for processing a query in a database management system |
US7661141B2 (en) * | 2004-02-11 | 2010-02-09 | Microsoft Corporation | Systems and methods that optimize row level database security |
US7711750B1 (en) | 2004-02-11 | 2010-05-04 | Microsoft Corporation | Systems and methods that specify row level database security |
US7596560B2 (en) | 2004-12-23 | 2009-09-29 | Raytheon Company | System and method for adaptive query identification and acceleration |
US20060230019A1 (en) * | 2005-04-08 | 2006-10-12 | International Business Machines Corporation | System and method to optimize database access by synchronizing state based on data access patterns |
US8452756B2 (en) * | 2006-11-09 | 2013-05-28 | International Business Machines Corporation | Database execution detail repository |
US20090271360A1 (en) * | 2008-04-25 | 2009-10-29 | Bestgen Robert J | Assigning Plan Volatility Scores to Control Reoptimization Frequency and Number of Stored Reoptimization Plans |
CN102035649B (en) | 2009-09-29 | 2013-08-21 | 国际商业机器公司 | Authentication method and device |
WO2012045071A2 (en) * | 2010-10-01 | 2012-04-05 | Asparity Decision Solutions, Inc. | Methods, systems, and computer readable media for using stored conjoint analysis software iteration data in conjoint analysis of different product or service combinations |
US10048974B1 (en) | 2014-09-30 | 2018-08-14 | Amazon Technologies, Inc. | Message-based computation request scheduling |
US9678773B1 (en) | 2014-09-30 | 2017-06-13 | Amazon Technologies, Inc. | Low latency computational capacity provisioning |
US9830193B1 (en) | 2014-09-30 | 2017-11-28 | Amazon Technologies, Inc. | Automatic management of low latency computational capacity |
US9146764B1 (en) | 2014-09-30 | 2015-09-29 | Amazon Technologies, Inc. | Processing event messages for user requests to execute program code |
US9600312B2 (en) | 2014-09-30 | 2017-03-21 | Amazon Technologies, Inc. | Threading as a service |
US9323556B2 (en) | 2014-09-30 | 2016-04-26 | Amazon Technologies, Inc. | Programmatic event detection and message generation for requests to execute program code |
CN105677683B (en) * | 2014-11-21 | 2018-12-14 | 华为技术有限公司 | Batch data querying method and device |
US9537788B2 (en) | 2014-12-05 | 2017-01-03 | Amazon Technologies, Inc. | Automatic determination of resource sizing |
US9733967B2 (en) | 2015-02-04 | 2017-08-15 | Amazon Technologies, Inc. | Security protocols for low latency execution of program code |
US9588790B1 (en) | 2015-02-04 | 2017-03-07 | Amazon Technologies, Inc. | Stateful virtual compute system |
EP3137987B1 (en) * | 2015-03-16 | 2020-01-01 | Huawei Technologies Co. Ltd. | A method and a plan optimizing apparatus for optimizing query execution plan |
US9785476B2 (en) | 2015-04-08 | 2017-10-10 | Amazon Technologies, Inc. | Endpoint management system and virtual compute system |
US10067801B1 (en) | 2015-12-21 | 2018-09-04 | Amazon Technologies, Inc. | Acquisition and maintenance of compute capacity |
US9910713B2 (en) | 2015-12-21 | 2018-03-06 | Amazon Technologies, Inc. | Code execution request routing |
US11132213B1 (en) | 2016-03-30 | 2021-09-28 | Amazon Technologies, Inc. | Dependency-based process of pre-existing data sets at an on demand code execution environment |
US10891145B2 (en) | 2016-03-30 | 2021-01-12 | Amazon Technologies, Inc. | Processing pre-existing data sets at an on demand code execution environment |
US10599646B2 (en) * | 2016-04-26 | 2020-03-24 | Quest Software Inc. | Symbiotic data insights from harmonized queries |
US10102040B2 (en) | 2016-06-29 | 2018-10-16 | Amazon Technologies, Inc | Adjusting variable limit on concurrent code executions |
US20180046675A1 (en) * | 2016-08-11 | 2018-02-15 | Sap Se | Automatic adjustment of an execution plan for a query |
US10884787B1 (en) * | 2016-09-23 | 2021-01-05 | Amazon Technologies, Inc. | Execution guarantees in an on-demand network code execution system |
US10831898B1 (en) | 2018-02-05 | 2020-11-10 | Amazon Technologies, Inc. | Detecting privilege escalations in code including cross-service calls |
US10733085B1 (en) | 2018-02-05 | 2020-08-04 | Amazon Technologies, Inc. | Detecting impedance mismatches due to cross-service calls |
US10725752B1 (en) | 2018-02-13 | 2020-07-28 | Amazon Technologies, Inc. | Dependency handling in an on-demand network code execution system |
US10776091B1 (en) | 2018-02-26 | 2020-09-15 | Amazon Technologies, Inc. | Logging endpoint in an on-demand code execution system |
US10853115B2 (en) | 2018-06-25 | 2020-12-01 | Amazon Technologies, Inc. | Execution of auxiliary functions in an on-demand network code execution system |
US10649749B1 (en) | 2018-06-26 | 2020-05-12 | Amazon Technologies, Inc. | Cross-environment application of tracing information for improved code execution |
US11146569B1 (en) | 2018-06-28 | 2021-10-12 | Amazon Technologies, Inc. | Escalation-resistant secure network services using request-scoped authentication information |
US10949237B2 (en) | 2018-06-29 | 2021-03-16 | Amazon Technologies, Inc. | Operating system customization in an on-demand network code execution system |
US11099870B1 (en) | 2018-07-25 | 2021-08-24 | Amazon Technologies, Inc. | Reducing execution times in an on-demand network code execution system using saved machine states |
US11099917B2 (en) | 2018-09-27 | 2021-08-24 | Amazon Technologies, Inc. | Efficient state maintenance for execution environments in an on-demand code execution system |
US11243953B2 (en) | 2018-09-27 | 2022-02-08 | Amazon Technologies, Inc. | Mapreduce implementation in an on-demand network code execution system and stream data processing system |
US11943093B1 (en) | 2018-11-20 | 2024-03-26 | Amazon Technologies, Inc. | Network connection recovery after virtual machine transition in an on-demand network code execution system |
US10884812B2 (en) | 2018-12-13 | 2021-01-05 | Amazon Technologies, Inc. | Performance-based hardware emulation in an on-demand network code execution system |
US11010188B1 (en) | 2019-02-05 | 2021-05-18 | Amazon Technologies, Inc. | Simulated data object storage using on-demand computation of data objects |
US11360969B2 (en) | 2019-03-20 | 2022-06-14 | Promethium, Inc. | Natural language based processing of data stored across heterogeneous data sources |
US11861386B1 (en) | 2019-03-22 | 2024-01-02 | Amazon Technologies, Inc. | Application gateways in an on-demand network code execution system |
US11100104B2 (en) * | 2019-04-09 | 2021-08-24 | Accenture Global Solutions Limited | Query tuning utilizing optimizer hints |
EP3977308B1 (en) * | 2019-05-24 | 2023-11-22 | Huawei Technologies Co., Ltd. | Learning-based query plan cache for capturing low-cost query plan |
US11119809B1 (en) | 2019-06-20 | 2021-09-14 | Amazon Technologies, Inc. | Virtualization-based transaction handling in an on-demand network code execution system |
US11159528B2 (en) | 2019-06-28 | 2021-10-26 | Amazon Technologies, Inc. | Authentication to network-services using hosted authentication information |
US11115404B2 (en) | 2019-06-28 | 2021-09-07 | Amazon Technologies, Inc. | Facilitating service connections in serverless code executions |
US11190609B2 (en) | 2019-06-28 | 2021-11-30 | Amazon Technologies, Inc. | Connection pooling for scalable network services |
US10908927B1 (en) | 2019-09-27 | 2021-02-02 | Amazon Technologies, Inc. | On-demand execution of object filter code in output path of object storage service |
US11360948B2 (en) | 2019-09-27 | 2022-06-14 | Amazon Technologies, Inc. | Inserting owner-specified data processing pipelines into input/output path of object storage service |
US11394761B1 (en) | 2019-09-27 | 2022-07-19 | Amazon Technologies, Inc. | Execution of user-submitted code on a stream of data |
US11023311B2 (en) | 2019-09-27 | 2021-06-01 | Amazon Technologies, Inc. | On-demand code execution in input path of data uploaded to storage service in multiple data portions |
US10996961B2 (en) | 2019-09-27 | 2021-05-04 | Amazon Technologies, Inc. | On-demand indexing of data in input path of object storage service |
US11656892B1 (en) | 2019-09-27 | 2023-05-23 | Amazon Technologies, Inc. | Sequential execution of user-submitted code and native functions |
US11550944B2 (en) | 2019-09-27 | 2023-01-10 | Amazon Technologies, Inc. | Code execution environment customization system for object storage service |
US11263220B2 (en) | 2019-09-27 | 2022-03-01 | Amazon Technologies, Inc. | On-demand execution of object transformation code in output path of object storage service |
US11106477B2 (en) | 2019-09-27 | 2021-08-31 | Amazon Technologies, Inc. | Execution of owner-specified code during input/output path to object storage service |
US11386230B2 (en) | 2019-09-27 | 2022-07-12 | Amazon Technologies, Inc. | On-demand code obfuscation of data in input path of object storage service |
US11416628B2 (en) | 2019-09-27 | 2022-08-16 | Amazon Technologies, Inc. | User-specific data manipulation system for object storage service based on user-submitted code |
US11250007B1 (en) | 2019-09-27 | 2022-02-15 | Amazon Technologies, Inc. | On-demand execution of object combination code in output path of object storage service |
US11055112B2 (en) | 2019-09-27 | 2021-07-06 | Amazon Technologies, Inc. | Inserting executions of owner-specified code into input/output path of object storage service |
US11023416B2 (en) | 2019-09-27 | 2021-06-01 | Amazon Technologies, Inc. | Data access control system for object storage service based on owner-defined code |
US10942795B1 (en) | 2019-11-27 | 2021-03-09 | Amazon Technologies, Inc. | Serverless call distribution to utilize reserved capacity without inhibiting scaling |
US11119826B2 (en) | 2019-11-27 | 2021-09-14 | Amazon Technologies, Inc. | Serverless call distribution to implement spillover while avoiding cold starts |
US11714682B1 (en) | 2020-03-03 | 2023-08-01 | Amazon Technologies, Inc. | Reclaiming computing resources in an on-demand code execution system |
US11188391B1 (en) | 2020-03-11 | 2021-11-30 | Amazon Technologies, Inc. | Allocating resources to on-demand code executions under scarcity conditions |
US11775640B1 (en) | 2020-03-30 | 2023-10-03 | Amazon Technologies, Inc. | Resource utilization-based malicious task detection in an on-demand code execution system |
US11550713B1 (en) | 2020-11-25 | 2023-01-10 | Amazon Technologies, Inc. | Garbage collection in distributed systems using life cycled storage roots |
US11593270B1 (en) | 2020-11-25 | 2023-02-28 | Amazon Technologies, Inc. | Fast distributed caching using erasure coded object parts |
US11388210B1 (en) | 2021-06-30 | 2022-07-12 | Amazon Technologies, Inc. | Streaming analytics using a serverless compute system |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5822749A (en) * | 1994-07-12 | 1998-10-13 | Sybase, Inc. | Database system with methods for improving query performance with cache optimization strategies |
US20040167873A1 (en) * | 2003-02-20 | 2004-08-26 | Intenational Business Machines Corporation | Incremental data query performance feedback model |
US20050028134A1 (en) * | 2003-07-07 | 2005-02-03 | Netezza Corporation | SQL code generation for heterogeneous environment |
US6865567B1 (en) * | 1999-07-30 | 2005-03-08 | Basantkumar John Oommen | Method of generating attribute cardinality maps |
-
2003
- 2003-02-06 US US10/360,397 patent/US7031958B2/en not_active Expired - Lifetime
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5822749A (en) * | 1994-07-12 | 1998-10-13 | Sybase, Inc. | Database system with methods for improving query performance with cache optimization strategies |
US6865567B1 (en) * | 1999-07-30 | 2005-03-08 | Basantkumar John Oommen | Method of generating attribute cardinality maps |
US20040167873A1 (en) * | 2003-02-20 | 2004-08-26 | Intenational Business Machines Corporation | Incremental data query performance feedback model |
US20050028134A1 (en) * | 2003-07-07 | 2005-02-03 | Netezza Corporation | SQL code generation for heterogeneous environment |
Cited By (62)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8983934B2 (en) | 2003-09-06 | 2015-03-17 | Oracle International Corporation | SQL tuning base |
US8825629B2 (en) | 2003-09-06 | 2014-09-02 | Oracle International Corporation | Method for index tuning of a SQL statement, and index merging for a multi-statement SQL workload, using a cost-based relational query optimizer |
US20050125452A1 (en) * | 2003-09-06 | 2005-06-09 | Oracle International Corporation | SQL profile |
US20050138015A1 (en) * | 2003-09-06 | 2005-06-23 | Oracle International Corporation | High load SQL driven statistics collection |
US20050177557A1 (en) * | 2003-09-06 | 2005-08-11 | Oracle International Corporation | Automatic prevention of run-away query execution |
US7739263B2 (en) | 2003-09-06 | 2010-06-15 | Oracle International Corporation | Global hints |
US20050125393A1 (en) * | 2003-09-06 | 2005-06-09 | Oracle International Corporation | SQL tuning sets |
US7664730B2 (en) * | 2003-09-06 | 2010-02-16 | Oracle International Corporation | Method and system for implementing a SQL profile |
US20050097091A1 (en) * | 2003-09-06 | 2005-05-05 | Oracle International Corporation | SQL tuning base |
US7634456B2 (en) | 2003-09-06 | 2009-12-15 | Oracle International Corporation | SQL structure analyzer |
US7664778B2 (en) | 2003-09-06 | 2010-02-16 | Oracle International Corporation | SQL tuning sets |
US7805411B2 (en) | 2003-09-06 | 2010-09-28 | Oracle International Corporation | Auto-tuning SQL statements |
US7747606B2 (en) | 2003-09-06 | 2010-06-29 | Oracle International Corporation | Automatic SQL tuning advisor |
US7467131B1 (en) * | 2003-09-30 | 2008-12-16 | Google Inc. | Method and system for query data caching and optimization in a search engine system |
US20050262046A1 (en) * | 2004-05-05 | 2005-11-24 | International Business Machines Corporation | Method and system for query directives and access plan hints |
US7630958B2 (en) | 2004-05-05 | 2009-12-08 | International Business Machines Corporation | Query directives and access plan hints |
US7685101B2 (en) | 2004-05-05 | 2010-03-23 | International Business Machines Corporation | Query directives and access plan hints |
US20080281780A1 (en) * | 2004-05-05 | 2008-11-13 | International Business Machines Corporation | Query Directives And Access Plan Hints |
US7440935B2 (en) * | 2004-05-05 | 2008-10-21 | International Business Machines Corporation | Method and system for query directives and access plan hints |
US20080281779A1 (en) * | 2004-05-05 | 2008-11-13 | International Business Machines Corporation | Query Directives And Access Plan Hints |
US8161037B2 (en) | 2004-06-03 | 2012-04-17 | International Business Machines Corporation | Method for autonomically generating a query implementation that meets a defined performance specification |
US20080215535A1 (en) * | 2004-06-03 | 2008-09-04 | International Business Machines Corporation | Autonomically generating a query implementation that meets a defined performance specification |
US9135298B2 (en) | 2004-06-03 | 2015-09-15 | International Business Machines Corporation | Autonomically generating a query implementation that meets a defined performance specification |
US20060004695A1 (en) * | 2004-06-03 | 2006-01-05 | International Business Machines Corporation | Apparatus and method for autonomically generating a query implementation that meets a defined performance specification |
US8046354B2 (en) * | 2004-09-30 | 2011-10-25 | International Business Machines Corporation | Method and apparatus for re-evaluating execution strategy for a database query |
US20060074874A1 (en) * | 2004-09-30 | 2006-04-06 | International Business Machines Corporation | Method and apparatus for re-evaluating execution strategy for a database query |
US8161038B2 (en) * | 2004-10-29 | 2012-04-17 | International Business Machines Corporation | Maintain optimal query performance by presenting differences between access plans |
US20060106839A1 (en) * | 2004-10-29 | 2006-05-18 | International Business Machines Corporation | Maintain optimal query performance by presenting differences between access plans |
US20060136368A1 (en) * | 2004-12-22 | 2006-06-22 | Ianywhere Solutions, Inc. | Database System and Methodology for Generalized Order Optimization |
US7359922B2 (en) | 2004-12-22 | 2008-04-15 | Ianywhere Solutions, Inc. | Database system and methodology for generalized order optimization |
US20060149724A1 (en) * | 2005-01-03 | 2006-07-06 | Ritter Gerd M | Methods relating to data repository querying |
US20070078829A1 (en) * | 2005-10-05 | 2007-04-05 | Microsoft Corporation | Safe mode for inverse query evaluations |
US7899817B2 (en) * | 2005-10-05 | 2011-03-01 | Microsoft Corporation | Safe mode for inverse query evaluations |
US20070143246A1 (en) * | 2005-12-15 | 2007-06-21 | International Business Machines Corporation | Method and apparatus for analyzing the effect of different execution parameters on the performance of a database query |
US8838620B2 (en) * | 2006-02-03 | 2014-09-16 | International Business Machines Corporation | Predictive data object retrieval |
US20070185933A1 (en) * | 2006-02-03 | 2007-08-09 | International Business Machines Corporation | Predictive data object retrieval |
US20080172356A1 (en) * | 2007-01-17 | 2008-07-17 | Microsoft Corporation | Progressive parametric query optimization |
US7680779B2 (en) | 2007-01-26 | 2010-03-16 | Sap Ag | Managing queries in a distributed database system |
US20080183671A1 (en) * | 2007-01-26 | 2008-07-31 | Sap Ag | Managing Queries in a Distributed Database System |
US10073893B2 (en) * | 2007-09-20 | 2018-09-11 | Hal Kravcik | Internet and database mining to generate database records |
US20150331915A1 (en) * | 2007-09-20 | 2015-11-19 | Hal Kravcik | Internet and database mining to generate database records |
US9122728B2 (en) | 2007-09-20 | 2015-09-01 | Hal Kravcik | Internet data mining method and system |
US20090216748A1 (en) * | 2007-09-20 | 2009-08-27 | Hal Kravcik | Internet data mining method and system |
US8600966B2 (en) * | 2007-09-20 | 2013-12-03 | Hal Kravcik | Internet data mining method and system |
US9910892B2 (en) | 2008-07-05 | 2018-03-06 | Hewlett Packard Enterprise Development Lp | Managing execution of database queries |
US8429146B2 (en) | 2008-09-04 | 2013-04-23 | Microsoft Corporation | Predicting future queries from log data |
US8112409B2 (en) | 2008-09-04 | 2012-02-07 | Microsoft Corporation | Predicting future queries from log data |
US20110238468A1 (en) * | 2008-09-04 | 2011-09-29 | Microsoft Corporation | Predicting future queries from log data |
US20100057687A1 (en) * | 2008-09-04 | 2010-03-04 | Microsoft Corporation | Predicting future queries from log data |
US7979415B2 (en) | 2008-09-04 | 2011-07-12 | Microsoft Corporation | Predicting future queries from log data |
US20100082507A1 (en) * | 2008-09-30 | 2010-04-01 | Archana Sulochana Ganapathi | Predicting Performance Of Executing A Query In Isolation In A Database |
US20100299337A1 (en) * | 2009-05-19 | 2010-11-25 | Sap Ag | Computer System for Processing a Query |
US9177019B2 (en) * | 2009-05-19 | 2015-11-03 | Sap Se | Computer system for optimizing the processing of a query |
US20100306591A1 (en) * | 2009-06-01 | 2010-12-02 | Murali Mallela Krishna | Method and system for performing testing on a database system |
US8620902B2 (en) | 2011-06-01 | 2013-12-31 | Lexisnexis, A Division Of Reed Elsevier Inc. | Computer program products and methods for query collection optimization |
US9697271B2 (en) * | 2013-03-06 | 2017-07-04 | Tata Consultancy Services Limited | Business intelligence reports with navigable reference indicators |
US20140258210A1 (en) * | 2013-03-06 | 2014-09-11 | Tata Consultancy Services Limited | Business intelligence reports with navigable reference indicators |
US10042888B2 (en) | 2014-11-28 | 2018-08-07 | International Business Machines Corporation | Searching in a database |
US11093501B2 (en) | 2014-11-28 | 2021-08-17 | International Business Machines Corporation | Searching in a database |
WO2017165914A1 (en) * | 2016-03-31 | 2017-10-05 | Wisetech Global Limited | "methods and systems for database optimisation" |
US11321315B2 (en) | 2016-03-31 | 2022-05-03 | Wisetech Global Limited | Methods and systems for database optimization |
US11256694B2 (en) | 2020-04-27 | 2022-02-22 | Hewlett Packard Enterprise Development Lp | Tolerance level-based tuning of query processing |
Also Published As
Publication number | Publication date |
---|---|
US20040158551A1 (en) | 2004-08-12 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US7031958B2 (en) | Patterned based query optimization | |
US7130838B2 (en) | Query optimization via a partitioned environment | |
US8250044B2 (en) | Byte-code representations of actual data to reduce network traffic in database transactions | |
US7117222B2 (en) | Pre-formatted column-level caching to improve client performance | |
US7734615B2 (en) | Performance data for query optimization of database partitions | |
US8775412B2 (en) | Method and system for a self-healing query access plan | |
US8473484B2 (en) | Identifying impact of installing a database patch | |
US7890497B2 (en) | Using estimated cost to schedule an order for refreshing a set of materialized views (MVS) | |
US6360214B1 (en) | Automatic database statistics creation | |
US9135299B2 (en) | System, method, and computer-readable medium for automatic index creation to improve the performance of frequently executed queries in a database system | |
US7698253B2 (en) | Method and system for reducing host variable impact on access path selection | |
US7502775B2 (en) | Providing cost model data for tuning of query cache memory in databases | |
US9734223B2 (en) | Difference determination in a database environment | |
US8478742B2 (en) | Using estimated cost to refresh a set of materialized views (MVS) | |
US10565201B2 (en) | Query processing management in a database management system | |
US7949685B2 (en) | Modeling and implementing complex data access operations based on lower level traditional operations | |
CN109902101B (en) | Transparent partitioning method and device based on spark SQL | |
US20230315727A1 (en) | Cost-based query optimization for untyped fields in database systems | |
US20100036804A1 (en) | Maintained and Reusable I/O Value Caches | |
US20070239656A1 (en) | Removal of Database Query Function Calls | |
US20090171921A1 (en) | Accelerating Queries Based on Exact Knowledge of Specific Rows Satisfying Local Conditions | |
US20220358095A1 (en) | Managing data requests to a data shard |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:SANTOSUOSSO, JOHN M.;REEL/FRAME:013763/0111Effective date: 20030130 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:027005/0673Effective date: 20110930 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 12TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1553)Year of fee payment: 12 |