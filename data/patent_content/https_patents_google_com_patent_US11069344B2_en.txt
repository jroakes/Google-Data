CROSS-REFERENCE TO RELATED APPLICATIONS
This application is a continuation of U.S. patent application Ser. No. 16/251,430, filed on Jan. 18, 2019, which is a continuation-in-part of U.S. patent application Ser. No. 16/171,629, filed on Oct. 26, 2018, which is a continuation of U.S. patent application Ser. No. 15/386,979, filed Dec. 21, 2016. The entirety of the prior applications are incorporated by reference herein.
FIELD
This application relates to speech recognition.
BACKGROUND
Various techniques can be used to recognize speech. Some techniques use an acoustic model that receives acoustic features derived from audio data.
SUMMARY
In some implementations, a speech recognition can use a neural network-based speech recognition model that have a complex-valued nature, and includes linear operators, some of which may be unitary while others may not be unitary. The use of this type of model can improve speech recognition performance while providing advantageous efficiency.
Unitary Evolution Recurrent Neural Networks (uRNNs) have three attractive properties: (a) the unitary property, (b) complex-valued nature, and (c) efficient linear operators. The unitary property, however, may not be required for an effective model. Accordingly, a new model is proposed, the complex evolution Recurrent Neural Network (ceRNN), which is similar to uRNNs but drops the unitary property selectively. On a simple multivariate linear regression task, dropping the constraints improves the learning trajectory. In a copy memory task, ceRNNs and uRNNs perform identically, demonstrating that their superior performance over LSTMs is due to complex-valued nature and their linear operators. In a large scale real-world speech recognition, pre-pending a uRNN degrades the performance of a baseline LSTM acoustic models, while pre-pending a ceRNN improves the performance over the baseline by 0.8% absolute WER.
In a general aspect, a method performed by one or more computers includes: receiving, by the one or more computers, audio data indicating acoustic characteristics of an utterance; generating, by the one or more computers, a first vector sequence comprising audio features determined from the audio data; generating, by the one or more computers, a second vector sequence that a first recurrent neural network outputs in response to receiving the first vector sequence as input, wherein the first recurrent neural network has a transition matrix that implements a cascade of linear operators comprising (i) first linear operators that are complex-valued and unitary, and (ii) one or more second linear operators that are non-unitary; generating, by the one or more computers, an output vector sequence that a second recurrent neural network outputs in response to receiving the second vector sequence as input, wherein the second recurrent neural network comprises one or more layers including long short-term memory cells; determining, by the one or more computers, a transcription for the utterance based on the output vector sequence generated by the second recurrent neural network; and providing, by the one or more computers, the transcription for the utterance.
In some implementations, the one or more second linear operators that are non-unitary are diagonal matrix multiplication operators, and wherein all other linear operators in the cascade are unitary operators.
In some implementations, one or more second linear operators that are non-unitary introduce decay of retained data in memory of the first recurrent neural network.
In some implementations, the cascade of linear operators includes at least one of each of the operators in the set comprising a Fourier transformation, an inverse Fourier transformation, a diagonal matrix multiplication, a column permutation, and a Householder reflection.
In some implementations, the cascade of linear operators comprises a sequence of operators comprising a first diagonal matrix multiplication, a Fourier transform, a first Householder reflection, a column permutation, a second diagonal matrix multiplication, an inverse Fourier transformation, a second Householder reflection, and a third diagonal matrix multiplication.
In some implementations, the cascade of linear operators is limited to operators selected from the set consisting of Fourier transformations, inverse Fourier transformations, diagonal matrix multiplications, column permutations, and Householder reflections; and wherein the one or more second linear operators that are non-unitary are limited to diagonal matrix multiplications.
In some implementations, the audio data comprises audio data for the utterance acquired using two or more microphones, wherein the first vector sequence comprises audio features determined using audio data from the two or more microphones, and wherein the first recurrent neural network is configured to perform beamforming processing.
In some implementations, the first recurrent neural network is configured to perform de-reverberation processing.
In some implementations, the first recurrent neural network is configured to perform noise reduction processing.
In some implementations, receiving the audio data comprises receiving the audio data from a client device over a network; and providing the transcription comprises providing the transcription to a client device over a network.
In some implementations, providing the transcription comprises providing the transcription to a computer system implementing a digital conversational assistant.
In some implementations, the method includes determining an action specified by the transcription, and performing the determined action by the one or more computers or instructing a client device or server system to perform the determined action.
So far, this document has described a recurrent neural network with complex-valued activation function and a complex-valued linear transition matrix constructed by a series of transformation, which is effectively a low rank linear projection. Now, the document will briefly discuss complex-valued linear projection with full rank. One particularly useful application of complex-valued linear projection is to perform computationally efficient convolution.
When performing speech recognition, some systems convolve audio data with multiple filters. Each convolution is a complex and computationally expensive process. To reduce computational demands, a system may convert the audio data to the frequency domain where the equivalent operation to convolution is a simple multiplication, which is much less computationally expensive. Therefore, to apply a filter, a system may convert the audio data to the frequency domain and multiples it by a frequency-domain representation of the filter.
To process the data further, speech recognition systems that have used frequency-domain equivalents for time-domain convolution typically convert the filtered audio data back to the time domain. The conversion is generally needed in order to perform a pooling operation. Many of the preferred pooling techniques for neural network processing, such as max pooling, do not have corresponding functions that are computationally efficient in the frequency domain. As a result, many neural network architectures for speech recognition require conversion of data from the frequency domain to the time domain in order to carry out pooling and perform further processing.
The techniques disclosed herein enable a speech recognition system to significantly improve computational efficiency by performing the equivalent of time-domain convolution and pooling in the frequency-domain. These operations are much more efficient than corresponding time domain operations. Further, unlike prior systems, there is no need to convert data to the time domain after the frequency domain convolution. The neural network layers of an acoustic model can be trained to predict phonetic unit likelihoods based on the frequency domain data rather than time-domain representations.
As discussed further below, the present speech recognition system may use complex linear projection (CLP). Before using CLP to recognize speech, the system generates one or more CLP filters in the frequency domain. A CLP filter may be based on a filter in the time domain, or may be otherwise determined during training of the speech recognition system. The CLP filter is a matrix where the values of the matrix correspond to the filter weights of a time-domain filter.
To use CLP to recognize speech, the audio data is converted to the frequency domain to produce a vector of audio data in the frequency domain. Both the CLP filter matrix and the vector of audio data in the frequency domain include complex numbers. The system multiples the CLP filter matrix by the vector of the audio data in the frequency domain. During the multiplication process, the system pools the data by summing the products of each value in each row of the CLP filter and the values in the frequency domain vector. Because of this pooling function, the equivalent to average weighted pooling can be performed efficiently in the frequency domain. This increases processing efficiency and avoids the need to convert back to the time domain to perform pooling. The system applies additional CLP filters to the vector of audio data in the frequency domain in the same manner, and performs other processing. The output is then provided to a neural network, e.g., one that has been trained as an acoustic model, that provides output used to generate a transcription of the audio data.
According to another innovative aspect of the subject matter described in this application, a method of complex linear projection for acoustic modeling includes the actions of receiving, by one or more computers, audio data corresponding to an utterance; generating, by the one or more computers, frequency domain data using the audio data; processing, by the one or more computers, the frequency domain data using complex linear projection; providing, by the one or more computers, the processed frequency domain data to a neural network trained as an acoustic model; and generating, by the one or more computers, a transcription for the utterance that is determined based at least on output that the neural network provides in response to receiving the processed frequency domain data.
This and other implementations may include one or more of the following optional features. The action of processing the frequency domain data using complex linear projection includes processing the frequency domain data for each input frame of audio data. The actions further include generating a convolutional filter with one or more real filter weights; and generating a frequency domain filter with one or more complex filter weights based on the convolutional filter. The action of processing the frequency domain data using complex linear projection includes applying the frequency domain filter to the audio data. The actions further include receiving an additional input frame of audio data corresponding to the utterance; generating additional frequency domain data using the additional input frame of audio data; applying the frequency domain filter with the one or more complex filter weights to the additional frequency domain data; and providing the filtered additional frequency domain data to the neural network. The action of generating the transcription for the utterance includes generating the transcription for the utterance based further on output that the neural network provides in response to receiving the filtered additional frequency domain data. The convolutional filter or the frequency domain filter are jointly trained using the neural network. The actions further include applying logarithmic compression to the processed frequency domain data before providing the processed frequency domain data to the neural network. The neural network trained as an acoustic model includes one or more long-short term memory layers and multiple hidden layers. The action of processing the frequency domain data using complex linear projection corresponds to weighted average pooling in time domain.
Other embodiments of this aspect include corresponding systems, apparatus, and computer programs recorded on computer storage devices, each configured to perform the operations of the methods.
The techniques disclosed herein may be optionally used to achieve one or more of the following advantages. For example, the computational complexity of a speech recognition process can be reduced while preserving or increasing accuracy. A neural network for speech recognition can be configured to operate using frequency domain data as an alternative to a convolutional neural network. The need to convert frequency domain information to time-domain information for further processing can also be avoided. For example, pooling can be performed in the frequency domain rather than in the time-domain.
The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
BRIEF DESCRIPTION OF THE DRAWINGS
FIG. 1 illustrates an example speech recognition system.
FIG. 1A illustrates an example timestep of a Long Short Term Memory (LSTM) model with Log Mel features.
FIG. 1B illustrates an example timestep of an LSTM model with a Convolutional Neural Network (CNN) transform.
FIG. 1C illustrates example timesteps of an LSTM model with Complex Linear Projection (CLP) transforms.
FIG. 2 illustrates an example speech recognition architecture using complex linear projection.
FIG. 3 illustrates an example system for speech recognition using complex linear projection.
FIG. 4 illustrates an example process for speech recognition using complex linear projection.
FIG. 5 illustrates speech recognition using a complex evolution recurrent neural network (ceRNN).
FIG. 6A is a graph that shows mean squared error (MSE) for various models including a complex evolution model.
FIG. 6B is a graph that shows characteristics of a unitary matrix model as training progresses.
FIG. 7 is a graph showing a projection of components of various models.
FIG. 8 is a graph showing a comparison of cross-entropy loss for various models.
FIGS. 9A and 9B are graphs that show performance of a long short-term memory (LSTM) model and a model including a complex evolution RNN and a LSTM.
FIG. 10 illustrates an example of a computing device and a mobile computing device.
In the drawings, like reference numbers represent corresponding parts throughout.
DETAILED DESCRIPTION
FIG. 1 illustrates an example speech recognition system 100. Briefly, and as described in more detail below, a user 105 speaks an utterance 110. A computing device 115 receives the utterance 110 and performs speech recognition on the utterance 110. The computing device 115 displays the transcription 120 of the utterance on a display of the computing device 115.
As illustrated in the example shown in FIG. 1, the user 105 speaks the utterance 110 “Text Mom I'll be home soon” in the presence of the computing device 115. The user may have opened a messaging application on the computing device 115. Alternatively, the computing device 115 may be in a mode where the computing device 115 can receive and process detected speech such as voice commands. This mode may be activated by selecting a particular button on the computing device 115 or by the user 105 speaking a particular activation keyword or hotword.
The computing device 115 detects the utterance 110 through a microphone 125. The microphone 125 may be part of an audio subsystem 130 that receives and processes incoming audio data. The microphone 125 may provide analog data to the audio subsystem 130. The audio subsystem 130 may process the audio data by performing one or more of the following: converting the analog data to digital audio data, filtering the audio data, sample the audio data, compress the audio data, and any other similar audio processing techniques. The computing device 115 may be any type of computing device that is configured to detect and process sound such a mobile phone, tablet device, wearable device, desktop computer, smart speaker, laptop computer, smart appliance, or any other similar device.
As part of the speech recognition process, the audio subsystem 130 provides the processed audio data to the feature extractor 135. The feature extractor 135 derives descriptive features of the audio data from the processed audio data. The feature extractor 135 may reduce the dimensionality of the processed audio data and produces a characteristic feature vector with a lower dimensionality than the processed audio data received form the audio subsystem 130. The feature extractor 135 may analyze the processed audio data to suppress the characteristics of the ambient environment, such as background noise, and any characteristics added by the microphone 125 or the audio subsystem 130.
The feature extractor 135 provides the feature vectors to one or more speech recognition models 140. As discussed below, one type of speech recognition model that may be used employs complex linear projection (CLP) techniques to efficiently process frequency-domain representations of audio data. FIGS. 1A to 4 relate to this type of model. Another type of speech recognition model that may be used is a complex evolution recurrent neural network (ceRNN), alone or in combination with long short-term memory (LSTM) layers or other neural network layers. FIGS. 5 to 9B relate to this type of model. Both of these types of models can provide speech recognition with improved accuracy and with reduced computational requirements than traditional speech recognition models. These properties make the models advantageous for speech recognition on mobile devices, which typically have limited amounts of battery power available and have limited processing capabilities compared to other computers. Of course, the same improvements and efficiencies of the models 140 make them advantageous for use in server-based speech recognition and speech recognition by other systems as well.
In some implementations, the speech recognition models may include an acoustic model or encoder, as well as a language model or decoder. The acoustic model or encoder may be used to identify the most likely phonemes of the utterance 110, or to generate an encoded representation of the acoustic properties. The language model or decoder can be used to identify the most likely word sequences of the utterance 110. The output of the language model or decoder may indicate a set of probabilities for different characters, word pieces, or whole words. A transcription may be created from those outputs.
With a transcription 120 of the utterance 110 identified, the computing device 115 may display and/or process the transcription 120. For example, the computing device 115 may parse the transcription 120 to identify a command and related words such as parameters. The command may be to text mom and the parameters may be message content, such as “I'll be home soon.”
In some implementations, the speech recognition processing of the computing device 115 may be performed on a different computing device. For example, the computing device 115 may detect and record the utterance 110 using the microphone 125 and process the audio data using the audio subsystem 130. The computing device may then transmit the audio data to server over a network. The server processes the audio data received from the computing device in a similar fashion to the feature extractor 135 and speech recognition model(s) 140. The server generates a transcription of the audio data and transmits, over the network, the transcription 120 back to the computing device 115 for further processing and/or displaying on the display of the computing device 115.
Various speech recognition techniques discussed below can be used as alternatives to typical convolutional layers of neural networks. In some situations, convolutions may prove to be prohibitively expensive, especially when large filter kernels are applied. This application addresses the computational bottleneck imposed by convolutions in the context of CNNs by utilizing a linear transform with complex weights. The Fourier transform is a means to represent a real valued vector in a complex form without losing information. Such an isomorphism provides an efficient way to perform a convolution using element-wise multiplication, and eliminates the need for parameter tuning of the convolution filter size. Furthermore, such a representation allows for analogous pooling operations typically used in CNNs without leaving the complex domain. This application will describe that the CLP is equivalent to a convolution followed by weighted average pooling. This allows for typical layers of a CNN to be computed in linear time. The CLP transform was compared with the CNN model in three audio recognition tasks and shown to achieve competitive performance while significantly reducing the total number of parameters and computations.
Convolutional neural networks (CNNs) pose a quality-time tradeoff in which high performance may be compromised in the interest of running time and choice of parameters. In the absence of a systematic approach for choosing optimal convolution filter support size, this value is may be large enough to capture fine temporal information of the input signal, which inherently increases the total number of computations. The convolution theorem between circular convolution in the time domain and element-wise multiplication in the frequency domain has been used to speed up CNNs. The system described below computes discrete a Fourier transform (DFT) of the input and convolutional filters, and then approximates the convolutional activations by the element-wise multiplication of the DFT of the input and filter weights. Finally, the system computes the inverse Fourier transform to apply pooling in time domain. For an input window size of n, this reduces the total number of computations from n2 using direct approach to 2n log (n)+n. In some implementations, the system may reduce the CNN computational complexity to n log(n)+n by learning filters directly in the frequency domain.
A linear transform with complex weights can serve as an alternative representation of convolutional neural networks with real weights. Because there is a one-to-one mapping between complex weight vectors and convolutional filter weights, this representation eliminates the need for finding the optimum convolution filter support size. Furthermore, this representation allows learning filter weights and pooling both in the same space which reduces the number of computations to order n per convolution filter. As discussed below, complex linear projection compares favorably with CNNs in the challenging task of joint feature extraction for speech recognition, speaker verification, and music genre recognition.
Complex linear projection can be an effective alternative for convolution. A convolutional layer convolves input x with a filter wi parameterized by filter support size a and stride si, to output yi=x*wi. For audio applications, the support size of wi may be on par with the input size, di≈n, to capture long temporal dependency structures in the time signal. For a CNN layer of p nodes, this makes the number of additions and multiplications needed for convolution filters pn2. In some implementations, convolution may require tuning the support size. The description below regarding selecting parameters demonstrates the effect of support size on the performance of convolutional-based models. In some implementations, a convolutional layer is followed by a pooling layer to further compress and remove the redundant information.
To reduce the complexity of the convolution operation, the above process is typically sped up in the frequency domain by taking the Fourier transform of input and convolution weights, doing element-wise multiplication and finally applying the inverse Fourier transform to do pooling. Going back and forth between the input and output spaces (also called time and frequency space, respectively) can be avoided by performing all operations in the complex space. The system performs the operations in the complex space by first representing the real valued convolution filter weights with an equivalent representation in the complex space, and then applying the analogous operation to convolution, followed by the analogous pooling operation. The description of these steps is below.
The use of complex linear projection takes advantage of isomorphism between the real space and complex space. Consider a transform fn:Rn→Cn/2+1 that for a given n defines an isomorphism between n dimensional vectors in real space and the 1+n/2 dimensional vectors in the complex space. The discrete Fourier transform can be leveraged to construct such fn. For a real valued input, the Fourier transform has a Hermitian symmetric complex output. Given x is an element of Rn, fn(x) is defined to be the lower half of the Fourier transform, F(x). In this case, fn is linear and invertible. For an input x and convolutional filter wi, n may be the size of x and define X=fn(x) and Wi=fn(wi). Although wi has only d<n non-zero values, to apply fn, wi is treated to be in Rn by zero padding.
The convolution theorem states the duality between circular convolution {circle around (*)} and element-wise multiplication ⊙ under the Fourier transform. The map fn above also preserves this duality. More precisely, for a convolutional filter wi and input x, fn(wi{circle around (*)}x)=fn(wi)⊙fn(x). Thus, element-wise multiplication in the complex space can be used for the equivalent of convolution in the real space.
Frequency pooling is advantageous in many speech recognition systems. In some implementations, the system may use deterministic functions such as max, average, or Ip pooling to aggregate the multi-dimensional convolution outputs into a scalar. When the convolution has been optimized by applying the Fourier transform, applying pooling may require returning to the input space through an inverse Fourier transform. In some implementations, returning to the input space through an inverse Fourier transform may not be necessary, however. Parseval's theorem, demonstrates the equivalence of I2 pooling in time and frequency space: I2 2(x)=I2 2(F(x)). For operations such as max or Ip>2 norm, the system may compute the inverse Fourier transform to apply pooling over the convolution output. As will be described below, the system uses summation in the frequency domain for pooling. Denoting yi to be the convolution output, the proposed summation pooling in frequency is formulated as Σj=0 n/2fn(yi)[j]=Σj=0 n/2fn(wi{circle around (*)}x)[j]=Σj=) n/2fn((wi)⊙fn(x)) [j]. This operation has the advantage that the final model with p convolution filters can be expressed as a projection of X into a lower dimensional space, through a matrix vector multiplication which can illustrate the goal of feature extraction, projection.
For real input x is an element of Rn, the complex linear projection (CLP) transform is defined as:
Each element i of Y can be written as:
where Wi is the i′th row of W and wi is the equivalent representation of Wi in real space. Since fn is an isomorphism, such representation exists. The inner argument of the summation in equation 2 is equivalent to a convolution in the input domain of fn and the summation can be interpreted as pooling in that space.
The following section discusses the equivalence of complex linear projection in real space. Lemma 1. Summation in the frequency domain is equivalent to weighted average pooling in the time domain. More precisely, for any v that is an element of Rn
This may be proven by the geometric sum.
Proposition 1. The projection in the frequency domain is equivalent to a convolution layer of size p followed by a weighted average pooling with the weights given in equation 4:
where x=fn −1(X) and wi=fn −1(Wi) are equivalent representations of X and Wi in the input domain of fn, and p is the projection size.
which is directly concluded by the application of Lemma 1 and the duality theorem.
Referring to FIGS. 1A-1C, three different feature extraction techniques are represented. In FIG. 1A, some automatic speech recognition (ASR) and music recognition systems may use manually defined features like log Mel.
In FIG. 1B, an alternative feature extraction technique is represented. Instead of using predetermined features like log Mel features, a speech recognition system may use deep neural networks in data-driven techniques which jointly estimate features combined with the recognition process. In these implementations, the first few layers of the network are designed to learn the features directly from a raw waveform. The architecture may include a convolutional layer followed by a pooling layer. The success of the resulting model may depend on the choice of convolutional and pooling layer parameters. In some implementations, the acoustic modeling (AM) task may use a raw waveform model. In this model, the Log Mel feature extraction block of FIG. 1A is replaced by CNN transform across the timesteps of the Long Short Term Memory (LSTM) cells. FIG. 1B illustrates the CNN model in which the CNN transform includes a convolution layer followed by a ReLu, a max pooling layer, and finally a logarithmic nonlinearity.
FIG. 1C illustrates CLP transforms that are integrated into the timesteps of a LSTM model. Since the rest of the network parameters are real, the magnitude of the CLP activations Y=WX is taken and passed to the logarithmic compression. The transform weights W=WR+jWI are shared across timesteps and learned by backpropagation of the gradients from a unique recognition loss.
The complex layer is implemented using four linear matrix vector multiplications. More precisely |Y| is calculated as:
|
Y|=[
{
Y} 2 +ℑ{Y} 2]
1/2 , {Y}=W R X R −W I X I , {Y}=W R X I +W I X R (7)
As discussed below, the CLP model provides a number of advantages over the log Mel model and the CNN model. For any of the three models, the input audio for these three models can be segmented, e.g., with the window size of 512 samples, xt is an element of R512, and frame shift of 160 samples. The 512 point FFT was computed to derive Xt. For comparisons of the models, the feature dimension input to LSTM cell per timestep is set to have the same size for all three models. For this, the number of filters in the Log Mel model, number of nodes in the CNN layer and number of rows of the complex projection matrix are set to 128. Additional details regarding the models and datasets used for comparison is discussed below.
FIG. 2 illustrates an example speech recognition system 200 using complex linear projection. Briefly, and as described in more detail below, the system 200 receives audio data 203 that may be received from a microphone detecting speech and an audio subsystem processing the detected speech. The system 200 processes the audio data 203 through a frequency domain converter 205, a complex linear projection module 210, a post processor 245, and an acoustic model 215 to generate an output 260 that corresponds to the phonemes of the audio data 203.
To process the audio data 203, the system processes individual frames of the audio data 203 as the system receives the audio data. Each input frame may correspond to a few milliseconds (e.g., 10 ms, 25 ms, or 50 ms, etc.) of audio data processed by an audio subsystem, for example, the audio subsystem 130 of FIG. 1. Each input frame of audio may be represented by a vector with a dimension of n. The system initially processes the input frame by converting the input frame to the frequency domain using the frequency domain converter 205. The frequency domain converter 205 converts the input frame of audio to the frequency domain by applying a Fourier transform, e.g., a fast Fourier transform (FFT). The output of the frequency domain converter 205 is the frequency domain data 208 that is a vector that includes both real and imaginary components.
The complex linear projection module 210 receives the frequency domain data 208. The system also accesses filter weights 239 that specify the parameters for a filter used by the complex linear projection module 210. Generally, the filter weights 239 have been previously determined during the process of training the acoustic model. In some implementations, the filter weights 239 describe multiple different filters, for example, different filters can be learned for different frequency ranges. The complex linear projection module 210 applies each frequency domain filter to each frequency domain vector 208 received from the frequency domain converter 205. In some implementations, the frequency domain filter is a matrix where each of the values in the matrix corresponds to a filter weight that includes both real and imaginary components. The complex linear projection module 210 multiples the frequency domain filter matrix by the frequency domain data 208, which is a vector. The resulting vector is the complex linear projection vector of the frequency domain data 208. The complex linear projection vector includes both a real component and an imaginary component. Each row of the filter matrix represents a filter. As an example, the filter matrix is three rows by four columns where three filters each filter four frequency components. The element located in the third row and the second column (w32) specifies how the frequency bin of the second column is weighted by the filter of the third row.
By multiplying the frequency domain filter by the frequency domain data 208, each value in the complex linear projection vector corresponds to the sum of a corresponding row of filter weights times each corresponding value in the frequency domain data 208. For example, to calculate the first value in the complex linear projection vector, the complex linear projection module 210 calculates the product of the filter weight in the first column and first row of the frequency domain filter and the first value in the frequency domain data 208. The complex linear projection stage 210 calculates the product of the filter weight in the second column and first row of the frequency domain filter and the second value in the frequency domain data 208. The complex linear projection stage 210 continues calculating the products of each filter weight and frequency domain data pair for the first row of the frequency domain filter. The complex linear projection module 210 sums the resulting products to calculate the first value in the complex linear projection vector. By summing the resulting products, the complex linear projection module 210 is performing a pooling operation in the frequency domain that is equivalent to weighted average pooling in the time domain. The complex linear projection module 210 operate entirely in the frequency domain and do not have to convert back to the time domain to perform a pooling operation. In other words, the complex linear projection module 210 performs a matrix vector multiplication where both matrix and vector values are complex values. Therefor a particular element of the product vector is based on a summation of the element-wise multiplication of a row of the matrix and the vector.
The system 200 provides the output of the complex linear projection module 210 to the post processor 245. In some implementations, the post processor 245 reduces the dimensionality of the vector received from the complex linear projection module 210. Reducing the dimensionality reduces the need for subsequent LSTM layers. In some implementations, the post processor performs logarithmic compression on the vector received from the complex linear projection module 210. To perform logarithmic compression, the post processor 245 computes the absolute value of each value in the vector received from the complex linear projection module 210. The absolute value corresponds to the square root of the sum of (i) the square of the real part and (ii) the square of the imaginary part. In other words, the absolute value corresponds to the distance that the value in the vector received from the complex linear projection module 210 is from the origin in the complex plane. The post processor 245 then computes the logarithm of the absolute value. The result is a vector with only real values.
The output vector of the post processor 245 is passed to LSTM layers 248, 251, and 254, which are appropriate to modeling the signal with respect to frequency. In some implementations, the system 200 trains the LSTM layers 248, 251, and 254 using frequency domain data instead of time data. In some implementations, three LSTM layers may be used to model the signal. In some implementations, each LSTM layer may include 832 cells and a 512 unit projection layer for dimensionality reduction. In some implementations, greater than three LSTM layers, including fewer cells, may alternatively be used. The output of the LSTM layers 248, 251, and 254 is provided to one or more deep neural network (DNN) layers 257.
The layers that are included in one or more DNN layers 257 may be fully-connected and, in some implementations, may each have 1,024 hidden units. The other layers of the system 200 may be trained jointly with the acoustic model 215. During training, the acoustic model 215 may be unrolled for training with truncated backpropagation through time (BPTT). In some implementations, the output state label may be delayed by one or more frames, as information about future frames may enhance the accuracy of predictions associated with a current frame.
In some implementations, the Mel filter banks are set of narrow band filters equally spaced in the Mel frequency scale. Both the CNN and CLP model are able to learn such a non-linear scale with set of narrow band filters. In some implementations, the CLP filters are more concentrated around the non-linear curve compare to the CNN alternative. The CLP model may be configured for multi-channel use. By concatenating the Xt vectors of multiple channels, the CLP model is able to configure the optimal linear combination of channel information.
Time representation of convolution filters may require proper choice of filter support size. For time-varying signals like sound, this parameter may have a role in the performance of recognition model. In some implementations, sweeping the filter support size affects the speech recognition performance. In some implementations, the minimum word error rate (WER) may be achieved when the filter support size is chosen to be at least 80% of the window size. Applying the convolution as an element-wise multiplication in the complex domain removes the necessity of choosing a support size, reducing the network's hyperparameter space. This is due to the fact that the model learns the weights within 1+n/2 complex weights per filter without any constraint on how the time representation should be.
The longer a convolutional filter support size, the greater the computational cost. An implementation of p filters in the time domain with kernel size of d and stride of one for an n-point signal and full convolution requires 2pd×(n+d+1)≈2pn2 operations. With an FFT speed up, this decreases to p(2n log(n)+n); one FFT and one inverse FFT computation per filter plus element-wise multiplication in the frequency domain. For the CLP model, this reduces to 8pn operations; four matrix vector multiplications. This reduction in the number of operations is due to the direct representation of the filters in the complex domain and the proposed frequency pooling which eliminates the need to compute an extra FFT and inverse FFT. This reduction leads to a factor of kernel size difference between run-time of the same operation in the time and frequency domains. The first two columns of Table 1 compares the total number of parameters as well as addition and multiplication operations in the CNN and CLP transform. The baseline CLP transform with a full matrix reduces the number of computations by a factor of 55, but has slightly more parameters.
TABLE 1 |
|
Computation efficiency. |
|
Model |
Raw |
baseline |
constrained |
|
|
|
# params |
45K |
66K |
5.12K |
|
# add-mult |
14.51M |
263.17K |
40.96K |
|
|
The comparison of time and frequency representation of the filters is also appealing from a sparsity perspective. The Gabor limit states the dual of band limited frequency filters are wide band in the time domain and vice versa. For some auditory filters, these frequency filters are narrow band in the frequency domain. So, the time representation is expected to have more nonzero entries compared to the counterpart frequency representation. In other words, the frequency representation of the filters tend to be sparser compared to their representation in the time domain. The tendency of filters to be sparser in the frequency representation with CLP transform greatly facilitates optimization, reduces 170 the total number of parameters and speeds up run time due to fewer computational operations.
The Lorenz curve may be used to compare the sparsity of the CNN and CLP models. For a sorted n dimensional vector v and index i, 0≤i≤n, the Lorenz curve is defined within the support interval of (0, 1) by
This curve may be used for sparsity measure in various signal processing tasks. The representation v1 may be sparser than an alternative representation v2, if the Lorenz curve Lv1 is under the curve Lv2. While both w and F(w) encodes the same information, the Fourier representation is relatively sparser that its time domain counterpart. Furthermore, learning the weights directly in the complex space leads to much sparser representation.
Various extensions of the CLP model can be made. One example is a regularized CLP technique. Due to the sparse nature of filters in the frequency domain it may be beneficial to inject more sparsity into the CLP model. The l1 norm provides a computationally a possible form of regularization. The CLP model trained with l1 regularization converges to significantly sparser model compare to the non-regularized CLP model. The same effect may be obtained by learning only a subset of weights in the CLP matrix. In other words, introduce hard zeros by constraining a subset of weights to zero. As the third column of Table 1 shows, the hard zero method may reduce the total number of parameters and computations.
Direct learning of the isomorphism fn. In the description above, fn was constructed to map the real valued input x into the complex domain to apply the subsequent CLP transform. fn was constructed based on the Fourier transform, so it is linear and thus can be integrated to the CLP matrix and learned jointly as part of the network training, so Y=Wfn(x)=W′x. After training by randomly initializing W′, the network learned a representation with similar properties to the Fourier transform. Similar to the Fourier transform, each row of W′ looks like a bandpass filter with a different center frequency. In addition, there appears to be a phase difference between the real and imaginary components of each row. In the case of the Fourier transform, this phase difference corresponds to π/2, the phase difference between the sin and cosine functions. In some implementations, the phase differences for all rows in W′ is concentrated around π/2. Furthermore, the rows of W′ make a nearly orthogonal basis. The curve shows that more than 90% of the pairs of distinct rows of W′ have a normalized dot product less than 0.02. This property may also be observed for the Fourier transform, where the matrix is fully orthogonal.
The CLP transform is embedded into the timesteps of a LSTM to jointly optimize the filter bank and recognition parameters for three audio recognition tasks: speech, speaker, and music recognition. The experiments are designed to evaluate CLP in three aspects, (1) effectiveness of CLP to achieve state-of-the-art performance using Log Mel and CNN models, (2) benefits of learning language dependent features to avoid feature engineering, and (3) benefits of joint training of features and recognition model for non-speech recognition tasks like speaker and music recognition.
Various speech recognition experiments discussed below used three datasets: (1) spontaneous speech, anonymized and human transcribed voice search data that included multichannel American English (en_us), consisting of 2,000 hours recorded from 8-channel linear microphone array; (2) Taiwanese Mandarin (cmn_hant_tw) speech consisting of more than 30,000 utterances that were transcribed; and (3) High Pitch (HP) speech, with 3,000 hours of audio, 40% of which are children's speech and 60% are adult speech. The test sets for each language are separately human-transcribed voice search data of about 25 hours. The speaker verification task was evaluated on a set of text dependent prompts such as “Ok computer” utterances collected from voice search logs in two languages, ko_kr (2 million utterances) and ja_jp (12 million utterances). Finally, the music recognition task was evaluated on dataset consisting of 25,000 songs of length 29 second each annotated with 188 tags. The training set includes 14,000 songs while the test set contains the rest.
A recognition model using Log Mel features was utilized to compare CNN and CLP transforms. The model consists of 3 LSTM layers followed by a ReLu and a Linear layer. The CNN and CLP models were embedded to timesteps of LSTM as in FIGS. 1A and 1B replacing the Log Mel feature extraction block in FIG. 1C. The number of CNN layer nodes and the projection size in the CLP model weight matrix may be equal to the Log Mel feature dimension per timestep. Each timestep is 32 msec long which consists of 512 samples. The timesteps have 22 msec overlap. The convolution filter support size may be 352, the minimal size for the lowest WER. The CNN and CLP weights are trained jointly with the recognition loss which is cross entropy for the speech and music tasks and logistic regression loss using a model for the speaker verification task. All models may be trained using asynchronous SGD training with 200 multi-core machines.
Four variants of the CLP model with summation and l2 pooling are compared in terms of WER in Table 2. The summation pooling outperforms the l2 pooling. Both sparsity injection approaches boost CLP performance by about 2% relative. In some implementations, the l1 regularization requires less parameter tuning.
TABLE 2 |
|
Word Error Rate (WER) for variants of the CLP models |
on en_us dataset. |
|
|
|
|
HARD |
|
|
MODEL |
|
1 REG. |
ZEROS |
2 POOLING |
|
|
|
32 MSEC |
23.2 |
22.8 |
22.9 |
23.8 |
|
|
The first two columns of Table 3 present the WER performance of Log Mel, CNN and CLP models on the en_us task for single and two channel models. For the first three rows, the feature dimension per timestep is set to 128 per channel. While the CNN model may lag behind the Log Mel performance for single channel, the CLP model WER is on par with the Log Mel model. In the two 254 channel case, the CLP model may outperform both Log Mel and CNN which can be explained by the fact that CLP model integrates speech phase information because of the complex weight representation. Furthermore, increasing the number of filters by a factor of 10 may benefit the CLP model by an additional 2-4% relative improvements over the Log Mel model. Increasing filterbank size may not be possible for the Log Mel model with the same size FFT since there is a possibility to have one or no FFT point per filter. In some implementations, increasing number of filters for the CNN model may not be feasible due to the computational cost.
TABLE 3 |
|
WER for the speech recognition tasks across different |
models and languages. |
|
1 CHANNEL |
2 CHANNEL |
PITCH |
CMN_HANT |
|
LOG MEL |
22.8 |
21.3 |
16.6 |
17.2 |
CNN |
23.4 |
21.2 |
16.3 |
16.8 |
CLP |
22.8 |
20.9 |
16.4 |
16.6 |
CLP (10 × p) |
22.2 |
20.2 |
— |
— |
|
For the languages which use tone to distinguish lexical or grammatical meaning, speech recognition may involve extensive feature engineering. The tonal features like pitch are appended to the Log Mel features to leverage the inefficiency of this representation for containing such information. Joint training of filterbank parameters allows the model to directly extract necessary information from the signal which avoids feature engineering. The last two columns of Table 3 illustrate this property for two tonal tasks, high pitch and Taiwanese mandarin datasets. Both CNN and CLP models may improve the Log Mel model in both tasks. In some implementations, they offer around 12% relative improvement over the Log Mel model for mandarin task. The pitch algorithms have a large number of hyper-parameters and are difficult to tune. This may be eliminated using a joint feature extraction approach like CNN or CLP.
While Log Mel features may have been parameterized for WER minimization, they may also be used for different audio tasks like speaker verification and music recognition. Table 4 illustrates the effectiveness of CLP as feature extractor for these two tasks. For Japanese speaker verification task, the CLP transform may have a 30% relative improvement over Log Mel model. The gap between the baseline Log Mel and the CLP may be smaller for Korean speaker verification and music genre recognition tasks. This might be due to smaller training set size for these two tasks compared to the Japanese task. The CLP matrix learned for these tasks are different from the one learned for the speech recognition task.
TABLE 4 |
|
Recognition accuracy (the higher, the better) for end |
to end speaker verification and music recognition. |
|
SPEAKER VERIFICATION |
MUSIC |
MODEL |
KO_KR |
JA_JP |
RECOGNITION |
|
LOG MEL |
96.4 |
94.48 |
83.52 |
CLP |
96.3 |
96.11 |
84.54 |
|
FIG. 3 is a block diagram that illustrates an example system 300 for speech recognition using neural networks. The system 300 includes a client device 310, a computing system 320, and a network 330. In the example, the computing system 320 provides information about an utterance to the filter module 325. The filter module 325 performs processing, such as feature extraction using a learned filter and pooling, in the frequency domain. The output of the filter module 325 is provided to the neural network 327, which can represent an acoustic model or other speech recognition model. The computing system 320 uses output from the neural network 327 to identify a transcription for the utterance.
In the system 300, the client device 310 can be, for example, a desktop computer, laptop computer, a tablet computer, a wearable computer, a cellular phone, a smart phone, a music player, an e-book reader, a navigation system, or any other appropriate computing device. The functions performed by the computing system 320 can be performed by individual computer systems or can be distributed across multiple computer systems. The network 330 can be wired or wireless or a combination of both and can include the Internet.
In the illustrated example, a user 302 of the client device 310 speaks, and the client device 310 records audio that includes the speech. The client device 310 transmits the recorded audio signal 312 to the computing system 320 over the network 330.
The computing system 320 receives the audio signal 312 and obtains audio waveform samples 321. For example, the computing system 320 may identify a set of audio waveform samples 321 that represent a time window of audio signal 312. These audio waveform samples may be similar to input frames that have been described above in reference to FIG. 2.
The computing system 320 may provide audio waveform samples 321 to a filter module 325. The filter module 325 may include features such as the frequency domain converter 205, complex linear projection module 210, and post processor 245 of FIG. 2. As such, the filter module 325 may generate feature vectors that each represent frequency domain data with one of the filters being applied during the complex linear projection stage for each audio input frame.
During the training of the neural network, the computing system 320 learns a mapping between a window of a signal x into a label class y. In some implementations, the computing system 320 extracts some features from the signal x using a feature extraction method, f. This extraction may be independent of the neural network training and map each signal x to f(x) through the method f. The parameters of the feature extraction method f may be fixed and independent of any training data.
The computing system 320 uses a matrix vector multiplication where parameters of the feature extraction method f may be jointly trained with the neural network. By converting the signal x to the frequency domain and using a filter matrix that is related, for example, by the Fourier transform, to f(x), the elements of the filter matrix are trained jointly with the rest of the neural network because the feature extraction method f may be jointly trained with the neural network. In this instance, computing system 320 performs the equivalent of convolution followed by average pooling in the time domain.
The computing system 320 provides output of the filter module 325 to the neural network 327. The neural network 327 has been trained to act as an acoustic model. For example, the neural network 327 indicates likelihoods that frequency feature representations correspond to different speech units when the frequency feature representations are output by filter module 325 and based on audio waveform samples 321. The neural network 327 may, for instance, correspond to the acoustic model stage 215, as described in association with FIG. 2 above.
The neural network 327 produces neural network outputs 329, which the computing system 320 uses to identify a transcription 330 for the audio signal 312. The neural network outputs 327 indicates likelihoods that the speech in a particular window, for example, w1 corresponding an acoustic feature vector v1, within the audio waveform samples 322 corresponds to specific phonetic units. In some implementations, the phonetic units used are phones or components of phones, also referred to a phonemes. In this example, the potential phones are referred to as s0 . . . sm. The phones may be any of the various phones in speech, such as an “ah” phone, an “ae” phone, a “zh” phone, and so on. The phones s0 . . . sm may include all of the possible phones that may occur in the audio waveform samples 321, or fewer than all of the phones that may occur. Each phone can be divided into three acoustic states.
The neural network outputs 327 can provide predictions or probabilities of acoustic states given the data included in the audio waveform samples 822. The neural network outputs 329 can provide a value, for each state of each phone, which indicates the probability that acoustic feature vector v1 represents the particular state of the particular phone. For example, for a first phone, s0, the neural network outputs 829 can provide a first value that indicates a probability P(s0_1|X), which indicates a probability that the window w1 includes the first acoustic state of the so phone, given the set of input X, provided at the audio waveform samples 321. For a first phone, s1, neural network outputs 329 can provide a second value indicating a probability P(s0_2|X), indicating a probability that the window w1 includes the second acoustic state of the so phone, given the set of input, X, provided at the audio waveform samples 321. Similar outputs can be provided for all states of all of the phones s0 . . . sm.
The computing system 320 provides different sets of acoustic feature vectors to the neural network 327 to receive predictions or probabilities of the acoustic states in different windows of the utterance. The computing system 320 may provide the neural network outputs 329 to, for example, weighted finite state transducers that approximate a hidden Markov model (HMM), which may include information about a lexicon indicating the phonetic units of words, a grammar, and a language model that indicates likely sequences of words. The output of the HMM can be a word lattice from which the transcription 330 may be derived. The computing system 320 then provides the transcription 330 to the client device 310 over the network 330.
During training, forward propagation through the neural network 327 produces outputs at an output layer of the neural network. As part of training, the outputs may be compared with data indicating correct or desired outputs that indicate that the received frequency feature representation corresponds to a known acoustic state. A measure of error between the actual outputs of the neural network and the correct or desired outputs is determined. The error is then back-propagated through the neural network to update the weights within the neural network 327. The parameters of the filters used by the filter module 325 can also be learned jointly as the neural network 327 is updated. This training process may be repeated for audio waveform samples of multiple different utterances in a set of training data. During training, the frames selected for training can be selected randomly from a large set, so that frames from the same utterance are not processed consecutively.
FIG. 4 illustrates an example process 400 for neural network adaptive beamforming for multichannel speech recognition. In general, the process 400 receives an utterance and identifies, using a neural network, likely phonemes that correspond to the words of the utterance. The process 400 will be described as being performed by a computer system comprising one or more computers, for example, system 115 as shown in FIG. 1, system 200 as shown in FIG. 2, or system 300 as shown in FIG. 3.
The system receives audio data corresponding to an utterance (410). For example, the system may detect speech spoken by a user near the system. As another example, the system may detect music playing near the system and use the process 400 for music recognition. Instead of audio data, the system may apply the process 400 to image data for image recognition.
The system generates frequency domain data using the audio data (420). In some implementations, the system processes an input frame of the audio data as it receives the audio data. An input frame may correspond to a few milliseconds of audio data. To generate frequency domain data, the system applies the Fourier transform to the input frame. The result is a vector of frequency domain data that represents the frequency components of the corresponding input frame.
The system processes the frequency domain data using complex linear projection (430). In some implementations, the system generates a convolutional filter using one or more real filter weights and then generates a frequency domain filter using the real filter weights. The resulting frequency domain filter is a matrix where the values of the matrix correspond to the filter weights. The system applies the frequency domain filter to the frequency domain data. To process the frequency domain data using complex linear projection, the system multiples the frequency domain filter by the vector of frequency domain data. In some implementations, the system generates additional filters and applies each filter to the vector of frequency domain data. For subsequent input frame, the system converts the input frame to the frequency domain and applies the frequency domain filters. In some implementations, complex linear projection corresponds to weighted average pooling in time domain. The system performs frequency pooling on the frequency domain data by summing the values to obtain each value in the processed vector. The summing operation may be inherent in the multiplication of the filter matrix and the frequency domain vector.
The system combines the processed frequency domain data (440). In some implementations, the system applies logarithmic compression to the vector of frequency domain data after processing the data using complex linear projection. To apply logarithmic compression, the system calculates the absolute value of each of the complex values in the vector of frequency domain data after processing the data using complex linear projection. The system then computes the logarithm of each absolute value before providing the data to the neural network.
The system provides the combined frequency domain data to a neural network trained as an acoustic model (450). In some implementations, the neural network trained as an acoustic model comprises one or more long-short term memory layers and multiple hidden layers. In some implementations, the neural network is trained using data in the frequency domain. The system generates a transcription for the utterance that is determined based at least on output that the neural network provides in response to receiving the combined frequency domain data (460). In instances where the system processed music, the system may identify the song. In instances where the system processed an image, the system may identify the image.
This application describes the properties of a complex linear projection as an alternative of convolution plus pooling in the real domain. Using the chain of equivalent operations in complex domain, complex linear projection may be equivalent to convolution followed by weighted average pooling. This model was compared with CNN with real value weights and max pooling in the task of joint feature extraction for audio recognition. In some implementations, the CLP model achieves competitive performance on variety of state-of-the-art recognition systems while reducing the total number of computations.
FIG. 5 illustrates speech recognition using a complex evolution recurrent neural network (ceRNN). The figure shows a speech recognition system 500 including a feature extraction module 510, a ceRNN 520, a LSTM RNN 530, and a transcription generation module 540. The speech recognition system 500 may be implemented on one or more computers, such as a desktop computer, laptop computer, phone, wearable device, etc. The speech recognition system 500 may additionally or alternatively be implemented on a remote system, such as a server system comprising one or more computers that provide results to a device over a communication network.
In the example, one or more computers of the system 500 receive audio data 502 indicating acoustic characteristics of an utterance. The feature extraction module 510 generates a first vector comprising audio features determined from the audio data. The ceRNN 520, a first recurrent neural network, receives the first vector as input and outputs a second vector in response. The first recurrent neural network has a transition matrix that implements a cascade of linear operators. As discussed below, these linear operators can include (i) first linear operators that are complex-valued and unitary, and (ii) one or more second linear operators that are non-unitary. A second neural network, e.g., the LSTM RNN 530, receives the second vector as input and provides an output vector in response. The LSTM RNN 530 includes one or more layers including long short-term memory cells. The transcription generation module 540 processes the output vector and determines a transcription 550 for the utterance. For example, the module 540 may identify the most likely characters, word pieces, or words indicated by the output vectors received in response to processing a sequence of vectors representing the utterance to determine the words predicted as most likely spoken in the utterance. The system 500 then provides the transcription 550 for the utterance.
As discussed further below, the one or more second linear operators of the ceRNN 520 that are non-unitary can be diagonal matrix multiplication operators. In some cases, all other linear operators in the cascade are unitary operators. One or more second linear operators that are non-unitary may introduce decay of retained data in memory of the ceRNN 520.
The cascade of linear operators for the ceRNN 520 may include at least one of each of the operators in the set of: a Fourier transformation, an inverse Fourier transformation, a diagonal matrix multiplication, a column permutation, and a Householder reflection. For example, the cascade of linear operators may be, or at least include, a sequence of operators comprising a first diagonal matrix multiplication, a Fourier transform, a first Householder reflection, a column permutation, a second diagonal matrix multiplication, an inverse Fourier transformation, a second Householder reflection, and a third diagonal matrix multiplication. Other sequences, orderings, subsets, and groups of more or fewer operators may also be used.
In some implementations, the cascade of linear operators is limited to operators selected from the set consisting of Fourier transformations, inverse Fourier transformations, diagonal matrix multiplications, column permutations, and Householder reflections. The one or more second linear operators that are non-unitary are limited to diagonal matrix multiplications.
In some implementations, the audio data for the utterance is acquired using two or more microphones, and the first vector comprises audio features determined using audio data from the two or more microphones, and wherein the ceRNN 520 is configured to perform beamforming processing. In addition, or as an alternative, the ceRNN 520 is configured to perform de-reverberation processing and/or noise reduction processing.
The audio data comprises receiving the audio data 502 may be received from a client device over a network, and the system 500 may provide the transcription 550 to the client device over a network. The transcription 550 may additionally or alternatively be provided to a computer system implementing a digital conversational assistant.
The complex evolution Recurrent Neural Network (ceRNN) model will now be discussed in more detail. This new type of model is similar to unitary evolution RNNs (uRNNs) but drops the unitary property selectively. On a simple multivariate linear regression task, dropping the constraints improves the learning trajectory. In copy memory task, ceRNNs and uRNNs perform identically, demonstrating that their superior performance over LSTMs is due to complex-valued nature and their linear operators. In a large scale real-world speech recognition, a uRNN degrades the performance of a baseline LSTM acoustic models, while pre-pending a ceRNN improves the performance over the baseline by 0.8% absolute WER.
In general, unitary evolution RNNs (uRNNs) were proposed to address the exploding gradients in RNNs, essentially by constraining the Eigenvalues of the linear transformations to be unity. The fundamentals of the uRNN model are discussed briefly to provide context. To understand why the gradients do not explode in this model, consider the standard RNN equation shown in equations 8 and 9.
z t+1 =W t h t +V t x t+1 (8)
h t+1=σ(z t+1) (9)
For T unrolled steps and cost C at T, the gradients at any previous step t are shown by equation 10 below:
where Dk=diag(σ′(zk)) is the Jacobian of point-wise nonlinearity. By imposing the constraint ∥Wk∥=1 and using ReLu (σ) as the non-linearity activation function, the uRNNs guarantee that the upper bound will not explode/vanish. As an aside, while the upper bound will not explode or vanish, the gradients themselves may decrease rapidly.
In uRNNs, the transition matrix W: x
→y. x,y∈
N was replaced by a cascade of efficient unitary linear operators, specifically Fourier transformation (F), its inverse (F
−1), unitary diagonal matrix multiplication U, column permutation operator P, and Householder reflection
The operators—{
, R, P}—are unitary in nature since its inverse is its conjugate transpose. The diagonal matrix is constrained to be unitary by choosing the elements on the unit circle, U
i,i=e
−iθ, ∀θ
i; ∈
. The cascade of operators were strung together as in Equation 12 below.
z=W u x=U 3 R 2 −1 U 2 PR 1 1 U 1 x (12)
Since the output of this transformation is a complex-valued vector, a complex-valued non-linear operator was needed. For this purpose, modReLu is used, which is a complex-valued extension of the ReLu, parameterized by a bias term b. This is shown below in equation 13.
The resulting models have been found to converge faster than LSTMs in copy memory and addition tasks. The performance on pixel-by-pixel MNIST dataset tests was mixed, the uRNNs outperformed LSTMs in the permuted case, but not in the un-permuted case.
The characteristics of complex evolution recurrent neural networks (ceRNNS) will now be described. As mentioned above, the uRNN models have three attractive properties: (a) the unitary property, (b) the complex-valued nature, and (c) efficient linear operators. One of the questions that has not been addressed in the literature so far is how critical is the unitary property of the model. The copy-memory task is designed to test the capacity of the model to retain the memory uncorrupted for long durations. The non-decaying property of the unitary transforms makes it particularly well-suited to address that task. However, in many real-world tasks such as automatic speech recognition (ASR) the model is only required to retain short-term memory and the ability to decay or forget may be useful. Thus, a variant that can drop the unitary constraints selectively may improve performance. The unitary constraint on the diagonal matrices D is dropped as in Equation 14 below.
z=W ce x=D 3 R 2 −1 D 2 PR 1 1 D 1 x (14)
While any cascade of the unitary operators will result in a unitary linear transformation, the uRNN model chooses a specific cascade of transformation, as in Equation 5, without any justification, but presumably based on empirical evaluations. As such, the uRNN contains only 7N real-valued parameters and has limited model capacity since the resulting matrices do not span the entire space of an unconstrained matrix with N2 parameters. This was one of the criticisms that inspired the “full unitary” model. On closer examination, this is not an inherent weakness and the model capacity can be increased arbitrarily by chaining more transformations in the cascade. For the purpose of head-to-head comparison, the same cascade is retained here.
In the comparison, the family of models that are constructed by chaining a cascade of the efficient complex-valued linear operators and non-unitary diagonal matrices is referred to as complex evolution RNNs (ceRNNs). The unconstrained diagonal could potentially take on the unitary values and hence the ceRNNs can be viewed as a superset of uRNNs. The complex-valued layers by themselves have several useful properties. For example, the orthogonal properties of their decision boundaries helps solve the XOR problem with fewer nodes and they have better generalization characteristics.
Models can be tested using a multivariate linear regression task. Consider a multivariate linear process, y=W
mx+n, with x, y, n
, where n denotes uncorrelated and independent noise, and W
m is a randomly generated matrix to be estimated using complex evolution matrix with a mean squared error (MSE) cost function. The MSE cost and the convergence are compared under three different settings—(a) a matrix, W, (b) the unitary model defined in Equation 12, and (c) a complex evolution model defined in Equation 14. Note, while this is a convex problem, the matrices have different constraints and as a result they are not guaranteed to reach the same value of MSE loss at convergence.
FIG. 6A is a graph that shows a comparison of MSE with complex evolution (W_ce), unitary (W_u) and full matrix (W) models for the multivariate regression task. FIG. 6A shows the convergence of the loss function for the three models. At convergence, the MSE is the least for the full matrix model (MSE=0.5) as expected. The unitary model performs poorly (MSE≈250) even with more iterations than shown in the plot. When the learning rates are increased, there are spikes with loss more than 2k! The L2 norm of the angles (in radians) of the elements of the diagonal matrices help explain these spikes.
FIG. 6B shows the norm of the angles (radians) in the diagonal (U1) as the training progresses. Interestingly, as shown in FIG. 6B, the norm exhibits abrupt transitions that coincide with the spikes in the MSE loss function.
The complex evolution model on the other hand behaves better than the unitary model, with a smoother convergence and lower cost function (MSE=38) than the unitary model. In particular, it did not exhibit the erratic spiking behavior.
FIG. 7 is a graph that shows the estimated diagonal components, diag_i, in the unitary transform for the linear regression task where the x-y plane is the complex plane. For the unitary matrix technique, as illustrated in FIG. 7, the diagonal components (Ui,i), lie on unit circle. In complex evolution model, this is not the case.
Next, the performance is examined for the copy memory task, which is often employed to evaluate the memory capacity of the model. The performance of three types of memory networks is compared: (a) a long short term memory model (LSTM), (b) a unitary RNN with Wu state-evolution transformation, and (c) an RNN with Wce state-evolution transformation. All three models were trained with cross-entropy cost function using Adam.
The input in a copy memory task consists of four components: (1) a target sequence (T), for example of length 10, whose elements are sampled with repetition from a set of symbols {ai∈{1:7}}, (2) an N-length filler sequence (FN) with filler symbol a8, (3) a trigger (R) with symbol a9, and (4) another filler sequence (FT), of the same length as T, with filler symbol a8. The model is expected to output a sequence of filler symbols a8 till it encounters the trigger symbol R in the input and then it is expected to regurgitate the memorized target sequence T provided in the first component of the input.
FIG. 8 is a graph showing a comparison of cross-entropy loss with the ceRNN, the uRNN and the LSTM models for the copy memory task. The cross-entropy loss of all the three models are shown in FIG. 8. The uRNN and ceRNN models have identical plots and their cross-entropy loss (0.18) are significantly better than the LSTM (0.46). The identical performance of uRNN and ceRNN models is not entirely surprising since the ceRNNs retain 3 of the 4 unitary components—Fourier transform, its inverse and permutation transform.
As discussed further below, the ceRNN model can be used to improve automatic speech recognition. For example, use of the ceRNN model can reduce word error rates, when using clean input data or noisy data, compared to an LSTM model alone.
Training a large-scale speech model often involves a large amount of speech data. As an example, on the order of about 10,000-15,000 hours of spontaneous speech from anonymized voice search queries may be used. For noise robustness training, each utterance in the training data can be corrupted with additive noise and reverberation, corresponding to 100 different settings of room size and signal-to-noise ratios. The performance of the models is evaluated on two test sets: an uncorrupted or clean set, and a corrupted or noisy (in the same fashion as the training data) version of a 25-hour subset of utterances from Google voice search traffic. Each test set is about 25 hours. The performance is measured against human transcriptions.
The acoustic features consist of a sequence of vectors, computed at a rate of one vector per 30 ms. Each vector is comprised of four stacked frames; the current frame along with three previous ones. Each frame contains 128 log mel-warped filter-bank outputs, computed at a rate of 100 frames per second using a sliding window of 32 ms. During training, to emulate the effect of the right context, the output state label is delayed by 5 frames. Each frame is labeled with one out of 8192 context-dependent output phoneme states. The baseline model is an LSTM model with 5-layers and 768 nodes in each layer.
Several experiments involve inserting uRNN and ceRNN layers between the inputs and the LSTM baseline. Preliminary experiments with uRNN and ceRNN layers by themselves performed poorly compared to LSTMs. The poor performance is likely because both uRNN and ceRNN lack the sort of gating mechanism present in LSTMs.
The uRNN+LSTM and ceRNN+LSTM models were trained from scratch to reduce cross-entropy using the Adam optimizer with a batch size of 256. Attempts to train a simple RNN as a test layer with different learning rate failed. The results in the Table 5 are reported at convergence (50M training steps). The unitary RNN layer hurts the ASR performance when compared to the baseline system. On the other hand, the ceRNN gives a marginal and consistent gain over the baseline system. To rule out the possibility that the ceRNN is only renormalizing the data, a normalization layer is introduced before uRNN. That still does not help improve the performance of the uRNN models.
TABLE 5 |
|
Performance (WER) comparison of the LSTM, |
the uRNN + LSTM, and the ceRNN + LSTM |
models. |
|
Model |
Clean |
Noisy |
|
|
|
LSTM |
11.7 |
18.5 |
|
uRNN (512) + LSTM |
12.6 |
20.9 |
|
ceRNN (512) + LSTM |
11.5 |
18.3 |
|
|
Since the ceRNN model parameters grow only linearly in the size (nodes) of the layer in contrast to standard matrix-based layers (O(7N) vs. O(N2)), the computational cost also scales linearly. This makes it practical to increase the size of the layer from 512 to 1024 and 2048 and Table 6 reports the associated improvements observed. The ceRNN with 2048 nodes (with only 14 k additional parameters) appears to provide the most performance gain. Increasing the number of nodes further to 4096 increased the performance only marginally.
TABLE 6 |
|
Performance (WER) improvements observed with |
512, 1024 and 2048 ceRNN nodes. |
|
Model |
Clean |
Noisy |
|
|
|
ceRNN (512) + LSTM |
11.5 |
18.3 |
|
ceRNN (1024) + LSTM |
11.4 |
18.1 |
|
ceRNN (2048) + LSTM |
11.1 |
17.5 |
|
|
Increasing the ceRNN output also increases the size of the LSTM inputs and the matrices associated with the gates. To rule out the possibility that the performance improvements are related to the larger size of the LSTM gates incidentally caused by using ceRNN, a contrasting experiment was run, in which only 512 outputs from the ceRNN were retained. The rest of the outputs were discarded. This is analogous to zero-padding the FFT and demonstrates how the ceRNN can be applied to project from higher to lower dimensions without an explicit linear bottleneck layer. In general, the performance does not suffer from discarding the extra dimensions and retaining the same number of parameters on the LSTM gates. Thus, the improvements are from the ceRNN layer itself.
FIGS. 9A-9B shows the performance of the baseline LSTM model with the best ceRNN+LSTM model as a function of training steps. The ceRNN+LSTM model is consistently better than the LSTM models for all the checkpoints on both the data sets, improving the performance by about 0.5% absolute WER over the LSTM models at convergence. FIGS. 9A-9B show performance of the ceRNN+LSTM model as training progresses, on clean test data in FIG. 9A, and on noisy test data in FIG. 9B.
This document proposes the use of ceRNNs, a family of RNNs whose transition matrix consists of a cascade of efficient complex-valued (unitary) linear operators and non-unitary diagonal matrices. We illustrate that dropping the unitary constraint on the diagonal improves the learning trajectory of a simple multivariate regression model. On copy memory task, ceRNNs and uRNNs perform identically, demonstrating that strict unitary constraint is not necessary to retain memory. In a head to head comparison of ceRNN and uRNN layer prepended before the baseline LSTM acoustic model, that uRNNs degrade the performance while ceRNNs improves the performance over the baseline, achieving as much as 0.8% absolute WER improvement. In various experiments, these matrices can model non-square linear transformations by dropping the extra dimensions, thus avoiding the expense of a bottleneck layer. Since these models utilize complex-valued FFTs as inputs, they open up the possibility of integrating de-reverberation and beam-forming within this framework. The linear transforms can be stitched together in many different ways to create a family of models with different trade-offs in memory and computational efficiency. This work raises the question whether the gains observed in different flavors of unitary matrices are due to their unitary nature or the properties (e.g., regularization) of transformations use to create those matrices.
FIG. 10 shows an example of a computing device 1000 and a mobile computing device 1050 that can be used to implement the techniques described here. The computing device 1000 is intended to represent various forms of digital computers, such as laptops, desktops, workstations, personal digital assistants, servers, blade servers, mainframes, and other appropriate computers. The mobile computing device 1050 is intended to represent various forms of mobile devices, such as personal digital assistants, cellular telephones, smart-phones, and other similar computing devices. The components shown here, their connections and relationships, and their functions, are meant to be examples only, and are not meant to be limiting.
The computing device 1000 includes a processor 1002, a memory 1004, a storage device 1006, a high-speed interface 1008 connecting to the memory 1004 and multiple high-speed expansion ports 1010, and a low-speed interface 1012 connecting to a low-speed expansion port 1014 and the storage device 1006. Each of the processor 1002, the memory 1004, the storage device 1006, the high-speed interface 1008, the high-speed expansion ports 1010, and the low-speed interface 1012, are interconnected using various busses, and may be mounted on a common motherboard or in other manners as appropriate. The processor 1002 can process instructions for execution within the computing device 1000, including instructions stored in the memory 1004 or on the storage device 1006 to display graphical information for a GUI on an external input/output device, such as a display 1016 coupled to the high-speed interface 1008. In other implementations, multiple processors and/or multiple buses may be used, as appropriate, along with multiple memories and types of memory. Also, multiple computing devices may be connected, with each device providing portions of the necessary operations (e.g., as a server bank, a group of blade servers, or a multi-processor system).
The memory 1004 stores information within the computing device 1000. In some implementations, the memory 1004 is a volatile memory unit or units. In some implementations, the memory 1004 is a non-volatile memory unit or units. The memory 1004 may also be another form of computer-readable medium, such as a magnetic or optical disk.
The storage device 1006 is capable of providing mass storage for the computing device 1000. In some implementations, the storage device 1006 may be or contain a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network or other configurations. Instructions can be stored in an information carrier. The instructions, when executed by one or more processing devices (for example, processor 1002), perform one or more methods, such as those described above. The instructions can also be stored by one or more storage devices such as computer- or machine-readable mediums (for example, the memory 1004, the storage device 1006, or memory on the processor 1002).
The high-speed interface 1008 manages bandwidth-intensive operations for the computing device 1000, while the low-speed interface 1012 manages lower bandwidth-intensive operations. Such allocation of functions is an example only. In some implementations, the high-speed interface 1008 is coupled to the memory 1004, the display 1016 (e.g., through a graphics processor or accelerator), and to the high-speed expansion ports 1010, which may accept various expansion cards. In the implementation, the low-speed interface 1012 is coupled to the storage device 1006 and the low-speed expansion port 1014. The low-speed expansion port 1014, which may include various communication ports (e.g., USB, Bluetooth, Ethernet, wireless Ethernet) may be coupled to one or more input/output devices, such as a keyboard, a pointing device, a scanner, or a networking device such as a switch or router, e.g., through a network adapter.
The computing device 1000 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a standard server 1020, or multiple times in a group of such servers. In addition, it may be implemented in a personal computer such as a laptop computer 1022. It may also be implemented as part of a rack server system 1024. Alternatively, components from the computing device 1000 may be combined with other components in a mobile device, such as a mobile computing device 1050. Each of such devices may contain one or more of the computing device 1000 and the mobile computing device 1050, and an entire system may be made up of multiple computing devices communicating with each other.
The mobile computing device 1050 includes a processor 1052, a memory 1064, an input/output device such as a display 1054, a communication interface 1066, and a transceiver 1068, among other components. The mobile computing device 1050 may also be provided with a storage device, such as a micro-drive or other device, to provide additional storage. Each of the processor 1052, the memory 1064, the display 1054, the communication interface 1066, and the transceiver 1068, are interconnected using various buses, and several of the components may be mounted on a common motherboard or in other manners as appropriate.
The processor 1052 can execute instructions within the mobile computing device 1050, including instructions stored in the memory 1064. The processor 1052 may be implemented as a chipset of chips that include separate and multiple analog and digital processors. The processor 1052 may provide, for example, for coordination of the other components of the mobile computing device 1050, such as control of user interfaces, applications run by the mobile computing device 1050, and wireless communication by the mobile computing device 1050.
The processor 1052 may communicate with a user through a control interface 1058 and a display interface 1056 coupled to the display 1054. The display 1054 may be, for example, a TFT (Thin-Film-Transistor Liquid Crystal Display) display or an OLED (Organic Light Emitting Diode) display, or other appropriate display technology. The display interface 1056 may comprise appropriate circuitry for driving the display 1054 to present graphical and other information to a user. The control interface 1058 may receive commands from a user and convert them for submission to the processor 1052. In addition, an external interface 1062 may provide communication with the processor 1052, so as to enable near area communication of the mobile computing device 1050 with other devices. The external interface 1062 may provide, for example, for wired communication in some implementations, or for wireless communication in other implementations, and multiple interfaces may also be used.
The memory 1064 stores information within the mobile computing device 1050. The memory 1064 can be implemented as one or more of a computer-readable medium or media, a volatile memory unit or units, or a non-volatile memory unit or units. An expansion memory 1074 may also be provided and connected to the mobile computing device 1050 through an expansion interface 1072, which may include, for example, a SIMM (Single In Line Memory Module) card interface. The expansion memory 1074 may provide extra storage space for the mobile computing device 1050, or may also store applications or other information for the mobile computing device 1050. Specifically, the expansion memory 1074 may include instructions to carry out or supplement the processes described above, and may include secure information also. Thus, for example, the expansion memory 1074 may be provide as a security module for the mobile computing device 1050, and may be programmed with instructions that permit secure use of the mobile computing device 1050. In addition, secure applications may be provided via the SIMM cards, along with additional information, such as placing identifying information on the SIMM card in a non-hackable manner.
The memory may include, for example, flash memory and/or NVRAM memory (non-volatile random access memory), as discussed below. In some implementations, instructions are stored in an information carrier. that the instructions, when executed by one or more processing devices (for example, processor 1052), perform one or more methods, such as those described above. The instructions can also be stored by one or more storage devices, such as one or more computer- or machine-readable mediums (for example, the memory 1064, the expansion memory 1074, or memory on the processor 1052). In some implementations, the instructions can be received in a propagated signal, for example, over the transceiver 1068 or the external interface 1062.
The mobile computing device 1050 may communicate wirelessly through the communication interface 1066, which may include digital signal processing circuitry where necessary. The communication interface 1066 may provide for communications under various modes or protocols, such as GSM voice calls (Global System for Mobile communications), SMS (Short Message Service), EMS (Enhanced Messaging Service), or MMS messaging (Multimedia Messaging Service), CDMA (code division multiple access), TDMA (time division multiple access), PDC (Personal Digital Cellular), WCDMA (Wideband Code Division Multiple Access), CDMA2000, or GPRS (General Packet Radio Service), among others. Such communication may occur, for example, through the transceiver 1068 using a radio-frequency. In addition, short-range communication may occur, such as using a Bluetooth, WiFi, or other such transceiver. In addition, a GPS (Global Positioning System) receiver module 1070 may provide additional navigation- and location-related wireless data to the mobile computing device 1050, which may be used as appropriate by applications running on the mobile computing device 1050.
The mobile computing device 1050 may also communicate audibly using an audio codec 1060, which may receive spoken information from a user and convert it to usable digital information. The audio codec 1060 may likewise generate audible sound for a user, such as through a speaker, e.g., in a handset of the mobile computing device 1050. Such sound may include sound from voice telephone calls, may include recorded sound (e.g., voice messages, music files, etc.) and may also include sound generated by applications operating on the mobile computing device 1050.
The mobile computing device 1050 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a cellular telephone 1080. It may also be implemented as part of a smart-phone 1082, personal digital assistant, or other similar mobile device.
Various implementations of the systems and techniques described here can be realized in digital electronic circuitry, integrated circuitry, specially designed ASICs (application specific integrated circuits), computer hardware, firmware, software, and/or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
These computer programs (also known as programs, software, software applications or code) include machine instructions for a programmable processor, and can be implemented in a high-level procedural and/or object-oriented programming language, and/or in assembly/machine language. As used herein, the terms machine-readable medium and computer-readable medium refer to any computer program product, apparatus and/or device (e.g., magnetic discs, optical disks, memory, Programmable Logic Devices (PLDs)) used to provide machine instructions and/or data to a programmable processor, including a machine-readable medium that receives machine instructions as a machine-readable signal. The term machine-readable signal refers to any signal used to provide machine instructions and/or data to a programmable processor.
To provide for interaction with a user, the systems and techniques described here can be implemented on a computer having a display device (e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor) for displaying information to the user and a keyboard and a pointing device (e.g., a mouse or a trackball) by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback (e.g., visual feedback, auditory feedback, or tactile feedback); and input from the user can be received in any form, including acoustic, speech, or tactile input.
The systems and techniques described here can be implemented in a computing system that includes a back end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front end component (e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here), or any combination of such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include a local area network (LAN), a wide area network (WAN), and the Internet.
The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
Although a few implementations have been described in detail above, other modifications are possible. For example, while a client application is described as accessing the delegate(s), in other implementations the delegate(s) may be employed by other applications implemented by one or more processors, such as an application executing on one or more servers. In addition, the logic flows depicted in the figures do not require the particular order shown, or sequential order, to achieve desirable results. In addition, other actions may be provided, or actions may be eliminated, from the described flows, and other components may be added to, or removed from, the described systems. Accordingly, other implementations are within the scope of the following claims.