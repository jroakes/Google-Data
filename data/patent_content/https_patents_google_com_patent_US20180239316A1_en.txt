US20180239316A1 - Communicating with devices - Google Patents
Communicating with devices Download PDFInfo
- Publication number
- US20180239316A1 US20180239316A1 US15/322,986 US201515322986A US2018239316A1 US 20180239316 A1 US20180239316 A1 US 20180239316A1 US 201515322986 A US201515322986 A US 201515322986A US 2018239316 A1 US2018239316 A1 US 2018239316A1
- Authority
- US
- United States
- Prior art keywords
- computing device
- component model
- component
- multiple traits
- trait
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Abandoned
Links
Images
Classifications
-
- G—PHYSICS
- G05—CONTROLLING; REGULATING
- G05B—CONTROL OR REGULATING SYSTEMS IN GENERAL; FUNCTIONAL ELEMENTS OF SUCH SYSTEMS; MONITORING OR TESTING ARRANGEMENTS FOR SUCH SYSTEMS OR ELEMENTS
- G05B15/00—Systems controlled by a computer
- G05B15/02—Systems controlled by a computer electric
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/01—Input arrangements or combined input and output arrangements for interaction between user and computer
- G06F3/048—Interaction techniques based on graphical user interfaces [GUI]
- G06F3/0484—Interaction techniques based on graphical user interfaces [GUI] for the control of specific functions or operations, e.g. selecting or manipulating an object, an image or a displayed text element, setting a parameter value or selecting a range
- G06F3/04847—Interaction techniques to control parameter settings, e.g. interaction with sliders or dials
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/30—Creation or generation of source code
- G06F8/38—Creation or generation of source code for implementing user interfaces
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/44—Arrangements for executing specific programs
- G06F9/451—Execution arrangements for user interfaces
- G06F9/452—Remote windowing, e.g. X-Window System, desktop virtualisation
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L67/00—Network arrangements or protocols for supporting network services or applications
- H04L67/01—Protocols
- H04L67/12—Protocols specially adapted for proprietary or special-purpose networking environments, e.g. medical networks, sensor networks, networks in vehicles or remote metering networks
Definitions
- the Internet provides access to a wide variety of resources, such as image files, audio files, video files, and webpages.
- a search system can identify resources in response to queries submitted by users and provide information about the resources in a manner that is useful to the users. The users can navigate through, e.g., select, search results to acquire information of interest.
- Devices can sometimes communicate through the internet or through a local network. For example, a user may be able to control a thermostat through an application on his smartphone.
- This specification relates to enabling a user to control multiple electronic devices, for example, devices that are a part of the Internet of Things (IoT), using a common interface.
- IoT Internet of Things
- innovative aspects of the subject matter described in this specification can be embodied in methods that include actions of sending a request, by a first computing device and for receipt by a second computing device, that the second computing device send data that describes characteristics of the second computing device.
- Receiving, from the second computing device, the data that describes the characteristics of the second computing device, where data that describes the characteristics of the second computing device (i) identifies a first component model of the second computing device, (ii) identifies multiple traits of the first component model,(iii) identifies a second component model of the second computing device, and (iv) identifies multiple traits of the second component model. Determining whether the second computing device includes the first component model based on the received data.
- Determining whether the second computing device includes the second component model based on the received data Generating, by the first computing device, a graphical user interface that is associated with the second computing device. And, the graphical user interface includes (i) a first graphical control to display or control one of the multiple traits of the first component, as a result of the first computing device having determined that the second computing device includes the first component, and (ii) a second graphical control to display or control one of the multiple traits of the second component, as a result of the first computing device having determined that the second computing device includes the second component.
- Other implementations of this aspect include corresponding systems, apparatus, and computer programs, configured to perform the actions of the methods, encoded on computer storage devices.
- the multiple traits of the first component model can include multiple states of the first component model, commands for controlling the first component model, or a combination of both.
- the multiple traits of the second component model can include multiple states of the second component model, commands for controlling the second component model, or a combination of both.
- the first computing device can generate the graphical control for controlling the one of the multiple traits of the first component model by determining whether the second computing device includes the first component model without determining whether the first component model includes the one of the multiple traits.
- the first computing device can store, before the first computing device received the data that describes the characteristics of the second computing device, information that identified the first component model as including the one of the multiple traits.
- the data can identifies multiple traits of the second computing device, assigns the multiple traits of the first component model to the first component model, assigns the multiple traits of the second component model to the second component model, and assigns a first one of the multiple traits of the second computing device to the multiple traits of the first component model and a second one of the multiple traits of the second component model.
- a first trait of the multiple traits of the second computing device is assigned to a second trait of the first component model, and a name of the first trait is different than a name of the second trait.
- the method includes sending a command, to the second computing device, to change a state of a particular trait of the multiple traits of the second computing device by referencing a name of the first component model or the second component model to which the particular trait is mapped by the data.
- the data identifies a trait of the second computing device and maps the trait of the second computing device to (i) one of the multiple traits of the first component model, and (ii) one of the multiple traits of the second component model that each refer to a same trait of the second computing device, due to the first component model and the second component model each having access to and sharing the same trait.
- the data maps the multiple traits of the second component model to the second component model, identifies a third component model that represents an array of a plurality of the second component model without specifying a quantity of the second component model, and identifies at least two traits of the second computing device and maps the at least two traits to elements in the array of the plurality of the second component model.
- the second computing device is an alarm clock, the first component model is a clock, and the second component model is an alarm.
- the second computing device is an oven, the first component model is an oven, and the second component model is light.
- the second computing device is a multi-light device the first component model is a light, and the second component model is an array of lights.
- the second computing device is a stove, the first component model is a first set of burners, and the second component model is a second set of burners.
- the second computing device is combined washer-dryer, the first component model is washer, and the second component model is dryer.
- assigning the multiple traits of the second computing device to the multiple traits of the first component and the multiple traits of the second component includes assigning (i) a name of a first trait of the multiple traits of the second computing device to (ii) a name of a second trait of the first component, and the first name is different than the second name.
- Implementations of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages. Implementations may provide for efficient discovery of functions associated with an Internet of Things (IoT) capable device. Implementations may enable simple and precise synchronization of device states associated with an IoT capable device. Implementations may permit IoT capable device manufactures to add new functions (e.g., commands and states) to existing parts of devices and to permit discovery of new functions by computing device applications (e.g., apps). Implementations may permit disambiguation of duplicated functions for an IoT capable device, and permit apps to address commands to specific parts of the device for performing associated with the duplicated functions.
- IoT Internet of Things
- FIG. 1 depicts an example system in accordance with implementations of the present disclosure.
- FIGS. 2A-2D depict exemplary component models and device definitions for exemplary IoT capable devices in accordance with implementations of the present disclosure.
- FIG. 2E depicts exemplary GUIs for an IoT device interface application and an example of GUI rendering instructions.
- FIG. 3 depicts an example process that can be executed in accordance with implementations of the present disclosure.
- IoT Internet of Things
- devices and systems such as home appliances (e.g., refrigerators, stoves, ovens, microwaves, washers/dryers), building mechanical systems (e.g., heating ventilation and air conditioning (HVAC) systems), security systems (e.g., security cameras, locks), building electrical systems (e.g., lighting) can be embedded with computing systems enabling the monitoring and control of such systems and devices over the internet.
- HVAC heating ventilation and air conditioning
- security systems e.g., security cameras, locks
- building electrical systems e.g., lighting
- computing systems enabling the monitoring and control of such systems and devices over the internet.
- Implementations of the present disclosure are generally directed to enabling an integration of diverse types of embedded devices into IoT technology. More specifically, implementations provide a common device monitoring and control model (e.g., device model) for use by application developers and device manufacturers.
- the device model represents IoT devices and their corresponding functions based on device traits and component models.
- Device traits may represent the lowest composable units of functionality for IoT devices (e.g., “onOff,” “temperature,” “volume,” “brightness,” etc.). That is, device traits can represent specific device functions or device states.
- a trait can represent a function performable by a device and an associated command for controlling the function. For example, a trait of an IoT stove may be an individual burner.
- the burner's function includes a range of settings from OFF through HIGH and associated command(s) for controlling the function (e.g., “burner.setTemperature()”).
- a trait can also represent a state of a device such as, for example, a battery charge level and associated command(s) (e.g., “battery.getChargeLevel()”).
- Component models represent groups of one or more traits combined into a common interface associated with a logical functionality between IoT device traits (e.g., “Security Camera,” “Light,” “Speaker,” “Display,” “Oven,” etc.). Component models may offer an abstraction over traits of the device that allows the device manufacturers to control what device functionality is exposed and how the functionality is exposed.
- a component model defines a collection of traits and the relationships between them. Traits of a particular device can be mapped to particular component models by the component models and a device definition.
- component models serve as a high level summary of the traits expressed by particular devices and provide a standardized syntax for communicating with IoT capable devices.
- component models can include repeated traits (e.g. lights in a chandelier or speakers in a surround sound system).
- component models can include other component models.
- a component model for a combination device e.g., a combination washer/dryer
- component models associated with stand-alone devices e.g., a separate washer or dryer.
- component models can be arranged in an inheritance model.
- a component model for an improved device e.g., a dimmable light lamp
- a standard device e.g., a standard lamp
- component models can be standardized to general device types (e.g., a stove, oven, lamp, stereo, security camera, thermostat, etc.). For example, such component models may not account for device functions which may or may not be available on a particular device of the same type (e.g., advanced functions or custom functions).
- device manufacturers can provide custom device models that, for example, include functions of standard devices of the same type in addition to manufacturer or device specific functions (e.g., advanced functions).
- the syntax “interface” is used to refer to component models when referring to examples of code. That is, the syntax “interface” can be used interchangeably with the term “component” or “component model” when referring to communications with, addressing for, or commands for IoT capable devices.
- FIG. 1 depicts an example system 100 that can execute implementations of the present disclosure.
- the example system 100 includes a computing device 102 in communication with one or more IoT devices 104 , and one or more server systems 106 .
- the computing device 102 may be in communication with the IoT devices 104 and server systems 106 through network 108 .
- the network 108 can include a large network or combination of networks, such as a local area network (LAN), wide area network (WAN), the Internet, analog or digital wired and wireless telephone networks (e.g., 4G and Long-Term Evolution (LTE) networks), a satellite network, one or more wireless access points, or any appropriate combination thereof connecting any number of mobile clients, fixed clients, and servers.
- the computing device 102 can also or alternatively communicate with the IoT devices 104 either directly through a wired or wireless interface (e.g., Universal Serial Bus (USB), Bluetooth, or Wi-Fi Direct).
- USB Universal Serial Bus
- Bluetooth Wireless Fidelity
- the computing device 102 can be any of a number of different types of computing devices including, for example, a mobile phone; smartphone; personal digital assistant; laptop, tablet computer, or netbook computer; or a desktop computer.
- the computing device 102 typically can have internal or external storage components for storing data and programs such as an operating system and one or more application programs.
- the internal or external storage components for the computing device 102 to store a client application for interfacing with IoT devices 104 .
- the computing device 102 can be configured to interface with IoT devices 104 without a specific user application, using, for example, a web browser.
- Computing device 102 also includes a central processing unit (CPU) for executing instructions stored in storage and/or received from one or more other electronic devices, for example over network 108 .
- Computing device 102 also includes one or more communication interfaces for sending and receiving data. Examples communication interfaces include antennas, transceivers, network communications cards, and other network adapters capable of transmitting and receiving data over a network (e.g., network 108 ) through a wired or wireless data pathway.
- a network e.g., network 108
- IoT devices 104 can be any internet capable device or system that can be controlled or monitored by, for example, an user application (e.g., an app) executed on a separate computing device (e.g., computing device 102 ). IoT devices can include, for example, an internet capable alarm clock 104 a, multi-light fixture 104 b, washer and dryer 104 c, or stove 104 d. An IoT device 104 includes a central processing unit (CPU) for executing instructions stored in storage and/or received from one or more other computing devices 102 , for example over network 108 . An IoT device 104 also includes one or more communication interfaces for sending and receiving data. Example communication interfaces include antennas, transceivers, network communications cards, and other network adapters capable of transmitting and receiving data over a network (e.g., network 108 ) through a wired or wireless data pathway.
- a network e.g., network 108
- the server systems 106 can be implemented using one or more computing devices (e.g., servers or a computing system).
- the one or more computing devices on which the server systems 106 are implemented can have internal or external storage components storing data and programs such as an operating system and one or more application programs.
- the one or more application programs can be implemented as instructions that are stored in the storage components and that, when executed, cause the one or more computing devices to provide the features ascribed herein to the server systems 106 .
- the one or more computing devices on which each of the server systems 106 are implemented can include one or more processors for executing instructions stored in storage and/or received from one or more other electronic devices, for example, over network 108 .
- these computing devices can include network interfaces and communication devices for sending and receiving data.
- the server systems 106 can be configured to store IoT device apps and/or IoT device data that can be accessed (e.g., downloaded) by computing device 102 .
- the server system can be an online store for purchasing computing device apps (e.g., an ANDROID application marketplace).
- the server system 106 can provide a library of standard IoT device models, IoT device component models, and device traits.
- the server systems 106 can be IoT device manufacturers' server systems that provide computing devices 102 with access to manufacturer specific IoT device models and/or component models associated with the manufacturers' IoT devices (e.g., a household appliance manufacturer's custom models for its IoT devices).
- a user may download an IoT device interface app 110 to a computing device 102 from a server system 106 .
- the user may own an IoT capable alarm clock 104 a made by manufacturer A, an IoT capable multi-light fixture 104 b made by manufacturer B, an IoT capable washer and dryer 104 c made by manufacturer C, and an IoT capable stove 104 d made by manufacturer D.
- the IoT device interface app 110 can obtain device characteristic data associated with each of the user's IoT capable devices 104 a - 104 d to generate appropriate user interfaces (e.g., graphical user interfaces (GUI)) for controlling each IoT capable device 104 a - 104 d.
- GUI graphical user interfaces
- the IoT capable stove 104 d can send characteristic data 112 to the computing device 102 .
- Characteristic data 112 can include data identifying one or more stove component models supported by the stove 104 d (e.g., names of the supported component models). These component models may represent sub-portions of the device, and may be designated by a standard or may be designated by the manufacturer.
- the stove 104 d may support a standard stove component model (e.g., “FourBurnerStoveInterface”) and a manufacturer specific stove component model (e.g., “AdvancedStoveInterface”).
- the characteristic data 112 can include data describing the supported component models. The data can identify multiple device traits that are associated with one or more of the supported component models.
- the standard stove component model may include four burner traits
- the manufacturer specific stove component model may include four burner traits plus a corn roaster trait.
- the characteristic data 112 can include the component models themselves.
- the computing device 102 can use the characteristic data 112 to determine which of the stove component models the IoT capable stove 104 d supports and therefore may use the characteristic data 112 to generate an appropriate GUI for the user to control and monitor the status of the stove 104 d.
- the computing device 102 can access an appropriate component model that identifies specific device traits and that is associated with the component models supported by the stove 104 d.
- the IoT interface app 110 can use the component model to determine, for example, attributes of a GUI for controlling the stove 104 d, such as, the type of graphical controls to render (e.g., selection boxes, drop down menus, slider bars, etc.).
- a user can use the GUI on the computing device 102 to control the functions of the IoT capable stove 104 d .
- the IoT device interface app 110 can generate appropriate command data 114 .
- the computing device 102 can send the command data 114 to the stove 104 d to control, for example, the temperature of one of the burners on the stove 104 d.
- the IoT device interface app 110 can include data defining various IoT device component models.
- standard component models can be integrated into the device interface app 110 at a time that the app 110 is downloaded from the server system 106 , or can be or downloaded from an IoT device library at the server system 106 at a later time.
- the computing device 102 and app 110 can access IoT device model definitions from a manufacturer's server system (e.g., a manufacturer specific device model) or from an IoT device 104 (e.g., a component model may be included in the characteristic data 112 ).
- the IoT device interface app 110 can still control the particular IoT capable device using a standard component model (e.g., “FourBurnerStoveInterface”).
- a manufacturer specific model e.g., “AdvancedStoveInterface”
- the IoT device interface app 110 can still control the particular IoT capable device using a standard component model (e.g., “FourBurnerStoveInterface”).
- IoT devices may be required to support standard component models in addition to any manufacturer or device specific component models.
- FIG. 2A depicts exemplary component models 202 , 204 for exemplary IoT capable stoves 206 , 208 .
- Component models 202 , 204 serve as a high level summaries of the traits expressed by stoves 206 , 208 and provide a standardized syntax for communicating with the IoT capable stoves 206 , 208 .
- Each component models 202 , 204 identifies traits supported by the component model and associates the supported traits to corresponding traits exposed by a particular IoT capable device.
- component model 202 is for a standard component model (e.g., “FourBurnerStoveInterface”) and component model 204 is for a manufacturer defined component model (e.g., “AdvancedStoveInterface”).
- a standard stove 206 can include four “burner” traits while the advanced stove 208 includes four “burner” trait types and a “cornRoastingBurner” traits type.
- the standard stove 206 can be controlled only using component model 202 (of the two example component models shown) because it does not include all of the traits expressed in the component model 204 .
- the advanced stove 208 can be controlled using either component model 202 or component model 204 because the advanced stove includes both “burner” and “cornRoastingBurner” traits.
- the component models 202 , 204 provide descriptive trait names (e.g., “topLeftBurner,” “topRightBurner,” “bottomLeftBurner,” and “bottomRightBurner”) usable by IoT device apps to address commands to a particular one of multiple similar traits in a single device.
- a separate “burner” trait is associated with each of the descriptive trait names (e.g., “topLeftBurner,” “topRightBurner,” “bottomLeftBurner,” and “bottomRightBurner”) of the component models 202 , 204 .
- a “cornRoastingBurner” trait is associated with the “centerCornRoaster” of the “AdvancedStoveInterface” component model 204 .
- a device definition 210 specifies, for each trait of a particular device, which component models can be used to reference the trait.
- the example device definition 210 for the advanced stove 208 provides a detailed mapping between specific traits expressed by the advanced stove 208 and component models 202 , 204 that may be called by an IoT device interface app to control functions of the advanced stove 208 .
- the device definition 210 can serve as a syntax translation between a standardized syntax used by IoT device interface apps, and a syntax used by an IoT device itself.
- the device definition 210 lists all of the traits expressed by the advanced stove 208 (e.g., four burners and a corn roaster). For each trait of the advanced stove 208 , the device definition 210 specifies each component model that can reference the trait.
- the first burner trait 212 can be referenced by either the “FourBurnerStoveInterface” component model 202 or the “AdvancedStoveInterface” component model 204 . More specifically the first burner trait 212 can be referenced by the “topLeftBurner” trait of either the “FourBurnerStoveInterface” component model 202 or the “AdvancedStoveInterface” component model 204 .
- the corn roasting burner trait 214 can only be referenced by the “AdvancedStoveInterface” component model 204 .
- traits can be identified by not only their type, but also with an optional device manufacturer provided name or trait suffix.
- This optional custom name can be referenced as a suffix to the trait type separated by a colon.
- the first burner trait 212 is identified as the “smallBurner” while the second burner trait 216 is identified as the “largeBurner” in the advanced stove device definition 210 .
- the custom name need not have any semantic relationship to the component models used by the device.
- an IoT device interface app can issue a command to set the temperature of the burner trait associated with the “smallBurner” of the advanced stove 208 by referencing the component model name associated with the “smallBurner” (e.g., “topLeftBurner”) instead of referencing the manufacturer's custom name associated with a specific burner.
- a command to set the temperature of the top left burner of an advanced stove named “stove1” may be formatted as:
- component models may be advantageous in allowing apps to be compatible with IoT capable devices manufactured by many different manufacturers while allowing each manufacturer to use different custom naming conventions.
- the device definition 210 can be included in the device characteristic data provided from the IoT device (e.g., device 104 a ) to a computing device (e.g., computing device 102 ).
- component models can be used in an alternative fashion, as described above in reference to the standard four burner stove component model 202 and the advanced stove component model 204 . That is, an IoT device interface app can select one of the two component models 202 , 204 to use for generating a GUI to control the advanced stove 208 , but would generally not use both. However, when a particular IoT capable device is a combination of two devices (e.g. a combination washer/dryer) the concurrent use of two different component models may be required to control a single IoT capable device, or even a single trait of an IoT capable device.
- a particular IoT capable device is a combination of two devices (e.g. a combination washer/dryer) the concurrent use of two different component models may be required to control a single IoT capable device, or even a single trait of an IoT capable device.
- FIG. 2B depicts an exemplary device definition 220 for exemplary IoT capable washer-dryer-combo device 222 .
- the washer-dryer-combo device which uses a single lock for both the washer and the dryer.
- a single lock trait (“lock:xyz”) is referenced by both a “WasherInterface” component model and a “DryerIntreface” component model.
- the component models allow a device manufacturer to share traits between multiple interfaces and maintain synchronization of the shared trait across component models.
- the device definition 220 for the washer-dryer-combo device 222 may only define a single lock trait that can be referenced by both the “WasherInterface” component model and the “DryerInterface” component model. Therefore, the state (e.g., locked/unlocked) of the shared lock can be stored in a single variable, thereby, eliminating the need to synchronize separate lock variables for each interface of the combined device (e.g., washer and dryer) that are associated with a single lock on the device.
- the combined device e.g., washer and dryer
- component models can represent an IoT capable device with multiple traits of the same type where the number of the multiple same type traits is unspecified.
- component models can incorporate an array of traits or an array of other component models to represent an unspecified number of the same type of traits.
- FIG. 2C depicts exemplary component models for a light (light component model 230 ) and a multi-light device (multi-light component model 232 ), an IoT capable multi-light fixture 236 , and a device definition 234 for the multi-light fixture 236 .
- the multi-light component model 232 includes an unbounded array of light component models 230 .
- the multi-light component model may be used as a standard type of component model for any multi-light lighting device irrespective of the actual number of light traits included in the device.
- the multi-light component model could be used for IoT capable chandeliers, track lighting, string lights, etc.
- similar multi-trait or multi-component model arrays can be generated for other types of multiple traits (e.g., an unspecified number of stove burners).
- the device definition 234 provides an example of how a trait or component model array can be implemented for a specific device.
- the device definition 234 for the multi-light fixture 236 exposes the three traits 238 associated with the three lights of the multi-light fixture 236 .
- Each light trait 238 includes an optional custom name (e.g., “one,” “two,” and “three”) to differentiate the light traits within the device itself, and a reference to an array index of the array of light component models 230 defined by the multi-light component model 232 .
- Each light trait 238 can be used to control one of the lights ( 236 a, 236 b, 236 c ) of the multi-light fixture 236 .
- an IoT device interface app can interface with any multi-light device, for example, and without requiring information regarding the actual number of lights in the device.
- the trait can be referenced by an array index instead of a specific name. This allows a manufacturer to provide specific descriptive names to each trait, while, at the same time, permitting an app to address the same traits through an array.
- the reference when a trait is referenced by a component model that includes another component model, then the reference should be scoped appropriately.
- the reference can first identify the property of the top level component model that the trait is indirectly referenced by (e.g., the multi-light component model “MultiLightInterface.lights[ 0 ]”), followed by a delimiter (e.g., “I”), followed by the included component model (e.g., the light component model 230 “LightInterface”) directly referencing the trait (e.g., the “onOff” trait of the light component model 230 ).
- component models can use inheritance to add an advanced trait with additional functionality to a basic trait.
- component models can inherit basic traits and add additional traits to provide additional functionality to an IoT capable device.
- FIG. 2C depicts an oven component model 240 including a basic light component model (“LightInterface”), an advanced dimmable light component model 242 , and a device definition 244 for an IoT capable oven 246 .
- the basic light component model may be insufficient to control a dimmable light feature of an IoT capable oven 246 .
- a “brightness” trait can be added to the basic light component model using inheritance.
- the dimmable light component model 242 can be defined to inherit all of the traits of a basic light component model (e.g., an “onOff” trait) and add a “brightness” trait for controlling a dimmable light bulb.
- the oven component model 240 includes a basic light component model (“LightInterface”) and an oven trait (“oven”).
- the oven component model 240 may be sufficient for most IoT capable ovens, but when considering an oven that has the ability to dim a light.
- the dimmable light component model 242 provides a relationship between the basic light component model and the “brightness” trait in order for an app to access light dimming capability of the IoT capable oven's 246 light.
- the device definition 244 illustrates three traits of the IoT capable oven 246 that are referenced by the oven component model 240 .
- the “onOff” and “brightness” traits are both referenced by the “OvenInterface.light” trait of the oven component model 240 , but they are referenced by different sub-component models. Specifically, the “onOff” trait is referenced by the basic light component model (“LightInterface”), and the “brightness” trait is referenced by the dimmable light component model 242 (“DimableLightInterface”); both of which are sub-component models of the oven component model 240 .
- interfaces can provide a clear and static mechanism for app developers to generate an IoT device interface app capable of interacting with IoT capable devices which is independent from the software models that the devices use to model device states.
- a computing device can query an IoT capable device for a set of component models that the IoT capable device incorporates in its device definition, including any custom component models (e.g., the device characteristic data discussed above).
- component models are statically defined and can be represented by software libraries that can be linked to an app. Therefore, discovery of the component models supported by a particular IoT capable device can be accomplished by querying the device, as discussed above in reference to FIG. 1 . Since the variance in IoT capable devices can be expressed by supported component models (e.g., the presence or absence of supported component models), GUIs can be rendered more efficiently in IoT device interface apps.
- supported component models e.g., the presence or absence of supported component models
- FIG. 2E shows GUIs 252 , 254 rendered for an IoT device interface app and example GUI rendering instructions 250 .
- the app can include a preferential GUI rendering order 260 based on a successive presence of more advanced component models.
- the IoT device interface app can compare a list of component models supported by a particular IoT capable device (e.g., IoT capable stove 258 ) and render a GUI that is customized to a selected component model supported by both the app and the device. For example, if both the app and the IoT capable stove support the “AdvancedStoveInterface” component model then the app can render GUI 252 , which provides slider controls 262 for four burners plus a corn roaster.
- GUI 254 may only have slider controls 262 for controlling four burners of the IoT capable stove 258 , but not the corn roaster.
- a GUI can include multiple different screens that are shown at different times, for example, as a result of a user providing input to switch from one screen to the next.
- an IoT device interface app can generate a generic GUI for an IoT capable device based on a device definition, for example, if a particular component model is not recognized by the IoT device interface app.
- an IoT interface app can map different traits included in a device definition to appropriate attributes of a GUI.
- a Boolean trait e.g., “onOff”
- a trait with an integer range e.g., “brightness”
- a trait having an enumerated variable e.g., a “burner” trait's settings (OFF, LOW, MED, HIGH)
- OFF, LOW, MED, HIGH a “burner” trait's settings
- FIG. 3 depicts an example process 300 that can be executed in accordance with implementations of the present disclosure.
- the example process 300 can be provided as one or more computer-executable programs executed using one or more computing devices.
- the process 300 is a computing device executing an IoT device interface app.
- a first computing device sends a request to a second computing device for data that describes characteristics of the second computing device ( 302 ).
- the first computing device receives the data that describes the characteristics of the second computing device from the second computing device ( 304 ).
- the data can include data that identifies a first component model of the second computing device, data that identifies multiple traits of the first component model, data that identifies a second component model of the second computing device, and data that identifies multiple traits of the second component model.
- the first computing device can request device characteristic data from an IoT capable device. Characteristic data can include, for example, data identifying one or more component models supported by an IoT capable device.
- the characteristic data can include only names of the supported component models.
- the characteristic data can include the component models themselves (e.g., as described above in reference to FIG. 2A ).
- the characteristic data can include a device definition associated with the second computing device, where the device definition identifies the traits of the device and relates the traits to the devices' supported component models (e.g., as described above in reference to FIG. 2A ).
- the first computing device determines, based on the received data, whether the second computing device includes the first component model ( 306 ).
- the first computing device determines based on the received data, whether the second computing device includes the second component model ( 308 ).
- the first computing device can determine based on characteristic data for the second computing device whether the second computing device includes the first and second component models.
- first computing device can identify from a list of component models supported by the second computing device whether the second computing device supports the first and/or the second computing model by identifying the first and/or the second computing model in the list.
- the first computing device generates a graphical user interface (GUI) that is associated with the second computing device based on the first component model ( 310 ). For example, as discussed in reference to FIG. 2E , as a result of the first computing device having determined that the second computing device includes the first component model the first computing device can generate a GUI that includes graphical controls to display or control one of multiple traits associated with the first component model. For example, the first computing device can determine that the second computing device supports only one of the first and second component models and generate a GUI based on only the supported component model. In some examples, the first computing device may determine that both of the first and second component models are supported by the second computing device. In such implementations, the first computing device can select one of the supported component models and generate a GUI based on the selected component model. For example, the first computing device can select between the first and the second component models based on an order of preference among multiple component models.
- GUI graphical user interface
- a user may be provided with controls allowing the user to make an election as to both if and when systems, programs or features described herein may enable collection of user information (e.g., a user's preferences, a user's IoT capable devices, or a user's current location), and if the user is sent content or communications from a server.
- user information e.g., a user's preferences, a user's IoT capable devices, or a user's current location
- certain data may be treated in one or more ways before it is stored or used, so that personally identifiable information is removed.
- a user's identity may be treated so that no personally identifiable information can be determined for the user, or a user's geographic location may be generalized where location information is obtained (such as to a city, ZIP code, or state level), so that a particular location of a user cannot be determined.
- location information such as to a city, ZIP code, or state level
- the user may have control over what information is collected about the user, how that information is used, and what information is provided to the user.
- Implementations of the subject matter and the operations described in this specification can be realized in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Implementations of the subject matter described in this specification can be realized using one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage medium for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- an artificially generated propagated signal e.g., a machine-generated electrical, optical, or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- a computer storage medium can be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Moreover, while a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially generated propagated signal. The computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
- the operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
- the term “data processing apparatus” encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations, of the foregoing
- the apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
- the apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them.
- the apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.
- a computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment.
- a computer program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code).
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- the processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output.
- the processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
- processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer.
- a processor will receive instructions and data from a read only memory or a random access memory or both.
- Elements of a computer can include a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks.
- mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks.
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few.
- Devices suitable for storing computer program instructions and data include all forms of non volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- implementations of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used
- Implementations of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network.
- Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
- LAN local area network
- WAN wide area network
- inter-network e.g., the Internet
- peer-to-peer networks e.g., ad hoc peer-to-peer networks.
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device).
- client device e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device.
- Data generated at the client device e.g., a result of the user interaction
Abstract
Description
- The Internet provides access to a wide variety of resources, such as image files, audio files, video files, and webpages. A search system can identify resources in response to queries submitted by users and provide information about the resources in a manner that is useful to the users. The users can navigate through, e.g., select, search results to acquire information of interest. Devices can sometimes communicate through the internet or through a local network. For example, a user may be able to control a thermostat through an application on his smartphone.
- This specification relates to enabling a user to control multiple electronic devices, for example, devices that are a part of the Internet of Things (IoT), using a common interface.
- In general, innovative aspects of the subject matter described in this specification can be embodied in methods that include actions of sending a request, by a first computing device and for receipt by a second computing device, that the second computing device send data that describes characteristics of the second computing device. Receiving, from the second computing device, the data that describes the characteristics of the second computing device, where data that describes the characteristics of the second computing device (i) identifies a first component model of the second computing device, (ii) identifies multiple traits of the first component model,(iii) identifies a second component model of the second computing device, and (iv) identifies multiple traits of the second component model. Determining whether the second computing device includes the first component model based on the received data. Determining whether the second computing device includes the second component model based on the received data. Generating, by the first computing device, a graphical user interface that is associated with the second computing device. And, the graphical user interface includes (i) a first graphical control to display or control one of the multiple traits of the first component, as a result of the first computing device having determined that the second computing device includes the first component, and (ii) a second graphical control to display or control one of the multiple traits of the second component, as a result of the first computing device having determined that the second computing device includes the second component. Other implementations of this aspect include corresponding systems, apparatus, and computer programs, configured to perform the actions of the methods, encoded on computer storage devices.
- These and other implementations can each optionally include one or more of the following features. The multiple traits of the first component model can include multiple states of the first component model, commands for controlling the first component model, or a combination of both. The multiple traits of the second component model can include multiple states of the second component model, commands for controlling the second component model, or a combination of both.
- In some implementations, the first computing device can generate the graphical control for controlling the one of the multiple traits of the first component model by determining whether the second computing device includes the first component model without determining whether the first component model includes the one of the multiple traits. The first computing device can store, before the first computing device received the data that describes the characteristics of the second computing device, information that identified the first component model as including the one of the multiple traits.
- In some implementations, the data can identifies multiple traits of the second computing device, assigns the multiple traits of the first component model to the first component model, assigns the multiple traits of the second component model to the second component model, and assigns a first one of the multiple traits of the second computing device to the multiple traits of the first component model and a second one of the multiple traits of the second component model.
- In some implementations, a first trait of the multiple traits of the second computing device is assigned to a second trait of the first component model, and a name of the first trait is different than a name of the second trait.
- In some implementations, the method includes sending a command, to the second computing device, to change a state of a particular trait of the multiple traits of the second computing device by referencing a name of the first component model or the second component model to which the particular trait is mapped by the data.
- In some implementations, the data identifies a trait of the second computing device and maps the trait of the second computing device to (i) one of the multiple traits of the first component model, and (ii) one of the multiple traits of the second component model that each refer to a same trait of the second computing device, due to the first component model and the second component model each having access to and sharing the same trait.
- In some implementations, the data maps the multiple traits of the second component model to the second component model, identifies a third component model that represents an array of a plurality of the second component model without specifying a quantity of the second component model, and identifies at least two traits of the second computing device and maps the at least two traits to elements in the array of the plurality of the second component model.
- In some implementations, the second computing device is an alarm clock, the first component model is a clock, and the second component model is an alarm. In some implementations, the second computing device is an oven, the first component model is an oven, and the second component model is light. In some implementations, the second computing device is a multi-light device the first component model is a light, and the second component model is an array of lights. In some implementations, the second computing device is a stove, the first component model is a first set of burners, and the second component model is a second set of burners. In some implementations, the second computing device is combined washer-dryer, the first component model is washer, and the second component model is dryer.
- In some implementations, assigning the multiple traits of the second computing device to the multiple traits of the first component and the multiple traits of the second component includes assigning (i) a name of a first trait of the multiple traits of the second computing device to (ii) a name of a second trait of the first component, and the first name is different than the second name.
- Implementations of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages. Implementations may provide for efficient discovery of functions associated with an Internet of Things (IoT) capable device. Implementations may enable simple and precise synchronization of device states associated with an IoT capable device. Implementations may permit IoT capable device manufactures to add new functions (e.g., commands and states) to existing parts of devices and to permit discovery of new functions by computing device applications (e.g., apps). Implementations may permit disambiguation of duplicated functions for an IoT capable device, and permit apps to address commands to specific parts of the device for performing associated with the duplicated functions.
- The details of one or more implementations of the subject matter of this disclosure are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
-
FIG. 1 depicts an example system in accordance with implementations of the present disclosure. -
FIGS. 2A-2D depict exemplary component models and device definitions for exemplary IoT capable devices in accordance with implementations of the present disclosure. -
FIG. 2E depicts exemplary GUIs for an IoT device interface application and an example of GUI rendering instructions. -
FIG. 3 depicts an example process that can be executed in accordance with implementations of the present disclosure. - Like reference numbers and designations in the various drawings indicate like elements.
- There is tremendous diversity in the types of embedded devices that will be brought online by Internet of Things (IoT) technology. Due to the rise in IoT technology, a greater variety of traditionally non-computer based, devices and systems are being offered with internet connection capabilities. For example, devices and systems such as home appliances (e.g., refrigerators, stoves, ovens, microwaves, washers/dryers), building mechanical systems (e.g., heating ventilation and air conditioning (HVAC) systems), security systems (e.g., security cameras, locks), building electrical systems (e.g., lighting) can be embedded with computing systems enabling the monitoring and control of such systems and devices over the internet. The breadth of diversity of internet connected devices across various industries (e.g., home appliances to HVAC) and across different manufacturers presents a problem to both developers (e.g., application developers) and users. Without a standard process for efficiently identifying the functionality of IoT capable devices and communicating with IoT devices, developers may have difficulty integrating the functionality of unrelated devices (e.g., a user's HVAC system and refrigerator) into a single app. Consequently, users may have to use separate apps to control different IoT devices.
- Implementations of the present disclosure are generally directed to enabling an integration of diverse types of embedded devices into IoT technology. More specifically, implementations provide a common device monitoring and control model (e.g., device model) for use by application developers and device manufacturers. The device model represents IoT devices and their corresponding functions based on device traits and component models. Device traits may represent the lowest composable units of functionality for IoT devices (e.g., “onOff,” “temperature,” “volume,” “brightness,” etc.). That is, device traits can represent specific device functions or device states. A trait can represent a function performable by a device and an associated command for controlling the function. For example, a trait of an IoT stove may be an individual burner. For example, the burner's function includes a range of settings from OFF through HIGH and associated command(s) for controlling the function (e.g., “burner.setTemperature()”). Similarly, a trait can also represent a state of a device such as, for example, a battery charge level and associated command(s) (e.g., “battery.getChargeLevel()”).
- Component models represent groups of one or more traits combined into a common interface associated with a logical functionality between IoT device traits (e.g., “Security Camera,” “Light,” “Speaker,” “Display,” “Oven,” etc.). Component models may offer an abstraction over traits of the device that allows the device manufacturers to control what device functionality is exposed and how the functionality is exposed. A component model defines a collection of traits and the relationships between them. Traits of a particular device can be mapped to particular component models by the component models and a device definition. In addition, component models serve as a high level summary of the traits expressed by particular devices and provide a standardized syntax for communicating with IoT capable devices.
- In some implementations, component models can include repeated traits (e.g. lights in a chandelier or speakers in a surround sound system). In some implementations, component models can include other component models. For example, a component model for a combination device (e.g., a combination washer/dryer) can include one or more component models associated with stand-alone devices (e.g., a separate washer or dryer). In some implementations, component models can be arranged in an inheritance model. For example, a component model for an improved device (e.g., a dimmable light lamp) can inherit traits (e.g., on/off) from a component model for a standard device (e.g., a standard lamp).
- In some implementations, component models can be standardized to general device types (e.g., a stove, oven, lamp, stereo, security camera, thermostat, etc.). For example, such component models may not account for device functions which may or may not be available on a particular device of the same type (e.g., advanced functions or custom functions).
- In some implementations, device manufacturers can provide custom device models that, for example, include functions of standard devices of the same type in addition to manufacturer or device specific functions (e.g., advanced functions).
- In the examples described herein, the syntax “interface” is used to refer to component models when referring to examples of code. That is, the syntax “interface” can be used interchangeably with the term “component” or “component model” when referring to communications with, addressing for, or commands for IoT capable devices.
-
FIG. 1 depicts anexample system 100 that can execute implementations of the present disclosure. Theexample system 100 includes acomputing device 102 in communication with one or moreIoT devices 104, and one ormore server systems 106. Thecomputing device 102 may be in communication with theIoT devices 104 andserver systems 106 throughnetwork 108. Thenetwork 108 can include a large network or combination of networks, such as a local area network (LAN), wide area network (WAN), the Internet, analog or digital wired and wireless telephone networks (e.g., 4G and Long-Term Evolution (LTE) networks), a satellite network, one or more wireless access points, or any appropriate combination thereof connecting any number of mobile clients, fixed clients, and servers. In some implementations, thecomputing device 102 can also or alternatively communicate with theIoT devices 104 either directly through a wired or wireless interface (e.g., Universal Serial Bus (USB), Bluetooth, or Wi-Fi Direct). - The
computing device 102 can be any of a number of different types of computing devices including, for example, a mobile phone; smartphone; personal digital assistant; laptop, tablet computer, or netbook computer; or a desktop computer. Thecomputing device 102 typically can have internal or external storage components for storing data and programs such as an operating system and one or more application programs. In particular, the internal or external storage components for thecomputing device 102 to store a client application for interfacing withIoT devices 104. Additionally or alternatively, thecomputing device 102 can be configured to interface withIoT devices 104 without a specific user application, using, for example, a web browser. -
Computing device 102 also includes a central processing unit (CPU) for executing instructions stored in storage and/or received from one or more other electronic devices, for example overnetwork 108.Computing device 102 also includes one or more communication interfaces for sending and receiving data. Examples communication interfaces include antennas, transceivers, network communications cards, and other network adapters capable of transmitting and receiving data over a network (e.g., network 108) through a wired or wireless data pathway. -
IoT devices 104 can be any internet capable device or system that can be controlled or monitored by, for example, an user application (e.g., an app) executed on a separate computing device (e.g., computing device 102). IoT devices can include, for example, an internetcapable alarm clock 104 a,multi-light fixture 104 b, washer anddryer 104 c, orstove 104 d. AnIoT device 104 includes a central processing unit (CPU) for executing instructions stored in storage and/or received from one or moreother computing devices 102, for example overnetwork 108. AnIoT device 104 also includes one or more communication interfaces for sending and receiving data. Example communication interfaces include antennas, transceivers, network communications cards, and other network adapters capable of transmitting and receiving data over a network (e.g., network 108) through a wired or wireless data pathway. - The
server systems 106 can be implemented using one or more computing devices (e.g., servers or a computing system). The one or more computing devices on which theserver systems 106 are implemented can have internal or external storage components storing data and programs such as an operating system and one or more application programs. The one or more application programs can be implemented as instructions that are stored in the storage components and that, when executed, cause the one or more computing devices to provide the features ascribed herein to theserver systems 106. Furthermore, the one or more computing devices on which each of theserver systems 106 are implemented can include one or more processors for executing instructions stored in storage and/or received from one or more other electronic devices, for example, overnetwork 108. In addition, these computing devices can include network interfaces and communication devices for sending and receiving data. - For example, the
server systems 106 can be configured to store IoT device apps and/or IoT device data that can be accessed (e.g., downloaded) bycomputing device 102. For example, the server system can be an online store for purchasing computing device apps (e.g., an ANDROID application marketplace). In addition, theserver system 106 can provide a library of standard IoT device models, IoT device component models, and device traits. Theserver systems 106 can be IoT device manufacturers' server systems that providecomputing devices 102 with access to manufacturer specific IoT device models and/or component models associated with the manufacturers' IoT devices (e.g., a household appliance manufacturer's custom models for its IoT devices). - For example, a user may download an IoT
device interface app 110 to acomputing device 102 from aserver system 106. The user may own an IoTcapable alarm clock 104 a made by manufacturer A, an IoT capablemulti-light fixture 104 b made by manufacturer B, an IoT capable washer anddryer 104 c made by manufacturer C, and an IoTcapable stove 104 d made by manufacturer D. The IoTdevice interface app 110 can obtain device characteristic data associated with each of the user's IoTcapable devices 104 a-104 d to generate appropriate user interfaces (e.g., graphical user interfaces (GUI)) for controlling each IoTcapable device 104 a-104 d. For example, the IoTcapable stove 104 d, can sendcharacteristic data 112 to thecomputing device 102.Characteristic data 112 can include data identifying one or more stove component models supported by thestove 104 d (e.g., names of the supported component models). These component models may represent sub-portions of the device, and may be designated by a standard or may be designated by the manufacturer. For example, thestove 104 d may support a standard stove component model (e.g., “FourBurnerStoveInterface”) and a manufacturer specific stove component model (e.g., “AdvancedStoveInterface”). In some examples, thecharacteristic data 112 can include data describing the supported component models. The data can identify multiple device traits that are associated with one or more of the supported component models. For example, the standard stove component model may include four burner traits, whereas the manufacturer specific stove component model may include four burner traits plus a corn roaster trait. In other words, as described in more detail below, thecharacteristic data 112 can include the component models themselves. - The
computing device 102 can use thecharacteristic data 112 to determine which of the stove component models the IoTcapable stove 104 d supports and therefore may use thecharacteristic data 112 to generate an appropriate GUI for the user to control and monitor the status of thestove 104 d. For example, thecomputing device 102 can access an appropriate component model that identifies specific device traits and that is associated with the component models supported by thestove 104 d. TheIoT interface app 110 can use the component model to determine, for example, attributes of a GUI for controlling thestove 104 d, such as, the type of graphical controls to render (e.g., selection boxes, drop down menus, slider bars, etc.). A user can use the GUI on thecomputing device 102 to control the functions of the IoTcapable stove 104 d. For example, upon receiving a user input to a GUI, the IoTdevice interface app 110 can generateappropriate command data 114. Thecomputing device 102 can send thecommand data 114 to thestove 104 d to control, for example, the temperature of one of the burners on thestove 104 d. - In some examples, the IoT
device interface app 110 can include data defining various IoT device component models. For example, standard component models can be integrated into thedevice interface app 110 at a time that theapp 110 is downloaded from theserver system 106, or can be or downloaded from an IoT device library at theserver system 106 at a later time. In some examples, thecomputing device 102 andapp 110 can access IoT device model definitions from a manufacturer's server system (e.g., a manufacturer specific device model) or from an IoT device 104 (e.g., a component model may be included in the characteristic data 112). - In some examples, if the IoT
device interface app 110 is unable to access data defining a particular component model, for example, a manufacturer specific model (e.g., “AdvancedStoveInterface”), the IoTdevice interface app 110 can still control the particular IoT capable device using a standard component model (e.g., “FourBurnerStoveInterface”). In other words, in some examples, IoT devices may be required to support standard component models in addition to any manufacturer or device specific component models. -
FIG. 2A depictsexemplary component models capable stoves Component models stoves capable stoves component models component model 202 is for a standard component model (e.g., “FourBurnerStoveInterface”) andcomponent model 204 is for a manufacturer defined component model (e.g., “AdvancedStoveInterface”). Astandard stove 206 can include four “burner” traits while theadvanced stove 208 includes four “burner” trait types and a “cornRoastingBurner” traits type. Thestandard stove 206 can be controlled only using component model 202 (of the two example component models shown) because it does not include all of the traits expressed in thecomponent model 204. Theadvanced stove 208 can be controlled using eithercomponent model 202 orcomponent model 204 because the advanced stove includes both “burner” and “cornRoastingBurner” traits. - Furthermore, the
component models component models component model 204. - Furthermore, a device maker must specify the mapping between traits of the component models, and traits exposed by the device. This is accomplished through a
device definition 210. Adevice definition 210 specifies, for each trait of a particular device, which component models can be used to reference the trait. Theexample device definition 210 for theadvanced stove 208 provides a detailed mapping between specific traits expressed by theadvanced stove 208 andcomponent models advanced stove 208. Furthermore, in some examples, thedevice definition 210 can serve as a syntax translation between a standardized syntax used by IoT device interface apps, and a syntax used by an IoT device itself. Thedevice definition 210 lists all of the traits expressed by the advanced stove 208 (e.g., four burners and a corn roaster). For each trait of theadvanced stove 208, thedevice definition 210 specifies each component model that can reference the trait. For example, thefirst burner trait 212 can be referenced by either the “FourBurnerStoveInterface”component model 202 or the “AdvancedStoveInterface”component model 204. More specifically thefirst burner trait 212 can be referenced by the “topLeftBurner” trait of either the “FourBurnerStoveInterface”component model 202 or the “AdvancedStoveInterface”component model 204. The cornroasting burner trait 214, however, can only be referenced by the “AdvancedStoveInterface”component model 204. - Furthermore, in order to support devices which may keep track of multiple traits of the same type (e.g. four burners of a stove), traits can be identified by not only their type, but also with an optional device manufacturer provided name or trait suffix. This optional custom name can be referenced as a suffix to the trait type separated by a colon. For example, the
first burner trait 212 is identified as the “smallBurner” while thesecond burner trait 216 is identified as the “largeBurner” in the advancedstove device definition 210. The custom name need not have any semantic relationship to the component models used by the device. - Additionally, the names used in an IoT device interface app need not conform to the custom names used by a device manufacturer. For example, an IoT device interface app can issue a command to set the temperature of the burner trait associated with the “smallBurner” of the
advanced stove 208 by referencing the component model name associated with the “smallBurner” (e.g., “topLeftBurner”) instead of referencing the manufacturer's custom name associated with a specific burner. For example, a command to set the temperature of the top left burner of an advanced stove named “stove1” may be formatted as: -
stove1.topLeftBurner.setTemperature(HIGH); - Thus, the use of component models may be advantageous in allowing apps to be compatible with IoT capable devices manufactured by many different manufacturers while allowing each manufacturer to use different custom naming conventions.
- In some implementations, the
device definition 210 can be included in the device characteristic data provided from the IoT device (e.g.,device 104 a) to a computing device (e.g., computing device 102). - In some examples, component models can be used in an alternative fashion, as described above in reference to the standard four burner
stove component model 202 and the advancedstove component model 204. That is, an IoT device interface app can select one of the twocomponent models advanced stove 208, but would generally not use both. However, when a particular IoT capable device is a combination of two devices (e.g. a combination washer/dryer) the concurrent use of two different component models may be required to control a single IoT capable device, or even a single trait of an IoT capable device. - For example,
FIG. 2B depicts anexemplary device definition 220 for exemplary IoT capable washer-dryer-combo device 222. The washer-dryer-combo device which uses a single lock for both the washer and the dryer. Furthermore, a single lock trait (“lock:xyz”) is referenced by both a “WasherInterface” component model and a “DryerIntreface” component model. In such situations, the component models allow a device manufacturer to share traits between multiple interfaces and maintain synchronization of the shared trait across component models. For example, by using component models to reference device functions, thedevice definition 220 for the washer-dryer-combo device 222 may only define a single lock trait that can be referenced by both the “WasherInterface” component model and the “DryerInterface” component model. Therefore, the state (e.g., locked/unlocked) of the shared lock can be stored in a single variable, thereby, eliminating the need to synchronize separate lock variables for each interface of the combined device (e.g., washer and dryer) that are associated with a single lock on the device. - In some implementations, component models can represent an IoT capable device with multiple traits of the same type where the number of the multiple same type traits is unspecified. For example, as shown in
FIG. 2C , component models can incorporate an array of traits or an array of other component models to represent an unspecified number of the same type of traits.FIG. 2C depicts exemplary component models for a light (light component model 230) and a multi-light device (multi-light component model 232), an IoT capablemulti-light fixture 236, and adevice definition 234 for themulti-light fixture 236. Themulti-light component model 232 includes an unbounded array oflight component models 230. As such, the multi-light component model may be used as a standard type of component model for any multi-light lighting device irrespective of the actual number of light traits included in the device. For example, the multi-light component model could be used for IoT capable chandeliers, track lighting, string lights, etc. Moreover, similar multi-trait or multi-component model arrays can be generated for other types of multiple traits (e.g., an unspecified number of stove burners). - Furthermore, the
device definition 234 provides an example of how a trait or component model array can be implemented for a specific device. For example, thedevice definition 234 for themulti-light fixture 236 exposes the threetraits 238 associated with the three lights of themulti-light fixture 236. Eachlight trait 238 includes an optional custom name (e.g., “one,” “two,” and “three”) to differentiate the light traits within the device itself, and a reference to an array index of the array oflight component models 230 defined by themulti-light component model 232. Eachlight trait 238 can be used to control one of the lights (236 a, 236 b, 236 c) of themulti-light fixture 236. Further, by using the array, an IoT device interface app can interface with any multi-light device, for example, and without requiring information regarding the actual number of lights in the device. For example, when a trait is referenced by a component model that defines an array of traits or component models, the trait can be referenced by an array index instead of a specific name. This allows a manufacturer to provide specific descriptive names to each trait, while, at the same time, permitting an app to address the same traits through an array. - In some implementations, when a trait is referenced by a component model that includes another component model, then the reference should be scoped appropriately. For example, the reference can first identify the property of the top level component model that the trait is indirectly referenced by (e.g., the multi-light component model “MultiLightInterface.lights[0]”), followed by a delimiter (e.g., “I”), followed by the included component model (e.g., the
light component model 230 “LightInterface”) directly referencing the trait (e.g., the “onOff” trait of the light component model 230). - In some implementations, component models can use inheritance to add an advanced trait with additional functionality to a basic trait. For example, as shown in
FIG. 2D , component models can inherit basic traits and add additional traits to provide additional functionality to an IoT capable device.FIG. 2C depicts anoven component model 240 including a basic light component model (“LightInterface”), an advanced dimmablelight component model 242, and adevice definition 244 for an IoTcapable oven 246. For example, the basic light component model may be insufficient to control a dimmable light feature of an IoTcapable oven 246. A “brightness” trait can be added to the basic light component model using inheritance. For example, the dimmablelight component model 242 can be defined to inherit all of the traits of a basic light component model (e.g., an “onOff” trait) and add a “brightness” trait for controlling a dimmable light bulb. - For example, the
oven component model 240 includes a basic light component model (“LightInterface”) and an oven trait (“oven”). Theoven component model 240 may be sufficient for most IoT capable ovens, but when considering an oven that has the ability to dim a light. The dimmablelight component model 242 provides a relationship between the basic light component model and the “brightness” trait in order for an app to access light dimming capability of the IoT capable oven's 246 light. Furthermore, thedevice definition 244 illustrates three traits of the IoTcapable oven 246 that are referenced by theoven component model 240. The “onOff” and “brightness” traits are both referenced by the “OvenInterface.light” trait of theoven component model 240, but they are referenced by different sub-component models. Specifically, the “onOff” trait is referenced by the basic light component model (“LightInterface”), and the “brightness” trait is referenced by the dimmable light component model 242 (“DimableLightInterface”); both of which are sub-component models of theoven component model 240. - In some examples, interfaces can provide a clear and static mechanism for app developers to generate an IoT device interface app capable of interacting with IoT capable devices which is independent from the software models that the devices use to model device states. For example, a computing device can query an IoT capable device for a set of component models that the IoT capable device incorporates in its device definition, including any custom component models (e.g., the device characteristic data discussed above).
- In some implementations, component models are statically defined and can be represented by software libraries that can be linked to an app. Therefore, discovery of the component models supported by a particular IoT capable device can be accomplished by querying the device, as discussed above in reference to
FIG. 1 . Since the variance in IoT capable devices can be expressed by supported component models (e.g., the presence or absence of supported component models), GUIs can be rendered more efficiently in IoT device interface apps. - For example,
FIG. 2E showsGUIs GUI rendering instructions 250. The app can include a preferentialGUI rendering order 260 based on a successive presence of more advanced component models. The IoT device interface app can compare a list of component models supported by a particular IoT capable device (e.g., IoT capable stove 258) and render a GUI that is customized to a selected component model supported by both the app and the device. For example, if both the app and the IoT capable stove support the “AdvancedStoveInterface” component model then the app can renderGUI 252, which provides slider controls 262 for four burners plus a corn roaster. If either the app or the IoTcapable stove 258 does not support the “AdvancedStoveInterface” component model, then the app can render aGUI 254 associated with another commonly supported, but, for example, less advanced component model (e.g., a “FourBurnerStoveInterface” component model). Thus,GUI 254 may only have slider controls 262 for controlling four burners of the IoTcapable stove 258, but not the corn roaster. - In some implementations, all that needs to be communicated from an IoT device to a computing device (e.g., in the device characteristic data) for an app to render an appropriate GUI is the name of the component models supported by a device instead of the device's entire definition. In some implementations, a GUI can include multiple different screens that are shown at different times, for example, as a result of a user providing input to switch from one screen to the next.
- In some implementations, an IoT device interface app can generate a generic GUI for an IoT capable device based on a device definition, for example, if a particular component model is not recognized by the IoT device interface app. For example, an IoT interface app can map different traits included in a device definition to appropriate attributes of a GUI. For example, a Boolean trait (e.g., “onOff”) can be represented and controlled by a check box in the GUI, a trait with an integer range (e.g., “brightness”) can be represented and controlled by a slider bar in the GUI, and a trait having an enumerated variable (e.g., a “burner” trait's settings (OFF, LOW, MED, HIGH)) can be represented and controlled by a dropdown menu in the GUI.
-
FIG. 3 depicts anexample process 300 that can be executed in accordance with implementations of the present disclosure. In some examples, theexample process 300 can be provided as one or more computer-executable programs executed using one or more computing devices. In some examples, theprocess 300 is a computing device executing an IoT device interface app. - A first computing device sends a request to a second computing device for data that describes characteristics of the second computing device (302). The first computing device receives the data that describes the characteristics of the second computing device from the second computing device (304). For example, the data can include data that identifies a first component model of the second computing device, data that identifies multiple traits of the first component model, data that identifies a second component model of the second computing device, and data that identifies multiple traits of the second component model. For example, as described above in reference to
FIG. 1 , the first computing device can request device characteristic data from an IoT capable device. Characteristic data can include, for example, data identifying one or more component models supported by an IoT capable device. The characteristic data can include only names of the supported component models. The characteristic data can include the component models themselves (e.g., as described above in reference toFIG. 2A ). In some implementations, the characteristic data can include a device definition associated with the second computing device, where the device definition identifies the traits of the device and relates the traits to the devices' supported component models (e.g., as described above in reference toFIG. 2A ). - The first computing device determines, based on the received data, whether the second computing device includes the first component model (306). The first computing device determines based on the received data, whether the second computing device includes the second component model (308). For example, the first computing device can determine based on characteristic data for the second computing device whether the second computing device includes the first and second component models. For example, first computing device can identify from a list of component models supported by the second computing device whether the second computing device supports the first and/or the second computing model by identifying the first and/or the second computing model in the list.
- The first computing device generates a graphical user interface (GUI) that is associated with the second computing device based on the first component model (310). For example, as discussed in reference to
FIG. 2E , as a result of the first computing device having determined that the second computing device includes the first component model the first computing device can generate a GUI that includes graphical controls to display or control one of multiple traits associated with the first component model. For example, the first computing device can determine that the second computing device supports only one of the first and second component models and generate a GUI based on only the supported component model. In some examples, the first computing device may determine that both of the first and second component models are supported by the second computing device. In such implementations, the first computing device can select one of the supported component models and generate a GUI based on the selected component model. For example, the first computing device can select between the first and the second component models based on an order of preference among multiple component models. - Further to the descriptions above, in situations in which the systems discussed herein collect personal information about users, or may make use of personal information, a user may be provided with controls allowing the user to make an election as to both if and when systems, programs or features described herein may enable collection of user information (e.g., a user's preferences, a user's IoT capable devices, or a user's current location), and if the user is sent content or communications from a server. In addition, certain data may be treated in one or more ways before it is stored or used, so that personally identifiable information is removed. For example, a user's identity may be treated so that no personally identifiable information can be determined for the user, or a user's geographic location may be generalized where location information is obtained (such as to a city, ZIP code, or state level), so that a particular location of a user cannot be determined. Thus, the user may have control over what information is collected about the user, how that information is used, and what information is provided to the user.
- Implementations of the subject matter and the operations described in this specification can be realized in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Implementations of the subject matter described in this specification can be realized using one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage medium for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. A computer storage medium can be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Moreover, while a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially generated propagated signal. The computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
- The operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
- The term “data processing apparatus” encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations, of the foregoing The apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit). The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.
- A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
- Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random access memory or both. Elements of a computer can include a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few. Devices suitable for storing computer program instructions and data include all forms of non volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- To provide for interaction with a user, implementations of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending webpages to a web browser on a user's client device in response to requests received from the web browser.
- Implementations of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
- The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some implementations, a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) can be received from the client device at the server.
- While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any implementation of the present disclosure or of what may be claimed, but rather as descriptions of features specific to example implementations. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely, various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable sub-combination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a sub-combination or variation of a sub-combination.
- Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the implementations described above should not be understood as requiring such separation in all implementations, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
- Thus, particular implementations of the subject matter have been described. Other implementations are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.
Claims (22)
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/UA2015/000111 WO2017082852A1 (en) | 2015-11-12 | 2015-11-12 | Communicating with devices |
Publications (1)
Publication Number | Publication Date |
---|---|
US20180239316A1 true US20180239316A1 (en) | 2018-08-23 |
Family
ID=55453254
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US15/322,986 Abandoned US20180239316A1 (en) | 2015-11-12 | 2015-11-12 | Communicating with devices |
Country Status (4)
Country | Link |
---|---|
US (1) | US20180239316A1 (en) |
EP (1) | EP3374854A1 (en) |
CN (1) | CN107924301A (en) |
WO (1) | WO2017082852A1 (en) |
Cited By (14)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20180034914A1 (en) * | 2016-07-29 | 2018-02-01 | American Megatrends, Inc. | System and method for controlling heterogeneous internet of things (iot) devices using single application |
US20190289120A1 (en) * | 2015-10-23 | 2019-09-19 | Traeger Pellet Grills, Llc | Cloud system for controlling outdoor grill with mobile application |
US10587482B2 (en) * | 2017-09-18 | 2020-03-10 | International Business Machines Corporation | Discovery of IoT devices |
US10664146B2 (en) * | 2017-01-04 | 2020-05-26 | Amazon Technologies, Inc. | Creation of custom user interface controls that are associated with physical devices |
US10735575B2 (en) | 2015-10-23 | 2020-08-04 | Traeger Pellet Grills, Llc | Mobile application for controlling outdoor grill |
US10735523B2 (en) | 2015-10-23 | 2020-08-04 | Traeger Pellet Grills, Llc | Cloud system for controlling outdoor grill with mobile application |
US10757244B2 (en) | 2015-10-23 | 2020-08-25 | Traeger Pellet Grills, Llc | Cloud system for controlling outdoor grill with mobile application |
US10951751B2 (en) | 2015-10-23 | 2021-03-16 | Traeger Pellet Grills, Llc | Mobile application for controlling outdoor grill |
US10951431B1 (en) * | 2016-09-30 | 2021-03-16 | Amazon Technologies, Inc. | Device registry service |
US11206307B2 (en) | 2015-10-23 | 2021-12-21 | Traeger Pellet Grills, Llc | Cloud system for controlling outdoor grill with mobile application |
US20220021736A1 (en) * | 2015-12-26 | 2022-01-20 | Intel Corporation | Reusable device management in machine-to-machine systems |
US11324357B2 (en) | 2015-10-23 | 2022-05-10 | Traeger Pellet Grills, Llc | Smoke generation cooking system and methods |
US11765261B2 (en) | 2015-10-23 | 2023-09-19 | Traeger Pellet Grills, LLC. | Mobile application for controlling outdoor grill |
US11785130B2 (en) | 2015-10-23 | 2023-10-10 | Traeger Pellet Grills, Llc | Mobile application for controlling outdoor grill |
Families Citing this family (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN108173874B (en) * | 2018-01-29 | 2021-07-16 | 海尔优家智能科技（北京）有限公司 | Intelligent device management method, platform, system, medium and device |
Family Cites Families (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP1205843A3 (en) * | 2000-11-13 | 2004-10-20 | Canon Kabushiki Kaisha | User interfaces |
JP2007519311A (en) * | 2003-12-03 | 2007-07-12 | コーニンクレッカ フィリップス エレクトロニクス エヌ ヴィ | How to enable programming of a universal remote control system |
CN104519395A (en) * | 2014-12-31 | 2015-04-15 | 杭州士兰控股有限公司 | Intelligent home system and visual control method thereof |
-
2015
- 2015-11-12 CN CN201580082462.5A patent/CN107924301A/en active Pending
- 2015-11-12 EP EP15839155.7A patent/EP3374854A1/en not_active Withdrawn
- 2015-11-12 US US15/322,986 patent/US20180239316A1/en not_active Abandoned
- 2015-11-12 WO PCT/UA2015/000111 patent/WO2017082852A1/en active Application Filing
Cited By (22)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11622007B2 (en) | 2015-10-23 | 2023-04-04 | Traeger Pellet Grills, Llc | Cloud system for controlling outdoor grill with mobile application |
US11622008B2 (en) | 2015-10-23 | 2023-04-04 | Traeger Pellet Grills, Llc | Cloud system for controlling outdoor grill with mobile application |
US11206307B2 (en) | 2015-10-23 | 2021-12-21 | Traeger Pellet Grills, Llc | Cloud system for controlling outdoor grill with mobile application |
US11819157B2 (en) | 2015-10-23 | 2023-11-21 | Traeger Pellet Grills, Llc | Smoke generation cooking system and methods |
US10735575B2 (en) | 2015-10-23 | 2020-08-04 | Traeger Pellet Grills, Llc | Mobile application for controlling outdoor grill |
US10735523B2 (en) | 2015-10-23 | 2020-08-04 | Traeger Pellet Grills, Llc | Cloud system for controlling outdoor grill with mobile application |
US10757244B2 (en) | 2015-10-23 | 2020-08-25 | Traeger Pellet Grills, Llc | Cloud system for controlling outdoor grill with mobile application |
US10785363B2 (en) * | 2015-10-23 | 2020-09-22 | Traeger Pellet Grills, Llc | Cloud system for controlling outdoor grill with mobile application |
US11785130B2 (en) | 2015-10-23 | 2023-10-10 | Traeger Pellet Grills, Llc | Mobile application for controlling outdoor grill |
US10951751B2 (en) | 2015-10-23 | 2021-03-16 | Traeger Pellet Grills, Llc | Mobile application for controlling outdoor grill |
US11825010B2 (en) | 2015-10-23 | 2023-11-21 | Traeger Pellet Grills, Llc | Mobile application for controlling outdoor grill |
US11765261B2 (en) | 2015-10-23 | 2023-09-19 | Traeger Pellet Grills, LLC. | Mobile application for controlling outdoor grill |
US20190289120A1 (en) * | 2015-10-23 | 2019-09-19 | Traeger Pellet Grills, Llc | Cloud system for controlling outdoor grill with mobile application |
US11324357B2 (en) | 2015-10-23 | 2022-05-10 | Traeger Pellet Grills, Llc | Smoke generation cooking system and methods |
US11652886B2 (en) * | 2015-12-26 | 2023-05-16 | Intel Corporation | Reusable device management in machine-to-machine systems |
US20220021736A1 (en) * | 2015-12-26 | 2022-01-20 | Intel Corporation | Reusable device management in machine-to-machine systems |
US20180034914A1 (en) * | 2016-07-29 | 2018-02-01 | American Megatrends, Inc. | System and method for controlling heterogeneous internet of things (iot) devices using single application |
US10834586B2 (en) * | 2016-07-29 | 2020-11-10 | Amzetta Technologies, Llc | System and method for controlling heterogeneous internet of things (IoT) devices using single application |
US10951431B1 (en) * | 2016-09-30 | 2021-03-16 | Amazon Technologies, Inc. | Device registry service |
US10664146B2 (en) * | 2017-01-04 | 2020-05-26 | Amazon Technologies, Inc. | Creation of custom user interface controls that are associated with physical devices |
US11356341B2 (en) * | 2017-09-18 | 2022-06-07 | International Business Machines Corporation | Discovery of IoT devices |
US10587482B2 (en) * | 2017-09-18 | 2020-03-10 | International Business Machines Corporation | Discovery of IoT devices |
Also Published As
Publication number | Publication date |
---|---|
WO2017082852A1 (en) | 2017-05-18 |
CN107924301A (en) | 2018-04-17 |
EP3374854A1 (en) | 2018-09-19 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20180239316A1 (en) | Communicating with devices | |
US11438939B2 (en) | Discovery of connected devices to determine control capabilities and meta-information | |
US20160226732A1 (en) | Systems and methods for interaction with an iot device | |
US10861013B2 (en) | Containerization of network services | |
US11228887B2 (en) | Internet of things device hierarchies | |
US10116602B2 (en) | System and methods for device to device control | |
US9306763B2 (en) | Providing a user interface for devices of a home automation system | |
US10444715B2 (en) | Controlling settings and attributes related to operation of devices in a network | |
AU2018365860B2 (en) | Code module selection for device design | |
US10001976B2 (en) | Generation of a device application | |
US10338904B2 (en) | Specialized app development and deployment system and method | |
EP3295649A1 (en) | Method and apparatus for automatic software development for a group of controller-based devices | |
US9396015B2 (en) | Flexible device templates for connected consumer devices | |
US11218855B2 (en) | Managing interaction constraints | |
US20160034596A1 (en) | Method and system for browsing virtual object | |
US20150222691A1 (en) | Hub Application Automation Widget | |
EP2677719A1 (en) | A method for interfacing a communication terminal with networked objects | |
Jain et al. | Getting Started with Home Assistant | |
JP2017158121A (en) | Device controller, information provision method, and device control system | |
Alvarez Rojano | Home Automation System for Rental Properties |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:TOSCANO, ROBERT LOPEZ;SINHA, APARNA BHATNAGAR;KARP, IGOR;AND OTHERS;SIGNING DATES FROM 20160505 TO 20160601;REEL/FRAME:040808/0234 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044567/0001Effective date: 20170929 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: NON FINAL ACTION MAILED |
|
STCB | Information on status: application discontinuation |
Free format text: ABANDONED -- FAILURE TO RESPOND TO AN OFFICE ACTION |