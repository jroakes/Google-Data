US9477452B2 - General purpose software parallel task engine - Google Patents
General purpose software parallel task engine Download PDFInfo
- Publication number
- US9477452B2 US9477452B2 US14/631,618 US201514631618A US9477452B2 US 9477452 B2 US9477452 B2 US 9477452B2 US 201514631618 A US201514631618 A US 201514631618A US 9477452 B2 US9477452 B2 US 9477452B2
- Authority
- US
- United States
- Prior art keywords
- tasks
- task
- new
- job
- data
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
- 238000000034 method Methods 0.000 claims abstract description 69
- 239000013598 vector Substances 0.000 claims description 73
- 238000000354 decomposition reaction Methods 0.000 claims description 66
- 238000012545 processing Methods 0.000 claims description 66
- 239000012634 fragment Substances 0.000 claims description 43
- 239000000872 buffer Substances 0.000 claims description 38
- 239000011159 matrix material Substances 0.000 claims description 23
- 230000001419 dependent effect Effects 0.000 claims description 15
- 238000000638 solvent extraction Methods 0.000 claims 2
- 238000004519 manufacturing process Methods 0.000 claims 1
- 238000005457 optimization Methods 0.000 abstract description 8
- 230000006870 function Effects 0.000 description 26
- 230000008569 process Effects 0.000 description 25
- 238000003491 array Methods 0.000 description 14
- 230000008901 benefit Effects 0.000 description 14
- 238000009877 rendering Methods 0.000 description 12
- VLCQZHSMCYCDJL-UHFFFAOYSA-N tribenuron methyl Chemical compound COC(=O)C1=CC=CC=C1S(=O)(=O)NC(=O)N(C)C1=NC(C)=NC(OC)=N1 VLCQZHSMCYCDJL-UHFFFAOYSA-N 0.000 description 12
- 238000010586 diagram Methods 0.000 description 11
- 230000003068 static effect Effects 0.000 description 11
- 230000000694 effects Effects 0.000 description 10
- 230000009466 transformation Effects 0.000 description 10
- 238000004422 calculation algorithm Methods 0.000 description 9
- 239000003086 colorant Substances 0.000 description 8
- 239000000203 mixture Substances 0.000 description 5
- 238000000844 transformation Methods 0.000 description 5
- 238000013461 design Methods 0.000 description 4
- 239000000463 material Substances 0.000 description 4
- 230000009467 reduction Effects 0.000 description 4
- 230000001133 acceleration Effects 0.000 description 3
- 239000010432 diamond Substances 0.000 description 3
- 230000008030 elimination Effects 0.000 description 3
- 238000003379 elimination reaction Methods 0.000 description 3
- 230000006872 improvement Effects 0.000 description 3
- 238000003860 storage Methods 0.000 description 3
- 238000012360 testing method Methods 0.000 description 3
- 230000001131 transforming effect Effects 0.000 description 3
- 101100285899 Saccharomyces cerevisiae (strain ATCC 204508 / S288c) SSE2 gene Proteins 0.000 description 2
- 238000013459 approach Methods 0.000 description 2
- 230000009286 beneficial effect Effects 0.000 description 2
- 230000008859 change Effects 0.000 description 2
- 238000004040 coloring Methods 0.000 description 2
- 238000004891 communication Methods 0.000 description 2
- 238000010276 construction Methods 0.000 description 2
- 230000003993 interaction Effects 0.000 description 2
- 230000007246 mechanism Effects 0.000 description 2
- 230000008520 organization Effects 0.000 description 2
- 238000005192 partition Methods 0.000 description 2
- 238000004458 analytical method Methods 0.000 description 1
- 238000004364 calculation method Methods 0.000 description 1
- 230000015556 catabolic process Effects 0.000 description 1
- 238000006243 chemical reaction Methods 0.000 description 1
- 230000000295 complement effect Effects 0.000 description 1
- 238000004883 computer application Methods 0.000 description 1
- 230000007717 exclusion Effects 0.000 description 1
- 238000002474 experimental method Methods 0.000 description 1
- 238000007667 floating Methods 0.000 description 1
- 238000009472 formulation Methods 0.000 description 1
- 230000014509 gene expression Effects 0.000 description 1
- 230000008570 general process Effects 0.000 description 1
- 238000009499 grossing Methods 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 230000003278 mimic effect Effects 0.000 description 1
- 230000004048 modification Effects 0.000 description 1
- 238000012986 modification Methods 0.000 description 1
- 238000001579 optical reflectometry Methods 0.000 description 1
- 230000036961 partial effect Effects 0.000 description 1
- 238000002360 preparation method Methods 0.000 description 1
- 238000013139 quantization Methods 0.000 description 1
- 230000002829 reductive effect Effects 0.000 description 1
- 238000002310 reflectometry Methods 0.000 description 1
- 238000011160 research Methods 0.000 description 1
- 230000000717 retained effect Effects 0.000 description 1
- 230000002441 reversible effect Effects 0.000 description 1
- 230000011664 signaling Effects 0.000 description 1
- 238000006467 substitution reaction Methods 0.000 description 1
- 238000012546 transfer Methods 0.000 description 1
- 230000007704 transition Effects 0.000 description 1
- 238000013519 translation Methods 0.000 description 1
- 238000005303 weighing Methods 0.000 description 1
- 238000004804 winding Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/48—Program initiating; Program switching, e.g. by interrupt
- G06F9/4806—Task transfer initiation or dispatching
- G06F9/4843—Task transfer initiation or dispatching by program, e.g. task dispatcher, supervisor, operating system
- G06F9/4881—Scheduling strategies for dispatcher, e.g. round robin, multi-level priority queues
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
- G06F8/45—Exploiting coarse grain parallelism in compilation, i.e. parallelism between groups of instructions
- G06F8/451—Code distribution
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
- G06F8/45—Exploiting coarse grain parallelism in compilation, i.e. parallelism between groups of instructions
- G06F8/451—Code distribution
- G06F8/452—Loops
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3885—Concurrent instruction execution, e.g. pipeline, look ahead using a plurality of independent parallel functional units
- G06F9/3887—Concurrent instruction execution, e.g. pipeline, look ahead using a plurality of independent parallel functional units controlled by a single instruction for multiple data lanes [SIMD]
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/50—Allocation of resources, e.g. of the central processing unit [CPU]
- G06F9/5005—Allocation of resources, e.g. of the central processing unit [CPU] to service a request
- G06F9/5027—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resource being a machine, e.g. CPUs, Servers, Terminals
- G06F9/5038—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resource being a machine, e.g. CPUs, Servers, Terminals considering the execution order of a plurality of tasks, e.g. taking priority or time dependency constraints into consideration
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/52—Program synchronisation; Mutual exclusion, e.g. by means of semaphores
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T1/00—General purpose image data processing
- G06T1/20—Processor architectures; Processor configuration, e.g. pipelining
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T15/00—3D [Three Dimensional] image rendering
- G06T15/005—General purpose rendering architectures
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T17/00—Three dimensional [3D] modelling, e.g. data description of 3D objects
- G06T17/10—Constructive solid geometry [CSG] using solid primitives, e.g. cylinders, cubes
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2209/00—Indexing scheme relating to G06F9/00
- G06F2209/48—Indexing scheme relating to G06F9/48
- G06F2209/483—Multiproc
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2209/00—Indexing scheme relating to G06F9/00
- G06F2209/50—Indexing scheme relating to G06F9/50
- G06F2209/5013—Request control
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2209/00—Indexing scheme relating to G06F9/00
- G06F2209/50—Indexing scheme relating to G06F9/50
- G06F2209/5015—Service provider selection
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2209/00—Indexing scheme relating to G06F9/00
- G06F2209/50—Indexing scheme relating to G06F9/50
- G06F2209/5017—Task decomposition
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T2219/00—Indexing scheme for manipulating 3D models or images for computer graphics
- G06T2219/20—Indexing scheme for editing of 3D models
Definitions
- the present description relates to the field of parallel processing of tasks in computer system.
- the description also relates to the field of software 3D image rendering.
- Parallel Processing Using multiple computer CPUs simultaneously or in parallel, to solve a single problem, or execute a single program, and by doing so, reducing the time required, is an old and well-studied idea. In fact parallel processing is an entire sub-discipline of computer science.
- Any system for accomplishing parallel solution of a problem or execution of a program has two components: A ‘problem decomposition’ strategy or scheme or method, or combination of methods, and an execution vehicle or machine or system.
- the problem must be broken down into multiple parts, and then these parts must be distributed to and executed by the multiple CPUs.
- Problems can sometimes be broken down into parts that are independent, which may be pursued completely in parallel, with no interaction between, or no specific ordering of, sub-programs to be executed on the CPUs required.
- problem decompositions have inter-dependent parts, implicit in the problem, or created by the decomposition.
- Decomposition methods can be sorted into two large categories: decomposition by domain, where the function to be performed remains the same, and the data to be processed is distributed to multiple CPUs, and decomposition by function, where the work to be done on each datum is broken up into sub-functions, and each CPU is responsible for performing its sub-function on all the data.
- Both types of decomposition can be achieved through two major means—implicit or problem-aware, specific, ad hoc means, built into the system, or ‘algorithmic decomposition’.
- algorithmic decomposition the original program, or a representation of that program, which encapsulates the single-CPU, sequential semantics of a solution to the problem, is decomposed into multiple programs.
- CPU sub-programs may be completely independent, or ‘perfectly parallel’, or they may be organized into successive, overlapping, sub-functional stages, as in an assembly line or ‘pipeline’, or there may be any number of dependencies and independences, in any sort of dependency graph.
- Systems of parallel execution of the sub-programs can be classified in terms of their similarity to two opposing models—those that have a central, master unit directing the flow of work, and those that are modeled as a de-centralized network of independent processors. Of course, many systems lie on the line somewhere in between these polar extremes.
- Dynamic Code Generation is a technique whereby code is compiled or prepared for execution dynamically, by a program which will need to call or invoke it. This code is often created at the last possible moment, or ‘just-in-time’. If the code is created only when it is about to be used, it will not be generated if it is never used, and this can represent savings in compilation time and program space. After compilation, the new routine can be retained, or cached, in case it is needed again. The required routine may be called under a particular set of prevailing conditions or with specific arguments that suggest a simpler, more efficient, custom compilation unique to that invocation or set of conditions.
- Dynamic compilation may also allow superior general-purpose optimizations due to facts unknown at the time the program in question was specified, but known at the time of execution.
- Dynamic code generation has often been used in environments where there is no obvious ‘program’ to be compiled, where a fixed function is replaced by a run-time generated, run-time specialized and optimized routine, in order to gain improved performance over statically compiled, necessarily general code. Because the ‘program’ is often not represented in formal semantic terms, or is represented only by the previously compiled, machine code for the function to be replaced, and because of the need to produce new code quickly in a run-time environment, dynamic code generators and optimizers are frequently simple affairs, exploiting high-leverage, problem-aware ad hoc methods or tricks to achieve their ends. In this case, the more high-leverage, informal or implicit, problem-specific information that can be imparted to these code generators, the better they can potentially perform.
- One application in which parallel processing and dynamic code generation may be combined is a three-dimensional graphical image rendering system, or ‘graphics pipeline’.
- Three dimensional (3D) computer graphics display programs simulate, on a two dimensional display, the effect that the display is a window into a three dimensional scene.
- This scene can contain multiple 3D objects, at different apparent distances from the window, and the window has a viewpoint or camera angle with respect to the scene and its objects.
- Objects can be colored and textured, and the objects can seem to be illuminated by light sources of different types and color.
- a software program that models and displays 3D objects can be divided into two parts: an ‘application program’ which relies on a set of high-level functions to manipulate and display graphical data, and a graphics software library that provides these functions
- 3D objects consist of geometric shapes, at certain positions in the 3D world, with certain properties or attributes. These objects are defined and maintained by the application program, as a collection of geometric primitives, and then these primitives are defined and described to the graphics library, which draws, or renders them onto the two dimensional (2D) display, with all necessary positioning, orientation, perspective scaling, coloring, texturing, lighting, or shading effects performed on each primitive as it appears in the window view.
- a software and hardware system that accomplishes this drawing of geometric primitives is called an image renderer, or a rendering ‘engine’, and the series of processing stages used is termed the ‘graphics pipeline’.
- FIG. 1 shows a generic graphics pipeline 100 for a rendering engine according to the prior art.
- Different renderers support different options and features, and use various techniques to perform the required processing at each stage.
- Operations and stages can also be, explicitly or implicitly, performed in different orders in different implementations, while preserving the same apparent rendering model. Stages or portions of stages may be performed to varying degrees by either software or hardware.
- Primitive a collection of points in 3D space forming a point, a line, a triangle, or other polygon, with associated properties.
- Vertex one of the points defining a primitive.
- Object a collection of primitives.
- Normal for a point on the surface of a primitive, a vector defined to be normal or perpendicular to the surface of the primitive at that point.
- Model space a 3D coordinate space in which an individual object is defined, apart from a 3D scene in which it may be placed.
- World space the coordinate space of the 3D scene.
- Viewport or Camera the window, with its associated orientation, position and perspective relative to the scene, through which the 3D scene is apparently being viewed.
- View space the coordinate space of the 3D scene, as seen from the viewpoint of the camera.
- Face a planar polygon in an object, either front-facing (toward the camera), or back-facing (away from the camera).
- Model Transformation scaling and placing an object in the scene, transforming its vertex coordinates from model space to world space.
- Viewing transformation translating (moving, positioning), and rotating (orienting) vertices to account for viewing position and orientation with respect to the scene, transforming vertex coordinates from world space to view space.
- Texture, or texture map an image, which may be designed to visually mimic the surface properties of a physical material.
- Lighting the interaction of light sources of different types and colors, with colors and materials and textures, at vertices.
- Primitive assembly determining primitives as defined by the application, and gathering their component vertex coordinates and attributes, in preparation for further processing.
- Clipping removing primitives or portions of primitives which are not visible, or fall ‘outside’ the field and depth of view of the viewport.
- Projection Transformation creating the 2D projection of points in view space, onto the plane of the viewport or “film” of the camera, transforming spatial coordinates of vertices to 2D display locations and depths.
- Culling removing (deciding not to render) a face of a polygon.
- Vertex Processing vertex coordinate transformations, and lighting of vertices.
- Frame buffer a 2D memory array containing bit patterns encoded in a form which directly represents the colored dots or rectangles on the computer's hardware display screen.
- Pixel a single colored picture element (dot or rectangle) in the frame buffer.
- Fragment or pre-pixel a single colored picture element, located in a 2D image corresponding to the frame buffer, before it is written to the display frame buffer.
- Rasterize to choose the fragments in the 2D projected image that correspond to the outline and/or interior of a primitive.
- Fragment Shading determining the color of a fragment, taking into account vertex colors, lighting, and textures.
- Buffer or Raster operations raster (pixel) operations done on fragments after shading, as they are written to pixels in the frame buffer, or to determine whether or not they should be written, according to a number of tests.
- Fragment processing fragment shading and buffer operations on starting with fragments, and yielding pixels.
- Transform 102 All vertices are transformed from model space to world space, and then transformed to view space, i.e., translated and rotated correctly in order to account for the viewpoint.
- Light 104 Vertices are lighted from different sources, and the resulting color is dependent on the source color and intensity, incidence angle of a directional source with the vertex's normal, distance of the source, the reflectivity of an associated material, and the original vertex color. If the primitive is a polygon, and a texture is to be applied to the face, texture map coordinates are assigned to the vertices.
- Assemble 106 Vertices are assembled into primitives, as they have been defined by the application program.
- Project 108 Primitives are clipped to conform to the field and depth of view, the ‘viewing volume’. They are then projected, possibly with perspective, onto the plane of the viewport, yielding a 2D image, with each vertex position now represented as a 2D display location and a depth. Polygon faces to be culled are discarded, and not processed further.
- Rasterize 110 Primitive fragments corresponding to outlines and interiors are identified in the 2D image. Anti-aliasing′, or modification of fragment colors at outlines of primitives in order to make the outline appear smoother, is done at this stage.
- Shade 112 Primitive fragments are shaded, or colored, according to one of several possible methods, by either interpolating the colors at the vertices of the enclosing primitive or by interpolating from vertex normals and re-lighting the fragments individually. If a texture is to be applied, texture map coordinates are interpolated and assigned to each fragment, and the indicated texture color is mixed in to yield the shaded fragment color.
- Buffer 114 As fragments are converted to pixels and written to the frame buffer, several tests are performed in order to determine whether or not they should be written, in order to allow displaying the image inside a stencil, or window, or rectangle. Hidden surface removal may also be done by recording the depth, or ‘z’ value of a pixel in a ‘z-buffer’, as the pixel is written to the 2D frame buffer. As new pixels are written to the frame buffer, their depth or z value is compared to the z-buffer value of the pixel previously written at that 2D location. If the new pixel is closer to the viewport, it is written, if it is further away than (behind) the old pixel, it is not written.
- Pixel colors may also be blended with the color of pixels already in the frame buffer, depending on the opacity of those colors, in order to simulate transparency of nearer surfaces. Pixel colors may be ‘dithered’ or modified based on their near neighbors as a way of smoothing color transitions or simulating shades. Finally, source and destination pixels in the frame buffer may be combined according to one of several logical operations performed as part of the block transfer (BLT) to the frame buffer.
- BLT block transfer
- FIG. 2 Another view of a graphics pipeline according to the prior art is seen in FIG. 2 .
- this pipeline 200 there are just three stages: ‘Process Vertices’ 202 , ‘Process Primitives’ 204 , and ‘Process Fragments’ 206 .
- FIG. 1 ‘Transform’ (model and view transformations) 102
- FIG. 1 ‘Light’ 104 (lighting) are collapsed into FIG. 2 ‘Process Vertices’ 202 , yielding lighted, 3D position-transformed vertices.
- FIG. 2 ‘Process Primitives’ 204 combines FIG. 1 ‘Assemble’ 106 (primitive assembly), FIG.
- FIG. 1 ‘Project’ 108 clipping, projection, and culling
- FIG. 1 ‘Rasterize’ 110 rasterization
- FIG. 2 ‘Process Fragments’ 206 incorporates FIG. 1 ‘Shade’ 112 (fragment shading and texture application to color fragments), and FIG. 1 ‘Buffer’ 114 (raster or buffer operations), finally yielding pixels 116 in the frame buffer.
- aspects of the ‘Project’ 108 computation may be split across vertex processing and primitive processing. All vertex position transformations, including those due to projection onto multiple depth 2D planes, can be done in ‘Process Vertices’, while those aspects of projection necessary for clipping and final mapping to the viewport are done in ‘Process Primitives’. This may be done in order to group all like position transformations, involving matrix arithmetic on vertex vectors, into one phase. How parts of the logical graphics computations are actually effected in which stages is not of primary importance. More important is that each of the three large stages is concerned with processing associated with one major data type: either vertices, or primitives, or fragments.
- SIMD CPU instructions Many computer CPUs now incorporate SIMD (single-instruction-multiple-data) types of instructions, which can perform certain single operations on multiple data at once. These instructions have been geared toward common low-level operations in the graphics pipeline, and software graphics library implementations can show dramatically improved performance through their use. It is important however, that the library organizes its computations so that data is available and staged accordingly, to take best advantage of these SIMD capabilities.
- SIMD single-instruction-multiple-data
- Multi-core CPUs CPUs are now available with multiple instruction-processing cores, which may run independently of each other. If tasks in the graphics pipeline can be divided and scheduled so that many different operations can be done in parallel, independent threads of execution, this can provide a geometric speed increase over a single program that must perform all the operations in sequence. Multi-core techniques have heretofore seen limited application in software graphics pipeline implementations.
- Hardware GPU functions Many of the functions of a graphics pipeline can be performed by the hardware graphics processing unit, or GPU. GPUs support many fixed-functionality operations, and many also have the capability of running programs locally, independent of the computer CPU. Hardware GPU functions or GPU programs may be considerably faster than their main CPU software counterparts.
- ‘Vertex shaders’ or ‘vertex programs’ can optionally be supplied to the graphics library to perform some or all of the functions of vertex processing.
- ‘Fragment Shaders’ or ‘Pixel Shaders’ can take over much of the job of fragment processing. These programs can be executed by the computer's CPU, or they may run in part or entirely on the hardware GPU. Several standards and languages exist for these vertex and fragment shader programs, which are then compiled for execution on CPU and/or GPU.
- Programmable vertex and fragment processing allow flexibility and specialization in the performance of these operations, allowing new functionality, or higher performance.
- Support for programmable shaders is a required feature in several graphics library definitions, and many compatible implementations exist. However, the compilation of the shader program, the quality of the resulting code, and the use of CPU and GPU resources and their effects on performance, differ considerably from one implementation to another.
- Dynamic code generation is used in various ways in many aspects of existing fixed-function and programmable graphics pipelines, but generation and caching policies, language translation techniques and optimizations, and effectiveness and scope of utility vary with the implementation.
- dynamic code generation is limited to the compilation of application-provided vertex and fragment programs.
- dynamic code is also used to accelerate fixed graphics pipeline functions, there may be some elements of the graphics pipeline implementation which must be implemented in a static fashion, or by separate dynamically created functions, to leave those stages ‘open’ for replacement by either application-provided or GPU-supported functions.
- the ideal case is to have all functions of the graphics pipeline supported by dynamically created code optimized for the specific CPU and GPU capabilities of the computer system.
- Methods of dynamic code generation can be used to create all the software routines necessary to execute the stages of a graphics pipeline. These routines can be more efficient than code that is statically compiled in advance, because they can take advantage of facts that are not known until the time of execution, and because they can be created specifically for the job at hand, and need not satisfy the full range of requirements that their interface and surrounding state might demand of a single, static routine.
- New computers have multiple, independent CPU cores that can execute software routines in parallel.
- the workload of a graphics processing task can be distributed across multiple CPUs, achieving performance acceleration that is linear with the number of CPU cores employed.
- the parallel task engine When the parallel task engine is applied to the problem of graphics processing, in other words, configured as a graphics pipeline engine, it can provide dynamically generated code for all stages of computation, and exploit specific task decompositions that take best advantage of the strengths of dynamic code generation and multiple CPU resources applied to graphics processing, resulting in high speed image rendering.
- a parallel task engine for performing tasks on data.
- the parallel task engine comprising: an input for receiving tasks; a scheduler for decomposing the tasks into one or more new tasks, the decomposing being dependent on at least one policy selected from a given set of policies; a run-time dynamic code generator for generating or locating, from the new tasks, operation routines; a set of job loops, at least one of the job loops for performing the new tasks on at least part of the data by executing the operation routines; the scheduler for distributing and assigning the new tasks to the at least one of the job loops; and the scheduler for making the selection of the at least one policy as a function of characteristics of the operation routines generated or located by the run-time dynamic code generator.
- a method for performing tasks on data comprises: receiving tasks; decomposing the tasks into one or more new tasks, the decomposing being dependent on at least one policy selected from a given set of policies; generating or locating, from the new tasks, operation routines; making the selection of the at least one policy as a function of characteristics of the operation routines generated or located by the run-time dynamic code generator; providing a set of job loops; distributing and assigning the new tasks to at least one of the job loops; and the at least one of the job loops performing the new tasks on at least part of the data by executing the operation routines.
- FIG. 1 is flow diagram depicting a generic graphics pipeline according to the prior art
- FIG. 2 is a flow diagram depicting another, simpler graphics pipeline organization according to the prior art
- FIG. 3 is a block diagram depicting a parallel task engine according to an embodiment
- FIG. 4 is a block diagram showing the composition of a job according to an embodiment
- FIG. 5 is a block diagram showing the composition of a task according to an embodiment
- FIG. 6 is a block diagram showing the composition of a command according to an embodiment
- FIG. 7 is a block diagram showing the cache as a collection of entries, and the composition of those entries according to an embodiment
- FIG. 8 is a block diagram depicting the components of code generation according to an embodiment
- FIG. 9 is a block diagram depicting task (problem) decomposition according to an embodiment
- FIG. 10 is the source code for a routine which performs a full-datum matrix-vector multiplication with SSE3 instructions according to an embodiment
- FIG. 11 is the source code for a routine which performs a half-datum matrix-vector multiplication with SSE3 instructions according to an embodiment
- FIG. 12 is the source code for a routine which performs a specialized half-datum matrix-vector multiplication with SSE3 instructions according to an embodiment
- FIG. 13 is the source code for a routine which performs an optimal half-datum matrix-vector multiplication with SSE2 instructions according to an embodiment
- FIG. 14 is the source code for a routine which performs a pipelined half-datum matrix-vector multiplication with SSE2 instructions according to an embodiment.
- FIG. 15 is a representation of a graphics pipeline consisting of multiple tasks being done by multiple programs, utilizing multiple stage units, according to an embodiment
- FIG. 16 depicts the sub-stages of the primitive setup stage of the graphics processing pipeline according to an embodiment
- FIG. 17 depicts the convex polygon outline rasterization algorithm according to an embodiment
- FIG. 18 depicts alternative approaches to construct polygons covering the fragments of line primitives according to an embodiment
- FIG. 19 is a flow chart depicting the Parallel Task Engine Main Program, according to an embodiment
- FIG. 20 is a flow chart depicting the Job Loop Program, according to an embodiment
- FIG. 21 is a flow chart depicting an alternative Parallel Task Engine Main Sub-program, according to an embodiment.
- FIG. 22 is a flow chart depicting an alternative Job Loop Program, according to an embodiment.
- ‘input Task 302 ’ is a Task 500 , the structure of which is detailed in FIG. 5 , but in this reference, attention is directed to this specific Task in FIG. 3 .
- ‘input Task 302 ’ is a Task 500 , the structure of which is detailed in FIG. 5 , but in this reference, attention is directed to this specific Task in FIG. 3 .
- the same instance of an element will be described with different reference numerals, in order to direct the reader's attention to different aspects of it or operations being performed on it. Numerals do not specify unique structures, nor do they specify the instance of an element being discussed. Elements with the same name have the same structure, and particular instances of elements are specified in the discussion explicitly.
- a Parallel Task Engine 300 is an apparatus for performing Tasks 302 on arrays of Primary Data 306 .
- Primary Data 306 is data external to the apparatus.
- a Task 500 (see FIG. 5 ) is a Command 510 and a collection of one or more Data Pointers 520 , which are POINTERS referencing Primary Data 306 .
- a POINTER is an address, index, or token that can be used to locate a single datum or an array of data, either directly or indirectly via one or more tables.
- a Command 600 (see FIG. 6 ) is an Operation 610 and zero, one or more Parameters 620 .
- An Operation 610 is a value that indicates a specific function to be performed on the Primary Data 306 referenced by the Data Pointers 520 , and Parameters 620 are values that further specify the Operation 610 , for example, a number of data items to be processed.
- Parallel Task Engine 300 is composed of:
- the current CONTEXT which is a set of variables, or a POINTER to a set of variables, containing auxiliary data, modes and details of computations to be performed on the Primary Data 306 to be processed.
- the CONTEXT is only read by the Parallel Task Engine, and not written by it.
- CONTEXT variables are initialized and written by the external software entities that send Tasks 302 to the engine, the “users” of this engine. If the CONTEXT is a POINTER to a set of variables, it points to a set of variables maintained by, and the value of this POINTER is set by, external software entities.
- a Task input 303 to receive input Tasks 302 .
- One or more Job Loops 318 will be allocated per CPU available for use by the Parallel Task Engine 300 in the dispensing of work. It is also possible to run more than one Job Loop 318 on a CPU, or to run a Job Loop 318 on a CPU also running other programs.
- the multiple CPUs, and the computer hardware, software, and operating facilities which allow a software system to establish programs running on multiple CPUs, are those known to persons skilled in the art, and will vary from computer system to computer system.
- the Parallel Task Engine 300 assumes and utilizes these facilities in a particular way, setting up programs on CPUs as necessary in order to dispatch and accomplish Tasks 500 .
- the Job Loop 318 receives a Job 320 , from the Parallel Task Engine Main Program (not shown, but described in detail below).
- a Job 400 is the combination of a Task 420 and a Code Pointer 410 to a routine which can execute an Operation 610 .
- the Job Loop 318 calls the Operation 610 routine, with Parameters 620 , via the Code Pointer 410 , in order to process the Primary Data 306 specified by the Task 420 via its Data Pointers 520 according to the Command 510 specified by the Task 420 .
- the Operation 610 routine returns, the Job Loop 318 will wait to receive the next Job 320 from the Main Program.
- a Code Generator 314 which is responsible for creating or finding Operation 610 routines, which perform Operations 610 on Primary Data 306 , under the current CONTEXT.
- a Cache 316 detailed on FIG. 7 as Cache 700 , which is a Directory 710 composed of Entries 720 , and a Code Buffer 750 .
- the Entries 720 are composed of a Tag 730 to be matched, which consists of an Operation 732 and a Context 734 , and Data 740 , which is a Code Pointer 742 to a routine which performs the Operation 732 .
- a CONTEXT specifies the conditions under which Operations 610 are to be performed, or augments or modifies the meaning of Operations 610 , and thereby influences the generation of code to perform Operations 610 , or influences the execution of that code.
- the Context 734 accompanying the Operation 732 and the Code Pointer 742 to the Operation 732 routine in an Entry 720 is the specific CONTEXT that was current at the time the Operation 732 routine was created or located by the Code Generator 314 , and the Entry 720 was created.
- To find a routine in a Cache 700 to perform an Operation 610 under the current CONTEXT it is necessary to match the specified Operation 610 and the current CONTEXT with the Tag 730 (Operation 732 and Context 734 ) of an Entry 720 .
- the Code Buffer 750 is the repository for storage of Operation 610 routines created dynamically by the Code Generator 314 .
- a Scheduler 312 which when requested, surveys the Task Pool 310 of Tasks 500 , and determines the appropriate Task 500 to assign to a specified Job Loop 318 .
- the Scheduler 312 is responsible for decomposing Tasks 905 as necessary, maintains the Task Pool 310 , maintains a record of Tasks 500 in progress on the Job Loops 318 , and understands the dependencies between Tasks 500 .
- a Parallel Task Engine Main Program which directs the operation of the engine, and communicates with the Job Loops 318 .
- the Main Program dispenses Jobs 320 to Job Loops 318 .
- the Main Program gets the Task 420 for the Job 320 from the Scheduler 312 , and looks up the Code Pointer 410 for the Job 320 by matching the Operation 610 in the Command 510 in the Task 420 , and the current CONTEXT, to the Tag 730 of an Entry 720 in the Directory 710 of the Cache 316 . If the proper Code Pointer 410 for the Operation 610 cannot be found in the Cache 316 Directory 710 , the Main Program calls the Code Generator 314 to create or find a suitable routine, and then creates a Directory 710 Entry 720 for future reference.
- All elements of the Parallel Task Engine 300 operate under, and may read from the current CONTEXT, including the Operation 610 routines executed by the Job Loops 318 . Only Operation 610 routines actually access the Primary Data 306 for which the engine is configured to process. The rest of the Parallel Task Engine 300 is concerned with dispensing Jobs 320 to the Job Loops 318 .
- Job 400 , Task 500 , and Command 600 data structures are ‘nested’ structures—they could each be represented by other structures that incorporate the same basic information in a less hierarchical form—the exact form of these data structures is not relevant to the essential operation of the Parallel Task Engine 300 , other representations of the same information would serve as well—these forms were chosen because they represent a unit of work or a key aspect of that work at the level at which they are created or utilized.
- Step 1901 Initialize the Cache 316 Directory 710 Entries 720 , making all the Tags 730 ‘un-matchable’, (perhaps by loading Context 734 with a value that will never match any current CONTEXT).
- Step 1902 Set up multiple Job Loops 318 , according to CPUs of different numbers and types available. For each Job Loop 318 , set REQUEST and DISPATCH counts to zero. These counts are integers, which may be of any width, including 1 bit. Each Job Loop 318 also has an incoming Job 320 POINTER variable. Start the Job Loops 318 on the CPUs (Job Loop 318 detailed below).
- Step 1903 Set L, an integer variable, to 0.
- Set N an integer variable, to the number of Job Loops 318 .
- L represents the index of the Job Loop 318 under consideration in steps 1904 through 1910 , below, and ranges from 0 to N—1.
- Step 1904 Inspect Job Loop 318 L's REQUEST count. If it is the same as the DISPATCH count, go to step 1910 .
- Step 1905 Call the Scheduler 312 to pick a Task 500 for Job Loop 318 L, and remove it from the Task Pool 310 . If necessary, the Scheduler 312 will decompose a Task 905 and place the new Tasks 940 in the Task Pool 310 , before picking a Task 500 for the Job Loop 318 , which it returns to the Main Program via a POINTER. If no Task 500 can be found, go to step 1910 .
- Step 1906 Look in the Cache 316 Directory 710 for an Entry 720 with a Tag 730 that matches the Operation 610 specified by the Task 500 and the current CONTEXT. If a matching Entry 720 is found, go to step 1908 .
- Step 1907 Call the Code Generator 314 to create or find a routine for the Operation 610 under the current CONTEXT. Create an Entry 720 in the Cache 316 Directory 710 containing the specified Operation 610 in Operation 732 , the current CONTEXT in Context 734 , and a pointer to the Operation 610 routine in Code Pointer 742 . Go to Step 1906 .
- Step 1908 Compose the Scheduler 312 in Task 420 , and the matching Entry 720 Code Pointer 742 in the Scheduler 312 in Task 420 , and the matching Entry 720 Code Pointer 742 in Code Pointer 410 , and place a POINTER to Job 320 in Job Loop 318 L's incoming Job 320 variable.
- Step 1909 Set Job Loop 318 L's DISPATCH count to the value of its REQUEST count.
- Step 1910 Increment L. If L is less than N, go to step 1904 .
- Step 1911 Pull the next input Task 302 from the Task input 303 , if there is one, and place it in the Task Pool 310 . Go to step 1903 .
- Step 2001 Increment this Job Loop's 318 REQUEST count.
- Step 2002 Inspect this Job Loop's 318 DISPATCH count. If it is not the same as the REQUEST count, go to step 2002 (repeat this step).
- Step 2003 From the incoming Job 320 POINTER variable, get the Job 320 to do. Call the Operation 610 routine, via the Code Pointer 410 with Parameters 620 , to process the Primary Data 306 as specified by the Task 420 Data Pointers 520 , according to the Command 510 of the Task 420 . Go to step 2001 .
- Both the Main Program and the Job Loops 318 are polling loops. When there is no work to do, both programs ‘spin’ or are ‘busy waiting’.
- a first improvement to this implementation, in a program environment that supports it, would be to cause the Main Program and Job Loops 318 to block or sleep when there are no input Tasks 302 to decompose or dispatch, and no Jobs 320 to do, and to resume operation when input Tasks 302 and Jobs 320 arrive. This would make more efficient use of any CPU that is shared by multiple programs.
- the Job Loops 318 may incorporate and call a version of the Main Program directly. In this case it is necessary to ensure that multiple Job Loops 318 have mutually exclusive access to the Main (sub) Program. This can be done by using operating system software facilities, atomic read-modify-write CPU instructions, or through any one of several software mutual exclusion algorithms, such as Dekker's algorithm, or Peterson's algorithm.
- the Main Program becomes a sub-program or subroutine which executes according to the following procedure:
- L an integer variable
- Step 2101 Call the Scheduler 312 to pick a Task 500 for Job Loop 318 L, and remove it from the Task Pool 310 . If necessary, the Scheduler 312 will decompose a Task 905 and place the new Tasks 940 in the Task Pool 310 , before picking a Task 500 for the Job Loop 318 , which it returns to the Main Program via a POINTER. If a Task 500 is found, go to step 2103 .
- Step 2102 Pull the next input Task 302 from the Task input 303 , if there is one, and place it in the Task Pool 310 . If there was an input Task 302 , go to step 2101 . If there was no input Task 302 , go to step 2106 .
- Step 2103 Look in the Cache 316 Directory 710 for an Entry 720 with a Tag 730 that matches the Operation 610 specified by the Task 500 and the current CONTEXT. If a matching Entry 720 is found, go to step 2105 .
- Step 2104 Call the Code Generator 314 to create or find a routine for the Operation 610 under the current CONTEXT. Create an Entry 720 in the Cache 316 Directory 710 containing the specified Operation 610 in Operation 732 , the current CONTEXT in Context 734 , and a pointer to the Operation 610 routine in Code Pointer 742 . Go to Step 2103 .
- Step 2105 Compose the Job 320 as a Job 400 with the Task 500 from the Scheduler 312 in Task 420 , and the matching Entry 720 Code Pointer 742 in Code Pointer 410 , and place a POINTER to Job 320 in Job Loop 318 L's incoming Job 320 variable.
- Job Loop 318 which calls the Main (sub) Program is detailed below.
- Step 2201 If this is the first Job Loop 318 , initialize the Cache 316 Directory 710 Entries 720 , making them ‘un-matchable’.
- Step 2202 If this is the first Job Loop 318 , set up multiple other Job Loops 318 , according to CPUs of different numbers and types available. Each Job Loop 318 has an incoming Job 320 POINTER variable. Start the other Job Loops 318 on the CPUs.
- Step 2203 Obtain exclusive access to the Main (sub) Program.
- Step 2204 Call the Main (sub) Program.
- Step 2205 Yield exclusive access to the Main (sub) Program.
- Step 2206 If there is no Job 320 to do, go to step 2203 .
- Step 2207 From the incoming Job 320 POINTER variable, get the Job 320 to do. Call the Operation 610 routine, via the Code Pointer 410 with Parameters 620 , to process the Primary Data 306 as specified by the Task 420 Data Pointers 520 , according to the Command 510 of the Task 420 . Go to step 2203 .
- the Code Generator 314 is an element of the Parallel Task Engine 300 .
- the design of any particular Code Generator 314 , and the specific methods by which the Code Generator 314 accomplishes its work will vary according to the specifics of the embodiment
- the way in which a Code Generator 314 , fulfilling the requirements detailed below, is used by the Parallel Task Engine 300 , as described above, and as will be detailed further in the exposition of specific applications, is part of an embodiment, and its application of techniques of dynamic code generation.
- the Code Generator 314 may ‘generate’ an Operation 810 routine in one of two ways:
- Operation 810 routines may have ‘canned’, statically compiled (Locate Static Code 830 ) Operation 810 routines, or fragments of Operation 810 routines, which may be used as-is, or concatenated together, to form Operation 810 routines.
- Method 2 extends the notion of Code Generator 314 to a function which simply looks up a static Operation 810 routine in a table—for the purposes of the description, this style of code ‘generation’ is sufficient.
- the Code Generator 314 must also have the capability of ‘specializing’ the code generated, by the CONTEXT outstanding at the time of generation, resulting in an Operation 810 routine specifically generated for use in that CONTEXT.
- the Code Generator 314 may generate custom code that assumes these values. Again, this may be done as simply as modifying a table look-up of the Operation 810 requested by adding elements from the CONTEXT to the index into the table, returning the proper, more specific static routine.
- the Code Generator 314 may also contain a general Optimizer 840 , which can accept as input, generated (Locate Static Code 830 or Synthesized 820 ) Operation 810 routines, or meta-code representations of those routines, and output more efficient routines or meta-code representations.
- Optimization techniques well-known in the art include constant-folding, reductions in strength, dead store elimination, common sub-expression elimination, copy propagation, instruction combination, branch chaining and elimination, loop unrolling and loop-invariant code motion, and global register allocation. These techniques and others may be used by an Optimizer 840 .
- the Code Generator 314 may also use the Optimizer 840 in order to accomplish specialization of a Synthesized 820 or static routine. For example, if a generic Operation 810 routine computes four values as output, but a more specific sub-Operation 810 requires only one value as output, the Code Generator 314 may select the generic routine, and pass it to the Optimizer 840 , informing the Optimizer 840 that the three unwanted values are to be considered dead stores. The Optimizer 840 will then create the specialized, one-value-computing routine.
- the Code Generator 314 when generating new Operation 610 routines, will store the code contents of these routines to the Cache 316 Code Buffer 750 . Because that storage space is finite, it will eventually be exhausted, and require some existing code to be overwritten, destroying some Operation 610 routines that reside in the Code Buffer 750 . How storage space is managed in this buffer is an implementation detail. However it is required that the Code Generator 314 invalidate, or make un-matchable, any Cache 316 Directory 710 Entries 720 with Code Pointers 742 that reference code that has been overwritten, at the time that the corresponding Operation 610 routines are destroyed.
- Scheduler Alternate embodiments may pursue different strategies or policies, as appropriate for the particular application of the Parallel Task Engine 300 , but there are basic functions that all Scheduler 312 implementations must perform, and there are certain constraints that must be observed.
- the Scheduler 312 maintains the Task Pool 310 of outstanding Tasks 500 , and keeps a record of the Task 500 in progress on each Job Loop 318 .
- the Scheduler 312 may, but is not required to, keep additional information, such as: 1.
- Any other statistics or auxiliary information that may assist the Scheduler 312 in its work.
- the Scheduler 312 has one function, as called from the Main Program—to remove a Task 500 from the Task Pool 310 , and assign it to a Job Loop 318 , returning that Task 500 to the Main Program, which will compose a Job 400 consisting of a Task 420 and an Operation 610 routine Code Pointer 410 , and pass this Job 320 to the Job Loop 318 . In the process of doing so, it may decide to decompose a Task 905 into other Tasks 940 , adding the Tasks 940 to the Task Pool 310 , before choosing and assigning the Task 500 to the Job Loop 318 .
- the Scheduler 312 from FIG. 3 may use one of three policies to decompose a Task 905 :
- the Task 905 can be effected by one or more Tasks 940 which each applies sub-FUNCTIONS or sub-Operations 610 , to the indicated Primary Data 306 . If the sub-Operations 610 must be applied sequentially, the original Task 905 becomes new Tasks 940 which form a pipeline. If the Operations 610 are independent, they may be dispatched in parallel. The new Operations 610 and Tasks 940 may have arbitrary dependencies, allowing some to be dispatched in parallel or in arbitrary order, and requiring some to be dispatched only after the completion of others. The new Tasks 940 reference the same Primary Data 306 , but have different Commands 510 (Operations 610 and Parameters 620 ).
- the Command 510 can be effected by independently applying the Operation 610 to different sub-sets or domains of the Primary Data 306 .
- One Task 905 becomes one or more independent Tasks 940 , which may be executed in parallel
- the new Tasks 940 all contain the original Operation 610 , but the Parameters 620 and/or Data Pointers 520 are modified to assign different Primary Data 306 domains to each new Task 940 .
- By-Component 930 An Operation 610 is defined to operate on arrays of data, in other words, one or more data items, which are atomic from the point of view of the Operation 610 .
- By-Component 930 decomposition of Tasks 905 divides the Primary Data 306 to be processed, or the new Primary Data 306 to be computed, into domains which are ‘sub-atomic’ or sub-components of the data processed by the original Operation 610 , effecting the original Operation 610 by one or more component Operations 610 .
- These component Operations 610 and the resulting Tasks 940 may or may not have inter-dependencies.
- By-Component 930 decomposition is a combination of methods 1 and 2, it is decomposition By-Domain 925 , below the level of an Operation 610 's natural atomic datum, in order to get, or resulting in, decomposition By-Function 920 .
- the Scheduler 312 can achieve ordinary decomposition of Tasks 905 By-Domain 925 , by simply modifying a Task's 905 Data Pointers 520 or Parameters 620 . Likewise, in order effect decomposition of Tasks 905 By-Function 920 , the Scheduler 312 can simply create the requisite Tasks 940 with sub-Operations 610 . These new Operations 610 naturally suggest new Operation 610 routines, with new code. However, as described above, the Code Generator 314 may decide that the sub-Operation 810 routine code is best generated by optimizing or specializing more general Operation 810 code. In this case, the Parallel Task Engine 300 can be said to use the Optimizer 840 to accomplish functional Task 905 division by ‘algorithmic decomposition’.
- the Scheduler 312 may use any sort of ordering to choose the next Task 500 , e.g. first-come-first-served, starting the largest jobs first, finishing related Tasks 500 before others, etc., but certain rules must be followed:
- the Scheduler 312 at the time it decomposes Tasks 905 , knows the dependencies that it creates between Tasks 940 as it creates new Tasks 940 from other Tasks 905 . It records and respects these dependencies, and will not choose to start or assign a Task 500 whose dependencies have not been fulfilled (Tasks 500 on which the Task 500 depends must have completed—this means that no Tasks 500 on which it depends still reside in the Task Pool 310 or are in progress on one of the Job Loops 318 ).
- the Task 500 dependencies, for any Task 500 are simply a list of other Tasks 500 that the Task 500 is dependent on.
- Dependency lists may be associated with the Task 500 , or may be kept in a table, indexed by a Task 500 number, or may be kept by the Scheduler 312 in some other way.
- a Task 500 is either in the Task Pool 310 unassigned, or assigned to one (1) Job Loop 318 . It cannot be assigned to two or more Job Loops 318 , and it cannot both be assigned and waiting to be assigned. Once assigned, it will stay with the Job Loop 318 until it is completed, at which time it ceases to exist.
- a Task 500 ‘A’ is understood to be completed when the Main Program asks the Scheduler 312 for a new Task 500 for the Job Loop 318 which was assigned the Task 500 ‘A’.
- the Scheduler 312 updates (removes) dependencies (Task 500 indicators on a list of Tasks 500 that a Task 500 is waiting on) from Tasks 500 dependent on the completed Task 500 .
- step by step description details the operation of one implementation of the Scheduler 312 .
- Step 1 The Main Program has asked the Scheduler 312 for a Task 500 for a specific Job Loop 318 . If the Job Loop 318 was not previously assigned a Task 500 , go to step 3.
- Step 2 Because the Job Loop 318 has now requested a Job 320 from the Main Program, and the Main Program has asked the Scheduler 312 for a Task 500 for the Job Loop 318 , this means that the Job Loop 318 has now completed any Task 500 previously assigned to it. Look through the Task Pool 310 and for each Task 500 , update the lists of other Tasks 500 that they are dependent on, by removing the Task 500 that this Job Loop 318 has just completed, from those lists.
- Step 3 Choose a Task 500 .
- the choice of Task 500 can be according to any number of policies, but must be a Task 500 with no outstanding dependencies on other Tasks 500 .
- This Task 500 may be a Task 500 that the Scheduler 312 can decompose, or it may not be.
- the Scheduler 312 understands which Commands 510 and Operations 610 allow decomposition by different means.
- the Scheduler 312 may also make decisions to decompose Tasks 500 or not based on available CPU resources, or the number of Job Loops 318 currently occupied with Tasks 500 . If the chosen Task 500 is not to be decomposed, go to step 5.
- Step 4 Decompose the Task 905 by one of the three means described above—By-Function 920 , By-Domain 925 , or By-Component 930 . Place all of the new Tasks 940 in the Task Pool 310 . Go to step 3. Note that Tasks 905 should not be infinitely decomposable, there should be a finite number of data By-Domain 925 partitions possible, and a finite number of Operations 610 and sub-Operations 610 .
- Tasks 905 should not be decomposed into the same Task 940 , or into chains of Task 905 decompositions that eventually lead back to the original Task 905 , or the Scheduler 312 may get stuck in this loop—but this is an implementation detail, part of the policies and strategies chosen, and definition of Commands 510 and Operations 610 , made by the implementor when applying the Parallel Task Engine to a specific problem.
- the Scheduler 312 may decompose a particular problem with little knowledge of it, an almost ‘blind’ or automatic decomposition.
- the Scheduler 312 need only know which Operations 610 are composed of which other Operations 610 in sequence, to perform a By-Function 920 decomposition, with dependencies among the new Tasks 940 set so that the new Operations 610 are performed in order on the same Primary Data 306 .
- By-Domain 925 decomposition can be done on any Task 905 by adjusting Data Pointers 520 or the Parameters 620 for an Operation 610 .
- the Code Generator 314 may or may not have ‘canned’ (Locate Static Code 830 ) specific Operation 610 routines, and it may have to Synthesize 820 new routines. Or it may Optimize 840 a more generic routine to get the appropriate partial datum routine. This general process, especially with code specialized and optimized under specific CONTEXTS, would seem to know more about a problem than it does—in reality it only need know Operation 610 rewriting rules.
- the Scheduler 312 can make run-time decomposition choices based on the quality of code generated by the Code Generator 314 , in the Main Program procedures as described above, with no change necessary to those procedures. Generated code quality is simply another input to the Scheduler's 312 decomposition strategy.
- the Scheduler 312 can try a number of Operation 610 re-writings in terms of new Operations 610 . It can request (independently of the Main Program's call to the Code Generator 314 ) the Code Generator 314 to generate code for the Operations 610 considered.
- the Code Generator may return statistics to the Scheduler 312 , or the Scheduler 312 may analyze the code itself.
- Operation 610 routines will be created differently by the Code Generator 314 at different times, depending on the CONTEXT, and the Scheduler 312 will make different decomposition decisions accordingly.
- the Scheduler 312 uses the Code Generator 314 in order to effect ‘dynamic problem decomposition’.
- Example Applications demonstrate the use of the Parallel Task Engine design and scheme of computation to provide solutions to specific computational problems, using dynamic code generation, in a multi-CPU environment.
- Matrix-Vector Multiplication A matrix K, with M rows and N columns, may be multiplied by a column vector V, with N rows, to get a column vector P, with N rows.
- Element “I” of P is the vector dot product of row I of matrix K with the vector V. Or, assuming rows are numbered 0 to M ⁇ 1 and columns 0 to N ⁇ 1:
- Matrix-vector multiplication of this sort comprises a linear transformation of the vector V by the function represented by the matrix K, and has many applications in various domains of computation.
- FIG. 10 shows a routine, written in Intel x86 assembly language, using the SSE3 instruction set extensions, which loops through vector data, multiplying these vectors by a constant matrix, and creating an output set of vectors.
- the semantics of the individual Intel x86 instructions are defined in the Intel Architecture Software Developer's Manual .
- This routine computes the multiplication of a 4 ⁇ 4 matrix with a 4 ⁇ 1 (4 row, 1 column) vector. All matrix and vector elements are double precision (64 bit) IEEE 754 format floating point numbers.
- the loop body computes two row-vector dot products at a time, using the HADDPD (Horizontal ADD Packed Double-precision) instruction and then does the next two.
- HADDPD Horizontal ADD Packed Double-precision
- a Parallel Task Engine software system can be constructed to perform matrix-vector multiplication, starting from the program in FIG. 10 as the template for a generic Operation 610 routine.
- Commands 510 /Operations 610 /Tasks 302 Operation 610 MATVEC4 ⁇ 4-Multiply a 4 ⁇ 4 matrix by a 4 ⁇ 1 vector, for all the vectors in an input array, computing product vectors, which are stored in an output array (as in the routine in FIG. 10 ).
- a Command 510 specifying this Operation 610 is Parameterized 620 by the number of vectors to process, the offset in bytes from the beginning of the array of the first input vector and first output vector to process, and an offset mask, which is the ((number of vectors to process multiplied by the vector size in bytes) ⁇ 1).
- Data Pointers 520 are provided in the enclosing Task 500 to specify the base addresses of the input and output vector arrays.
- Operation 610 XY_MATVEC4 ⁇ 4, and Operation 610 YZ_MATVEC4 ⁇ 4 These Operations 610 are sub-Operations 610 of MATVEC4 ⁇ 4, and Tasks 905 with MATVEC4 ⁇ 4 Operations 610 may be decomposed into one Task 940 each with XY_MATVEC4 ⁇ 4 and YZ_MATVEC4 ⁇ 4 Operations 610 . These Operations 610 compute (only) either the x and y (0 and 1), or y and z (2 and 3) elements of the four element product vector, in the matrix-vector multiply of the MATVEC4 ⁇ 4 Operation 610 .
- a Command 510 specifying either of these Operations 610 is Parameterized 620 by the number of vectors to process in this Task 500 , the starting offset of vectors input and output in this Task 500 , and the offset mask from the full-datum Task 500 from which it was decomposed.
- the Data Pointers 520 are copied from the full-datum Task 500 into these half-datum sub-Tasks 500 .
- the machine receives MATVEC4 ⁇ 4 Tasks 302 (Tasks 302 with Commands 510 with Operation 610 of MATVEC4 ⁇ 4) from the outside world, and processes them; that is its sole function. It decomposes and dispatches these Tasks 302 or sub-Tasks 500 as it deems necessary in a one, two, or four CPU environment.
- the matrix used for the matrix-vector multiplication is part of the CONTEXT.
- the Scheduler 312 for this matrix-vector multiplying machine has the following policies:
- Tasks 302 are received at the Task input 303 , they are placed in the Task Pool 310 in a linked list, such that new Tasks 500 are placed at the end of the list. Tasks 500 are assigned to Job Loops 318 (after being decomposed, if the Scheduler 312 chooses to do so) from the front of the list.
- FIFO First-in, First-out
- the Scheduler 312 will not decompose MATVEC4 ⁇ 4 Tasks 500 . If there are two CPUs present, the Scheduler 312 will decompose MATVEC4 ⁇ 4 Tasks 905 By-Component 930 to get XY_MATVEC4 ⁇ 4 and YZ_MATVEC4 ⁇ 4 Tasks 940 (Tasks 940 with Commands 510 with Operations 610 which are XY_MATVEC4 ⁇ 4 and YZ_MATVEC4 ⁇ 4).
- XY_MATVEC4 ⁇ 4 and YZ_MATVEC4 ⁇ 4 Tasks 905 are further decomposed By-Domain 925 , splitting the XY Task 905 into two XY sub-Tasks 940 , and the YZ Task 905 into two YZ sub-Tasks 940 , each responsible for half of the vectors covered by the larger Task 500 from which it was decomposed.
- a MATVEC4 ⁇ 4 Task 302 becomes 1, 2, or 4 Tasks 500 , for 1, 2, or 4 CPUs.
- Decomposed Tasks 940 replace the original Task 905 in the same position on the linked list of Tasks 500 in the Task Pool 310 —in other words, one MATVEC4 ⁇ 4 Task 500 in the second position from the head of the linked list can become XY_MATVEC4 ⁇ 4 and YZ_MATVEC4 ⁇ 4 Tasks 500 in positions 2 and 3 , in front of the Task 500 that was previously at position 3 .
- the Code Generator 314 for this MATVEC4 ⁇ 4 engine operates as follows:
- the MATVEC4 ⁇ 4 Operation 810 routine is as shown in FIG. 10 . It can be used unchanged for a MATVEC4 ⁇ 4 operation.
- the XY_MATVEC4 ⁇ 4 Operation 810 routine is shown in FIG. 11 . It can be used directly, or it could also be derived from the MATVEC4 ⁇ 4 routine by applying the Optimizer 840 —note that when the z and w components are considered dead, all of the instructions that contribute to the computation of these values (the last 12 instructions in the second half of the loop body) can be eliminated. Once these instructions are eliminated, the four matrix-row register loads in the second half of the loop body become redundant, and the first four loads of these values to registers, which are now constant over the loop, can be moved outside the loop.
- the YZ_MATVEC4 ⁇ 4 Operation 810 routine is symmetrical to the XY routine, and is of the same length.
- the XY_MATVEC4 ⁇ 4 and YZ_MATVEC4 ⁇ 4 Operation 810 routines can be specialized by knowledge of the constant matrix, in the CONTEXT, that is used over the routine.
- Operation 610 routine look-ups in the Cache 326 Directory 710 will fail, and new Operation 610 routines must be generated, and new Entries 720 created.
- the Code Generator 314 will take note of which matrix elements are zero and nonzero.
- FIG. 12 shows a routine that has been specialized with such knowledge of matrix zero elements. It can be derived from XY and YZ routines as shown in FIG. 11 , by using the Optimizer 840 to systematically apply simple substitutions and rules, as noted in the comments accompanying the code.
- FIG. 13 shows an extremely optimized version of the XY_MATVEC4 ⁇ 4 Operation 810 routine, specialized with the same matrix knowledge as in FIG. 12 . Achieving this code is challenging, but possible for an Optimizer 840 . It represents a dramatic example of the possible performance advantage of specialized, optimized, decomposed Operation 810 routines.
- the MATVEC4 ⁇ 4 engine will basically operate as follows:
- MATVEC4 ⁇ 4 Tasks 302 will arrive at the Task input 303 .
- the engine will dispatch the Tasks 500 to the Job Loops 318 in order.
- Job Loops 318 will execute either:
- Performance of the MATVEC4 ⁇ 4 Parallel Task Engine In the case of CPU/Job Loop 318 , the performance of a Parallel Task Engine implementation of MATVEC4 ⁇ 4 Operations 610 on arrays of vector data is substantially the same as simply calling the Operation 610 routine directly—there is a very small amount of overhead for SCHEDULING and communication, but the processing of the Primary Data 306 is unchanged.
- this processing consists of 32 instructions, 12 memory reads, and 2 memory writes, in the body of the loop, in order to compute one complete product vector.
- the instructions ahead of the loop and at the very end of the loop, which update offsets and loop count, are not counted.
- the instructions ahead of the loop are not counted because they are executed once per routine, and with a large number of vectors to be processed, the time spent in the loop will represent almost all the time spent in the routine.
- the reason the instructions at the end of the loop should not be counted is that this loop may easily be ‘unrolled’ that is, the body of the loop may be duplicated some number of times, and the offset and loop count updates may be amortized over the entire resulting loop body.
- the metrics for comparison include the length in instructions of the core loop body, and the quantity of results achieved by that code. It is also possible, for any particular CPU and computer system, to estimate or measure the actual time in CPU clock cycles for a small ‘kernel’ computation such as this, but the cycle counts for instructions on different models of CPU vary. For any one CPU, however, given a base routine using particular instruction set features, routines with shorter core sequences will in general be faster. As long as these shorter routines do not use ‘extra’ CPU features that would have also been useful in the base routine, these are fair comparisons.
- Operation 610 routines can be re-ordered, or scheduled, in particular ways for particular CPU models, and this can improve the performance of this code on a particular CPU.
- Instructions can have various latencies (time to creation of results), but another instruction may start execution before a previous instruction has completed, as long as the later instruction does not require the results of the previous instruction. So instruction execution may be overlapped, and instructions can be re-ordered to take advantage of this overlap. Instructions may only be re-ordered insofar as long as they preserve the semantics of the original sequence—in other words, data dependencies and the essential computations must remain the same in the re-scheduled code.
- XY_MATVEC4 ⁇ 4 and YZ_MATVEC4 ⁇ 4 Operations 610 will be used.
- the core of the loop is 12 instructions, with two memory reads, and 1 memory write. Because it is only computing the x and y components of the output vector, only the first two rows of the matrix are required, and the four registers containing the first two rows may be loaded ahead of, and remain constant throughout, the loop. In 12 instructions two of the four components of the output vector are computed.
- the YZ Operation 610 routine is symmetrical, and performs the same intrinsic computations. This scheme of computing two components at a time results in a more efficient loop body.
- Double the cache misses will occur if XY and YZ routines are executed in sequence on a single CPU, unless the original MATVEC4 ⁇ 4 Task 302 was first decomposed By-Domain 925 into a series of small vector batches (which could be done without the Parallel Task Engine, by simply nesting an XY loop and a YZ loop in an outer loop, or could also use a Parallel Task Engine configured for this application, to do the decomposition, even with one CPU).
- any single CPU has a limited size data cache, and two CPUs of the same model will have twice the data cache, and this can be exploited.
- An XY and a YZ Task 500 can be dispatched to different CPUs, and in this case, each CPU will see roughly the same number of cache misses as a single CPU running the full-datum routine of FIG. 10 (or less, because the matrix rows are not reloaded), but enjoy the 25% reduction in loop body length, and the factor of three reduction in memory reads.
- Each XY or YZ loop does half as much work, but it is more than twice as fast, and so using two CPUs in this fashion is faster than using two CPUs and decomposing a MATVEC4 ⁇ 4 Task 905 simply By-Domain 925 , giving half the full-datum computations to each processor (which, of course, can be done with the Parallel Task Engine).
- the number of input data reads done by the CPUs in combination may be more than the number of reads done by full-datum routines on the same number of CPUs (although this is not the case in the current example, due to the dearth of registers, and the requirement to reload the input vectors, in the full-datum routine), and this may be how we “pay” for the extra registers available in partial-datum routines—but those reads are covered by the individual data caches on the CPUs, and the fact that the total load on memory is higher will not be important, unless the two CPUs contend for access to memory.
- the XY Task 500 starts at the beginning of the input and output arrays, and YZ Task 500 starts in the middle.
- the input and output offsets are advanced through the arrays in each routine, they are masked (logical “and” operation) with the offset mask as defined above, which has the effect of “wrapping” the offset around at the end of the vector arrays—the XY Task 500 starts at vector 0 and ends at vector N ⁇ 1, and the YZ Task 500 starts at N/2, wraps past the end to 0, and ends at vector N/2 ⁇ 1.
- the two Operations 610 proceed at roughly the same rate, they will rarely contend for read access to the same memory.
- the XY and YZ problem breakdown takes advantage of having two sets of registers and two data caches to apply to the problem.
- the XY and YZ Tasks 905 can be decomposed by Domain 925 , each Task 905 splitting into two of the same sorts of Tasks 940 , with each responsible for one half the vectors. This will cut the time per vector in half.
- Each Task 940 will now be starting on a separate quarter of the vector arrays, with each task reading and writing half of them, as follows: CPU 0; XY Task 500 , vectors 0 to N/2 ⁇ 1, CPU 1: YZ Task 500 , vectors N/4 to 3N/4 ⁇ 5 CPU 2: XY Task 500 , vectors N/2 to N ⁇ 1, CPU 3: YZ Task 500 , vectors 3N/4 to N/4 ⁇ 1.
- FIG. 12 shows that in a case where only one element in each of the two matrix rows being used are nonzero, and the two elements are diagonally adjacent (not that uncommon a case in many matrix applications), a routine specialized through simple optimization can be almost twice as fast as the un-specialized routine, needing only seven instructions in the loop body to complete its work. (Larger, full-datum routines can also be specialized, of course—but the smaller the generic routine, the smaller the resulting specialized routine).
- FIG. 13 shows an optimally specialized routine, under the same conditions as in FIG. 12 .
- This result is achievable by a Code Generator 314 and an Optimizer 840 , but not as easily as the routine in FIG. 12 .
- This routine requires just three instructions in the core of the loop. Such a short loop suggests a pipelined stream of instructions, one that could be scheduled to achieve maximum overlap of long-latency instructions, as in FIG. 14 .
- the total number of instructions per half-vector output does not change from FIG. 13 , but as four half-vectors are “in flight” at the same time (which is possible because of the freeing of registers due to the By-Component 930 decomposition and the constant matrix specialization), this code will probably schedule better on many CPUs.
- By-Component 930 or other By-Function 920 decompositions are useful when the full-datum or full-function routine is “too big” to fit in the register set of the CPU.
- By-Domain 925 decompositions are generally productive, and in a multi-CPU environment, domains may also be interleaved. As shown by this example, several aspects of the Parallel Task Engine 300 can leverage each other to provide greater than linear speed-up when applying multiple CPUs to the data processing problem:
- interleaved decompositions may contain address arithmetic or other expressions which can be simplified in more specific variants of Operation 810 routines, because of knowledge of evenness, oddness, or other implicit numeric properties of data indices under the interleaved decomposition.
- the appropriate By-Component 930 or By-Function 920 problem decomposition can yield Operation 610 routines that are simpler and faster, splitting the computation of results over multiple CPU register sets. These routines can then make better use of individual CPU resources, which may allow more data to be computed per iteration, and which may schedule better, leading to better overall efficiency per CPU. They are also easier for a static or dynamic Optimizer 840 to improve.
- By-Component 930 and other By-Function 920 decomposed routines can be created dynamically (‘algorithmically decomposed’) by the Code Generator 314 , deriving them from generic routines by applying the Optimizer 840 to the generic code.
- Decompositions are chosen, either at run-time, or by experimentation, the results of which are then fed back into the configuration of the Scheduler 312 , so that the decompositions produce the best sum total performance, based on an examination of the operation routines generated.
- the example just given is a methodical exercise in this decomposition process.
- the Scheduler 312 makes these decisions at run-time, it must perform a similar analysis of code, weighing the benefits of different decompositions, optimizations, and specializations.
- Decomposing to get the same amount of work done across all CPUs, with best per-CPU code in dynamically generated Operation 810 routines is a novel decomposition strategy, and a means for pursuit of this strategy as presented here, is a feature of the invention.
- a 3D graphics image renderer like the pipeline 200 represented in FIG. 2 , can be implemented with the Parallel Task Engine 300 . It consists of: Vertex processing (position transformations and lighting); Primitive assembly or “setup”, clipping, culling, and rasterization; and Fragment or pixel “shading” (coloring, texturing, buffer operations).
- Each of these stages of computation can be performed by a dynamically generated Operation 810 routine that is specialized according to run-time values of graphics CONTEXT variables.
- the processing involved in the graphic pipeline is ripe for parallel decomposition—many primitives, defined by many vertices, enclosing many pixels, all of these stages have many processing steps, and all of these basic data types have many independent properties.
- This graphics pipeline can also support application-provided vertex programs and pixel shaders. These programs are simply part of the graphics CONTEXT, and the Code Generator 314 now creates vertex, setup, and pixel Operation 810 routines using these programs as a source of semantics, instead of the usual fixed function definitions. The result is the same, Operation 610 routines for the three stages specific to the CONTEXT.
- stage Units 1510 are static data structures enclosing temporary data, utilized by the stage computations, and specific to a particular kind of stage (vertex, setup, or pixel) computation. Stage computations must be attached to an available (no other computation in progress) Unit 1510 of the right kind in order to commence.
- FIG. 15 shows the data flow and stages of computation in the graphics pipeline.
- the horizontal rows show vertex, setup, and pixel Units 1510 , with all Units 1510 of the same kind in their own column. There is no specific relationship between the rows and Job Loops 318 , or any partition of Primary Data 306 .
- the diagram depicts an array of Units 1510 , and the paths that the data may follow, as it is transformed. Any Task 500 , for any stage of processing, may be attached to any available Unit 1510 of the right kind, and then the Task 500 may be assigned to any Job Loop 318 .
- the system is set up with as many Units 1510 of a certain kind as required to support concurrent stage computations of that kind.
- input Tasks 302 specify lists of graphics primitives to be rendered.
- the input Primary Data 306 is a collection of vertices and primitive definitions.
- the output Primary Data 306 is the display frame buffer.
- Auxiliary data such as transformation and projection matrices, texture and light source definitions reside in the graphics CONTEXT.
- the Scheduler 312 for this graphics pipeline has these policies:
- Primitives are drawn in first-in, first-out order. All pixels of a primitive may not be displayed at once, but for any pixel in the frame buffer, pixels from primitives are written in the same order as the primitives themselves are (requested to be) drawn, e.g. the pixel resulting from the first primitive drawn will be written first, and the pixel from the last primitive drawn will be written last. This will preserve the effect of primitives that are drawn over portions of other primitives.
- Pixel Tasks 500 are dependent on setup Tasks 500 that process the outlines, compute gradients for interpolation, and perform the rasterization of the primitives that enclose or bound them.
- Primitive setup Tasks 500 are dependent on the vertex Tasks 500 that process the vertices that define the primitive.
- Pixels are written to the frame buffer as soon as possible, while preserving drawing order as described above.
- Pixel sub-Tasks 500 are done before their enclosing primitive setup Tasks 500 , which are done before their defining vertex Tasks 500 , in other words, as soon as the Tasks 500 on which they are dependent have completed.
- the pixel Tasks 500 for primitives drawn earlier are done before the pixel Tasks 500 for that same set of pixels resulting from primitives drawn later.
- the same ordering with respect to their source primitives is true for setup and vertex Tasks 500 .
- Tasks 500 must be assigned to a Unit 1510 of the right kind to do their work. If the right kind of Unit 1510 is not available (free) for use, the Task 500 cannot be scheduled. When a Task 500 is assigned a Unit 1510 , the Unit 1510 is unavailable until the Task 500 is complete.
- Tasks 500 are decomposed in several ways:
- the input Task 302 is a list of primitives to render.
- This input Task 905 is first split into Tasks 940 for two passes. These two passes are a decomposition By-Component 930 of the final frame buffer pixels—the first pass computes only the z-buffer value of the rendered pixels. The second pass computes everything but the z-buffer value, and uses the first pass z-buffer value in the traditional way, in order to determine whether the pixel should be drawn or not.
- a (pass 1 or pass 2) primitive-list rendering Task 905 can be decomposed By-Domain 925 into Tasks 940 with shorter lists, or batches of one or more primitives to render.
- a primitive-list rendering Task 905 is decomposed by FUNCTION into a vertex Task 940 , a primitive assembly or setup Task 940 , and a pixel Task 940 , modeling the pipelines 200 of FIGS. 2 and 1500 of FIG. 15 .
- These Tasks 940 are successive stages, the pixel Task 940 is dependent on the setup Task 940 , and the setup Task 940 is dependent on the vertex Task 940 .
- the vertex Task 500 has a Data Pointer 520 from the input Task 302 to a vertex buffer containing all of the vertices for all of the primitives, to be processed en masse, regardless of their primitive associations.
- This vertex Task 905 can be decomposed By-Domain 925 into multiple independent vertex Tasks 940 . This decomposition may be ‘blind’, or it could be sorted according to association with groups of primitives.
- Vertex processing includes many cases of matrix-vector multiplication, which may be decomposed By-Component 930 and By-Domain 925 , as in the matrix-vector example described above.
- the primitive setup Task 905 has a Data Pointer 520 to a list of primitives to render, from the input Task 302 . It can be subdivided By-Domain 925 into multiple independent Tasks 940 with shorter lists of primitives. Depending on how the original vertex Task 905 was decomposed, some setup sub-Tasks 940 may not be dependent on all of the vertex sub-Tasks 940 .
- the pixel Task 905 can be decomposed By-Domain 925 into pixel groups of various kinds. One alternative is multiple sections of the display screen. Another is interlaced, or alternating horizontal bands on the display, one or more pixels tall. Or the pixel Tasks 940 can be sorted according to primitive groups, or types. The pixel Tasks 905 may also amenable to By-Component 930 decompositions, e.g. color values, the components of which can be computed independently, in certain lighting and shading operations.
- By-Component 930 decompositions e.g. color values, the components of which can be computed independently, in certain lighting and shading operations.
- the scheduler In order to effect its Task 500 ordering policy, the scheduler must look for the earliest pixel Task 500 (from the earliest primitive), check its dependencies, and if none are ready, look for the earliest setup Task 500 , and if none are ready, choose the earliest vertex task. This can be done in a number of ways. One convenient way is to keep the Tasks 500 on a linked list, as in the matrix-vector example above. When decomposing primitive-list rendering Tasks 905 into vertex, setup, and pixel Tasks 940 , they are added to the list in reverse order: pixel, setup, and vertex. Now the scheduler can start from the head of the list, and simply choose the first Task 500 with no outstanding dependencies, and for which a Unit 1510 of the right kind is available.
- the Code Generator 314 for the graphics pipeline can take advantage of the following opportunities for specialization and optimization:
- the first pass and second pass are By-Component 930 final pixel decompositions of the pixel's depth, z, and the complementary components to z.
- the first pass Operation 610 routines can be dramatically reduced, as most of the results which will be computed in pass 2 Tasks 500 are not needed in pass 1.
- Vertex processing includes many cases of matrix-vector multiplication, and the optimizations presented in the matrix-vector multiplication example above may be used in vertex processing.
- Stage 1601 assembles the vertices of the primitive, in the illustration a triangle.
- Stage 1602 performs back-face culling by determining the winding order of the triangle's vertices. This stage is skipped for line and point primitives.
- Stage 1603 constructs a polygon covering the primitive's fragments and clips it against the visible region.
- Stage 1604 projects the clipped polygon into screen space and scan-converts its edges.
- Stage 1605 computes z and vertex attribute gradients.
- Primitive setup rasterization stage The first step in rasterizing primitives is to construct a polygon covering their fragments.
- Triangle primitives can use their vertex positions directly as such a polygon.
- Line primitives require the construction of a thick line shaped polygon surrounding the line in screen space.
- One way to achieve this is to construct a 1-pixel wide rectangle as depicted in FIGS. 18( a ) and ( b ) .
- the white-filled circles connected by the dotted line represent the vertex positions in screen space.
- the black dots represent the screen space positions of the newly constructed polygon.
- every polygon edge is located at 0.5 pixel distance from the polygon, to avoid underdraw (missing pixels) in between connecting lines.
- the second step in rasterization consists of clipping the constructed polygon using the Sutherland-Hodgman clipping algorithm, against viewing frustum planes and optional application-controlled clipping planes.
- the viewing frustum and viewport scaling can be adjusted to provide viewport and scissor clipping functionality. Only positions are clipped; the constructed polygon does not include vertex attribute data.
- the next step is to rasterize the outline of the (clipped) polygon, and is illustrated in FIG. 17 . For every edge of the polygon (a pair of points), it is determined whether it is on the left or right side of the polygon.
- intersections For every scanline 1703 intersecting the edge, the x-coordinate of the intersection is computed, and stored in the left outline array 1701 or right outline array 1702 depending on which side the edge is located, at an index corresponding to the scanline's y-coordinate.
- intersections can be computed at higher resolution.
- the intersections can be computed efficiently using a variant of Bresenham's line drawing algorithm, the ‘digital differential analyzer’ (DDA) algorithm or a fixed-point or floating-point edge stepping method. Together with the outline arrays the top and bottom index where the polygon is located in the outline arrays 1701 and 1702 is stored.
- the (clipped) polygon can now be discarded. Gradient setup calculations use the original vertices of the primitive.
- the outline arrays and top and bottom indices can now be used by the interpolators to determine coverage masks for pixels or groups of pixels: For every fragment the coverage can be determined by comparing it's x-coordinate to the left and right outline arrays at the index corresponding to the fragment's y-coordinate. This process can be done in parallel for a group of fragments.
- Advantages of the whole rasterization algorithm compared to prior art are the ability to clip every type of primitive to viewport and scissor edges at an early stage, computing fragment coverage at a lower per-fragment cost than using half-space functions (as described in “Triangle Scan Conversion using 2D Homogeneous Coordinates”, Marc Olano and Trey Greer, Proceedings of the 1997 SIGGRAPH/Eurographics Workshop on Graphics Hardware), and computing coverage of groups of fragments in parallel on the same processor and in parallel for multiple groups of fragments on multiple processors.
- a graphics pipeline implemented via the Parallel Task Engine 300 as described above can keep multiple CPUs busy throughout every stage of image rendering, from the original list of primitives to display, to the final pixel frame buffer operations. This, in concert with the previously described beneficial problem decomposition, and dynamically generated context-specific optimized code, as well as specific, novel graphics processing algorithms detailed above, can give a super-linear acceleration of the rendering process when applied via this engine to multiple CPUs.
Abstract
Description
Claims (26)
Priority Applications (4)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/631,618 US9477452B2 (en) | 2006-03-14 | 2015-02-25 | General purpose software parallel task engine |
US14/940,350 US9436451B2 (en) | 2006-03-14 | 2015-11-13 | General purpose software parallel task engine |
US14/940,331 US9430202B2 (en) | 2006-03-14 | 2015-11-13 | General purpose software parallel task engine |
US15/225,362 US9875138B2 (en) | 2006-03-14 | 2016-08-01 | General purpose software parallel task engine |
Applications Claiming Priority (4)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US78196106P | 2006-03-14 | 2006-03-14 | |
US11/686,114 US8284206B2 (en) | 2006-03-14 | 2007-03-14 | General purpose software parallel task engine |
US13/597,403 US9019283B2 (en) | 2006-03-14 | 2012-08-29 | General purpose software parallel task engine |
US14/631,618 US9477452B2 (en) | 2006-03-14 | 2015-02-25 | General purpose software parallel task engine |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/597,403 Continuation US9019283B2 (en) | 2006-03-14 | 2012-08-29 | General purpose software parallel task engine |
Related Child Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/940,350 Continuation US9436451B2 (en) | 2006-03-14 | 2015-11-13 | General purpose software parallel task engine |
US14/940,331 Continuation US9430202B2 (en) | 2006-03-14 | 2015-11-13 | General purpose software parallel task engine |
Publications (2)
Publication Number | Publication Date |
---|---|
US20150169305A1 US20150169305A1 (en) | 2015-06-18 |
US9477452B2 true US9477452B2 (en) | 2016-10-25 |
Family
ID=38509002
Family Applications (6)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/686,114 Active 2031-06-13 US8284206B2 (en) | 2006-03-14 | 2007-03-14 | General purpose software parallel task engine |
US13/597,403 Active US9019283B2 (en) | 2006-03-14 | 2012-08-29 | General purpose software parallel task engine |
US14/631,618 Active US9477452B2 (en) | 2006-03-14 | 2015-02-25 | General purpose software parallel task engine |
US14/940,350 Active US9436451B2 (en) | 2006-03-14 | 2015-11-13 | General purpose software parallel task engine |
US14/940,331 Active US9430202B2 (en) | 2006-03-14 | 2015-11-13 | General purpose software parallel task engine |
US15/225,362 Active US9875138B2 (en) | 2006-03-14 | 2016-08-01 | General purpose software parallel task engine |
Family Applications Before (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/686,114 Active 2031-06-13 US8284206B2 (en) | 2006-03-14 | 2007-03-14 | General purpose software parallel task engine |
US13/597,403 Active US9019283B2 (en) | 2006-03-14 | 2012-08-29 | General purpose software parallel task engine |
Family Applications After (3)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/940,350 Active US9436451B2 (en) | 2006-03-14 | 2015-11-13 | General purpose software parallel task engine |
US14/940,331 Active US9430202B2 (en) | 2006-03-14 | 2015-11-13 | General purpose software parallel task engine |
US15/225,362 Active US9875138B2 (en) | 2006-03-14 | 2016-08-01 | General purpose software parallel task engine |
Country Status (4)
Country | Link |
---|---|
US (6) | US8284206B2 (en) |
EP (1) | EP2013710B8 (en) |
CA (2) | CA2638453C (en) |
WO (1) | WO2007104158A1 (en) |
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9875138B2 (en) | 2006-03-14 | 2018-01-23 | Google Llc | General purpose software parallel task engine |
Families Citing this family (98)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8111260B2 (en) * | 2006-06-28 | 2012-02-07 | Microsoft Corporation | Fast reconfiguration of graphics pipeline state |
US8954947B2 (en) * | 2006-06-29 | 2015-02-10 | Microsoft Corporation | Fast variable validation for state management of a graphics pipeline |
US9478062B2 (en) * | 2006-09-19 | 2016-10-25 | Imagination Technologies Limited | Memory allocation in distributed memories for multiprocessing |
US8286069B2 (en) * | 2007-01-26 | 2012-10-09 | Myspace Llc | System and method for editing web-based video |
US8117541B2 (en) * | 2007-03-06 | 2012-02-14 | Wildtangent, Inc. | Rendering of two-dimensional markup messages |
US20090165007A1 (en) * | 2007-12-19 | 2009-06-25 | Microsoft Corporation | Task-level thread scheduling and resource allocation |
GB2458488C (en) * | 2008-03-19 | 2018-09-12 | Imagination Tech Ltd | Untransformed display lists in a tile based rendering system |
US8698818B2 (en) * | 2008-05-15 | 2014-04-15 | Microsoft Corporation | Software rasterization optimization |
US8966490B2 (en) * | 2008-06-19 | 2015-02-24 | Freescale Semiconductor, Inc. | System, method and computer program product for scheduling a processing entity task by a scheduler in response to a peripheral task completion indicator |
WO2009153621A1 (en) * | 2008-06-19 | 2009-12-23 | Freescale Semiconductor, Inc. | A system, method and computer program product for scheduling processor entity tasks in a multiple-processing entity system |
WO2009153619A1 (en) * | 2008-06-19 | 2009-12-23 | Freescale Semiconductor, Inc. | A system, method and computer program product for debugging a system |
US8341615B2 (en) * | 2008-07-11 | 2012-12-25 | International Business Machines Corporation | Single instruction multiple data (SIMD) code generation for parallel loops using versioning and scheduling |
US20100017321A1 (en) * | 2008-07-18 | 2010-01-21 | Chicago Mercantile Exchange, Inc. | Adaptive Implied Spread Matching |
US10621092B2 (en) | 2008-11-24 | 2020-04-14 | Intel Corporation | Merging level cache and data cache units having indicator bits related to speculative execution |
BRPI0920541A2 (en) * | 2008-11-24 | 2018-11-06 | Intel Corp | systems, methods and apparatus for decomposing a sequential program into multichains, executing said chains, and reconstructing sequential execution |
US9672019B2 (en) | 2008-11-24 | 2017-06-06 | Intel Corporation | Systems, apparatuses, and methods for a hardware and software system to automatically decompose a program to multiple parallel threads |
US20100274972A1 (en) * | 2008-11-24 | 2010-10-28 | Boris Babayan | Systems, methods, and apparatuses for parallel computing |
US9189233B2 (en) | 2008-11-24 | 2015-11-17 | Intel Corporation | Systems, apparatuses, and methods for a hardware and software system to automatically decompose a program to multiple parallel threads |
US8069446B2 (en) * | 2009-04-03 | 2011-11-29 | Microsoft Corporation | Parallel programming and execution systems and techniques |
US8531473B2 (en) * | 2009-07-28 | 2013-09-10 | Technion R&D Foundation Ltd. | Photogrammetric texture mapping using casual images |
US8817031B2 (en) * | 2009-10-02 | 2014-08-26 | Nvidia Corporation | Distributed stream output in a parallel processing unit |
US10572937B2 (en) | 2010-06-17 | 2020-02-25 | Chicago Mercantile Exchange Inc. | Generating implied orders based on electronic requests for quotes |
WO2012177282A1 (en) * | 2011-06-23 | 2012-12-27 | Intel Corporation | Stochastic rasterization with selective culling |
WO2013010159A1 (en) * | 2011-07-14 | 2013-01-17 | Siemens Corporation | Reducing the scan cycle time of control applications through multi-core execution of user programs |
US9417855B2 (en) | 2011-09-30 | 2016-08-16 | Intel Corporation | Instruction and logic to perform dynamic binary translation |
US20130106887A1 (en) * | 2011-10-31 | 2013-05-02 | Christopher Tremblay | Texture generation using a transformation matrix |
US10048990B2 (en) | 2011-11-19 | 2018-08-14 | International Business Machines Corporation | Parallel access of partially locked content of input file |
US8812895B2 (en) * | 2011-11-21 | 2014-08-19 | Verizon Patent And Licensing Inc. | System redundancy and site recovery |
US9424168B2 (en) | 2012-03-20 | 2016-08-23 | Massively Parallel Technologies, Inc. | System and method for automatic generation of software test |
US8762946B2 (en) | 2012-03-20 | 2014-06-24 | Massively Parallel Technologies, Inc. | Method for automatic extraction of designs from standard source code |
US8959494B2 (en) * | 2012-03-20 | 2015-02-17 | Massively Parallel Technologies Inc. | Parallelism from functional decomposition |
US9977655B2 (en) | 2012-03-20 | 2018-05-22 | Massively Parallel Technologies, Inc. | System and method for automatic extraction of software design from requirements |
US9324126B2 (en) | 2012-03-20 | 2016-04-26 | Massively Parallel Technologies, Inc. | Automated latency management and cross-communication exchange conversion |
US9146709B2 (en) | 2012-06-08 | 2015-09-29 | Massively Parallel Technologies, Inc. | System and method for automatic detection of decomposition errors |
US9146777B2 (en) | 2013-01-25 | 2015-09-29 | Swarm Technology Llc | Parallel processing with solidarity cells by proactively retrieving from a task pool a matching task for the solidarity cell to process |
WO2014152800A1 (en) | 2013-03-14 | 2014-09-25 | Massively Parallel Technologies, Inc. | Project planning and debugging from functional decomposition |
US9495722B2 (en) * | 2013-05-24 | 2016-11-15 | Sony Interactive Entertainment Inc. | Developer controlled layout |
US10255650B2 (en) | 2013-05-24 | 2019-04-09 | Sony Interactive Entertainment Inc. | Graphics processing using dynamic resources |
CN104461478A (en) * | 2013-09-13 | 2015-03-25 | 鸿富锦精密工业（深圳）有限公司 | Three-dimensional cloud offline programming system and three-dimensional cloud offline programming method |
US9891936B2 (en) | 2013-09-27 | 2018-02-13 | Intel Corporation | Method and apparatus for page-level monitoring |
EP3039544B1 (en) * | 2013-10-03 | 2018-12-12 | Huawei Technologies Co., Ltd. | Method and system for assigning a computational block of a software program to cores of a multi-processor system |
CN105471950A (en) * | 2014-09-05 | 2016-04-06 | 鸿富锦精密工业(武汉)有限公司 | Distributed computing method and system |
US9361154B2 (en) * | 2014-09-30 | 2016-06-07 | International Business Machines Corporation | Tunable computerized job scheduling |
US20160125263A1 (en) * | 2014-11-03 | 2016-05-05 | Texas Instruments Incorporated | Method to compute sliding window block sum using instruction based selective horizontal addition in vector processor |
US9607414B2 (en) | 2015-01-27 | 2017-03-28 | Splunk Inc. | Three-dimensional point-in-polygon operation to facilitate displaying three-dimensional structures |
US9916326B2 (en) | 2015-01-27 | 2018-03-13 | Splunk, Inc. | Efficient point-in-polygon indexing technique for facilitating geofencing operations |
US9767122B2 (en) | 2015-01-27 | 2017-09-19 | Splunk Inc. | Efficient point-in-polygon indexing technique to facilitate displaying geographic data |
US10026204B2 (en) * | 2015-01-27 | 2018-07-17 | Splunk Inc. | Efficient point-in-polygon indexing technique for processing queries over geographic data sets |
US9836874B2 (en) | 2015-01-27 | 2017-12-05 | Splunk Inc. | Efficient polygon-clipping technique to reduce data transfer requirements for a viewport |
US9400685B1 (en) * | 2015-01-30 | 2016-07-26 | Huawei Technologies Co., Ltd. | Dividing, scheduling, and parallel processing compiled sub-tasks on an asynchronous multi-core processor |
US9910826B2 (en) | 2015-03-27 | 2018-03-06 | International Business Machines Corporation | SIMD implementation of stencil codes |
US20160364845A1 (en) * | 2015-06-11 | 2016-12-15 | Rahul P. Sathe | Pixel merge unit efficiency by identifying silhouette pixels |
US9652218B2 (en) | 2015-06-17 | 2017-05-16 | International Business Machines Corporation | Feature exploitation evaluator |
US10242419B2 (en) * | 2015-09-02 | 2019-03-26 | Intel Corporation | Compiler optimization to reduce the control flow divergence |
WO2017061589A1 (en) * | 2015-10-07 | 2017-04-13 | ブルーイノベーション株式会社 | Flight management system for flying objects |
WO2017066953A1 (en) | 2015-10-22 | 2017-04-27 | Oracle International Corporation | System and method for providing distributed caching in transactional processing environment |
US10726619B2 (en) | 2015-10-29 | 2020-07-28 | Sony Interactive Entertainment Inc. | Foveated geometry tessellation |
US9703537B2 (en) | 2015-11-02 | 2017-07-11 | International Business Machines Corporation | Method for defining alias sets |
US10140678B2 (en) * | 2015-12-18 | 2018-11-27 | Intel Corporation | Specialized code paths in GPU processing |
EP3208712B1 (en) * | 2016-02-22 | 2020-02-19 | Karlsruher Institut für Technologie | Computer system and method for parallel program code optimization and deployment |
US10372127B2 (en) | 2016-07-18 | 2019-08-06 | International Business Machines Corporation | Drone and drone-based system and methods for helping users assemble an object |
CN108022281B (en) * | 2016-10-31 | 2021-02-23 | 龙芯中科技术股份有限公司 | Method and device for rendering three-dimensional graph |
US10073715B2 (en) | 2016-12-19 | 2018-09-11 | Intel Corporation | Dynamic runtime task management |
US20180260878A1 (en) | 2017-03-09 | 2018-09-13 | Microsoft Technology Licensing, Llc | Item delivery fulfillment plan determination |
US10521880B2 (en) * | 2017-04-17 | 2019-12-31 | Intel Corporation | Adaptive compute size per workload |
US10656964B2 (en) * | 2017-05-16 | 2020-05-19 | Oracle International Corporation | Dynamic parallelization of a calculation process |
CN108415766B (en) * | 2018-03-06 | 2022-01-28 | 洛阳理工学院 | Rendering task dynamic scheduling method |
US11194800B2 (en) * | 2018-04-26 | 2021-12-07 | Microsoft Technology Licensing, Llc | Parallel search in program synthesis |
US10796472B2 (en) * | 2018-06-30 | 2020-10-06 | Intel Corporation | Method and apparatus for simultaneously executing multiple contexts on a graphics engine |
US10950162B2 (en) | 2018-10-25 | 2021-03-16 | Baylor University | System and method for a six-primary wide gamut color system |
US11488510B2 (en) | 2018-10-25 | 2022-11-01 | Baylor University | System and method for a multi-primary wide gamut color system |
US11341890B2 (en) | 2018-10-25 | 2022-05-24 | Baylor University | System and method for a multi-primary wide gamut color system |
US11475819B2 (en) | 2018-10-25 | 2022-10-18 | Baylor University | System and method for a multi-primary wide gamut color system |
US10607527B1 (en) | 2018-10-25 | 2020-03-31 | Baylor University | System and method for a six-primary wide gamut color system |
US11037481B1 (en) | 2018-10-25 | 2021-06-15 | Baylor University | System and method for a multi-primary wide gamut color system |
US11189210B2 (en) * | 2018-10-25 | 2021-11-30 | Baylor University | System and method for a multi-primary wide gamut color system |
US11062638B2 (en) | 2018-10-25 | 2021-07-13 | Baylor University | System and method for a multi-primary wide gamut color system |
US11587491B1 (en) | 2018-10-25 | 2023-02-21 | Baylor University | System and method for a multi-primary wide gamut color system |
US10997896B2 (en) | 2018-10-25 | 2021-05-04 | Baylor University | System and method for a six-primary wide gamut color system |
US11069279B2 (en) | 2018-10-25 | 2021-07-20 | Baylor University | System and method for a multi-primary wide gamut color system |
US10950161B2 (en) | 2018-10-25 | 2021-03-16 | Baylor University | System and method for a six-primary wide gamut color system |
US11289000B2 (en) | 2018-10-25 | 2022-03-29 | Baylor University | System and method for a multi-primary wide gamut color system |
US11373575B2 (en) | 2018-10-25 | 2022-06-28 | Baylor University | System and method for a multi-primary wide gamut color system |
US11315467B1 (en) | 2018-10-25 | 2022-04-26 | Baylor University | System and method for a multi-primary wide gamut color system |
US11410593B2 (en) | 2018-10-25 | 2022-08-09 | Baylor University | System and method for a multi-primary wide gamut color system |
US11289003B2 (en) | 2018-10-25 | 2022-03-29 | Baylor University | System and method for a multi-primary wide gamut color system |
US11069280B2 (en) | 2018-10-25 | 2021-07-20 | Baylor University | System and method for a multi-primary wide gamut color system |
US11532261B1 (en) | 2018-10-25 | 2022-12-20 | Baylor University | System and method for a multi-primary wide gamut color system |
US11043157B2 (en) | 2018-10-25 | 2021-06-22 | Baylor University | System and method for a six-primary wide gamut color system |
US11030934B2 (en) | 2018-10-25 | 2021-06-08 | Baylor University | System and method for a multi-primary wide gamut color system |
US11403987B2 (en) | 2018-10-25 | 2022-08-02 | Baylor University | System and method for a multi-primary wide gamut color system |
US10740074B2 (en) * | 2018-11-30 | 2020-08-11 | Advanced Micro Devices, Inc. | Conditional construct splitting for latency hiding |
CN111400024B (en) * | 2019-01-03 | 2023-10-10 | 百度在线网络技术（北京）有限公司 | Resource calling method and device in rendering process and rendering engine |
US11256488B1 (en) | 2020-07-29 | 2022-02-22 | Bank Of America Corporation | Graph-based vectorization for software code optimizations |
US11301218B2 (en) | 2020-07-29 | 2022-04-12 | Bank Of America Corporation | Graph-based vectorization for software code optimization references |
CN113487714A (en) * | 2021-06-23 | 2021-10-08 | 北京奇岱松科技有限公司 | Rendering method and device of space object, computing equipment and storage medium |
US20230084739A1 (en) * | 2021-09-10 | 2023-03-16 | International Business Machines Corporation | Subtractive patterning of interconnect structures |
CN113867912A (en) * | 2021-09-26 | 2021-12-31 | 中国联合网络通信集团有限公司 | Method and device for executing task, electronic equipment and readable storage medium |
Citations (23)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5202987A (en) | 1990-02-01 | 1993-04-13 | Nimrod Bayer | High flow-rate synchronizer/scheduler apparatus and method for multiprocessors |
US5452461A (en) | 1989-04-28 | 1995-09-19 | Hitachi, Ltd. | Program parallelizing apparatus capable of optimizing processing time |
US5535393A (en) | 1991-09-20 | 1996-07-09 | Reeve; Christopher L. | System for parallel processing that compiles a filed sequence of instructions within an iteration space |
US5768594A (en) | 1995-07-14 | 1998-06-16 | Lucent Technologies Inc. | Methods and means for scheduling parallel processors |
US6075935A (en) | 1997-12-01 | 2000-06-13 | Improv Systems, Inc. | Method of generating application specific integrated circuits using a programmable hardware architecture |
US20020073129A1 (en) | 2000-12-04 | 2002-06-13 | Yu-Chung Wang | Integrated multi-component scheduler for operating systems |
US6480876B2 (en) | 1998-05-28 | 2002-11-12 | Compaq Information Technologies Group, L.P. | System for integrating task and data parallelism in dynamic applications |
US6525737B1 (en) | 1998-08-20 | 2003-02-25 | Apple Computer, Inc. | Graphics processor with pipeline state storage and retrieval |
US6760907B2 (en) | 1998-06-30 | 2004-07-06 | Sun Microsystems, Inc. | Code generation for a bytecode compiler |
WO2005006153A2 (en) | 2003-07-07 | 2005-01-20 | Netezza Corporation | Sql code generation for heterogeneous environment |
EP1569104A2 (en) | 2004-01-09 | 2005-08-31 | Interuniversitair Microelektronica Centrum Vzw | An automated method for performing parallelization of sequential code and a computerized system adapted therefore |
US7058945B2 (en) | 2000-11-28 | 2006-06-06 | Fujitsu Limited | Information processing method and recording medium therefor capable of enhancing the executing speed of a parallel processing computing device |
US7103881B2 (en) | 2002-12-10 | 2006-09-05 | Intel Corporation | Virtual machine to provide compiled code to processing elements embodied on a processor device |
US7222218B2 (en) | 2002-10-22 | 2007-05-22 | Sun Microsystems, Inc. | System and method for goal-based scheduling of blocks of code for concurrent execution |
US7478376B2 (en) | 2004-12-02 | 2009-01-13 | International Business Machines Corporation | Computer program code size partitioning method for multiple memory multi-processing systems |
US7522168B2 (en) | 2005-09-27 | 2009-04-21 | Sony Computer Entertainment Inc. | Cell processor task and data management |
US7587439B1 (en) | 2001-08-31 | 2009-09-08 | Intergrated Device Technology, Inc. | Method and apparatus for generating a random bit stream in true random number generator fashion |
US7598953B2 (en) | 2004-11-05 | 2009-10-06 | Microsoft Corporation | Interpreter for simplified programming of graphics processor units in general purpose programming languages |
US7633506B1 (en) | 2002-11-27 | 2009-12-15 | Ati Technologies Ulc | Parallel pipeline graphics system |
US7747842B1 (en) | 2005-12-19 | 2010-06-29 | Nvidia Corporation | Configurable output buffer ganging for a parallel processor |
US7804504B1 (en) | 2004-12-13 | 2010-09-28 | Massachusetts Institute Of Technology | Managing yield for a parallel processing integrated circuit |
US8141076B2 (en) | 2005-09-27 | 2012-03-20 | Sony Computer Entertainment Inc. | Cell processor methods and apparatus |
US8434086B2 (en) | 2005-03-14 | 2013-04-30 | Qnx Software Systems Limited | Process scheduler employing adaptive partitioning of process threads |
Family Cites Families (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JP2004054680A (en) * | 2002-07-22 | 2004-02-19 | Fujitsu Ltd | Parallel efficiency calculation method |
CA2638453C (en) | 2006-03-14 | 2010-11-09 | Transgaming Technologies Inc. | General purpose software parallel task engine |
-
2007
- 2007-03-14 CA CA2638453A patent/CA2638453C/en active Active
- 2007-03-14 WO PCT/CA2007/000415 patent/WO2007104158A1/en active Application Filing
- 2007-03-14 US US11/686,114 patent/US8284206B2/en active Active
- 2007-03-14 EP EP07710745.6A patent/EP2013710B8/en active Active
- 2007-03-14 CA CA2707680A patent/CA2707680A1/en not_active Abandoned
-
2012
- 2012-08-29 US US13/597,403 patent/US9019283B2/en active Active
-
2015
- 2015-02-25 US US14/631,618 patent/US9477452B2/en active Active
- 2015-11-13 US US14/940,350 patent/US9436451B2/en active Active
- 2015-11-13 US US14/940,331 patent/US9430202B2/en active Active
-
2016
- 2016-08-01 US US15/225,362 patent/US9875138B2/en active Active
Patent Citations (24)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5452461A (en) | 1989-04-28 | 1995-09-19 | Hitachi, Ltd. | Program parallelizing apparatus capable of optimizing processing time |
US5202987A (en) | 1990-02-01 | 1993-04-13 | Nimrod Bayer | High flow-rate synchronizer/scheduler apparatus and method for multiprocessors |
US5535393A (en) | 1991-09-20 | 1996-07-09 | Reeve; Christopher L. | System for parallel processing that compiles a filed sequence of instructions within an iteration space |
US5768594A (en) | 1995-07-14 | 1998-06-16 | Lucent Technologies Inc. | Methods and means for scheduling parallel processors |
US6434590B1 (en) | 1995-07-14 | 2002-08-13 | Avaya Technology Corp. | Methods and apparatus for scheduling parallel processors |
US6075935A (en) | 1997-12-01 | 2000-06-13 | Improv Systems, Inc. | Method of generating application specific integrated circuits using a programmable hardware architecture |
US6480876B2 (en) | 1998-05-28 | 2002-11-12 | Compaq Information Technologies Group, L.P. | System for integrating task and data parallelism in dynamic applications |
US6760907B2 (en) | 1998-06-30 | 2004-07-06 | Sun Microsystems, Inc. | Code generation for a bytecode compiler |
US6525737B1 (en) | 1998-08-20 | 2003-02-25 | Apple Computer, Inc. | Graphics processor with pipeline state storage and retrieval |
US7058945B2 (en) | 2000-11-28 | 2006-06-06 | Fujitsu Limited | Information processing method and recording medium therefor capable of enhancing the executing speed of a parallel processing computing device |
US20020073129A1 (en) | 2000-12-04 | 2002-06-13 | Yu-Chung Wang | Integrated multi-component scheduler for operating systems |
US7587439B1 (en) | 2001-08-31 | 2009-09-08 | Intergrated Device Technology, Inc. | Method and apparatus for generating a random bit stream in true random number generator fashion |
US7222218B2 (en) | 2002-10-22 | 2007-05-22 | Sun Microsystems, Inc. | System and method for goal-based scheduling of blocks of code for concurrent execution |
US7633506B1 (en) | 2002-11-27 | 2009-12-15 | Ati Technologies Ulc | Parallel pipeline graphics system |
US7103881B2 (en) | 2002-12-10 | 2006-09-05 | Intel Corporation | Virtual machine to provide compiled code to processing elements embodied on a processor device |
WO2005006153A2 (en) | 2003-07-07 | 2005-01-20 | Netezza Corporation | Sql code generation for heterogeneous environment |
EP1569104A2 (en) | 2004-01-09 | 2005-08-31 | Interuniversitair Microelektronica Centrum Vzw | An automated method for performing parallelization of sequential code and a computerized system adapted therefore |
US7598953B2 (en) | 2004-11-05 | 2009-10-06 | Microsoft Corporation | Interpreter for simplified programming of graphics processor units in general purpose programming languages |
US7478376B2 (en) | 2004-12-02 | 2009-01-13 | International Business Machines Corporation | Computer program code size partitioning method for multiple memory multi-processing systems |
US7804504B1 (en) | 2004-12-13 | 2010-09-28 | Massachusetts Institute Of Technology | Managing yield for a parallel processing integrated circuit |
US8434086B2 (en) | 2005-03-14 | 2013-04-30 | Qnx Software Systems Limited | Process scheduler employing adaptive partitioning of process threads |
US7522168B2 (en) | 2005-09-27 | 2009-04-21 | Sony Computer Entertainment Inc. | Cell processor task and data management |
US8141076B2 (en) | 2005-09-27 | 2012-03-20 | Sony Computer Entertainment Inc. | Cell processor methods and apparatus |
US7747842B1 (en) | 2005-12-19 | 2010-06-29 | Nvidia Corporation | Configurable output buffer ganging for a parallel processor |
Non-Patent Citations (10)
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9875138B2 (en) | 2006-03-14 | 2018-01-23 | Google Llc | General purpose software parallel task engine |
Also Published As
Publication number | Publication date |
---|---|
US20150169305A1 (en) | 2015-06-18 |
US20170132038A1 (en) | 2017-05-11 |
US20070220525A1 (en) | 2007-09-20 |
EP2013710A4 (en) | 2010-03-10 |
CA2707680A1 (en) | 2007-09-20 |
WO2007104158A1 (en) | 2007-09-20 |
US20160071305A1 (en) | 2016-03-10 |
US9875138B2 (en) | 2018-01-23 |
CA2638453C (en) | 2010-11-09 |
CA2638453A1 (en) | 2007-09-20 |
EP2013710A1 (en) | 2009-01-14 |
US20120320051A1 (en) | 2012-12-20 |
US9019283B2 (en) | 2015-04-28 |
EP2013710B8 (en) | 2016-12-07 |
US9436451B2 (en) | 2016-09-06 |
US20160070552A1 (en) | 2016-03-10 |
US9430202B2 (en) | 2016-08-30 |
EP2013710B1 (en) | 2013-05-08 |
US8284206B2 (en) | 2012-10-09 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9875138B2 (en) | General purpose software parallel task engine | |
US6088044A (en) | Method for parallelizing software graphics geometry pipeline rendering | |
EP2939208B1 (en) | Sprite graphics rendering system | |
Whitman | Dynamic load balancing for parallel polygon rendering | |
Zhou et al. | RenderAnts: interactive Reyes rendering on GPUs | |
US20090189896A1 (en) | Graphics Processor having Unified Shader Unit | |
US5951672A (en) | Synchronization method for work distribution in a multiprocessor system | |
US6384833B1 (en) | Method and parallelizing geometric processing in a graphics rendering pipeline | |
US20010051971A1 (en) | Parallel object task engine and processing method | |
US8212825B1 (en) | System and method for geometry shading | |
Fernando et al. | Programming graphics hardware | |
EP1152331B1 (en) | Parallel task processing system and method | |
Hoberock et al. | Stream compaction for deferred shading | |
EP0600204A2 (en) | Method and apparatus for rendering primitives with multiple processors | |
Ellsworth | Polygon rendering for interactive visualization on multicomputers | |
Krogh et al. | Parallel sphere rendering | |
Challinger | Scalable parallel direct volume rendering for nonrectilinear computational grids | |
Clay | Optimization for real-time graphics applications | |
Holten-Lund | Design for scalability in 3D computer graphics architectures | |
Anglada Sánchez | Exploiting frame coherence in real-time rendering for energy-efficient GPUs | |
Fangerau et al. | Parallel volume rendering implementation on graphics cards using CUDA | |
Cassagnabère et al. | Cpu-gpu multithreaded programming model: Application to the path tracing with next event estimation algorithm | |
Hillesland | GPU compute for graphics | |
Hrinčár | Volume Visualization of Human Skulls | |
Kugler | Profiling und Optimierung Großer Biomolekularer Szenen |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: TRANSGAMING TECHNOLOGIES INC., CANADAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:STATE, GAVRIEL;CAPENS, NICOLAS;JOHNSON, LUTHER;SIGNING DATES FROM 20070514 TO 20070523;REEL/FRAME:035037/0513Owner name: TRANSGAMING INC., CANADAFree format text: CHANGE OF NAME;ASSIGNOR:TRANSGAMING TECHNOLOGIES INC.;REEL/FRAME:035100/0838Effective date: 20060531 |
|
AS | Assignment |
Owner name: TRANSGAMING INC., CANADAFree format text: MERGER;ASSIGNOR:TRANSGAMING TECHNOLOGIES INC.;REEL/FRAME:036879/0059Effective date: 20060529 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:TRANSGAMING INC.;REEL/FRAME:039980/0530Effective date: 20160420 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044097/0658Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 8TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1552); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 8 |