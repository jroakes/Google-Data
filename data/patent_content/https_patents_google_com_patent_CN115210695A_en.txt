CN115210695A - System and method for debugging delivery of content items - Google Patents
System and method for debugging delivery of content items Download PDFInfo
- Publication number
- CN115210695A CN115210695A CN202180017868.0A CN202180017868A CN115210695A CN 115210695 A CN115210695 A CN 115210695A CN 202180017868 A CN202180017868 A CN 202180017868A CN 115210695 A CN115210695 A CN 115210695A
- Authority
- CN
- China
- Prior art keywords
- content
- content item
- debug
- information
- interface
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000000034 method Methods 0.000 title claims abstract description 83
- 230000009471 action Effects 0.000 claims abstract description 48
- 230000004044 response Effects 0.000 claims abstract description 13
- 238000012545 processing Methods 0.000 claims description 81
- 238000012360 testing method Methods 0.000 claims description 72
- 230000008439 repair process Effects 0.000 claims description 9
- 230000004913 activation Effects 0.000 claims description 7
- 230000003993 interaction Effects 0.000 description 31
- 238000004458 analytical method Methods 0.000 description 25
- 238000004891 communication Methods 0.000 description 19
- 230000000694 effects Effects 0.000 description 18
- 238000004590 computer program Methods 0.000 description 12
- 238000010586 diagram Methods 0.000 description 11
- 230000006870 function Effects 0.000 description 11
- 238000010801 machine learning Methods 0.000 description 6
- 230000003287 optical effect Effects 0.000 description 6
- 230000008569 process Effects 0.000 description 6
- 238000013515 script Methods 0.000 description 5
- 230000003190 augmentative effect Effects 0.000 description 4
- 230000000153 supplemental effect Effects 0.000 description 4
- 230000005540 biological transmission Effects 0.000 description 3
- 230000036541 health Effects 0.000 description 3
- 230000033001 locomotion Effects 0.000 description 3
- 230000000644 propagated effect Effects 0.000 description 3
- 238000012546 transfer Methods 0.000 description 3
- 239000008186 active pharmaceutical agent Substances 0.000 description 2
- 238000013528 artificial neural network Methods 0.000 description 2
- 230000001174 ascending effect Effects 0.000 description 2
- 230000003542 behavioural effect Effects 0.000 description 2
- 238000012790 confirmation Methods 0.000 description 2
- 230000001815 facial effect Effects 0.000 description 2
- 230000003862 health status Effects 0.000 description 2
- 210000000554 iris Anatomy 0.000 description 2
- 239000004973 liquid crystal related substance Substances 0.000 description 2
- 238000007726 management method Methods 0.000 description 2
- 230000006855 networking Effects 0.000 description 2
- 238000000926 separation method Methods 0.000 description 2
- 230000003068 static effect Effects 0.000 description 2
- VYZAMTAEIAYCRO-UHFFFAOYSA-N Chromium Chemical compound [Cr] VYZAMTAEIAYCRO-UHFFFAOYSA-N 0.000 description 1
- 230000001133 acceleration Effects 0.000 description 1
- 230000003213 activating effect Effects 0.000 description 1
- 238000007792 addition Methods 0.000 description 1
- 230000002776 aggregation Effects 0.000 description 1
- 238000004220 aggregation Methods 0.000 description 1
- 238000013459 approach Methods 0.000 description 1
- 210000000617 arm Anatomy 0.000 description 1
- 238000013473 artificial intelligence Methods 0.000 description 1
- 230000008901 benefit Effects 0.000 description 1
- 238000004422 calculation algorithm Methods 0.000 description 1
- 230000015556 catabolic process Effects 0.000 description 1
- 230000008859 change Effects 0.000 description 1
- 238000013527 convolutional neural network Methods 0.000 description 1
- 238000013479 data entry Methods 0.000 description 1
- 238000013500 data storage Methods 0.000 description 1
- 230000001934 delay Effects 0.000 description 1
- 238000001514 detection method Methods 0.000 description 1
- 238000011161 development Methods 0.000 description 1
- 238000005516 engineering process Methods 0.000 description 1
- 210000000887 face Anatomy 0.000 description 1
- 230000006872 improvement Effects 0.000 description 1
- 238000011423 initialization method Methods 0.000 description 1
- 230000002452 interceptive effect Effects 0.000 description 1
- 238000011835 investigation Methods 0.000 description 1
- 238000012417 linear regression Methods 0.000 description 1
- 230000007257 malfunction Effects 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 239000011159 matrix material Substances 0.000 description 1
- 238000013021 overheating Methods 0.000 description 1
- 230000000306 recurrent effect Effects 0.000 description 1
- 238000005067 remediation Methods 0.000 description 1
- 238000009877 rendering Methods 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 230000001953 sensory effect Effects 0.000 description 1
- 239000004984 smart glass Substances 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
- 239000000758 substrate Substances 0.000 description 1
- 230000001960 triggered effect Effects 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/34—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment
- G06F11/3438—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment monitoring of user actions
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/362—Software debugging
- G06F11/366—Software debugging using diagnostics
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/34—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment
- G06F11/3466—Performance evaluation by tracing or monitoring
- G06F11/3476—Data logging
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/3668—Software testing
- G06F11/3672—Test management
- G06F11/3688—Test management for test execution, e.g. scheduling of test suites
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/01—Input arrangements or combined input and output arrangements for interaction between user and computer
- G06F3/011—Arrangements for interaction with the human body, e.g. for user immersion in virtual reality
- G06F3/012—Head tracking input arrangements
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/01—Input arrangements or combined input and output arrangements for interaction between user and computer
- G06F3/011—Arrangements for interaction with the human body, e.g. for user immersion in virtual reality
- G06F3/013—Eye tracking input arrangements
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/01—Input arrangements or combined input and output arrangements for interaction between user and computer
- G06F3/011—Arrangements for interaction with the human body, e.g. for user immersion in virtual reality
- G06F3/015—Input arrangements based on nervous system activity detection, e.g. brain waves [EEG] detection, electromyograms [EMG] detection, electrodermal response detection
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/01—Input arrangements or combined input and output arrangements for interaction between user and computer
- G06F3/016—Input arrangements with force or tactile feedback as computer generated output to the user
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/01—Input arrangements or combined input and output arrangements for interaction between user and computer
- G06F3/017—Gesture based interaction, e.g. based on a set of recognized hand gestures
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/01—Input arrangements or combined input and output arrangements for interaction between user and computer
- G06F3/048—Interaction techniques based on graphical user interfaces [GUI]
- G06F3/0487—Interaction techniques based on graphical user interfaces [GUI] using specific features provided by the input device, e.g. functions controlled by the rotation of a mouse with dual sensing arrangements, or of the nature of the input device, e.g. tap gestures based on pressure sensed by a digitiser
- G06F3/0488—Interaction techniques based on graphical user interfaces [GUI] using specific features provided by the input device, e.g. functions controlled by the rotation of a mouse with dual sensing arrangements, or of the nature of the input device, e.g. tap gestures based on pressure sensed by a digitiser using a touch-screen or digitiser, e.g. input of commands through traced gestures
- G06F3/04883—Interaction techniques based on graphical user interfaces [GUI] using specific features provided by the input device, e.g. functions controlled by the rotation of a mouse with dual sensing arrangements, or of the nature of the input device, e.g. tap gestures based on pressure sensed by a digitiser using a touch-screen or digitiser, e.g. input of commands through traced gestures for inputting data by handwriting, e.g. gesture or text
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/362—Software debugging
- G06F11/3636—Software debugging by tracing the execution of the program
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2200/00—Indexing scheme relating to G06F1/04 - G06F1/32
- G06F2200/16—Indexing scheme relating to G06F1/16 - G06F1/18
- G06F2200/163—Indexing scheme relating to constructional details of the computer
- G06F2200/1636—Sensing arrangement for detection of a tap gesture on the housing
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2200/00—Indexing scheme relating to G06F1/04 - G06F1/32
- G06F2200/16—Indexing scheme relating to G06F1/16 - G06F1/18
- G06F2200/163—Indexing scheme relating to constructional details of the computer
- G06F2200/1637—Sensing arrangement for detection of housing movement or orientation, e.g. for controlling scrolling or cursor movement on the display of an handheld computer
Abstract
Systems, methods, and computer-readable storage media may be used to debug a content item. One example method includes presenting, by a mobile application executing on a mobile device, a first application interface. The example method also includes detecting, by the mobile device, a predetermined user action. The example method also includes: generating debugging information from a content event log in response to detecting a predetermined user action, wherein the content event log is associated with a content item slot in which the content item is presented in the mobile application; and presenting, by the debug interface, the debug information.
Description
RELATED APPLICATIONS
This application claims priority and benefit from U.S. provisional patent application No. 63/108,025, filed 10/30/2020, which is hereby incorporated by reference in its entirety.
Background
In a computer networking environment, such as the internet, entities, such as individuals or companies, provide content items for display in content item slots to attract consumers. An entity providing a content item may wish to debug (debug) the failure of the content item.
Disclosure of Invention
Some implementations relate to a method of debugging delivery of a content item. The method is implemented by one or more processing circuits. The method includes presenting, by a mobile application executing on a mobile device, a first application interface. Further, the method includes generating debugging information from a content event log, wherein the content event log is associated with a content item slot in which the content item is presented in the mobile application. Further, the method includes detecting, by the mobile device, a predetermined user action. Further, the method includes presenting, by the debug interface, the debug information in response to detecting the predetermined user action.
In some implementations, the method also includes fixing, by the debug interface, the first exception to the debug information based on modifying the configuration of the content item. In various embodiments, the debug interface is presented as an overlay on the first application interface. In some implementations, the method also includes sending, by the mobile application, a registration request including the identifier and the activation gesture, and receiving, by the mobile application, a notification indicating that the mobile device is registered. In various embodiments, the predetermined user action is a gesture, and wherein the gesture is at least one of a shake, flick, or user-defined custom gesture configured within the mobile application. In some implementations, the content event log includes a plurality of events based on a threshold time period or a threshold number of events, and wherein each event of the plurality of events includes usage data for a content item presented in the mobile application. In various implementations, each of the content item slots includes different debug information, and wherein the content event logs are organized in the debug interface and inactive content items are organized together based on recency of the different debug information for each of the content item slots. In some implementations, the method further includes updating, by the debug interface, the content event log in real-time based on receiving additional debug information associated with the content item. In various embodiments, the method further includes extending, by the debug information, the debug information to include a detailed description of the debug information, wherein the detailed description includes one or more action items. In some implementations, the method further includes requesting, by the debugging information, a content item test for a content item in a particular content network, wherein the content item is associated with a plurality of content networks for displaying the content item. In various embodiments, the method further comprises transmitting, by the debug information, the content event log to a remediation system.
Drawings
FIG. 1 is a block diagram depicting an implementation of a system for debugging in accordance with some embodiments;
FIG. 2 is a flow diagram of a computer-implemented method for debugging delivery of a content item, according to some embodiments;
FIG. 3 is a flow diagram of a computer-implemented method for debugging delivery of a content item, according to some embodiments;
FIG. 4 is an exemplary diagram depicting a registration interface according to some embodiments;
5A-5C are exemplary diagrams depicting a debug interface according to some embodiments;
6A-6C are exemplary diagrams depicting a debug interface according to some embodiments;
7A-7B are exemplary diagrams depicting a debug interface according to some embodiments;
FIG. 8 is a block diagram illustrating an example computing system suitable for use in the various arrangements described herein.
It will be appreciated that some or all of the figures are schematic representations for purposes of illustration. These drawings are provided for the purpose of illustrating one or more embodiments and are not to be construed as limiting the scope or meaning of the claims.
Detailed Description
In many fields, it may be desirable to debug content items in a debugging interface (e.g., a Software Development Kit (SDK)) from a mobile application on a mobile device. For example, in the event of a failure (e.g., a software crash, a hardware failure, etc.), it is often desirable to view content item event logs such as debug information (e.g., interaction data and debug data) in order to diagnose and repair the failure. Furthermore, non-application developers may wish to fix bugs and perform testing of content items through a debug interface without the need for encoding.
In many systems, to analyze content item failures and modify content item configurations associated with mobile applications, application developers debug and modify code using various testing techniques, all of which use debugging interfaces (e.g., android SDK, iOS SDK, VMware SDK, nordic SDK, java Debugging Interface (JDI), chrome DevTools, debuggers, etc.). In fact, debug interfaces have become a standard tool for developing mobile applications since their introduction. However, the debug interface is technical and requires experience in programming and developing code that non-application developers cannot use to examine the mobile application (e.g., event logs, tests), learn about the health of the mobile application (e.g., failure, performance, configuration), or modify the configuration of the mobile application (e.g., content item configuration). Thus, the ability of non-application developers to examine mobile applications, understand the health of mobile applications, and modify the configuration of mobile applications using a debugging interface provides the ability for non-application developers to view and execute actions on the debugging interface (which is typically only viewable and executable by application developers). This unique debug interface and computer architecture approach provides improved data reporting and analysis paths and computer architecture. Non-application developers can invoke paths and schemas to configure and analyze mobile application event logs (e.g., content item event logs) in a robust and timely manner.
Accordingly, the systems and methods of the present disclosure generally relate to debugging content items on a debugging interface from a mobile application on a mobile device. More particularly, the systems and methods of the present disclosure relate to unique debug interfaces and computer architecture methods for presenting event logs and configuring content items from mobile devices. Thus, the systems and methods described herein describe methods of debugging content items and modifying the configuration of content items. In various embodiments, the mobile devices described herein include the capability to perform debugging, perform content network testing, and present a debugging interface.
Where the systems discussed herein collect personal information about or may use personal information about a user and/or entity, the user and/or entity has an opportunity to control whether programs or features collect user information and/or entity information (e.g., information about the user's social network, social actions or activities, profession, user preferences, or the user's current location), or whether and/or how to receive content from a content server that may be more relevant to the user and/or entity. In addition, or as an alternative, some data may be processed in one or more ways before being stored or used in order to remove personally identifiable information. For example, the user's identity may be processed such that personally identifiable information of the user cannot be determined, or the user's geographic location may be summarized where location information is obtained (e.g., at a city, zip code, or state level) such that a particular location of the user cannot be determined. Thus, the user and/or entity may control how information about the user and/or entity is collected and used by the content server.
Referring now to fig. 1, a block diagram depicts an implementation of a system 100 for debugging in accordance with some embodiments. The system 100 comprises a client device 10, a first data processing system 300. In various embodiments, the components of system 100 communicate over a network 60. The network 60 may include a computer network such as the internet, a local area network, a wide area network, a metropolitan area network, or other area network, an intranet, a satellite network, other computer networks (e.g., voice or data mobile telephone communication networks), combinations thereof, or any other type of electronic communication network. The network 60 may comprise or constitute a display network (e.g., a subset of the information resources available on the internet associated with or eligible to include third-party content items as part of a content item placement activity). In various embodiments, the network 60 facilitates secure communications between components of the system 100. By way of non-limiting example, the network 60 may implement Transport Layer Security (TLS), secure Sockets Layer (SSL), hypertext transfer protocol security (HTTPS), and/or any other secure communication protocol.
Client device 10 (sometimes referred to herein as a "mobile device") may be a mobile computing device, smartphone, tablet, smartwatch, smart sensor, or any other device configured to facilitate receiving content (e.g., web pages, mobile applications, etc.), displaying content, and interacting with content. The client device 10 may include an application 12 for receiving and displaying online content and receiving user interactions with the online content. For example, the application 12 may be a network (web) browser. Additionally or alternatively, the application 12 may be a mobile application associated with a particular merchant. Client device 10 may also include input/output circuitry 28 for transmitting data (e.g., receiving and transmitting to first data processing system 300) over network 60.
In various implementations, the application 12 interacts with content publishers to receive online content and/or web content. For example, the application 12 may receive an information resource from a content publisher. The information resources may include web-based content items (e.g., web pages) or other online documents. The information resources may include instructions (e.g., scripts, executable code, etc.) that, when interpreted by the application 12, cause the application 12 to display a graphical user interface (e.g., an interactable web page and/or an interactive mobile application) to a user (e.g., a first application interface). In various implementations, the application 12 may include one or more application interfaces for presenting applications (e.g., mobile applications, web-based applications, virtual reality/augmented reality applications, smart television applications, etc.).
In some implementations, debug circuitry 22 may be configured to generate debug information (sometimes referred to as a "debug summary") for a content item for application 12. The debugging information may be generated based on preloaded content items, debugger requests (e.g., user interactions), and/or other collected library interactions. The debug information may include state information for the content item based on event logs collected by the event circuitry 26. For example, content item X may have a status indicating that the content item is provided through content item slot a on content network one (e.g., "content item provided," "populated," etc.). In another example, content item Y may have a status indicating that the content item is not provided through content item slot B on content network two (e.g., "content item not provided," "not populated," etc.). In yet another example, content item Z may have a status indicating that the content item is not populated through content item slot C on content network three (e.g., "unpopulated" or "inactive"). In each example, the state including the content item slots and the content network is based on analyzing the event logs collected by the event circuitry 26 and generating debugging information. In various embodiments, the debugging information may also include other information, but is not limited to, additional failure information, failure causes, repair options, timestamps, elapsed time to service/out of service, health status (e.g., a readable summary of the health status of the content item), requests for particular content items, and the like. In some implementations, the debug information can be categorized by recency or various other parameters of a user or any of the computing devices and/or circuit settings described herein. The debugging information may also be shared with third parties or other computing devices. For example, the debug information may be sent to database 310 over network 60 after generation. In another example, the debug information, after being generated, may be compiled into a report and sent to another computing device (e.g., via email, airDrop, bluetooth, messaging) or saved to another storage system.
In an example embodiment, the application 12 executed by the client device 10 may overlap the application interface with a debug interface on the client device 10. For example, a user may perform a gesture (e.g., input) on client device 10 to invoke a debugging interface. In response, debug circuitry 22 executing the debug interface may request data, for example from a content item event log stored in database 310 or directly from event circuitry 26. For example, upon request, the event circuitry 26 may begin collecting content item event logs (sometimes referred to herein as "requests") and transmit them when an event (or request) occurs. In another example, upon request, the first data processing system 300 may perform a database query (e.g., query database 310) to identify previously collected content item event logs (e.g., within the past hour, between particular time frames, between particular frames, the most recent ten, etc.). In some implementations, the event circuitry 26 can collect content item event logs in a particular session and bundle them together at the end of the particular session. For example, a user may initiate a test session to test various aspects of application 12 by performing various interactions (e.g., clicking, scrolling, viewing, navigating, etc.), and during the test session, event circuitry 26 may collect and/or generate various debugging information. In this example, once the session is completed (e.g., after a failure, after application shutdown, upon request, etc.), the content item event logs may be bundled together by the event circuitry 26 and sent to the debug circuitry 22, stored on the client device 10 (e.g., in a cache, in memory, etc.), and/or sent to the first data processing system 300 for analysis and/or storage.
In another example embodiment, application 12 executed by client device 10 may cause a web browser to display a debugging interface on client device 10. For example, a user may connect (e.g., via network 60) to a website that is structured to host a debugging interface. In various implementations, the hosted debugging interface may include infrastructure such as, but not limited to, a host device (e.g., a computing device) and a collection of files that define the debugging interface and are stored on the host device (e.g., in a database). A web browser operates by receiving an input of a Uniform Resource Locator (URL) into a field from an input device (e.g., a pointing device, a keyboard, a touch screen, a mobile phone, or other form of input device). In response, debug circuitry 22, which executes a debug interface in the web browser, may request data, such as from a content item event log, from database 310. The web browser may include other functionality, such as navigation controls (e.g., back and forward buttons, home button). In some implementations, the debug interface can include both a client-side interface and a server-side interface. For example, the client interface may be written in one or more general-purpose programming languages and may be executed by the client device 10. The server-side interface may be written in one or more general-purpose programming languages, for example, and may be executed by the first data processing system 300. Additional details associated with the debug interface will be described in detail with reference to example figures 5-7.
The event circuit 26 may detect events within the application 12. In various embodiments, the event circuitry 26 may be configured to trigger other functions based on detecting a particular event (e.g., a transaction, an in-app purchase, reaching a certain level in an in-app game, performing a certain number of actions, taking a certain amount of time to interact with an application, etc.). For example, event circuitry 26 may trigger debug circuitry 22 upon detection of an event within application 12. In various embodiments, the library 20 includes functionality embedded in the application 12 to trigger the event circuit 26. For example, the user may include the following library 20 functions in the transaction confirmation function of the application 12: which causes the event circuit 26 to detect the confirmed transaction. It should be understood that events may include any action within an application that is important to a user and are not limited to the examples explicitly contemplated herein. In various embodiments, the event circuitry 26 is configured to distinguish between different types of events. For example, event circuitry 26 may trigger a first set of actions based on a first type of detected event. And a second set of actions may be triggered based on a second type of detected event. In various embodiments, event circuitry 26 is configured to collect event logs associated with the detected one and/or more events and to transmit the collected event logs to debug circuitry 22.
The event circuitry 26 may also bundle (e.g., aggregate, etc.) the event logs. In various embodiments, the event circuitry 26 receives an event log associated with one or more detected events in the application 12 and/or on the client device 10. Event circuitry 26 may collect event logs from one or more events and bundle the event logs for transmission (e.g., to debug circuitry 22). For example, the event circuitry 26 may collect event logs from ten events and combine the event logs into a single bundle. The event log may include a timestamp of the event, a name of the event, and/or parameters of the event (e.g., items purchased, price, currency, discounts, subscription information, etc.). In some embodiments, event circuitry 26 transmits the bale to debug circuitry 22. Additionally or alternatively, event circuitry 26 may transmit the bale to input/output circuitry 28 and/or debug circuitry 22. In various embodiments, the event circuitry 26 generates a data bundle. The data bale may include a bale index, a bale timestamp, bale data, and a bale signature. In various embodiments, the bale signature is generated by the event circuit 26. In some embodiments, the bale index specifies where in the bale data a particular event log is located. For example, the bundle data may include a byte array and the bundle index may include an index to the byte array.
In various embodiments, the event circuitry 26 may collect event logs based on specified sessions. In one example, the specified session may be active from when the application 12 is opened/selected to when the application 12 is closed/exited. In another example, the specified session may be active based on the user requesting a session start and requesting a session end. For each session, the event circuitry 26 may collect an event log while the session is active. Once completed, the event log may be provided to any of the systems described herein. During a session, the event log may track each event in the session such that the events are organized in ascending and/or descending order. In some implementations, the events can be organized using various other techniques (e.g., by event type, by timestamp, by fault, etc.).
In various implementations, the event circuitry 26 of the client device 10 (e.g., a test device) may begin collecting event logs when the application 12 is opened (e.g., selected by a user via the input/output device 28 of the client device 10), thereby beginning a session. In some embodiments, the event circuitry 26 may stop collecting the event log once the application is closed by the user, thereby ending the session. In various embodiments, the user may force a clearing of the event log or force a reset of the application 12 so that the current session may be reset, thereby ending the particular session and starting a new session. For example, if a user desires a content network test, the user may want to force a reset of the application 12 so that only new event logs associated with the content network test are collected.
Input/output circuitry 28 is configured to send and receive communications over network 60 (e.g., with first data processing system 300). The input/output circuitry 28 is configured to exchange data (e.g., bundled event logs, content event logs, interactions), communications, instructions, etc. with the input/output components of the first data processing system 300. In one embodiment, the input/output circuit 28 includes communication circuitry for facilitating the exchange of data, values, messages, etc. between the input/output circuit 28 and the first data processing system 300. In yet another embodiment, the input/output circuitry 28 includes a machine-readable medium for facilitating the exchange of information between the input/output device and the first data processing system 300. In yet another embodiment, the input/output circuitry 28 includes any combination of hardware components, communication circuitry, and a machine-readable medium.
In some embodiments, the input/output circuitry 28 includes suitable input/output ports and/or uses an interconnection bus (not shown) for interconnection with a local display (e.g., a touch screen display) and/or a keyboard/mouse device (as applicable), etc., for local user interface for programming and/or data entry, retrieval, or other user interaction purposes. Thus, the input/output circuitry 28 may provide a user with an interface to interact with various applications (e.g., applications 12) stored on the client device 10. For example, the input/output circuitry 28 includes a keyboard, keypad, mouse, joystick, touch screen, microphone, haptic sensor, automobile sensor, internet of things sensor, biometric sensor, acceleration sensor, virtual reality headset, smart glasses, smart headset, and the like. As another example, the input/output circuitry 28 may include, but is not limited to, a television monitor, a computer monitor, a printer, a facsimile machine, speakers, and the like. As used herein, each of virtual reality, augmented reality, and mixed reality may be used interchangeably, but refer to any kind of augmented reality, including virtual reality, augmented reality, and mixed reality.
In some implementations, input/output circuitry 28 of client device 10 may receive user input from a user (e.g., through a sensor or any other input/output device/port described herein). The user input may be a plurality of inputs including, but not limited to, gestures (e.g., flicking the client device 10, shaking the client device 10, user-defined custom gestures (e.g., utilizing an API), biometric data (e.g., pressure level, heart rate, hand geometry, facial geometry, psychology, etc.), and/or behavioral data (e.g., haptic feedback, gestures, voice patterns, motion patterns (e.g., hands, food, arms, faces, irises, etc.), or combinations thereof, etc. in some embodiments, one or more user inputs may be used to perform various actions on the client device 10.
The input/output circuit 28 may transmit the bundled event log to the first data processing system 300. In various embodiments, input/output circuit 28 transmits data over network 60. Input/output circuitry 28 may acknowledge the transfer of data. For example, the input/output circuitry 28 may transmit the bundled event log to the first data processing system 300 and receive confirmation that the bundled event log was successfully received. In some embodiments, the input/output circuitry 28 first attempts to transmit the bundled event log to the first data processing system 300 and, if it fails, attempts to transmit the bundled event log to the first data processing system 300 after a predefined period of time has elapsed (e.g., one minute, five minutes, one hour, etc.). In some embodiments, input/output circuitry 28 transmits different data to first data processing system 300 based on various factors (e.g., type of data, amount of data, time, etc.). For example, input/output circuitry 28 may transmit an encrypted event log with a device identifier to first data processing system 300 based on the data being personal identification data (e.g., a data type), and may transmit an unencrypted event log without a device identifier to first data processing system 300 at different times based on the amount of data (e.g., one gigabyte, one terabyte, etc., since large amounts of data being encrypted may require large network bandwidth).
In various embodiments, input/output circuitry 28 may transmit data periodically. For example, input/output circuit 28 may transmit data at predetermined times. As another example, the input/output circuitry 28 may transmit data at certain intervals (e.g., every ten minutes, every ten hours, etc.). Additionally or alternatively, the input/output circuitry 28 may transmit data in response to a threshold value. For example, the input/output circuit 28 may transmit data in response to the event circuit 26 receiving a threshold number of event logs from events (e.g., ten events, one hundred events, etc.). In some embodiments, input/output circuit 28 transmits data dynamically. For example, input/output circuitry 28 may transmit data in response to client device 10 being connected to a charging source. As another example, input/output circuitry 28 may transmit data in response to a transmit packet reaching a specified data size (e.g., one megabyte, one gigabyte, etc.).
In some embodiments, input/output circuitry 28 reports the metrics. For example, input/output circuitry 28 may transmit metrics with each data packet. The metrics may include a size of the data bundle, a timestamp of transmission and/or generation of the data bundle, a data bundle index, a debugger identifier, and/or a signature of the data bundle. In various embodiments, the debugger identifier includes information associated with library 20. For example, the debugger identifier may include a version number of the library 20. The signature of the data bundle may include a hash (hash) of the contents of the data bundle.
The first data processing system 300 may receive event logs from the repository 20 and facilitate performing analysis on the received data to generate information. For example, the first data processing system 300 may receive a data bundle including an event log from the repository 20 and securely associate the received data with data stored in the database 310 to generate information. As another example, the first data processing system 300 may receive first data associated with a transaction and second data associated with metadata comprising the transaction specifying the content item and the content item slot from the library 20 and correlate the first and second data.
In various embodiments, the first data processing system 300 generates aggregated information. For example, the first data processing system 300 may determine how many users completed the transaction after interacting with the content item. The aggregated information may describe the number or grouping of online interactions (e.g., interactions with multiple content items). Additionally or alternatively, the aggregated information may describe separate online interactions (e.g., a single interaction with a single content item). The aggregated information may include a unique identifier. In some implementations, the identifier identifies a marketing campaign. Additionally or alternatively, the identifier may uniquely identify each online interaction and/or application interaction. In some implementations, the aggregation information describes one or more interactions associated with the content item. For example, the aggregated information may include the time, date, and/or location of the online interaction. The interactions described by the anonymous interaction data may include viewing the content item (e.g., navigating to a web page in which the content item is presented and/or determining that the item or a portion of the item is presented within a view of a device on which the web page is viewed, etc.), selecting/clicking on the content item, hovering over the content item, and/or other interactions with the content item.
The first data processing system 300 may be a server, a distributed processing cluster, a cloud processing system, or any other computing device. The first data processing system 300 may comprise or execute at least one computer program or at least one script. In some embodiments, first data processing system 300 includes a combination of software and hardware, such as one or more processors configured to execute one or more scripts.
First data processing system 300 is shown to include a database 310 and processing circuitry 320. Database 310 may store the received data. For example, the database 310 may store event logs received from the library 20 and/or supplemental data received from the first data processing system 300. In some embodiments, database 310 stores identifiers. For example, the database 310 may store event logs and supplemental data that share intermediate identifiers. The identifier may later be used for association of anonymous interaction data. Database 310 may include one or more storage media. The storage medium may include, but is not limited to, magnetic storage, optical storage, flash memory, and/or RAM. First data processing system 300 may implement or facilitate various APIs to perform database functions (i.e., to manage data stored in database 310). The API may be, but is not limited to, SQL, ODBC, JDBC, NOSQL, and/or any other data storage and manipulation API.
In various implementations, database 310 may include a front end 330 that may store mapping information, user inputs (e.g., gestures), and client devices for registered users. For example, during registration, the analysis circuit 328 may query the front end 330 to store new registration information. In some implementations, the front end 330 may include key-value pairs of registered client devices to registered user inputs (e.g., particular gestures).
The processing circuit 320 includes a processor 322 and a memory 324. Memory 324 may have stored thereon instructions that, when executed by processor 322, cause processing circuit 320 to perform various operations described herein. The operations described herein may be implemented using software, hardware, or a combination thereof. The processor 322 may include a microprocessor, ASIC, FPGA, or the like, or a combination thereof. In many embodiments, processor 322 may be a multicore processor or an array of processors. Memory 324 may include, but is not limited to, an electronic, optical, magnetic, or any other storage device capable of providing processor 322 with program instructions. Memory 324 may include a floppy disk, CD-ROM, DVD, magnetic disk, memory chip, ROM, RAM, EEPROM, EPROM, flash memory, optical media, or any other suitable memory from which processor 322 may read instructions. The instructions may include code from any suitable computer programming language, such as, but not limited to, C + +, C #, java, javaScript, perl, HTML, XML, python, and Visualbasic.
In various embodiments, the analysis circuit 328 performs statistical operations on the received data to generate statistical measures that describe the received data. For example, the analysis circuitry 328 may determine an interaction rate associated with the marketing campaign. In some implementations, the analysis circuitry 328 generates demographic information (e.g., user distribution, etc.), geographic results (e.g., location distribution, etc.), and/or audiences (e.g., a target group of users based on one or more parameters, such as purchasing more than a threshold amount of users, etc.) based on one or more parameters. In some implementations, the analysis circuit 328 correlates the event log with the supplemental data. For example, the analysis circuitry 328 may correlate event logs associated with the event with supplemental data associated with the content interaction using the intermediate identifier to determine the impact of the content interaction on causing the event. In various embodiments, the analysis circuit 328 generates information. This information may include interaction rates, data describing the operation of the application 12, and so forth.
Further, the statistical operations performed by analysis circuitry 328 may produce usage metrics for the client device (e.g., client device 10) and library 20. Some usage metrics may include, but are not limited to, device registration metrics (e.g., test device registration-how many accounts have registered at least one client device, number of test devices registered-on average how many test devices are registered per account), initialization method metrics (e.g., initialization method-what is the classification (breakdowns) of the method used to initialize the checkers), debugger metrics (e.g., debugger overall use-how many times the debugger is initialized, debugger penetration-percentage of application using the debugger at least once, debugger reuse-how often the debugger is used after the first use), content item status metrics (e.g., fill-down-drill-how many percentage of users drill down to display "filled" content items on the content item screen, no fill-down-how many percentage of users drill down to display "no fill" content items on the content item screen, content items-how many percentage of content items in a given application have at least one debugger request), content item event log metrics (e.g., error spread-how many error percentages are spread), feedback metrics (e.g., feedback usage-percentage of feedback users submit feedback), content network test metrics (e.g., single content network usage-how many percentages of users go to single content item test, network usage-how many different networks a single content network user uses on average, degree of network usage-how many percentages of networks a user performs a single content network test on). The statistical operations performed by analysis circuitry 328 may also generate impact metrics for client devices (e.g., client device 10) and library 20. Some impact metrics may include, but are not limited to, new publisher guidance (onboarding) metrics (e.g., what percentage of debugger users get their interactions supplied (new publisher)), new application guidance funnel metrics (e.g., what percentage of debugger users get their interactions supplied (new application)), error resolution metrics (e.g., what percentage of errors displayed in the debugger are subsequently resolved), product Sales Lead (PSL) metrics (e.g., percentage of cases of PSL or bugs that change), and developer relationship (DevRel)/Advertiser Technology Solution (ATS) metrics (e.g., how many times rel/ATS have put a debugger solution to the publisher).
In various embodiments, the usage metrics and impact metrics may be calculated based on performing various statistical operations and analyses. The usage and impact metrics may be further prioritized based on various factors (e.g., publisher segment, publisher region, application platform, language preferences, new or existing publishers, etc.). In some implementations, the received data and previously collected data (e.g., event logs, content items, debugging information) stored in the database 310 can be used to train a machine learning model. That is, predictions about usage and impact may be based on artificial intelligence or machine learning models. For example, a first machine learning model may be trained to identify specific effects of the library 20 and output a prediction. In this example, the second machine learning model may be trained to recognize usage based on previous usage of the library 20. In various embodiments, the machine learning algorithm may include, but is not limited to, neural networks, convolutional neural networks, recurrent neural networks, linear regression models, and sparse vector machines). Various computing systems/devices described herein may input various data (e.g., event logs, debugging information, etc.) into a machine learning model and receive output from the model indicating a particular action to perform.
In some implementations, the analysis circuit 328 can be configured to perform content source testing on one or more content networks. Content source testing on one or more content networks may include executing various test plans for the application 12 with one or more content items associated with a content item slot. During source testing, various faults and anomalies may be identified. Additionally, the content network may be identified such that the testing occurs over a specified content network (e.g., or multiple specified content networks). Typically, a content network connects content items to applications and websites that host the content items. That is, the content network may receive content from a content provider, and the content network may then provision (or provide) the content (e.g., content items) to one or more applications (e.g., application 12) and/or websites so that the user may interact with the content (e.g., purchase items of the content provider, register services of the content provider, perform any actions based on the provided content). In some implementations, the application 12 (or library 20) can communicate directly with a content network (e.g., a third party) hosted on one or more computing devices (e.g., computer system 800 in fig. 8). An online advertising network or advertising network is a company that connects advertisers to websites that want to host advertisements. A key function of the advertising network is to aggregate and match the ad supply from the publishers to the needs of the advertisers. In various embodiments, the library 20 may communicate directly with the content network to obtain the configuration (e.g., delivery information for content items, content item slot information, etc.).
In various embodiments, debug circuitry 22 may also perform content source testing on one or more content networks (as also described in detail with reference to fig. 5-7). In some implementations, debug circuitry 22 and analysis circuitry 328 may work in parallel to perform various content source tests and may share resources to improve network latency, bandwidth, and/or storage capacity.
Referring now to FIG. 2, a flow diagram of a method 200 of debugging a content item is shown, in accordance with some embodiments. The system 100 may be configured to perform the method 200. Further, any of the computing devices described herein may be configured to perform the method 200.
In the broad overview of method 200, at block 202, one or more processing circuits (e.g., client device 10, first data processing system 300, and/or computer system 800 in FIG. 8, etc.) may present a first application interface. At block 204, the one or more processing circuits may generate debug information from the content event log. At block 206, the one or more processing circuits may detect a predetermined user action. At block 208, the one or more processing circuits may present the debugging information. Additional, fewer, or different operations may be performed in the method depending on the particular arrangement. In some arrangements, some or all of the operations of method 200 may be performed by one or more processors executing on one or more computing devices, systems, or servers. In various arrangements, each operation may be reordered, added, removed, or repeated. Combinations and variations of the operations of the methods described herein are also included within the scope of the present disclosure (e.g., one or more blocks of method 350 may be incorporated into method 200).
Generally, the method 200 depicts a method of debugging delivery of a content item. That is, the debug interface may be provided to a non-technician (e.g., a non-application developer) to repair the failure and perform testing of the content item through the debug interface without the need for encoding. This may enable a non-technician to test content item implementations (on physical or virtual devices) without the need for in-depth technical knowledge. For any problems discovered (sometimes referred to herein as "faults"), detailed information may be passed to a more technical user for further investigation. The debug interface is an in-application overlay (facilitated by the library 20 (e.g., SDK)) that can be invoked using a physical gesture, an API call, another action, or a combination of each. The debugger interface allows users to move from a high-level view of their application content item health (e.g., application 12) up to detailed technical responses around specific repair calls made to various content networks.
Referring in more detail to the method 200, at block 202, a mobile application executing on a mobile device may present a first application interface. In various implementations, the first application interface may be a mobile application interface presented based on a user selecting a mobile application on a display of the mobile device. The first application interface may require an account login to identify the user. In some implementations, the first application interface can present a "home screen" for a given application. Further, a user of the mobile device may have multiple mobile applications that may display additional application interfaces.
At block 204, the mobile device may generate debugging information from a content event log, wherein the content event log is associated with a content item slot, wherein the content item is presented in the mobile application. The library 20 may automatically generate (and also collect) debug information associated with the content event log after an application executing on the mobile device detects a predetermined user action. For example, upon launching the application 12, a session may begin and the library may automatically generate debugging information.
In some implementations, each content item slot can include various data, but is not limited to, the content item served (sometimes referred to herein as "delivered") in the content item slot, the content item identification (or name, unique ID, etc.), the content item slot type (e.g., banner, paged, bonus, etc.), and one or more debugger requests, including a content network (e.g., content network) that populated the content item, a content fill status (e.g., served content, content not served, etc.), and a timestamp of the last event (e.g., two seconds ago, two minutes ago, two hours ago, etc.). In one example, the content fill status may be identified in the content event log by: an "inactive" state (e.g., no debugger requests are made for the content item slot during the session), a "fill" state (e.g., a recently completed debugger request for the content item slot results in "fill"), and a "no fill" state (e.g., a recently completed debugger request for the content item slot results in "no fill").
In various implementations, each content item slot can include a content event log specific to that content item slot. The content event log (also sometimes referred to herein as a "bundled event log") may be based on data collected by the event circuitry 26 from one or more events occurring on the application 12. Debug circuitry 22 may receive content event logs from application 12 event circuitry 26 and/or the first data processing system (e.g., database 310, among others), and debug circuitry 22 may analyze each content event log and may generate debug information with the additional information. For example, as the user navigates through the application 12 through the first application interface, the user may click (e.g., execute a request for) a content item in a content item slot. In this example, the event circuitry 26 may generate a content event log each time a user clicks on a content item. The content event log may include various data of the content item slots as the user interacts with them. In some implementations, a user can perform a session that includes performing a number of actions (e.g., clicking, viewing, scrolling, etc.), such that a content event log can have an event string (e.g., a debugger request string) associated with the session. In one example, the event strings may be sorted in descending order of most recently completed debugger requests. In an alternative example, the event strings may be arranged in ascending order of most recently completed debugger requests. In some implementations, the debugger request string can include a request for each attempt made to one or more content networks. Additional details regarding the session and event string are described in detail with reference to fig. 1 and 5.
At block 206, the mobile device may detect a predetermined user action. The predetermined user action may be any action that the user may provide through the mobile device. The mobile device may detect the predetermined user action based on various sensors located on or in the mobile device (e.g., through input/output circuitry 28 described in detail with reference to fig. 1). The predetermined user action may be set by the user during registration of the mobile device and/or modified after registration. In particular, the predetermined user action may be, but is not limited to, a gesture (e.g., flicking the client device 10, shaking the client device 10, a user-defined custom gesture (e.g., utilizing an API)), biometric data (e.g., stress level, heart rate, hand geometry, facial geometry, mind, etc.), and/or behavioral data (e.g., haptic feedback, gesture, voice pattern, motion pattern (e.g., hand, food, arm, face, iris, etc.), combinations thereof, and the like.
Various methods may be used to initiate debug interface initialization on a mobile device. In some implementations, as indicated above, the user can provide a predetermined user action (e.g., a physical gesture, a custom Application Programming Interface (API) call, etc.) that can trigger presentation of the debug interface on the mobile device. Either way, the device may need to be registered as a debug device to invoke the debug interface. For example, where a user utilizes a custom API as a way to call a debug interface, if the device is not registered, no activity will occur at the front end, but the publisher will receive an error callback in the code. In various embodiments, custom APIs may be used to invoke a debugger, and thus no code-free gestures and/or actions may be required in order for a user to trigger the debugger.
In some implementations, to qualify a mobile device for utilizing a debug interface, a user may have to register the mobile device (e.g., client device 10) as a debug device for first data processing system 300. In addition to enabling the debugging tool, the first device processing system 300 can mark (e.g., in a table in the database 310) the device as a "debugging device" so that developers can debug content items without the risk of their accounts being suspended. During registration, the mobile device may prompt the user to provide one or more of a device name, a platform, a code (e.g., two-dimensional code, pseudo-random code, etc.), a content item identification, a user/publisher identifier, and a predetermined user action, among others, but is not limited to a device name, a platform, a code (e.g., two-dimensional code, pseudo-random code, etc.), a content item identification, a user/publisher identifier, and a predetermined user action, among others. The first data processing system 300 may receive user input based on the prompt and register the device using the provided input. In some implementations, the first data processing system 300 may cross-reference available user information (e.g., from the database 310) to verify the provided information before the user device is registered. In various embodiments, registration may not be required to utilize the library 20 and/or debug interface. Further, a user may register multiple devices to use a commissioning tool (e.g., library 20). For example, a user may register a mobile device for use "on the go" (e.g., not sitting down), but may also register a tablet for use "at home" or "not on the go" (e.g., sitting down).
In block 208, in response to detecting the predetermined user action, the debug interface may present the debug information. The debug interface may present various data (e.g., or sub-interfaces) indicative of various activities. For example, the debug interface can present a summary screen that lists all content item slots associated with one or more content items. The summary screen may be sorted by activity recency (in descending order of most recently completed debugger requests for content item slots). In other words, the content item slot with the most recent event (i.e., a completed debugger request) will be listed at the top, followed by the content item slot with the next most recent event, and so on. In some implementations, content item slots that do not have any events (no activity) for the current session will appear at the bottom of the list organized alphabetically based on their content item slot names. In various embodiments, when the debug interface is presented, it may be dynamically updated to include new event information based on one or more newly completed debugger requests (e.g., banner refreshes or end of game cycles). That is, where there are more recent events, the ordering of the content item slots will be rearranged in real-time (e.g., because the debug interface is streaming/dynamic). In one example, after startup, if library 20 determines that client device 10 experiences difficulty in presenting or updating a debugger interface (e.g., based on low bandwidth, power saving mode, slow networking speed, processor/over-usage, overheating, etc.). The library 20 may update the debug interface to present only the five most recent events and only refresh when the user takes action or explicitly refreshes. Additional details regarding the debug interface are described in detail with reference to fig. 5-7.
Referring now to FIG. 3, a flow diagram of a method 350 of debugging a content item, according to some embodiments. The system 100 may be configured to perform the method 200. Further, any of the computing devices described herein may be configured to perform method 350.
In the broad overview of method 350, one or more processing circuits (e.g., client device 10, first data processing system 300, and/or computer system 800 in FIG. 8, etc.) may receive a registration request at block 352. At block 354, the one or more processing circuits may send a notification indicating that the mobile device is registered. At block 356, the one or more processing circuits may receive a content item test request. At block 358, the one or more processing circuits may test the content item on the particular content network. At block 360, the one or more processing circuits may transmit a content event log. Additional, fewer, or different operations may be performed in the method depending on the particular arrangement. In some arrangements, some or all of the operations of method 350 may be performed by one or more processors executing on one or more computing devices, systems, or servers. In various arrangements, each operation may be reordered, added, removed, or repeated. Combinations and variations of the operations of the methods described herein are also included within the scope of the present disclosure (e.g., one or more blocks of method 200 may be incorporated into method 350).
Referring in more detail to method 350, at block 352, the one or more processing circuits may receive a registration request that includes an identifier associated with a mobile application on a mobile device and an activation gesture.
At block 354, the one or more processing circuits may send a notification to a mobile application on the mobile device indicating that the mobile device is registered. In various implementations, the registration request information (e.g., identifier, activation gesture) may be stored in the front end 330 of the database 310.
At block 356, the one or more processing circuits may receive a content item test request for a content item in a particular content network.
At block 358, the one or more processing circuits may test the content item on the particular content network. In various implementations, a mobile device can perform testing of content items on a particular content network. In some implementations, the client device and the one or more processing circuits may work together to perform the test.
At block 360, the one or more processing circuits may transmit a content event log to a mobile application on the mobile device, the content event log including debugging information for the content item during testing on the content network.
Referring now to fig. 4, an example illustration of a registration interface 400 according to some embodiments. As shown, a registration interface 400 is included to enable a user to register the user's user account with a client device (e.g., client device 10). In various implementations, a user may have a user account with login credentials and account data stored in a database (e.g., database 310). The account data may include information about client devices registered with a debugger (e.g., library 20) of an application (e.g., application 12). That is, a user account may be registered with multiple client devices such that each client device may use a debugger on one or more applications stored on the client device. For example, bob's user account may be registered with "mobile device 1" so that mobile device 1 may be used to debug "application X". In another example, jane's user account may be registered with "mobile device 2" so that mobile device 2 may be used to debug "application Y".
Further, during the registration process, registration interface 400 may include various fields (e.g., 410, 412, 414, 416, 418). The input slot may include a device name field 410, a platform field 412, a content ID field 414, and debugger fields 416 and 418. Each field may receive user input via the client device. For example, the user may type (e.g., via a touch screen keyboard) the device name and content ID in their respective fields (e.g., 410 and 414). In this example, during registration, the user may also provide input for the platform field 412 and select a drop down menu from the debugger field 418. Debugger field 418 may include a user input field for activating library 20. The user input field may be a gesture, as shown, or may be various other user inputs as described above with reference to FIG. 1.
In various embodiments, each field may be various forms of input fields (e.g., text input, buttons, drop-down menus, speech-to-text, etc.). Moreover, various additional fields are contemplated in the present disclosure. In some implementations, once the user provides input to various fields in the registration interface 400, the client device 10 can send the input (e.g., over the network 60) to the first data processing system 300 for storage and/or analysis. In various implementations, the client device may register immediately after submitting the input or after being analyzed by the system described herein. In some implementations, a user associated with a user account may be able to manage client devices registered with one or more applications. Management may include, but is not limited to, removing client devices, changing configurations (e.g., names, gestures), and the like.
Referring now to fig. 5A-5C, example illustrations of debug interface 23, according to some embodiments. In general, fig. 5A-5C illustrate a debug interface 23 that may be rendered at a client device 10 to debug and test content item slots and content items associated with a content item event log. Debug interface 23 may include a plurality of interfaces and objects. For example, client device 10 may execute to provide debug information to debug interface 23 based on events executing in application 12.
In example illustration 500, client device 10 presents application 12, which may include one or more content item slots (e.g., content slot 504), in a viewport of client device 10. The application 12 may be any type of application used by a user of the client device 10 (e.g., in an application store, downloaded, customized, etc.). In various embodiments, client device 10 may register as a test device for application 12 (as described above). Upon a user action (e.g., gesture), the example illustration 510 may be presented in a viewport of the client device 10. For example, when the client device 10 recognizes shaking (e.g., by a sensor), the library 20 may be initialized and the debug interface 23 may be presented within the viewport of the client device 10.
In example illustration 510, various debugging information may be presented, such as content item slot data including an identifier 512 and activity data 516. The identifier 512 may include data specific to a particular content item slot of the application 12. As shown, the identifiers may be mid-game full-screen content item slots, top banner content item slots, end-of-game bottom banner content item slots, player revival bonus content item slots, home page banner content item slots, and home page banner 2 content item slots. Each of the identifiers 512 may include activity data 516. The activity data 516 may indicate activity associated with the collected content event logs.
The content event logs may be collected by the event circuitry 26 during execution of the application 12 (e.g., during a session). Debug circuitry 22 may receive the content event log, analyze the content event log, and generate debug information. As shown, the activity data can include fill information indicating whether a content item is served (e.g., served, delivered, shown, presented) in a particular content item slot. The activity data may also include a timestamp of the most recent activity and the content network supplying the content item. In some implementations, inactive content item slots may be grayed-out or de-emphasized (de-emphasised), and the most recent activity data 516 for the identifier may be at the top of the viewport and descend through the next most recent activity data, and so on. For example, the mid-game full screen identifier may have a latest event indicating a timestamp, a service status (e.g., filled, unfilled, delivered, undelivered, etc.), and a content network service/served. Upon selection 514 by a user of client device 10 (e.g., via a touch screen display), example illustration 520 may be presented in a viewport of client device 10. For example, upon receipt of the selection by the client device 10, the library 20 may update the debug interface 23 to present debug information specific to the content item slot selected by the selection 514.
In example illustration 520, various debugging information, such as content item slot data, including detailed event logs 522, including event logs 524 and event logs 528, may be presented. Each event log may include additional data, including service status 523 and fault 526 (sometimes referred to herein as an "error summary"). As shown, the example illustration 520 presents a detailed view of a particular content item slot. In some implementations, the detailed view may present a list of all attempted requests/events made to each content network of the library 20. In various implementations, events can be ordered based on activity (e.g., timestamp and most recently completed) and each event can include server state (e.g., filled, not filled, etc.). In various implementations, the event logs (e.g., 524 and 528) may be content item specific, such that each event log may be activity of a particular content item in a particular content item slot.
The content event logs (e.g., 524 and 528) may be titled by the time of the debugger completion time (e.g., 12. In addition, it will include a start time, an end time, and a duration (in seconds). (e.g., 12 am. In some implementations, the event log may show requests made after a particular event (e.g., a successful fill event, the end of a waterfall). In particular, each particular event may also include, but is not limited to, a content network name, the result of the event (e.g., fill state), and the duration of its execution (e.g., round trip time for each event). In some implementations, the request may only present events that complete successfully if the event is in progress. Further, as shown, the debug information for a particular event may include a fault (e.g., 526). In one example, the failure 526 may indicate a failure of the content item (e.g., an incorrect content item size, a return failure, an exception, etc.). In another example, the fault 526 may indicate a software crash or a hardware failure of the client device 10, the application 12, the library 20, and/or the network 60. In some embodiments, the failure may be determined by client device 10, content circuitry 326, and/or analysis circuitry 328. For example, the client device 10 may identify a software crash associated with the application 12. In another example, the analysis circuitry 328 may identify large delays between certain events in the content event logs (e.g., 524 and 528) after receiving a bundle of event logs. In yet another example, the content circuitry 326 may identify a content item slot service error after receiving an interaction with a content item presented in a content item slot on the client device 10.
In the example illustration 530 of fig. 5B, the client device 10 may receive various selections 532 and 534 via the debug interface 23, which may allow the user to further debug the content event log without developing experience. As shown, once a user selects an event in the detailed event log 522, an example illustration 540 may be presented through a viewport of the client device 10.
In example illustration 540, descriptions (e.g., 542 and 544) regarding the detailed event log 522 can be presented for analysis. As shown, causes and actions may be concatenated into descriptions 542 and 544 of their respective events. In various implementations, the description may include a selectable link for modifying the configuration of the content item.
In the example illustrations 550-590 of FIG. 5C, the debug interface 23 depicts additional scenarios of the presented debug information, particularly content event logs. For example, in scenario 1 of example illustration 550, library 20 executes and presents a waterfall of content item slots that are not populated based on a content Network (e.g., T-Rex Network, fantastic Ad Network, adMob Network). In this example, the T-Rex and Fantastic networks do not return content items, but do not have errors (e.g., exceptions and/or faults), except that there are no content items populated for the content item slots. Furthermore, as shown, the AdMob network does not return a content item, but does encounter an error, thus depicting why the content item has not been filled in.
In another example, in scenario 2 of example illustration 560, library 20 executes and presents a waterfall of the content item slots that are indeed populated based on the content network. In this example, the T-Rex and Fantastic networks do not return content items, but have no errors, except that there are no content items populated for the content item slots. Furthermore, as shown, the AdMob network does fill without errors.
In another example, in scenario 3 of example illustration 570, library 20 executes and presents a waterfall of content item slots that are not populated based on the content network. In this example, the AdMob network is not populated and encounters an error (e.g., the ad unit does not match the format). In various embodiments, the user may modify the content item configuration through the library 20 to fix the error. For example, the repair may be performed by selecting an AdMob network and modifying a particular content item configuration associated with the format of the content item.
In another example, in scenario 4 of example illustration 580, library 20 executes and presents a waterfall of the content item slots that are indeed populated based on the content network. In this example, the T-Rex network does not return a content item, but has no errors, except that there are no content items to fill for the content item slot. Furthermore, as shown, the AdMob network does fill without errors.
In yet another example, in scenario 5 of example illustration 590, library 20 executes and presents a waterfall of content item slots that are positively populated based on the content network. In this example, the T-Rex network does not return a content item, but has no errors, except that there are no content items to fill for the content item slot.
In some implementations, the entity can place bids on content items in the content item slots. In such implementations, the example illustrations 550-590 can also include open bid auction results, including but not limited to who won the auction, and presenting it in an order in which it is based on a ranking relative to the price of the waterfall (e.g., or events in the content event log). In some implementations, the entity may be associated with a priority, and the error message may include additional or less detail based on the priority of the entity.
Referring now to fig. 6A-6C, example illustrations of debug interface 23, according to some embodiments. In general, fig. 6A-6C depict a user (e.g., a non-application developer) selecting a particular content network to test the capabilities of intermediary settings and server-side configurations. In general, an intermediary adapter is a library (e.g., library 20) that enables the library to communicate with other libraries (e.g., stored on client device 10, and/or over network 60). Thus, other libraries may be packaged separately so that content providers can select the intermediary adapters they desire and test different intermediary settings (e.g., with five intermediary adapters, with ten intermediary adapters, etc.).
During these tests, the user may use the debug interface 23 to ensure that the user is using the correct intermediary adapter and that the user has entered the correct content item identifier, both of which may be addressed by rendering (or presenting) the content item in the application 12. In general, latency can be a problem when performing content network testing on an individual's content network. However, as shown in fig. 6A-6C, the user may force a particular content network test through the debug interface 23. In some implementations, content network testing can be performed using a Virtual Private Network (VPN) in a particular geographic location (e.g., latitude and longitude). In one example, the content network test may be based on a particular geographic area (e.g., building, town, state, country) such that the VPN may be used to test in the particular geographic area.
In example illustration 600, debug interface 23 may include a test toggle 602 such that a "test mode" may be activated and deactivated upon toggling. In various embodiments, the test mode may include testing the functionality of various content items and content item slots on a particular content network. In some implementations, during testing, the client device 10 may collect content event logs. For example, when the client device 10 receives the selection, the library 20 may update the debug interface 23 to present the content network test overlay 612.
In the example illustration 610, a content network test overlay 612 is presented having various functions, including a content network drop down menu 614 and a selectable information icon 616. In some implementations, upon selection of the selectable information icon 616, the debug interface 23 can overlay information about the content network test on additional pages.
In example illustration 620, client device 10 receives a selection of a start test selectable icon 622. For example, upon selection of a content network in the content network drop down menu 614 and selection of the selectable icon 622, the library 20 may begin a content network test.
In example illustration 630, debug interface 22 may provide a notification 632 in a viewport of client device 10 indicating that application 12 (e.g., the application being debugged) should be restarted. In various embodiments, the application 12 may not need to be restarted. In some implementations, the notification 632 may be dismissed (diswise) by the selectable icon 634.
In example illustration 640, debug interface 23 in a viewport of client device 10 can present a pop-up notification 642 indicating that the content network test is active. Additionally, the debug interface 23 in the viewport of the client device 10 may include a notification 644 of the content network being tested. In various embodiments, pop-up notification 642 may persist throughout debug interface 23 such that it is always presented. In some embodiments, when library 20 is in test mode, all debugger requests will attempt to return content items for the selected content network. For example, if "content network 1" is selected and a content item slot is given but the content network 1 is not used, there is no population with an error message (sometimes referred to as an error summary or failure) indicating that the "content item slot is not configured for the content network named content network 1".
In example illustration 650, debug interface 23 may become minimized or closed such that a user may interact with application 20 within a viewport of client device 10. For example, the user may select content item slot 654 and library 20 may collect all events associated with the interaction. In various embodiments, debug interface 23 may be automatically minimized after starting content network testing or after user action (e.g., gesture input such as during registration). In some implementations, certain user actions (e.g., other than initialization actions) may be set during registration to "toggle" between debug interfaces 23 during content network testing.
In example illustration 660, debug interface 23 may become overlaid on application 12 based on user actions (e.g., gestures) and/or based on completion of content network testing. As shown, debug interface 23 may include another content network test overlay 662 that enables a user to select a stop test selectable icon 664.
In the example illustration 670, a user may select a test switch 676 (e.g., also 602) to exit the test mode. In various embodiments, upon exiting test mode, event circuitry 26 may send a content event log associated with the content network test to debug circuitry 22 and/or first data processing system 300 for analysis.
In example illustration 680, the debug interface 23 in the viewport of the client device 10 can present a pop-up notification 682 indicating that the content network testing is disabled (e.g., or stopped).
Referring now to fig. 7A-7B, example illustrations of a debug interface, according to some embodiments. In general, fig. 7A enables a non-application developer to send feedback associated with debug interface 23 (e.g., example illustrations 700 and 710). The feedback may also include direct feedback from the user regarding improvements, changes, and additions to the debug interface 23. In some implementations, sending the feedback can also include content event log sharing, such that when a fault/error is discovered, the content event log can be forwarded to a third party system (e.g., the first data processing system 300). For example, upon selection 702, an overlay debugger configuration 712 including a send feedback selectable link 714 may be presented. In some implementations, upon selecting the send feedback optional link 714, the debug circuitry 22 can bundle the debug information and send (e.g., via email, bluetooth, text, etc.) the content event log bundle to a third party system (e.g., the first data processing system 300 or another computer on the network 60). In various embodiments, the overlay debugger configuration 712 may also include a version of the library 20 (e.g., v19.3, v 1.3) and/or a version of the content network. In various embodiments, debug interface 23 may also enable non-application developers to clear all previously saved and collected content event logs.
Generally, FIG. 7B depicts an empty state of debug interface 23, indicating that no content item slots and/or content event log data have been collected by library 20. In various embodiments, an empty status may be presented if no account is registered with the client device 10. In some embodiments, the empty state may be presented if library 20 fails (or malfunctions) in initializing (or loading) debug interface 23.
FIG. 8 illustrates a depiction of a computer system 800, which computer system 800 may be used, for example, to implement the illustrative client device 10, the illustrative first data processing system 300, and/or various other illustrative systems described in this disclosure. Computing system 800 includes a bus 805 or other communication component for communicating information, and a processor 810 coupled with bus 805 for processing information. Computing system 800 also includes a main memory 815, such as a Random Access Memory (RAM) or other dynamic storage device, coupled to bus 805 for storing information and instructions to be executed by processor 810. Main memory 815 also may be used for storing location information, temporary variables, or other intermediate information during execution of instructions by processor 810. Computing system 800 may also include a Read Only Memory (ROM) 820 or other static storage device coupled to bus 805 for storing static information and instructions for processor 810. A storage device 825, such as a solid state device, magnetic disk or optical disk, is coupled to bus 805 for persistently storing information and instructions.
In some implementations, computing system 800 may include a communications adapter 840, such as a network adapter. A communication adapter 840 may be coupled to bus 805 and may be configured to enable communication with a computing or communication network 130 and/or other computing systems. In various illustrative embodiments, any type of networked configuration may be implemented using the communication adapter 840, such as wired (e.g., via ethernet), wireless (e.g., via WiFi, bluetooth, etc.), pre-configured, ad-hoc (ad-hoc), LAN, WAN, etc.
According to various embodiments, the processes for implementing the illustrative embodiments described herein may be implemented by the computing system 800 in response to the processor 810 executing an arrangement of instructions contained in main memory 815. Such instructions may be read into main memory 815 from another computer-readable medium, such as storage device 825. Execution of the arrangement of instructions contained in main memory 815 causes the computing system 800 to perform the illustrative processes described herein. One or more processors in a multi-processing arrangement may also be employed to execute the instructions contained in main memory 815. In alternative implementations, hard-wired circuitry may be used in place of or in combination with software instructions to implement the illustrative embodiments. Thus, implementations are not limited to any specific combination of hardware circuitry and software.
Although an example processing system has been described in fig. 8, implementations of the subject matter and the functional operations described in this specification can be performed using other types of digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software embodied in tangible media, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on one or more computer storage media for execution by, or to control the operation of, data processing apparatus. Alternatively or additionally, the program instructions may be encoded on an artificially generated propagated signal (e.g., a machine-generated electrical, optical, or electromagnetic signal) that is generated to encode information for transmission to suitable receiver apparatus for execution by the data processing apparatus. The computer readable storage medium may be or be embodied in a computer readable storage device, a computer readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Further, although the computer storage medium is not a propagated signal, the computer storage medium can be a source or destination of computer program instructions encoded in an artificially generated propagated signal. The computer storage medium may also be or be contained in one or more separate components or media (e.g., multiple CDs, disks, or other storage devices). Thus, computer storage media is both tangible and non-transitory.
The operations described in this specification may be implemented as operations performed by data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
The term "data processing apparatus" or "computing device" includes all types of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or a plurality or combination of the above. The apparatus can comprise special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment may implement a variety of different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.
A computer program (also known as a program, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with the instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer does not necessarily have such a device. Further, a computer may be embedded in another device, e.g., a mobile phone, a Personal Digital Assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a Universal Serial Bus (USB) flash drive), to name a few. Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, such as internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, implementations of the subject matter described in this specification can be implemented using a computer having a display device (e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor) for displaying information to the user and a keyboard and a pointing device (e.g., a mouse or a trackball) by which the user can provide input to the computer. Other types of devices may also be used to provide for interaction with a user; for example, feedback provided to the user can be any form of sensory feedback, such as visual feedback, auditory feedback, or tactile feedback; input from the user can be received in any form, including acoustic, speech, or tactile input. Further, the computer may interact with the user by sending and receiving documents to and from the device used by the user; for example, by sending a web page to a web browser on a user's client device in response to a request received from the web browser.
Implementations of the subject matter described in this specification can be performed using a computing system that includes a back end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front end component (e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described is this specification), or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include local area networks ("LANs") and wide area networks ("WANs"), the internet (e.g., the internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks, distributed ledger networks).
The computing system may include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some implementations, the server transmits data (e.g., HTML pages) to the client device (e.g., for the purpose of displaying data to and receiving user input from a user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) may be received at the server from the client device.
In some demonstrative embodiments, the features disclosed herein may be implemented on a smart television module (or connected television module, hybrid television module, and the like), which may include processing circuitry configured to integrate an internet connection with a more traditional television program source (e.g., via cable, satellite, over-the-air, or other signal reception). The smart television module may be physically incorporated into a television, or may comprise a separate device, such as a set-top box, a blu-ray or other digital media player, a game console, a hotel television system, and/or other companion device. The smart television module may be configured to allow viewers to search and find videos, movies, photos, and other content on a network, local cable channels, satellite television channels, or stored on a local hard drive. A Set Top Box (STB) or Set Top Unit (STU) may include an information appliance device that may contain a tuner and connect to a television and an external signal source to convert the signal into content that is then displayed on a television screen or other display device. The smart television module may be configured to provide a main screen or top-level screen including icons for a plurality of different applications, such as a web browser and a plurality of streaming media services (e.g., netflix, vudu, hulu, disney +, etc.), connected cable or satellite media sources, other network "channels," and so forth. The smart television module may also be configured to provide an electronic program guide to the user. A companion application to the smart television module may be operable on the mobile computing device to provide additional information to the user about available programming, to allow the user to control the smart television module, and so on. In alternative embodiments, these features may be implemented on a laptop or other personal computer, smartphone, other mobile phone, handheld computer, smartwatch, tablet computer, or other computing device.
While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any inventions or of what may be claimed, but rather as descriptions of features specific to particular implementations of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be combined or performed in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination. Furthermore, features described with respect to particular headings may be used with respect to and/or in conjunction with the illustrative embodiments described under other headings; the headings provided are included for readability purposes only, and should not be construed as limiting any of the features provided in relation to such headings.
Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the implementations described above should not be understood as requiring such separation in all implementations, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products embodied on tangible media.
Thus, particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. Moreover, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In some embodiments, multitasking and parallel processing may be advantageous.
Claims (24)
1. A computer-implemented method of debugging delivery of a content item, the method comprising:
presenting, by a mobile application executing on a mobile device, a first application interface;
generating debugging information from a content event log, wherein the content event log is associated with a content item slot in which a content item is presented in the mobile application;
detecting, by the mobile device, a predetermined user action; and
presenting, by a debug interface, the debug information in response to detecting a predetermined user action.
2. The method of claim 1, further comprising:
repairing, by the debug interface, the first exception to the debug information based on modifying a configuration of delivery of the content item.
3. The method of claim 1, wherein the debug interface is presented as an overlay on the first application interface.
4. The method of claim 1, further comprising:
sending, by the mobile application, a registration request including an identifier and an activation gesture; and
receiving, by the mobile application, a notification indicating that the mobile device is registered.
5. The method of claim 1, wherein the predetermined user action is a gesture, and wherein the gesture is at least one of a shake, flick, or user-defined custom gesture configured within the mobile application.
6. The method of claim 1, wherein the content event log includes a plurality of events based on a threshold time period or a threshold number of events, and wherein each event of the plurality of events includes usage data for the content item presented in the mobile application.
7. The method of claim 1, wherein:
each of the content item slots includes different debug information;
organizing the content event log in the debug interface based on recency of different debug information for each of the content item slots; and
inactive content items are organized together.
8. The method of claim 1, further comprising:
updating, by the debug interface, the content event log in real-time based on receiving additional debug information associated with the content item.
9. The method of claim 1, further comprising:
extending, by the debug interface, the debug information to include a detailed description of the debug information, wherein the detailed description includes one or more action items.
10. The method of claim 1, further comprising:
requesting, by the debug interface, a content item test for a content item in a particular content network, wherein the content item is associated with a plurality of content networks for displaying the content item.
11. The method of claim 1, further comprising:
transmitting, by the debug interface, the content event log to a repair system.
12. A computer-implemented method of debugging delivery of a content item, the method comprising:
receiving, by one or more processing circuits, a registration request comprising an identifier associated with a mobile application on a mobile device and an activation gesture;
sending, by the one or more processing circuits, a notification to a mobile application on the mobile device indicating that the mobile device is registered;
receiving, by the one or more processing circuits, a content item test request for a content item in a particular content network;
testing, by the one or more processing circuits, a content item on the particular content network; and
transmitting, by the one or more processing circuits, a content event log to a mobile application on the mobile device, the content event log including debugging information for a content item during testing on the content network.
13. The method of claim 12, further comprising:
communicating, by the one or more processing circuits, with a debug interface configured for presentation on the mobile device.
14. The method of claim 12, wherein the debugging information is configured for presentation in a debugging interface configured for presentation on the mobile device.
15. The method of claim 14, wherein the debug interface is configured for presentation as an overlay on the first application interface.
16. The method of claim 12, wherein the activation gesture is at least one of a shake, flick, or user-defined custom gesture configured within the mobile application.
17. The method of claim 12, wherein the content event log comprises a plurality of events based on a threshold time period or a threshold number of events, and wherein each event of the plurality of events comprises usage data for a content item presented in the mobile application.
18. The method of claim 12, wherein the content event log is associated with a content item slot in which content items are presented in the mobile application.
19. The method of claim 14, wherein:
the content event log is associated with a content item slot in which content items are presented in the mobile application;
each of the content item slots includes different debug information;
organizing the content event log in the debug interface based on recency of the different debug information for each of the content item slots; and
inactive content items are organized together.
20. The method of claim 12, further comprising:
updating, by the one or more processing circuits, the content event log in real-time based on obtaining additional debugging information associated with the content item.
21. The method of claim 12, further comprising:
transmitting, by the one or more processing circuits, a detailed description of the debug information, wherein the detailed description comprises one or more action items.
22. The method of claim 12, wherein the content item is associated with a plurality of content networks for displaying the content item.
23. The method of claim 12, further comprising:
transmitting, by the one or more processing circuits, one or more repair calls to the particular content network.
24. The method of claim 23, wherein transmitting the one or more repair calls comprises:
transmitting, by the one or more processing circuits, the content event log.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202063108025P | 2020-10-30 | 2020-10-30 | |
US63/108,025 | 2020-10-30 | ||
PCT/US2021/057192 WO2022094175A2 (en) | 2020-10-30 | 2021-10-29 | Systems and methods of debugging delivery of content items |
Publications (1)
Publication Number | Publication Date |
---|---|
CN115210695A true CN115210695A (en) | 2022-10-18 |
Family
ID=78771194
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202180017868.0A Pending CN115210695A (en) | 2020-10-30 | 2021-10-29 | System and method for debugging delivery of content items |
Country Status (6)
Country | Link |
---|---|
US (1) | US20220138077A1 (en) |
EP (2) | EP4336335A2 (en) |
JP (1) | JP2023525433A (en) |
KR (1) | KR20220124290A (en) |
CN (1) | CN115210695A (en) |
WO (1) | WO2022094175A2 (en) |
Family Cites Families (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20150128110A1 (en) * | 2013-11-05 | 2015-05-07 | Alexander Falk | Mobile application development and deployment |
GB2521364A (en) * | 2013-12-17 | 2015-06-24 | Ibm | Recording GUI data |
US11023363B2 (en) * | 2016-03-11 | 2021-06-01 | Spirent Communications, Inc. | Performance test application sequence script |
US10061683B2 (en) * | 2016-03-22 | 2018-08-28 | Symantec Corporation | Systems and methods for collecting error data to troubleshoot product errors |
US10585682B2 (en) * | 2016-08-05 | 2020-03-10 | Oracle International Corporation | Tenant self-service troubleshooting for a multi-tenant identity and data security management cloud service |
WO2018133190A1 (en) * | 2017-01-22 | 2018-07-26 | 华为技术有限公司 | Authentication method, mobile terminal, device and system |
US10853232B2 (en) * | 2018-01-19 | 2020-12-01 | Spirent Communications, Inc. | Adaptive system for mobile device testing |
US10810412B2 (en) * | 2018-09-20 | 2020-10-20 | Zebra Technologies Corporation | Method, system and apparatus for gesture-based configuration of paired scanner |
US10788954B1 (en) * | 2019-04-11 | 2020-09-29 | Elasticsearch B.V. | Systems and methods for integration of application performance monitoring with logs and infrastructure using a common schema |
GB201913773D0 (en) * | 2019-09-24 | 2019-11-06 | Blancco Tech Group Ip Oy | Determining a status of a mobile electronic device |
-
2021
- 2021-10-29 JP JP2022552343A patent/JP2023525433A/en active Pending
- 2021-10-29 EP EP23211825.7A patent/EP4336335A2/en active Pending
- 2021-10-29 CN CN202180017868.0A patent/CN115210695A/en active Pending
- 2021-10-29 WO PCT/US2021/057192 patent/WO2022094175A2/en unknown
- 2021-10-29 EP EP21815002.7A patent/EP4091060B1/en active Active
- 2021-10-29 KR KR1020227029824A patent/KR20220124290A/en unknown
- 2021-10-29 US US17/515,068 patent/US20220138077A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
JP2023525433A (en) | 2023-06-16 |
US20220138077A1 (en) | 2022-05-05 |
KR20220124290A (en) | 2022-09-13 |
WO2022094175A2 (en) | 2022-05-05 |
WO2022094175A3 (en) | 2022-06-09 |
EP4336335A2 (en) | 2024-03-13 |
EP4091060A2 (en) | 2022-11-23 |
EP4091060B1 (en) | 2023-12-06 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11838350B2 (en) | Techniques for identifying issues related to digital interactions on websites | |
US11468454B2 (en) | Method, apparatus, and computer program product for consumer tracking | |
US10733079B2 (en) | Systems and methods for end-to-end testing of applications using dynamically simulated data | |
US10218651B2 (en) | Virtual assistance for chat agents | |
EP3177997A2 (en) | Policy based resource management and allocation system | |
US11330024B2 (en) | Personalized content sharing platform | |
US20150120816A1 (en) | Tracking use of content of an online library | |
KR101847761B1 (en) | Method and system to facilitate transactions | |
EP3796155A1 (en) | Improving acquisition process of gui elements using user input | |
US10348579B2 (en) | Ubiquitous trouble management and E-service ecosystem for the internet of things | |
US20210042134A1 (en) | Providing non-invasive guided assistance to a client device | |
WO2020146698A1 (en) | Systems and methods for enhanced host classification | |
US20240037176A1 (en) | Using embedded elements for online content verification | |
US11709759B2 (en) | Contextual drill back to source code and other resources from log data | |
JP2023542646A (en) | Smart span prioritization based on plug-in service backpressure | |
EP4091060B1 (en) | Systems and methods of debugging delivery of content items | |
US10423970B2 (en) | Changing depth of analytics tracking or content targeting based on user value | |
US10165075B1 (en) | Retrieving shared content by proxy | |
CN115461743A (en) | System and method for delegated analytics collection | |
CN114730340A (en) | Protecting user privacy in user interface data collection | |
US9148468B1 (en) | Distributing shared content |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |