US20220171693A1 - Optimizing large scale data analysis - Google Patents
Optimizing large scale data analysis Download PDFInfo
- Publication number
- US20220171693A1 US20220171693A1 US16/960,817 US201916960817A US2022171693A1 US 20220171693 A1 US20220171693 A1 US 20220171693A1 US 201916960817 A US201916960817 A US 201916960817A US 2022171693 A1 US2022171693 A1 US 2022171693A1
- Authority
- US
- United States
- Prior art keywords
- data
- register
- determining
- registers
- hashed parameter
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/34—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment
- G06F11/3452—Performance evaluation by statistical analysis
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/34—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment
- G06F11/3409—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment for performance assessment
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/34—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment
- G06F11/3404—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment for parallel or distributed programming
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/34—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment
- G06F11/3442—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment for planning or managing the needed capacity
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2458—Special types of queries, e.g. statistical queries, fuzzy queries or distributed queries
- G06F16/2462—Approximate or statistical queries
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/44—Arrangements for executing specific programs
- G06F9/448—Execution paradigms, e.g. implementations of programming paradigms
- G06F9/4488—Object-oriented
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/465—Distributed object oriented systems
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06Q—INFORMATION AND COMMUNICATION TECHNOLOGY [ICT] SPECIALLY ADAPTED FOR ADMINISTRATIVE, COMMERCIAL, FINANCIAL, MANAGERIAL OR SUPERVISORY PURPOSES; SYSTEMS OR METHODS SPECIALLY ADAPTED FOR ADMINISTRATIVE, COMMERCIAL, FINANCIAL, MANAGERIAL OR SUPERVISORY PURPOSES, NOT OTHERWISE PROVIDED FOR
- G06Q30/00—Commerce
- G06Q30/02—Marketing; Price estimation or determination; Fundraising
- G06Q30/0241—Advertisements
- G06Q30/0251—Targeted advertisements
- G06Q30/0269—Targeted advertisements based on user profile or attribute
Definitions
- This specification generally relates to computing processes for resource and space efficient storage and analysis of large scale datasets.
- Collecting and analyzing data about different objects in a digital environment online interactions, components, resources, etc. can be beneficial to providers of content products, and/or services.
- providers can aggregate data for numerous (e.g., millions or billions) objects to, for example, improve the provider's services and/or improve a user online experience.
- providers may aggregate the data for components or resources of a server firm to determine how frequently components of the server farm are failing (or operating in a certain manner).
- providers may aggregate the data about several devices interacting with certain content to determine how frequently these devices interact with the content.
- one innovative aspect of the subject matter described in this specification can be embodied in methods that include the operations of obtaining activity data for a plurality of objects in a dataset, wherein each object in the dataset performs activities in a digital environment and the activity data represents the activities; for each data item in the dataset: generating, using an identifier for au object specified in the data item, a hashed parameter for the object, wherein the hashed parameter has a binary representation; identifying a register from among a set of registers based on the binary representation of the hashed parameter, wherein each register in the set of registers is used to store data about objects in the dataset; determining, based on the binary representation of the hashed parameter, that the hashed parameter for the object contributes to an aggregation amount that specifies a number of occurrences of the object in the dataset; and in response to determining that the hashed parameter for the object contributes to the aggregation amount, updating the aggregation amount stored in the register; and generating, based on
- inventions of this aspect include corresponding systems, devices, apparatus, and computer programs configured to perform the actions of the methods.
- the computer programs e.g., instructions
- each object represents a user; and an aggregation amount represents a frequency value.
- identifying a register from among a set of registers based on the binary representation of the hashed parameter comprises: identifying a first portion of the binary representation of the hashed parameter; and identifying the register using the first portion of the binary representation of the bashed parameter.
- each register in the set of registers comprises a data structure that stores data about a received hashed parameter, wherein the data structure includes: a first field for storing data specifying a number of leading zeroes in a second portion of the received hashed parameter; a second field for storing data specifying trailing bits in a second portion of the received bashed parameter; and a third field for storing data specifying an aggregation amount that indicates a number of occurrences when (i) an existing data value in the first held matches the number of leading zeroes and (ii) an existing data value in the second field matches the trailing bits.
- determining, based on the binary representation of the hashed parameter, that the hashed parameter for the object contributes to an aggregation amount comprises: determining a number of leading zeros from the second portion of the binary representation of the hashed parameter; determining trailing bits from the second portion of the binary representation of the hashed parameter; and determining, based on the number of leading zeros and the trailing bits, that the hashed parameter impacts an existing data value stored in the third field of the data structure of the register.
- determining, based on the number of leading zeros and the maximum number of trailing bits, that the hashed parameter impacts an existing data value stored in the third field of the data structure of the register comprises: determining that the existing data value stored in the first field of the data structure of the register is the same as the number of leading zeros; and determining that the existing data value stored in the second field of the data structure of the register is the same as the maximum number of trailing bits.
- updating the aggregation amount stored in the register comprises incrementing the existing data value stored in the third field of the data structure of the register by one.
- generating, based on aggregate amounts stored in the set of registers, a reporting output that indicates a set of data items, wherein each data item identities an estimated number of objects in the dataset that performed activities in the digital environment at a particular aggregation amount comprises: identifying a set of unique aggregate amounts based on aggregation amounts stored in the set of registers; for each particular aggregation amount in the set of aggregation amounts, determining an estimated number of objects of the dataset that performed activities at the particular aggregation amount, the determining includes: determining a number of registers storing an aggregation amount that matches the particular aggregation amount, adjusting the number of registers storing the aggregation amount that matches the particular aggregation amount based on a hash collision correction factor; determining tin average number of object stored in each register of the set of registers; and scaling the adjusted number of registers by the average number of objects.
- HLL HyperLogLog
- activity data as further described below
- Conventional methods require substantially more computing and storage resources than those required by techniques and/or systems described in this specification, which is especially the case when performing these operations on large datasets.
- the techniques and/or systems in this specification require substantially less storage and can perform more time rand resource efficient processing of large datasets to determine a frequency distribution of the objects in the dataset based on the object' activity data.
- FIG. 1 is a block diagram of an example computing system for computing information for a dataset.
- FIG. 2 is a flowchart of an example process for computing aggregate distributions based on activity data for objects in a dataset.
- FIG. 3 is a block diagram of a computing system that can be used in connection with methods described in this specification.
- This specification describes techniques for using a probabilistic cardinality estimator, such as a HyperLogLog data structure, for providing, a distribution of objects in a dataset across different aggregate values (e.g., frequencies) based on the activity data for the objects.
- a probabilistic cardinality estimator such as a HyperLogLog data structure
- the techniques described in this specification enhance conventional HyperLogLog (HLL) data structures in a manner that enables computing such aggregate (e.g., frequency) distributions, which is not possible using the conventional HLL data structures.
- HLL HyperLogLog
- An object can be an entity, resource, or component such as users, spam events, system components, digital assets, etc.
- Each object in the dataset air associated with or performs certain activities in a digital environment and the activity data in the dataset represents the activities of the objects.
- This can include, for example, data describing device interactions with certain digital assets (e.g., portions of content), such as which users clicked on, viewed, or otherwise interacted with a content for a particular digital campaign.
- the activity data can include log data about hardware/component events (e.g., failures, resets, outages, network calls, memory access, or other events) in a network environment.
- the conventional HLL data structure can be used to measure or estimate the number of unique objects in a large dataset (i.e., the cardinality of the dataset).
- the conventional HLL data structures cannot determine an aggregate distribution of the objects based on the activity data of the objects.
- this data structure cannot be used to determine a distribution of the number of users who have viewed the content at particular frequencies (e.g., one time, two times, three times, etc.).
- Examples of such aggregation counters can include, among others, (1) a frequency counter that counts the number of occurrences of, the object in the dataset, (2) a counter that counts the most recent timestamp at which a particular event was recorded at, and (3) a counter that counts counting the number of times an error code was observed at each error logging levels.
- An HLL data engine assigns objects in the dataset to a set of M registers.
- the object's unique identifier (as further described below) is hashed using a hash function to generate a hashed parameter as further described below) that has a binary representation.
- the HLL data engine uses a certain number of hits (e.g., the first four bits) of the hashed parameter to assign the object to one of the M registers.
- the HLL data engine determines an aggregate number of times that the object has been associated with or performed a certain activity. As described below and in greater detail throughout this specification, the HLL data engine accomplishes this by evaluating whether the remaining bits of the hashed parameter (i.e., the bits other than those that were used, to identify the register) contribute to an aggregation amount, e.g., that specifies a number of occurrences of the object in the dataset.
- an aggregation amount e.g., that specifies a number of occurrences of the object in the dataset.
- the HLL data engine determines the number of leading zeros (which also represents the bit position of the most significant non-zero bit) for the remaining bits of the hashed parameter. If the number of leading zeros is the same as the value stored in the first field of the register, the HLL data engine determines a set of trailing bits for the previously determined most significant bit (or another appropriate stable identifier, as described above). If the determined trailing bits are the same as the value stored in the trailing p bits field of the register, the data engine determines that the current object is the same as the object for which data is already stored in the register. As a result, the HLL data engine updates the aggravation counter field of the register, e.g., by incrementing the value stored in that field by one or by performing another appropriate commutative reduction operation.
- the HLL data engine can determine the number of objects in the dataset that occurred at and or above a certain aggregate value (e.g., frequency). The HLL data engine computes this value by scaling the number of registers (e.g., adjusted to account for any hash collisions) for which the aggregation counter was set to a certain aggregate value by the average number of objects per register.
- a certain aggregate value e.g., frequency
- a user may be provided with controls allowing the user to make an election as to both if and when systems, programs, or features described herein may enable collection of information (e.g., information about a user's social network, social actions, or activities, profession, a user's preferences, or a user's current location), and if the user is sent content or communications from a server.
- information e.g., information about a user's social network, social actions, or activities, profession, a user's preferences, or a user's current location
- certain data may be treated in one or more ways before it is stored or used, so that personally identifiable information is removed.
- a user's identity may be treated so that no personally identifiable information can be determined for the user, or a user's geographic location may be generalized where location information is obtained (such as to a city, ZIP code, or state level), so that a particular location of a user cannot be determined.
- location information such as to a city, ZIP code, or state level
- the user may have control over what information is collected about the user, how that information is used, and what information is provided to the user.
- FIG. 1 is a block diagram of an example computing system 100 for computing information for a dataset.
- System 100 generally includes a computing server 102 , a HLL data engine 104 , a data storage device 130 , and a data ingest engine 140 .
- the system 100 includes special-purpose hardware circuitry configured to execute specific computational rules that measure or estimate the aggregate distribution of the objects in a dataset based on the activity data for the objects. These techniques can be applied to various applications.
- the techniques described in this specification can be used in digital campaign reach assessment, which includes generating data describing a distribution of users that have interacted with a particular campaign at different frequencies, e.g., how many unique users interacted (e.g., viewed, clicked on, etc.) with a digital content once, twice, thrice, etc.
- the techniques described in this specification can be used to analyze hardware/component failures in a large scale network environment, which includes generating statistics about how frequently certain components or computing devices fail in the network environment. It will be understood that the techniques described in this specification may be used in other applications as well.
- the system 100 includes a computing server 102 , which is configured to use a HyperLogLog (HLL) data engine 104 to determine an aggregate distribution of objects in a dataset based on their activity levels.
- HLL HyperLogLog
- the term engine refers to a data processing apparatus that performs a set of tasks.
- the HLL data engine 104 is included within computing server 102 as a sub-system of hardware circuits (e.g., special-purpose circuitry) that includes one or more processor microchips.
- computing server 102 can include processors (e.g., central or graphics processing units), memory, and data storage devices 106 that collectively form computer systems of computing server 102 .
- processors e.g., central or graphics processing units
- memory e.g., central or graphics processing units
- data storage devices 106 e.g., data storage devices that collectively form computer systems of computing server 102 .
- Processors of these computer systems process instructions for execution by server 102 , including instructions stored in the memory or on the dataset storage device 106 to display graphical information for output at an example display monitor of system 100 .
- execution of the stored instructions causes one or more of the actions described in this specification to be performed by the computing server 102 or the HLL data engine 104 .
- multiple processors may be used, as appropriate, along with multiple memories and types of memory.
- computing server 102 may be connected with multiple other computing devices, with each device (e.g., a server bank, groups of servers, modules, or a multi-processor system) performing portions of the actions, operations, or logical flows described in this specification.
- System 100 can receive, via data ingest engine 140 , a dataset including activity data for a plurality of objects in a digital environment.
- the received dataset is provided to the HLL data engine 104 of the computing server 102 .
- the HLL data engine 104 uses the logic engine 116 , including the hashing logic 108 , the leading zero logic 110 , and the register ID logic 112 , to store the data of the dataset in a set of M registers 125 in memory 106 .
- Data ingest engine 140 also receives queries, which request data about the number of objects in the dataset that are associated with or otherwise performed activities in the digital environment at particular frequencies. For example, a query 150 can request data about the number of unique users in the dataset that viewed, accessed, or otherwise interacted with content a certain number of times (e.g., one time, two times, three times, etc.). The data ingest engine 140 sends the query 150 to the computing server 102 , which in turn uses the HLL data engine 104 (and in particular, the repot ting logic 114 ) to determine the number of distinct users in a dataset and their distribution across different frequencies based on their activity data.
- queries which request data about the number of objects in the dataset that are associated with or otherwise performed activities in the digital environment at particular frequencies.
- a query 150 can request data about the number of unique users in the dataset that viewed, accessed, or otherwise interacted with content a certain number of times (e.g., one time, two times, three times, etc.).
- the HLL data engine 104 then, alone or in combination with a front end engine of the computing server 102 , provides the determined distribution data as reporting output 180 .
- the reporting output 180 can be statistics in the form of text or a visual representation (e.g., a histogram, a pie chart, etc.) showing the number of users who are associated with or otherwise performed certain activities at different frequencies, e.g., one time, two times, etc.
- the reporting output 180 may be in the form of a data structure that can be processed by computing server 102 or by another computing device.
- HLL data engine 104 (as shown in FIG. 1 ) that are used in generating such statistics and the respective operations of these components are described further with reference to FIG. 2 below.
- FIG. 2 is a flowchart of an example process 200 for computing aggregate distributions based on activity data for objects in a dataset.
- Process 200 can be implemented or executed using computing resources of system 100 , and in particular the HLL data engine 104 , described above. Operations of the process 200 are described below for illustration purposes only. Operations of the process 200 can be performed by any appropriate device or system, e.g., any appropriate data processing apparatus. Operations of the process 200 can also be implemented as programmed instructions stored on a non-transitory computer readable medium (such as the memory and/or data storage device 130 , described with reference to FIG. 1 ) and executed by at least one processor of the computing server 102 .
- a non-transitory computer readable medium such as the memory and/or data storage device 130 , described with reference to FIG. 1
- the data ingest engine 140 obtains activity data for a plurality of objects in a dataset (at 202 ).
- the data ingest engine 140 receives data logs specifying the activity data in a digital environment for objects in a dataset (wherein each object can occur one or more times in the dataset).
- the data logs can include separate fields (or delimiters that can be used to delineate different data items) corresponding to an object identifier for the object and the corresponding activity data for the object.
- the object identifier is a value (e.g., a number, alphanumeric string, data structure) that uniquely identities a particular object in the dataset.
- the object identifier is a byte (e.g., eight bits), while in other implementations the object identifier is a data word formed by, e.g., 12 bits, 16 bits, 32 bits, or 64 bits. In some cases, a variable number of bits can be used to form the object identifier, such as more than 64 bits or fewer than 64 bits.
- the data ingest engine 140 sends the received dataset to the HLL data engine 104 of the computing server 102 .
- the process 200 then performs the operations 204 , 206 , 208 , and 210 , which are further described below. As a result of performing these operations, the process 200 accumulates an aggregate distribution of objects in the data set based on the activity data associated with or performed by these objects.
- the HLL data engine 104 generates a hashed parameter 128 for the object using the hashing logic 108 (at 204 ).
- the hashing logic 108 applies one or more hash functions (which may include any conventional hash function/s) to the object identifier for the object to generate the hashed parameter (which may also be referred to as a hash, hash code, or hash value).
- the hashed parameter has a binary representation whose length is dependent upon the hash function itself or the parameters of the hash function.
- the hash of object identifier for the object is indicated as the hashed parameter 128 , as shown in FIG. 1 .
- the HLL data engine 104 identifies a register from among a set of registers that can be used to store data about the object (at 206 ).
- data for a dataset can be stored in a set of M registers 125 .
- the register ID logic 112 identifies one of the M registers that can be used to store data about the object For example, for the flashed parameter 128 (0001 0101 0100), the register ID logic 112 can uses the first four bits (0001) to identify one of the M registers. It will be appreciated that the number of registers 125 is less than the number of data items in the dataset.
- the HLL data engine 104 determines whether the hashed parameter contributes to a frequency amount (at 208 ).
- the hashing logic 108 identifies a second portion of the hashed parameter 128 , which includes the bits of the hashed parameter without the first set of bits that are used to identify the appropriate register (as described above at operation 206 )
- the hits (0101 0100) do not include the first four bits that are used by the register ID logic 112 to identify the appropriate register (as described in the preceding paragraph).
- the leading zero logic 110 determines the number of leading zeros (which also represents the bit position of the most significant non-zero bit) in the second portion or set of hits. In some implementations, the leading zero logic 110 determines the number of leading zeros by counting the number of zeros, from left to right, in the second set of bits until the bit position of the first “1” in the second set of bits is identified. For example, the number of leading zeros for the second set of bits (0101 0100) of the hashed parameter 128 is one because, when counting from left to right, one zero is identified before the first “1” is encountered.
- the HLL data engine 104 determines the number of trailing bits for the most significant bit in the second set of bits, as identified in the previous paragraph.
- the HLL data engine 110 determines the trailing bits by identifying all the bits in the second set of bits after the most significant bit, which is the location where the first “1” is identified when counting from left to fight (as described in the preceding paragraph). For example, the trailing bits in the second set of bits (0101 0100) is “010100” because these are the bits that follow the first “1” that was identified when counting the leading zeros for the second set of bits.
- each register in the set of M registers 125 includes a data structure 120 that has three fields, a field for the most significant bit 122 , a field for the trailing p bits 124 , and a field for the aggregation counter 126 .
- field 124 instead of storing the trailing p bits, stores any number of trailing bits for the most significant bit in the second set of bits or alternatively, a stable identifier for the object, such as a separate hash value made up of p bits.
- the total amount of information stored in each register may only be two bytes (or 16 bits).
- the standard HLL algorithm which only stores the number of leading zeros in each register, generally required six bits of data.
- the HLL registers described in this specification can store additional data about objects in the dataset with only a marginal increase in storage requirement per register (as compared with storing the entirety of the activity data for objects in the dataset, which would require much more than two bytes of storage space).
- the aggregation counter field 126 stores the frequency amount, which specifies a number of occurrences of the object in the dataset.
- the object's hashed parameter contributes to the aggregation amount based on a comparison of the number of leading zeros and the trailing bits of the hashed parameter (as determined by tire HLL data engine 104 ) with the values stored in the most significant hit field 122 and the trailing p bits field 124 of the data structure 120 in the register (identified in operation 206 ), respectively.
- the aggregation counter Held 126 can aggregate information about objects with the same key (e.g., counting the most recent timestamp that a particular event was recorded at counting the number of times an error code was observed at each error logging levels, etc.).
- leading zero logic 110 When the number of leading zeros determined by the leading zero logic 110 Is less than the value stored in field 122 , the leading zero logic 110 does not update the data structure 120 . In other words, the existing values in fields 122 , 124 , and 126 are retained. Because this operation does not result in updating the aggregation counter field 126 , the object's hashed parameter does not contribute to the aggregation (e.g., frequency ) amount.
- the leading zero logic 110 updates field 122 with the value of the most significant bit determined by the leading zero logic 110 .
- the HLL data engine 104 also (1) updates the value stored in field 124 with the trailing bits value calculated by the HLL data engine 104 and (2) resets the value stored in field 126 to zero.
- the leading zero logic 110 When the number of leading zeros determined by the leading zero logic 110 is the same as the value stored in field 122 , the leading zero logic 110 does not update the value stored in the field 122 . In such instances, the HLL data engine 104 also determines whether to update the values stored in the fields 124 and 126 . As further described below, it does so by comparing the trailing bits determined by the HLL data engine 104 with the value stored in the trailing p bits field 124 of the data structure 120 .
- the HLL data engine 104 (1) updates the field 124 with the value of the trailing bits determined by the HLL data engine 104 and (2) resets the value of the aggregation counter field 126 to zero.
- the HLL data engine engine 104 retains (i.e., does not update) the values stored in fields 122 , 124 , and 126 .
- the HLL data engine 104 determines that the current object is the same as the object for which data is already stored in the data structure 120 . In such instances, the HLL data engine 104 (1) does not update the value already stored in the trailing p bits field 124 and (2) updates the value stored in the aggregation counter field 126 based on the commutative reduction function involving the current value of the field and the object (at 210 ).
- the HLL data engine updates the value in this field by incrementing the value stored in this field 126 by one (e.g., if the value stored in the aggregation counter field 106 is 2, the HLL data engine 104 increments that value by one, which results in a value of 3). It will be appreciated that when an aggregation distribution other than frequency is to be determined, the data engine 104 uses the commutative reduction function to appropriate scale (e.g., multiplying, dividing, incrementing by) more than one, etc.) the value in the field 126 .
- the object's hashed parameter contributes to the aggregation amount.
- the data engine 104 performs operations 206 , 208 , and 210 based on the single hash representation generated for the object at operation 204 .
- the HLL data engine 104 can perform operations 206 , 208 , and 210 using separate hash representations, in other words, the hashing logic 108 can use the object identifier to generate separate hash representations: one hash representation can be used to identify the appropriate register in the set of registers 125 , a second hash representation from which the number of leading zeros are determined, and a third hash representation from which the trailing bits are determined. The above described operations 206 to 240 can then be performed using these separate hash representations.
- the data ingest engine 140 receives a query 150 requesting an aggregation distribution of the number of objects in the dataset that performed activities in the digital environment at different frequencies (at 212 ).
- the query 150 can request a frequency distribution of the number of users in a dataset that interacted with certain content at different frequencies (one time, two times, three times, etc.).
- the data ingest engine 140 sends the query 150 to the computing server 102 , which in turn routes the query 150 to the reporting logic 114 of the logic engine 116 .
- the reporting logic 114 In response to the query 150 , the reporting logic 114 generates a reporting output that represents an aggregate distribution of the objects in the dataset based on the associated activities or activities performed by these objects in the digital environment (at 212 ). The reporting logic 114 estimate the aggregate distribution based on the aggregate value stored in the registers 125 . The reporting logic 114 generates this reporting output by performing the following operations. In some implementations, the reporting logic 114 determines the different possible aggregate values by identifying a set of values including the unique aggregate values stored in aggregation counter field 126 in the set of registers 125 . In some implementations, the query 150 may identify the aggregate values, in which case, the reporting logic 114 can skip the operation of identifying the different possible aggregate values stored in field 126 of the registers. In some implementations, the reporting logic 114 may access a set of aggregate values specified by an administrator of the system (and stored in the data storage device 130 ), in which case, the reporting logic 114 can skip the operation of identifying the different possible aggregate values stored in the registers
- the reporting logic 114 determines a number of registers that have the same value stored in the aggregation counter field 126 as the identified aggregate value. In such implementations, the reporting logic 114 counts all registers for which the value in the aggregation counter field 126 is the same as the identified aggregate value. In other implementations, the reporting logic 114 counts all registers for which the value in the aggregation counter field 126 is the same as or greater than the identified aggregate value.
- hash collisions may arise when storing and updating values in the data structure 120 of the registers 125 .
- two object identifiers for two different objects in the dataset when hashed by the hashing logic 108 , may update the same register and may have the same number of leading zeros and the same trailing bits.
- the value of this field should only be incremented by one in this scenario; however, because of the hash collision, value of this field 126 is instead incorrectly incremented by two.
- both objects e.g., may have interacted with the same content only once, the aggregation counter field 126 may incorrectly reflect that a single object interacted with the same content twice.
- the reporting logic 114 counts all registers that satisfy some criteria, which can be specified in the query (e.g. having more errors at one reporting level than another, or having a value between two bounds), that provides a function to map the value in field 126 to a boolean (e.g., include in the count or not).
- the reporting logic 114 obtains the count of registers for which the value in the aggregation counter field 126 is the same as or greater than the identified aggregate value and then adjusts (e.g., reduces) this count by a correction factor.
- the correction factor also referred to as a hash collision correction factor
- F can be represented by F(C, M, n)), and estimates the number of hash collisions expected at the identified aggregate value (a) for a number of distinct objects (c) the dataset that have performed or are associated with certain activity, which are stored in the set of M registers 125 .
- the number of distinct elements that have performed or are associated with certain activity is determined using the standard HLL algorithm.
- the correction factor is based on empirically determined lookup table of reduction values indexed by C, M, and f.
- the reporting logic 114 scales (e.g., multiplies) the adjusted number of registers (as determined in the previous paragraph) at the particular aggregate value by the average number of objects per register.
- the average number of objects per register is determined by dividing the cardinality of the dataset C (as determined using the standard HLL algorithm) by M, which is the number of registers 125 .
- the reporting logic 114 repeats the above operations for each identified frequency.
- the total number of object at a particular aggregate value can be represented using the following equation:
- R n C * B n - F ⁇ ( C , M , n ) M
- R n is the number of objects at a particular aggregate value n
- B n is the number of buckets with the aggregation counter field set to n
- C is the cardinality of the dataset
- M is the total number of registers 125
- F(C,M,n) is the correction factor.
- reporting logic 114 sends the identified frequencies and the corresponding number of determined objects to a front end engine of the computing server 102 , which uses these values to generate a report, e.g., reporting output 180 , that is provided to the entity from which the query 150 was received.
- the front end engine can use the values provided by the reporting logic 114 to generate statistics that include a set of data items, in which each data item identifies an estimated number of objects in the dataset that is associated with or performed activities in the environment at a particular frequency. These statistics can be in the form of text and/or visuals (e.g., a histogram, a pie chart, etc.) on the reporting output 180 , and show the distribution of the number of objects at different frequencies based on the activity data of the objects.
- FIG. 3 is a block diagram of computing devices 300 , 350 that may be used to implement the systems and methods described in this document, either as a client or as a server or plurality of servers.
- Computing device 300 is intended to represent various forms of digital computers, such as laptops, desktops, workstations, personal digital assistants, servers, blade servers, mainframes, and other appropriate computers.
- Computing device 350 is intended to represent various forms of mobile devices, such as personal digital assistants, cellular telephones, smartphones, smart watches, head-worn devices, and other similar computing devices.
- the components shown here, their connections and relationships, and their functions, are meant to be exemplary only, and are not meant to limit implementations described and/or claimed in this document.
- Computing device 300 includes a processor 302 , memory 304 , a storage device 306 , a high-speed interface 308 connecting to memory 304 and high-speed expansion ports 310 , and a low speed interlace 312 connecting to low speed bus 314 and storage device 306 .
- Each of the components 302 , 304 , 306 , 308 , 310 , and 312 are interconnected using various busses, and may be mounted on a common motherboard or in other manners as appropriate.
- the processor 302 can process instructions for execution within the computing device 300 , including instructions stored in the memory 304 or on the storage device 306 to display graphical information for a GUI on an external input/output device, such as display 316 coupled to high speed interlace 308 .
- multiple processors and/or multiple buses may be used, as appropriate, along with multiple memories and types of memory.
- multiple computing devices 300 may be connected, with each device providing portions of the necessary operations (e.g., as a server bank, a group of blade servers, or a multi-processor system).
- the memory 304 stores information within the computing device 300 .
- the memory 304 is a computer-readable medium.
- the memory 304 is a volatile memory unit or units.
- the memory 304 is a non-volatile memory unit or units.
- the storage device 306 is capable of providing mass storage for the computing device 300 .
- the storage device 306 is a computer-readable medium.
- the storage device 306 may be a hard disk device, an optical disk device, or a tape device a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network or other configurations.
- a computer program product is tangibly embodied in an information carrier.
- the computer program product contains instructions that, when executed, perform one or more methods, such as those described above.
- the information carrier is a computer- or machine-readable medium, such as the memory 304 , the storage device 306 , or memory on processor 302 .
- the high-speed controller 308 manages bandwidth-intensive operations for the computing device 300 , while the low speed controller 312 manages lower bandwidth-intensive operations. Such allocation of duties is exemplary only.
- the high-speed controller 308 is coupled to memory 304 , display 316 (e.g., through a graphics processor or accelerator), and to high-speed expansion ports 310 , which may accept various expansion cards (not shown).
- low seed controller 312 is coupled to storage device 306 and low-speed expansion port 314 .
- the low speed expansion port which may include various communication ports (e.g., USB, Bluetooth, Ethernet, wireless Ethernet) may be coupled to one or more input/output devices, such as a keyboard, a pointing device, a scanner, or a networking device such as a switch or router, e.g., through a network adapter.
- input/output devices such as a keyboard, a pointing device, a scanner, or a networking device such as a switch or router, e.g., through a network adapter.
- the computing device 300 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a standard server 320 , or multiple times in a group of such servers. It may also, be implemented as part of a rack server system 324 . In addition, it may be implemented in a personal computer such as a laptop computer 322 . Alternatively, components from computing device 300 may be combined with other components in a mobile device (not shown), such as device 350 . Each of such devices may contain one or more of computing device 300 , 350 , and an entire system may be made up of multiple computing devices 300 , 350 communicating with each other.
- Computing device 350 includes a processor 352 , memory 364 , an input/output device such us a display 354 , a communication interface 366 , and a transceiver 368 , among other components.
- the device 350 may also be provided with a storage device, such as a microdrive or other device, to provide additional storage.
- a storage device such as a microdrive or other device, to provide additional storage.
- Each of the components 350 , 352 , 364 , 354 , 366 , and 368 are interconnected using, various buses, and several of the components may be mounted on a common motherboard or in other manners as appropriate.
- the processor 352 can process instructions for execution within the computing device 350 , including instructions stored in the memory 364 .
- the processor may also include separate analog and digital processors.
- the processor may provide, for example, for coordination of the other components of the device 350 , such as control of interfaces, applications run by device 350 , and wireless communication by device 350 .
- Processor 352 may communicate with a user through control interface 358 and display interface 356 coupled to a display 354 .
- the display 354 may be, for example, a TFT LCD display or an OLED display, or other appropriate display technology.
- the display interface 356 may comprise appropriate circuitry for driving the display 354 to present graphical and other information to a user.
- the control interface 358 may receive commands from a user and convert them for submission to the processor 352 .
- an external interface 362 may be provided in communication with processor 352 , so as to enable near area communication of device 350 with other devices.
- External interlace 362 may provide, for example, for wired communication (e.g., via a docking procedure) or for wireless communication (e.g., via Bluetooth or other such technologies).
- the memory 364 stores information within the computing device 350 .
- the memory 364 is a computer-readable medium.
- the memory 344 is a volatile memory unit or units.
- the memory 364 is a non-volatile memory unit or units.
- Expansion memory 374 may also be provided and connected to device 350 through expansion interface 372 , which may include, for example, a SIMM card interface. Such expansion memory 174 may provide extra storage space for device 350 , or may also store applications or other information device 350 .
- expansion memory 374 may include instructions to carry out or supplement the processes described above, and may include secure information also.
- expansion memory 374 may be provided as a security module for device 350 , and may be programmed with instructions that permit secure use of device 350 .
- secure applications may be provided via the SIMM cards, along with additional information, such as placing identifying information on the SIMM card in a non-hackable manner.
- the memory may include for example, flash memory and/or MRAM memory, as discussed below.
- a computer program product is tangibly embodied in an information carrier.
- the computer program product contains instructions that, when executed, perform one or more methods, such as those described above.
- the information carrier is a computer- or machine-readable medium, such as the menial 364 , expansion. memory 374 , or memory on processor 352 .
- Device 350 may communicate wirelessly through communication interface 366 , which may include digital signal processing circuitry where necessary. Communication interface 366 may provide for communications under various modes or protocols, such as GSM voice calls, SMS, EMS, or MMS messaging, CDMA, TDMA, PDC, WCDMA, CDMA2000, or GPRS, among others. Such communication may occur, for example, through radio-frequency transceiver 368 . In addition, short-range communication may occur, such as using a Bluetooth, WiFi, or other such transceiver (not shown). In addition, GPS receiver module 370 may provide additional wireless data to device 350 , which may be used as appropriate by applications running on device 350 .
- GPS receiver module 370 may provide additional wireless data to device 350 , which may be used as appropriate by applications running on device 350 .
- Device 350 may also communicate audibly using audio codec 360 , which may receive spoken information from a user and convert it to usable digital information. Audio codec 360 may likewise generate audible sound for a user, such as through a speaker, e.g., in a handset of device 350 . Such sound may include sound from voice telephone calls, may include recorded sound (e.g., voice messages, music files, etc.) and may also include sound generated by applications operating on device 350 .
- Audio codec 360 may receive spoken information from a user and convert it to usable digital information. Audio codec 360 may likewise generate audible sound for a user, such as through a speaker, e.g., in a handset of device 350 . Such sound may include sound from voice telephone calls, may include recorded sound (e.g., voice messages, music files, etc.) and may also include sound generated by applications operating on device 350 .
- the computing device 350 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a cellular telephone 380 . It may also be implemented as part of a smartphone 382 , personal digital assistant, or other similar mobile device.
- implementations of the systems and techniques described here can be realized in digital electronic circuitry, integrated circuitry, specially designed ASICs, computer hardware, firmware, software, and/or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
- the systems and techniques described here can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- a keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- the systems and techniques described here can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component such as an application server, or that includes a front end component such as a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here, or any combination of such back end, middleware, or front end components.
- the components of the system can be interconnected by any for or medium of digital data communication such as, a communication network. Examples of communication networks include a local area network (“LAN”), a wide area network (“WAN”), and the Internet.
- LAN local area network
- WAN wide area network
- the Internet the global information network
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network.
- the relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- module As used in this specification, the terms “module,” “engine,” and “component” are is intended to include, but is not limited to, one or more computers configured to execute one or more software programs that include program code that causes a processing unit(s)/device(s) of the computer to execute one or more functions.
- computer is intended to include any data processing or computing devices/systems, such as a desktop computer, a laptop computer, a mainframe computer, a personal digital assistant, a server, a handheld device, a smartphone, as tablet computer, an electronic reader, or any other electronic device able to process data.
Abstract
Description
- This specification generally relates to computing processes for resource and space efficient storage and analysis of large scale datasets.
- Collecting and analyzing data about different objects in a digital environment online interactions, components, resources, etc.) can be beneficial to providers of content products, and/or services. In some cases, providers can aggregate data for numerous (e.g., millions or billions) objects to, for example, improve the provider's services and/or improve a user online experience. For example, providers may aggregate the data for components or resources of a server firm to determine how frequently components of the server farm are failing (or operating in a certain manner). As another example, providers may aggregate the data about several devices interacting with certain content to determine how frequently these devices interact with the content. These types of operations, particularly when performed on large datasets, can present significant technical challenges in efficiently processing, querying, and storing the data, and obtaining accurate results can cause significant system latency.
- In general, one innovative aspect of the subject matter described in this specification can be embodied in methods that include the operations of obtaining activity data for a plurality of objects in a dataset, wherein each object in the dataset performs activities in a digital environment and the activity data represents the activities; for each data item in the dataset: generating, using an identifier for au object specified in the data item, a hashed parameter for the object, wherein the hashed parameter has a binary representation; identifying a register from among a set of registers based on the binary representation of the hashed parameter, wherein each register in the set of registers is used to store data about objects in the dataset; determining, based on the binary representation of the hashed parameter, that the hashed parameter for the object contributes to an aggregation amount that specifies a number of occurrences of the object in the dataset; and in response to determining that the hashed parameter for the object contributes to the aggregation amount, updating the aggregation amount stored in the register; and generating, based on aggregate amounts stored in the set of registers, a reporting output that indicates a set of data items, wherein each data item identifies an estimated number of objects in the dataset that performed activities in the digital environment at a particular aggregation amount. Other embodiments of this aspect include corresponding systems, devices, apparatus, and computer programs configured to perform the actions of the methods. The computer programs (e.g., instructions) can be encoded on computer storage devices. These and other embodiments cart each optionally include one or more of the following features.
- In some implementations, each object represents a user; and an aggregation amount represents a frequency value.
- In some implementations, identifying a register from among a set of registers based on the binary representation of the hashed parameter, comprises: identifying a first portion of the binary representation of the hashed parameter; and identifying the register using the first portion of the binary representation of the bashed parameter.
- In some implementations, each register in the set of registers comprises a data structure that stores data about a received hashed parameter, wherein the data structure includes: a first field for storing data specifying a number of leading zeroes in a second portion of the received hashed parameter; a second field for storing data specifying trailing bits in a second portion of the received bashed parameter; and a third field for storing data specifying an aggregation amount that indicates a number of occurrences when (i) an existing data value in the first held matches the number of leading zeroes and (ii) an existing data value in the second field matches the trailing bits.
- In some implementations, determining, based on the binary representation of the hashed parameter, that the hashed parameter for the object contributes to an aggregation amount, comprises: determining a number of leading zeros from the second portion of the binary representation of the hashed parameter; determining trailing bits from the second portion of the binary representation of the hashed parameter; and determining, based on the number of leading zeros and the trailing bits, that the hashed parameter impacts an existing data value stored in the third field of the data structure of the register.
- In some implementations, determining, based on the number of leading zeros and the maximum number of trailing bits, that the hashed parameter impacts an existing data value stored in the third field of the data structure of the register, comprises: determining that the existing data value stored in the first field of the data structure of the register is the same as the number of leading zeros; and determining that the existing data value stored in the second field of the data structure of the register is the same as the maximum number of trailing bits.
- In some implementations, updating the aggregation amount stored in the register, comprises incrementing the existing data value stored in the third field of the data structure of the register by one.
- In some implementations, generating, based on aggregate amounts stored in the set of registers, a reporting output that indicates a set of data items, wherein each data item identities an estimated number of objects in the dataset that performed activities in the digital environment at a particular aggregation amount, comprises: identifying a set of unique aggregate amounts based on aggregation amounts stored in the set of registers; for each particular aggregation amount in the set of aggregation amounts, determining an estimated number of objects of the dataset that performed activities at the particular aggregation amount, the determining includes: determining a number of registers storing an aggregation amount that matches the particular aggregation amount, adjusting the number of registers storing the aggregation amount that matches the particular aggregation amount based on a hash collision correction factor; determining tin average number of object stored in each register of the set of registers; and scaling the adjusted number of registers by the average number of objects.
- Particular embodiments of the subject matter described in this specification can be implemented to enhance probabilistic data structures, such as HyperLogLog (HLL), by storing activity data (as further described below) about objects in a space-efficient manner that in tarn enables efficiently determining a distribution of the objects in the dataset based on their activity data. Conventional methods require substantially more computing and storage resources than those required by techniques and/or systems described in this specification, which is especially the case when performing these operations on large datasets. In contrast, the techniques and/or systems in this specification require substantially less storage and can perform more time rand resource efficient processing of large datasets to determine a frequency distribution of the objects in the dataset based on the object' activity data.
- In details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
-
FIG. 1 is a block diagram of an example computing system for computing information for a dataset. -
FIG. 2 is a flowchart of an example process for computing aggregate distributions based on activity data for objects in a dataset. -
FIG. 3 is a block diagram of a computing system that can be used in connection with methods described in this specification. - Like reference numbers and designations in the various drawings indicate like elements.
- This specification describes techniques for using a probabilistic cardinality estimator, such as a HyperLogLog data structure, for providing, a distribution of objects in a dataset across different aggregate values (e.g., frequencies) based on the activity data for the objects. The techniques described in this specification enhance conventional HyperLogLog (HLL) data structures in a manner that enables computing such aggregate (e.g., frequency) distributions, which is not possible using the conventional HLL data structures. It will be appreciated that other types of probabilistic data structures may also be used to implement the techniques described in this specification.
- An object can be an entity, resource, or component such as users, spam events, system components, digital assets, etc. Each object in the dataset air associated with or performs certain activities in a digital environment and the activity data in the dataset represents the activities of the objects. This can include, for example, data describing device interactions with certain digital assets (e.g., portions of content), such as which users clicked on, viewed, or otherwise interacted with a content for a particular digital campaign. As another example, the activity data can include log data about hardware/component events (e.g., failures, resets, outages, network calls, memory access, or other events) in a network environment.
- For context, the conventional HLL data structure can be used to measure or estimate the number of unique objects in a large dataset (i.e., the cardinality of the dataset). However, the conventional HLL data structures cannot determine an aggregate distribution of the objects based on the activity data of the objects. For example, while the conventional HLL data structure can be used to determine the number of users in a dataset that have interacted with a particular digital content, this data structure cannot be used to determine a distribution of the number of users who have viewed the content at particular frequencies (e.g., one time, two times, three times, etc.).
- As described below and in greater detail throughout this specification the techniques described in this specification enhance conventional FILL data structures to enable determining an aggregate (e.g., frequency) distribution of objects in a dataset based on the activity data fur these objects in a digital environment. The HLL registers of the HLL data structure can be enhanced to include three fields: one field that stores the number of leading zeros fur an object in a dataset, which also represents the bit position of the most significant non zero bit as already stored by standard Hi registers), a second field that stores the trailing bits for that object (or another stable identifier of the object, such as for example, a separate hash value for the object that is made up of p bits), and a third field that stores an aggregation counter that is based on the result of a commutative reduction function f(S_t,1)=S_[t+1], which stores information about all the objects with the same key. Examples of such aggregation counters can include, among others, (1) a frequency counter that counts the number of occurrences of, the object in the dataset, (2) a counter that counts the most recent timestamp at which a particular event was recorded at, and (3) a counter that counts counting the number of times an error code was observed at each error logging levels.
- An HLL data engine assigns objects in the dataset to a set of M registers. When data for an object is received, the object's unique identifier (as further described below) is hashed using a hash function to generate a hashed parameter as further described below) that has a binary representation. The HLL data engine uses a certain number of hits (e.g., the first four bits) of the hashed parameter to assign the object to one of the M registers.
- The HLL data engine determines an aggregate number of times that the object has been associated with or performed a certain activity. As described below and in greater detail throughout this specification, the HLL data engine accomplishes this by evaluating whether the remaining bits of the hashed parameter (i.e., the bits other than those that were used, to identify the register) contribute to an aggregation amount, e.g., that specifies a number of occurrences of the object in the dataset.
- The HLL data engine determines the number of leading zeros (which also represents the bit position of the most significant non-zero bit) for the remaining bits of the hashed parameter. If the number of leading zeros is the same as the value stored in the first field of the register, the HLL data engine determines a set of trailing bits for the previously determined most significant bit (or another appropriate stable identifier, as described above). If the determined trailing bits are the same as the value stored in the trailing p bits field of the register, the data engine determines that the current object is the same as the object for which data is already stored in the register. As a result, the HLL data engine updates the aggravation counter field of the register, e.g., by incrementing the value stored in that field by one or by performing another appropriate commutative reduction operation.
- The HLL data engine can determine the number of objects in the dataset that occurred at and or above a certain aggregate value (e.g., frequency). The HLL data engine computes this value by scaling the number of registers (e.g., adjusted to account for any hash collisions) for which the aggregation counter was set to a certain aggregate value by the average number of objects per register.
- Further to the descriptions throughout this document, a user may be provided with controls allowing the user to make an election as to both if and when systems, programs, or features described herein may enable collection of information (e.g., information about a user's social network, social actions, or activities, profession, a user's preferences, or a user's current location), and if the user is sent content or communications from a server. In addition, certain data may be treated in one or more ways before it is stored or used, so that personally identifiable information is removed. For example, a user's identity may be treated so that no personally identifiable information can be determined for the user, or a user's geographic location may be generalized where location information is obtained (such as to a city, ZIP code, or state level), so that a particular location of a user cannot be determined. Thus, the user may have control over what information is collected about the user, how that information is used, and what information is provided to the user.
-
FIG. 1 is a block diagram of anexample computing system 100 for computing information for a dataset.System 100 generally includes acomputing server 102, aHLL data engine 104, adata storage device 130, and a data ingestengine 140. As described in more detail below, thesystem 100 includes special-purpose hardware circuitry configured to execute specific computational rules that measure or estimate the aggregate distribution of the objects in a dataset based on the activity data for the objects. These techniques can be applied to various applications. For example, the techniques described in this specification can be used in digital campaign reach assessment, which includes generating data describing a distribution of users that have interacted with a particular campaign at different frequencies, e.g., how many unique users interacted (e.g., viewed, clicked on, etc.) with a digital content once, twice, thrice, etc. As another example, the techniques described in this specification can be used to analyze hardware/component failures in a large scale network environment, which includes generating statistics about how frequently certain components or computing devices fail in the network environment. It will be understood that the techniques described in this specification may be used in other applications as well. - As shown in
FIG. 1 , thesystem 100 includes acomputing server 102, which is configured to use a HyperLogLog (HLL)data engine 104 to determine an aggregate distribution of objects in a dataset based on their activity levels. As used in this specification, the term engine refers to a data processing apparatus that performs a set of tasks. - The
HLL data engine 104 is included withincomputing server 102 as a sub-system of hardware circuits (e.g., special-purpose circuitry) that includes one or more processor microchips. In general,computing server 102 can include processors (e.g., central or graphics processing units), memory, anddata storage devices 106 that collectively form computer systems ofcomputing server 102. Processors of these computer systems process instructions for execution byserver 102, including instructions stored in the memory or on thedataset storage device 106 to display graphical information for output at an example display monitor ofsystem 100. - In some implementations, execution of the stored instructions causes one or more of the actions described in this specification to be performed by the
computing server 102 or theHLL data engine 104. In some implementations, multiple processors may be used, as appropriate, along with multiple memories and types of memory. For example,computing server 102 may be connected with multiple other computing devices, with each device (e.g., a server bank, groups of servers, modules, or a multi-processor system) performing portions of the actions, operations, or logical flows described in this specification. -
System 100 can receive, via data ingestengine 140, a dataset including activity data for a plurality of objects in a digital environment. The received dataset is provided to theHLL data engine 104 of thecomputing server 102. - As further described below with reference to
FIG. 2 , theHLL data engine 104 uses the logic engine 116, including the hashinglogic 108, the leading zerologic 110, and theregister ID logic 112, to store the data of the dataset in a set of M registers 125 inmemory 106. - Data ingest
engine 140 also receives queries, which request data about the number of objects in the dataset that are associated with or otherwise performed activities in the digital environment at particular frequencies. For example, aquery 150 can request data about the number of unique users in the dataset that viewed, accessed, or otherwise interacted with content a certain number of times (e.g., one time, two times, three times, etc.). The data ingestengine 140 sends thequery 150 to thecomputing server 102, which in turn uses the HLL data engine 104 (and in particular, the repot ting logic 114) to determine the number of distinct users in a dataset and their distribution across different frequencies based on their activity data. TheHLL data engine 104 then, alone or in combination with a front end engine of thecomputing server 102, provides the determined distribution data as reportingoutput 180. In the above example, the reportingoutput 180 can be statistics in the form of text or a visual representation (e.g., a histogram, a pie chart, etc.) showing the number of users who are associated with or otherwise performed certain activities at different frequencies, e.g., one time, two times, etc. Alternatively or in addition, the reportingoutput 180 may be in the form of a data structure that can be processed by computingserver 102 or by another computing device. - The components of the HLL data engine 104 (as shown in
FIG. 1 ) that are used in generating such statistics and the respective operations of these components are described further with reference toFIG. 2 below. -
FIG. 2 is a flowchart of anexample process 200 for computing aggregate distributions based on activity data for objects in a dataset.Process 200 can be implemented or executed using computing resources ofsystem 100, and in particular theHLL data engine 104, described above. Operations of theprocess 200 are described below for illustration purposes only. Operations of theprocess 200 can be performed by any appropriate device or system, e.g., any appropriate data processing apparatus. Operations of theprocess 200 can also be implemented as programmed instructions stored on a non-transitory computer readable medium (such as the memory and/ordata storage device 130, described with reference toFIG. 1 ) and executed by at least one processor of thecomputing server 102. - The data ingest
engine 140 obtains activity data for a plurality of objects in a dataset (at 202). In some implementations, the data ingestengine 140 receives data logs specifying the activity data in a digital environment for objects in a dataset (wherein each object can occur one or more times in the dataset). The data logs can include separate fields (or delimiters that can be used to delineate different data items) corresponding to an object identifier for the object and the corresponding activity data for the object. As used in this specification, the object identifier is a value (e.g., a number, alphanumeric string, data structure) that uniquely identities a particular object in the dataset. In some implementations, the object identifier is a byte (e.g., eight bits), while in other implementations the object identifier is a data word formed by, e.g., 12 bits, 16 bits, 32 bits, or 64 bits. In some cases, a variable number of bits can be used to form the object identifier, such as more than 64 bits or fewer than 64 bits. - The data ingest
engine 140 sends the received dataset to theHLL data engine 104 of thecomputing server 102. For each data item in the dataset, theprocess 200 then performs theoperations process 200 accumulates an aggregate distribution of objects in the data set based on the activity data associated with or performed by these objects. - The
HLL data engine 104 generates a hashedparameter 128 for the object using the hashing logic 108 (at 204). In some implementations, the hashinglogic 108 applies one or more hash functions (which may include any conventional hash function/s) to the object identifier for the object to generate the hashed parameter (which may also be referred to as a hash, hash code, or hash value). The hashed parameter has a binary representation whose length is dependent upon the hash function itself or the parameters of the hash function. The hash of object identifier for the object is indicated as the hashedparameter 128, as shown inFIG. 1 . - The
HLL data engine 104 identifies a register from among a set of registers that can be used to store data about the object (at 206). In some implementations, data for a dataset can be stored in a set of M registers 125. Using a first portion (e.g., first four bits) of the object's hashedparameter 128, theregister ID logic 112 identifies one of the M registers that can be used to store data about the object For example, for the flashed parameter 128 (0001 0101 0100), theregister ID logic 112 can uses the first four bits (0001) to identify one of the M registers. It will be appreciated that the number ofregisters 125 is less than the number of data items in the dataset. - The
HLL data engine 104 determines whether the hashed parameter contributes to a frequency amount (at 208). In some implementations, the hashinglogic 108 identifies a second portion of the hashedparameter 128, which includes the bits of the hashed parameter without the first set of bits that are used to identify the appropriate register (as described above at operation 206) For the hashed parameter 128 (0001 0101 0100), the hits (0101 0100) do not include the first four bits that are used by theregister ID logic 112 to identify the appropriate register (as described in the preceding paragraph). - The leading zero
logic 110 determines the number of leading zeros (which also represents the bit position of the most significant non-zero bit) in the second portion or set of hits. In some implementations, the leading zerologic 110 determines the number of leading zeros by counting the number of zeros, from left to right, in the second set of bits until the bit position of the first “1” in the second set of bits is identified. For example, the number of leading zeros for the second set of bits (0101 0100) of the hashedparameter 128 is one because, when counting from left to right, one zero is identified before the first “1” is encountered. - The
HLL data engine 104 determines the number of trailing bits for the most significant bit in the second set of bits, as identified in the previous paragraph. In some implementations, theHLL data engine 110 determines the trailing bits by identifying all the bits in the second set of bits after the most significant bit, which is the location where the first “1” is identified when counting from left to fight (as described in the preceding paragraph). For example, the trailing bits in the second set of bits (0101 0100) is “010100” because these are the bits that follow the first “1” that was identified when counting the leading zeros for the second set of bits. - As shown in
FIG. 1 , each register in the set of M registers 125 includes adata structure 120 that has three fields, a field for the mostsignificant bit 122, a field for the trailingp bits 124, and a field for theaggregation counter 126. In some implementations, instead of storing the trailing p bits,field 124 stores any number of trailing bits for the most significant bit in the second set of bits or alternatively, a stable identifier for the object, such as a separate hash value made up of p bits. - In total, the total amount of information stored in each register may only be two bytes (or 16 bits). In contrast, the standard HLL algorithm, which only stores the number of leading zeros in each register, generally required six bits of data. In other words, relative to the standard HLL algorithm, the HLL registers described in this specification can store additional data about objects in the dataset with only a marginal increase in storage requirement per register (as compared with storing the entirety of the activity data for objects in the dataset, which would require much more than two bytes of storage space).
- In some implementations, the
aggregation counter field 126 stores the frequency amount, which specifies a number of occurrences of the object in the dataset. As further described below, the object's hashed parameter contributes to the aggregation amount based on a comparison of the number of leading zeros and the trailing bits of the hashed parameter (as determined by tire HLL data engine 104) with the values stored in the mostsignificant hit field 122 and the trailing p bits field 124 of thedata structure 120 in the register (identified in operation 206), respectively. In some implementations, instead of storing a frequency count for each object, the aggregation counter Held 126 can aggregate information about objects with the same key (e.g., counting the most recent timestamp that a particular event was recorded at counting the number of times an error code was observed at each error logging levels, etc.). - When the number of leading zeros determined by the leading zero
logic 110 Is less than the value stored infield 122, the leading zerologic 110 does not update thedata structure 120. In other words, the existing values infields aggregation counter field 126, the object's hashed parameter does not contribute to the aggregation (e.g., frequency ) amount. - When the number of leading zeros determined by the leading zero
logic 110 exceeds the value stored infield 122, the leading zerologic 110updates field 122 with the value of the most significant bit determined by the leading zerologic 110. In such instances, theHLL data engine 104 also (1) updates the value stored infield 124 with the trailing bits value calculated by theHLL data engine 104 and (2) resets the value stored infield 126 to zero. - When the number of leading zeros determined by the leading zero
logic 110 is the same as the value stored infield 122, the leading zerologic 110 does not update the value stored in thefield 122. In such instances, theHLL data engine 104 also determines whether to update the values stored in thefields HLL data engine 104 with the value stored in the trailing p bits field 124 of thedata structure 120. - If the value of the trailing bits determined by the
HLL data engine 104 is larger than the value stored in the trailing p bits field 124 of thedata structure 120, the HLL data engine 104 (1) updates thefield 124 with the value of the trailing bits determined by theHLL data engine 104 and (2) resets the value of theaggregation counter field 126 to zero. - If the value of the trailing bits determined by the
HLL data engine 104 is less than the value stored in the trailing p bits field 124 of thedata structure 120, the HLLdata engine engine 104 retains (i.e., does not update) the values stored infields - If, however, the value of the trailing bits determined by the
HLL data engine 104 is the same as the value stored in the trailing p bits field 124 of thedata structure 120, theHLL data engine 104 determines that the current object is the same as the object for which data is already stored in thedata structure 120. In such instances, the HLL data engine 104 (1) does not update the value already stored in the trailing p bits field 124 and (2) updates the value stored in theaggregation counter field 126 based on the commutative reduction function involving the current value of the field and the object (at 210). In implementations where theaggregation counter field 126 is a frequency counter, the HLL, data engine updates the value in this field by incrementing the value stored in thisfield 126 by one (e.g., if the value stored in theaggregation counter field 106 is 2, theHLL data engine 104 increments that value by one, which results in a value of 3). It will be appreciated that when an aggregation distribution other than frequency is to be determined, thedata engine 104 uses the commutative reduction function to appropriate scale (e.g., multiplying, dividing, incrementing by) more than one, etc.) the value in thefield 126. - Because the above-described operation results in updating the
aggregation counter field 126, the object's hashed parameter contributes to the aggregation amount. - As described above, in some implementations, the
data engine 104 performsoperations operation 204. In other implementations, theHLL data engine 104 can performoperations logic 108 can use the object identifier to generate separate hash representations: one hash representation can be used to identify the appropriate register in the set ofregisters 125, a second hash representation from which the number of leading zeros are determined, and a third hash representation from which the trailing bits are determined. The above describedoperations 206 to 240 can then be performed using these separate hash representations. - The data ingest
engine 140 receives aquery 150 requesting an aggregation distribution of the number of objects in the dataset that performed activities in the digital environment at different frequencies (at 212). For example, thequery 150 can request a frequency distribution of the number of users in a dataset that interacted with certain content at different frequencies (one time, two times, three times, etc.). In some implementations, the data ingestengine 140 sends thequery 150 to thecomputing server 102, which in turn routes thequery 150 to thereporting logic 114 of the logic engine 116. - In response to the
query 150, thereporting logic 114 generates a reporting output that represents an aggregate distribution of the objects in the dataset based on the associated activities or activities performed by these objects in the digital environment (at 212). Thereporting logic 114 estimate the aggregate distribution based on the aggregate value stored in theregisters 125. Thereporting logic 114 generates this reporting output by performing the following operations. In some implementations, thereporting logic 114 determines the different possible aggregate values by identifying a set of values including the unique aggregate values stored inaggregation counter field 126 in the set ofregisters 125. In some implementations, thequery 150 may identify the aggregate values, in which case, thereporting logic 114 can skip the operation of identifying the different possible aggregate values stored infield 126 of the registers. In some implementations, thereporting logic 114 may access a set of aggregate values specified by an administrator of the system (and stored in the data storage device 130), in which case, thereporting logic 114 can skip the operation of identifying the different possible aggregate values stored in the registers. - In some implementations, for each identified aggregate value, the
reporting logic 114 determines a number of registers that have the same value stored in theaggregation counter field 126 as the identified aggregate value. In such implementations, thereporting logic 114 counts all registers for which the value in theaggregation counter field 126 is the same as the identified aggregate value. In other implementations, thereporting logic 114 counts all registers for which the value in theaggregation counter field 126 is the same as or greater than the identified aggregate value. - In some instances, hash collisions may arise when storing and updating values in the
data structure 120 of theregisters 125. For example, two object identifiers for two different objects in the dataset, when hashed by the hashinglogic 108, may update the same register and may have the same number of leading zeros and the same trailing bits. In the case of a frequency counter, the value of this field should only be incremented by one in this scenario; however, because of the hash collision, value of thisfield 126 is instead incorrectly incremented by two. In other words, even though both objects, e.g., may have interacted with the same content only once, theaggregation counter field 126 may incorrectly reflect that a single object interacted with the same content twice. In some implementations where another aggregate (i.e., other than frequency) is being measured, thereporting logic 114 counts all registers that satisfy some criteria, which can be specified in the query (e.g. having more errors at one reporting level than another, or having a value between two bounds), that provides a function to map the value infield 126 to a boolean (e.g., include in the count or not). - To account for such error arising from hash collisions, the
reporting logic 114 obtains the count of registers for which the value in theaggregation counter field 126 is the same as or greater than the identified aggregate value and then adjusts (e.g., reduces) this count by a correction factor. The correction factor (also referred to as a hash collision correction factor), F, can be represented by F(C, M, n)), and estimates the number of hash collisions expected at the identified aggregate value (a) for a number of distinct objects (c) the dataset that have performed or are associated with certain activity, which are stored in the set of M registers 125. The number of distinct elements that have performed or are associated with certain activity (i.e., the cardinality of the dataset (C)) is determined using the standard HLL algorithm. In some implementations, the correction factor is based on empirically determined lookup table of reduction values indexed by C, M, and f. - To obtain the total number of objects at a particular aggregate value, the
reporting logic 114 scales (e.g., multiplies) the adjusted number of registers (as determined in the previous paragraph) at the particular aggregate value by the average number of objects per register. The average number of objects per register is determined by dividing the cardinality of the dataset C (as determined using the standard HLL algorithm) by M, which is the number ofregisters 125. Thereporting logic 114 repeats the above operations for each identified frequency. As such, the total number of object at a particular aggregate value can be represented using the following equation: -
- where (1) Rn is the number of objects at a particular aggregate value n, (2) Bn is the number of buckets with the aggregation counter field set to n, (3) C is the cardinality of the dataset, (4) M is the total number of
registers 125, and (5) F(C,M,n) is the correction factor. - In some implementations, reporting
logic 114 sends the identified frequencies and the corresponding number of determined objects to a front end engine of thecomputing server 102, which uses these values to generate a report, e.g., reportingoutput 180, that is provided to the entity from which thequery 150 was received. The front end engine can use the values provided by thereporting logic 114 to generate statistics that include a set of data items, in which each data item identifies an estimated number of objects in the dataset that is associated with or performed activities in the environment at a particular frequency. These statistics can be in the form of text and/or visuals (e.g., a histogram, a pie chart, etc.) on thereporting output 180, and show the distribution of the number of objects at different frequencies based on the activity data of the objects. -
FIG. 3 is a block diagram ofcomputing devices Computing device 300 is intended to represent various forms of digital computers, such as laptops, desktops, workstations, personal digital assistants, servers, blade servers, mainframes, and other appropriate computers.Computing device 350 is intended to represent various forms of mobile devices, such as personal digital assistants, cellular telephones, smartphones, smart watches, head-worn devices, and other similar computing devices. The components shown here, their connections and relationships, and their functions, are meant to be exemplary only, and are not meant to limit implementations described and/or claimed in this document. -
Computing device 300 includes a processor 302,memory 304, astorage device 306, a high-speed interface 308 connecting tomemory 304 and high-speed expansion ports 310, and alow speed interlace 312 connecting tolow speed bus 314 andstorage device 306. Each of thecomponents computing device 300, including instructions stored in thememory 304 or on thestorage device 306 to display graphical information for a GUI on an external input/output device, such asdisplay 316 coupled tohigh speed interlace 308. In other implementations, multiple processors and/or multiple buses may be used, as appropriate, along with multiple memories and types of memory. Also,multiple computing devices 300 may be connected, with each device providing portions of the necessary operations (e.g., as a server bank, a group of blade servers, or a multi-processor system). - The
memory 304 stores information within thecomputing device 300. In one implementation, thememory 304 is a computer-readable medium. In one implementation, thememory 304 is a volatile memory unit or units. In another implementation, thememory 304 is a non-volatile memory unit or units. - The
storage device 306 is capable of providing mass storage for thecomputing device 300. In one implementation, thestorage device 306 is a computer-readable medium. In various different implementations, thestorage device 306 may be a hard disk device, an optical disk device, or a tape device a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network or other configurations. In one implementation, a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that, when executed, perform one or more methods, such as those described above. The information carrier is a computer- or machine-readable medium, such as thememory 304, thestorage device 306, or memory on processor 302. - The high-
speed controller 308 manages bandwidth-intensive operations for thecomputing device 300, while thelow speed controller 312 manages lower bandwidth-intensive operations. Such allocation of duties is exemplary only. In one implementation, the high-speed controller 308 is coupled tomemory 304, display 316 (e.g., through a graphics processor or accelerator), and to high-speed expansion ports 310, which may accept various expansion cards (not shown). In the implementation,low seed controller 312 is coupled tostorage device 306 and low-speed expansion port 314. The low speed expansion port, which may include various communication ports (e.g., USB, Bluetooth, Ethernet, wireless Ethernet) may be coupled to one or more input/output devices, such as a keyboard, a pointing device, a scanner, or a networking device such as a switch or router, e.g., through a network adapter. - The
computing device 300 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as astandard server 320, or multiple times in a group of such servers. It may also, be implemented as part of arack server system 324. In addition, it may be implemented in a personal computer such as alaptop computer 322. Alternatively, components fromcomputing device 300 may be combined with other components in a mobile device (not shown), such asdevice 350. Each of such devices may contain one or more ofcomputing device multiple computing devices -
Computing device 350 includes aprocessor 352,memory 364, an input/output device such us adisplay 354, acommunication interface 366, and atransceiver 368, among other components. Thedevice 350 may also be provided with a storage device, such as a microdrive or other device, to provide additional storage. Each of thecomponents - The
processor 352 can process instructions for execution within thecomputing device 350, including instructions stored in thememory 364. The processor may also include separate analog and digital processors. The processor may provide, for example, for coordination of the other components of thedevice 350, such as control of interfaces, applications run bydevice 350, and wireless communication bydevice 350. -
Processor 352 may communicate with a user throughcontrol interface 358 anddisplay interface 356 coupled to adisplay 354. Thedisplay 354 may be, for example, a TFT LCD display or an OLED display, or other appropriate display technology. Thedisplay interface 356 may comprise appropriate circuitry for driving thedisplay 354 to present graphical and other information to a user. Thecontrol interface 358 may receive commands from a user and convert them for submission to theprocessor 352. In addition, anexternal interface 362 may be provided in communication withprocessor 352, so as to enable near area communication ofdevice 350 with other devices.External interlace 362 may provide, for example, for wired communication (e.g., via a docking procedure) or for wireless communication (e.g., via Bluetooth or other such technologies). - The
memory 364 stores information within thecomputing device 350. In one implementation, thememory 364 is a computer-readable medium. In one implementation, the memory 344 is a volatile memory unit or units. In another implementation, thememory 364 is a non-volatile memory unit or units.Expansion memory 374 may also be provided and connected todevice 350 throughexpansion interface 372, which may include, for example, a SIMM card interface. Such expansion memory 174 may provide extra storage space fordevice 350, or may also store applications orother information device 350. Specifically,expansion memory 374 may include instructions to carry out or supplement the processes described above, and may include secure information also. Thus, for example,expansion memory 374 may be provided as a security module fordevice 350, and may be programmed with instructions that permit secure use ofdevice 350. In addition, secure applications may be provided via the SIMM cards, along with additional information, such as placing identifying information on the SIMM card in a non-hackable manner. - The memory may include for example, flash memory and/or MRAM memory, as discussed below. In one implementation, a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that, when executed, perform one or more methods, such as those described above. The information carrier is a computer- or machine-readable medium, such as the menial 364, expansion.
memory 374, or memory onprocessor 352. -
Device 350 may communicate wirelessly throughcommunication interface 366, which may include digital signal processing circuitry where necessary.Communication interface 366 may provide for communications under various modes or protocols, such as GSM voice calls, SMS, EMS, or MMS messaging, CDMA, TDMA, PDC, WCDMA, CDMA2000, or GPRS, among others. Such communication may occur, for example, through radio-frequency transceiver 368. In addition, short-range communication may occur, such as using a Bluetooth, WiFi, or other such transceiver (not shown). In addition,GPS receiver module 370 may provide additional wireless data todevice 350, which may be used as appropriate by applications running ondevice 350. -
Device 350 may also communicate audibly usingaudio codec 360, which may receive spoken information from a user and convert it to usable digital information.Audio codec 360 may likewise generate audible sound for a user, such as through a speaker, e.g., in a handset ofdevice 350. Such sound may include sound from voice telephone calls, may include recorded sound (e.g., voice messages, music files, etc.) and may also include sound generated by applications operating ondevice 350. - The
computing device 350 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as acellular telephone 380. It may also be implemented as part of asmartphone 382, personal digital assistant, or other similar mobile device. - Various implementations of the systems and techniques described here can be realized in digital electronic circuitry, integrated circuitry, specially designed ASICs, computer hardware, firmware, software, and/or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
- These computer programs, also known as programs, software, software applications or code, include machine instructions for programmable processor, and can be implemented in a high-level procedural and/or object-oriented programming language, and/or in assembly/machine language. As used herein, the terms “machine-readable medium” “computer-readable medium” refers to any computer program product, apparatus and/or device, e.g., magnetic discs, optical disks, memory. Programmable Logic Devices (PLDs) used to provide machine instructions and/or data to a programmable processor, including a machine-readable medium that receives machine instructors as a machine-readable signal. The term “machine-readable signal” refers to any signal used to provide machine instructions and/or data to a programmable processor.
- To provide for interaction with a user, the systems and techniques described here can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- The systems and techniques described here can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component such as an application server, or that includes a front end component such as a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here, or any combination of such back end, middleware, or front end components. The components of the system can be interconnected by any for or medium of digital data communication such as, a communication network. Examples of communication networks include a local area network (“LAN”), a wide area network (“WAN”), and the Internet.
- The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- As used in this specification, the terms “module,” “engine,” and “component” are is intended to include, but is not limited to, one or more computers configured to execute one or more software programs that include program code that causes a processing unit(s)/device(s) of the computer to execute one or more functions. The term “computer” is intended to include any data processing or computing devices/systems, such as a desktop computer, a laptop computer, a mainframe computer, a personal digital assistant, a server, a handheld device, a smartphone, as tablet computer, an electronic reader, or any other electronic device able to process data.
- A number of embodiments have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the invention. Accordingly, other embodiments are within the scope of the following claims. While this specification contains many specific implementation details, these should not be construed as limitations on the scope of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment.
- Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
- Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such opera ions be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
- Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, some processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results.
Claims (24)
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2019/047393 WO2021034320A1 (en) | 2019-08-21 | 2019-08-21 | Optimizing large scale data analysis |
Publications (2)
Publication Number | Publication Date |
---|---|
US20220171693A1 true US20220171693A1 (en) | 2022-06-02 |
US11768752B2 US11768752B2 (en) | 2023-09-26 |
Family
ID=67874522
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US16/960,817 Active 2040-06-03 US11768752B2 (en) | 2019-08-21 | 2019-08-21 | Optimizing large scale data analysis |
Country Status (6)
Country | Link |
---|---|
US (1) | US11768752B2 (en) |
EP (1) | EP3799638A1 (en) |
JP (1) | JP7098735B2 (en) |
KR (1) | KR20210023795A (en) |
CN (1) | CN112771512A (en) |
WO (1) | WO2021034320A1 (en) |
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20220398220A1 (en) * | 2021-06-14 | 2022-12-15 | EMC IP Holding Company LLC | Systems and methods for physical capacity estimation of logical space units |
Families Citing this family (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11847119B2 (en) * | 2021-08-30 | 2023-12-19 | The Nielsen Company (Us), Llc | Method and system for estimating the cardinality of information |
Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20180300363A1 (en) * | 2017-04-14 | 2018-10-18 | Dynatrace Llc | Method And System To Estimate The Cardinality Of Sets And Set Operation Results From Single And Multiple HyperLogLog Sketches |
Family Cites Families (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
KR20030040263A (en) | 2003-04-07 | 2003-05-22 | 주식회사 드림나우 | The Collecting Method and System of an Internet Homepage User's Activity |
KR100798008B1 (en) | 2005-09-07 | 2008-01-24 | 노키아 코포레이션 | A method and a device for frequency counting |
US7565349B2 (en) | 2005-11-10 | 2009-07-21 | International Business Machines Corporation | Method for computing frequency distribution for many fields in one pass in parallel |
US8316064B2 (en) * | 2008-08-25 | 2012-11-20 | Emc Corporation | Method and apparatus for managing data objects of a data storage system |
US10198363B2 (en) * | 2015-10-23 | 2019-02-05 | Oracle International Corporation | Reducing data I/O using in-memory data structures |
US10055506B2 (en) * | 2014-03-18 | 2018-08-21 | Excalibur Ip, Llc | System and method for enhanced accuracy cardinality estimation |
US9886301B2 (en) * | 2015-05-04 | 2018-02-06 | Strato Scale Ltd. | Probabilistic deduplication-aware workload migration |
US10009239B2 (en) * | 2016-08-09 | 2018-06-26 | Airmagnet, Inc. | Method and apparatus of estimating conversation in a distributed netflow environment |
US10467433B2 (en) * | 2017-03-17 | 2019-11-05 | Mediasift Limited | Event processing system |
US10579827B2 (en) * | 2017-07-24 | 2020-03-03 | Meltwater News International Holdings Gmbh | Event processing system to estimate unique user count |
-
2019
- 2019-08-21 US US16/960,817 patent/US11768752B2/en active Active
- 2019-08-21 WO PCT/US2019/047393 patent/WO2021034320A1/en unknown
- 2019-08-21 KR KR1020207022602A patent/KR20210023795A/en not_active IP Right Cessation
- 2019-08-21 EP EP19765368.6A patent/EP3799638A1/en active Pending
- 2019-08-21 JP JP2020542129A patent/JP7098735B2/en active Active
- 2019-08-21 CN CN201980011648.XA patent/CN112771512A/en active Pending
Patent Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20180300363A1 (en) * | 2017-04-14 | 2018-10-18 | Dynatrace Llc | Method And System To Estimate The Cardinality Of Sets And Set Operation Results From Single And Multiple HyperLogLog Sketches |
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20220398220A1 (en) * | 2021-06-14 | 2022-12-15 | EMC IP Holding Company LLC | Systems and methods for physical capacity estimation of logical space units |
Also Published As
Publication number | Publication date |
---|---|
EP3799638A1 (en) | 2021-04-07 |
WO2021034320A1 (en) | 2021-02-25 |
CN112771512A (en) | 2021-05-07 |
US11768752B2 (en) | 2023-09-26 |
JP2022500714A (en) | 2022-01-04 |
JP7098735B2 (en) | 2022-07-11 |
KR20210023795A (en) | 2021-03-04 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10394693B2 (en) | Quantization of data streams of instrumented software | |
US8892954B1 (en) | Managing groups of application versions | |
EP3507963B1 (en) | Aggregating service data for transmission and risk analysis | |
US10664481B2 (en) | Computer system programmed to identify common subsequences in logs | |
US10191947B2 (en) | Partitioning advisor for online transaction processing workloads | |
US11768752B2 (en) | Optimizing large scale data analysis | |
US11693842B2 (en) | Generating compact data structures for monitoring data processing performance across high scale network infrastructures | |
CN107016115B (en) | Data export method and device, computer readable storage medium and electronic equipment | |
CN116137908A (en) | Dynamically determining trust level of end-to-end links | |
EP4104086A1 (en) | Differentially private frequency deduplication | |
US10795903B2 (en) | Method and system for determining data usage behavior in a database system | |
US20150220648A1 (en) | Systems and Methods for Performing Machine-Implemented Tasks | |
CN112189199B (en) | Privacy preserving data collection and analysis | |
US8788506B1 (en) | Methods and systems for estimating a count of unique items | |
US20210056586A1 (en) | Optimizing large scale data analysis | |
CN116783588A (en) | Column technique for large metadata management | |
US10972353B1 (en) | Identifying change windows for performing maintenance on a service | |
CN114329164A (en) | Method, apparatus, device, medium and product for processing data | |
JP6845344B2 (en) | Data leakage risk assessment | |
US20230061914A1 (en) | Rule based machine learning for precise fraud detection | |
CN116894229A (en) | Method, device, equipment and storage medium for fusing multiple data sources of same type | |
US11120030B2 (en) | High qualified pattern mining method and apparatus, and data processing device | |
US20240112053A1 (en) | Determination of an outlier score using extreme value theory (evt) | |
US8700868B1 (en) | Methods and systems for incrementing a logarithmic count | |
CN115577349A (en) | Method and device for determining abnormal request and electronic equipment |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
FEPP | Fee payment procedure |
Free format text: ENTITY STATUS SET TO UNDISCOUNTED (ORIGINAL EVENT CODE: BIG.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:SKVORTSOV, EVGENY;WILHELM, JEFFREY;TSANG, YIP MAN;AND OTHERS;SIGNING DATES FROM 20190725 TO 20190813;REEL/FRAME:053640/0312 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: NON FINAL ACTION MAILED |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: RESPONSE TO NON-FINAL OFFICE ACTION ENTERED AND FORWARDED TO EXAMINER |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: NOTICE OF ALLOWANCE MAILED -- APPLICATION RECEIVED IN OFFICE OF PUBLICATIONS |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: PUBLICATIONS -- ISSUE FEE PAYMENT VERIFIED |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |