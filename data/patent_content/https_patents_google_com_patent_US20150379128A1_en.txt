US20150379128A1 - Deep links for native applications - Google Patents
Deep links for native applications Download PDFInfo
- Publication number
- US20150379128A1 US20150379128A1 US14/750,082 US201514750082A US2015379128A1 US 20150379128 A1 US20150379128 A1 US 20150379128A1 US 201514750082 A US201514750082 A US 201514750082A US 2015379128 A1 US2015379128 A1 US 2015379128A1
- Authority
- US
- United States
- Prior art keywords
- native application
- application
- publisher
- uri
- native
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/951—Indexing; Web crawling techniques
-
- G06F17/30864—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/955—Retrieval from the web using information identifiers, e.g. uniform resource locators [URL]
- G06F16/9566—URL specific, e.g. using aliases, detecting broken or misspelled links
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/958—Organisation or management of web site content, e.g. publishing, maintaining pages or automatic linking
-
- G06F17/30887—
-
- G06F17/3089—
Definitions
- the Internet provides access to a wide variety of information.
- digital image files, video and/or audio files, as well as web page resources for particular subjects or particular news articles are accessible over the Internet.
- web page resources many of these resources are designed to facilitate the performing of particular functions, such as banking, booking hotel reservations, shopping, etc., or to provide structured information, such as on-line encyclopedias, movie databases, etc.
- a user's informational need may thus be satisfied by providing search results that identify either one (or both) of a particular web page resource or a native applications that facilitates the performance of the same functions facilitated by web page resource, or presents the same or very similar information as the web page resource.
- the present disclosure relates to native application deep linking, and more specifically to systems and methods for automatically generating native application deep links.
- one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving publisher affiliation data for native applications that define, for each native application, an affiliated publisher for the native application; for each native application of a set of native applications, determining, based on the publisher affiliation data, whether it is affiliated with a publisher that provides content addressed by URIs determined for the native application; for only the native applications that are determined to be affiliated with a publisher that provides content addressed by URIs determined for the native application: selecting URIs based on the URI pattern for the native application, indexing content accessible by the URI for the native application in an index that is searchable by a search engine.
- Other embodiments of this aspect include corresponding systems, apparatus, and computer programs, configured to perform the actions of the methods, encoded on computer storage devices.
- Another innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of determining a uniform resource identifier (URI) pattern for a native application; instantiating the native application and selecting a first URI based on the URI pattern to generate an application page in the native application display environment; indexing application page data of the application page in an index that is searchable by a search engine; iteratively processing linked application pages for the native application until a cessation event occurs, the iterative processing comprising for each iteration; determining, from the application page, outbound URIs including in the first application page; selecting one or more of the outbound URIs to generate one or more subsequent application pages in the native application display environment; indexing the application page data for each of the one or more subsequent application pages in the index.
- Other embodiments of this aspect include corresponding systems, apparatus, and computer programs, configured to perform the actions of the methods, encoded on computer storage devices.
- FIG. 1 is a block diagram of an example environment in which deep links for native applications are generated.
- FIG. 2 is a block diagram of an application crawling and indexing system.
- FIG. 3 is a flow diagram of an example process for generating deep links for native applications.
- FIG. 4 is a flow diagram of another example process for generating deep links for native applications.
- a system provides native application search results.
- a native application operates independent of a browser application on the user device.
- a native application is an application specifically designed to run on a particular user device operating system and machine firmware and not within a browser. Native applications thus differ from browsers, browser-based applications and browser-rendered resources. The latter require all, or at least some, elements or instructions downloaded from a web server each time they are instantiated or rendered.
- browser-based applications and browser-rendered resources can be processed by all web-capable mobile devices within the browser and thus are not operating system specific as are native applications.
- a native application search result is a search result that corresponds to a particular native application and that, when selected, invokes the particular native application.
- native application examples include applications to create text documents, edit photographs, play music, interface with a remote banking system, and so on.
- Mobile native applications are designed to operate on mobile devices such as smart phones, tablets, and so on.
- Web native applications are designed to run within (both visually and functionally) web browser software.
- native applications, or simply “apps,” provide a user with access to content and/or functionality.
- Internet search engines provide the ability to search an indexed collection of web pages that exist on the Internet.
- the typical search engine provides, in response to a query, a list of results relevant to the query, often with hyperlinks allowing a user to quickly navigate to a result of interest.
- a user may select a linked result and thereby be provided with a web page(s) containing content about a celebrity, product, business, etc.
- the links may be to a site's “home page” (e.g., a welcome and search page for a site aggregating cooking information such as recipes) or may be a “content page” that a user can access when navigating from a site's home page (e.g., a specific recipe at the cooking information site).
- links to content pages, as opposed to home pages are referred to as “deep links” (and the process for crawling, indexing, and serving these content pages is similarly referred to as “deep linking”).
- Some native applications lack some of the basic properties of websites when it comes to linking
- native applications have corresponding web pages for the URIs the native applications access, while others do not. Of those that do have corresponding web pages, some native applications maintain duplicate or corresponding content and functionality between the native application and web platforms, while other native applications have small or large degree differences between mobile and web platforms.
- Some systems for indexing native applications rely on developers to publish their native application deep links either as HTML markup on their webpages or in their existing sitemaps. That is, the native application provider must have both a web platform and at least map the native application pages at the website. Some services providing native application deep linking also rely on developers publishing their native application deep links on their webpages.
- native application deep links may be automatically generated for indexing purposes.
- URLs uniform resource locators
- a process to generate native application deep links includes:
- a system implements a method comprising the following steps:
- the systems and methods described herein can provide an automatic indexing of native application deep links.
- the systems and methods may further determine and utilize link prioritizations from actual user activity. Prioritization permits, inter alia, optimizing the utilization of search resources.
- systems and methods are disclosed that can accommodate apps with and without corresponding websites, overcoming the limitations of existing techniques that require apps to publish links through corresponding webpages.
- FIG. 1 is a block diagram of an example environment 100 in which deep links for native applications are generated.
- a computer network 102 such as the Internet, connects resource publisher web sites 104 , application publishers 106 , user devices 108 and a search engine 120 .
- a resource publisher website 104 includes one or more web resources 105 associated with a domain and hosted by one or more servers in one or more locations.
- a resource publisher website is a collection of web pages formatted in hypertext markup language (HTML) that can contain text, images, multimedia content, and programming elements.
- HTML hypertext markup language
- Each website 104 is maintained by a content publisher, which is an entity that controls, manages and/or owns the website 104 .
- a web page resource is any data that can be provided by a publisher website 104 over the network 102 and that has a resource address, e.g., a uniform resource locator (URL).
- Web resources may be HTML pages, images files, video files, audio files, and feed sources, to name just a few.
- the resources may include embedded information, e.g., meta information and hyperlinks, and/or embedded instructions, e.g., client-side scripts.
- An application publisher website 106 may also include one or more web resources 105 , and also provides native applications 107 .
- a native application 107 is an application specifically designed to run on a particular user device operating system and machine firmware.
- Native applications 107 may include multiple versions designed to run on different platforms. For example, native applications corresponding to a movie database website may include a first native application that runs on a first type of smart phone, a second native application that runs on a second type of smart phone, a third native application that runs on a first type of tablet, etc.
- An application page is a particular display environment within a native application and in which is displayed content, such as text, images, and the like.
- An application page is specific to the particular native application, and the native application is specific to the particular operating system of the user device 108 .
- An application page differs from a rendered web resource in that the application page is generated within and specific to the native application, while a web resource may be rendered in any browser for which the web page resource is compatible, and is independent of the operating system of the user device.
- the publisher backend 130 includes a publisher store 132 that stores content the publisher provides, a web server 134 that provides the content from the publisher store as web resources (e.g., web pages), and a native application server 136 that handles requests from a native application.
- the web pages correspond to native application pages, and thus for many native application URIs there are corresponding web page URIs.
- Some native applications may also simply use the same URLs as the web pages to which they correspond.
- the content of the publisher store 132 is accessible for presentation on both the web resources and the corresponding native application pages. Accordingly, such content is referred to as “synchronized” content.
- news publishers which may have a “mobile news app” for reading news content on a mobile device.
- the news content (e.g., the text of news story) provided on web resources 105 are the same content that is provided by the corresponding application pages of the native application 107 .
- a user device 108 is an electronic device that is capable of requesting and receiving web page resources 105 and native applications 107 over the network 102 .
- Example user devices 108 include personal computers, mobile communication devices, and tablet computers.
- the web index 116 is an index of publisher content that has, for example, been built from crawling the publisher websites 104 , by receiving data feeds from the publisher websites 104 , or by other appropriate methods of collecting and indexing data.
- the native application index 114 stores data relating to native applications 107 .
- the application index 114 stores, for example, a list of native applications provided by the publishers 104 and identifiers that identify the native applications.
- publishers 104 may specify that certain native applications 107 are used to access and display synchronized data, and this information may be stored in the application index.
- a news publisher may specify that a news reading application it provides displays synchronized content that is displayed on the news publisher's website.
- the user devices 108 submit search queries to the search engine 110 .
- the search engine 110 accesses the web index 116 and the application index 114 to identify content that is relevant to the query.
- the search engine 110 may, for example, identify the resources and applications in the form of web resource search results and native application search results, respectively, by of use a search result generator 116 . Once generated, the search results are provided to the user device 108 from which the query was received.
- a web resource search result is data generated by the search engine 110 that identifies a web resource, based on the content of the resource that satisfies a particular search query.
- a web resource search result for a resource can include a web page title, a snippet of text extracted from the resource, and a uniform resource identifier (URI) for the resource, e.g., the uniform resource locator (URL) of the web page.
- URI uniform resource identifier
- the web resource search result causes the user device to generate a request for the resource located at the URL.
- the web resource that is received is then displayed in a browser application.
- a native application search result specifies a native application and is generated in response to a search of the application index 114 and the web index 116 , as described in more detail below.
- the native application search result When selected at a user device, the native application search result causes the native application installed on the user device to request the synchronized content. Once the native application receives the requested content, the native application displays the content in a user interface of the native application.
- FIG. 2 is a block diagram of an application crawling and indexing system 120 . Operation of the system 120 in the context of native applications that use URLs is described with reference to FIG. 3 . A variation of the operation for native applications that use custom URIs is described with reference to FIG. 4 .
- FIG. 3 is a flow diagram of an example process 300 for generating deep links for native applications.
- the process 300 is implemented in a data processing apparatus of one or more computers.
- the process 300 receives at the data collector 204 publisher affiliation data 202 for native applications that define, for each native application, an affiliated publisher for the native application ( 302 ).
- publishers provide data that a particular native application is affiliated with the publisher, such as an association of a native application identifier with a site identifier of the publisher.
- site identifier is a domain name, but other types of data for defining an affiliation between a publisher and native application can be used.
- the process 300 determines based on the publisher affiliation data whether the native application is affiliated with a publisher that provides content addressed by URIs determined for the native application ( 304 ).
- the application package crawler 206 extracts from an application manifest file 109 (or other data defining similar application specifications) a scheme, host and path of a URI format for the native application.
- an application manifest file 109 or other data defining similar application specifications
- the following is extracted from an intent filter section:
- the scheme is “http,”
- the host is “example.com,” and the path is “/gizmos.”
- the process determining a URI pattern for the native application, and whether the URI pattern defines an affiliated publisher for the native application that matches an affiliated publisher for the native application specified by the publisher affiliation data 202 .
- the affiliation data 202 defines a scheme of “http” for a native application, and a host of “example.com,” and the manifest 109 of the native application 107 defines the same scheme and host, then the native application is affiliated with the host.
- the URI scheme generator 208 stores the data for the native application in the URI scheme table 210 , and then the process 300 selects URIs based on the URI pattern for the native application ( 306 ). For example, in some implementations, the URI selector 212 retrieves the URI pattern from the URI scheme table 210 . The selector 212 then searches the web index 116 for URL's that that include the URI pattern. In the example above, candidate URLs that being with http://example.com/gizmos/ will be processed by the selector 212 . The selector 212 may discard URLs that may include an indication they are not to be crawled; that have been recently searched and indexed for the native application, that are indicated as being deleted or inactive; or URLs that meet some other exclusion criteria.
- system 120 instantiates a virtual machine emulating an operating system for a user device.
- the virtual machine may, in some implementations, be a modified version of the operating system and includes extractors that extract data from application pages as described in more detail below.
- the system 120 also instantiates, within the virtual machine, a native application 107 that generates application pages for display on a user device within the native application 107 , and then accesses, within the virtual machine, application pages of the native application generated in response to processing the selected URLs.
- the system 110 For each application page, the system 110 generates application page data describing content of the application page.
- the content of the page may include, for example, text displayed on the application page; images displayed on the application page; links on the application page to other application pages or other web resources; and other content that is appropriate for indexing.
- the virtual machine includes extractors that extract content data for indexing.
- the extracted content data is, for example, data that is provided to a rendering process of the native application.
- the rendering process renders content based on the data for display on a user device.
- Use of extractors allows for more accurate identification of the various content of an application page.
- the text extractor extracts text data provided to a rendering process of the native application.
- the text data specifies the text that is to be rendered in the application page.
- the virtual machine receives the actual text that is to be rendered in the environment of the native application 107 .
- extractors can likewise be used, such as an image extractor and a list extractor.
- the image extractor provides image data of an image that is to be rendered in the environment of the native application 107
- the list extractor provides list data of a list of scrollable items that is rendered in the environment of the native application 107 .
- Other data can also be extracted, such as application page link data describing links within the application page that link to another application page; web page link data describing links within the application page that link to a web resource referenced by a uniform resource locator and that, when selected, instantiate a browser application that renders the resource in a browser environment separate from the native application; etc.
- the extractors described above, and other appropriate data extractors can be implemented using appropriate data handlers for a particular operating system.
- the extractors may be implemented using TextView objects, ImageView objects, and ListView objects, respectively.
- the virtual machine processes the objects to extract the corresponding data, e.g., by including instructions that cause the virtual machine to store for indexing the corresponding data that is provided for rendering.
- the process 300 does not process URIs of publisher ( 310 ). This facilitates the indexing of publisher content for only the native application that are affiliated with the publisher (e.g., published by the publisher or approved by the publisher to display publisher content).
- FIG. 4 is a flow diagram of another example process for generating deep links for native applications.
- the process 400 is implemented in a data processing apparatus of one or more computers.
- the process 400 determines a URI pattern for a native application ( 402 ).
- the application manifest 109 may be accessed to determine the URI scheme.
- the URI scheme may be used to define a “top level” native application URI resource, or may be used to select URIs that have already been indexed for the native application.
- the process 400 instantiate the native application and selects a first URI based on the URI pattern to generate an application page in the native application display environment ( 404 ). For example, a virtual machine is instantiated, and on the virtual machine the native application is also instantiated. The URI is provided to the native application and the application page is rendered.
- the process 400 begins an iterative discovery process ( 406 ). The process will continue until a complete set of URIs have been processed.
- the process 400 determines, from the application page, outbound URIs including in the first application page ( 408 ).
- a native application API determines from the application page data URIs that link to other native application URIs. The determination can be made, for example, by processing text extracted from the application page for matches to the URI pattern generated from the manifest 109 ; or based on the API selecting mark-up text that defines outgoing URIs.
- the process 400 selects one or more of the outbound URIs to generate one or more subsequent application pages in the native application display environment ( 410 ). In some implementations, all outgoing URIs are selected. In other implementations, only the outbound URIs conforming to the URI pattern of the native application are selected.
- the process 400 indexes the application page data for each of the one or more subsequent application pages in the index ( 412 ).
- the system 110 can use a virtual machine, or some other construct, to extract the application page data for indexing.
- the process 400 determines if the iterative discovery process has ended ( 414 ). If the iterative discovery process has ended, then the process 400 ends application indexing for the native application ( 416 ). Otherwise, the process 400 returns to step 406 and begins another iteration.
- the native application API when actual users view content within the native applications, can be used to let the application crawling and indexing system 120 know that links that are actually being viewed by users.
- the application crawling and indexing system 120 can use this information as an additional source of links, in addition to the organic discovery described above.
- the application crawling and indexing system 120 can also prioritize crawling based on the popularity of links.
- Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage medium for execution by, or to control the operation of, data processing apparatus.
- the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- a computer storage medium can be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them.
- a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially-generated propagated signal.
- the computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
- the operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
- data processing apparatus encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations, of the foregoing.
- the apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them.
- the apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.
- a computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment.
- a computer program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code).
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer.
- a processor will receive instructions and data from a read-only memory or a random access memory or both.
- the essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- mass storage devices for storing data
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few.
- PDA personal digital assistant
- GPS Global Positioning System
- USB universal serial bus
- Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks
- magneto-optical disks e.g., CD-ROM and DVD-ROM disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a user computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network.
- Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
- LAN local area network
- WAN wide area network
- inter-network e.g., the Internet
- peer-to-peer networks e.g., ad hoc peer-to-peer networks.
- the computing system can include users and servers.
- a user and server are generally remote from each other and typically interact through a communication network. The relationship of user and server arises by virtue of computer programs running on the respective computers and having a user-server relationship to each other.
- a server transmits data (e.g., an HTML page) to a user device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the user device).
- Data generated at the user device e.g., a result of the user interaction
Abstract
Description
- This application claims priority under 35 USC §119(e) to U.S. Patent Application Ser. No. 62/017,193, filed on Jun. 25, 2014, the entire contents of which are hereby incorporated by reference.
- The Internet provides access to a wide variety of information. For example, digital image files, video and/or audio files, as well as web page resources for particular subjects or particular news articles, are accessible over the Internet. With respect to web page resources, many of these resources are designed to facilitate the performing of particular functions, such as banking, booking hotel reservations, shopping, etc., or to provide structured information, such as on-line encyclopedias, movie databases, etc.
- A variety of search engines are available for identifying particular web page resources accessible over the Internet. With the advent of tablet computers and smart phones, native applications that facilitate the performance of the same functions facilitated by the use of web page resources are now being provided in large numbers.
- A user's informational need may thus be satisfied by providing search results that identify either one (or both) of a particular web page resource or a native applications that facilitates the performance of the same functions facilitated by web page resource, or presents the same or very similar information as the web page resource.
- The present disclosure relates to native application deep linking, and more specifically to systems and methods for automatically generating native application deep links.
- In general, one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving publisher affiliation data for native applications that define, for each native application, an affiliated publisher for the native application; for each native application of a set of native applications, determining, based on the publisher affiliation data, whether it is affiliated with a publisher that provides content addressed by URIs determined for the native application; for only the native applications that are determined to be affiliated with a publisher that provides content addressed by URIs determined for the native application: selecting URIs based on the URI pattern for the native application, indexing content accessible by the URI for the native application in an index that is searchable by a search engine. Other embodiments of this aspect include corresponding systems, apparatus, and computer programs, configured to perform the actions of the methods, encoded on computer storage devices.
- Another innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of determining a uniform resource identifier (URI) pattern for a native application; instantiating the native application and selecting a first URI based on the URI pattern to generate an application page in the native application display environment; indexing application page data of the application page in an index that is searchable by a search engine; iteratively processing linked application pages for the native application until a cessation event occurs, the iterative processing comprising for each iteration; determining, from the application page, outbound URIs including in the first application page; selecting one or more of the outbound URIs to generate one or more subsequent application pages in the native application display environment; indexing the application page data for each of the one or more subsequent application pages in the index. Other embodiments of this aspect include corresponding systems, apparatus, and computer programs, configured to perform the actions of the methods, encoded on computer storage devices.
- Particular embodiments of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages. The generation of the deep links makes it easier for application developers to participate in native application indexing, which in turn helps drive usage and re-engagement of their applications. The system also lowers the barrier for participation.
- The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
-
FIG. 1 is a block diagram of an example environment in which deep links for native applications are generated. -
FIG. 2 is a block diagram of an application crawling and indexing system. -
FIG. 3 is a flow diagram of an example process for generating deep links for native applications. -
FIG. 4 is a flow diagram of another example process for generating deep links for native applications. - Like reference numbers and designations in the various drawings indicate like elements.
- A system provides native application search results. As used herein, a native application operates independent of a browser application on the user device. A native application is an application specifically designed to run on a particular user device operating system and machine firmware and not within a browser. Native applications thus differ from browsers, browser-based applications and browser-rendered resources. The latter require all, or at least some, elements or instructions downloaded from a web server each time they are instantiated or rendered. Furthermore, browser-based applications and browser-rendered resources can be processed by all web-capable mobile devices within the browser and thus are not operating system specific as are native applications. Furthermore, as used herein, a native application search result is a search result that corresponds to a particular native application and that, when selected, invokes the particular native application.
- Examples of native application include applications to create text documents, edit photographs, play music, interface with a remote banking system, and so on. Mobile native applications are designed to operate on mobile devices such as smart phones, tablets, and so on. Web native applications are designed to run within (both visually and functionally) web browser software. At a very high level, native applications, or simply “apps,” provide a user with access to content and/or functionality.
- Internet search engines provide the ability to search an indexed collection of web pages that exist on the Internet. The typical search engine provides, in response to a query, a list of results relevant to the query, often with hyperlinks allowing a user to quickly navigate to a result of interest. A user may select a linked result and thereby be provided with a web page(s) containing content about a celebrity, product, business, etc. The links may be to a site's “home page” (e.g., a welcome and search page for a site aggregating cooking information such as recipes) or may be a “content page” that a user can access when navigating from a site's home page (e.g., a specific recipe at the cooking information site). Links to content pages, as opposed to home pages, are referred to as “deep links” (and the process for crawling, indexing, and serving these content pages is similarly referred to as “deep linking”).
- The ability to navigate to a page, as well as the accessibility of content and functionality that that page provides, is dictated in part by the nature of the published page. For example, certain pages may contain dynamic content (e.g., asynchronous java script and XML (AJAX), Adobe Flash, etc.) that are difficult or impossible to crawl and retrieve. Consequently, these pages may not be available in response to a search, a user may not be able to save the page as a bookmark or the like, and page navigation via browser controls (e.g., forward and back in history) may not operate as intended.
- Some native applications lack some of the basic properties of websites when it comes to linking First, when a search engine crawls a native application, it cannot simply inspect the existing link to a page and look at the outbound links of the page like it can by looking at the HTML of a webpage. Second, many native applications do not link to one another the way that websites inherently do, so search engines cannot rely on crawling the web to discover app deep links like they can for discovering web links. This makes it challenging for native application search engines in that it is much more difficult to discover links that a native application supports. If a native application search engine cannot discover links, then it cannot index them, retrieve them, and serve them to users.
- Furthermore, some native applications have corresponding web pages for the URIs the native applications access, while others do not. Of those that do have corresponding web pages, some native applications maintain duplicate or corresponding content and functionality between the native application and web platforms, while other native applications have small or large degree differences between mobile and web platforms.
- Some systems for indexing native applications rely on developers to publish their native application deep links either as HTML markup on their webpages or in their existing sitemaps. That is, the native application provider must have both a web platform and at least map the native application pages at the website. Some services providing native application deep linking also rely on developers publishing their native application deep links on their webpages.
- According to the present disclosure, native application deep links may be automatically generated for indexing purposes. There are numerous methods for native application deep link generation, depending on the nature of the native application deep links. For example, some native applications support deep links having URIs that conform to web-based uniform resource locators (URLs), such as http://www.example.com, etc. Other native applications use a custom URI that does not necessarily conform to a particular HTTP protocol.
- For native applications that support deep linking based on web-based URLs, a process to generate native application deep links includes:
-
- 1) Native application developers verify their official website with a centralized indexing service. The service then indexes the native application based on the previously indexed web URLs discovered through web crawling.
- 2) A native application data crawling and indexing system inspects registration information, such as a manifest file, of the native application to determine if it supports the appropriate URL structure of the website.
- 3) If the native application does support the appropriate URL structure, the native application data crawling and indexing system can determine and prioritize links based on criteria such as popularity. The native application data crawling and indexing system will also respect any non-index tag in the registration information which specifies which URL paths should not be indexed.
- According to a second aspect of the present disclosure, for native applications that support custom deep linking, a system implements a method comprising the following steps:
-
- 1) Native application developers implement a native application indexing API that allows specifying the URI address of a particular native application document, its corresponding web URL (if any), and all outbound app deep links and their associated web URLs (if any) that are on the document.
- 2) Once a native application is updated at a digital distribution source, the native application data crawling and indexing system inspects the native application to determine if it is using the native application indexing API. If so, then the native application data crawling and indexing system launches the native application and looks for the link to native applications “home page.” The native application data crawling and indexing system also looks for any outbound URI links on the application page. If there are outbound URIs, then the native application data crawling and indexing system will index each of those links (or only affiliated links), and will also in turn process the subsequent native application pages for outbound URIs as well. Thus the native application data crawling and indexing system is able to automatically discover links. And at each step, the native application data crawling and indexing system can check the current link of the application page against the source link as a method of authentication.
- 3) The native application data crawling and indexing system can be used to maintain a list of those links that are actually being viewed by the user within a native application, and provide that list to the native application data crawling and indexing system. The native application data crawling and indexing system uses this list as an additional source of links, in addition to the automatic discovery described in the previous step. Furthermore, the lists of links that are actually viewed can be used to determine link popularity, and the native application data crawling and indexing system can then prioritize crawling based on the popularity of links.
- Accordingly, the systems and methods described herein can provide an automatic indexing of native application deep links. The systems and methods may further determine and utilize link prioritizations from actual user activity. Prioritization permits, inter alia, optimizing the utilization of search resources. Finally, systems and methods are disclosed that can accommodate apps with and without corresponding websites, overcoming the limitations of existing techniques that require apps to publish links through corresponding webpages.
-
FIG. 1 is a block diagram of anexample environment 100 in which deep links for native applications are generated. Acomputer network 102, such as the Internet, connects resourcepublisher web sites 104,application publishers 106,user devices 108 and asearch engine 120. - A
resource publisher website 104 includes one ormore web resources 105 associated with a domain and hosted by one or more servers in one or more locations. Generally, a resource publisher website is a collection of web pages formatted in hypertext markup language (HTML) that can contain text, images, multimedia content, and programming elements. Eachwebsite 104 is maintained by a content publisher, which is an entity that controls, manages and/or owns thewebsite 104. - A web page resource is any data that can be provided by a
publisher website 104 over thenetwork 102 and that has a resource address, e.g., a uniform resource locator (URL). Web resources may be HTML pages, images files, video files, audio files, and feed sources, to name just a few. The resources may include embedded information, e.g., meta information and hyperlinks, and/or embedded instructions, e.g., client-side scripts. - An
application publisher website 106 may also include one ormore web resources 105, and also providesnative applications 107. Anative application 107 is an application specifically designed to run on a particular user device operating system and machine firmware.Native applications 107 may include multiple versions designed to run on different platforms. For example, native applications corresponding to a movie database website may include a first native application that runs on a first type of smart phone, a second native application that runs on a second type of smart phone, a third native application that runs on a first type of tablet, etc. - An application page is a particular display environment within a native application and in which is displayed content, such as text, images, and the like. An application page is specific to the particular native application, and the native application is specific to the particular operating system of the
user device 108. An application page differs from a rendered web resource in that the application page is generated within and specific to the native application, while a web resource may be rendered in any browser for which the web page resource is compatible, and is independent of the operating system of the user device. - Some
publishers publisher backend 130. Thepublisher backend 130 includes apublisher store 132 that stores content the publisher provides, aweb server 134 that provides the content from the publisher store as web resources (e.g., web pages), and anative application server 136 that handles requests from a native application. The web pages correspond to native application pages, and thus for many native application URIs there are corresponding web page URIs. Some native applications may also simply use the same URLs as the web pages to which they correspond. The content of thepublisher store 132 is accessible for presentation on both the web resources and the corresponding native application pages. Accordingly, such content is referred to as “synchronized” content. - Examples of such publishers are news publishers, which may have a “mobile news app” for reading news content on a mobile device. The news content (e.g., the text of news story) provided on
web resources 105 are the same content that is provided by the corresponding application pages of thenative application 107. - A
user device 108 is an electronic device that is capable of requesting and receivingweb page resources 105 andnative applications 107 over thenetwork 102.Example user devices 108 include personal computers, mobile communication devices, and tablet computers. - The
web index 116 is an index of publisher content that has, for example, been built from crawling thepublisher websites 104, by receiving data feeds from thepublisher websites 104, or by other appropriate methods of collecting and indexing data. - The
native application index 114 stores data relating tonative applications 107. Theapplication index 114 stores, for example, a list of native applications provided by thepublishers 104 and identifiers that identify the native applications. Furthermore, in some implementations,publishers 104 may specify that certainnative applications 107 are used to access and display synchronized data, and this information may be stored in the application index. For example, a news publisher may specify that a news reading application it provides displays synchronized content that is displayed on the news publisher's website. - The
user devices 108 submit search queries to thesearch engine 110. In response to each query, thesearch engine 110 accesses theweb index 116 and theapplication index 114 to identify content that is relevant to the query. Thesearch engine 110 may, for example, identify the resources and applications in the form of web resource search results and native application search results, respectively, by of use asearch result generator 116. Once generated, the search results are provided to theuser device 108 from which the query was received. - A web resource search result is data generated by the
search engine 110 that identifies a web resource, based on the content of the resource that satisfies a particular search query. A web resource search result for a resource can include a web page title, a snippet of text extracted from the resource, and a uniform resource identifier (URI) for the resource, e.g., the uniform resource locator (URL) of the web page. When selected at a user device, the web resource search result causes the user device to generate a request for the resource located at the URL. The web resource that is received is then displayed in a browser application. - A native application search result specifies a native application and is generated in response to a search of the
application index 114 and theweb index 116, as described in more detail below. When selected at a user device, the native application search result causes the native application installed on the user device to request the synchronized content. Once the native application receives the requested content, the native application displays the content in a user interface of the native application. - To generate the
application index 114, the search system utilizes an application crawling andindexing system 120.FIG. 2 is a block diagram of an application crawling andindexing system 120. Operation of thesystem 120 in the context of native applications that use URLs is described with reference toFIG. 3 . A variation of the operation for native applications that use custom URIs is described with reference toFIG. 4 . -
FIG. 3 is a flow diagram of anexample process 300 for generating deep links for native applications. Theprocess 300 is implemented in a data processing apparatus of one or more computers. - The
process 300 receives at thedata collector 204publisher affiliation data 202 for native applications that define, for each native application, an affiliated publisher for the native application (302). For example, publishers provide data that a particular native application is affiliated with the publisher, such as an association of a native application identifier with a site identifier of the publisher. One example site identifier is a domain name, but other types of data for defining an affiliation between a publisher and native application can be used. - The
process 300, for a native application, determines based on the publisher affiliation data whether the native application is affiliated with a publisher that provides content addressed by URIs determined for the native application (304). For example, theapplication package crawler 206 extracts from an application manifest file 109 (or other data defining similar application specifications) a scheme, host and path of a URI format for the native application. For example, in the case of an Android manifest, the following is extracted from an intent filter section: - <data android:scheme=“http”
- android:host=“example.com”
- android:pathPrefix=“/gizmos”/>
- Here the scheme is “http,”, the host is “example.com,” and the path is “/gizmos.” The process determining a URI pattern for the native application, and whether the URI pattern defines an affiliated publisher for the native application that matches an affiliated publisher for the native application specified by the
publisher affiliation data 202. To illustrate, for the example data above, if theaffiliation data 202 defines a scheme of “http” for a native application, and a host of “example.com,” and themanifest 109 of thenative application 107 defines the same scheme and host, then the native application is affiliated with the host. - If the determination is positive, the
URI scheme generator 208 stores the data for the native application in the URI scheme table 210, and then theprocess 300 selects URIs based on the URI pattern for the native application (306). For example, in some implementations, theURI selector 212 retrieves the URI pattern from the URI scheme table 210. Theselector 212 then searches theweb index 116 for URL's that that include the URI pattern. In the example above, candidate URLs that being with http://example.com/gizmos/ will be processed by theselector 212. Theselector 212 may discard URLs that may include an indication they are not to be crawled; that have been recently searched and indexed for the native application, that are indicated as being deleted or inactive; or URLs that meet some other exclusion criteria. - The remaining URLs that are selected are provided to a
URI processor 214, which the collects data from content accessible by the URL. Theprocess 300 then indexes content accessible by the URL for the native application in an index that is searchable by a search engine (308). The collection and indexing of data can be done by any appropriate process. In one example implementation,system 120 instantiates a virtual machine emulating an operating system for a user device. The virtual machine may, in some implementations, be a modified version of the operating system and includes extractors that extract data from application pages as described in more detail below. - The
system 120 also instantiates, within the virtual machine, anative application 107 that generates application pages for display on a user device within thenative application 107, and then accesses, within the virtual machine, application pages of the native application generated in response to processing the selected URLs. For each application page, thesystem 110 generates application page data describing content of the application page. The content of the page may include, for example, text displayed on the application page; images displayed on the application page; links on the application page to other application pages or other web resources; and other content that is appropriate for indexing. - In some implementations, the virtual machine includes extractors that extract content data for indexing. The extracted content data is, for example, data that is provided to a rendering process of the native application. The rendering process renders content based on the data for display on a user device. Use of extractors allows for more accurate identification of the various content of an application page. For example, the text extractor extracts text data provided to a rendering process of the native application. The text data specifies the text that is to be rendered in the application page. Thus, rather than processing an image of the application page, or processing binary data of the display, the virtual machine receives the actual text that is to be rendered in the environment of the
native application 107. - Other extractors can likewise be used, such as an image extractor and a list extractor. The image extractor provides image data of an image that is to be rendered in the environment of the
native application 107, and the list extractor provides list data of a list of scrollable items that is rendered in the environment of thenative application 107. Other data can also be extracted, such as application page link data describing links within the application page that link to another application page; web page link data describing links within the application page that link to a web resource referenced by a uniform resource locator and that, when selected, instantiate a browser application that renders the resource in a browser environment separate from the native application; etc. - The extractors described above, and other appropriate data extractors, can be implemented using appropriate data handlers for a particular operating system. For example, for the Android™ operating system, the extractors may be implemented using TextView objects, ImageView objects, and ListView objects, respectively. The virtual machine processes the objects to extract the corresponding data, e.g., by including instructions that cause the virtual machine to store for indexing the corresponding data that is provided for rendering.
- Returning to 304, if the determination is negative, then the
process 300 does not process URIs of publisher (310). This facilitates the indexing of publisher content for only the native application that are affiliated with the publisher (e.g., published by the publisher or approved by the publisher to display publisher content). - For native applications that support custom deep linking that does not necessarily conform to a website, a different process is used to generate deep links
FIG. 4 is a flow diagram of another example process for generating deep links for native applications. The process 400 is implemented in a data processing apparatus of one or more computers. - The process 400 determines a URI pattern for a native application (402). For example, the
application manifest 109 may be accessed to determine the URI scheme. The URI scheme may be used to define a “top level” native application URI resource, or may be used to select URIs that have already been indexed for the native application. - The process 400 instantiate the native application and selects a first URI based on the URI pattern to generate an application page in the native application display environment (404). For example, a virtual machine is instantiated, and on the virtual machine the native application is also instantiated. The URI is provided to the native application and the application page is rendered.
- The process 400 begins an iterative discovery process (406). The process will continue until a complete set of URIs have been processed.
- The process 400 determines, from the application page, outbound URIs including in the first application page (408). For example, a native application API determines from the application page data URIs that link to other native application URIs. The determination can be made, for example, by processing text extracted from the application page for matches to the URI pattern generated from the
manifest 109; or based on the API selecting mark-up text that defines outgoing URIs. - The process 400 selects one or more of the outbound URIs to generate one or more subsequent application pages in the native application display environment (410). In some implementations, all outgoing URIs are selected. In other implementations, only the outbound URIs conforming to the URI pattern of the native application are selected.
- The process 400 indexes the application page data for each of the one or more subsequent application pages in the index (412). As described above, the
system 110 can use a virtual machine, or some other construct, to extract the application page data for indexing. - The process 400 determines if the iterative discovery process has ended (414). If the iterative discovery process has ended, then the process 400 ends application indexing for the native application (416). Otherwise, the process 400 returns to step 406 and begins another iteration.
- In some implementations, when actual users view content within the native applications, the native application API can be used to let the application crawling and
indexing system 120 know that links that are actually being viewed by users. The application crawling andindexing system 120 can use this information as an additional source of links, in addition to the organic discovery described above. Furthermore, the application crawling andindexing system 120 can also prioritize crawling based on the popularity of links. - Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage medium for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. A computer storage medium can be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Moreover, while a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially-generated propagated signal. The computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
- The operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
- The term “data processing apparatus” encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations, of the foregoing. The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.
- A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few. Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's user device in response to requests received from the web browser.
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a user computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
- The computing system can include users and servers. A user and server are generally remote from each other and typically interact through a communication network. The relationship of user and server arises by virtue of computer programs running on the respective computers and having a user-server relationship to each other. In some embodiments, a server transmits data (e.g., an HTML page) to a user device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the user device). Data generated at the user device (e.g., a result of the user interaction) can be received from the user device at the server.
- While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any inventions or of what may be claimed, but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
- Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
- Thus, particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.
Claims (22)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/750,082 US10073911B2 (en) | 2014-06-25 | 2015-06-25 | Deep links for native applications |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201462017193P | 2014-06-25 | 2014-06-25 | |
US14/750,082 US10073911B2 (en) | 2014-06-25 | 2015-06-25 | Deep links for native applications |
Publications (2)
Publication Number | Publication Date |
---|---|
US20150379128A1 true US20150379128A1 (en) | 2015-12-31 |
US10073911B2 US10073911B2 (en) | 2018-09-11 |
Family
ID=53511031
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/750,082 Active 2036-08-20 US10073911B2 (en) | 2014-06-25 | 2015-06-25 | Deep links for native applications |
Country Status (6)
Country | Link |
---|---|
US (1) | US10073911B2 (en) |
EP (1) | EP3161678B1 (en) |
JP (1) | JP6370408B2 (en) |
CN (1) | CN106663108B (en) |
RU (1) | RU2668726C2 (en) |
WO (1) | WO2015200600A1 (en) |
Cited By (11)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20170124101A1 (en) * | 2015-10-29 | 2017-05-04 | Google Inc. | Indexing native application data |
US20170193062A1 (en) * | 2015-12-31 | 2017-07-06 | Quixey, Inc. | Combining Search Results to Generate Customized Software Application Functions |
WO2017120360A1 (en) * | 2016-01-05 | 2017-07-13 | Quixey, Inc. | Computer-automated generation of application deep links |
WO2017172659A1 (en) * | 2016-03-31 | 2017-10-05 | Microsoft Technology Licensing, Llc | Enabling stateful dynamic links in mobile applications |
WO2017172666A1 (en) * | 2016-03-31 | 2017-10-05 | Microsoft Technology Licensing, Llc | Validating stateful dynamic links in mobile applications |
US20180219963A1 (en) * | 2017-01-31 | 2018-08-02 | Microsoft Technology Licensing, Llc | Automated application linking |
US10146785B2 (en) * | 2015-05-13 | 2018-12-04 | Samsung Electronics Co., Ltd. | Operator-guided application crawling architecture |
US20200326914A1 (en) * | 2019-04-15 | 2020-10-15 | Andrej KOELEWIJN | Creating an app method and system |
US10810278B2 (en) * | 2017-04-18 | 2020-10-20 | Google Llc | Contextual deep bookmarking |
US11003724B2 (en) * | 2013-03-15 | 2021-05-11 | Gadget Software, Inc. | System for mobile application search |
US11574028B2 (en) * | 2018-06-28 | 2023-02-07 | Google Llc | Annotation and retrieval of personal bookmarks |
Families Citing this family (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JP2018048042A (en) * | 2016-09-21 | 2018-03-29 | Jsr株式会社 | Method for producing silica particle, silica particle, and chemical mechanical polishing composition |
CN108008941B (en) * | 2017-11-16 | 2019-06-21 | 北京大学 | A kind of deep chain interface automatic generation method and depth chain execution method of Android application |
US10409575B2 (en) * | 2018-02-09 | 2019-09-10 | Cognizant Technology Solutions India Pvt. Ltd. | System and method for developing software applications of wearable devices |
CN109918153B (en) * | 2019-03-18 | 2022-05-27 | 北京信息科技大学 | Page opening method and device and page content retrieval method and device |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20060230011A1 (en) * | 2004-11-22 | 2006-10-12 | Truveo, Inc. | Method and apparatus for an application crawler |
US20100024016A1 (en) * | 2006-01-09 | 2010-01-28 | Thierry Violleau | Method and apparatus for protection domain based security |
US20130311301A1 (en) * | 2012-05-17 | 2013-11-21 | Ad-Vantage Networks, Inc. | Content easement and management system for internet access providers and premise operators |
US20140358887A1 (en) * | 2013-05-29 | 2014-12-04 | Microsoft Corporation | Application content search management |
Family Cites Families (42)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JP2004038889A (en) | 2002-07-08 | 2004-02-05 | Ntt Docomo Inc | Service providing system and service providing method |
US20040030882A1 (en) | 2002-08-08 | 2004-02-12 | Forman George Henry | Managed application pre-launching |
US7076616B2 (en) | 2003-03-24 | 2006-07-11 | Sony Corporation | Application pre-launch to reduce user interface latency |
US7730012B2 (en) | 2004-06-25 | 2010-06-01 | Apple Inc. | Methods and systems for managing data |
JP4769822B2 (en) | 2005-03-04 | 2011-09-07 | チョンヌン インコーポレイテッド | Information search service providing server, method and system using page group |
CN101004694B (en) * | 2006-01-09 | 2012-05-30 | 太阳微系统有限公司 | Method and apparatus for data transfer between isolated execution contexts |
US8707451B2 (en) | 2006-03-01 | 2014-04-22 | Oracle International Corporation | Search hit URL modification for secure application integration |
US7797340B2 (en) | 2007-06-15 | 2010-09-14 | Samsung Electronics Co., Ltd. | Method and system for searchable web services |
CA2711731A1 (en) * | 2008-02-14 | 2009-08-20 | Nokia Corporation | System and method for implementing a publication |
US8086957B2 (en) | 2008-05-21 | 2011-12-27 | International Business Machines Corporation | Method and system to selectively secure the display of advertisements on web browsers |
WO2010020963A2 (en) | 2008-08-21 | 2010-02-25 | Mango Moon Trading 1138 Cc | Indexing system |
US8219572B2 (en) | 2008-08-29 | 2012-07-10 | Oracle International Corporation | System and method for searching enterprise application data |
JP5476752B2 (en) | 2009-03-13 | 2014-04-23 | 株式会社リコー | Information processing apparatus, information processing method, and program |
US20100257466A1 (en) | 2009-04-01 | 2010-10-07 | Yahoo! Inc. | Method and system for generating a mini-software application corresponding to a web site |
CN102483753A (en) | 2009-05-27 | 2012-05-30 | 谷歌公司 | Computer Application Data In Search Results |
US8458384B2 (en) | 2010-02-03 | 2013-06-04 | National Instruments Corporation | Automatically launching a measurement application in response to measurement device connection |
US9098363B2 (en) | 2010-04-07 | 2015-08-04 | Apple Inc. | Search extensibility to third party applications |
US8515979B2 (en) | 2010-06-18 | 2013-08-20 | Verizon Patent And Licensing, Inc. | Cross application execution service |
US20120124061A1 (en) * | 2010-11-12 | 2012-05-17 | Microsoft Corporation | Rich Search Over and Deep Integration with Applications |
US8909697B2 (en) | 2010-11-29 | 2014-12-09 | Hughes Network Systems, Llc | Computer networking system and method with javascript execution for pre-fetching content from dynamically-generated URL and javascript injection to modify date or random number calculation |
US9317621B2 (en) | 2011-01-06 | 2016-04-19 | Microsoft Technology Licensing, Llc | Providing deep links in association with toolbars |
US9858092B2 (en) | 2011-01-06 | 2018-01-02 | Mitel Networks Corporation | Contextual application launch via search query |
US20120316955A1 (en) | 2011-04-06 | 2012-12-13 | Yahoo! Inc. | System and Method for Mobile Application Search |
RU110847U1 (en) | 2011-05-05 | 2011-11-27 | Игорь Викторович Лебедев | INFORMATION AND SEARCH SYSTEM |
EP2712442A1 (en) | 2011-05-09 | 2014-04-02 | Google, Inc. | Recommending applications for mobile devices based on installation histories |
CN102226916B (en) * | 2011-05-30 | 2015-07-29 | 华为技术有限公司 | Platform, the method and apparatus of management application program |
US9519726B2 (en) | 2011-06-16 | 2016-12-13 | Amit Kumar | Surfacing applications based on browsing activity |
US8650139B2 (en) | 2011-07-01 | 2014-02-11 | Google Inc. | Predicting user navigation events |
KR101491878B1 (en) | 2011-08-31 | 2015-02-09 | 라인 가부시키가이샤 | System and method for providing ranking information of mobile application using information obtained from user terminal |
US20130110815A1 (en) | 2011-10-28 | 2013-05-02 | Microsoft Corporation | Generating and presenting deep links |
CA2854142A1 (en) | 2011-11-01 | 2013-05-10 | Google Inc. | Launching applications from webpages |
US8554345B2 (en) | 2011-11-10 | 2013-10-08 | Cbs Interactive, Inc. | APP rating system |
KR101295644B1 (en) | 2011-11-11 | 2013-09-16 | 한국전자통신연구원 | System and method for verifying smart phone application |
US20130124606A1 (en) | 2011-11-14 | 2013-05-16 | Boopsie, Inc. | Automatic personalization of downloadable mobile apps |
CN103176790B (en) * | 2011-12-26 | 2016-04-20 | 阿里巴巴集团控股有限公司 | Application dissemination method and system |
US8793235B2 (en) | 2012-01-19 | 2014-07-29 | Google Inc. | System and method for improving access to search results |
GB2501276A (en) | 2012-04-18 | 2013-10-23 | Ibm | Determining web page loading at a client |
CN102710753B (en) * | 2012-05-15 | 2015-09-09 | 华为技术有限公司 | A kind of dissemination method of internet, applications, Apparatus and system |
US9510141B2 (en) | 2012-06-04 | 2016-11-29 | Apple Inc. | App recommendation using crowd-sourced localized app usage data |
US20140040226A1 (en) * | 2012-07-31 | 2014-02-06 | Microsoft Corporation | Providing application result and preview |
US8510764B1 (en) | 2012-11-02 | 2013-08-13 | Google Inc. | Method and system for deep links in application contexts |
CN103838584B (en) * | 2014-03-26 | 2017-09-15 | 北京京东尚科信息技术有限公司 | The development approach and device of a kind of mobile terminal application |
-
2015
- 2015-06-25 WO PCT/US2015/037639 patent/WO2015200600A1/en active Application Filing
- 2015-06-25 EP EP15734014.2A patent/EP3161678B1/en active Active
- 2015-06-25 JP JP2016574940A patent/JP6370408B2/en active Active
- 2015-06-25 CN CN201580034756.0A patent/CN106663108B/en active Active
- 2015-06-25 RU RU2016150421A patent/RU2668726C2/en active
- 2015-06-25 US US14/750,082 patent/US10073911B2/en active Active
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20060230011A1 (en) * | 2004-11-22 | 2006-10-12 | Truveo, Inc. | Method and apparatus for an application crawler |
US20100024016A1 (en) * | 2006-01-09 | 2010-01-28 | Thierry Violleau | Method and apparatus for protection domain based security |
US20130311301A1 (en) * | 2012-05-17 | 2013-11-21 | Ad-Vantage Networks, Inc. | Content easement and management system for internet access providers and premise operators |
US20140358887A1 (en) * | 2013-05-29 | 2014-12-04 | Microsoft Corporation | Application content search management |
Cited By (26)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11550857B2 (en) | 2013-03-15 | 2023-01-10 | Gadget Software, Inc. | System for mobile application search |
US11003724B2 (en) * | 2013-03-15 | 2021-05-11 | Gadget Software, Inc. | System for mobile application search |
US10146785B2 (en) * | 2015-05-13 | 2018-12-04 | Samsung Electronics Co., Ltd. | Operator-guided application crawling architecture |
US20230044789A1 (en) * | 2015-10-29 | 2023-02-09 | Google Llc | Indexing Native Application Data |
US20170124101A1 (en) * | 2015-10-29 | 2017-05-04 | Google Inc. | Indexing native application data |
US11748429B2 (en) * | 2015-10-29 | 2023-09-05 | Google Llc | Indexing native application data |
US10120949B2 (en) * | 2015-10-29 | 2018-11-06 | Google Llc | Indexing native application data |
US20190026294A1 (en) * | 2015-10-29 | 2019-01-24 | Google Llc | Indexing native application data |
US11500953B2 (en) * | 2015-10-29 | 2022-11-15 | Google Llc | Indexing native application data |
US10915592B2 (en) * | 2015-10-29 | 2021-02-09 | Google Llc | Indexing native application data |
US9984132B2 (en) * | 2015-12-31 | 2018-05-29 | Samsung Electronics Co., Ltd. | Combining search results to generate customized software application functions |
US20170193062A1 (en) * | 2015-12-31 | 2017-07-06 | Quixey, Inc. | Combining Search Results to Generate Customized Software Application Functions |
WO2017120360A1 (en) * | 2016-01-05 | 2017-07-13 | Quixey, Inc. | Computer-automated generation of application deep links |
WO2017172666A1 (en) * | 2016-03-31 | 2017-10-05 | Microsoft Technology Licensing, Llc | Validating stateful dynamic links in mobile applications |
WO2017172659A1 (en) * | 2016-03-31 | 2017-10-05 | Microsoft Technology Licensing, Llc | Enabling stateful dynamic links in mobile applications |
US10257342B2 (en) | 2016-03-31 | 2019-04-09 | Microsoft Technology Licensing, Llc | Validating stateful dynamic links in mobile applications |
US20180219963A1 (en) * | 2017-01-31 | 2018-08-02 | Microsoft Technology Licensing, Llc | Automated application linking |
US10701166B2 (en) * | 2017-01-31 | 2020-06-30 | Microsoft Technology Licensing, Llc | Automated application linking |
WO2018144256A1 (en) * | 2017-01-31 | 2018-08-09 | Microsoft Technology Licensing, Llc | Automated application linking |
US11423113B2 (en) * | 2017-04-18 | 2022-08-23 | Google Llc | Contextual deep bookmarking |
US10810278B2 (en) * | 2017-04-18 | 2020-10-20 | Google Llc | Contextual deep bookmarking |
US20220391466A1 (en) * | 2017-04-18 | 2022-12-08 | Google Llc | Contextual deep bookmarking |
US11829433B2 (en) * | 2017-04-18 | 2023-11-28 | Google Llc | Contextual deep bookmarking |
US11574028B2 (en) * | 2018-06-28 | 2023-02-07 | Google Llc | Annotation and retrieval of personal bookmarks |
US20230169134A1 (en) * | 2018-06-28 | 2023-06-01 | Google Llc | Annotation and retrieval of personal bookmarks |
US20200326914A1 (en) * | 2019-04-15 | 2020-10-15 | Andrej KOELEWIJN | Creating an app method and system |
Also Published As
Publication number | Publication date |
---|---|
EP3161678B1 (en) | 2020-12-16 |
RU2018133614A3 (en) | 2021-11-30 |
RU2668726C2 (en) | 2018-10-02 |
JP6370408B2 (en) | 2018-08-08 |
CN106663108A (en) | 2017-05-10 |
JP2017522663A (en) | 2017-08-10 |
US10073911B2 (en) | 2018-09-11 |
RU2018133614A (en) | 2018-10-23 |
EP3161678A1 (en) | 2017-05-03 |
CN106663108B (en) | 2020-08-04 |
RU2016150421A3 (en) | 2018-07-25 |
WO2015200600A1 (en) | 2015-12-30 |
RU2016150421A (en) | 2018-07-25 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10073911B2 (en) | Deep links for native applications | |
US9652550B2 (en) | Indexing application pages of native applications | |
US10713324B2 (en) | Search results for native applications | |
US9547721B2 (en) | Native application search results | |
US10068028B1 (en) | Deep link verification for native applications | |
US11188578B1 (en) | Search suggestions based on native application history | |
US20150169703A1 (en) | Ranking of presentation modes for particular content | |
EP3238105B1 (en) | Application partial deep link to a corresponding resource | |
US11003728B1 (en) | Native application search results | |
RU2774319C2 (en) | Deep links for native applications |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:CHANG, LAWRENCE;XU, HUI;REEL/FRAME:036485/0549Effective date: 20150901 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044129/0001Effective date: 20170929 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
CC | Certificate of correction | ||
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |