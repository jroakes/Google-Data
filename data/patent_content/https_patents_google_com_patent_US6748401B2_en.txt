US6748401B2 - Method and system for dynamically managing hash pool data structures - Google Patents
Method and system for dynamically managing hash pool data structures Download PDFInfo
- Publication number
- US6748401B2 US6748401B2 US09/974,977 US97497701A US6748401B2 US 6748401 B2 US6748401 B2 US 6748401B2 US 97497701 A US97497701 A US 97497701A US 6748401 B2 US6748401 B2 US 6748401B2
- Authority
- US
- United States
- Prior art keywords
- new
- record
- index
- key value
- insertion location
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/901—Indexing; Data structures therefor; Storage structures
- G06F16/9014—Indexing; Data structures therefor; Storage structures hash tables
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99941—Database schema or data structure
- Y10S707/99944—Object-oriented database structure
- Y10S707/99945—Object-oriented database structure processing
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99941—Database schema or data structure
- Y10S707/99948—Application of database or data structure, e.g. distributed, multimedia, or image
Definitions
- the present invention relates generally to dynamically managing hash pool data structures. More particularly, the present invention relates to dynamically adding index and contention records to hash data pools in response to data load and data distribution.
- Hashing is a technique for storing and retrieving data records.
- Hash functions provide quick access to individual data cells in a group, via a hash table, without linear searching. Therefore, hashing is especially beneficial for computational problems that grow into a very large scale in terms of data volume.
- a variety of hash functions can be implemented in order to minimize collisions between key values and to minimize processing time for a particular group of data key values. The decision to use a particular hash function is implementation dependent.
- a collision between key values occurs when the output of the hash function is the same for two or more records. When a collision occurs, one of the key values might, based on bucket size, be stored in another location and not the location indicated by the hash function.
- Collision resolution management refers to the process of determining where the other location is and tying the key value into the hash pool data structure in a manner that is accessible at a later point in time.
- a large hash table may be kept on a disk storage device such as DASD (Direct Access Storage Device).
- DASD Direct Access Storage Device
- the hash function or the operating system in response to a request from the hash function, reads a portion of the entire hash table and must manage the process of paging the hash table. When this happens, the speed of processing can be diminished because of the extra time for the Input/Output (I/O) operations and the extra processing overhead required to manage the hash table.
- I/O Input/Output
- the hash records are stored on external storage devices such as DASD, it is important to minimize the number of accesses to the hash records.
- the hash function may be compute intensive with the goal of minimizing the number of I/O operations required to insert or retrieve a record from the hash pool data structure.
- Hash technique exists that keep a small piece of information in memory to quickly find the hash table entry. If the hash table is very large even these techniques exhaust main memory so this associated information must also be placed on DASD which increases the I/O required.
- An index can be used to reduce the required hash table space. This option requires at least one extra I/O operation.
- the benefit is a reduction in the number of required hash table records that must be pre-allocated.
- the number of “slots” that can be contained in a hash table record determines how much the hash table space can be reduced. If a four-thousand and ninety-six byte (4K) record size is used, and an allowance is made to use ninety-six bytes for system overhead, the 4K record could hold five-hundred eight byte storage addresses. In this scenario, the use of a one level index could reduce the required number of pre-allocated hash table records by a factor of five hundred.
- a second level index could reduce the number of pre-allocated hash table records by another factor of five-hundred, resulting in a reduction of two-hundred and fifty thousand.
- a third level index reduces the requirement by a factor of one-hundred and twenty-five million but adds three required I/O operations in retrieving a data record if the index records are stored on DASD.
- Contention of keys to the same hash slot can be handled with record chaining.
- a look-up routine can detect that there is more than one record and can examine the contents of the record for an exact match.
- the average number of I/O operations required in chaining can be expressed by the equation “(k+1)/2” where “k” is the length of the chain.
- the chain can be implemented using a linked list that connects the records together. After a hash function is performed on a key value, a sequential search is performed on the linked list until either the key value is found or the spot to insert the key value is located.
- the linked list could be sorted in terms of frequency of access or alphabetically to expedite the search.
- a look-up routine can detect that the record is a contention record and that the record contains a table of key values and record addresses. The look-up routine can go through the record looking for a match of the key value, and if found, can use the record address that corresponds to the key value to locate a user data record. Any of the above methods: indexes, contention records and chaining; can be utilized when contention is encountered in a hash pool data structure. Which one is selected depends on balancing factors that can include the number of I/O operations, the required storage space, the number of hash table entries, and the required speed of data access.
- An exemplary embodiment of the present invention is a method for dynamically managing a hash pool data structure.
- a request to insert a new key value into a hash pool data structure that includes at least one index level is received.
- An insertion location is calculated for the new key value in response to the new key value and to existing key values in the hash pool data structure.
- the insertion location includes an index level.
- a new index level is added at the insertion location if the index level is not the maximum number of index levels in the hash pool data structure; if the insertion location contains a chain of existing key values with a length equal to the maximum chain length; and if the new index record locations of the new key value and the existing key values are dispersed.
- the insertion location is updated in response to adding a new index record and the new key value is inserted into the insertion location.
- An additional embodiment includes a storage medium for dynamically managing a hash pool data structure.
- FIG. 1 is a block diagram of an exemplary embodiment of a system for dynamically managing hash pool data structures.
- FIG. 2 is a flowchart of an exemplary high level process for inserting a record into a hash pool.
- FIG. 3 depicts an exemplary process for inserting a record into a second level index data structure.
- FIG. 4 depicts an exemplary process for inserting a record into a contention record data structure.
- FIG. 5 depicts an exemplary process for inserting a record into a user record data structure.
- the disclosed invention is a method of dynamically managing hash pool data structures by combining the use of indexing, chaining, and contention records in an effort to reduce the I/O operations and DASD requirements of hash tables used to process data in a very large data pool.
- the method described in the disclosed invention can be utilized in any hashing implementation but it is especially effective when used with large hash tables containing highly changeable tables or tables with high insertion rates, such as Internet mail user lists or Internet domain name lists.
- the hash data pool is initialized with one level of indexing, but has the ability to selectively add more levels of index records at the points in the data structure where data is clustering.
- a new record being inserted may cause the creation of a contention record or the new record being inserted may be chained to an existing record.
- the decision about which alternative to take when a new record being inserted causes contention is performed by software and is based on many factors that include the data dispersion, the data load, the number of resulting I/O operations, and the number of index levels available. In the disclosed invention these techniques to deal with contention are used together, and shifted into and out of use as the number of entries saved in the hash space changes. Records can be initially single indexed and chained. As more entries end up in the same hash value range, the chain can be changed to a contention record or into a level two index. The decision about which method to use to insert a new record into the hash pool data structure and building the associated data structures is performed dynamically as the record is being inserted.
- FIG. 1 is a block diagram of an exemplary embodiment of a system for dynamically managing hash pool data structures.
- the process starts out with a key value 102 being entered into a hash function 104 .
- the hash function could be any hash function that is known in the art.
- One example of a hash function is to take the EBCDIC or ASCII value of a portion of the key value 102 and add the values of each portion. The sum of the values of each portion are then modulo divided by a prime number just under the hash table size to yield “x”, the output value or ordinal 106 , where x is greater than or equal to zero and less than or equal to one less than the prime number.
- the ordinal 106 is then input into an index location function 108 which will produce pointers to the indexes associated with the ordinal 106 .
- the maximum number of index levels are decided by the system administrator during system set-up and before the hash table is populated with data. For example, the expected number of data records accessed via a hash table could be two-hundred and fifty million. If no indexing is implemented, two-hundred and fifty million records would need to be pre-allocated. This alternative is costly in terms of potentially unused storage space because many records would be empty until the hash table becomes heavily populated with key values.
- the hash table records are broken up into 4K bytes with each record holding up to five-hundred eight-byte storage addresses or slots.
- the index location function 108 calculates at least three values.
- the first value, level one index record address 112 is a pointer to the storage location of the level one index record 116 that corresponds to the key value 102 that was input. It can be calculated by the formula “(x mod y) mod n”, where “x” is the ordinal 106 from the hash function 104 , “y” is the number of slots in each second level index record 122 , and “n” is the number of slots in each first level index record 116 .
- the second value, level one index record off-set 114 points to the slot in the level one index record that corresponds to the key value 102 .
- level two index record off-set 110 points to the slot in the level two index record that corresponds to the key value 102 and can be calculated by the formula “x rem y.”
- a variety of formulas can be implemented to produce the outputs from the index location function 108 . The choice of formulas depends on many factors including the size of the hash table, the size of the records, and the number of levels of indexing.
- the three formulas described are examples of ones that would work for an exemplary embodiment that includes a hash table size of two-hundred and fifty million data records, hash table index records that are 4K bytes in size, and a data structure that includes two levels of indexing.
- the level one index records 116 can be stored on a storage device (e.g. DASD) or they can be stored in main memory.
- a storage device e.g. DASD
- the hash table size is estimated at two-hundred and fifty million
- the one-thousand level one index records 116 would be stored on DASD.
- a storage address is contained in the slot 118 in the level one index record 116 that is pointed to by the level one index record off-set 114 .
- the slot could contain a zero which would indicate that the slot is empty and available for data insertion.
- a key value could be stored in the slot for quick access to the right record.
- only the address of the data record associated with the key value is stored in the slot.
- a reference to inserting a key value refers to either inserting data that includes the actual key value and associated address or to inserting data that includes just the associated address.
- the storage addresses contained in the slots 118 can include storage addresses of three different types of records 120 . First, the storage address contained in the slot 118 could hold a record 120 that is a level two index 122 . The level two index record off-set 110 , that was calculated by the index location function 108 , would point to the slot in the level two index table 122 that corresponds to the key value 102 .
- This slot could be empty (contain a zero), or it could contain a storage address that holds either a user data record 124 or a contention record 126 .
- the level one index record 116 slot 118 could contain a storage address that holds a user data record 124 .
- the user data record 124 contains the data associated with the key value 102 .
- the user data record 124 could be a single record or it could be part of a chain of user data records 124 as depicted in FIG. 1 . In an exemplary embodiment the chain could be implemented using a linked list data structure.
- the slot 118 in the level one index record 116 could also contain the storage address of a record that holds a contention record 126 .
- the contention record 126 is a 4K byte that has 100 slots for user data record 124 storage addresses.
- contention records 126 can be chained.
- Another possibility is that the slot 118 in the level one index record 116 does not contain a storage address because it is empty (contains a zero). This would be the case if no data had been inserted into this slot 118 . When this occurs, the storage address of the associated user data record 124 could be entered directly into the slot.
- the hash function 104 , the index location function 108 , and the process that manages the hash pool data structures can be implemented by software and executed on any host hardware platform under any operating system.
- the host hardware platform is a mainframe and the operating system is Transaction Processing Facility (TPF).
- TPF Transaction Processing Facility
- the hash pool data structures and the software are stored on any kind of storage device including both main memory, disk storage directly connected to the host hardware platform, and disk storage that is remote from the host hardware platform.
- all hash pool data structures and software are stored on disk storage (e.g. DASD) that is directly connected to the host hardware platform.
- the users of the software can be local to the host hardware platform or they can be remote and access the software across a network such as a local area network (LAN), wide area network (WAN), the Internet, an intranet, or any kind of network that is known in the art. All or portions of the software could execute on a remote system, for example the hash function and index location function software may be stored and executed on a remote user system while the hash pool data structure management software is being executed on the host hardware platform. In an exemplary embodiment the users of the software are local to the host hardware platform.
- LAN local area network
- WAN wide area network
- the Internet an intranet, or any kind of network that is known in the art.
- All or portions of the software could execute on a remote system, for example the hash function and index location function software may be stored and executed on a remote user system while the hash pool data structure management software is being executed on the host hardware platform.
- the users of the software are local to the host hardware platform.
- FIG. 2 is a flowchart of an exemplary high level process for inserting a record into a hash pool utilizing the disclosed invention.
- the key value is hashed and the index location values are calculated.
- a loop performed where the records at referenced storage locations are retrieved and analyzed until a place to insert the record is located and the record is inserted.
- the process starts at step 202 and a key value is input at step 204 .
- the hash function is performed on the key value at step 206 which results in a hash value as output.
- a variety of hash functions could be implemented depending on factors that include the expected distribution of the data, the data load, and the size of the hash table.
- the index location function is performed using the ordinal value that is output from the hash function.
- the index location function produces three results: the level one index ordinal 112 , the level one index record off-set 114 , and the level two index record off-set 110 .
- a function is provided that takes an ordinal 112 and produces a record address which contains the exact DASD location of the record.
- the level one index record is retrieved and it is accessed at the slot that is pointed to by the level one index record off-set 114 .
- Step 212 determines if the slot is empty. In an exemplary embodiment this would be indicated by the slot containing the value of zero. If the slot is empty it means that the slot has not been accessed before and that the slot is available for data insertion and step 214 is performed. Step 214 allocates a new data record and populates it with the user data that is associated with the key value. Then, at step 216 , the address of the new data record is stored in the slot. Step 218 is then performed and the inserting process is complete.
- step 220 is performed, if at step 212 it was determined that the slot was not empty.
- the variable “next_record” is set equal to the address contained in the slot.
- step 222 is performed which starts a loop that is performed until the next_record variable is equal to zero.
- step 218 is performed to end the program. If the next-record variable is not equal to zero then the record with the address stored in next-record is retrieved from storage at step 224 .
- step 226 a check is made to see if the record is a second level index record. If it is a second level index record then step 228 is performed and the function to perform the second level index process is invoked.
- step 230 is performed. At step 230 a check is made to determine if the record is a contention record. If it is a contention record then step 232 is performed and the function to perform the contention record process is invoked. Again, once the process returns control, a loop is made back up to step 222 . If the record is not a contention record then step 234 is performed and the perform user record process is invoked. When the control returns to step 234 , a loop is made back up to step 222 .
- step 218 a key value has been inserted into the hash pool data structure and a new storage record containing user data has been created and tied to the key value. If the key value is a duplicate then an error message stating that the key value was found is created and the key value is not inserted.
- FIG. 3 depicts an exemplary process for inserting a record into a second level index data structure. It is invoked by step 228 in FIG. 2 and the process is entered at step 302 .
- the second level index record is accessed at the slot pointed to by the level two index record off-set 110 as calculated by the index location function 108 .
- a check is made to determine if the slot is empty. If the slot is empty then the key value and associated storage address can be inserted in the slot and step 308 is performed to start this process.
- step 308 a new data record is allocated and the new data record is populated with the user data. Then, step 310 is performed and the address of the new data record is entered into the slot.
- step 312 the next_record variable is set to zero to signal to the calling program that the record has been inserted and that processing is complete.
- the process then returns at step 316 to the calling program in FIG. 1 .
- step 314 is performed if the slot is not empty as determined at step 306 .
- step 314 is performed if the index slot contains an address and therefore is not available for inserting the new data key.
- the next-record variable is set to the address contained in the slot and processing control is returned at step 316 to the calling program in FIG. 1 .
- FIG. 4 depicts an exemplary process for inserting a record into a contention record data structure.
- the process is entered at step 402 when it is called by step 232 in FIG. 2 .
- the contention record is scanned to see if it already contains the key value. If the key value is found, as determined at step 406 , a message telling of the duplicate key is created and sent to the calling program or system user. Then, at step 410 , the next_record variable is set to zero and the processing control is returned to the calling program at step 412 . If, at step 406 it is determined that the key value does not exist in this contention record, step 414 is performed. Step 414 determines if the contention record is chained to another contention record. If the contention record is chained to another contention record step 416 is performed. At step 416 the address of the next contention record in the chain is entered into the variable next_record and control is returned to the calling program at step 418 .
- step 420 is performed.
- Step 420 is used to determine if the contention record contains an empty slot for entering the key value and data record address. If the contention record is full and does not contain an empty slot then step 430 is performed.
- step 430 a new contention record is allocated and chained to the previous contention record. The new contention record is labeled as a contention record.
- processing continues with step 422 . If the contention record is not full, as determined at step 420 , then step 420 is skipped and processing continues with step 422 .
- a new data record is allocated and the new data record is populated with the user data associated with the key value. Then, at step 424 , the address of the new data record and key value are entered into the next empty slot in the contention record.
- the next_record variable is set to zero at step 426 and processing control is returned to the calling program at step 428 .
- FIG. 5 depicts an exemplary process for inserting a record into a user record data structure.
- the process is entered at step 502 when it is called by step 234 in FIG. 2 .
- a determination is made, based on factors that include data load and data distribution, to insert the record as another user record data structure in a chain, to create a level two index record, or to create a contention record.
- the chain of user records are retrieved and scanned, looking for the key value and counting the number of entries or depth of the chain. In an exemplary embodiment the chain will contain one, two or three records.
- step 506 a message is sent about the attempt to insert a duplicate key and that the record was found and processing continues at step 526 .
- step 510 is performed.
- step 510 a new data record is allocated and the new data record is populated with the user data associated with the key value.
- Step 512 checks to see if the chain depth is three or more. If the current chain depth is one or two, step 514 is performed and the new record is added to the end of the current chain. Processing then continues at step 526 .
- the current chain could be put in order in terms of frequency of access or it could be ordered alphabetically.
- Step 516 determines if the key values are dispersed and if the maximum number of index levels, two in this example, have already been reached.
- the key values are dispersed if all four contain different values for their level two index record off-set 110 as determined by the index location function 108 . If the four values are distinct then the keys are determined to be dispersed and step 522 is performed. In this case it makes sense to create a level two index, if one does not already exist, because the key values will point to different slots in the index and cut back on the number of I/O operations required to access the user data record.
- the chain is converted to a level two index record.
- a new level two index record is allocated and the address of the new index record is entered into the slot corresponding to the key value in the level one index record.
- the key values from the chain and addresses of the associated data records are entered into the level two index record slots as determined by the level two index record off-set 110 and the records are re-chained from each other.
- the new level two index record is labeled as a level two index record.
- the address of the new data record and the key value are entered into the slot in the level two index table corresponding to the level two index record off-set 110 as determined by the index location function 108 . Processing then continues with step 526 .
- step 518 converts the chain to a contention record. A new contention record is allocated and the address of the new contention record is entered into the slot corresponding to the key value in the level one or level two index record. The new contention record is labeled as a contention record.
- step 520 The key values from the chain and addresses of the associated data records are entered into the contention record slots.
- step 520 the address of the new data record and the associated key value are entered into an empty slot of the new contention record.
- step 526 the next-record variable is set to zero because one of two things has happened in the process described in FIG. 5 . Either the new user record has been inserted or a duplicate key has been found. In both cases processing of the new record is complete.
- step 528 control is passed back to the calling program in FIG. 2 .
- Each implementation may select a particular maximum chain depth based on factors that include where the index records are stored and the importance of high speed I/O operations.
- a chain depth of three or less can be used in an exemplary embodiment, where all the records are stored on DASD, there are two levels of index records available, and each record holds five-hundred storage addresses. It is at this point in an exemplary embodiment, where the fourth record is chained to the linked list, that the average number of I/O operations involved in chaining becomes higher than the average number of I/O operations if contention records or level two indexes are utilized. This number at which chaining becomes less efficient is implementation specific and can be adjusted based on the requirements of a specific implementation.
- the determination of what constitutes dispersion can also vary between implementations.
- the level two index record off-sets 110 associated with the three key values in the chain and the new key value being inserted are compared. If any of the level two index record off-sets 110 are the same a determination is made that the key values are not dispersed. Adding a level two index record would not result in eliminating I/O operations for each of the key values. Therefore, in an exemplary embodiment a level two index record would not be added in this case.
- other determinations, based on implementation factors, and trade-offs between I/O operations and storage space can be made.
- the disclosed invention describes the process of inserting a new key value and associated user data into a hash pool data structure.
- the resulting structure can be used to locate a particular user record given a key value using methods that are known in the art.
- methods that are known in the art can be utilized to delete and consolidate remaining records. These methods can include remove from chain, remove from contention record, and remove from second level index. They can also include methods that reverse the tasks including: removing a contention record when only two entries remain, and building a chain from the remaining two entries. Similar methods are available for the second level index.
- the disclosed invention can handle extremely large hash tables. These hash tables are so large that associative tables, such as those in linear hashing are too large to be held in main memory.
- the disclosed invention uses an index, stored on DASD, that adds one I/O operation but increases the size of the hash space that is possible to address.
- the hash pool data structures can all be stored on DASD. Therefore, accessing a level one index table requires one I/O operation.
- the use of the hash function along with an index location function removes the requirement for the entire hash table to be segmented in order to be stored on DASD.
- the disclosed invention utilizes a technique of taking the ordinal returned from the hash function and using it as input into the index location function.
- the hash table is not in local memory but is distributed among several DASD volumes and can therefore be extremely large.
- the hash function and index location function are compute intensive and do not require additional I/O operations in order to determine the ordinal or index location of a particular key value.
- the disclosed invention also eliminates the need for special case hash table management functions that require paging and other overhead requirements associated with a segmented hash table.
- the use of one or more layers of index records that can be added dynamically reduces the DASD requirement for unused hash entries.
- the trade-off is that each index record layer adds an additional I/O operation.
- the hash pool data structure described in the disclosed invention can be built dynamically as the hash table fills up.
- the present invention can be embodied in the form of computer-implemented processes and apparatuses for practicing those processes.
- the present invention can also be embodied in the form of computer program code containing instructions embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other computer-readable medium, wherein, when the computer program code is loaded into and executed by a computer, the computer becomes an apparatus for practicing the invention.
- the present invention can also be embodied in the form of computer program code, for example, whether stored in a storage medium, loaded into and/or executed by a computer or transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via electromagnetic radiation, wherein, when the computer program code is loaded into and executed by a computer, the computer becomes an apparatus for practicing the invention.
- the computer program code segments configure the microprocessor to create specific logic circuits.
Abstract
Description
Claims (20)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/974,977 US6748401B2 (en) | 2001-10-11 | 2001-10-11 | Method and system for dynamically managing hash pool data structures |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/974,977 US6748401B2 (en) | 2001-10-11 | 2001-10-11 | Method and system for dynamically managing hash pool data structures |
Publications (2)
Publication Number | Publication Date |
---|---|
US20030074341A1 US20030074341A1 (en) | 2003-04-17 |
US6748401B2 true US6748401B2 (en) | 2004-06-08 |
Family
ID=25522577
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/974,977 Expired - Fee Related US6748401B2 (en) | 2001-10-11 | 2001-10-11 | Method and system for dynamically managing hash pool data structures |
Country Status (1)
Country | Link |
---|---|
US (1) | US6748401B2 (en) |
Cited By (13)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20070143352A1 (en) * | 2005-12-21 | 2007-06-21 | International Business Machines Corporation | Method and system for implementing database migration using a staged approach |
US20090019038A1 (en) * | 2006-01-10 | 2009-01-15 | Millett Ronald P | Pattern index |
US20090064042A1 (en) * | 2007-08-30 | 2009-03-05 | Perfect Search Corporation | Indexing and filtering using composite data stores |
US20090063479A1 (en) * | 2007-08-30 | 2009-03-05 | Perfect Search Corporation | Search templates |
US20090063454A1 (en) * | 2007-08-30 | 2009-03-05 | Perfect Search Corporation | Vortex searching |
US7624229B1 (en) * | 2006-09-29 | 2009-11-24 | Emc Corporation | Spillover slot |
US20090307184A1 (en) * | 2006-03-03 | 2009-12-10 | Inouye Dillon K | Hyperspace Index |
US20090319549A1 (en) * | 2008-06-20 | 2009-12-24 | Perfect Search Corporation | Index compression |
US7844731B1 (en) * | 2003-11-14 | 2010-11-30 | Symantec Corporation | Systems and methods for address spacing in a firewall cluster |
US20110264687A1 (en) * | 2010-04-23 | 2011-10-27 | Red Hat, Inc. | Concurrent linked hashed maps |
US9444786B2 (en) | 2005-04-19 | 2016-09-13 | Servicenow, Inc. | Policy based auditing of workflows |
CN106874329A (en) * | 2016-07-15 | 2017-06-20 | 阿里巴巴集团控股有限公司 | The implementation method and device of database table index |
US11200217B2 (en) | 2016-05-26 | 2021-12-14 | Perfect Search Corporation | Structured document indexing and searching |
Families Citing this family (12)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8266152B2 (en) * | 2006-03-03 | 2012-09-11 | Perfect Search Corporation | Hashed indexing |
US20080065618A1 (en) * | 2006-07-25 | 2008-03-13 | Maluf David A | Indexing for rapid database searching |
US8180744B2 (en) * | 2008-03-05 | 2012-05-15 | Hewlett-Packard Development Company, L.P. | Managing storage of data in a data structure |
US8225100B2 (en) * | 2008-10-31 | 2012-07-17 | Apple Inc. | Hash functions using recurrency and arithmetic |
WO2013044502A1 (en) * | 2011-09-30 | 2013-04-04 | 华为技术有限公司 | Data management method and device |
WO2013075306A1 (en) * | 2011-11-24 | 2013-05-30 | 华为技术有限公司 | Data access method and device |
CN102663090B (en) | 2012-04-10 | 2013-11-06 | 华为技术有限公司 | Method and device for inquiry metadata |
RU2015125383A (en) * | 2015-06-29 | 2017-01-10 | Общество С Ограниченной Ответственностью "Яндекс" | METHOD AND SYSTEM FOR UPDATING THE DATA TABLE |
RU2632133C2 (en) | 2015-09-29 | 2017-10-02 | Общество С Ограниченной Ответственностью "Яндекс" | Method (versions) and system (versions) for creating prediction model and determining prediction model accuracy |
CN105550345B (en) * | 2015-12-25 | 2019-03-26 | 百度在线网络技术（北京）有限公司 | File operation method and device |
RU2693324C2 (en) * | 2017-11-24 | 2019-07-02 | Общество С Ограниченной Ответственностью "Яндекс" | Method and a server for converting a categorical factor value into its numerical representation |
US11797508B1 (en) * | 2023-06-02 | 2023-10-24 | Black Cape Inc. | Systems and methods for geospatial correlation |
Citations (18)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP0066766A2 (en) | 1981-06-05 | 1982-12-15 | International Business Machines Corporation | I/O controller with a dynamically adjustable cache memory |
US5276878A (en) * | 1992-10-07 | 1994-01-04 | International Business Machines Corporation | Method and system for task memory management in a multi-tasking data processing system |
US5410663A (en) * | 1992-10-15 | 1995-04-25 | International Business Machines Corporation | Method and system for cache memory congruence class management in a data processing system |
US5604879A (en) * | 1994-04-04 | 1997-02-18 | Motorola Inc. | Single array address translator with segment and page invalidate ability and method of operation |
US5809494A (en) | 1995-11-16 | 1998-09-15 | Applied Language Technologies, Inc. | Method for rapidly and efficiently hashing records of large databases |
US5893086A (en) | 1997-07-11 | 1999-04-06 | International Business Machines Corporation | Parallel file system and method with extensible hashing |
US5911144A (en) | 1997-04-23 | 1999-06-08 | Sun Microsystems, Inc. | Method and apparatus for optimizing the assignment of hash values to nodes residing in a garbage collected heap |
US6014733A (en) | 1997-06-05 | 2000-01-11 | Microsoft Corporation | Method and system for creating a perfect hash using an offset table |
US6067547A (en) | 1997-08-12 | 2000-05-23 | Microsoft Corporation | Hash table expansion and contraction for use with internal searching |
US6115802A (en) | 1995-10-13 | 2000-09-05 | Sun Mircrosystems, Inc. | Efficient hash table for use in multi-threaded environments |
US6122375A (en) | 1996-12-10 | 2000-09-19 | Hitachi, Ltd. | Hash value generating method and device, data encryption method and device, data decryption method and device |
US6212525B1 (en) | 1997-03-07 | 2001-04-03 | Apple Computer, Inc. | Hash-based system and method with primary and secondary hash functions for rapidly identifying the existence and location of an item in a file |
US6216214B1 (en) | 1996-11-12 | 2001-04-10 | Institute For The Development Of Emerging Architectures, L.L.C. | Apparatus and method for a virtual hashed page table |
US6226639B1 (en) | 1998-09-22 | 2001-05-01 | International Business Machines Corporation | System and method for hybrid hash join using over-partitioning to respond to database query |
US6226629B1 (en) | 1997-02-28 | 2001-05-01 | Compaq Computer Corporation | Method and apparatus determining and using hash functions and hash values |
US6230231B1 (en) | 1998-03-19 | 2001-05-08 | 3Com Corporation | Hash equation for MAC addresses that supports cache entry tagging and virtual address tables |
US6516320B1 (en) * | 1999-03-08 | 2003-02-04 | Pliant Technologies, Inc. | Tiered hashing for data access |
US6630946B2 (en) * | 1999-11-10 | 2003-10-07 | Symantec Corporation | Methods for automatically locating data-containing windows in frozen applications program and saving contents |
-
2001
- 2001-10-11 US US09/974,977 patent/US6748401B2/en not_active Expired - Fee Related
Patent Citations (19)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP0066766B1 (en) | 1981-06-05 | 1988-08-10 | International Business Machines Corporation | I/o controller with a dynamically adjustable cache memory |
EP0066766A2 (en) | 1981-06-05 | 1982-12-15 | International Business Machines Corporation | I/O controller with a dynamically adjustable cache memory |
US5276878A (en) * | 1992-10-07 | 1994-01-04 | International Business Machines Corporation | Method and system for task memory management in a multi-tasking data processing system |
US5410663A (en) * | 1992-10-15 | 1995-04-25 | International Business Machines Corporation | Method and system for cache memory congruence class management in a data processing system |
US5604879A (en) * | 1994-04-04 | 1997-02-18 | Motorola Inc. | Single array address translator with segment and page invalidate ability and method of operation |
US6115802A (en) | 1995-10-13 | 2000-09-05 | Sun Mircrosystems, Inc. | Efficient hash table for use in multi-threaded environments |
US5809494A (en) | 1995-11-16 | 1998-09-15 | Applied Language Technologies, Inc. | Method for rapidly and efficiently hashing records of large databases |
US6216214B1 (en) | 1996-11-12 | 2001-04-10 | Institute For The Development Of Emerging Architectures, L.L.C. | Apparatus and method for a virtual hashed page table |
US6122375A (en) | 1996-12-10 | 2000-09-19 | Hitachi, Ltd. | Hash value generating method and device, data encryption method and device, data decryption method and device |
US6226629B1 (en) | 1997-02-28 | 2001-05-01 | Compaq Computer Corporation | Method and apparatus determining and using hash functions and hash values |
US6212525B1 (en) | 1997-03-07 | 2001-04-03 | Apple Computer, Inc. | Hash-based system and method with primary and secondary hash functions for rapidly identifying the existence and location of an item in a file |
US5911144A (en) | 1997-04-23 | 1999-06-08 | Sun Microsystems, Inc. | Method and apparatus for optimizing the assignment of hash values to nodes residing in a garbage collected heap |
US6014733A (en) | 1997-06-05 | 2000-01-11 | Microsoft Corporation | Method and system for creating a perfect hash using an offset table |
US5893086A (en) | 1997-07-11 | 1999-04-06 | International Business Machines Corporation | Parallel file system and method with extensible hashing |
US6067547A (en) | 1997-08-12 | 2000-05-23 | Microsoft Corporation | Hash table expansion and contraction for use with internal searching |
US6230231B1 (en) | 1998-03-19 | 2001-05-08 | 3Com Corporation | Hash equation for MAC addresses that supports cache entry tagging and virtual address tables |
US6226639B1 (en) | 1998-09-22 | 2001-05-01 | International Business Machines Corporation | System and method for hybrid hash join using over-partitioning to respond to database query |
US6516320B1 (en) * | 1999-03-08 | 2003-02-04 | Pliant Technologies, Inc. | Tiered hashing for data access |
US6630946B2 (en) * | 1999-11-10 | 2003-10-07 | Symantec Corporation | Methods for automatically locating data-containing windows in frozen applications program and saving contents |
Non-Patent Citations (8)
Title |
---|
Title: "Climbing Hashing for Expansible Files", Published by: Information Sciences, vol. 86, No. 1-3, pp. 77-99, Sep. 1995, Authors: Ye-In Chang, Chien-I Lee. |
Title: "Evaluation of Associative Memory Using Parellel Chained Hashing", Published by: IEEE Transactions on Computers, vol. C-33, No. 9, pp. 851-855, Sep. 1984, Auther: Kei Hiraki, Kenji Nishida, and Toshio Smimada. |
Title: "Extendible Chained Bucket Hashing for Main Memory Databases"; Published by: International Journal of Applied Software Technology, vol. 1, No. 2, pp. 123-125; Author: Pyung-Chul Kim, Kee-Wook Rim, Jin-Pyo Hong. |
Title: "Linear Hashing with Overflow-Handling by Linear Probing", Published by; ACM Transactions on Database Systems, vol. 10, No. 1, pp. 75-89, Mar. 1985, A04, Author: Per-Ake Larson. |
Title: "Linear Hashing with Separators- A Dynamic Hashing Scheme Achieving One-Access Retrieval", Published by: ACM Transactions on Database Systems, vol. 13, No. 3, pp. 366-388, Sep. 1988, Author: Per-Ake Larson. |
Title: "Linear Hashing: A New Tool For File And Table Addressing", Published by: IEEE Computer Society, Very Large Data Bases. Proceedings of the Sixth International Conference, pp. 212-223, 1980, Author: Witold Litwin. |
Title: "Linear Spiral Hashing for Expansible Files", Published by: IEEE Transactions on Knowledge and Data Engineering, vol. 11, No. 6, pp. 969-984, Nov./Dec. 1999, Authors: Ye-In Chang, Chien I Lee, Wann-Bay ChangLiaw. |
Title: "Multikey, Extensible Hashing for Relational Database", Published by: IEEE Software, vol. 5, No. 4, pp. 77-85, Jul. 1988, Authors: Keith L. Kelley and Marek Rusinkiewicz. |
Cited By (22)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7844731B1 (en) * | 2003-11-14 | 2010-11-30 | Symantec Corporation | Systems and methods for address spacing in a firewall cluster |
US9444786B2 (en) | 2005-04-19 | 2016-09-13 | Servicenow, Inc. | Policy based auditing of workflows |
US20070143352A1 (en) * | 2005-12-21 | 2007-06-21 | International Business Machines Corporation | Method and system for implementing database migration using a staged approach |
US20090019038A1 (en) * | 2006-01-10 | 2009-01-15 | Millett Ronald P | Pattern index |
US8037075B2 (en) | 2006-01-10 | 2011-10-11 | Perfect Search Corporation | Pattern index |
US8176052B2 (en) | 2006-03-03 | 2012-05-08 | Perfect Search Corporation | Hyperspace index |
US20090307184A1 (en) * | 2006-03-03 | 2009-12-10 | Inouye Dillon K | Hyperspace Index |
US7624229B1 (en) * | 2006-09-29 | 2009-11-24 | Emc Corporation | Spillover slot |
US20090063454A1 (en) * | 2007-08-30 | 2009-03-05 | Perfect Search Corporation | Vortex searching |
US7774347B2 (en) | 2007-08-30 | 2010-08-10 | Perfect Search Corporation | Vortex searching |
US20090064042A1 (en) * | 2007-08-30 | 2009-03-05 | Perfect Search Corporation | Indexing and filtering using composite data stores |
US7912840B2 (en) | 2007-08-30 | 2011-03-22 | Perfect Search Corporation | Indexing and filtering using composite data stores |
US20110167072A1 (en) * | 2007-08-30 | 2011-07-07 | Perfect Search Corporation | Indexing and filtering using composite data stores |
US20090063479A1 (en) * | 2007-08-30 | 2009-03-05 | Perfect Search Corporation | Search templates |
US7774353B2 (en) | 2007-08-30 | 2010-08-10 | Perfect Search Corporation | Search templates |
US8392426B2 (en) | 2007-08-30 | 2013-03-05 | Perfect Search Corporation | Indexing and filtering using composite data stores |
US8032495B2 (en) | 2008-06-20 | 2011-10-04 | Perfect Search Corporation | Index compression |
US20090319549A1 (en) * | 2008-06-20 | 2009-12-24 | Perfect Search Corporation | Index compression |
US8719307B2 (en) * | 2010-04-23 | 2014-05-06 | Red Hat, Inc. | Concurrent linked hashed maps |
US20110264687A1 (en) * | 2010-04-23 | 2011-10-27 | Red Hat, Inc. | Concurrent linked hashed maps |
US11200217B2 (en) | 2016-05-26 | 2021-12-14 | Perfect Search Corporation | Structured document indexing and searching |
CN106874329A (en) * | 2016-07-15 | 2017-06-20 | 阿里巴巴集团控股有限公司 | The implementation method and device of database table index |
Also Published As
Publication number | Publication date |
---|---|
US20030074341A1 (en) | 2003-04-17 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6748401B2 (en) | Method and system for dynamically managing hash pool data structures | |
Broder et al. | Using multiple hash functions to improve IP lookups | |
US5960431A (en) | Method and apparatus for adding data storage bins to a stored computer database while minimizing movement of data and balancing data distribution | |
US6115705A (en) | Relational database system and method for query processing using early aggregation | |
US7664927B2 (en) | Hash tables | |
US5664179A (en) | Modified skip list database structure and method for access | |
US6668263B1 (en) | Method and system for efficiently searching for free space in a table of a relational database having a clustering index | |
US5692177A (en) | Method and system for data set storage by iteratively searching for perfect hashing functions | |
KR100971863B1 (en) | System and method for batched indexing of network documents | |
US6751627B2 (en) | Method and apparatus to facilitate accessing data in network management protocol tables | |
US7590625B1 (en) | Method and system for network load balancing with a compound data structure | |
US6247014B1 (en) | Method and apparatus for performing hash lookups using valid bit tables with pointers | |
US6625612B1 (en) | Deterministic search algorithm | |
EP1211612A2 (en) | A data structure and storage and retrieval method supporting ordinality based searching and data retrieval | |
US5307494A (en) | File name length augmentation method | |
US20040128463A1 (en) | Apparatus and method for controlling memory allocation for variable size packets | |
US7613669B2 (en) | Method and apparatus for storing pattern matching data and pattern matching method using the same | |
US20100030994A1 (en) | Methods, systems, and computer readable media for memory allocation and deallocation | |
JP2769065B2 (en) | Method and apparatus for use in a digital data processing system | |
Pibiri et al. | PTHash: Revisiting FCH minimal perfect hashing | |
US6065005A (en) | Data sorting | |
US6625592B1 (en) | System and method for hash scanning of shared memory interfaces | |
US8719274B1 (en) | Method, system, and apparatus for providing generic database services within an extensible firmware interface environment | |
US6233574B1 (en) | Method and apparatus for performing radix lookups using transition tables with pointers | |
US7031971B1 (en) | Lock-free handle resolution |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:BLACKBURN, ROBERT A.;DRYFOOS, ROBERT O.;FISHER, GARY A., SR.;AND OTHERS;REEL/FRAME:012255/0255Effective date: 20011009 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026894/0001Effective date: 20110817 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
REMI | Maintenance fee reminder mailed | ||
LAPS | Lapse for failure to pay maintenance fees | ||
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20160608 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044144/0001Effective date: 20170929 |