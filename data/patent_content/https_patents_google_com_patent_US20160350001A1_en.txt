US20160350001A1 - Consistent, disk-backed arrays - Google Patents
Consistent, disk-backed arrays Download PDFInfo
- Publication number
- US20160350001A1 US20160350001A1 US15/233,021 US201615233021A US2016350001A1 US 20160350001 A1 US20160350001 A1 US 20160350001A1 US 201615233021 A US201615233021 A US 201615233021A US 2016350001 A1 US2016350001 A1 US 2016350001A1
- Authority
- US
- United States
- Prior art keywords
- array
- volatile storage
- computing device
- specified bit
- changes
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0602—Interfaces specially adapted for storage systems specifically adapted to achieve a particular effect
- G06F3/0604—Improving or facilitating administration, e.g. storage management
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/07—Responding to the occurrence of a fault, e.g. fault tolerance
- G06F11/08—Error detection or correction by redundancy in data representation, e.g. by using checking codes
- G06F11/10—Adding special bits or symbols to the coded information, e.g. parity check, casting out 9's or 11's
- G06F11/1004—Adding special bits or symbols to the coded information, e.g. parity check, casting out 9's or 11's to protect a block of data words, e.g. CRC or checksum
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2228—Indexing structures
- G06F16/2237—Vectors, bitmaps or matrices
-
- G06F17/30324—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0628—Interfaces specially adapted for storage systems making use of a particular technique
- G06F3/0638—Organizing or formatting or addressing of data
- G06F3/0644—Management of space entities, e.g. partitions, extents, pools
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0628—Interfaces specially adapted for storage systems making use of a particular technique
- G06F3/0646—Horizontal data movement in storage systems, i.e. moving data in between storage devices or systems
- G06F3/0647—Migration mechanisms
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0668—Interfaces specially adapted for storage systems adopting a particular infrastructure
- G06F3/0671—In-line storage system
- G06F3/0673—Single storage device
Definitions
- the present disclosure relates to consistent disk-backed arrays.
- An array is a data structure consisting of a collection of elements (values or variables), each of which is identified by at least one array index or key. Arrays are sometimes used to implement tables, such as look-up tables. Many software programs use arrays, which also can be used to implement other data structures, such as lists, strings and tries.
- an array In general, it is desirable for an array to be persistent such that the data in the array remains valid even if power is removed from the device storing the array. For this reason, arrays often are stored on disk (e.g., flash memory). However, some arrays are mutable, such that the data structure can be updated, for example, to include additional elements. In such situations, the data in the array between transactions (e.g., between updates) may contain inconsistent states and, therefore, may contain errors.
- the present disclosure describes disk-backed array techniques that can, in some implementations, help ensure that the arrays contain consistent data.
- An alert can be provided if it is determined that the data in the array is, or may be, corrupted.
- one aspect describes a method of managing changes to an array in non-volatile storage of a computing device.
- the method includes storing, in random access or other volatile memory of the computing device, information indicative of changes to be made to the array.
- a pre-specified bit in the non-volatile storage that is associated with the array is set, for example, in response to a user request (e.g., after a batch of changes are made to the array).
- a request is received in the computing device to carry over to the non-volatile storage the changes indicated by the information stored in the random access or other volatile memory, and a request is received in the computing device to clear the pre-specified bit.
- the method includes subsequently checking whether the pre-specified bit has been cleared, and determining, based on results of the checking, whether data in the array in the non-volatile storage is, or may be, corrupted.
- checking whether the pre-specified bit has been cleared and determining whether data in the array in the non-volatile storage is corrupted is performed after power is restored to the computing device following a power loss.
- an alert can be provided. For example, in some cases, providing an alert includes providing a message in the computing device indicating the presence of possibly corrupted data in the array in the non-volatile storage.
- a method of managing changes to an array in non-volatile storage includes storing, in volatile memory, a mapping of the array that is in non-volatile storage. Requested modifications are made to one or more sections of the array as stored in the volatile memory. Original, unmodified values of the array corresponding to the modified sections may be stored in the volatile memory as well. The method also includes computing a cyclic redundancy check (CRC) value for the entire array as modified, and writing the one or more modified sections of the array and the CRC value to the non-volatile storage.
- CRC cyclic redundancy check
- Some implementations can include subsequently computing a new CRC value for the entire array as stored in the non-volatile storage and comparing the new CRC value to the CRC value previously written to the non-volatile storage. A determination can be made as to whether data in the array in the non-volatile storage is corrupted based on the comparison.
- Various techniques can be used to compute a CRC value for the modified array stored in non-volatile memory.
- the CRC value can be updated incrementally, rather than computing a new CRC for the entire modified array each time. Updating the CRC value incrementally can be based, at least in part, on using the original, unmodified values of the array stored in the volatile memory.
- the original, unmodified values of the array are maintained in the volatile memory only up to a predetermined constant fraction of the array size, and the CRC value is updated incrementally only if a changed area of the array is less than the predetermined constant fraction of the array size.
- the disclosure also describes computing devices, such as mobile phones and the like, that store a mutable array in non-volatile memory and which can be managed using the foregoing techniques.
- Performing various processing tasks on data stored in the volatile memory can increase overall processing speed for updating and incorporating changes to the array(s), while also reducing the likelihood of inconsistent data being present in the array(s) in the non-volatile storage.
- a particular example of an application for the disclosed techniques is in connection with a mutable trie structure that is composed of multiple arrays.
- the trie can be used, for example, for searching files locally on a mobile phone or other computing device.
- the disclosed techniques can help ensure that as the arrays in the trie structure are updated, the data stored in non-volatile memory remains consistent. If the data becomes (or appears to be) corrupted, an alert can be provided.
- the techniques also can be used in other applications.
- FIG. 1 illustrates an example of an array.
- FIG. 2 is a block diagram of an example of a computing device that stores the array.
- FIG. 3 illustrates a first implementation of how changes to an array are managed.
- FIG. 4 is a flow chart illustrating a first method of managing changes to the array.
- FIG. 5 illustrates a second implementation of how changes to an array are managed.
- FIG. 6 is a flow chart illustrating a second method of managing changes to the array.
- FIG. 7 is a flow chart illustrating a method of reading data from the array.
- FIG. 1 shows an example of an array 20 .
- Array 20 can be stored, for example, in a non-volatile, or persistent, storage medium 102 , such as disk or flash memory, on a mobile phone or other computing device 100 (see FIG. 2 ).
- the non-volatile storage medium 102 retains data and information stored thereon even if power is removed from the device. Power loss may be intentional (e.g., a device reboot or shutdown) or accidental (e.g., a power failure).
- the computing device 100 also may include other components such as volatile memory (e.g., random access memory (RAM)) 104 , read-only memory (ROM) 106 that stores the device's operating system 108 and other software instructions, a processor 110 , a user interface 112 (including, e.g., input/output keys 114 , a touch screen 116 , and a display 118 ), a battery or other power source 120 and a transceiver 122 .
- volatile memory e.g., random access memory (RAM)
- ROM read-only memory
- array 20 contains multiple elements 22 .
- array 20 can be part of a data structure that can be searched.
- Array 20 can be used, for example, in connection with a key value look-up table on a computing device.
- array 20 can be updated dynamically to incorporate new elements 22 or to change the contents of existing elements.
- the device operates according to a private mode, in which the kernel (i.e., the operating system) obtains a bitmap of the portions(s) of the underlying file of array 20 that is being modified (see FIG. 3 ).
- the bitmap is stored in RAM 104 , and when an attempt is made to write to the array 20 , changes are made to the bitmap in RAM 104 , rather than to the array stored in disk 102 ( FIG. 4 , block 202 ).
- 4-kbyte sections of the array 20 are stored in RAM 104 corresponding to the section(s) of the array being modified.
- a user can call a Flush function with respect to the array (block 204 ).
- Calling the Flush function causes the processor 110 to set a special bit 124 that is stored in disk 102 and that is associated with the particular array 20 being modified (block 206 ).
- the special bit 124 may be referred to as a “corrupt data indicator” bit, for reasons that will become evident below, and can be located, for example, at the end of the disk space.
- the kernel's Sync to Disk function is called (block 208 ). Changes that were made with respect to the bitmap in RAM 104 then are carried over to array 20 that is stored on disk 102 (see FIG. 3 , and block 210 of FIG.
- the kernel's Sync to Disk function writes any data buffered in memory 104 to disk 102 and synchronizes disk 102 .
- the kernel can receive confirmation when the Sync to Disk function is returned.
- the kernel clears the “corrupt data indicator” bit 124 and synchronizes disk 102 (block 214 ), and the kernel's Sync to Disk function is called again (block 216 ).
- the kernel discards the bitmap previously stored in RAM 104 (block 218 ). A new bitmap then can be initiated in RAM 104 so as to track any additional changes to the array.
- the data stored in the array 20 on disk 102 can be considered valid up until the last time the Flush function was called.
- a crash i.e., a condition where a processor or a program, either an application or part of the operating system, ceases to function properly
- the data stored in the array 20 on disk 102 can be considered valid up until the last time the Flush function was called.
- changes to the array 20 initially are made only in RAM 104 , data stored in the array can be considered valid up until the last time the Flush function was called.
- the second technique uses check pointing, without disk synchronization.
- the file storing the array 20 that is being modified is stored in a shared mode, in which it is assumed that changes made in RAM 104 will be reflected in the file on disk 101 .
- the timing of carrying over the changes to disk 102 is handled by the operating system 108 at a time of its own choosing and can be optimized, for example, in accordance with other system operations.
- the kernel can store in RAM 104 a mapping 302 of the underlying file for the array (including any changes that are made to the array), and also can store the original values 304 of the modified sections of the array (i.e., prior to the modifications) (see also FIG. 6 , block 402 ).
- the original values of the array are maintained in RAM 104 only up to a predetermined constant fraction “k” (e.g., 20%) of the array size.
- the Checkpoint function computes a cyclic redundancy check (CRC) value for the array as modified (block 406 ), and stores the computed CRC value 306 is stored in RAM 104 (block 408 ).
- the CRC value can be computed as discussed in greater detail below, which also describes an advantage of maintaining the original values of the array in RAM 104 .
- Changes to array 20 and to the CRC value are carried over to disk 102 based on the memory mapping (block 410 ).
- operating system 108 can carry over the information to disk 20 at a time selected, for example, to optimize overall system performance.
- the CRC value can be written and stored, for example, in four bytes at the end of the array file on disk 102 .
- the program executed by processor 110 when the program executed by processor 110 returns and reads data from the array 20 on disk 102 , the program computes a CRC value for the entire array as stored on the disk, and compares the newly computed CRC value to the CRC value previously-stored in disk 102 (bock 414 ). If the newly computed value equals the CRC value stored in the file on disk 102 , then the data stored in the array on disk 102 is valid (block 416 ). On the other hand, if the newly computed value does not equal the CRC value stored in the file on disk 102 , then the data stored in the array on disk 102 is not valid and may be corrupted (block 418 ).
- a message can be provided automatically as an alert regarding the presence of possibly corrupted data in the particular file on disk 102 .
- One approach to calculating the CRC value for the array data stored in RAM 104 is to recalculate the CRC value for the entire array each time the Checkpoint function is called. Although such an approach can be used, it can be very time consuming. For example, if array 20 has size N and the Checkpoint function is called N/K times in fixed chunks of size K, then the total number of operations required to execute the CRCs is on the order of N 2 .
- An alternative approach makes use of the original values 304 of the array stored in RAM 104 and allows the CRC value to be updated incrementally, rather than re-computing a new CRC value for the entire array every time.
- the CRC value is computed (in block 404 ) using the foregoing incremental updating technique if the changed area of the array is less than the predetermined constant fraction of the array size “k” (e.g., 20%).
- k the predetermined constant fraction of the array size “e.g. 20%”.
- array 20 may be modified by appending new data to the array rather than changing existing elements in the array.
- an updated CRC value for the array as modified can be computed by obtaining a CRC value for the newly added elements in the array, and then adding this CRC value to the CRC value previously obtained for the array prior to its modification.
- CRC u (M; v) v′ 2 .
- a pointer can be used to point to the last byte in the array touched by the user.
- the foregoing techniques can be implemented, for example, on various types of handheld computing devices, such as mobile phones, tablets, personal digital assistants (PDAs), as well as desk top personal computers, laptop computers, and other computing devices.
- handheld computing devices such as mobile phones, tablets, personal digital assistants (PDAs), as well as desk top personal computers, laptop computers, and other computing devices.
- PDAs personal digital assistants
- Embodiments of the subject matter described in this specification can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions encoded on a computer readable medium for execution by, or to control the operation of, data processing apparatus.
- the computer readable medium can be a machine-readable storage device, a machine-readable storage substrate, a memory device, a composition of matter effecting a machine-readable propagated signal, or a combination of one or more of them.
- data processing apparatus and “computer” encompasses all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers.
- the apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- a computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.
- a computer program does not necessarily correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code).
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- the processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output.
- the processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
- processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer.
- a processor will receive instructions and data from a read only memory or a random access memory or both.
- the essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks.
- mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks.
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone or other computing device.
- Computer readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks.
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks
- magneto optical disks e.g., CD ROM and DVD-ROM disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
Abstract
Description
- This application is a divisional of U.S. patent application Ser. No. 13/970,075, filed on Aug. 19, 2013, which claims the benefit of U.S. Provisional Application No. 61/753,159, filed on Jan. 16, 2013, the entire contents of which is incorporated by reference.
- The present disclosure relates to consistent disk-backed arrays.
- An array is a data structure consisting of a collection of elements (values or variables), each of which is identified by at least one array index or key. Arrays are sometimes used to implement tables, such as look-up tables. Many software programs use arrays, which also can be used to implement other data structures, such as lists, strings and tries.
- In general, it is desirable for an array to be persistent such that the data in the array remains valid even if power is removed from the device storing the array. For this reason, arrays often are stored on disk (e.g., flash memory). However, some arrays are mutable, such that the data structure can be updated, for example, to include additional elements. In such situations, the data in the array between transactions (e.g., between updates) may contain inconsistent states and, therefore, may contain errors.
- The present disclosure describes disk-backed array techniques that can, in some implementations, help ensure that the arrays contain consistent data. An alert can be provided if it is determined that the data in the array is, or may be, corrupted.
- For example, one aspect describes a method of managing changes to an array in non-volatile storage of a computing device. The method includes storing, in random access or other volatile memory of the computing device, information indicative of changes to be made to the array. A pre-specified bit in the non-volatile storage that is associated with the array is set, for example, in response to a user request (e.g., after a batch of changes are made to the array). A request is received in the computing device to carry over to the non-volatile storage the changes indicated by the information stored in the random access or other volatile memory, and a request is received in the computing device to clear the pre-specified bit.
- In some implementations, the method includes subsequently checking whether the pre-specified bit has been cleared, and determining, based on results of the checking, whether data in the array in the non-volatile storage is, or may be, corrupted. In some implementations, checking whether the pre-specified bit has been cleared and determining whether data in the array in the non-volatile storage is corrupted is performed after power is restored to the computing device following a power loss. In the event that it is determined that the data is or may be corrupted, an alert can be provided. For example, in some cases, providing an alert includes providing a message in the computing device indicating the presence of possibly corrupted data in the array in the non-volatile storage.
- According to another aspect, a method of managing changes to an array in non-volatile storage includes storing, in volatile memory, a mapping of the array that is in non-volatile storage. Requested modifications are made to one or more sections of the array as stored in the volatile memory. Original, unmodified values of the array corresponding to the modified sections may be stored in the volatile memory as well. The method also includes computing a cyclic redundancy check (CRC) value for the entire array as modified, and writing the one or more modified sections of the array and the CRC value to the non-volatile storage.
- Some implementations can include subsequently computing a new CRC value for the entire array as stored in the non-volatile storage and comparing the new CRC value to the CRC value previously written to the non-volatile storage. A determination can be made as to whether data in the array in the non-volatile storage is corrupted based on the comparison.
- Various techniques can be used to compute a CRC value for the modified array stored in non-volatile memory. For example, the CRC value can be updated incrementally, rather than computing a new CRC for the entire modified array each time. Updating the CRC value incrementally can be based, at least in part, on using the original, unmodified values of the array stored in the volatile memory. In some implementations, the original, unmodified values of the array are maintained in the volatile memory only up to a predetermined constant fraction of the array size, and the CRC value is updated incrementally only if a changed area of the array is less than the predetermined constant fraction of the array size.
- The disclosure also describes computing devices, such as mobile phones and the like, that store a mutable array in non-volatile memory and which can be managed using the foregoing techniques.
- Performing various processing tasks on data stored in the volatile memory can increase overall processing speed for updating and incorporating changes to the array(s), while also reducing the likelihood of inconsistent data being present in the array(s) in the non-volatile storage.
- A particular example of an application for the disclosed techniques is in connection with a mutable trie structure that is composed of multiple arrays. The trie can be used, for example, for searching files locally on a mobile phone or other computing device. The disclosed techniques can help ensure that as the arrays in the trie structure are updated, the data stored in non-volatile memory remains consistent. If the data becomes (or appears to be) corrupted, an alert can be provided. The techniques also can be used in other applications.
- Other aspects, features and advantages will be apparent from the following detailed description, the accompanying drawings and the claims.
-
FIG. 1 illustrates an example of an array. -
FIG. 2 is a block diagram of an example of a computing device that stores the array. -
FIG. 3 illustrates a first implementation of how changes to an array are managed. -
FIG. 4 is a flow chart illustrating a first method of managing changes to the array. -
FIG. 5 illustrates a second implementation of how changes to an array are managed. -
FIG. 6 is a flow chart illustrating a second method of managing changes to the array. -
FIG. 7 is a flow chart illustrating a method of reading data from the array. - The techniques described here can be used in connection with various arrays. For the purposes of illustration,
FIG. 1 shows an example of anarray 20.Array 20 can be stored, for example, in a non-volatile, or persistent,storage medium 102, such as disk or flash memory, on a mobile phone or other computing device 100 (seeFIG. 2 ). Thenon-volatile storage medium 102 retains data and information stored thereon even if power is removed from the device. Power loss may be intentional (e.g., a device reboot or shutdown) or accidental (e.g., a power failure). Thecomputing device 100 also may include other components such as volatile memory (e.g., random access memory (RAM)) 104, read-only memory (ROM) 106 that stores the device'soperating system 108 and other software instructions, aprocessor 110, a user interface 112 (including, e.g., input/output keys 114, atouch screen 116, and a display 118), a battery orother power source 120 and atransceiver 122. - As illustrated in
FIG. 1 ,array 20 containsmultiple elements 22. In some implementations,array 20 can be part of a data structure that can be searched.Array 20 can be used, for example, in connection with a key value look-up table on a computing device. In some implementations,array 20 can be updated dynamically to incorporatenew elements 22 or to change the contents of existing elements. - This and the following paragraphs describe a first technique for storing changes to
array 20. In this first technique, the device operates according to a private mode, in which the kernel (i.e., the operating system) obtains a bitmap of the portions(s) of the underlying file ofarray 20 that is being modified (seeFIG. 3 ). The bitmap is stored inRAM 104, and when an attempt is made to write to thearray 20, changes are made to the bitmap inRAM 104, rather than to the array stored in disk 102 (FIG. 4 , block 202). In some implementations, 4-kbyte sections of thearray 20 are stored inRAM 104 corresponding to the section(s) of the array being modified. - After modifications to
array 20 are made and stored by the bitmap inRAM 104, a user can call a Flush function with respect to the array (block 204). Calling the Flush function causes theprocessor 110 to set aspecial bit 124 that is stored indisk 102 and that is associated with theparticular array 20 being modified (block 206). Thespecial bit 124 may be referred to as a “corrupt data indicator” bit, for reasons that will become evident below, and can be located, for example, at the end of the disk space. Next, the kernel's Sync to Disk function is called (block 208). Changes that were made with respect to the bitmap inRAM 104 then are carried over toarray 20 that is stored on disk 102 (seeFIG. 3 , and block 210 ofFIG. 4 ), and the kernel's Sync to Disk function is called again (block 212). In particular, the Sync to Disk function writes any data buffered inmemory 104 todisk 102 and synchronizesdisk 102. The kernel can receive confirmation when the Sync to Disk function is returned. Once the changes to the array are written to the file stored indisk 102, the kernel clears the “corrupt data indicator”bit 124 and synchronizes disk 102 (block 214), and the kernel's Sync to Disk function is called again (block 216). In addition, the kernel discards the bitmap previously stored in RAM 104 (block 218). A new bitmap then can be initiated inRAM 104 so as to track any additional changes to the array. - By using the foregoing technique, in the event that the program executed by
processor 110 is interrupted, for example, as the result of a power loss to thedevice 100 or a crash (i.e., a condition where a processor or a program, either an application or part of the operating system, ceases to function properly), the data stored in thearray 20 ondisk 102 can be considered valid up until the last time the Flush function was called. In other words, since changes to thearray 20 initially are made only inRAM 104, data stored in the array can be considered valid up until the last time the Flush function was called. - An exception can occur if the program is interrupted during execution of the Flush function. In such a situation, it is possible that data stored in the
array 20 ondisk 102 may be corrupted and is not necessarily valid. Nevertheless, the status of the “corrupt data indicator”bit 124 can be used to determine whether the changes to the array were successfully carried over todisk 102. In particular, if the “corrupt data indicator”bit 124 associated with the file for the particular array is still set when power is restored todevice 100, thebit 124 would thus indicate that the file may be corrupted. In some implementations, a message can be provided automatically as an alert regarding the presence of possibly corrupted data in the particular file ondisk 102. On the other hand, if the “corrupt data indicator”bit 124 is clear when power is restored to the device, the bit's status would indicate that the data was successfully written to the array ondisk 102. One advantage to the foregoing technique for storing a mutable array is that, other than during the Flush sequence, the data in the array is more reliably secure. - Whereas the foregoing first technique employs explicit disk synchronization, the second technique, described in this and the following paragraphs uses check pointing, without disk synchronization. The file storing the
array 20 that is being modified is stored in a shared mode, in which it is assumed that changes made inRAM 104 will be reflected in the file on disk 101. However, the timing of carrying over the changes todisk 102 is handled by theoperating system 108 at a time of its own choosing and can be optimized, for example, in accordance with other system operations. - In the shared mode, when a section of
array 20 is modified, the changes are reflected immediately in the kernel buffers inRAM 104. In particular, as shown inFIG. 5 , the kernel can store in RAM 104 amapping 302 of the underlying file for the array (including any changes that are made to the array), and also can store theoriginal values 304 of the modified sections of the array (i.e., prior to the modifications) (see alsoFIG. 6 , block 402). Preferably, the original values of the array are maintained inRAM 104 only up to a predetermined constant fraction “k” (e.g., 20%) of the array size. When a batch of changes is completed with respect to the array, the user can call a Checkpoint function (block 404). The Checkpoint function computes a cyclic redundancy check (CRC) value for the array as modified (block 406), and stores the computedCRC value 306 is stored in RAM 104 (block 408). The CRC value can be computed as discussed in greater detail below, which also describes an advantage of maintaining the original values of the array inRAM 104. Changes toarray 20 and to the CRC value are carried over todisk 102 based on the memory mapping (block 410). As mentioned above,operating system 108 can carry over the information todisk 20 at a time selected, for example, to optimize overall system performance. The CRC value can be written and stored, for example, in four bytes at the end of the array file ondisk 102. - As illustrated in
FIG. 7 , when the program executed byprocessor 110 returns and reads data from thearray 20 ondisk 102, the program computes a CRC value for the entire array as stored on the disk, and compares the newly computed CRC value to the CRC value previously-stored in disk 102 (bock 414). If the newly computed value equals the CRC value stored in the file ondisk 102, then the data stored in the array ondisk 102 is valid (block 416). On the other hand, if the newly computed value does not equal the CRC value stored in the file ondisk 102, then the data stored in the array ondisk 102 is not valid and may be corrupted (block 418). In some implementations, a message can be provided automatically as an alert regarding the presence of possibly corrupted data in the particular file ondisk 102. One advantage to the foregoing technique for storing a mutable array is that fewer disk sync operations need to be performed. - One approach to calculating the CRC value for the array data stored in RAM 104 (in
block 404 ofFIG. 6 ) is to recalculate the CRC value for the entire array each time the Checkpoint function is called. Although such an approach can be used, it can be very time consuming. For example, ifarray 20 has size N and the Checkpoint function is called N/K times in fixed chunks of size K, then the total number of operations required to execute the CRCs is on the order of N2. - An alternative approach makes use of the
original values 304 of the array stored inRAM 104 and allows the CRC value to be updated incrementally, rather than re-computing a new CRC value for the entire array every time. The following technique can be used to replace a part of information M(x) in-place, and to re-compute the CRC value of modified information M(x) efficiently. If information M=ABC is a concatenation of parts A, B, and C, and B′(x) is a new part of the same length as B(x), CRCu(M′) of information M′=AB′C may be computed from known CRCu(M). In particular: -
CRC u(M′(x),v(x))=CRC u(M(x),v(x))+Δ -
where -
Δ={CRC u(B′(x),v(x))−(CRC u(B(x),v(x))}x |C|mod|P(x). - In some implementations, the CRC value is computed (in block 404) using the foregoing incremental updating technique if the changed area of the array is less than the predetermined constant fraction of the array size “k” (e.g., 20%). An advantage to this approach is that it can be less time consuming because the number of operations required is on the order of [n*log(n)], rather than n2. In the event that the changed area of the array is equal to or greater than the predetermined constant fraction of the array size “k” (e.g., 20%), then the program simply re-computes the CRC for the entire array.
- In some scenarios,
array 20 may be modified by appending new data to the array rather than changing existing elements in the array. In such a case, there is no original CRC value with respect to the newly appended data. Nevertheless, an updated CRC value for the array as modified can be computed by obtaining a CRC value for the newly added elements in the array, and then adding this CRC value to the CRC value previously obtained for the array prior to its modification. - For example, if information M(x)=M1(x)·xM|2|+M2(x) is a concatenation of M1 and M2, and CRCs of M1, M2 (computed with some initial values v1(x), v2(x) respectively) are known, then CRCu(M(x); v(x)) can be computed without touching contents of the M. For example, the value of v′1=CRCu(M1; v) can be computed from the known CRCu(M1; v1) without touching the contents of M1 using the following formula:
-
CRC u(M;v′)=CRC u(M;v)+|{(v′−v)x |M|} mod P. - Then, v′2=CRCu(M2; v′1) can be computed from known CRCu(M2; v2) without touching the contents of M2. Finally, CRCu(M; v)=v′2. When using the foregoing technique to compute the CRC value, a pointer can be used to point to the last byte in the array touched by the user.
- As indicated above, the foregoing techniques can be implemented, for example, on various types of handheld computing devices, such as mobile phones, tablets, personal digital assistants (PDAs), as well as desk top personal computers, laptop computers, and other computing devices.
- Various aspects of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions encoded on a computer readable medium for execution by, or to control the operation of, data processing apparatus. The computer readable medium can be a machine-readable storage device, a machine-readable storage substrate, a memory device, a composition of matter effecting a machine-readable propagated signal, or a combination of one or more of them. The terms “data processing apparatus” and “computer” encompasses all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
- Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone or other computing device. Computer readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- While operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
- A number of implementations have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the invention. Accordingly, other implementations are within the scope of the claims.
Claims (20)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/233,021 US10067674B2 (en) | 2013-01-16 | 2016-08-10 | Consistent, disk-backed arrays |
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201361753159P | 2013-01-16 | 2013-01-16 | |
US13/970,075 US9424125B2 (en) | 2013-01-16 | 2013-08-19 | Consistent, disk-backed arrays |
US15/233,021 US10067674B2 (en) | 2013-01-16 | 2016-08-10 | Consistent, disk-backed arrays |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/970,075 Division US9424125B2 (en) | 2013-01-16 | 2013-08-19 | Consistent, disk-backed arrays |
Publications (2)
Publication Number | Publication Date |
---|---|
US20160350001A1 true US20160350001A1 (en) | 2016-12-01 |
US10067674B2 US10067674B2 (en) | 2018-09-04 |
Family
ID=51166148
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/970,075 Active 2034-07-01 US9424125B2 (en) | 2013-01-16 | 2013-08-19 | Consistent, disk-backed arrays |
US15/233,021 Active US10067674B2 (en) | 2013-01-16 | 2016-08-10 | Consistent, disk-backed arrays |
Family Applications Before (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/970,075 Active 2034-07-01 US9424125B2 (en) | 2013-01-16 | 2013-08-19 | Consistent, disk-backed arrays |
Country Status (1)
Country | Link |
---|---|
US (2) | US9424125B2 (en) |
Families Citing this family (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9424125B2 (en) * | 2013-01-16 | 2016-08-23 | Google Inc. | Consistent, disk-backed arrays |
US9305655B2 (en) * | 2013-09-27 | 2016-04-05 | Virtium Technology, Inc. | Solving MLC NAND paired page program using reduced spatial redundancy |
US10891057B1 (en) * | 2015-12-31 | 2021-01-12 | EMC IP Holding Company LLC | Optimizing flash device write operations |
US10177785B2 (en) * | 2016-08-23 | 2019-01-08 | Western Digital Technologies, Inc. | Error detecting code with partial update |
Citations (57)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4746233A (en) * | 1986-08-20 | 1988-05-24 | Coulter Electronics, Inc. | Automatic printing apparatus utilizing turnaround document |
US5414839A (en) * | 1992-06-19 | 1995-05-09 | Digital Equipment Corporation | Hybrid lock escalation and de-escalation protocols |
US5509120A (en) * | 1993-11-30 | 1996-04-16 | International Business Machines Corporation | Method and system for detecting computer viruses during power on self test |
US5574874A (en) * | 1992-11-03 | 1996-11-12 | Tolsys Limited | Method for implementing a checkpoint between pairs of memory locations using two indicators to indicate the status of each associated pair of memory locations |
US5652793A (en) * | 1995-05-08 | 1997-07-29 | Nvidia Corporation | Method and apparatus for authenticating the use of software |
US5870520A (en) * | 1992-12-23 | 1999-02-09 | Packard Bell Nec | Flash disaster recovery ROM and utility to reprogram multiple ROMS |
US6549977B1 (en) * | 2001-05-23 | 2003-04-15 | 3Ware, Inc. | Use of deferred write completion interrupts to increase the performance of disk operations |
US6553388B1 (en) * | 2000-07-20 | 2003-04-22 | International Business Machines Corporation | Database deltas using Cyclic Redundancy Checks |
US20030159056A1 (en) * | 2002-02-15 | 2003-08-21 | International Business Machines Corporation | Method and system for securing enablement access to a data security device |
US20040100966A1 (en) * | 2002-11-21 | 2004-05-27 | International Business Machines Corporation | Apparatus, method and program product to generate and use CRC in communications network |
US20040123282A1 (en) * | 2000-11-17 | 2004-06-24 | Rao Bindu Rama | Mobile handset with a fault tolerant update agent |
US20040153952A1 (en) * | 2003-02-04 | 2004-08-05 | Sharma Debendra Das | CRC encoding scheme for conveying status information |
US6775794B1 (en) * | 2001-05-23 | 2004-08-10 | Applied Micro Circuits Corporation | Use of activity bins to increase the performance of disk arrays |
US20040221125A1 (en) * | 2003-04-29 | 2004-11-04 | International Business Machines Corporation | Method, system and computer program product for implementing copy-on-write of a file |
US20050091569A1 (en) * | 2003-10-24 | 2005-04-28 | Hon Hai Precision Industry Co., Ltd. | System and method for securely storing data in a memory |
US20050132179A1 (en) * | 2003-12-16 | 2005-06-16 | Microsoft Corporation | Applying custom software image updates to non-volatile storage in a failsafe manner |
US20050138347A1 (en) * | 2003-12-18 | 2005-06-23 | International Business Machines Corporation | Update in-use flash memory without external interfaces |
US20050149818A1 (en) * | 2003-12-17 | 2005-07-07 | Tsai Kovsky T.J. | High performance CRC calculation method and system with a matrix transformation strategy |
US20050198432A1 (en) * | 2004-03-05 | 2005-09-08 | Dell Products L.P, | Information handling system including media drive resume recording feature |
US20060072369A1 (en) * | 2004-10-04 | 2006-04-06 | Research In Motion Limited | System and method for automatically saving memory contents of a data processing device on power failure |
US7082446B1 (en) * | 2002-04-15 | 2006-07-25 | Steel Eye Technology, Inc. | Hybrid transaction/intent log for data replication |
US20060179367A1 (en) * | 2005-01-05 | 2006-08-10 | Lg Electronics Inc. | Method for updating memory |
US20060265568A1 (en) * | 2003-05-16 | 2006-11-23 | Burton David A | Methods and systems of cache memory management and snapshot operations |
US20070032228A1 (en) * | 2005-08-05 | 2007-02-08 | Research In Motion Limited | Methods and systems for handling software operations associated with startup and shutdown of handheld devices |
US20070088912A1 (en) * | 2005-10-05 | 2007-04-19 | Oracle International Corporation | Method and system for log structured relational database objects |
US20070288533A1 (en) * | 2003-03-28 | 2007-12-13 | Novell, Inc. | Methods and systems for file replication utilizing differences between versions of files |
US20080046608A1 (en) * | 1999-08-04 | 2008-02-21 | Super Talent Electronics Inc. | Low-Power Extended USB Flash Device Without Polling |
US20080091876A1 (en) * | 2006-10-11 | 2008-04-17 | Akira Fujibayashi | Storage apparatus and control method thereof |
US20080096671A1 (en) * | 2004-09-16 | 2008-04-24 | Gagner Mark B | Gaming Machine With Secure Fault-Tolerant Memory |
US20080117685A1 (en) * | 2006-11-16 | 2008-05-22 | Freescale Semiconductor, Inc. | Memory device with retained indicator of read reference level |
US20080195912A1 (en) * | 2007-02-14 | 2008-08-14 | Nokia Corporation | Method of communicatoin |
US20090019342A1 (en) * | 2007-07-13 | 2009-01-15 | Shay Gueron | Determining a Message Residue |
US7480907B1 (en) * | 2003-01-09 | 2009-01-20 | Hewlett-Packard Development Company, L.P. | Mobile services network for update of firmware/software in mobile handsets |
US20090031097A1 (en) * | 2007-07-29 | 2009-01-29 | Lee Nelson | Creating Backups in Storage Systems |
US20090106580A1 (en) * | 2007-10-17 | 2009-04-23 | Marko Slyz | Mobile handset employing efficient backup and recovery of blocks during update |
US20090119450A1 (en) * | 2007-11-06 | 2009-05-07 | Saeki Shusuke | Memory device, memory management method, and program |
US20090248964A1 (en) * | 2008-03-01 | 2009-10-01 | Kabushiki Kaisha Toshiba | Memory system and method for controlling a nonvolatile semiconductor memory |
US20100011279A1 (en) * | 2008-07-11 | 2010-01-14 | Freescale Semiconductor, Inc. | Error correcting viterbi decoder |
US20100220536A1 (en) * | 2009-02-27 | 2010-09-02 | International Business Machines Corporation | Advanced memory device having reduced power and improved performance |
US20100287351A1 (en) * | 2007-06-28 | 2010-11-11 | Nokia Corporation | File access management system |
US7908448B1 (en) * | 2007-01-30 | 2011-03-15 | American Megatrends, Inc. | Maintaining data consistency in mirrored cluster storage systems with write-back cache |
US7979396B1 (en) * | 2005-06-28 | 2011-07-12 | Symantec Operating Corporation | System and method for performing consistent resynchronization between synchronized copies |
US20110200146A1 (en) * | 2010-02-17 | 2011-08-18 | Sony Corporation | Receiving device, receiving method, and program |
US8046548B1 (en) * | 2007-01-30 | 2011-10-25 | American Megatrends, Inc. | Maintaining data consistency in mirrored cluster storage systems using bitmap write-intent logging |
US20110283070A1 (en) * | 2010-05-14 | 2011-11-17 | Rischar Charles M | Method to Separate and Persist Static and Dynamic Portions of a Control Application |
US20110280381A1 (en) * | 2010-05-12 | 2011-11-17 | Sony Corporation | Receiving apparatus, announcement control method, and program |
US8065472B2 (en) * | 2005-07-18 | 2011-11-22 | Hewlett-Packard Development Company, L.P. | System and method for improving data integrity and memory performance using non-volatile media |
US20120254636A1 (en) * | 2011-03-28 | 2012-10-04 | Fujitsu Limited | Control apparatus and control method |
US8291180B2 (en) * | 2008-03-20 | 2012-10-16 | Vmware, Inc. | Loose synchronization of virtual disks |
US20120278799A1 (en) * | 2011-04-26 | 2012-11-01 | Microsoft Corporation | Virtual Disk Storage Techniques |
US8335771B1 (en) * | 2010-09-29 | 2012-12-18 | Emc Corporation | Storage array snapshots for logged access replication in a continuous data protection system |
US20130117641A1 (en) * | 2009-12-09 | 2013-05-09 | Kuljit S. Bains | Method and system for error management in a memory device |
US20130128022A1 (en) * | 2010-08-26 | 2013-05-23 | Blast Motion, Inc. | Intelligent motion capture element |
US20130268717A1 (en) * | 2012-04-09 | 2013-10-10 | Ross S. Scouller | Emulated electrically erasable memory having sector management |
US8572337B1 (en) * | 2009-12-14 | 2013-10-29 | Symantec Corporation | Systems and methods for performing live backups |
US20140181397A1 (en) * | 2012-12-21 | 2014-06-26 | Red Hat, Inc. | Synchronous management of disk flush requests |
US9424125B2 (en) * | 2013-01-16 | 2016-08-23 | Google Inc. | Consistent, disk-backed arrays |
Family Cites Families (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP1169676A1 (en) | 1999-04-05 | 2002-01-09 | Marathon Technologies Corporation | Background synchronization for fault-tolerant systems |
US7539828B2 (en) * | 2000-08-08 | 2009-05-26 | Faronics Corporation | Method and system for automatically preserving persistent storage |
US6981114B1 (en) * | 2002-10-16 | 2005-12-27 | Veritas Operating Corporation | Snapshot reconstruction from an existing snapshot and one or more modification logs |
US20040160975A1 (en) | 2003-01-21 | 2004-08-19 | Charles Frank | Multicast communication protocols, systems and methods |
US20040179228A1 (en) * | 2003-03-10 | 2004-09-16 | Mccluskey Mark | Indication of image content modification |
US20080071963A1 (en) * | 2003-11-22 | 2008-03-20 | Super Talent Electronics Inc. | Express card with extended USB interface |
US7971199B1 (en) * | 2004-05-03 | 2011-06-28 | Hewlett-Packard Development Company, L.P. | Mobile device with a self-updating update agent in a wireless network |
US7536529B1 (en) * | 2005-06-10 | 2009-05-19 | American Megatrends, Inc. | Method, system, apparatus, and computer-readable medium for provisioning space in a data storage system |
CA2687883C (en) | 2007-06-19 | 2014-07-08 | Qualcomm Incorporated | Methods and apparatus for dataset synchronization in a wireless environment |
-
2013
- 2013-08-19 US US13/970,075 patent/US9424125B2/en active Active
-
2016
- 2016-08-10 US US15/233,021 patent/US10067674B2/en active Active
Patent Citations (57)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4746233A (en) * | 1986-08-20 | 1988-05-24 | Coulter Electronics, Inc. | Automatic printing apparatus utilizing turnaround document |
US5414839A (en) * | 1992-06-19 | 1995-05-09 | Digital Equipment Corporation | Hybrid lock escalation and de-escalation protocols |
US5574874A (en) * | 1992-11-03 | 1996-11-12 | Tolsys Limited | Method for implementing a checkpoint between pairs of memory locations using two indicators to indicate the status of each associated pair of memory locations |
US5870520A (en) * | 1992-12-23 | 1999-02-09 | Packard Bell Nec | Flash disaster recovery ROM and utility to reprogram multiple ROMS |
US5509120A (en) * | 1993-11-30 | 1996-04-16 | International Business Machines Corporation | Method and system for detecting computer viruses during power on self test |
US5652793A (en) * | 1995-05-08 | 1997-07-29 | Nvidia Corporation | Method and apparatus for authenticating the use of software |
US20080046608A1 (en) * | 1999-08-04 | 2008-02-21 | Super Talent Electronics Inc. | Low-Power Extended USB Flash Device Without Polling |
US6553388B1 (en) * | 2000-07-20 | 2003-04-22 | International Business Machines Corporation | Database deltas using Cyclic Redundancy Checks |
US20040123282A1 (en) * | 2000-11-17 | 2004-06-24 | Rao Bindu Rama | Mobile handset with a fault tolerant update agent |
US6775794B1 (en) * | 2001-05-23 | 2004-08-10 | Applied Micro Circuits Corporation | Use of activity bins to increase the performance of disk arrays |
US6549977B1 (en) * | 2001-05-23 | 2003-04-15 | 3Ware, Inc. | Use of deferred write completion interrupts to increase the performance of disk operations |
US20030159056A1 (en) * | 2002-02-15 | 2003-08-21 | International Business Machines Corporation | Method and system for securing enablement access to a data security device |
US7082446B1 (en) * | 2002-04-15 | 2006-07-25 | Steel Eye Technology, Inc. | Hybrid transaction/intent log for data replication |
US20040100966A1 (en) * | 2002-11-21 | 2004-05-27 | International Business Machines Corporation | Apparatus, method and program product to generate and use CRC in communications network |
US7480907B1 (en) * | 2003-01-09 | 2009-01-20 | Hewlett-Packard Development Company, L.P. | Mobile services network for update of firmware/software in mobile handsets |
US20040153952A1 (en) * | 2003-02-04 | 2004-08-05 | Sharma Debendra Das | CRC encoding scheme for conveying status information |
US20070288533A1 (en) * | 2003-03-28 | 2007-12-13 | Novell, Inc. | Methods and systems for file replication utilizing differences between versions of files |
US20040221125A1 (en) * | 2003-04-29 | 2004-11-04 | International Business Machines Corporation | Method, system and computer program product for implementing copy-on-write of a file |
US20060265568A1 (en) * | 2003-05-16 | 2006-11-23 | Burton David A | Methods and systems of cache memory management and snapshot operations |
US20050091569A1 (en) * | 2003-10-24 | 2005-04-28 | Hon Hai Precision Industry Co., Ltd. | System and method for securely storing data in a memory |
US20050132179A1 (en) * | 2003-12-16 | 2005-06-16 | Microsoft Corporation | Applying custom software image updates to non-volatile storage in a failsafe manner |
US20050149818A1 (en) * | 2003-12-17 | 2005-07-07 | Tsai Kovsky T.J. | High performance CRC calculation method and system with a matrix transformation strategy |
US20050138347A1 (en) * | 2003-12-18 | 2005-06-23 | International Business Machines Corporation | Update in-use flash memory without external interfaces |
US20050198432A1 (en) * | 2004-03-05 | 2005-09-08 | Dell Products L.P, | Information handling system including media drive resume recording feature |
US20080096671A1 (en) * | 2004-09-16 | 2008-04-24 | Gagner Mark B | Gaming Machine With Secure Fault-Tolerant Memory |
US20060072369A1 (en) * | 2004-10-04 | 2006-04-06 | Research In Motion Limited | System and method for automatically saving memory contents of a data processing device on power failure |
US20060179367A1 (en) * | 2005-01-05 | 2006-08-10 | Lg Electronics Inc. | Method for updating memory |
US7979396B1 (en) * | 2005-06-28 | 2011-07-12 | Symantec Operating Corporation | System and method for performing consistent resynchronization between synchronized copies |
US8065472B2 (en) * | 2005-07-18 | 2011-11-22 | Hewlett-Packard Development Company, L.P. | System and method for improving data integrity and memory performance using non-volatile media |
US20070032228A1 (en) * | 2005-08-05 | 2007-02-08 | Research In Motion Limited | Methods and systems for handling software operations associated with startup and shutdown of handheld devices |
US20070088912A1 (en) * | 2005-10-05 | 2007-04-19 | Oracle International Corporation | Method and system for log structured relational database objects |
US20080091876A1 (en) * | 2006-10-11 | 2008-04-17 | Akira Fujibayashi | Storage apparatus and control method thereof |
US20080117685A1 (en) * | 2006-11-16 | 2008-05-22 | Freescale Semiconductor, Inc. | Memory device with retained indicator of read reference level |
US8046548B1 (en) * | 2007-01-30 | 2011-10-25 | American Megatrends, Inc. | Maintaining data consistency in mirrored cluster storage systems using bitmap write-intent logging |
US7908448B1 (en) * | 2007-01-30 | 2011-03-15 | American Megatrends, Inc. | Maintaining data consistency in mirrored cluster storage systems with write-back cache |
US20080195912A1 (en) * | 2007-02-14 | 2008-08-14 | Nokia Corporation | Method of communicatoin |
US20100287351A1 (en) * | 2007-06-28 | 2010-11-11 | Nokia Corporation | File access management system |
US20090019342A1 (en) * | 2007-07-13 | 2009-01-15 | Shay Gueron | Determining a Message Residue |
US20090031097A1 (en) * | 2007-07-29 | 2009-01-29 | Lee Nelson | Creating Backups in Storage Systems |
US20090106580A1 (en) * | 2007-10-17 | 2009-04-23 | Marko Slyz | Mobile handset employing efficient backup and recovery of blocks during update |
US20090119450A1 (en) * | 2007-11-06 | 2009-05-07 | Saeki Shusuke | Memory device, memory management method, and program |
US20090248964A1 (en) * | 2008-03-01 | 2009-10-01 | Kabushiki Kaisha Toshiba | Memory system and method for controlling a nonvolatile semiconductor memory |
US8291180B2 (en) * | 2008-03-20 | 2012-10-16 | Vmware, Inc. | Loose synchronization of virtual disks |
US20100011279A1 (en) * | 2008-07-11 | 2010-01-14 | Freescale Semiconductor, Inc. | Error correcting viterbi decoder |
US20100220536A1 (en) * | 2009-02-27 | 2010-09-02 | International Business Machines Corporation | Advanced memory device having reduced power and improved performance |
US20130117641A1 (en) * | 2009-12-09 | 2013-05-09 | Kuljit S. Bains | Method and system for error management in a memory device |
US8572337B1 (en) * | 2009-12-14 | 2013-10-29 | Symantec Corporation | Systems and methods for performing live backups |
US20110200146A1 (en) * | 2010-02-17 | 2011-08-18 | Sony Corporation | Receiving device, receiving method, and program |
US20110280381A1 (en) * | 2010-05-12 | 2011-11-17 | Sony Corporation | Receiving apparatus, announcement control method, and program |
US20110283070A1 (en) * | 2010-05-14 | 2011-11-17 | Rischar Charles M | Method to Separate and Persist Static and Dynamic Portions of a Control Application |
US20130128022A1 (en) * | 2010-08-26 | 2013-05-23 | Blast Motion, Inc. | Intelligent motion capture element |
US8335771B1 (en) * | 2010-09-29 | 2012-12-18 | Emc Corporation | Storage array snapshots for logged access replication in a continuous data protection system |
US20120254636A1 (en) * | 2011-03-28 | 2012-10-04 | Fujitsu Limited | Control apparatus and control method |
US20120278799A1 (en) * | 2011-04-26 | 2012-11-01 | Microsoft Corporation | Virtual Disk Storage Techniques |
US20130268717A1 (en) * | 2012-04-09 | 2013-10-10 | Ross S. Scouller | Emulated electrically erasable memory having sector management |
US20140181397A1 (en) * | 2012-12-21 | 2014-06-26 | Red Hat, Inc. | Synchronous management of disk flush requests |
US9424125B2 (en) * | 2013-01-16 | 2016-08-23 | Google Inc. | Consistent, disk-backed arrays |
Also Published As
Publication number | Publication date |
---|---|
US10067674B2 (en) | 2018-09-04 |
US20140201428A1 (en) | 2014-07-17 |
US9424125B2 (en) | 2016-08-23 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10664362B2 (en) | Recovery processing for database in persistent system | |
US8224780B2 (en) | Checkpoints for a file system | |
US10067674B2 (en) | Consistent, disk-backed arrays | |
KR101999409B1 (en) | Formatting data by example | |
US8620894B2 (en) | Searching files | |
AU2010328591B2 (en) | Consistency without ordering dependency | |
US20190146882A1 (en) | Journal-less recovery for nested crash-consistent storage systems | |
US9558248B2 (en) | Unified searchable storage for resource-constrained and other devices | |
CN111078672A (en) | Data comparison method and device for database | |
US20230014427A1 (en) | Global secondary index method for distributed database, electronic device and storage medium | |
US20210279135A1 (en) | Method, device and computer program product for recovering data | |
US20200099745A1 (en) | Storage segment server covered cache | |
US20110289289A1 (en) | Backup and restore of items using bounded checkpoint and log buffers in memory | |
US7444482B2 (en) | Storage pools with write atomicity | |
US11436200B2 (en) | Fault tolerant parallel journaling for file systems | |
US11099948B2 (en) | Persistent storage segment caching for data recovery | |
CN111221817B (en) | Service information data storage method, device, computer equipment and storage medium | |
US20200097366A1 (en) | Accessing prior storage segment server state | |
CN113326268A (en) | Data writing and reading method and device |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:KIRAZCI, ULAS;BANACHOWSKI, SCOTT;REEL/FRAME:039414/0372Effective date: 20130816 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044129/0001Effective date: 20170929 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |