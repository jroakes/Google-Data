CN113056897A - Low entropy browsing history for content quasi-personalization - Google Patents
Low entropy browsing history for content quasi-personalization Download PDFInfo
- Publication number
- CN113056897A CN113056897A CN202080006197.3A CN202080006197A CN113056897A CN 113056897 A CN113056897 A CN 113056897A CN 202080006197 A CN202080006197 A CN 202080006197A CN 113056897 A CN113056897 A CN 113056897A
- Authority
- CN
- China
- Prior art keywords
- content
- application
- computing device
- cluster
- browsing history
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/904—Browsing; Visualisation therefor
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L67/00—Network arrangements or protocols for supporting network services or applications
- H04L67/2866—Architectures; Arrangements
- H04L67/30—Profiles
- H04L67/306—User profiles
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/906—Clustering; Classification
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/903—Querying
- G06F16/9035—Filtering based on additional data, e.g. user or group profiles
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/951—Indexing; Web crawling techniques
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/953—Querying, e.g. by the use of web search engines
- G06F16/9536—Search customisation based on social or collaborative filtering
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/957—Browsing optimisation, e.g. caching or content distillation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/957—Browsing optimisation, e.g. caching or content distillation
- G06F16/9574—Browsing optimisation, e.g. caching or content distillation of access to content, e.g. by caching
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/958—Organisation or management of web site content, e.g. publishing, maintaining pages or automatic linking
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F18/00—Pattern recognition
- G06F18/20—Analysing
- G06F18/23—Clustering techniques
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F18/00—Pattern recognition
- G06F18/20—Analysing
- G06F18/24—Classification techniques
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/50—Monitoring users, programs or devices to maintain the integrity of platforms, e.g. of processors, firmware or operating systems
- G06F21/55—Detecting local intrusion or implementing counter-measures
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
- G06F21/6245—Protecting personal data, e.g. for financial or medical purposes
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L63/00—Network architectures or network communication protocols for network security
- H04L63/14—Network architectures or network communication protocols for network security for detecting or protecting against malicious traffic
- H04L63/1441—Countermeasures against malicious traffic
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L67/00—Network arrangements or protocols for supporting network services or applications
- H04L67/50—Network services
- H04L67/535—Tracking the activity of the user
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N7/00—Computing arrangements based on specific mathematical models
- G06N7/02—Computing arrangements based on specific mathematical models using fuzzy logic
- G06N7/04—Physical realisation
- G06N7/046—Implementation by means of a neural network
Abstract
The present disclosure provides systems and methods for content retrieval for content quasi-personalization or anonymization via aggregated browsing history of a large number of devices, such as millions or billions of devices. A sparse matrix may be constructed from the aggregated browsing history and reduced in dimension, thereby reducing entropy and providing anonymity for individual devices. Relevant content may be selected via quasi-personalized clustering to represent similar browsing history without exposing individual device details to the content provider.
Description
Cross Reference to Related Applications
This application claims priority from U.S. patent application No.16/535,912 entitled "Low entry Browsing History for Content quick-Personalization" (Low Entropy Browsing History for Content Quasi-Personalization) filed on 8/2019, which is incorporated herein by reference in its entirety.
Background
In a computer networking environment, such as the internet, content providers are able to provide content items to be inserted into information resources (e.g., web pages) that are processed and rendered by applications (e.g., web browsers) executing on client devices.
Personalized content delivery is typically based on capturing identifying information of the user and/or device, such as a browsing or access history of the device. However, this significantly affects the privacy and security of the device and the user. Opt-out and no-tracking policies allow the user some measure of control over their privacy, but diminish the ability of the content provider to provide relevant content.
Disclosure of Invention
The systems and methods discussed herein provide content quasi-personalized or anonymized content retrieval via the aggregated browsing history of a large number of devices, such as millions or billions of devices. The sparse matrix may be constructed from the aggregated browsing history and reduced in dimension, thereby reducing entropy and providing anonymity for individual devices. Relevant content may be selected via quasi-personalized clustering to represent similar browsing history without exposing individual device details to the content provider.
In one aspect, the present disclosure is directed to a method for anonymized content retrieval. The method includes generating, by a browser application of a computing device, a profile based on a browsing history of the computing device. The method also includes encoding, by the browser application, the profile as an n-dimensional vector. The method also includes calculating, by the browser application, a reduced-dimension vector from the n-dimension vector. The method also includes determining, by the browser application, a first cluster corresponding to the reduced-dimension vector. The method also includes transmitting, by the browser application, a request for the content item to a content server, the request including an identification of the first cluster. The method also includes receiving, by the browser application from the content server, the content items selected according to the identification of the first cluster.
In some implementations, the method includes generating a profile based on the browsing history of the user of the computing device by identifying, from a log of the browsing history, a number n of accesses to each of the plurality of addresses within a predetermined time period. In some embodiments, the method includes generating a string having values representing: each of the one or more accesses to an address associated with a corresponding location in the string within a predetermined period of time.
In some embodiments, the method includes performing a singular value decomposition of the n-dimensional vector. In another embodiment, the method includes receiving a set of singular vectors of a singular value decomposition from a second computing device. In yet another embodiment, the method includes transmitting the n-dimensional vectors to a second computing device that computes a set of singular vectors based on an aggregation of the n-dimensional vectors of the computing device and the n-dimensional vectors of at least one other computing device.
In some implementations, the method includes receiving, from the second computing device, a boundary for each of a plurality of clusters. In another embodiment, the method includes selecting a first cluster of the plurality of clusters in response to the reduced-dimension vector being within a boundary of the first cluster.
In some embodiments, the method comprises: receiving, by a browser application from a second computing device, weights for a neural network model determined based on an aggregation of an n-dimensional vector of the computing device and an n-dimensional vector of at least one other computing device; applying, by a machine learning system of the browser application, the neural network model to the reduced-dimension vector to generate a ranking of the set of predetermined clusters; and selecting, by the browser application, the first cluster as a highest-ranked cluster of the predetermined set of clusters.
In another aspect, the present disclosure is directed to a method for anonymized content retrieval. The method includes receiving, by a server computing device from each of a plurality of client computing devices, a profile based on a browsing history of the corresponding client computing device, each profile including an n-dimensional vector. The method also includes aggregating, by the server computing device, a plurality of n-dimensional vectors of the plurality of profiles into a matrix. The method also includes calculating, by the server computing device, a singular value decomposition of the matrix to generate a set of singular values. The method also includes transmitting, by the server computing device, the singular value set to each of the plurality of client computing devices and the at least one content provider device.
In some implementations, the method includes determining, by the server computing device, a boundary of each cluster in a set of clusters of the matrix. In another embodiment, the method includes transmitting, by the server computing device, to each of the plurality of client computing devices and the at least one content provider device, a boundary of each of a set of clusters of the matrix.
In some implementations, the method includes identifying, by the server computing device, each cluster in the set of clusters from the matrix via a neural network model. In another embodiment, the method includes transmitting weights of the neural network model to each of the plurality of client computing devices and the at least one content provider device.
In yet another aspect, the present disclosure is directed to a system for anonymized content retrieval. The system includes a computing device including a network interface to communicate with a content server, a memory to store a browsing history of the computing device, and a browser application. The browser application is configured to: generating a profile based on a browsing history of the computing device; encoding the profile as an n-dimensional vector; calculating a dimensionality reduction vector according to the n-dimensional vector; determining a first cluster corresponding to the dimensionality reduction vector; transmitting a request for a content item to a content server via a network interface, the request comprising an identification of a first cluster; and receiving, from the content server via the network interface, the content items selected according to the identification of the first cluster.
In some implementations, the browser application is further configured to generate a string having a value representing each of the one or more accesses to the address associated with the corresponding location in the string within a predetermined time period. In some implementations, the browser application is further configured to perform singular value decomposition of the n-dimensional vector. In another embodiment, the browser application is further configured to receive, from the second computing device via the network interface, a set of singular vectors of the singular value decomposition. In yet another embodiment, the browser application is further configured to transmit the n-dimensional vector to a second computing device via the network interface, the second computing device calculating a set of singular vectors based on an aggregation of the n-dimensional vector of the computing device and the n-dimensional vector of the at least one other computing device.
In some implementations, the browser application is further configured to: receiving, from a second computing device via a network interface, weights for a neural network model determined based on an aggregation of an n-dimensional vector of the computing device and an n-dimensional vector of at least one other computing device; applying a neural network model to the reduced-dimension vector to generate a ranking of the set of predetermined clusters; and selecting the first cluster as the highest ranked cluster of the predetermined set of clusters.
At least one aspect relates to a method of encoding an identifier for content selection. A first application executing on a client device can identify a browsing history maintained on the client device. The browsing history can record information resources accessed by the client device via the first application. The first application can apply a classification model to a browsing history of the first application to identify a class in which the first application is to be classified. The first application can assign the first application to a class identifier corresponding to the identified class. The class identifier of the first application can be the same as the class identifier of the second application. The first application can receive an information resource from the content publisher device, the information resource including primary content and a content slot available to receive content from the content selection service. The first application can generate a request for content for a content slot of the information resource, the request for content including a class identifier for the first application. The first application can communicate a request for content to a content selection service. The content selection service can use the class identifier for the first application and the class identifier for the second application to select a content item to be inserted into a content slot of the information resource.
In some implementations, the first application can receive a set of parameters from an application administrator service for updating a classification model for classifying the application into one of a plurality of classes. In some implementations, the first application can modify a classification model maintained on the client device based on a set of parameters received from an application administrator service. In some implementations, a first application can train a classification model maintained on a client device using a distributed learning protocol consistent with a plurality of applications executing on a plurality of corresponding client devices.
In some implementations, the first application can generate a reduced feature vector set from a browsing history identified from the client device using a dimension reduction process, the feature vector being smaller in file size than the browsing history. In some implementations, applying the classification model can include applying the classification model to a reduced set of feature vectors generated from the browsing history.
In some implementations, the first application can determine that the classification model is to be applied to the browsing history according to an identifier assignment policy. In some embodiments, applying the classification model can include: the classification model is applied in response to determining that the classification model is to be applied in accordance with the identifier assignment policy.
In some implementations, applying the classification model can include applying the classification model to identify classes from a plurality of classes. Each of the plurality of classes can have at least a predetermined number of clients to be categorized into the class. In some implementations, assigning the first application to the class identifier can also include assigning the first application to a class identifier of the plurality of class identifiers. Each class identifier can correspond to one of a plurality of classes.
In some implementations, generating the request for content can include: the request for content is generated without a unique tracking identifier corresponding to an account provided by the content selection service associated with the first application, or the client device. In some implementations, generating a request for content can include generating a request for content including a secure cookie (a type of browser cache) for transmission over a connection with a content selection service. The secure cookie can have a class identifier of the first application. In some implementations, identifying the browsing history can include identifying the browsing history over a predetermined time range in which the classification model is to be applied.
At least one aspect relates to a system for encoding an identifier for content selection. The system can include a first application executable on a client device having one or more processors. A first application executing on a client device can identify a browsing history maintained on the client device. The browsing history can record information resources accessed by the client device via the first application. The first application can apply a classification model to a browsing history of the first application to identify a class in which the first application is to be classified. The first application can assign the first application to a class identifier corresponding to the identified class. The class identifier of the first application can be the same as the class identifier of the second application. The first application can receive an information resource from the content publisher device, the information resource including primary content and a content slot available to receive content from the content selection service. The first application can generate a request for content for a content slot of the information resource, the request for content including a class identifier for the first application. The first application can communicate a request for content to a content selection service. The content selection service can use the class identifier for the first application and the class identifier for the second application to select a content item to be inserted into a content slot of the information resource.
In some implementations, the first application can receive a set of parameters from an application administrator service for updating a classification model for classifying the application into one of a plurality of classes. In some implementations, the first application can modify a classification model maintained on the client device based on a set of parameters received from an application administrator service. In some implementations, a first application can train a classification model maintained on a client device using a distributed learning protocol consistent with a plurality of applications executing on a plurality of corresponding client devices.
In some implementations, the first application can generate a reduced feature vector set from a browsing history identified from the client device using a dimension reduction process, the feature vector being smaller in file size than the browsing history. In some implementations, the first application can apply the classification model to a set of simplified feature vectors generated from the browsing history.
In some implementations, the first application can determine that the classification model is to be applied to the browsing history according to an identifier assignment policy. In some implementations, the first application can apply the classification model in response to determining to apply the classification model in accordance with the identifier assignment policy.
In some implementations, the first application can apply a classification model to identify the class from a plurality of classes. Each of the plurality of classes can have at least a predetermined number of clients to be categorized into the class. In some implementations, the first application can assign the first application to a class identifier of a plurality of class identifiers. Each class identifier can correspond to a rib in a plurality of classes.
In some implementations, the first application generates the request for content without a unique tracking identifier provided by the content selection service corresponding to an account associated with the first application, the second application, or the client device. In some implementations, the first application generates a request for content including a secure cookie for transmission over a connection with a content selection service. The secure cookie can have a class identifier for the first application. In some implementations, the first application can identify the browsing history over a predetermined time range in which the classification model is to be applied.
The present disclosure also provides a computer program comprising instructions which, when executed by a computing device, cause the computing device to perform any of the methods disclosed herein. The present disclosure also provides a computer-readable medium comprising instructions that, when executed by a computing device, cause the computing device to perform any of the methods disclosed herein.
Optional features of one aspect may be combined with any other aspect.
Drawings
The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the disclosure will become apparent from the description, the drawings, and the claims, wherein:
FIG. 1A is an illustration of an example profile vector, according to some embodiments;
FIG. 1B is a diagram of aggregating profile vectors into a sparse matrix, according to some embodiments;
FIG. 1C is an illustration of a process for anonymization to provide pseudo-personalized clusters, according to some embodiments;
FIG. 2 is a block diagram of a system for anonymization to provide pseudo-personalized clusters, according to some embodiments;
FIG. 3 is a flow diagram of a method for anonymization to provide pseudo-personalized clusters, according to some embodiments;
FIG. 4 is a block diagram depicting a system for encoding identifiers for content selection using a classification model in accordance with an illustrative embodiment;
FIG. 5 is a block diagram depicting a client device and an application management service in a system for encoding identifiers for content selection using a classification model in accordance with an illustrative embodiment;
FIG. 6 is a block diagram depicting a client device, a content provider, a content publisher, and a content selection service in a system for encoding identifiers for content selection using a classification model in accordance with an illustrative embodiment;
FIG. 7 is a block diagram depicting a client device and a content selection service in a system for encoding identifiers for content selection using a classification model in accordance with an illustrative embodiment;
FIG. 8 is a flowchart depicting a method of encoding an identifier for content selection using a classification model in accordance with an illustrative embodiment; and
FIG. 9 is a block diagram illustrating a general architecture of a computer system that may be employed to implement the elements of the systems and methods described and illustrated herein, in accordance with an illustrative embodiment.
Like reference numbers and designations in the various drawings indicate like elements.
Detailed Description
Personalized content delivery is typically based on capturing identifying information of the user and/or device, such as a browsing or access history of the device. For example, the device may provide identification information, such as a device identifier, account name, cookie, or other such information; and the content provider may store this information for use in selecting personalized content. As a result, the content provider can obtain a large amount of data about an individual. This significantly affects the privacy and security of the device and the user. Opt-out and no-tracking policies allow the user some measure of control over their privacy (assuming that the content provider follows those policies). However, some content providers may not comply with user requests because these policies impair the content providers' ability to provide relevant content.
The systems and methods discussed herein provide content quasi-personalized or anonymized content retrieval via an aggregated browsing history of a large number of devices, such as millions or billions of devices. For example, the browsing history of each device may be encoded as a long data string or an n-dimensional vector. FIG. 1A is an illustration of an example profile vector 100 according to some embodiments. The profile vector may include an identification of a tour or visit by the device to a domain, website, or web page within a given time period. In the illustrated example, the vector identifies the number of views or tours for each of a large number of domains 1-n within each day of the week. Although shown as a one-dimensional vector, in a similar implementation, the vector may comprise an n-by-7 array (e.g., one row per day). In other implementations, additional data may be included (e.g., each day of the month, time of day, etc.). Thus, the vector may comprise a large n-dimensional vector or array. Additional data may be included in the vector, such as an identification of the time of generation, location, IP address, or any other such information.
As noted above, in many embodiments, the vector may be very large. For example, there are approximately 18 million active web sites and over 3.3 million registered domains on the internet. In some implementations, the vector may record a visit or visit to any of these domains or websites. In other embodiments, the vector may record visits or visits to only a subset of the domains or web sites. For example, less than one million web sites account for approximately 50% of web traffic. Thus, in many embodiments, the vector may only record or represent visits or tours to a subset of domains or websites. However, even in many such embodiments, the vector may be large, such as O (2)26) Or larger.
The vector may be provided to a server device, which may aggregate the vector with vectors of other devices, as shown in the diagram of fig. 1B. The profile vectors 100 from each of the multiple devices 102 may be aggregated to create a very large matrix. For example, there are billions (O (2) per month on the network30) ) active users or devices. The matrix for combining the profile vectors 100 for each of these devices may thus be O (2)30x226) The dimension, or in some embodiments, is larger.
However, this matrix is highly sparse. A typical user may visit O (100) in millions of possible domains over a given period of time, such as a week. The dimensionality of this matrix can be reduced due to the highly sparse nature and redundancy in the browsing history of any given device.
In some embodiments, a rank X matrix, which is the best approximation of the matrix (e.g., minimizing the squared error), may be calculated using a linear reduction technique such as Singular Vector Decomposition (SVD). Each profile vector 100 may be projected to X dimensions, where X is less than the original dimension of the matrix. For each dimension, the projection result can be quantized into buckets of powers of 2 to Ni, where i ∈ [1, X ], and the number of buckets is proportional to the singular value of the corresponding dimension. K ∑ Ni bits may be used to represent the quantized projection results for all X dimensions. Those bits concatenated together may be the cluster identifier of the device. In other implementations, a clustering algorithm (e.g., nearest neighbor) may be used to cluster the devices in a reduced-dimension space.
Because the singular vectors are orthogonal to each other and as a result of the quantization process, a statistically similar number of devices (e.g., approximately equal given a large total number of devices) may be within or identified as belonging to each cluster, assuming no non-linear dependencies among the profile vectors. Each cluster may be represented by an identifier (sometimes referred to as a cluster identifier, a browsing group identifier) or by similar terms.
In other embodiments, other linear decomposition methods may be used, such as principal component analysis. In still other embodiments, a non-linear dimension reduction algorithm may be used to reduce the dimension of the matrix. Various classification techniques may be used, including nearest neighbor searching, potential class analysis, and the like.
Fig. 1C is an illustration of this process according to some embodiments. As shown, profile vectors from a large number of devices may be aggregated into a large matrix at step 120. The matrix may be reduced in dimension at step 122. Clusters may be identified at step 124 as discussed above.
In some embodiments, the classification system may be trained as part of and/or in accordance with the cluster identification. For example, in some implementations, a neural network may be used to classify devices as part of a predetermined number of clusters. Such a network may use a reduced-dimension profile vector as an input, while using a cluster identifier as an output. The network may be trained in various embodiments via supervised or unsupervised learning.
In some implementations, the neural network model or weights for the model can be provided to the client device, orOther parameters for classification. Singular vectors generated from the dimensionality reduction may also be provided to the client device. Thus, after receiving the vectors and/or models, the clients can generate their own classifications by using the local profile vectors without further communication with the server. The server may periodically, for example, monthly or quarterly, regenerate the singular vectors and/or classification model parameters. The data transfer may be substantial in some embodiments (e.g., O (2)26) Dimension, each dimension having O (2)4) Individual singular vectors, resulting in approximately 2GB of data being required in some embodiments). In some implementations, to reduce data transfers to other devices, the server may compare the parameters and vectors to previously generated parameters and vectors and provide a new set only when there is a significant difference (e.g., a threshold difference is exceeded), or provide only a subset of the significantly changed parameters and/or vectors. In various implementations, the client may use these parameters and vectors to update its classification locally more frequently (e.g., daily, hourly, or with each content request).
Similarly, singular vectors and/or model parameters may be provided to the content provider in some implementations. When a client device requests a content item, the request may include a cluster identification. The cluster identification may be embedded in the payload (payload) or header of the request, such as within the HTTPS request or in an optional field of the HTTP header. The content provider may in some embodiments use a neural network model or provider-specific neural network model to infer demographics and/or user interests for the devices within each cluster (e.g., by determining an approximate profile vector corresponding to the cluster identification based on the reduced-dimension singular vectors, and then providing the vector to a machine learning system to infer the characteristics) without being able to identify characteristics of any individual device or user.
Thus, these embodiments provide device anonymity by aggregating (i.e., aggregating devices with similar browsing histories or patterns together). Clustering algorithms attempt to maintain similar cluster sizes so that each cluster contains approximately the same number of users. The entropy of the cluster identifier controls the cluster size given a fixed number of active devices on the internet (e.g., the higher the entropy of the cluster identifier, the fewer devices in each cluster, thereby reducing privacy protection). By tuning the entropy of the cluster identifiers (e.g., by providing a fewer or greater number of clusters), the system can achieve a desired level of anonymity and privacy protection while still maintaining the effectiveness of content personalization.
These embodiments improve systems that do not utilize aggregation and pseudo-personalization to improve privacy while maintaining effectiveness. In such an unmodified system, a user or device identifier may be used to record a browsing history of the device and infer demographic information and interests of the corresponding user based on the accumulated history. Such inferred information may be used to predict the effectiveness of personalized content selections, such as click-through rates, attention, or other such metrics. However, via the systems and methods discussed herein, browsing history may be accumulated only for the device groups associated with a given cluster identifier or group. The inferred group demographics and interests may still be used for content selection by the inferred effectiveness metrics, while leaving the content provider with no way to distinguish the characteristics of the devices or users within the group or cluster.
In some implementations, a power of 2 to K typical browsing history pattern is defined based on the aggregated browsing history of billions of internet users. Each typical browsing history pattern has a unique cluster identifier or browsing history identifier, which may be represented by some small K-bit integer, such that each cluster identifier is shared by a large number of devices. When a user chooses to opt out of personalized content selection or chooses to join pseudo-personalization, the browser application of his device may select a typical browsing history pattern that best matches the user's actual browsing history. The browser may provide the corresponding cluster identifier to the content provider for content personalization purposes.
Typical browsing history patterns and encodings of cluster identifiers are chosen in such a way that approximately equal numbers of devices are associated with each cluster identifier. By controlling the value of K and the entropy of other signals that each content provider can obtain from the browser at the content request (e.g., IP address, user agent identifier, etc.), the browser can significantly reduce the risk of re-identification of the user while enabling pseudo-personalization of the content.
Fig. 2 is a block diagram of a system for anonymization to provide pseudo-personalized clusters according to some embodiments. Client device 200, which may include a desktop computer, a laptop computer, a tablet computer, a wearable computer, a smart phone, an embedded computer, a smart car, or any other type and form of computing device, may communicate with one or more classifier servers 230 and/or content servers 250 via network 225.
In many implementations, the client device 200 may include a processor 202 and a memory device 206. The memory device 206 may store machine instructions that, when executed by the processor, cause the processor to perform one or more of the operations described herein. The processor 202 may comprise a microprocessor, ASIC, FPGA, the like, or a combination thereof. In many embodiments, the processor may be a multi-core processor or an array of processors. The memory device 206 may include, but is not limited to, an electronic, optical, magnetic, or any other storage device capable of providing a processor with program instructions. The memory device may include a floppy disk, a CD-ROM, a DVD, a magnetic disk, a memory chip, a ROM, a RAM, an EEPROM, an EPROM, a flash memory, an optical medium, or any other suitable memory from which a processor can read instructions. The instructions may include code from any suitable computer programming language, such as, but not limited to C, C + +, C #, Java, JavaScript, Perl, HTML, XML, Python, and Visual Basic.
Client device 200 may include one or more network interfaces 204. The network interface 204 may include any type and form of interface, including: ethernet including 10Base T, 100Base T, or 1000Base T ("gigabit"); any of the 802.11 wireless varieties, such as 802.11a, 802.11b, 802.11g, 802.11n, or 802.11 ac; cellular networks, including CDMA, LTE, 3G, or 4G cellular networks; bluetooth or other short-range wireless connection; or any combination of these or other interfaces for communicating with a network. In many embodiments, the client device 200 may include multiple network interfaces 204 of different types, allowing connection to various networks 225. Accordingly, the network 225 may include a Local Area Network (LAN), a Wide Area Network (WAN) such as the internet, a cellular network, a broadband network, a bluetooth network, an 802.11(WiFi) network, a satellite network, or any combination of these or other networks, and may include one or more additional devices (e.g., routers, switches, firewalls, hubs, network accelerators, caches, etc.).
The client device may include one or more user interface devices. The user interface device may be any electronic device (e.g., a keyboard, a mouse, a pointing device, a touch screen display, a microphone, etc.) that communicates data to a user by generating sensory information (e.g., a visualization on a display, one or more sounds, haptic feedback, etc.) and/or converts sensory information received from a user into electronic signals. According to various embodiments, the one or more user interface devices may be internal to the housing of the client device, such as a built-in display, touch screen, microphone, etc., or external to the housing of the client device, such as a monitor connected to the client device, a speaker connected to the client device, etc.
The memory 206 may include an application 208 for execution by the processor 202. The applications 208 may include any type and form of application, such as a media application, a web browser, a productivity application, or any other such application, and may be referred to generally herein as a browser application. Application 208 may receive content from a content server and may display it for a user of a client device via a user interface.
Memory 206 may store an access log 210 (shown as log 210a of client device 200), which may be part of application 208 or maintained by application 208 (e.g., as part of a profile, preference file, history file, or other such file). The access log 210 may be stored in any format that may be used by the application 208. The access log may include an identification of a website, domain, web page, content, or other data accessed, retrieved, displayed, or otherwise obtained by the application 208. The access log 210 may also store a profile vector 100 as discussed above, which may be generated from the access history of the application and/or device. The profile vector 100 may include an n-dimensional string or array of values representing access to one or more domains, web pages, websites, or other such data during a predetermined period of time (e.g., day, week, time of day, etc.). As discussed above, the profile vector may be provided to the classifier server 230 (step a). The profile vector 100 may be generated by the application 208 or the log reducer 214, which may include an application, service, daemon, routine, plug-in, or other executable logic for generating a profile vector from an access log. In many implementations, the log reducer 214 may comprise a portion of the application 208.
The memory 206 may also store singular vectors 212. As discussed above, singular vectors 212 may be obtained from the classifier server 230 (step B), which may be computed from a dimensionality reduction of a matrix of profile vectors for the plurality of client devices 200 as discussed above. The singular vectors 212 may be stored in any suitable format, such as a flat file, data array, or other structure, and may be compressed in many embodiments.
The memory 206 may also store parameters of the neural network model 216. As discussed above, the neural network model 216 may be generated by the classifier server and provide parameters or weights to the client device 200 (step C). The classifier 218 of the client device 200, which may include an application, service, server, daemon, routine, or other executable logic for performing a machine learning algorithm, may utilize the neural network model 216 parameters to generate the cluster identifier 220 from the client device's reduced-dimension profile vector. In some implementations, the classifier 218 may include hardware circuitry, such as a tensor processing unit or other such hardware. In other implementations, the classifier 218 may include software that is executed by the processor 202 of the device.
The memory 206 may also store a cluster identifier 220. The cluster identifier 220 may include a cookie or other string associated with the cluster identifier and/or may encode or include information (e.g., XML code or parameters, parameter-value peers) for identifying characteristics of the cluster. The cluster identifier 220 may be predetermined or generated by the server 230 and provided to the client device 200. The classifier 218 of the client device may process the reduced-dimension profile vector of the client device by using a neural network model to generate a ranking or score for each cluster identifier 220, and may select the highest ranked or scored identifier for transmission to the content server during the content request (step D).
Classifier server 230 may include one or more server computing devices, and may include one or more physical computing devices, or one or more virtual computing devices (e.g., a cloud, cluster, or server farm) executed by one or more physical computing devices. Classifier server 230 may be referred to generally as a server, a measurement server, an aggregation server, or by other such terms.
Classifier server 230 may include one or more processors 202, network interface 204, and memory device 206, as well as other devices not shown. Classifier server 230 may store access logs and/or profile vectors 210a-210n obtained from multiple client devices 200 in memory. As discussed above, the aggregator 232 of the classifier server 230 may aggregate the profile vectors 210a-210n into a matrix or n-dimensional array, and the aggregator 232 of the classifier server 230 may include an application, server, service, routine, or other executable logic executed by the processor 202. The aggregator 232 may also compute the decomposition or dimensionality reduction of the matrix into singular vectors 212, which may be provided to the client device 200 (and the content server 250, in some implementations).
Classifier server 230 may also store classifier 218 in memory. The classifier 218 may be part of the aggregator 232 or may be another application, service, server, routine, or other executable logic executed by the processor 202 and/or a hardware processor, such as a tensor processing unit, for identifying clusters in the dimension reduction matrix. In many embodiments, the classifier 218 may include a neural network or similar artificial intelligence for classifying the reduced-dimension vector into one of a plurality of clusters. Once trained, the parameters of the neural network may be provided to the client device 200 to similarly generate cluster identifications or rankings as discussed above.
Content server 250 may include any type and form of content providing server or service, including a content delivery network, a web server, a media server, a social media service, or any other type and form of computing system. The content server 250 may include one or more processors 202, a network interface 204, and a memory device 206. In many implementations, the content server 250 may store a plurality of content items 252, which may include any type and form of content, including text, audio, video, animation, images, executable scripts, web pages, or any other such data.
Content server 250 may include a content selector 254, which may be part of a web server or file server, or may be a separate application, service, server, daemon, routine, or other executable logic for selecting content for delivery to a client device. The content may be selected based on the inferential characteristics of the device. The content server may receive a cluster identifier from the device at the request for content and may select content based on inferential characteristics of the device for the cluster. In some implementations, the content server may use the singular vectors obtained from the classifier server 230 to expand the cluster identifier into the corresponding profile vector used to represent the aggregate cluster. The profile vector of a cluster may not match the profile vector of any particular device, but may be an approximation or average of the vectors of all devices associated with the cluster.
Fig. 3 is a flow diagram of a method for anonymization to provide pseudo-personalized clusters, according to some embodiments. At step 302, the client device 200 may provide an access log or a profile vector generated from the access log to the classifier server 230. As discussed above, the profile vector may be based on a browsing or access history of the client device and may include an n-dimensional vector or string having values to represent: each of the one or more accesses to an address associated with a corresponding location in the string or array within a predetermined time period.
At step 304, the classifier server 230 may aggregate the profile vectors or logs from the client devices 200 into a matrix with profile vectors or logs obtained from one or more additional client devices 200. The profile vector may be obtained by the classifier server 230 periodically, or upon logging into a service provided by the classifier server or an association server. Step 302 and 304 may be repeated for a plurality of client devices, which may be a fraction of all devices that may utilize the singular vectors in 312 to perform dimension reduction in 314. In some implementations, steps 302 through 312 may be replaced with joint learning on the client device, and the classifier server 230 may be optional or may be removed.
At step 306, classifier server 230 may compute a dimensionality reduction or decomposition of the matrix. The classifier server may use a singular value decomposition algorithm in some embodiments, and may generate a plurality of singular vectors and a dimension reduction matrix.
At step 308, the classifier server may optionally identify cluster boundaries or parameters for the clusters of the dimension reduction matrix. The classifier server may use any suitable algorithm, such as principal component analysis, or a machine learning system, such as a neural network, to identify the clusters.
At step 310, in some implementations, the classifier model may be adjusted or trained based on the identified clusters and the reduced-dimension profile vectors. In various embodiments, the training may be supervised or unsupervised.
At step 312, the singular vectors and, in some embodiments, weights for the neural network model or other learning algorithm may be provided to the client device 200, and in some embodiments, to one or more content servers 250.
At step 314, the client device 200 may compute a dimensionality reduction of the profile vector or access log of the device by using the singular vectors received from the classifier server. At step 316, the reduced-dimension vector may be classified via artificial intelligence or neural networks by using the model parameters received from the classifier server, and the classification is determined at step 318. Determining the classification may include calculating a score or ranking for each of a plurality of clusters for a profile vector of the device (e.g., identified by a classifier server and provided via the parameters in some embodiments).
At step 320, the client device may transmit a request for a content item to one or more content servers 250. The request may include an identification of a cluster corresponding to a profile vector of the device. The request may be generated in response to executing the script on the web page after playback of the media item or a portion of the media item is complete or any other such condition.
At step 322, the content server may determine characteristics of the clusters based on the classifier model parameters and singular vectors received from the classifier server. In some implementations, the content server can use the singular vectors to compute a profile vector representing an aggregate browsing history for all devices in a cluster, and can then infer characteristics of the cluster based on aspects of the history (e.g., keywords/topics associated with web pages or domains or other content, other associated domains or web pages, etc.). At step 324, the content server may select a content item using the cluster identification in the request (or the inferential properties associated with the cluster as discussed above). The content may be transmitted to the client device at step 326, and the client device may render or display the content item at step 328.
Thus, the systems and methods discussed herein provide content quasi-personalized or anonymized content retrieval via the aggregated browsing history of a large number of devices, such as millions or billions of devices. The sparse matrix may be constructed from the aggregated browsing history and reduced in dimension, thereby reducing entropy and providing anonymity for individual devices. Relevant content may be selected via quasi-personalized clusters representing similar browsing histories without exposing the details of the individual devices to the content provider.
In a networked environment, an application (e.g., a web browser) running on a client device can receive an information resource (e.g., a web page) having primary content provided by a content publisher and one or more content slots (e.g., an inline frame) for supplemental content. The information resources can include code segments or scripts (e.g., content selection tags) for specifying retrieval of content items of the content provider from the content selection service for insertion into the content slots. Upon parsing the script of the information resource, the application can generate a request for content to be inserted into the content slot and can send the request to a content selection service. In response to receiving the request, the content selection service can select one of the content items provided by the content provider to embed in the content slot of the information resource.
Selection of a content item by a content selection service may rely on the use of a deterministic tracking identifier that is unique to the user (or via an account), a client device operated by the user, or an application running on the client device. The identifier can be maintained on the client device and accessed by the content selection service via a cookie. The Cookie may be, for example, a third party Cookie associated with a domain of the content selection service that is different from the domain of the content publisher of the information resource. When the content slot of the information resource specifies retrieval of content from the content selection service, a cookie containing the identifier can be passed from the client device to the content selection service. By using cookies, the content selection service is able to track which information resources a user has accessed via an application running on a client device. Additionally, the content selection service can identify content items determined to be relevant to a user operating the application on the client device based on the tracked information resources.
While the use of these unique tracking identifiers allows for the selection of content items that are customized for a particular user, there may be a number of disadvantages, particularly with respect to data security and integrity. Once, the user can be exposed to data security risks by user data communicated between the client device and the content selection service. For example, an administrator of the content selection service can intentionally provide private user data to third parties without user consent. Further, unauthorized malicious entities can intercept third party cookies in transit and can use unique tracking identifiers to monitor online activity of affected client devices and applications. Again, using such identifiers to access a collection of information resources may increase the risk of data leakage for the content selection service. For example, accidental release of data or malicious attacks to infiltrate collected data (portions of which can be individually traced back to a particular user) may result in loss of data privacy for the user.
One method for addressing concerns for a unique tracking identifier may include disabling a third party cookie having a unique tracking identifier from a client device. An application running on the client device can be configured to disable generation, maintenance, or transmission of the unique tracking identifier to the content selection service. The limitation of third party cookies may create many other problems. With third party cookies disabled, the content selection service may not be able to track which information resources are accessed by the client device via the application. Thus, when a request for content is received, the content selection service may not be able to use such information in determining the relevance of a content item to the user operating the application. Thus, the selected content item may have a lower likelihood of interacting with the user of the client device than the content item selected through use of the tracking identifier. As a result, the information resources on which the content item is inserted for display may suffer degradation in the quality of human-computer interaction (HCI).
To address the technical challenges in prohibiting the use of unique identifiers to track individual client devices or applications when selecting content, each application can categorize itself into one of a plurality of clusters based on a locally maintained browsing history. Applications and even users operating the applications in a similar browsing mode can be categorized into the same cluster. Users having similar browsing patterns and categorized in the same cluster can be associated as having similar characters and interests and therefore are more likely to have similar responses to the same content item. Each cluster can have a large number of associated users (e.g., greater than 1000), so categorizing users into clusters may not be an individual user-specific characteristic.
When assigning the application itself to one of the clusters, the application can convert or encode the browsing history into a vector having preset dimensions. The vectors may be sparse and have a high dimensionality. For example, one element in the feature vector can indicate whether a user has visited a particular domain, a portion of a website, a particular category (e.g., vacation) of web pages, or even a particular URL at a particular time slot (e.g., at a particular hour of the day and a particular day of the week). The application can then apply a dimension reduction technique (e.g., a linear reduction, a non-linear reduction, or a random projection technique) to map the vector to another vector of a lower dimensional space. The application can then apply a clustering or classification algorithm (e.g., k-nearest neighbor algorithm, linear classification, support vector machine, and pattern recognition) to the reduced vectors to identify the cluster to which the application, and even the user, is to be assigned. The clustering algorithm can be provided and updated by an application manager (e.g., browser vendor) for the application.
In finding a cluster by using a clustering algorithm, the application can identify a cluster identifier (also referred to as a class identifier or a browsing history identifier) for the cluster. A cluster identifier can be assigned to each cluster by the application manager and can be provided to the application and content selection services. In contrast to a unique deterministic tracking identifier, a cluster identifier may not be specific to an individual user, application, or client device. Since multiple users can be categorized into the same cluster, the cluster identifier can also be shared among multiple users, applications, or client devices having similar browsing patterns. Because the cluster identifier is shared among multiple users, the cluster identifier has a lower entropy than the unique tracking identifiers assigned to individual users. For example, a deterministic unique tracking identifier for all internet users can have an entropy of over 30 bits, while a cluster identifier can be set to an entropy of 18 to 22 bits. At lower entropy, the cluster identifier itself may have a smaller length and size than the unique tracking identifier.
When an information resource having a content slot is received, the application can include a cluster identifier, rather than a unique tracking identifier, into a request for content for the content slot and send the request to a content selection service. Additional protective measures can be taken to improve data security and integrity, and reduce the likelihood of leakage of cluster identifiers and related information. To protect the interception of the cluster identifier during transmission over the network, the application can use an encryption protocol, such as the secure hypertext transfer protocol secure (HTTPS) protocol. Further, to protect the cluster identifier maintained on the client device, the application can restrict other client-side processes (e.g., JavaScript on the information resource) from accessing the cluster identifier. For example, the cluster identifier can be included in a security token or HTTP token-only cookie maintained on the client device to prevent access to the cluster identifier. This may be in contrast to third party cookies that do not have such access control.
In response to receiving the request, the content selection service can select one of the content items using the cluster identifier. The content selection service can accumulate browsing history for users categorized as clusters by using previous requests for content containing cluster identifiers for the clusters. Applying a profile model to the accumulated history for the cluster, the content selection service can infer the personality and interests of the user in the cluster. Using the results of the profile model, the content selection service is able to find content items that are determined to be relevant to the cluster into which the user associated with the request is categorized.
By using the cluster identifier, the browsing history of applications maintained on the client device may be prevented from being accessed by the content selection service so that the browsing history may be tracked to a particular user, application, or client device. Additionally, the content selection service may not be able to track individual users, applications, or client devices across different domains to compile detailed browsing histories. Alternatively, the content selection service can aggregate browsing history of particular clusters of users associated with the cluster identifier received from the application. At aggregation, the content selection service can protect the data privacy of individual users by merging the browser histories of different users from the same cluster. By setting the number of users to be assigned to each cluster, the degree of data privacy can also be controlled.
Further, under the assumption that users in the same cluster have similar browsing patterns, the content selection service can extrapolate and determine similar traits and interests for users of the same cluster based on the browsing history aggregated for the cluster. The content selection service is also able to select content items that expect that users of the same cluster will respond similarly. In this manner, data security, integrity, and privacy over the browsing history of individual users can be maintained. At the same time, with the ability to determine relevance in the selection of content items, the quality of human-computer interaction (HCI) with the selected content items or the entire information resource can be maintained.
Referring now to FIG. 4, depicted is a block diagram depicting one embodiment of a computer network environment or system 400 for encoding identifiers for content selection using a classification model. In general, the system 400 can include at least one network 405 for communicating among the components of the system 400. The system 400 can include at least one application manager service 410 (also referred to herein as a browser provider) to provide services for at least one application (e.g., browser). The system 400 can include at least one content provider 415 to provide content items. The system 400 can include at least one content publisher 420 to provide information resources (e.g., web pages). The system 400 can include at least one content selection service 425 to select content items. System 400 can include one or more client devices 430A-N (generally referred to herein as client devices 430). Each client device 430 can include at least one application 435A-N (generally referred to herein as application 435). Each of the components of system 400 (e.g., network 405, application manager service 410 and components thereof, content provider 415 and components thereof, content publisher 420 and components thereof, content selection service 425 and components thereof, and client device 430 and components thereof) can be implemented using the components of computing system 900 detailed herein in connection with fig. 9.
In more detail, the network 405 of the system 400 can communicatively couple the application manager service 410, the content provider 415, the content publisher 420, the content selection service 425, and the client device 430 to one another. Each of the application manager service 410, content provider 415, content publisher 420, and content selection service 425 of the system 400 can include a plurality of servers located in at least one data center or server farm that are communicatively coupled to one another via a network 405. The application manager service 410 is capable of communicating with content providers 415, content publishers 420, content selection services 425, and client devices 430 via the network 405. Content provider 415 can communicate with application manager service 410, content publisher 420, content selection service 425, and client device 430 via network 405. The content publisher 420 can communicate with the application manager service 410, the content publisher 420, the content selection service 425, and the client device 430 via the network 405. The content selection service 425 is capable of communicating with the application manager service 410, the content provider 415, the content publisher 420, and the client device 430 via the network 405. Each client device 430 is capable of communicating with the application manager service 410, the content provider 415, the content publisher 420, and the content selection service 425 via the network 405.
The application manager service 410 can include a server or other computing device operated by an application provider (sometimes referred to herein as a browser provider) to provide resources and updates to applications 435 running on the client device 430. For example, the application manager service 410 can provide the application 435 for installation to the client device 430. The application manager service 410 can also provide updates to applications 435 installed on the client device 430. The update can affect at least one of the subcomponents of the application 435. The application manager service 410 can also provide plug-ins or attachments to the applications 435 to augment the functionality of the applications 435 running on the client device 430. The application manager service 410 can communicate with the content selection service 425 to provide information about applications 435 running on the client device 430. The provision of applications 435 and related files or data can be communicated by the application manager service 410 over the network 405.
The content publisher 420 can include a server or other computing device operated by a content publishing entity to provide information resources including primary content for display via the network 405. For example, the content publisher 420 can include a web page operator that provides primary content for display on an information resource. The information resources can include content other than that provided by the content publisher 420, and the information resources can include content slots configured to display content items from the content provider 415. For example, the content publisher 420 can operate a website of a company and can provide content about the company for display on a web page of the website. The Web page can include a content slot configured to display content items provided by the content provider 415 or by the content publisher 420 itself. In some implementations, the content publisher 420 includes a search engine computing device (e.g., a server) of a search engine operator operating a search engine website. The primary content of the search engine web page (e.g., results or login web page) can include the results of the search as well as third party content items displayed in content slots of the information resource, such as content items from content provider 415. In some implementations, the content publisher 420 can include one or more servers for providing video content.
The content selection service 425 can include a server or other computing device operated by a content placement entity to select or identify content items to be inserted into content slots of an information resource via the network 405. In some implementations, the content selection service 425 can include a content placement system (e.g., an online advertising server). The content selection service 425 can maintain a list of content items to select from to provide over the network 405 for insertion into content slots of the information resources. The manifest may be maintained on a database accessible to content selection service 425. The content item or an identifier (e.g., address) of the content item can be provided by the content provider 415.
Each client device 430 may be a computing device for communicating via the network 405 to display data. The displayed data can include content (e.g., information resources) provided by the content publisher 420, as well as content (e.g., content items for display in content slots of the information resources) provided by the content providers 415 as identified by the content selection service 425. Client devices 430 can include desktop computers, laptop computers, tablet computers, smart phones, personal digital assistants, mobile devices, consumer computing devices, servers, clients, digital video recorders, set-top boxes for televisions, video game consoles, or any other computing devices configured to communicate via network 405. Client device 430 may be a communication device through which an end user can submit a request to receive content. The request can be a request for a search engine, and the request can include a search query. In some implementations, the request can include a request to access a web page.
Applications 435 executing on client device 430 can include, for example, an internet browser, a mobile application, or any other computer program capable of executing or otherwise invoking computer-executable instructions provided to client device 430, such as computer-executable instructions included in information resources and content items. The information resources included therein can correspond to scripts, logic, tags, or instructions (e.g., hypertext markup language (HTML), extensible hypertext markup language (XHTML), extensible markup language (XML), Cascading Style Sheets (CSS), and JavaScript, or any combination thereof). The content item may be inserted into a content slot of the information resource.
Referring now to FIG. 5, depicted is a block diagram depicting one embodiment of a client device 430 and an application management service 410 in a system 400. In general, the application manager service 410 can include at least one classification model 500 to classify applications 435 based on browsing patterns. The application manager service 410 can include at least one model trainer 505 to train and maintain at least one classification model 500. The application manager service 410 can include at least one model updater 510 to change or adjust the classification model 500. The application manager service 410 can include at least one database 515 to store and maintain a set of class identifiers 520A-N (generally referred to herein as class identifiers 520). The applications 435 on each client device 430 can include at least one classification model 500 to categorize the applications 435 based on browsing patterns. The application 435 can include at least one model trainer 505 to train and maintain the classification model 500. The application 435 can include at least one model applicator 525 to categorize the application 435 using the classification model 500. Model trainer 505 and model applicator 525 may be an integral part of application 435, an accessory or plug-in to application 435, or a separate application that interfaces with application 435. The application 435 can include at least one browsing history 530 to maintain and store one or more entries 535A-N (generally referred to herein as entries 535). The application 435 can include at least one identifier cache 540 to maintain and store at least one class identifier 520 of the application 435.
In more detail, the classification model 500 can classify, group, or otherwise categorize each application 435 (or each client device 430 running the application 435 or an account associated with the application 435) based on the browsing history 530. The classification of the application 435 on the client device 430 can indicate or represent a classification of an instance of the application 435 running on the client device 430. For example, there can be an instance of one application 435 (e.g., a web browser) running on one client device 430 and another instance of the application 435 (e.g., the same type of web browser) running on another client device 430. The two instances can be classified as the same category or different categories. Further, the classification of the application 435 can extend to a classification corresponding to or including a user associated with an account operating the application 435 or a client device 430 operated by the user.
The classification model 500 may be a classification or clustering model or algorithm. The classification model 500 can include classification algorithms, such as linear classifiers (e.g., linear regression, logarithmic regression and naive Bayes classifier), Support Vector Machines (SVM), quadratic classifiers, k-nearest neighbor algorithms, Artificial Neural Networks (ANN), and so forth. The classification model 500 can include clustering models such as centroid-based clustering algorithms (e.g., k-means algorithm or Expectation Maximization (EM) algorithm), density-based clustering algorithms (e.g., density-based noise application spatial clustering (DBSCAN)), distribution-based clustering algorithms (e.g., gaussian mixture model), Artificial Neural Networks (ANN), and so forth. The classification model 500 can also include hash functions, such as location-sensitive hashing schemes (e.g., MinHash, SimHash, and nilsmisa hashing), and so forth.
The classification model 500 can include an input set, a parameter set, and an output set according to any of classification or clustering models and algorithms. The input set can accept or include entries 535 of the browsing history 530. In some implementations, the input set can accept or include a reduced-dimension representation of an entry 535 of the browsing history 530. The set of parameters (or weights) can connect or associate the input set with the output set. In some implementations, a parameter set can include many classes and values for each class. For example, a parameter set may be the centroid in a k-means cluster for each class. In another example, a parameter set may include a range of values associated with each class. The number of classes can equal the number of class identifiers 520. The number of classes and the number of class identifiers 520 can be predetermined (e.g., as fixed values) or dynamically determined. The output set can generate or include a class corresponding to one of the class identifiers 520. The output set can include one of the class identifiers 520 themselves. For example, the class identifier 520 may be a hash value calculated using a hash function. Each class identifier 520 may be or include an alphanumeric character set or a numeric value (e.g., an integer or binary number).
In training the classification model 500, the model trainer 505 can use the training data set to change, adjust, or otherwise set the values of the parameters (e.g., the values of each class) in the classification model 500. At each iteration, the model trainer 505 can determine whether the classification model 500 has converged with respect to the previous iteration based on changes in the set of values of the parameters. In some implementations, the model trainer 505 can compare the changes in the set of values in the parameters for the classification model 500 to a convergence threshold. If the change is less than the convergence threshold, the model trainer 505 can determine that the classification model 500 has converged. Otherwise, if the change is greater than the convergence threshold, the model trainer 505 can determine that the classification model 500 has not converged. When the classification model 500 is determined to have not converged, the model trainer 505 can continue to train the classification model 500.
Otherwise, when the classification model 500 is determined to have converged, the model trainer 505 can end, terminate, or stop training the classification model 500. The model trainer 505 can store the classification model 500 on the application manager service 410. Further, the model trainer 505 can transmit or send the classification model 500 to an application 435 running on the client device 430. In some implementations, the model trainer 505 can transmit or send the set of parameters for the classification model 500. For each class in the classification model 500, the model trainer 505 can identify, assign, or otherwise associate the class to a corresponding class identifier 520. The class identifier 520 may be a set of alphanumeric characters used to reference the class. The classification model 500 can associate each class to a corresponding class identifier 520. The model trainer 505 can communicate and provide a set of class identifiers 520 to the application 435 running on each client device 430 and to the content selection service 425.
The model trainer 505 of the application 435 executing on the client device 430 is also capable of training the classification model 500. In some implementations, the model trainer 505 can train the classification model 500 using a distributed learning protocol. The distributed learning protocol can be consistent with applications 435 and application manager services 410 executing on other client devices 430 communicating over the network 405. The distributed learning protocol can include joint learning, for example, by training the classification model 500 using an optimization algorithm (e.g., Stochastic Gradient Descent (SGD) or averaging). As discussed above, the number of classes and the number of class identifiers 520 can be predetermined (e.g., fixed values) or dynamically determined. During each iteration, each model trainer 505 is able to change, adjust, or otherwise set the values of the parameters (e.g., the values of each class) in the classification model 500 by using the training data set. At the end of the iteration, each model trainer 505 can provide the values of the parameters in the classification model 500 (e.g., the values of each class) to each other. The model trainer 505 can use the received values of the parameters to adjust, change, or set parameters on the locally maintained classification model 500. The model trainer 505 can repeat the iterations until it is determined that the classification model 500 has converged with respect to the previous iteration based on the change in the set of values of the parameters, as discussed above.
The model updater 510 executing on the application manager service 410 can provide or send updates to the classification model 500 maintained on each client device 430 running on the application 435. The model updater 510 can determine whether to update the classification model 500 in accordance with a model update policy. The model update policy can specify a set of conditions under which the classification model 500 is to be updated. In some implementations, the model update policy can include a schedule indicating a time at which the classification model 500 is to be updated. The model update policy can specify: the classification model 500 will be updated when the number of applications 435 assigned to each class is unevenly distributed (e.g., the difference in class sizes is within 5% to 100% of another class). The model update policy can specify: the updated classification model 500 will be updated when the amount of accumulated additional browsing history 530 satisfies a threshold amount. If it is determined that the classification model 500 is not to be updated, the model updater 510 can maintain the classification model 500.
On the other hand, if the determination is to update, model updater 510 can invoke model trainer 505 (an application 435 running on application manager service 410 or across client devices 430) to retrain classification model 500. In some implementations, model updater 510 can accumulate browsing history 530 of training data sets from content providers 415, content publishers 420, content selection service 425, or applications 435 running on client device 430. The model updater 510 can pass the accumulated browsing history 530 to the model trainer 505 to retrain the classification model 500. Upon determining that the classification model 500 has converged, the model trainer 505 can end, terminate, or stop training the classification model 500. The model updater 510 can communicate or send the retrained classification model 500 (or the set of parameters for the classification model 500) to each application 435 to update the model 510. Model updater 510 is able to communicate and provide a set of class identifiers 520 to applications 435 running on each client device 430 and to content selection service 425.
A model applicator 525 of an application 435 executing on a client device 430 can receive the classification model 500 from the application manager service 410 via the network 405. Upon receipt, model applicator 525 can store and maintain classification model 500 on client device 430. In some implementations, the model applicator 525 can receive a set of parameters for the classification model 500 from the application manager service 410. The set of parameters may be received in order to update the classification model 500. Upon receipt, the model applicator 525 can change, configure, or otherwise modify the classification model 500 by using the received set of parameters. Further, model applicator 525 can receive a set of class identifiers 520 for classifying classes in model 500 from application manager service 410. The class identifier 520 may be received as part of updating the classification model 500.
With the configuration of classification model 500, model applicator 525 is able to identify browsing history 530 maintained by application 435 on client device 430. The application 435 is able to maintain a browsing history 530 by creating an entry 535 whenever an information resource is accessed. The browsing history 530 can record information resources (e.g., web pages) and other online content accessed via the application 435. The browsing history 530 can include a collection of entries 535. Each entry 535 can include an address of the information resource being accessed (e.g., a Uniform Resource Locator (URL) including a host name and a pathname of the web page) and a timestamp indicating the time when the information resource was accessed. The set of entries 535 can be indexed by a timestamp or address of an information resource within the browsing history 530. In some implementations, the model applicator 525 can identify a portion of the browsing history 530 over a time horizon for further processing by the model applicator 525. A portion of the browsing history 530 can include a subset of entries 535 having timestamps within the time range. The time range may be, for example, a week amount of entry 535 from the current time.
In identifying the browsing history 530, the model applicator 535 can use the entries 535 of the browsing history 530 to form or generate a set of feature vectors. A set of feature vectors may be used as input to the classification model 500. The set of feature vectors can include or can be defined by dimensions. The dimensions can include a time range (e.g., hours of a day or days of a week) and address attributes (e.g., domain name, a portion of a website, a subject category, or the address itself). Each feature vector can be associated with at least one of the time ranges based on a timestamp associated with the corresponding entry 535. Each feature vector can be associated with at least one of the address attributes of the information resource based on the address of the information resource identified in the corresponding entry 535. In some implementations, the model applicator 535 can generate a set of feature vectors by projecting the entries 535 of the browsing history 530 onto dimensions of the feature vectors defined by the time range and address attributes. For each entry 535 of the browsing history 530, the model applicator 535 can identify whether an existing feature vector exists based on the address and timestamp in the entry 535. To identify, the model applicator 525 can determine whether the entry 535 matches any of the existing feature vectors. When existing feature vectors exist, the model applicator 535 can add the entry 535 to the feature vector. Conversely, when an existing feature does not exist, model applicator 535 can create a new feature vector for entry 535.
The model applicator 535 can use a dimension reduction process to form or generate a reduced feature vector set. The dimensionality reduction process can include linear reduction techniques (e.g., Principal Component Analysis (PCA), Singular Value Decomposition (SVD), non-and Negative Matrix Factorization (NMF)), non-linear dimensionality reduction (e.g., Generalized Discriminant Analysis (GDA), local linear embedding, and Sammon mapping), or other techniques (e.g., Johnson-lindenstruuss lemma and multi-factor dimensionality reduction), among others. In some implementations, the model applicator 525 can apply a dimension reduction process when projecting the entries 535 of the browsing history 530 onto the dimensions of the feature vectors. In some implementations, the model applicator 535 can apply a dimension reduction process to the generated feature vector set. In the case where a dimension reduction process is applied, the model applicator 535 can reduce the dimensions among the original set of feature vectors to generate a reduced set of feature vectors. The reduced feature vector set can have fewer dimensions and data points than the initial reduced feature vector set. For example, the reduced feature vector set can omit the time range or address attributes without any associated entries 535.
The model applicator 525 can apply the classification model 500 to the browsing history 530 (or any subset or representation of the entries 535 of the browsing history 530, such as feature vectors) to identify classes 435 within which to classify the application. For application, the model applicator 525 can feed the browsing history 530 as a set of inputs to the classification model 500. In some implementations, the model applicator 525 can feed the feature vectors or reduced set of feature vectors as inputs to the classification model 500. Once fed, the model applicator 525 can use the classification model 500 to compare the input to the parameters used to define the class and generate or produce a set of outputs based on the comparison. The output set can include classes to which the browsing patterns as indicated in the browsing history 530 maintained by the application 435 are to be categorized. Model applicator 525 can identify classes from the output of classification model 500. The identified class may correspond to one of many classes as defined by the classification model 500. The identified class of the application 435 running on the client device 430 can be shared, or the same as the identified class of at least some other applications 435 running on other devices 430. As discussed above, each class defined by the classification model 500 can have many client devices to be classified into that class.
Based on the identified class, model applicator 525 can assign application 435 to the class identifier 520 to which the class corresponds. In some implementations, the model applicator 525 can use the classification model 500 to identify class identifiers 520 associated with the identified classes. With this identification, model applicator 525 can then assign class identifier 520 to application 435. Assigning the class identifier 520 to the application 435 can indicate: the browsing history 530 of the application 435 is similar to the other browsing histories 530. Other browsing histories 530 on other applications 435 with the same class identifier 520. The class identifiers 520 assigned to the applications 435 running on the client device 430 can be shared, or the same with the class identifiers 520 of at least some other applications 435 running on other client devices 430.
At assignment time, model applicator 525 can store and maintain class identifiers 520 onto identifier cache 540. For example, as depicted, the model applicator 525 of the first application 435A may have identified the first application 435A as having a similar browsing pattern as the other applications 435B-N having a class corresponding to the first class identifier 520A. The identifier cache 540 can control access to scripts executed by the application 435 from the access class identifier 520. In some implementations, the model applicator 525 can store the class identifier 520 in a secure cookie maintained on the identifier cache 540. The secure cookie can include a cookie with a secure flag or only an HTTP flag set. The secure cookie can prevent scripts on the information resource from accessing the class identifier 520 maintained on the identifier cache 540. In addition, the secure cookie can allow authorized entities to access the class identifier 520 stored on the identifier cache 540. The secure cookie can identify the content selection service 425 or the application manager service 410 as being allowed to access the class identifier 520 on the identifier cache 540.
The model applicator 535 can determine whether to apply the classification model 500 in accordance with the identifier assignment policy. The identifier assignment policy can specify a set of conditions under which the classification model 500 is to be applied for reassignment of the class identifiers 520. In some implementations, the identifier assignment policy can include a schedule indicating a time at which the classification model 500 is to be applied. The identifier assignment policy can specify: the classification model 500 will be updated when new updates to the application 435 are provided by the application manager service 410. The identifier assignment policy can specify: the classification model 500 will be applied when the number of additional browsing histories 530 accumulated meets a threshold amount. If it is determined that the classification model 500 is not to be reapplied, the model applicator 525 can maintain the class identifier 520. On the other hand, if the determination is to reapply the classification model 500, the model applier 525 can repeat the above-described functions. For example, the model applicator 525 can identify the browsing history 530, generate a reduced feature vector set using a dimension reduction process, apply the classification model 500 to the reduced feature vector set to identify the class, and assign a classifier identifier 520 associated with the identified class to the application 435.
Referring now to FIG. 6, depicted is a block diagram depicting one embodiment of a client device 430, a content provider 415, a content publisher 420, and a content selection service 425 in a system 400. In general, the application 435 on each client device 430 (e.g., as depicted for the first client device 430A) can include at least one resource handler 615 to handle reading and parsing of at least one information resource 600 and other data in communication with the content provider 415, the content publisher 420, or the content selection service 425.
In more detail, the resource handler 615 executing on the client device 430 can receive the information resource 600 from the content publisher 420. The receipt of the information resource 600 can be in response to a request for the information resource 600 sent by the application 435 to the content publisher 420 and can be used for presentation at the client device 430. The received information resource 600 (e.g., a web page) can include at least one primary content 605 (e.g., a body, text, and image of the web page) and at least one content slot 610 (e.g., an inline frame of the web page). The primary content 605 can correspond to a portion of the information resource 600 provided by the content publisher 420. The content slot 610 can be available to receive content from the content provider 415 or the content selection service 425. The content to be inserted into the content slot 610 can have a host name that is different from the host name of the information resource 600. Once received, the resource handler 615 is able to parse the information resource 600, which includes the primary content 605 and the content slots 610.
For a content slot 610 of the information resource 600, the resource processor 615 can generate requests 620A-N (generally referred to herein as requests 620 for content) to send to the content selection service 425. The request for content 620 can be generated according to a script (e.g., an advertisement tag or a content selection tag) for inserting content into the content slot 610. The script for the content slot 610 can be embedded or included in the content slot 610 itself or another portion of the information resource 600. In generating the request 620 for content, the resource processor 615 can include addresses 625A-N (generally referred to herein as address 625) into the request 620 for content. The address 625 can reference the content selection service 425 specified by the script for the content slot 610, such as a URL for the content selection service 425. The address 625 can indicate a destination address to which the request for content 620 is to be routed. In addition, the resource handler 615 can include a source address that references the client device 430 into the request for content 620. The resource handler 615 can also include an address corresponding to the content publisher 420 that provided the information resource 600 to the application 435.
Additionally, the resource handler 615 can include a class identifier 520 identified for the application 435 into the request 620 for content. In some embodiments, the resource processor 615 can access the identifier cache 540 to retrieve the class identifier 520. Once retrieved, the resource handler 615 can include the class identifier 520 to include the request 620 for content. In some implementations, the request for content 620 is initially generated by the application 435 when parsing the script for the content slot 610 and can originally include the unique tracking identifier. The resource processor 615 can remove or otherwise exclude from the request for content 620 any unique tracking identifiers corresponding to the application 435 (or the client device 430 running the application 435 or an account associated with the application 435). The unique tracking identifier can include, for example, a cookie user identifier corresponding to an account associated with the application 435, or a cookie device identifier corresponding to the client device 430 running the application 435. The unique tracking identifier may have been provided by content provider 415 or another content placement service. Once removed, the resource handler 615 can include the class identifier 520 into the request 620 for content. In some implementations, the resource processor 615 can replace the unique tracking identifier included in the request for content 620 with the class identifier 520.
In some implementations, the resource handler 615 can wrap or include the class identifier 520 into cookies 630A-N (hereinafter generally referred to as cookies 630). In some implementations, a cookie 630 can be generated in connection with the request for content 620. In some implementations, the cookie 630 can be retrieved from the application 435 (e.g., the identifier cache 540). The Cookie 630 can have a security flag or only an HTTP flag set to prevent unauthorized entities from intercepting and accessing the class identifier 520. Unauthorized entities can include entities other than content selection service 425 or application manager service 410. The cookie 630 can also restrict access to the class identifier 520 over a secure communication channel (e.g., Hypertext Transfer Protocol Secure (HTTPs)) over the network 405 by setting a secure flag or HTTP only flag. The resource handler 615 can include a cookie 630 including the class identifier 520 into the request for content 620. The Cookie 630 can also include an address corresponding to the content publisher 420 that provided the information resource 600 to the application 435. Upon generation, the resource processor 615 can communicate a request 620 for content to the content selection service 425 via the network 405. In some implementations, the application 435 can establish a secure communication channel (e.g., in accordance with HTTP) between the client device 430 and the content selection service 425 to communicate the request 620 for content. The establishment of the channel can allow the content selection service 425 to access the class identifier 520 included in the cookie 630 of the request 620 for content.
The class identifiers 520A-N assigned by the respective model applicators 525 to the different applications 435A-N running on the client devices 430A-N may not be specific to one application 435A-N and may not uniquely identify the applications 435A-N. For example, as depicted, a first type identifier 520A may have been assigned to a first application 435A on a first client device 430A and a second application 435B running on a second client device 430B. In contrast, the second-type identifier 520B may have been assigned to the nth application 435N running on the nth client device 430N. This may be in contrast to a unique tracking identifier, such as a user or client identifier that specifically identifies an application 435A-N or client device 430A-N provided by the content provider 415 or other content placement service. Further, since the class identifiers 520A-N may not uniquely identify each application 435 running on the client device 430, the class identifiers 520A-N can have a lower entropy than such unique tracking identifiers. For example, the entropy of the unique tracking identifier can have an entropy greater than 63 bits, whereas the entropy of the class identifiers 520A-N can have an entropy between 18 and 52 bits. Thus, the class identifiers 520A-N can be smaller in size than these unique tracking identifiers, thereby reducing the size of the request for content 620 sent over the network 405.
Referring now to FIG. 7, depicted is a block diagram depicting one embodiment of a client device 430 and a content selection service 425 in a system 400. The content selection service 425 can include at least one history aggregator 700 to store and maintain browsing records. The content selection service 425 can include at least one class characterizer 705 to determine the selection parameters for each class. The content selection service 425 can include at least one content placer 710 to identify content items 725A-N (hereinafter generally referred to as content items 725) for the application 435 associated with the request 620 using the identified classes. The content selection service 425 can include at least one history database 715 to maintain and store browsing history entries 720A-N (generally referred to herein as entries 720) of the class identifiers 520.
In more detail, the history aggregator 700 executing on the content selection service 425 is able to collect, aggregate, or otherwise maintain the history database 715 through the use of cookies 630 included in the request for content 620 received from the client device 430. The history database 715 can include a collection of entries 720 indexed by class identifiers 520 defined by the application manager service 410. Each entry 720 can include an address of the accessed information resource 600 and a timestamp indicating the time at which the information resource 600 was accessed. Rather than aggregating the browsing history of the client device 430 through the use of a unique tracking identifier (e.g., a cookie identifier), the history aggregator 700 can aggregate the browsing history through the class identifier 520. Unlike the browsing history 530 maintained on each individual application 435, the history database 715 may not separately identify the application 435 (or the user associated with the application 435) from which the entry 720 was generated. Each time a request 620 for content is received, the history aggregator 700 can identify an address corresponding to the information resource 600 on which the content will be returned. The history aggregator 700 can also identify the class identifier 520 included in the request for content 620. With these identifications, the history aggregator 700 can add an entry 720 including an address and a timestamp (not shown in FIG. 4) to the set of entries 720 including the class identifier 520 in the request for content 620.
A class characterizer 705 executing on the content selection service 425 can determine one or more characteristics of each class based on the entry 720 of the class identifier 520 for the class. The characteristics can include, for example, a common personality, profile, behavior, or interest of the class corresponding to the class identifier 520. In some implementations, the class characterizer 705 can use a class profile model to determine the characteristics of the class based on the set of entries 720 in the historical database 715 of class identifiers 520. The profile-like model may be any model, such as linear regression, logistic regression, Artificial Neural Networks (ANNs), Support Vector Machines (SVMs), Honeyu Bayesian classifiers, and the like. The class profile model may have been trained by using a sample data set that associates the browsing history tagged by the class identifier 520 with certain characteristics. The class profile model can convert the entry 720 for each class identifier 520 on the history database 715 into the characteristics of the corresponding class. In some embodiments, the class characterizer 705 can store and maintain characteristics of each class identifier 520.
The content placer 710 executing on the content selection service 425 is able to select or identify a content item 725 from a collection of content items 725 in response to a request 620 for content by using the class identifier 520. The use of the class identifier 520 may be in contrast to the use of a unique identifier for a particular user associated with a request for content, as the selection of the content item 725 may not be based on an identifier that is unique to the particular user. Each content item 725 can include an object or element to be embedded, inserted, or otherwise added to the content slot 610 of the information resource 600. Each content item 725 can be provided by one or more of the content providers 415. Upon receipt, the content placer 710 can parse the request for content 620 to identify the class identifier 520. Upon identification, the content placer 710 can identify the characteristics of the class corresponding to the class identifier 520. The content placer 710 is able to identify or select content items 725 that are associated with the characteristics of the class. In some implementations, the content placer 710 can select the content item 725 using a content placement process. The content placement process can use models such as linear regression, logistic regression, Artificial Neural Networks (ANNs), Support Vector Machines (SVMs), naive Bayes classifiers, and the like. For each content item 725, the content placement process can calculate, determine, or generate a predicted likelihood of interaction by the user in the class corresponding to the class identifier 520 included in the request for content 620. The content placer 710 can identify the content item 725 that is most likely to be interacted with by users in the class. Once selected, the content placer 710 can transmit the content item 725 to the client device 430 that initiated the request 620 for content. In some implementations, the content placer 710 can send the address of the content item 725 to the client device 430 for the application 435 to retrieve the selected content item 725 from the content provider 415.
Referring back to FIG. 6 in conjunction with FIG. 7, the resource handler 615 can receive a content item 725 identified by the content selection service 425. The resource handler 615 can embed, insert, or add the content item 725 into the content slot 610 of the information resource 600. In some implementations, the resource processor 615 can receive an address of the content item 725. The address of the content item 725 can reference the content provider 415. The resource handler 615 can send another request to the content provider 415 to retrieve the content item 725 and insert the content item 725 into the content slot 610 of the information resource 600.
In this manner, the content selection service 425 is able to select the content item 725 as desired by users associated with the same class identifier 520 that are expected to have similar responses. In addition, data security, integrity, and privacy over the individual user's browsing history 530 can be preserved. At the same time, with the ability to determine relevance to individual classes when selecting content items 725, the quality of human-computer interaction (HCI) with the entire information resource 600 can be maintained.
Referring now to FIG. 8, depicted is a flow diagram depicting one embodiment of a method 800 for encoding an identifier for content selection using a classification model. The functionality described herein with respect to the method 800 can be performed by the system 400 as shown in fig. 4 or the computing device as shown in fig. 9 or otherwise. In summary, an application running on a client device can identify a browsing history (805). The application is capable of reducing the dimension (810). The application can apply a classification model (815). The application is capable of identifying a class (820). The application can assign a class identifier (825). The application is capable of receiving an information resource (825). The application can generate a request for content (835). The application can include a class identifier (840). The application can transmit a request for content (845). The application can receive the selected content item (850). The application can determine whether to reassign (855). If not, the application can maintain a class identifier (860).
In more detail, an application (e.g., application 435) on a client device (e.g., client device 430) can identify a browsing history (e.g., browsing history 530) (805). The browsing history can include a collection of items (e.g., item 535). Each entry can include an address of the information resource being accessed and a timestamp identifying the time at which the information resource was accessed. The application is capable of generating a set of feature vectors from a set of entries of a browsing history. The feature vector may be a projection of the browsing history onto a set of dimensions. The dimensions can include time ranges and address attributes, among others. The application is capable of reducing the dimension (810). Using a dimension reduction process, the application is able to generate a reduced feature vector set from the initial feature vector set.
The application can apply a classification model (e.g., classification model 500) (815). The classification model can include an input set, a parameter set, and an output set. The input set can include entries of the browsing history or representations of the browsing history. The parameter set can associate an input with an output. The output set can include classes into which a user interacting with the application is to be categorized based on a browsing history by the user on the application. The application can feed a set of reduced-dimension feature vectors as input to the classification model. The classification model can apply the parameters to the input. The application is capable of identifying a class (820). In the case of an application classification model, the classification model can generate an output for identifying classes into which a user interacting with the application is to be classified. The classification of the application can extend to a classification that corresponds to or includes a user associated with the account operating the application or a client device operated by the user. The application can assign a class identifier (e.g., class identifier 520) (825). The classification model can associate each class to one of the class identifiers. Once the class identifier is identified, the application is able to identify the class identifier corresponding to the class and assign the application to the class identifier.
The application can receive an information resource (e.g., information resource 600) (830). The information resources can include primary content (e.g., primary content 605) and a content slot (e.g., content slot 610). The primary content can be provided by a content publisher (e.g., content publisher 420). The content slots can be used to insert content from a content provider (e.g., content provider 415) or a content selection service (e.g., content selection service 425). Upon receipt, the application is able to parse the information resource. The application can generate a request for content (e.g., request for content 620) (835). The generation of the request for content can be combined with the parsing of the information resource.
The application can include a class identifier (840). The request for content can include a class identifier corresponding to a class identified by using a classification model. The application can also remove any unique tracking identifiers associated with a user of the application, the application itself, or a client device running the application. The unique tracking identifier may have been provided as part of a third party cookie from the content provider or another content placement platform. The class identifier can be included as part of a secure cookie included in the request for content. The application can transmit a request for content (845). The transfer may be through a secure communication channel established between the client device and the content selection service. The request for content can be received by a content selection service. The content selection service can use the class identifier included in the request to identify a content item from a collection of content items (e.g., content item 725). In the case of the selection, the content selection service can send the content item to the application. The application can receive the selected content item (850). The application is capable of inserting the content item into a content slot defined on the information resource.
The application can determine whether to reassign the class identifier (855). The reassignment may be in accordance with an identifier assignment policy. The policy can specify a set of conditions under which the classification model will be applied again to the browsing history for new class identifiers. If the determination is to reassign, the application can repeat (805) - (825) and proceed. On the other hand, if it is determined not to reassign, the application can maintain the class identifier (860).
Fig. 9 shows the general architecture of an illustrative computer system 900 that may be employed to implement any of the computer systems discussed herein, including the application manager service 410 and its components, the content provider 415 and its components, the content publisher 420 and its components, the content selection service 425 and its components, and the client device 430 and its components, in accordance with some embodiments. Computer system 900 can be used to provide information for display via network 930. The computer system 900 includes one or more processors 920 communicatively coupled to a memory 925, one or more communication interfaces 905 communicatively coupled to at least one network 930 (e.g., the network 405), as well as one or more output devices 910 (e.g., one or more display units) and one or more input devices 915.
The processor 920 can include a microprocessor, an Application Specific Integrated Circuit (ASIC), a Field Programmable Gate Array (FPGA), the like, or a combination thereof. The memory may include, but is not limited to, an electronic, optical, magnetic, or any other storage or transmission device capable of providing a processor with program instructions. The memory 925 may include any computer-readable storage medium and may store computer instructions, such as processor-executable instructions for implementing various functionalities described herein for the respective system, as well as any data related thereto, generated thereby, or received via a communication interface or input device, if present. The memory 925 can include a floppy disk, CD-ROM, DVD, magnetic disk, memory chip, ASIC, FPGA, Read Only Memory (ROM), Random Access Memory (RAM), electrically erasable ROM (EEPROM), Erasable Programmable ROM (EPROM), flash memory, optical media, or any other suitable memory from which a processor can read instructions. The instructions may include code from any suitable computer programming language.
The processor 920 shown in fig. 9 may be used to execute instructions stored in the memory 925 and, in so doing, may also read from and write to the memory various information processed and/or generated pursuant to execution of the instructions. The processor 920 (collectively referred to herein as a processing unit), coupled with the memory 925, can be included in the application manager service 410. For example, the application manager service 410 can include a memory 925 as the database 515. The processor 920 (collectively referred to herein as a processing unit), coupled with the memory 925, can be included in the content provider 415. For example, the content provider 415 can include a memory 925 to store the content item 725. The processor 920 (collectively referred to herein as a processing unit), coupled with the memory 925, can be included in the content publisher 420. For example, the content publisher 420 can include a memory 925 to store the information resource 600. A processor 920 (collectively referred to herein as a processing unit), coupled with a memory 925, can be included in the content selection service 425. For example, the content selection service 425 can include a memory 925 as the history database 720. The processor 920 (collectively referred to herein as a processing unit), coupled with the memory 925, can be included in the client device 430. For example, the client device 430 can include a memory 925 as a browsing history 530 and an identifier cache 540.
The processor 920 of the computer system 900 may also be communicatively coupled to or made to control the communication interface 905 to transmit or receive various information upon execution of instructions. For example, communication interface 905 may be coupled to a wired or wireless network, bus, or other communication means, and thus may allow computer system 900 to transmit information to other devices (e.g., other computer systems) or receive information from other devices (e.g., other computer systems). Although not explicitly shown in the systems of fig. 4-7 or 9, one or more communication interfaces facilitate the flow of information between components of the system 900. In some implementations, the communication interface can be configured (e.g., via various hardware or software components) to provide a website as an access portal to at least some aspects of computer system 900. Examples of communication interfaces 905 include user interfaces (e.g., applications 435, information resources 600, primary content 605, content slots 610, and content items 725) that a user can use to communicate with other devices of the system 400.
For example, an output device 910 of the computer system 900 shown in fig. 9 may be provided to allow various information to be viewed or otherwise perceived in conjunction with the execution of instructions. For example, an input device 915 may be provided to allow a user to make manual adjustments during execution of instructions, to make selections to enter data, or to interact with the processor in any of a variety of ways. Additional information regarding the general computer system architecture that may be employed for the various systems discussed herein is further provided herein.
The network 930 can include computer networks such as the internet, local area networks, wide area networks, metropolitan area networks or other area networks, intranets, satellite networks, other computer networks such as voice or data mobile telephone communication networks, and combinations thereof. Network 930 may be any form of computer network used to relay information among the components of system 400, such as application manager service 410, content providers 415, content publishers 420, content selection service 425, and client devices 430. For example, network 930 may include the internet and/or other types of data networks, such as a Local Area Network (LAN), a Wide Area Network (WAN), a cellular network, a satellite network, or other types of data networks. Network 930 may also include any number of computing devices (e.g., computers, servers, routers, network switches, etc.) configured to receive and/or transmit data within network 930. Network 930 may also include any number of hardwired and/or wireless connections. The client device 430 may communicate wirelessly (e.g., via WiFi, cellular, radio, etc.) with a transceiver that is hardwired (e.g., via fiber optic cable, CAT5 cable, etc.) to other computing devices in the network 930.
Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software (including the structures disclosed in this specification and their structural equivalents) embodied in tangible media, firmware, or hardware, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a computer storage medium for execution by, or to control the operation of, data processing apparatus. The program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage media may be or be included in a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Further, although the computer storage medium is not a propagated signal, the computer storage medium can comprise a source or destination of computer program instructions encoded in an artificially generated propagated signal. The computer storage media may also be or be included in one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
The features disclosed herein may be implemented on a smart television module (or a connected television module, a hybrid television module, etc.) that may include a processing module configured to integrate an internet connection with a more traditional television program source (e.g., via cable, satellite, over-the-air, or other signal reception). The smart television module may be physically incorporated into a television, or may comprise a separate device, such as a set-top box, a blu-ray or other digital media player, a game console, a hotel television system, or other companion device. The smart television module may be configured to allow viewers to search for and find videos, movies, photos, and other content on the web, on local cable channels, on satellite TV channels, or stored on a local hard disk. A Set Top Box (STB) or Set Top Unit (STU) may include an information appliance that may contain a tuner and connect to a television and an external signal source to tune the signal to content, which is then displayed on a television screen or other display device. The smart television module may be configured to provide a home screen or top level screen that includes a plurality of different applications (such as web browsers) as well as icons for a plurality of streaming media services, connected cable or satellite media sources, other web "channels," and so forth. The smart television module may also be configured to provide an electronic program guide to the user. A companion application to the smart television module may operate on the mobile computing device to provide additional information to the user about available programming, to allow the user to control the smart television module, and so on. In some implementations, the features may be implemented on a laptop or other personal computer, smart phone, other mobile phone, handheld computer, tablet PC, or other computing device. In some implementations, the features disclosed herein may be implemented on a wearable device or component (e.g., a smart watch), which may include a processing module configured to integrate an internet connection (e.g., an internet connection with another computing device or network 930).
The operations described in this specification can be implemented as operations performed by data processing apparatus on data stored on one or more computer-readable storage devices or on data received from other sources.
The terms "data processing apparatus", "data processing system", "user equipment" or "computing device" encompass all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip or system on multiple chips, or a combination of the above. An apparatus can comprise special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment are capable of implementing a variety of different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.
A computer program (also known as a program, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with the instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Further, for example, the computer can be embedded in another device, e.g., a mobile phone, a Personal Digital Assistant (PDA), a mobile audio or video player, a game player, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a Universal Serial Bus (USB) flash drive). Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, such as internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube), plasma or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can also be used to provide for interaction with the user. For example, feedback provided to the user can include any form of sensory feedback, such as visual feedback, auditory feedback, or tactile feedback, and input from the user can be received in any form, including acoustic, speech, or tactile input. Further, the computer can interact with the user by sending documents to and receiving documents from the device used by the user, e.g., by sending web pages to a web browser on the user's client device in response to requests received from the web browser.
Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front end component, such as a client computer having a graphical user interface or a Web browser through which a user can interact with an embodiment of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include local area networks ("LANs") and wide area networks ("WANs"), internetworks (e.g., the internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
A computing system, such as system 900 or system 400, can include clients and servers. For example, the application manager service 410, content providers 415, content publishers 420, and content selection service 425 of the system 400 can each include one or more servers in one or more data centers or server farms. A client (e.g., client device 430) and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some implementations, the server transmits data (e.g., an HTML page) to the client device (e.g., for displaying data to a user interacting with the client device and receiving user input from the user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) can be received at the server from the client device.
Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front end component, such as a client computer having a graphical user interface or a Web browser through which a user can interact with an embodiment of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Communication networks may include local area networks ("LANs") and wide area networks ("WANs"), internetworks (e.g., the internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
For situations in which the systems discussed herein collect personal information about a user or may make use of personal information, the user may be provided with an opportunity to control whether programs or features may collect personal information (e.g., information about the user's social network, social actions or activities, the user's preferences, or the user's location), or whether or how to receive content from a content server or other data processing system that may be more relevant to the user. Further, certain data may be anonymized in one or more ways before it is stored or used, such that personally identifiable information is removed when generating parameters. For example, the identity of the user may be anonymized such that personally identifiable information cannot be determined for the user, or the geographic location of the user may be generalized (such as to a city, zip code, or state level) if location information is obtained such that a particular location of the user cannot be determined. Thus, the user can control how information is collected about him or her and used by the content server.
While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features specific to particular implementations of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Furthermore, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
Thus, particular embodiments of the present subject matter have been described. Other implementations are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. Moreover, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In some embodiments, multitasking or parallel processing may be utilized.
Claims (30)
1. A method for anonymized content retrieval, comprising:
generating, by a browser application of a computing device, a profile based on a browsing history of the computing device;
encoding, by the browser application, the profile as an n-dimensional vector;
calculating, by the browser application, a reduced-dimension vector from the n-dimensional vector;
determining, by the browser application, a first cluster corresponding to the reduced-dimension vector;
transmitting, by the browser application, a request for a content item to a content server, the request including an identification of the first cluster; and
receiving, by the browser application, from the content server, a content item selected according to the identification of the first cluster.
2. The method of claim 1, wherein generating the profile based on a browsing history of a user of the computing device comprises identifying a number n of visits to each of a plurality of addresses within a predetermined time period from a log of the browsing history.
3. The method of claim 1, wherein encoding the profile as an n-dimensional vector further comprises generating a string having values representing: each of the one or more accesses to an address associated with a corresponding location in the string within a predetermined period of time.
4. The method of claim 1, wherein computing the reduced-dimension vector further comprises performing a singular value decomposition of the n-dimensional vector.
5. The method of claim 4, wherein computing the reduced-dimension vector further comprises receiving a set of singular vectors of the singular value decomposition from a second computing device.
6. The method of claim 5, wherein computing the reduced-dimension vector further comprises transmitting the n-dimensional vector to the second computing device, the second computing device computing the set of singular vectors based on an aggregation of the n-dimensional vector of the computing device and n-dimensional vectors of at least one other computing device.
7. The method of claim 1, wherein determining the first cluster corresponding to the reduced-dimension vector further comprises receiving a boundary of each of a plurality of clusters from a second computing device.
8. The method of claim 7, wherein determining the first cluster corresponding to the reduced-dimension vector further comprises: selecting a first cluster of the plurality of clusters in response to the dimensionality reduction vector being within boundaries of the first cluster.
9. The method of claim 1, wherein determining the first cluster corresponding to the reduced-dimension vector further comprises:
receiving, by the browser application from a second computing device, weights for a neural network model determined based on an aggregation of the n-dimensional vector of the computing device and n-dimensional vectors of at least one other computing device;
applying, by a machine learning system of the browser application, the neural network model to the reduced-dimension vector to generate a ranking of a predetermined set of clusters; and
selecting, by the browser application, the first cluster as a highest-ranked cluster of the predetermined set of clusters.
10. A method for anonymized content retrieval, comprising:
receiving, by a server computing device from each of a plurality of client computing devices, a profile based on a browsing history of the corresponding client computing device, each profile comprising an n-dimensional vector;
aggregating, by the server computing device, a plurality of n-dimensional vectors of a plurality of profiles into a matrix;
calculating, by the server computing device, a singular value decomposition of the matrix to generate a set of singular values; and
transmitting, by the server computing device, the set of singular values to each of the plurality of client computing devices and at least one content provider device.
11. The method of claim 10, further comprising determining, by the server computing device, a boundary of each cluster in a set of clusters of the matrix.
12. The method of claim 11, further comprising transmitting, by the server computing device, to each of the plurality of client computing devices and the at least one content provider device, the boundary of each of the set of clusters of the matrix.
13. The method of claim 10, further comprising identifying, by the server computing device, each cluster in a set of clusters from the matrix via a neural network model.
14. The method of claim 13, further comprising communicating weights of the neural network model to each of the plurality of client computing devices and the at least one content provider device.
15. A system for anonymized content retrieval, comprising:
a computing device comprising a network interface to communicate with a content server, a memory to store a browsing history of the computing device, and a browser application configured to:
generating a profile based on a browsing history of the computing device,
encoding the profile as an n-dimensional vector,
a dimension reduction vector is calculated from the n-dimensional vector,
determining a first cluster corresponding to the dimensionality reduction vector,
transmitting a request for a content item to the content server via the network interface, the request comprising an identification of the first cluster, an
Receiving, from the content server via the network interface, a content item selected according to the identification of the first cluster.
16. The system of claim 15, wherein the browser application is further configured to generate a string having values to represent: each of the one or more accesses to an address associated with a corresponding location in the string within a predetermined period of time.
17. The system of claim 15, wherein the browser application is further configured to perform singular value decomposition of the n-dimensional vector.
18. The system of claim 17, wherein the browser application is further configured to receive, from a second computing device via the network interface, a set of singular vectors of the singular value decomposition.
19. The system of claim 18, wherein the browser application is further configured to transmit the n-dimensional vector to the second computing device via the network interface, the second computing device calculating the singular set of vectors based on an aggregation of the n-dimensional vector of the computing device and n-dimensional vectors of at least one other computing device.
20. The system of claim 15, wherein the browser application is further configured to:
receiving, from a second computing device via the network interface, weights for a neural network model determined based on an aggregation of the n-dimensional vector of the computing device and n-dimensional vectors of at least one other computing device;
applying the neural network model to the reduced-dimension vector to generate a ranking of a predetermined set of clusters; and
selecting the first cluster as a highest-ranked cluster of the predetermined set of clusters.
21. A method of encoding an identifier for content selection, comprising:
identifying, by a first application executing on a client device, a browsing history maintained on the client device that records information resources accessed by the client device via the first application;
applying, by the first application, a classification model to the browsing history of the first application to identify a class into which the first application is to be classified;
assigning, by the first application, the first application to a class identifier corresponding to the identified class, the class identifier of the first application being the same as a class identifier of a second application;
receiving, by the first application from a content publisher device, an information resource comprising primary content and a content slot available to receive content from a content selection service;
generating, by the first application, a request for content for the content slot of the information resource, the request for content including the class identifier for the first application; and
transmitting, by the first application, the request for content to the content selection service, the content selection service selecting a content item to be inserted into a content slot of the information resource using the class identifier for the first application and the class identifier for the second application.
22. The method of claim 21, further comprising:
receiving, by the first application from an application administrator service, a set of parameters for updating the classification model to classify the application into one of a plurality of classes; and
modifying, by the first application, the classification model maintained on the client device based on the set of parameters received from the application administrator service.
23. The method of claim 21, further comprising training, by the first application, the classification model maintained on a plurality of corresponding client devices by using a distributed learning protocol consistent with a plurality of applications executing on the client devices.
24. The method of claim 21, further comprising generating, by the first application, a reduced set of feature vectors from the browsing history identified from the client device using a dimension reduction process, the feature vectors being smaller in file size than the browsing history; and is
Wherein applying the classification model further comprises applying the classification model to the set of simplified feature vectors generated from the browsing history.
25. The method of claim 21, further comprising determining, by the first application, that the classification model is to be applied to the browsing history by an identifier assignment policy; and is
Wherein applying the classification model further comprises: applying the classification model in response to determining that the classification model is to be applied in accordance with the identifier assignment policy.
26. The method of claim 21, wherein applying the classification model further comprises applying the classification model to identify the class from a plurality of classes, each of the plurality of classes having at least a predetermined number of clients to be classified into the class.
27. The method of claim 21, wherein assigning the first application to the class identifier further comprises assigning the first application to a class identifier of a plurality of class identifiers, each class identifier corresponding to one of the plurality of classes.
28. The method of claim 21, wherein generating the request for content further comprises: generating the request for content without a unique tracking identifier provided by the content selection service and corresponding to an account associated with the first application, or the client device.
29. The method of claim 21, wherein generating the request for content further comprises generating a request for content comprising a secure cookie for transmission over the connection with the content selection service, the secure cookie having the class identifier for the first application.
30. The method of claim 21, wherein identifying the browsing history further comprises identifying the browsing history over a predetermined time range in which the classification model is to be applied.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US16/535,912 | 2019-08-08 | ||
US16/535,912 US11194866B2 (en) | 2019-08-08 | 2019-08-08 | Low entropy browsing history for content quasi-personalization |
PCT/US2020/026017 WO2021025731A1 (en) | 2019-08-08 | 2020-03-31 | Low entropy browsing history for content quasi-personalization |
Publications (1)
Publication Number | Publication Date |
---|---|
CN113056897A true CN113056897A (en) | 2021-06-29 |
Family
ID=70471097
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202080006197.3A Pending CN113056897A (en) | 2019-08-08 | 2020-03-31 | Low entropy browsing history for content quasi-personalization |
Country Status (8)
Country | Link |
---|---|
US (4) | US11194866B2 (en) |
EP (3) | EP3868076B1 (en) |
JP (3) | JP7254922B2 (en) |
KR (3) | KR20230118199A (en) |
CN (1) | CN113056897A (en) |
DE (1) | DE112020000133T5 (en) |
GB (1) | GB2594367A (en) |
WO (1) | WO2021025731A1 (en) |
Families Citing this family (8)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11194866B2 (en) | 2019-08-08 | 2021-12-07 | Google Llc | Low entropy browsing history for content quasi-personalization |
EP3868077A1 (en) | 2019-08-08 | 2021-08-25 | Google LLC | Low entropy browsing history for content quasi-personalization |
US20210056458A1 (en) * | 2019-08-20 | 2021-02-25 | Adobe Inc. | Predicting a persona class based on overlap-agnostic machine learning models for distributing persona-based digital content |
US11544080B2 (en) * | 2019-10-25 | 2023-01-03 | Micro Focus Llc | Adaptive user interface based on device context as well as user context |
CN111475392B (en) * | 2020-04-08 | 2022-05-20 | 北京字节跳动网络技术有限公司 | Method, device, electronic equipment and computer readable medium for generating prediction information |
EP4053738A1 (en) * | 2021-03-03 | 2022-09-07 | Tata Consultancy Services Limited | Determining similar behavioral pattern between time series data obtained from multiple sensors and clustering thereof |
WO2023075774A1 (en) * | 2021-10-28 | 2023-05-04 | Google Llc | Machine learning techniques for user group based content distribution |
US20240020279A1 (en) * | 2022-07-18 | 2024-01-18 | Dell Products L.P. | Systems and methods for intelligent database recommendation |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20090006974A1 (en) * | 2007-06-27 | 2009-01-01 | Kosmix Corporation | Automatic selection of user-oriented web content |
US20120203723A1 (en) * | 2011-02-04 | 2012-08-09 | Telefonaktiebolaget Lm Ericsson (Publ) | Server System and Method for Network-Based Service Recommendation Enhancement |
US20190034535A1 (en) * | 2017-07-25 | 2019-01-31 | Yandex Europe Ag | Method and system for generating a user-personalization interest parameter for identifying personalized targeted content item |
Family Cites Families (19)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6962940B2 (en) | 2002-03-20 | 2005-11-08 | Celgene Corporation | (+)-2-[1-(3-Ethoxy-4-methoxyphenyl)-2-methylsulfonylethyl]-4-acetylaminoisoindoline-1,3-dione: methods of using and compositions thereof |
US7779040B2 (en) * | 2007-09-27 | 2010-08-17 | Amazon Technologies, Inc. | System for detecting associations between items |
JP5242507B2 (en) * | 2009-06-22 | 2013-07-24 | 日本電信電話株式会社 | Advertisement delivery system, advertisement delivery server, advertisement delivery method, and advertisement delivery program |
US9129000B2 (en) | 2010-04-30 | 2015-09-08 | International Business Machines Corporation | Method and system for centralized control of database applications |
EP2533168B1 (en) | 2011-06-07 | 2017-01-25 | BlackBerry Limited | Method and devices for managing permission requests to allow access to computing resource |
US8763080B2 (en) | 2011-06-07 | 2014-06-24 | Blackberry Limited | Method and devices for managing permission requests to allow access to a computing resource |
US9519726B2 (en) | 2011-06-16 | 2016-12-13 | Amit Kumar | Surfacing applications based on browsing activity |
JP5730734B2 (en) | 2011-09-28 | 2015-06-10 | 株式会社Ｎｔｔドコモ | Application recommendation device, application recommendation method, and application recommendation program |
CN103647800B (en) | 2013-11-19 | 2017-12-12 | 乐视致新电子科技（天津）有限公司 | Recommend the method and system of application resource |
CN104899220B (en) | 2014-03-06 | 2021-06-25 | 腾讯科技（深圳）有限公司 | Application program recommendation method and system |
CN105991722B (en) | 2015-02-12 | 2020-03-10 | Oppo广东移动通信有限公司 | Downloader recommendation method, application server, terminal and system |
US20170046510A1 (en) | 2015-08-14 | 2017-02-16 | Qualcomm Incorporated | Methods and Systems of Building Classifier Models in Computing Devices |
US20170091303A1 (en) * | 2015-09-24 | 2017-03-30 | Intel Corporation | Client-Side Web Usage Data Collection |
US20160162924A1 (en) | 2015-11-27 | 2016-06-09 | Yogesh Rathod | Track user activities and in exchange provide points to use for various activities including advertising contents to targeted users of network |
CN105608117B (en) | 2015-12-14 | 2019-12-10 | 微梦创科网络科技（中国）有限公司 | Information recommendation method and device |
US20170262894A1 (en) | 2016-03-11 | 2017-09-14 | Facebook, Inc. | Expanding targeting criteria for content items based on user characteristics and weights associated with users satisfying the targeting criteria |
US11030651B2 (en) * | 2016-05-06 | 2021-06-08 | Adp, Llc | Segmented user profiles |
US10496263B2 (en) * | 2017-01-03 | 2019-12-03 | Jpmorgan Chase Bank, N.A. | De-anonymization of website visitor identity |
US11194866B2 (en) | 2019-08-08 | 2021-12-07 | Google Llc | Low entropy browsing history for content quasi-personalization |
-
2019
- 2019-08-08 US US16/535,912 patent/US11194866B2/en active Active
-
2020
- 2020-03-31 KR KR1020237026345A patent/KR20230118199A/en active IP Right Grant
- 2020-03-31 EP EP20722409.8A patent/EP3868076B1/en active Active
- 2020-03-31 CN CN202080006197.3A patent/CN113056897A/en active Pending
- 2020-03-31 EP EP23198404.8A patent/EP4274194A3/en active Pending
- 2020-03-31 KR KR1020237026346A patent/KR20230119258A/en active IP Right Grant
- 2020-03-31 WO PCT/US2020/026017 patent/WO2021025731A1/en unknown
- 2020-03-31 DE DE112020000133.4T patent/DE112020000133T5/en active Pending
- 2020-03-31 GB GB2107198.0A patent/GB2594367A/en active Pending
- 2020-03-31 EP EP23198403.0A patent/EP4274193A3/en active Pending
- 2020-03-31 JP JP2021527201A patent/JP7254922B2/en active Active
- 2020-03-31 KR KR1020217014910A patent/KR102564387B1/en active IP Right Grant
-
2021
- 2021-07-21 US US17/381,797 patent/US11687597B2/en active Active
- 2021-11-29 US US17/537,203 patent/US20220083599A1/en active Granted
-
2023
- 2023-03-28 JP JP2023051920A patent/JP2023093476A/en active Pending
- 2023-03-28 JP JP2023051923A patent/JP2023098897A/en active Pending
- 2023-08-25 US US18/456,281 patent/US20230409646A1/en active Pending
Patent Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20090006974A1 (en) * | 2007-06-27 | 2009-01-01 | Kosmix Corporation | Automatic selection of user-oriented web content |
US20120203723A1 (en) * | 2011-02-04 | 2012-08-09 | Telefonaktiebolaget Lm Ericsson (Publ) | Server System and Method for Network-Based Service Recommendation Enhancement |
US20190034535A1 (en) * | 2017-07-25 | 2019-01-31 | Yandex Europe Ag | Method and system for generating a user-personalization interest parameter for identifying personalized targeted content item |
Non-Patent Citations (2)
Title |
---|
ERAN TOCH: "Personalization and privacy: a survey of privacy risks and remedies in personalization-based systems", 《USER MODEL USER-ADAP INTER》 * |
GHAZALEH BEIGI: "Protecting User Privacy: An Approach for UntraceableWeb", 《12TH ACM INTERNATIONAL WSDM CONFERENCE》 * |
Also Published As
Publication number | Publication date |
---|---|
EP3868076B1 (en) | 2023-11-01 |
EP4274193A2 (en) | 2023-11-08 |
KR102564387B1 (en) | 2023-08-08 |
GB202107198D0 (en) | 2021-06-30 |
DE112020000133T5 (en) | 2021-07-29 |
KR20230119258A (en) | 2023-08-16 |
KR20210077736A (en) | 2021-06-25 |
JP2022542623A (en) | 2022-10-06 |
US11194866B2 (en) | 2021-12-07 |
EP3868076A1 (en) | 2021-08-25 |
US20220083599A1 (en) | 2022-03-17 |
JP7254922B2 (en) | 2023-04-10 |
JP2023093476A (en) | 2023-07-04 |
KR20230118199A (en) | 2023-08-10 |
GB2594367A (en) | 2021-10-27 |
US20210349947A1 (en) | 2021-11-11 |
JP2023098897A (en) | 2023-07-11 |
WO2021025731A1 (en) | 2021-02-11 |
US11687597B2 (en) | 2023-06-27 |
US20210042357A1 (en) | 2021-02-11 |
EP4274193A3 (en) | 2023-11-29 |
US20230409646A1 (en) | 2023-12-21 |
EP4274194A2 (en) | 2023-11-08 |
EP4274194A3 (en) | 2023-12-06 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
EP3868076B1 (en) | Low entropy browsing history for content quasi-personalization | |
CN113169982B (en) | Low entropy browsing history for content quasi-personalization | |
CN102792300A (en) | User role based customizable semantic search | |
US11423441B2 (en) | Low entropy browsing history for ads quasi-personalization | |
EP3763108A1 (en) | Restricted environments for message generation in networked environments | |
US20230306263A1 (en) | Pattern-based classification | |
EP3971811A1 (en) | Privacy supporting messaging systems and methods | |
US20220188698A1 (en) | Machine learning techniques for web resource interest detection | |
US20220374546A1 (en) | Privacy preserving data collection and analysis | |
US20220075891A1 (en) | Systems and methods for encryption of content request data | |
Samarasinghe et al. | Prediction of user intentions using Web history | |
US11204965B2 (en) | Data analytics and insights brokerage service | |
US20230259815A1 (en) | Machine learning techniques for user group based content distribution |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |