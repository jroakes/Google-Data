DE202015009258U1 - Efficient annotation system for distributed version management systems - Google Patents
Efficient annotation system for distributed version management systems Download PDFInfo
- Publication number
- DE202015009258U1 DE202015009258U1 DE202015009258.6U DE202015009258U DE202015009258U1 DE 202015009258 U1 DE202015009258 U1 DE 202015009258U1 DE 202015009258 U DE202015009258 U DE 202015009258U DE 202015009258 U1 DE202015009258 U1 DE 202015009258U1
- Authority
- DE
- Germany
- Prior art keywords
- file
- commit
- line
- row
- parent
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/70—Software maintenance or management
- G06F8/71—Version control; Configuration management
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/70—Software maintenance or management
- G06F8/73—Program documentation
Abstract
System für die Erstellung einer inkrementellen Blame-Datenstruktur für eine Datei – das System besteht aus den folgenden Punkten: ein oder mehrere Verarbeitungsgeräte; und ein oder mehrere Speichergeräte, die Anweisungen speichern, dass bei Ausführung durch ein oder mehrere Verarbeitungsgeräte, ein oder mehrere Verarbeitungsgeräte Folgendes tun: das Empfangen eines Commits mit mindestens einer Datei, die in Bezug auf einen übergeordneten Commit (501) aktualisiert wurde; das Ermittlung übergeordneter Revisionen einer Datei für mindestens eine Datei (505); das Bestimmen der Unterschiede zwischen mindestens einer Datei und den ermittelten übergeordneten Revisionen einer Datei (507); das Rückverfolgen eines Ursprungs jeder Zeile in der Datei basierend auf den ermittelten Unterschieden (507); Reaktion auf die Tatsache, dass eine Zeile hinzugefügt oder verändert wurde, die Zeile als Ursprung markieren und die Zeile in einer inkrementellen Blame-Datenstruktur (509, 511) mit sich selbst verknüpfen; das Bestimmen, als Reaktion auf die Tatsache, dass eine Zeile nicht aktualisiert wurde, des Ursprungs der unveränderten Zeile durch Nachverfolgen der übergeordneten Revisionen der Datei, die der unveränderten Zeile zugewiesen sind (509, 519); und das Hinzufügen einer Zeilenkennung und des Ursprungs der Zeile zur inkrementellen Blame-Datenstruktur der Datei (521).System for creating an incremental blame data structure for a file - the system consists of the following items: one or more processing devices; and one or more storage devices storing instructions that, when executed by one or more processing devices, one or more processing devices: receiving a commit with at least one file that has been updated with respect to a parent commit (501); determining parent revisions of a file for at least one file (505); determining the differences between at least one file and the determined parent revisions of a file (507); retracing an origin of each line in the file based on the determined differences (507); Responsive to the fact that a row has been added or changed, marking the row as the origin and associating the row in an incremental blame data structure (509, 511) with itself; determining, in response to the fact that a row has not been updated, the origin of the unchanged row by tracking the parent revisions of the file assigned to the unchanged row (509, 519); and adding a row identifier and the origin of the row to the incremental blame data structure of the file (521).
Description
Unter Schutz gestellt werden und Gegenstand des Gebrauchsmusters sind dabei, entsprechend den Vorschriften des Gebrauchsmustergesetzes, lediglich Vorrichtungen wie in den beigefügten Schutzansprüchen definiert, jedoch keine Verfahren. Soweit nachfolgend in der Beschreibung gegebenenfalls auf Verfahren Bezug genommen wird, dienen diese Bezugnahmen lediglich der beispielhaften Erläuterung der in den beigefügten Schutzansprüchen unter Schutz gestellten Vorrichtung oder Vorrichtungen.Be provided under protection and subject of the utility model are, according to the provisions of the utility model law, only devices as defined in the appended claims, but no method. Wherever in the description, if appropriate, reference is made to methods, these references are merely illustrative of the device or devices set forth in the appended claims.
HINTERGRUNDBACKGROUND
Bei der Entwicklung einer Softwareanwendung arbeitet ein Softwareentwickler in vielen Fällen alleine an einer bestimmten Funktion der Anwendung. Sobald die Funktion entwickelt und getestet wurde, wird der die Funktion enthaltende Quellcode eingecheckt und dem Code-Repository der Softwareanwendung hinzugefügt, um die Funktion anderen Softwareentwicklern zur Verfügung zu stellen, die ebenfalls an der Anwendung arbeiten. Eine Funktion wird dem Code-Repository hinzugefügt, indem der Softwareentwickler sämtliche Dateiänderungen und neue Dateien eincheckt, die für einen einwandfreien Betrieb der Funktion auf anderen Systemen erforderlich sind. Ein Commit für das Code-Repository der Softwareanwendung kann nur eine Datei oder eine Reihe von Veränderungen an bestimmten Quellcode-Dateien beinhalten, die sich auf dem Rechner eines Softwareentwicklers befinden, und die der Datenbank im Code-Repository der Softwareanwendung hinzugefügt werden sollen. Jedem Commit wird üblicherweise eine Kennung zugeteilt. Ein spezifischer Commit, der mit der Kennung versehen ist, kann zu einem beliebigen Zeitpunkt eine Schattenkopie des Code-Repositorys bereitstellen. Jede Datei innerhalb des Commits erhält eine Dateirevisionsnummer, die dem Commit zugewiesen ist. Softwareentwickler können Updates aus dem Code-Repository beziehen und annehmen, um die aktuellen Commits mit den aktuellen Dateiversionen im Code-Repository zu erhalten und sicherzustellen, dass sie mit aktuellen Versionen der Quellcode-Dateien in der Code-Datenbank arbeiten.In developing a software application, a software developer often works alone on a particular function of the application. Once the function has been developed and tested, the source code containing the function is checked in and added to the code repository of the software application to make the function available to other software developers who also work on the application. A function is added to the code repository by having the software developer check in all the file changes and new files required to function properly on other systems. Committing the software application code repository may involve only a file or a series of changes to certain source code files residing on a software developer's computer to be added to the database in the code repository of the software application. Each commit is usually assigned an identifier. A specific commit provided with the identifier can provide a shadow copy of the code repository at any given time. Each file within the commit receives a file number that is assigned to the commit. Software developers can obtain and accept updates from the code repository to keep up-to-date commits with the current versions of files in the code repository and to ensure that they are working with current versions of the source code files in the code database.
Während der Entwicklung der Softwareanwendung sind bei der Ansicht des Codes zusätzliche Informationen in Bezug auf den Code relevant, um die Funktion des Codes zu verstehen, ihn zu modifizieren oder fehlerhaften Code zu korrigieren. Integrierte Entwicklungsumgebungen (IDEs, Integrated Development Environments) bzw. Texteditoren können diese zusätzlichen Informationen als Anmerkungen zum Quellcode darstellen. Falsch geschriebene Wörter können beispielsweise hervorgehoben, Compiler-Fehler neben dem verursachenden Code angezeigt und Listen kürzlich durchgeführter Änderungen an der Quellcode-Datei oder dem Verzeichnis erstellt werden. Anmerkungen können von verschiedenen Quellen stammen, beispielsweise von einer statischen Code-Analyse, von Produktionssystemen, Rechtschreibprüfungen oder Kooperationstools. Die Tools, die die Anmerkungen erstellen, arbeiten auf einer bestimmten Revision einer Datei oder einem Commit. Die generierten Anmerkungen können jedoch auch für andere Revisionen einer Datei oder Repository-Schattenkopien relevant sein, sofern nachfolgende Codeänderungen die Anmerkungen in späteren Commits nicht überfällig machen.During the development of the software application, additional code information is relevant to the understanding of the code in order to understand the function of the code, to modify it, or to correct erroneous code. Integrated Development Environments (IDEs) or text editors can present this additional information as annotations to the source code. For example, misspelled words can be highlighted, compiler errors next to the originating code, and lists of recent changes made to the source file or directory. Annotations can come from a variety of sources, such as static code analysis, production systems, spell checkers, or collaboration tools. The tools that create the annotations work on a specific revision of a file or commit. However, the generated annotations may also be relevant to other revisions of a file or repository shadow copies, as long as subsequent code changes make the annotations in later commits obsolete.
Es wäre vorteilhaft, wenn generierte Anmerkungen über mehrere Revisionen einer Quellcode-Datei und Code-Commits hinweg verfügbar wären, sofern sie für Softwareentwickler von Nutzen sind. Die Erfinder haben erkannt, dass es einen Weg geben sollte, Anmerkungen über mehrere Code-Commits hinweg in einem Quellcode-Repository zu generieren und darzustellen.It would be beneficial if generated annotations were available across multiple revisions of a source code file and code commits, as long as they are useful to software developers. The inventors have realized that there should be a way to generate and display annotations across multiple code commits in a source code repository.
ZUSAMMENFASSUNGSUMMARY
In dieser Spezifikation werden Technologien beschrieben, durch die Quellcode allgemein dargestellt wird, insbesondere Verfahren und Systeme zur Bereitstellung von Quellcode-Anmerkungen über mehrere Code-Repository-Commits hinweg.This specification describes technologies that generally portray source code, and more particularly, methods and systems for providing source code annotations across multiple code repository commits.
Im Allgemeinen kann ein Aspekt des in dieser Spezifikation beschriebenen Gegenstands in computerimplementierten Verfahren und Systemen realisiert werden. Ein Beispielsystem beinhaltet ein oder mehrere Verarbeitungsgeräte und Speichersysteme, die Anweisungen speichern, die bei der Ausführung durch ein oder mehrere Verarbeitungsgeräte ein oder mehrere Verarbeitungsgeräte veranlassen, ein Beispielverfahren umzusetzen. Zu einem Beispielverfahren gehört: Erhalt eines Commits mit mindestens einer Datei, die in Bezug auf einen übergeordneten Commit aktualisiert wurde; Bestimmen von übergeordneten Revisionen einer Datei für mindestens eine Datei; Ermittlung der Unterschiede zwischen mindestens einer Datei und den bestimmten übergeordneten Revisionen einer Datei; Rückverfolgung des Ursprungs jeder Zeile in der Datei basierend auf den ermittelten Unterschieden; Reaktion auf das Hinzufügen oder Ändern einer Zeile, eine Zeile als Ursprung kennzeichnen und die Zeile mit sich selbst in einer inkrementellen Blame-Datenstruktur für die Datei verknüpfen; sowie eine Kennung zu einer Zeile und den Ursprung der Zeile zur inkrementellen Blame-Datenstruktur der Datei hinzufügen.In general, one aspect of the subject matter described in this specification may be implemented in computer-implemented methods and systems. An example system includes one or more processing devices and memory systems that store instructions that, when executed by one or more processing devices, cause one or more processing devices to implement an example method. An example method involves: receiving a commit with at least one file that has been updated with respect to a parent commit; Determining parent revisions of a file for at least one file; Determining the differences between at least one file and the particular parent revisions of a file; Tracing the origin of each line in the file based on the differences found; Responding to the addition or modification of a line, marking a line as the origin, and linking the line to itself in an incremental blame data structure for the file; and adding an identifier to a line and the origin of the line to the file's incremental blame data structure.
Ein weiteres Beispielverfahren für die Anzeige relevanter Anmerkungen über mehrere Revisionen einer Datei ist das Beziehen einer aktuellen Revision einer Datei; das Anfordern einer Blame-Struktur, um Blame-Daten zu erhalten, die der Datei zugewiesen sind, um sichtbare Zeilen in der aktuellen Revision aus einer älteren Revision zu bestimmen; Bestimmung von Anmerkungen, die den sichtbaren Zeilen in der aktuellen Revision zugewiesen sind, die aus einer älteren Revision stammen; und die Anzeige der bestimmten Anmerkungen.Another example method of displaying relevant annotations over multiple revisions of a file is obtaining a current revision of a file; Requesting a Blame Structure to obtain blame data assigned to the file to determine visible lines in the current revision from an older revision; Determining annotations associated with the visible lines in the current revision that are from an older revision; and the display of specific comments.
Diese und andere Ausführungsformen können als Option eines oder mehrere der folgenden Merkmale beinhalten. Das Bestimmen des Ursprungs einer Zeile kann das Bestimmen der übergeordneten Revisionen einer Datei beinhalten, die einer Zeile zu einer übergeordneten Revision einer Datei zugewiesen sind, und das Kopieren der Ursprungsinformationen aus einer übergeordneten Revision einer Datei in die Zeile. Das Bestimmen des Ursprungs einer Zeile kann das Bestimmen der übergeordneten Revisionen einer Datei beinhalten, die einer Zeile zu mehreren übergeordneten Revisionen einer Datei zugewiesen sind, und das Kopieren der Ursprungsinformationen aus einer übergeordneten Revision einer Datei, die als die älteste bestimmt wurde, in die Zeile in der inkrementellen Blame-Datenstruktur. Die übergeordnete Revision einer Datei, die als die älteste bestimmt wurde, kann mithilfe eines Zeitstempels gefunden werden, der der übergeordneten Revision einer Datei zugewiesen ist. Reaktion auf das Ergebnis, dass zwei Zeilen in mindestens einer Datei denselben Ursprung enthalten; die letzte der beiden Zeilen kann als neue Ursprungszeile markiert werden. Zeilen aus mindestens einer Datei können basierend auf dem bestimmten Unterschied als hinzugefügte oder entfernte Zeilen gekennzeichnet werden. Eine Bool'sche Abfrage kann erstellt werden, um zu prüfen, ob eine Zeile in einem Commit sichtbar ist. Möglicherweise muss festgestellt werden, ob eine Bool'sche Abfrage zu komplex wird (z. B. wenn eine vorbestimmte Länge überschritten wird), und falls dies zutrifft, wird die Abfrage durch eine Abkürzung ersetzt, um die Größe und Komplexität der Abfrage zu reduzieren. Alternativ kann ein binäres Entscheidungsdiagramm anstelle einer Bool'schen Abfrage eingesetzt werden, und es kann ein Label für jeden Commit erstellt werden. Die binären Entscheidungsdiagramme können von unten nach oben entlang der Seiten ausgewertet werden, um zu sehen, ob eine Zeile im Commit sichtbar ist.These and other embodiments may optionally include one or more of the following features. Determining the origin of a line may include determining the parent revisions of a file assigned to a line to a parent revision of a file, and copying the source information from a parent revision of a file into the line. Determining the origin of a row may include determining the parent revisions of a file assigned to a row to multiple parent revisions of a file, and copying the source information from a parent revision of a file designated as the oldest to the row in the incremental Blame data structure. The parent revision of a file that was determined to be the oldest can be found by using a timestamp assigned to the parent revision of a file. Response to the result that two lines in at least one file contain the same origin; the last of the two lines can be marked as a new source line. Lines from at least one file may be marked as added or removed rows based on the particular difference. A Boolean query can be created to check if a row is visible in a commit. It may be necessary to determine if a Boolean query becomes too complex (eg, if a predetermined length is exceeded), and if so, the query is replaced with an abbreviation to reduce the size and complexity of the query. Alternatively, a binary decision diagram can be used instead of a Boolean query, and a label can be created for each commit. The binary decision charts can be evaluated from bottom to top along the pages to see if a row is visible in the commit.
Die Einzelheiten einer oder mehrerer Ausführungsformen der Erfindung sind in den begleitenden Zeichnungen dargelegt, die nur der Veranschaulichung dienen, sowie in der nachstehenden Beschreibung. Andere Merkmale, Aspekte und Vorteile der Erfindung werden aus der Beschreibung, den Zeichnungen und den Ansprüchen deutlich. Entsprechende Referenznummern und Kennzeichnungen in den verschiedenen Zeichnungen zeigen entsprechende Elemente an.The details of one or more embodiments of the invention are set forth in the accompanying drawings, which are given by way of illustration only, as well as in the following description. Other features, aspects and advantages of the invention will be apparent from the description, drawings and claims. Corresponding reference numbers and markings in the various drawings indicate corresponding elements.
KURZBESCHREIBUNG DER ZEICHNUNGENBRIEF DESCRIPTION OF THE DRAWINGS
AUSFÜHRLICHE BESCHREIBUNGDETAILED DESCRIPTION
Wie oben erwähnt, bieten Anmerkungen nützliche Informationen über Quellcode und sollten daher über verschiedene Commits hinweg verfügbar sein, sofern sie für die aktuellen Zeilenversionen in der Datei anwendbar sind, an die sie angehängt wurden. Anmerkungen können wie erforderlich aus einer bestimmten Code-Zeile hinzugefügt (oder entfernt) werden. Wie in
Softwareentwickler können während der Erstellung des Quellcodes mehrere Commits an einem Code-Repository durchführen. Wie in
Ein dritter Commit könnte aus Commit #1 folgen und Datei #1 ändern, indem er „aaa” löscht, „ccc” ändert, „ddd” hinzufügt und „eee” hinzufügt. Der Inhalt von Datei #1 könnte wie folgt lauten: „bbb” auf Zeile 1 (aus Commit #1), „ccccc” auf Zeile 2 (aus Commit #3), „ddd” auf Zeile 3 (aus Commit #3) und „eee” auf Zeile 4 (aus Commit #3). Datei #2 könnte geändert werden, um aaa auf Zeile 1 zu beinhalten (aus Commit #1), aaa auf Zeile 2 (aus Commit #1), „aaa” auf Zeile 3 (aus Commit #3) und „bbb” auf Zeile 4 (aus Commit #3).A third commit could follow from commit # 1 and
Ein vierter Commit könnte ein untergeordneter Commit aus Commit #2 und Commit #3 sein. Datei #1 könnte von einem Benutzer oder einem Versionsverwaltungssystem zusammengefügt werden. Datei #1 könnte Folgendes enthalten: „bbb” auf Zeile 1 (aus Commit #1), „cccc” (aus Commit #2, der Benutzer kann die in Konflikt stehenden Zeilendaten durch die Auswahl von „cccc” statt „ccccc” beheben), ddd auf Zeile 3 (aus Commit #2), was zu einem Blame-Konflikt führt, da die Daten von Commit #2 oder Commit #3 stammen könnten, und „eee” auf Zeile 4 (aus Commit #3). Datei #2 könnte Folgendes enthalten: „aaa” auf Zeile 1 (aus Zeile 1 von Commit #1), „aaa” auf Zeile 2 (aus Zeile 2 von Commit #1), „aaa” auf Zeile 3 (aus Zeile 3 von Commit #3) und „bbb” auf Zeile 4 (aus Zeile 3 von Commit #2).A fourth commit could be a subordinate commit from commit # 2 and commit # 3.
Blame-Daten für eine Zeile Quellcode enthalten Informationen über den Commit, in dem die Zeile eingeführt oder zuletzt geändert wurde. Im Beispiel aus
Eine Anmerkung kann an einer Zeile bzw. an Zeilen eines spezifischen Commits erstellt werden. Jede Information über die spezifische Anmerkung, einschließlich der Anhänge der Anmerkung, kann in einer Beispiel-Datenstruktur für die Anmerkung auf der Blame-Ebene gespeichert werden. Die Blame-Ebene verweist eine Zeile einer Revision einer Datei zu einer älteren Revision, in der die Zeile eingeführt wurde. Wird die Zeile neu erstellt, verweist die Blame-Ebene die Zeile zu der Zeile selbst. Diese Ursprungszeile oder -zeilen können sich auf verschiedene tatsächliche Zeilen in nachfolgenden Revisionen des Codes beziehen. Daher können Anmerkungen an der Stelle gespeichert werden, an der die Zeile ursprünglich eingeführt wurde. Wenn die Anmerkungen einer Datei bezogen werden sollen, kann ein Beispielsystem sämtliche Anmerkungen an den Zeilen suchen, auf die sich die aktuelle Revision einer Datei bezieht.An annotation can be made on a line or lines of a specific commit. Any information about the specific annotation, including the annotations of the annotation, may be stored in a sample data structure for the annotation at the blame level. The blame level references a line of a revision of a file to an older revision in which the line was introduced. When the row is rebuilt, the blame level references the row to the row itself. These source rows or rows may refer to different actual rows in subsequent revisions of the code. Therefore, annotations can be stored at the point where the line was originally inserted. If you want to get the notes of a file, a sample system can search for any annotations on the rows to which the current revision of a file refers.
Um eine schnelle Suche nach Anmerkungen zu Zeilen im Quellcode durchzuführen, müssen vorberechnete Blame-Daten bezogen und in einer Beispiel-Blame-Datenstruktur gespeichert werden. Wie oben erwähnt, erstellt die Blame-Datenstruktur Verweise zu tatsächlichen und repräsentativen Zeilen. Mithilfe einer Blame-Datenstruktur kann ein Beispielsystem alle repräsentativen Zeilen für eine Datei bestimmen, für die Anmerkungen angezeigt werden sollen. Die an diesen repräsentativen Zeilen gespeicherten Anmerkungen können dann gefunden werden. Anders formuliert, kann eine Bestimmung dazu dienen, die Anmerkung in einer bestimmten Version des Codes anzuzeigen, basierend auf den repräsentativen Zeilen einer aktuellen Datei. Blame-Daten können Daten beinhalten, die den Commit anzeigen, der für eine bestimmte Änderung oder Revision an einer Zeile einer Datei verantwortlich ist. Die inkrementelle Blame-Datenstruktur kann eine schnelle Suche nach repräsentativen Zeilen durchführen, um die verantwortlichen Commits für jede Zeile einer Datei zu bestimmen. Jede Information über die Anmerkung, einschließlich der Anhänge für die Anmerkung, kann auf der Blame-Ebene gespeichert werden.To perform a quick search for annotations to lines in the source code, precalculated blame data must be obtained and stored in a sample Blame data structure. As mentioned above, the Blame data structure creates references to actual and representative rows. Using a blame data structure, a sample system can designate all representative rows for a file for which annotations are to be displayed. The annotations stored on these representative lines can then be found. In other words, a determination may be to display the annotation in a particular version of the code based on the representative lines of a current file. Blame data can include data that indicates the commit responsible for a particular change or revision to a line of a file. The Blame incremental data structure can perform a quick lookup for representative rows to determine the responsible commits for each row of a file. Any information about the annotation, including attachments for the annotation, can be stored at the Blame level.
Ein Beispielverfahren für die Anzeige relevanter Anmerkungen über verschiedene Revisionen einer Datei kann mit dem Empfang einer aktuellen Revision einer Datei beginnen, wie dargestellt in
Eine einfache Lösung, sämtliche Blame-Daten zu finden, könnte darin bestehen, die Blame-Informationen für sämtliche Dateien zu berechnen, die in einem bestimmten Commit sichtbar sind. Ein Beispiel-Commit-Crawler (
Die Datei im Commit (
Ein Beispiel-Commit-Crawler (
Ein Beispielverfahren für das Erstellen einer Blame-Datenstruktur für eine Datei beginnt mit dem Empfang mindestens einer Datei, wie dargestellt in
In einer Beispiel-Blame-Struktur können veränderte und/oder hinzugefügte Zeilen als Ursprung gekennzeichnet und mit sich selbst verknüpft werden. Eine Beispiel-Blame-Struktur verweist von aktuellen tatsächlichen Zeilen zu deren Ursprungszeilen. Ursprungszeilen sind mit sich selbst verknüpft. Eine Referenz zu einer Ursprungszeile kann ein Tupel der Nummer einer Revision einer Datei und einer Zeilennummer bei der entsprechenden Revision sein. Daher wäre in der Blame-Datenstruktur, wie dargestellt in
Wie dargestellt in
Die Ermittlung des Ursprungs durch das Zurückverfolgen übergeordneter Revisionen einer Datei, die einer Dateizeile zugewiesen sind, kann etwas umständlich sein. Wenn eine Zeile nur zu einer übergeordneten Revision einer Datei zurückverfolgt werden kann, wird die Ursprungsinformation von der übergeordneten Revision der Datei auf die Zeile kopiert. Kann eine Zeile zu mehreren übergeordneten Revisionen einer Datei zurückverfolgt werden, besteht möglicherweise ein Blame-Konflikt.Determining the origin by tracing the parent revisions of a file assigned to a file line can be a bit cumbersome. If a line can only be traced back to a parent revision of a file, the source information is copied from the parent revision of the file to the line. If a line can be traced to multiple parent revisions of a file, there may be a blame conflict.
Ein Blame-Konflikt kann entstehen, wenn eine Zeile einen Bezug zu zwei oder mehr möglichen Quellzeilen herstellen kann. Diese potenziellen Quellzeilen können von verschiedenen Revisionen einer Datei stammen und im Falle von Dateiverschiebungen auch unterschiedliche Namen haben. Entsteht ein Blame-Konflikt, kann dieser Konflikt zugunsten des ältesten Commits behoben werden. Dies basiert auf einem Zeitstempel, da diese Lösung die größte Verbindung zwischen Branches bietet. Der Konflikt kann auch gelöst werden, indem der letzte Commit verwendet wird, der anhand des Commit-Zeitstempels bestimmt wird. Dieses Verfahren ist in Versionsverwaltungssystemen standardmäßig eingestellt. Alternativ kann der Commit, der an erster (oder letzter) Stelle in einer Liste übergeordneter Commits steht, mithilfe einer übergeordneten Kennung zur Lösung des Konflikts ausgewählt werden. Jeder Commit (mit Ausnahme des ersten Commits in einem Repository) besitzt mindestens einen übergeordneten Commit. Hat ein Commit mehrere übergeordnete Commits, muss ein Benutzer deren Reihenfolge (explizit oder implizit) in einer Auflistung der Commits bestimmen. Die Reihenfolge darf nicht verändert werden, sobald sie festgelegt wurde.A blame conflict can arise when a line can relate to two or more possible source lines. These potential source lines may come from different revisions of a file and, in the case of file relocations, may also have different names. If a blame conflict arises, this conflict can be resolved in favor of the oldest commit. This is based on a timestamp, as this solution provides the largest connection between branches. The conflict can also be resolved by using the most recent commit determined by the commit timestamp. This procedure is set by default in version control systems. Alternatively, the commit that is first (or last) in a list of parent commits can be selected by using a parent identifier to resolve the conflict. Each commit (except the first commit in a repository) has at least one parent commit. If a commit has multiple parent commits, a user must determine their order (explicitly or implicitly) in a list of commits. The order must not be changed once it has been set.
Ein Beispiel für einen Blame-Konflikt wird dargestellt in
In manchen Ausführungsformen ändert sich der Inhalt im Vergleich mit einem übergeordneten Commit nicht, jedoch unterscheiden sich die zugewiesenen Blame-Informationen zwischen den Commits. So zum Beispiel in Commit #4 von Datei #2, wie dargestellt in
Eine Beispiel-Blame-Datenstruktur kann auch (bzw. alternativ) eine Regel beinhalten, nach der eine Zeile nicht zweimal innerhalb derselben Blame-Datenstruktur ausgewählt werden kann. In diesem Beispiel wird Commit #1 bereits als der Blame-Ursprung für Zeile 1 verwendet und sollte somit nicht für Zeile 3 ausgewählt werden. Die Limitierung einer Datenstruktur auf der Blame-Ebene, dieselbe Zeile nicht zweimal als Blame-Ursprung innerhalb der Blame-Datenstruktur zu verwenden, könnte die doppelte Anzeige einer Anmerkung verhindern. Würde dieselbe Zeile innerhalb einer Datei zweimal verantwortlich gemacht (referenziert) werden, würden die der Zeile zugewiesenen Anmerkungen nur einmal gezählt, jedoch zweimal angezeigt werden.An example blame data structure may also (or alternatively) include a rule that a row can not be selected twice within the same blame data structure. In this example, commit # 1 is already used as the blame origin for
Es kann auch zu Problemen führen, wenn sich Zeilen in unterschiedlichen Dateien auf dieselbe repräsentative Zeile beziehen, was bei Dateikopien auftreten könnte. Datei f könnte beispielsweise aus dem ersten Verzeichnis a/b in das zweite Verzeichnis a/c kopiert werden, wodurch die zweite Datei g entsteht. Beide Dateien teilen dieselben repräsentativen Zeilen (mit Ursprung in der Datei f). Diese beiden Dateien können identische Blame-Datenstrukturen besitzen. Werden Datei f Informationen wie etwa eine Log-Meldung hinzugefügt, werden diese Informationen auf der Blame-Ebene gespeichert und mit Datei g geteilt. Diese Zeile auf der Blame-Ebene ist in Datei g sichtbar. Darüber hinaus sind jegliche zu Datei g hinzugefügte Informationen auch in Datei f sichtbar. Angenommen die Dateien f und g sind die einzigen Dateien im Verzeichnis und es gibt eine einzelne Anmerkung in Datei f, würde ein Beispielsystem eine Anmerkung für Verzeichnis a/, eine Anmerkung für Verzeichnis a/b/ und eine Anmerkung für Verzeichnis a/c/ zählen. In einem übergeordneten Verzeichnis, wie etwa a/, würde eine Anmerkung je nach Implementierung der Aggregation nur einmal angezeigt werden, jedoch würde man aus Konsistenzgründen zwei erwarten.It can also cause problems if lines in different files are the same representative row, which could occur with file copies. For example, file f could be copied from the first directory a / b to the second directory a / c, resulting in the second file g. Both files share the same representative lines (originating in file f). These two files can have identical blame data structures. If file f information such as a log message is added, this information is stored at the blame level and shared with file g. This line at the blame level is visible in file g. In addition, any information added to file g is also visible in file f. Assuming the files f and g are the only files in the directory and there is a single note in file f, a sample system would count a note for directory a /, a note for directory a / b / and a note for directory a / c / , In a parent directory, such as a /, an annotation would be displayed only once, depending on how the aggregation was implemented, but two would be expected for consistency reasons.
Um den ältesten Ursprung zu ermitteln, nutzt ein Beispiel-Commit-Crawler einen Zeitstempel jedes Commits (z. B. der Zeitstempel vom Zeitpunkt der Erstellung des Commits im verteilten Versionsverwaltungssystem), um den ältesten Commit zu bestimmen. Enthalten zwei Zeilen in derselben Revision einer Datei denselben Ursprung (was nach dem Zusammenführen (Mergen) vorkommen kann), wird die letzte Zeile als neue Ursprungszeile gekennzeichnet. Zwei Zeilen aus einem Commit – jedoch beziehen sich verschiedene Dateien nach dem Kopieren oder Verschieben auf denselben Ursprung. Um in diesem Fall zwei Zeilen daran zu hindern, denselben Ursprung zu haben, muss eine von mehreren Maßnahmen erfolgen. Dateibewegungen können beispielsweise gänzlich ignoriert werden. Ein weiteres Beispiel wäre, die Unterschiede zwischen übergeordneten Commits zu finden, um zu ermitteln, ob die Unterschiede zu Inkonsistenzen im Index führen könnten, und einen Satz verwendeter Ursprünge zu pflegen, um Duplikate zu vermeiden. Alle referenzierten Zeilen in Dateien eines Commits könnten in einem Satz gespeichert werden, um einen Satz verwendeter Ursprünge zu erstellen. Anschließend kann durch eine einfache Suche bestimmt werden, ob sich eine andere Datei bereits auf eine Zeile bezieht. Um die Ursprungszeilen für eine größere Anzahl an Dateien zu bestimmen, muss eine feste Implementierung erstellt werden, die gemeinsame Daten zwischen Commits teilt. Persistente Bäume sind eine Lösung. Zeilen und Ihre Ursprünge können dann zu der Blame-Datenstruktur einer Datei hinzugefügt werden.To find the oldest origin, a sample commit crawler uses a timestamp of each commit (for example, the timestamp from the time the commit was created in the distributed versioning system) to determine the oldest commit. If two lines in the same revision of a file contain the same origin (which may occur after merge), the last line will be marked as a new source line. Two lines out of a commit - however, after copying or moving, different files refer to the same origin. In this case, to prevent two lines from having the same origin, one of several measures must be taken. For example, file movements can be completely ignored. Another example would be to find the differences between parent commits to determine if the differences could lead to inconsistencies in the index and maintain a set of used origins to avoid duplicates. All referenced rows in files of a commit could be stored in a sentence to create a set of used origins. Subsequently, it can be determined by a simple search whether another file already refers to a line. To determine the source lines for a larger number of files, a fixed implementation must be created that shares common data between commits. Persistent trees are a solution. Lines and their origins can then be added to the blame data structure of a file.
Zwar können Blame-Informationen für alle in einem Commit sichtbaren Dateien berechnet werden, jedoch können auch Kurzbefehle verwendet werden, um Zeit und Speicher zu sparen. Für jeden Commit kann beispielsweise ein Verweis von Dateinamen zu einem Fingerabdruck der entsprechenden Blame-Informationen gespeichert werden. Dann reicht es aus, nur die Blame-Informationen für die Dateien neu zu berechnen, die unterschiedliche Fingerabdrücke in übergeordneten Commits haben. Außerdem können Dateien ausgeschlossen werden, die nur an einem der beiden Branches berührt wurden. Zwei Dateien mit demselben Inhalt können unterschiedliche Blame-Informationen besitzen. Daher ist der Fingerabdruck über Blame-Informationen eindeutiger als der Fingerabdruck über dem Dateiinhalt. Durch die Nutzung des Fingerabdrucks über Blame-Informationen können Dateien mit unverändertem Inhalt, aber sich ändernden Blame-Informationen schnell gefunden werden.Although blame information can be calculated for all files visible in a commit, shortcuts can also be used to save time and memory. For each commit, for example, a reference from filenames to a fingerprint of the corresponding blame information may be stored. Then it's enough to recompute only the blame information for files that have different fingerprints in parent commits. In addition, files that have only been touched on one of the two branches can be excluded. Two files with the same content can have different blame information. Therefore, the fingerprint over blame information is more distinct than the fingerprint over the file content. By using the fingerprint over blame information, files with unmodified content but changing blame information can be found quickly.
In einer Beispiel-Ausführungsform kann ein Kennzeichnungsschema eingesetzt werden, um alle für einen bestimmten Commit sichtbaren Zeilen schnell aufzurufen. Eine Möglichkeit, sichtbare Zeilen in einer bestimmten Revision einer Datei zu finden ist, sämtliche Zeilen mit allen Commit-Hashes (die die Commits identifizieren) zu markieren, unter denen diese Zeilen sichtbar sind. Das Abfragen eines Satzes sichtbarer Zeilen wäre dann ein einfacher Filter-Task durch den Commit-Hash-Wert. Dieser Ansatz hat jedoch auch Nachteile – vor allem in Bezug auf den Speicherbedarf und die Crawling-Zeit. Bei jedem Crawl eines Commits müssten sämtliche Zeilen des Commits gezählt werden. Diese Zählung kann auch Zeilen und Dateien beinhalten, die nicht verändert wurden. Stattdessen kann ein Beispiel-Kennzeichnungsschema erstellt werden, das weniger Speicher und Zeit für das Bestimmen sichtbarer Zeilen innerhalb eines bestimmten Commits benötigt.In an example embodiment, a tagging scheme may be used to quickly invoke all lines visible to a particular commit. One way to find visible rows in a given revision of a file is to mark all rows with all commit hashes (which identify the commits) under which those rows are visible. Querying a set of visible rows would then be a simple filter task by the commit hash value. However, this approach has its drawbacks - especially in terms of storage requirements and crawling time. Each time a commit is crawled, all the lines of the commit must be counted. This count can also include lines and files that have not been altered. Instead, an example labeling scheme can be created that requires less memory and time to determine visible rows within a particular commit.
In einem Beispiel-Kennzeichnungsschema, das Konflikte mithilfe von Zeitstempeln löst, erhält jeder Commit zwei einzigartige Kennzeichnungen: eine für hinzugefügte Zeilen (+L) und eine für entfernte Zeilen (–L). Kennzeichnungen können gegen einen der übergeordneten Commits der Datei erstellt werden. Zu Kennzeichnungszwecken können veränderte Zeilen als entfernt oder hinzugefügt angesehen werden. Wie beispielsweise dargestellt in
Für jeden Commit kann eine Bool'sche Abfrage erstellt werden, die überprüft, ob eine bestimmte Ursprungszeile zu dem Commit gehört. Die rekursive Formel kann wie folgt lauten: IsVisible(line, commit) = (IsVisible(line, first_parent(commit)) OR not –L(line, commit)) OR +L(line, commit). Diese Formel sammelt alle im übergeordneten Commit sichtbaren Zeilen, schließt alle entfernten Zeilen in der aktuellen Revision der Datei aus und schließt neu zu der aktuellen Revision der Datei hinzugefügten Zeilen ein. Diese Formel wächst linear mit der Tiefe des übergeordneten Commits. Nutzt ein Commit keine Kennzeichnungen (z. B. keine Zeilen wurden hinzugefügt – es besteht kein Bedarf für eine +L Kennzeichnung), kann er aus der Abfrage ausgeschlossen werden. Abfragen können als Teil der Metadaten für Commits gespeichert werden.For each commit, you can create a Boolean query that checks whether a particular source line belongs to the commit. The recursive formula can be: IsVisible (line, commit) = (IsVisible (line, first_parent (commit)) OR notL (line, commit)) OR + L (line, commit). This formula gathers all lines visible in the parent commit, excludes any removed lines in the current revision of the file, and rejoins the current revision of the added lines file. This formula grows linearly with the depth of the parent commit. If a commit does not use tags (eg no rows have been added - there is no need for a + L tag), it can be excluded from the query. Queries can be stored as part of the metadata for commits.
Werden Konflikte mithilfe von Zeitstempeln gelöst, wächst die Formel exponentiell mit der Anzahl der Merges. Die rekursive Formel könnte wie folgt lauten: IsVisible(line, commit) = ((IsVisible(line, parent #1) OR IsVisible(line, parent #2) OR ... OR IsVisible(line, parent #n)) && not –L(line, commit)) OR +L(line, commit), n ist hierbei die Anzahl der Vorgänger des Commits. Die Formel kann als Bool'sches Diagramm dargestellt sein, in dem gemeinsame Bestandteile nur einmal vorkommen. Dieses Diagramm kann linear mit der Anzahl an Vorgänger-Commits wachsen.If conflicts are resolved using timestamps, the formula grows exponentially with the number of merges. The recursive formula might be: IsVisible (line, commit) = ((IsVisible (line, parent # 1) OR IsVisible (line, parent # 2) OR ... OR IsVisible (line, parent #n)) && not -L (line, commit)) OR + L (line, commit), where n is the number of predecessors of the commit. The formula can be represented as a Boolean diagram in which common components occur only once. This graph can grow linearly with the number of predecessor commits.
In Datei #1 können alle Zeilen mit der Kennzeichnung (A) versehen sein, da alle Zeilen hinzugefügt und im Root-Commit sichtbar sind. Alle Zeilen in Datei #2 können ebenfalls mit (A) gekennzeichnet werden. Commit #2 hat die positive Kennzeichnung B und die negative Kennzeichnung b. Da der Vorgänger von Commit #2 Commit #1 ist, kann die Abfrage für Commit #2 die Abfrage von Commit #1 erweitern: (A AND (NOT b)) OR B. Die Kennzeichnungen für Commit #1 können basierend auf den Revisionen in Commit #2 geändert werden – wie dargestellt in
Die Kennzeichnung von Datei #2 in Commit #1 ändert sich nicht für Commit #2. Die Kennzeichnungen von Datei #2 in Commit #2 könnten wie folgt lauten: Zeile 1, A übertragen aus Zeile 1 von Commit #1 für Datei #2, da diese Zeile aus Commit #1 stammt; Zeile 2, B, da diese Zeile aus Commit #2 stammt, Zeile 3 kann A sein, übertragen aus Zeile 3 von Commit #1, da die Ursprungszeile aus Commit #1 stammt, und Zeile 4 kann mit B gekennzeichnet sein, da die Zeile in Commit #2 hinzugefügt wurde.The flag of
Commit #3 hat die positive Kennzeichnung C und die negative Kennzeichnung c. Da der übergeordnete Commit Commit #1 ist, kann die Abfrage für Commit #3 die Abfrage für Commit #1 erweitern. (A AND (NOT c)) OR C. Wie dargestellt in
Kennzeichnungen für den Inhalt von Datei #1 in Commit #3 könnten wie folgt lauten: Zeile 1, A, übertragen aus Zeile 1 von Commit #1; Zeile 2, C; Zeile 3, C und Zeile 4, C. Die Kennzeichnung von Datei #2 in Commit #1 bleibt gleich. Jedoch können die Kennzeichnungen von Datei #2 in Commit #3 wie folgt lauten: Zeile 1, A, übertragen aus Zeile #1 von Commit #1; Zeile 2, A, übertragen aus Zeile 2 von Commit #1; Zeile 3, C; und Zeile 4, C.Labels for the contents of
Commit #4 kann mit der positiven Kennzeichnung D und der negativen Kennzeichnung d versehen sein – wie dargestellt in
- 1. (((A AND (NOT b)) OR B) AND (NOT d)) OR D
- 2. (((A AND (NOT c)) OR C) AND (NOT d)) OR D
- 1. (((A AND (NOT b)) OR B) AND (NOT d)) OR D
- 2. (((A (NOT c)) OR C) AND (NOT d)) OR D
Je nach Blame-Strategie kann eine andere Abfrage eingesetzt werden. In den meisten Fällen sollten beide Abfragen den Befehl „OR” (ODER) enthalten. Ein Beispiel nach der Vereinfachung: (((A AND (NOT b)) OR (A AND (NOT c)) OR B OR C) AND (NOT d)) OR D. Mithilfe eines gerichteten azyklischen Graphen für die Formulierung der Abfrage kann der üblichere Teil von Commit #1 einfacher wiederverwendet werden. Die Kennzeichnungen für den Inhalt von Datei #1 in Commit #1 ändern sich nicht. Die Kennzeichnungen für den Inhalt von Datei #1 in Commit #3 können wie folgt lauten: Zeile 1, A, übertragen aus Zeile #1 von Commit #1; Zeile 2, C, d; Zeile 3, C, d; Zeile 4, C, übertragen aus Zeile 4 von Commit #3 – wie dargestellt in
Um Abfragen effizienter zu gestalten, kann ein Beispiel-Kennzeichnungsschema gelegentlich umfassende Verdichtungen durchführen, durch die Abkürzungskennzeichnungen entstehen. Umfassende Verdichtungen können stattfinden, wenn die Länge der Abfrage einen bestimmten Wert erreicht oder andere bestimmte Kriterien erfüllt. Diese Kriterien können beim Crawling ausgewertet werden. Sind die Kriterien erfüllt, kann eine Abkürzungskennzeichnung für eine Abfrage gespeichert werden, damit die Abkürzungskennzeichnung in nachfolgenden Commits eingesetzt werden kann. Dateien, die die Anforderungen der ursprünglichen Abfrage erfüllen, können mithilfe der entsprechenden Abkürzungskennzeichnung aktualisiert werden.In order to make queries more efficient, an example labeling scheme may occasionally perform extensive compaction that gives rise to abbreviation tags. Complex densities can take place when the length of the query reaches a certain value or meets other specific criteria. These criteria can be evaluated during crawling. If the criteria are met, an abbreviation identifier for a query can be stored so that the abbreviation identifier can be used in subsequent commits. Files that meet the requirements of the original query can be updated using the appropriate abbreviation identifier.
Diese Neukennzeichnung kann mehrere Dateien verschiedener Commits betreffen. Eine Neukennzeichnung könnte daher asynchron zum Crawling durchgeführt werden. Neue Commits, die die Abkürzungskennzeichnung nutzen, funktionieren erst wieder, wenn die asynchrone Neukennzeichnung abgeschlossen ist. Daher werden sowohl die lange als auch die kurze Abfrage zu Commits propagiert. Die kurze Version der Abfrage wird beibehalten und die Tupel geplanter Abfragen werden nachverfolgt. Soll eine Abfrage ausgewertet werden, die eine der noch nicht abgeschlossenen Austausch-Kennzeichnungen verwendet, kann die Abfrage durch den Ersatz der Austausch-Kennzeichnung mit einer entsprechenden Abfrage erweitert werden.This redirection can affect several files of different commits. A new flag could therefore be performed asynchronously to crawling. New commits that use the shortcut flag will not work until the asynchronous re-flag is complete. Therefore, both the long and the short query are propagated to commits. The short version of the query is preserved and the tuples of scheduled queries are tracked. If a query is to be evaluated that uses one of the not yet completed exchange markings, the query can be extended by replacing the replacement mark with a corresponding query.
Eine umfassende Verdichtung kann auch die Suche nach allen Anfragen beinhalten, die eine vorbestimmte Länge überschreiten, und die Festlegung eines Satzes an Abfragen, die durch neue Kennzeichnungen ersetzt werden sollen. Für jede Anfrage des Satzes werden passende Ursprungszeilen gezählt und eine Austausch-Kennzeichnung angehängt. Austausch-Kennzeichnungen können eingeführt werden, wenn die Verdichtung ausgelöst wird, und für spätere Abfragen-Strukturen eingesetzt werden. Diese Verdichtung kann vom Commit-Crawler geplant werden, wenn er auf einen Commit mit einer langen Abfrage trifft. Ein Vorteil dieses Verfahrens besteht darin, dass die Verdichtung deterministisch ist und ein neuer Crawl dieselben Abkürzungen erstellen wird.Comprehensive compaction may also include searching for all requests that exceed a predetermined length and specifying a set of queries to be replaced by new identifiers. For each request of the sentence, matching source lines are counted and an exchange tag is appended. Exchange tags can be introduced when the compaction is triggered and used for later query structures. This compaction can be scheduled by the commit crawler when it encounters a commit with a long query. An advantage of this method is that the compression is deterministic and a new crawl will create the same abbreviations.
Ein Beispiel-Kennzeichnungsschema kann zusätzlich oder alternativ Abkürzungskennzeichnungen vor deren Verwendung reservieren, um die Länge der Abfrage zu verringern. Abkürzungskennzeichnungen können untergeordneten Commits zugeteilt werden. Eine reservierte Abkürzungskennzeichnung kann von demselben Vorgänger nur an einen Nachfolger übertragen werden. Derartige Kennzeichnungen sammeln Änderungen auf ihrem Propagierungspfad und können für das Kürzen von Abfragen eingesetzt werden. Auf diese Weise kann die Reihenfolge des Abfragen-Wachstums von linear zu logarithmisch reduziert werden.An example tagging scheme may additionally or alternatively reserve shortcut tags prior to their use to reduce the length of the query. Abbreviation tags can be assigned to subordinate commits. A reserved abbreviation identifier can only be transferred from the same predecessor to a successor. Such labels collect changes on their propagation path and can be used to truncate queries. In this way, the order of query growth can be reduced from linear to logarithmic.
Ein Beispiel für die Kennzeichnung ist in
Für jede Kennzeichnung stellt ein Suchen-Backend einen Iterator bereit, der jedes Dokument iteriert, das jeder Kennzeichnung in der Reihenfolge entspricht. Das Suchen-Backend kann eine Dokumentenkennung speichern, auf die der Iterator derzeit gerichtet ist, und eine Funktion für das Vorantreiben bieten, bei der eine Dokumentenkennung als Eingang verwendet und der Iterator zum nächsten Dokument in dem Satz bewegt wird, der nicht kleiner ist als die bereitgestellte Dokumentenkennung. Ist die nächste Dokumentenkennung kleiner oder gleich der aktuellen Dokumentenkennung, geschieht nichts mit dem Suchen-Backend. Eine einfache Beispielimplementierung der Iterator-Klasse ist dargestellt in
Ein Beispielschema kann die folgenden Eigenschaften besitzen: Die Anzahl der Kennzeichnungsänderungen kann in der Reihenfolge der Anzahl an Unterschieden zwischen der aktuellen Datei und ihren früheren Revisionen basieren; die Anzahl der Kennzeichnungen kann in einer beliebigen Zeile in der Reihenfolge der Anzahl an Commits stehen, die eine bestimmte Zeile berühren, sowie Abkürzungskennzeichnungen, die dieser Zeile zugewiesen sind; und Abfragen für das Bestimmen, ob eine Zeile in einem Commit sichtbar ist, kann nach jeder umfassenden Verdichtung konstant sein, kann jedoch linear oder logarithmisch mit der Anzahl eingehender Commits wachsen, je nach der Commit-Diagrammstruktur seit der letzten umfassenden Verdichtung.An example schema may have the following characteristics: The number of label changes may be based on the number of differences between the current file and its previous revisions; the number of tags can be in any row in the order of the number of commits that touch a particular row, as well as shortcut tags assigned to that row; and queries for determining whether a row is visible in a commit may be constant after each full compression, but may grow linearly or logarithmically with the number of incoming commits, depending on the commit chart structure since the last full compression.
Die inkrementelle Beispiel-Blame-Datenstruktur und das Kennzeichnungsschema sind nützliche Tools für die Entscheidung, welche Anmerkungen in einer integrierten Entwicklungsumgebung (IDE) zu einem bestimmten Zeitpunkt oder in einer bestimmten Revision angezeigt werden sollen. Wie oben beschrieben, können Anmerkungen von mehreren Quellen stammen, beispielsweise eine statische Code-Analyse, Produktionssysteme, Rechtschreibprüfungen oder Kollaborationstools. Sie können zusätzliche Informationen bezüglich des Codes liefern, die für das Verständnis seiner Aufgabe bzw. Funktionalität oder bei der Suche nach Möglichkeiten relevant sein können, den Code zu verändern und Fehler im Code zu beheben.The sample incremental blame data structure and labeling scheme are useful tools for deciding which annotations to display in an integrated development environment (IDE) at a specific time or revision. As described above, annotations can come from multiple sources, such as static code analysis, production systems, spell checkers, or collaboration tools. You can provide additional information regarding the code, that may be relevant to understanding his or her role or functionality, or finding ways to modify the code and fix bugs in the code.
Soll eine Anmerkung für eine Zeile in einer bestimmten Version einer Datei erstellt werden, kann die Ursprungszeile in einer Beispiel-Blame-Datenstruktur gefunden und die Anmerkung dem Zeilenursprung zugewiesen werden, wie dargestellt in
Um die Suche von Anmerkungen zu ermöglichen, müssen Anmerkungen in einem Suchen-Backend platziert werden, beispielsweise einer Datenbank, einer Hash-Tabelle oder einem anderen Speichermechanismus. Jede Anmerkung bezieht sämtliche Commit-Kennzeichnungen von der ihr zugewiesenen Ursprungszeile (
Eine schnelle Aggregation von Anmerkungen kann durch Abtastung erreicht werden, indem die zufälligen Fingerabdrücke im Anmerkungsbereich verwendet werden, bis eine ausreichende Anzahl an Ergebnissen gefunden wurde, um diese dem Benutzer mit der erforderlichen Genauigkeit anzuzeigen. Falls sich sämtliche Daten beispielsweise auf einem Rechner befinden, werden die Dokumente in der Reihenfolge der Hashes iteriert, bis eine bestimmte Anzahl an Ergebnissen (z. B. 1000) erzielt wurde. Die Gesamtzahl der Ergebnisse kann daraufhin geschätzt werden, indem die Anzahl gefundener Ergebnisse, in diesem Beispiel 1000, durch den Abschnitt des durchsuchten Hash-Bereichs geteilt wird.Quick aggregation of annotations can be accomplished by sampling by using the random fingerprints in the annotation area until a sufficient number of results are found to display to the user with the required accuracy. For example, if all the data is on a machine, the documents are iterated in order of hashes until a certain number of results (eg, 1000) have been obtained. The total number of results can then be estimated by dividing the number of results found, in this example 1000, by the portion of the searched hash area.
Die Daten können auf mehrere Rechner verteilt werden, und jeder Rechner ist für ein abgeschlossenes Intervall des Hash-Bereichs verantwortlich. Ein einfacher Vorgang kann angewandt werden. Bei 100 Rechnern sucht beispielsweise jeder Rechner nach 10 Ergebnissen. Jeder Rechner sendet die Daten bezüglich der gefundenen Ergebnisse und des durchsuchten Hash-Bereichs zurück. Die Ergebnisse jedes Rechners werden summiert und eine Abschätzung kann berechnet werden. Ist die Gesamtzahl der Ergebnisse deutlich niedriger als die festgelegte Anzahl – sollten beispielsweise bei 1000 angeforderten Ergebnissen nur 100 gefunden werden – ist die Abschätzung möglicherweise ungenau. Um eine genauere Abschätzung zu erzielen, muss das Verfahren erneut mit einer höheren Ergebniszahl pro Rechner durchgeführt werden. Je nach Suchen-Backend können die gesammelten Werte anstelle der einzelnen Anmerkungen an jeder Ebene des Suchen-Backends ausgegeben werden.The data can be spread across several computers and each computer is responsible for a completed interval of the hash area. A simple process can be applied. For example, with 100 computers, each computer searches for 10 results. Each machine returns the data regarding the results found and the searched hash area. The results of each calculator are summed and an estimate can be calculated. If the total number of results is significantly less than the specified number-for example, if you find only 100 out of 1000 requested results-the estimate might be inaccurate. To get a more accurate estimate, the procedure must be performed again with a higher score per calculator. Depending on the search backend, the collected values may be output instead of the individual annotations at each level of the search backend.
Diese Aggregation ermöglicht zudem die Rückverfolgung von Anmerkungen, die aus einem bestimmten Tool stammen und für beliebige Versionen ausgeführt werden. Statt einfach eine neue Anmerkung zu erstellen, kann durch ein Beispielverfahren bestimmt werden, ob eine Anmerkung bereits in einer früheren Version an der Ursprungszeile existiert. Falls eine Anmerkung existiert, wird sie einfach wiederverwendet und bei Bedarf mit zusätzlichen Informationen aus der neuen Version ergänzt.This aggregation also allows tracing annotations that come from a particular tool and run on any version. Instead of simply creating a new annotation, a sample method can be used to determine if an annotation already exists on the source line in an earlier version. If a note exists, it is easily reused and supplemented with additional information from the new version as needed.
Produziert ein Tool zahlreiche Anmerkungen, kann ein weiterer Satz an Kennzeichnungen, Tool-Kennzeichnungen, für jede Anmerkung bereitgestellt werden, und ein Beispielverfahren kann bestimmen, ob das Tool ausgeführt wurde. Das Tool kann dann nur die Unterschiede zwischen der neuen und der alten Ausführung berichten. Jede Anmerkung, die nicht Teil der neuen Ausführung ist, kann mit der Kennzeichnung (–L) der entsprechenden Ausführung versehen werden (oder Commit, wenn es nur eine Ausführung pro Commit gibt) und jede neue Anmerkung kann mit der Kennzeichnung (+L) versehen werden. Das Paar (tool_label, tool_query; („Tool_Kennzeichnung, Tool_Abfrage”)) für die neue Ausführung kann aus der vorherigen Ausführung konstruiert werden – so wie die Konstruktion des Paars (Kennzeichnung, Abfrage) für Commits funktioniert (basierend auf einem übergeordneten Commit). Die Suche nach Anmerkungen einer Ausführung kann eine einfache Suche nach einem bestimmten (tool_label, tool_query)-Paar in dem neuen Kennzeichnungssatz der Anmerkungen umfassen. Die Suche nach Anmerkungen einer bestimmten Ausführung in einem anderen Commit beinhaltet einfach die Beschränkung der Suche mit dem Paar (tool_label, tool_query) der entsprechenden Ausführung und dem Paar (Kennzeichnung, Abfrage) des Commits, in dem die Anmerkungen gesucht werden sollen. Diese Art der Suche kann nützlich sein, da manche Tools zwar einige Commits decken, jedoch nicht alle. Eine Beispiel-Ausführungsform würde die nächsten Ergebnisse zu einem ungedeckten Commit anzeigen. Ein zweites (tool_label, tool_query)-Paar kann aus Ausführungen stammen, die ein lineares oder geführtes azyklisches Diagramm definieren, dessen Struktur dem Commit-Diagramm ähnelt.If a tool produces many annotations, another set of tags, tool tags, can be provided for each note, and a sample method can determine if the tool has been executed. The tool can then only report the differences between the new and the old version. Any annotation that is not part of the new execution can be tagged (-L) with the appropriate execution (or committed if there is only one execution per commit), and each new annotation can be tagged (+ L) become. The pair (tool_label, tool_query;) for the new execution can be constructed from the previous execution - just as the construction of the pair (flag, query) works for commits (based on a parent commit). The search for annotations of an execution can be a simple search for a particular (tool_label, tool_query) pair in the new identifier set Include comments. Searching for annotations of a particular execution in another commit simply involves restricting the search with the pair (tool_label, tool_query) of the corresponding execution and the pair (id, query) of the commit in which the annotations are to be searched. This type of search can be useful because some tools cover some commits, but not all. An example embodiment would display the next uncovered commit results. A second (tool_label, tool_query) pair may come from implementations that define a linear or guided acyclic diagram whose structure is similar to the commit diagram.
Der vorgeschlagene Index kann eine effiziente Berechnung von Kreuzungen, Unterschieden und Verbindungen von Anmerkungen zwischen Commits und/oder Ausführungen ermöglichen. Bei der Softwareentwicklung können sich diese Berechnungen bei der Analyse von Produktionsproblemen als hilfreich erweisen. Eine Anmerkung kann beispielsweise für jede Log-Ausgabe während der Entwicklung hinzugefügt werden. Diese Anmerkungen können automatisch an einem Entwicklungs-Branch erscheinen, an dem der Softwareentwickler das Problem beheben möchte. Zusätzlich sind Statistiken mit der Anzahl an Log-Statements in einem Projekt oder den Unterschieden der Ereignisse zwischen zwei Einsätzen verfügbar.The proposed index may allow efficient calculation of crossings, differences, and annotations between comments and / or executions. In software development, these calculations can be helpful in analyzing production issues. For example, an annotation can be added for each log output during development. These annotations may automatically appear on a development branch where the software developer wants to fix the problem. In addition, statistics are available with the number of log statements in a project or the differences in events between sessions.
Eine weitere Einsatzmöglichkeit sind Codeprüfungen, bei denen Tools für bestimmte Schattenkopien potenzielle Programmierfehler ermitteln. Mit dem Beispielsystem können Anmerkungen effizient bei späteren Schattenkopien sichtbar gemacht werden, bei denen das Tool noch nicht ausgeführt wurde. Diese Anmerkungen können darüber hinaus im Verlauf für das gesamte Repository effizient verfolgt werden, um die Integrität des Codes zu ermitteln. Anmerkungen sind nur für spätere Commits sichtbar und nicht für Vorgängerversionen. Anmerkungen können für spätere Commits als behoben markiert werden. Anmerkungen können nachverfolgt werden, selbst wenn eine Zeile geändert oder gelöscht wurde. Benutzerkommentare sollten beispielsweise nicht ohne Eingaben durch den Benutzer verschwinden.Another use is code checking where tools for certain shadow copies detect potential programming errors. With the example system, annotations can be efficiently made visible on later shadow copies where the tool has not yet been executed. These annotations can also be efficiently tracked throughout the repository to determine the integrity of the code. Annotations are only visible for later commits and not for previous versions. Annotations can be marked as fixed for later commits. Annotations can be tracked even if a line has been changed or deleted. For example, user comments should not disappear without user input.
Je nach der gewünschten Konfiguration kann es sich bei dem Prozessor (
Abhängig von der gewünschten Konfiguration kann der Systemspeicher (
Das Computergerät (
Der Systemspeicher (
Das Computergerät (
Die vorstehende detaillierte Beschreibung hat verschiedene Ausführungsformen der Geräte und/oder Prozesse über die Verwendung von Blockdiagrammen, Flussdiagrammen und/oder Beispielen. Insoweit wie solche Blockdiagramme, Flowcharts und/oder Beispiele eine oder mehrere Funktionen und/oder Operationen beinhalten, werden sie verstanden von denen in der Wissenschaft, das jede Funktion und/oder Operation mit solchen Blockdiagrammen, Flowcharts oder Beispielen implementiert werden können, individuell und/oder kollektiv, durch ein weites Angebot von Hardware, Software, Firmware der irgendeiner virtuellen Kombination davon. In einer Ausführungsform können einige Teile des hier beschriebenen Gegenstands über anwendungsspezifische integrierte Schaltungen (ASICs), Field Programmable Gate Arrays (FPGAs), digitale Signalprozessoren (DSPs) oder andere integrierte Formate implementiert werden. Dennoch werden die Fachkundigen feststellen, dass einige Aspekte der hier dargelegten Ausführungen, teilweise oder gänzlich, ebenso in integrierten Kreisläufen implementiert werden können, als ein oder mehrere Computerprogramme, die auf einem oder mehreren Computern ausgeführt werden, als ein oder mehrere Programme, die auf einem oder mehreren Prozessoren ausgeführt werden, als Firmware oder irgend eine Kombination davon; und dass ein Entwurf der Kreisläufe und/oder des Schreibens des Codes für die Software und/oder Firmware unter Berücksichtigung der vorliegenden Veröffentlichung eine große Leistung wäre. Außerdem werden Fachleute verstehen, dass die Mechanismen dieses hier beschriebenen Gegenstands in der Lage sind, als ein Programmprodukt in einer Vielzahl von Formen verteilt zu werden, und dass eine veranschaulichende Ausführungsform des hier beschriebenen Gegenstands unabhängig von der besonderen Art des nicht-flüchtigen signalführenden Mediums gilt, das für die tatsächliche Verteilung verwendet wird. Beispiele eines nicht-vorübergehenden Signalträgermediums umfassen, sind aber nicht hierauf beschränkt, folgendes: ein aufnahmefähiges Medium, wie z. B. eine Floppy-Disk, ein Festplattenlaufwerk, eine Compact Disk (CD), eine Digital Video Disk (DVD), ein digitales Band, einen Computerspeicher, usw.; und ein Übertragungsmedium wie ein digitales und/oder analoges Kommunikationsmedium, (z. B., ein optisches Glasfaserkabel, ein Wellenleiter, eine verdrahtete Kommunikationsverbindung, eine drahtlose Kommunikationsverbindung, usw.)The foregoing detailed description has various embodiments of the devices and / or processes through the use of block diagrams, flowcharts, and / or examples. To the extent that such block diagrams, flowcharts, and / or examples include one or more functions and / or operations, they will be understood by those in the science that any function and / or operation can be implemented with such block diagrams, flowcharts, or examples, individually and / or. or collectively, through a wide range of hardware, software, firmware of any virtual combination thereof. In one embodiment, some portions of the subject matter described herein may be implemented via application specific integrated circuits (ASICs), field programmable gate arrays (FPGAs), digital signal processors (DSPs), or other integrated formats. Nevertheless, those skilled in the art will recognize that some aspects of the embodiments set forth herein may be implemented, in whole or in part, in integrated circuits as one or more computer programs executing on one or more computers as one or more programs running on one or more computers or multiple processors, as firmware or any combination thereof; and that a design of the circuits and / or the writing of the code for the software and / or firmware taking into account the present publication would be a great achievement. In addition, those skilled in the art will understand that the mechanisms of this subject matter described herein are capable of being distributed as a program product in a variety of forms, and that an illustrative embodiment of the subject matter described herein applies regardless of the particular nature of the non-volatile signal carrying medium which is used for the actual distribution. Examples of a non-transient signal bearing medium include, but are not limited to: a receptive medium, such as a medium; A floppy disk, a hard disk drive, a compact disk (CD), a digital video disk (DVD), a digital tape, a computer memory, etc .; and a transmission medium such as a digital and / or analog communication medium (e.g., a fiber optic cable, a waveguide, a wired communication link, a wireless communication link, etc.)
Im Hinblick auf die Verwendung von im Wesentlichen beliebigen Plural- und/oder Singularausdrücken können Fachkundige in diesem Bereich aus dem Plural in den Singular und/oder aus dem Singular in den Plural übersetzen, wenn dies für den Kontext und/oder die Anwendung geeignet ist. Die verschiedenen Singular-/Plural-Permutationen können hierin ausdrücklich aus Gründen der Klarheit dargelegt.With respect to the use of substantially any plural and / or singular expressions, those skilled in the art may translate from plural to singular and / or singular to plural, as appropriate to the context and / or application. The various singular / plural permutations may be expressly set forth herein for the sake of clarity.
Folglich wurden bestimmte Ausführungsformen des Gegenstands beschrieben. Weitere Ausführungsformen gehören zum Umfang der folgenden Ansprüche. In einigen Fällen können die in den Ansprüchen beschriebenen Handlungen in einer anderen Reihenfolge ausgeführt werden und dennoch erwünschte Ergebnisse erzielen. Zusätzlich erfordern die in den beigefügten Figuren dargestellten Prozesse nicht notwendigerweise die bestimmte gezeigte Reihenfolge oder aufeinanderfolgende Reihenfolge, um erwünschte Ergebnisse zu erzielen. Bei bestimmten Implementierungen können Multitasking und eine Parallelbearbeitung vorteilhaft sein.Thus, certain embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases, the acts described in the claims may be performed in a different order and still achieve desirable results. In addition, the processes illustrated in the attached figures do not necessarily require the particular order shown or sequential order to achieve desired results. In certain implementations, multitasking and parallel processing may be beneficial.
Claims (8)
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/572,463 | 2014-12-16 | ||
US14/572,463 US9600273B2 (en) | 2014-12-16 | 2014-12-16 | Efficient annotation system for distributed version control systems |
Publications (1)
Publication Number | Publication Date |
---|---|
DE202015009258U1 true DE202015009258U1 (en) | 2017-01-19 |
Family
ID=53938436
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
DE202015009258.6U Active DE202015009258U1 (en) | 2014-12-16 | 2015-08-13 | Efficient annotation system for distributed version management systems |
Country Status (4)
Country | Link |
---|---|
US (1) | US9600273B2 (en) |
CN (1) | CN107148616B (en) |
DE (1) | DE202015009258U1 (en) |
WO (1) | WO2016099610A1 (en) |
Families Citing this family (14)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10331541B2 (en) * | 2016-06-14 | 2019-06-25 | Open Invention Network Llc | Collaborative data sharing and data modification application |
US9652359B1 (en) * | 2016-10-27 | 2017-05-16 | Semmle Limited | Annotation natural keys for source code analysis |
US10592236B2 (en) * | 2017-11-14 | 2020-03-17 | International Business Machines Corporation | Documentation for version history |
US10802954B2 (en) * | 2017-11-30 | 2020-10-13 | Vmware, Inc. | Automated-application-release-management subsystem that provides efficient code-change check-in |
US10303469B1 (en) * | 2017-12-28 | 2019-05-28 | Semmle Limited | Commit graph generation |
CN110196840A (en) * | 2019-05-22 | 2019-09-03 | 中至数据集团股份有限公司 | Document management method, device, readable storage medium storing program for executing and computer equipment |
CN110188337B (en) * | 2019-06-05 | 2023-08-18 | 中国联合网络通信集团有限公司 | Revision labeling method, device, equipment and computer readable storage medium |
US11720347B1 (en) * | 2019-06-12 | 2023-08-08 | Express Scripts Strategic Development, Inc. | Systems and methods for providing stable deployments to mainframe environments |
US11237824B2 (en) | 2020-02-07 | 2022-02-01 | Red Hat, Inc. | Tracking related changes with code annotations |
US11232097B1 (en) * | 2020-06-08 | 2022-01-25 | Sprint Communications Company L.P. | Ordering commits of code in multi-branch parallel development projects |
US11847444B2 (en) | 2020-12-30 | 2023-12-19 | S.T. Swimm Tech Ltd | Automatically updating documentation |
CN112698821B (en) * | 2021-01-12 | 2024-03-26 | 北京字节跳动网络技术有限公司 | Code labeling method, device, computer equipment, medium and system |
WO2023047398A1 (en) * | 2021-09-22 | 2023-03-30 | S.T. Swimm Tech Ltd | Automatically updating documentation |
US20230401057A1 (en) * | 2022-06-14 | 2023-12-14 | Microsoft Technology Licensing, Llc | Video-Based Progress Tracker for Mobile Application Development |
Family Cites Families (19)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4912637A (en) * | 1988-04-26 | 1990-03-27 | Tandem Computers Incorporated | Version management tool |
US6757893B1 (en) * | 1999-12-17 | 2004-06-29 | Canon Kabushiki Kaisha | Version control system for software code |
US6766334B1 (en) * | 2000-11-21 | 2004-07-20 | Microsoft Corporation | Project-based configuration management method and apparatus |
US6904590B2 (en) * | 2001-05-25 | 2005-06-07 | Microsoft Corporation | Methods for enhancing program analysis |
CN100555264C (en) * | 2003-10-21 | 2009-10-28 | 国际商业机器公司 | The annotate method of electronic document, device and system |
US20050268281A1 (en) * | 2004-05-25 | 2005-12-01 | Kim Letkeman | Portable annotated merge model and methods of using the same |
US9207933B2 (en) * | 2006-10-10 | 2015-12-08 | International Business Machines Corporation | Identifying authors of changes between multiple versions of a file |
WO2008119572A1 (en) * | 2007-03-29 | 2008-10-09 | International Business Machines Corporation | An apparatus and method for identifying contextual changes in source code |
US8495100B2 (en) * | 2007-11-15 | 2013-07-23 | International Business Machines Corporation | Semantic version control system for source code |
US8495567B2 (en) * | 2008-03-28 | 2013-07-23 | International Business Machines Corporation | Transferring annotations across versions of the data |
US9361365B2 (en) * | 2008-05-01 | 2016-06-07 | Primal Fusion Inc. | Methods and apparatus for searching of content using semantic synthesis |
US8312440B2 (en) * | 2008-08-19 | 2012-11-13 | International Business Machines Corporation | Method, computer program product, and hardware product for providing program individuality analysis for source code programs |
CN101782849A (en) * | 2009-01-21 | 2010-07-21 | 大唐移动通信设备有限公司 | Control method and device for software annotation |
US8719239B2 (en) * | 2010-07-16 | 2014-05-06 | International Business Machines Corporation | Displaying changes to versioned files |
US20130174124A1 (en) * | 2011-12-29 | 2013-07-04 | Christina Watters | Version numbering in single development and test environment |
US20120254219A1 (en) * | 2011-03-30 | 2012-10-04 | Elise Bell | Boolean search query system, method and computer readable media |
US9052983B2 (en) * | 2012-01-16 | 2015-06-09 | International Business Machines Corporation | Source code patches |
US9411580B2 (en) * | 2012-05-31 | 2016-08-09 | International Business Machines Corporation | Annotating a generator output stream |
CN104199664B (en) * | 2014-09-03 | 2017-06-06 | 北京大学 | A kind of simulation code synchronization generation method based on annotation |
-
2014
- 2014-12-16 US US14/572,463 patent/US9600273B2/en active Active
-
2015
- 2015-08-13 DE DE202015009258.6U patent/DE202015009258U1/en active Active
- 2015-08-13 WO PCT/US2015/045003 patent/WO2016099610A1/en active Application Filing
- 2015-08-13 CN CN201580059265.1A patent/CN107148616B/en active Active
Also Published As
Publication number | Publication date |
---|---|
US9600273B2 (en) | 2017-03-21 |
WO2016099610A1 (en) | 2016-06-23 |
CN107148616B (en) | 2021-06-18 |
CN107148616A (en) | 2017-09-08 |
US20160170746A1 (en) | 2016-06-16 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
DE202015009258U1 (en) | Efficient annotation system for distributed version management systems | |
DE112020000749T5 (en) | Index creation for evolving large data sets in hybrid transaction and analysis processing systems with multiple masters | |
Jain et al. | Sqlshare: Results from a multi-year sql-as-a-service experiment | |
DE112015003406B4 (en) | Lineage Summation | |
DE60004385T2 (en) | METHODS AND SYSTEMS TO MAKE OLAP HIERARCHIES COMBINABLE | |
Santiago et al. | Model-driven engineering as a new landscape for traceability management: A systematic literature review | |
EP1311989B1 (en) | Automatic search method | |
DE202014010938U1 (en) | Omega name: name generation and derivation | |
Hassanzadeh et al. | Discovering linkage points over web data | |
DE112015000347T5 (en) | Processing records in a large data store | |
DE202014010893U1 (en) | Rufwegsucher | |
DE102013204521A1 (en) | Transaction management for database systems | |
EP2188742A1 (en) | Detecting correlations between data representing information | |
DE102014103279A1 (en) | Pivot facets for text mining and search | |
DE102013200355A1 (en) | Merging of documents based on the knowledge of a document schema | |
DE102012221251A1 (en) | Semantic and contextual search of knowledge stores | |
Stvilia | A model for ontology quality evaluation | |
DE202015009280U1 (en) | Integrated domain-specific languages as first-class code artifacts | |
DE202016008044U1 (en) | Automatic imports and dependencies in large-scale source code repositories | |
DE102016015536A1 (en) | Organizing electronically stored files using an automatically generated memory hierarchy | |
EP2193455A1 (en) | Detecting correlations between data representing information | |
WO2009030248A1 (en) | Detecting correlations between data representing information | |
DE10218905A1 (en) | Method and device for access control in knowledge networks | |
DE112022000886T5 (en) | DATA PROCESSING SYSTEM WITH MANIPULATION OF LOGICAL DATA RECORD GROUPS | |
DE112020000536T5 (en) | EXPANDABLE DATA SKIP |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
R207 | Utility model specification | ||
R081 | Change of applicant/patentee |
Owner name: GOOGLE LLC (N.D.GES.D. STAATES DELAWARE), MOUN, USFree format text: FORMER OWNER: GOOGLE INC., MOUNTAIN VIEW, CALIF., US |
|
R082 | Change of representative |
Representative=s name: BETTEN & RESCH PATENT- UND RECHTSANWAELTE PART, DE |
|
R150 | Utility model maintained after payment of first maintenance fee after three years | ||
R151 | Utility model maintained after payment of second maintenance fee after six years | ||
R079 | Amendment of ipc main class |
Free format text: PREVIOUS MAIN CLASS: G06F0017300000Ipc: G06F0008710000 |
|
R152 | Utility model maintained after payment of third maintenance fee after eight years |