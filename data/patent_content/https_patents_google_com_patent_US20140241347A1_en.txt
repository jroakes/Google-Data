US20140241347A1 - Static translation of network forwarding plane models into target implementation in the hardware abstraction layer - Google Patents
Static translation of network forwarding plane models into target implementation in the hardware abstraction layer Download PDFInfo
- Publication number
- US20140241347A1 US20140241347A1 US13/776,012 US201313776012A US2014241347A1 US 20140241347 A1 US20140241347 A1 US 20140241347A1 US 201313776012 A US201313776012 A US 201313776012A US 2014241347 A1 US2014241347 A1 US 2014241347A1
- Authority
- US
- United States
- Prior art keywords
- target
- mapping
- device model
- target device
- network
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Abandoned
Links
Images
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L45/00—Routing or path finding of packets in data switching networks
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L45/00—Routing or path finding of packets in data switching networks
- H04L45/56—Routing software
Definitions
- information may be sent along a path from a source device to a destination device.
- the source device and the destination device may be, for example personal computers, servers such as email servers, web servers, or file servers, or other electronic devices capable of sending and/or receiving information via the network.
- the information may pass through one or more forwarding devices, such as routers or other electronic devices having the ability to forward the information to another device.
- the intermediate devices may receive the information and use functions, algorithms, data structures, and rules to determine where and how to forward the information so that the information moves towards its intended destination.
- These functions, algorithms, data structures, and rules form the “forwarding plane” of the network.
- the functions, algorithms, data structures, and rules of the forwarding plane may be implemented and/or enforced by one or more forwarding devices in the network.
- a forwarding device may receive a packet on an inbound interface, look up the destination address of the packet, and apply a rule which causes the forwarding device to look up the destination address in a particular routing table.
- the routing table may provide a list of “next destinations” which represent a device to which the packet should be sent.
- the next destination for a particular packet might be, for example, the final destination device or another intermediate forwarding device.
- the next destination may be identified by an address stored in the routing table.
- the next destinations stored in the routing table may be indexed by a final destination of the packet—thus, by looking up the final destination of the packet (e.g., as identified by a header of the packet), the next destination can be retrieved from the routing table.
- the forwarding device may then forward the packet on an outbound interface to the identified next destination.
- Certain aspects of the forwarding plane can affect the efficiency of the network. These aspects include the specific rules, algorithms, data structures, and functions employed, the manner in which the forwarding plane is implemented, and the location at which the forwarding plane is implemented and/or enforced.
- a routing controller in a communication network may be responsible for generating a device model for a target device using a universal language of network primitives.
- the target device may have forwarding capabilities. Exemplary embodiments allow the target device to determine how to forward the incoming data packets based on the intended behavior of the network.
- the target device may translate the desired behavior described using the universal language into implementation based on the capabilities of the target device. The translation may generate a mapping between the desired behaviors and the implementations thereof.
- the universal language is a target-independent description that is used to define the intent of the network, i.e. the intended forwarding behavior.
- the universal language may describe a requested capability (e.g., “find the longest prefix match of a subnet mask in a routing table”) without specifying how to implement the requested capability (e.g., without specifying a particular algorithm for performing a longest prefix match).
- the universal language may support multiple implementations of the specified functionality (e.g., a first algorithm for finding a longest prefix match, and a second algorithm for finding a longest prefix match).
- the device model may include one or more known identifiers associated with one or more portions of the model.
- the mapping between the known identifiers and the capabilities of a target device is known.
- the known mappings may be stored, for example, in a database of known mappings.
- the target device upon receiving the device model with known identifiers from the controller, may retrieve and use the mapping to statically translate the device model to implementation. Absent a known mapping, the translator of the target device would have to dynamically translate intents described in the device model to implementation. Accordingly, the device model provides reusability of the previously determined mappings and does not require the translator to dynamically translate the device model each time the device model is received from the controller.
- a non-transitory electronic device readable storage medium holds instructions that, when executed, cause one or more processors to receive a device model described in a target-independent format.
- the device model describes an intended forwarding behavior for a target device.
- the device model includes one or more known identifiers associated with one or more portions of the device model.
- the storage medium further holds instructions that, when executed, cause one or more processors to retrieve a mapping that maps the one or more known identifiers of the device model to implementation of one or more capabilities of a target device having a forwarding or switching capability.
- the storage medium further holds instructions that, when executed, cause one or more processors to configure the target device by statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping.
- a method entails receiving a device model described in a target-independent format.
- the device model describes an intended forwarding behavior for a target device.
- the method further entails retrieving a mapping that maps one or more elements of the device model to implementation of one or more capabilities of the target device having a forwarding or switching capability.
- the method also involves configuring the target device by statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping.
- the method further involves receiving one or more input packets and forwarding the one or more input packets to one or more elements of the network based on the configuring.
- a system comprising a routing controller, a target device and a storage.
- the routing controller generates a device model described in a target-independent format.
- the target device receives the device model.
- the device model describes an intended forwarding behavior for the target device.
- the target device has a forwarding or switching capability.
- the storage stores one or more mappings that map one or more portions of the device model to implementation of one or more capabilities of the target device.
- the target device is configured to retrieve one or more mappings from the storage for statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping.
- FIG. 1 depicts an exemplary network 100 including a routing controller and a target device according to an exemplary embodiment.
- FIG. 2 depicts an exemplary manner how elements of the exemplary network 100 interact according to an exemplary embodiment.
- FIG. 3 depicts an exemplary device model generated by a controller according to an exemplary embodiment.
- FIG. 4 is a flowchart describing exemplary steps performed by a controller in accordance with an exemplary embodiment.
- FIG. 5 is a flowchart describing exemplary steps performed by a target device in accordance with an exemplary embodiment.
- FIG. 6 depicts an exemplary electronic device suitable for use with exemplary embodiments described herein.
- FIG. 7 depicts an exemplary network implementation of processing performed according to an exemplary embodiment.
- exemplary embodiments allow abstracting of the forwarding plane of a software defined network.
- the abstraction of setting forwarding table entries loses too much information about the intents of the application developer.
- conventional techniques cannot leverage all the features of the forwarding device to deliver scalable and efficient end-to-end implementations.
- the present application aims at mapping high-level forwarding intents to low-level features of the forwarding device.
- a routing controller in the network may be responsible for generating a device model using a universal language of network primitives.
- the device model may define the intent of the network, i.e. the intended forwarding behavior.
- the device model may include one or more identifiers associated with one or more portions of the model.
- the controller may send the device model to a target device.
- the target device translates the desired behavior described in the device model into an implementation based on the capabilities of the target device.
- the target device may include predetermined hardware or software logic for implementing the desired behavior defined in the device model. Accordingly, the target device may implement a requested capability defined in the device model without receiving instructions prescribing how to implement the requested capability. If the identifiers included in the device model are known to the target device, i.e. the target device previously received and translated the identifiers, the target device would also know the mapping between the identifiers and the implementation for the identifiers. The target device, upon receiving the device model from the controller, may retrieve and use the known mapping to statically translate the device model into an implementation.
- the translator of the target device would have to translate the device model into an implementation dynamically. Accordingly, static translation of the device model provides reusability of the previously determined mappings and does not require the translator to dynamically translate the device model each time the device model is received from the routing controller.
- FIG. 1 depicts an exemplary network 100 including a routing controller 110 and a target device 120 according to an exemplary embodiment.
- the controller 110 may include a processor, a server or other device implemented in hardware, software or a combination thereof.
- the network 100 may be a communications network such as the Internet, an intranet, or a telephone network, among other possibilities.
- the network 100 may include one or more optical, electronic, or other transmission mediums.
- the controller 110 of the network 100 may be in communication with the target device 120 .
- the controller 110 may be connected to the target device 120 directly or indirectly.
- the network 100 is for explanatory purposes only, and a network suitable for use with the exemplary embodiments described herein may have other elements or capabilities.
- the controller may generate a plurality of device models according to various embodiments.
- the target device 120 may have forwarding functionality such that the target device 120 is capable of receiving incoming information on an inbound interface, processing the information to determine a next destination of the information, and forwarding the information to the next destination on an outbound interface.
- the controller 110 may generate a device model 112 using a universal language.
- the device model 112 may define the intent of the network 100 (e.g., the intended forwarding behavior within the network 100 ) using the universal language.
- the device model 112 may describe a desired behavior of a node of the network 100 under certain conditions, such as upon the receipt of an incoming packet.
- the universal language is a target-independent language that can be interpreted by all recipient devices.
- the universal language may be formed of building blocks called “network primitives”.
- the device model 112 may include one or more network primitives 114 .
- a network primitive 114 is a basic unit of functionality to be implemented by elements of the network 100 .
- a network primitive 114 may be, for example, a description of a particular functionality to be used in the network 100 .
- a network primitive 114 may describe what actions elements of the network 100 are meant to perform, but typically will not include requirements for how those actions are to be carried out.
- a networking primitive 114 may describe a desired outcome without providing implementation details for achieving the outcome.
- the implementation details may be left to the particular device implementing the network primitive 114 , or may be specified by an external device.
- the device model 112 may be constructed as a collection of one or more network primitives 114 .
- a network primitive 114 related to queuing may specify that a recipient device of the device model 112 is to implement flat queuing, hierarchical queuing, buffer resource sharing, dynamic buffer sizing, tail drop queue management, weighted tail drop queue management, or queue high and low watermarks.
- Scheduling primitives may specify that scheduling should be in a round robin fashion, as a weighted round robin, low latency queuing or strict priority queuing, weighted fair queuing, or class-based weighted fair queuing.
- Metering primitives may make use of one rate two color (1R2C) IP packet marking, 1R3C marking, or 2R3C marking. Numerous other networking primitives may also be utilized. The details of the implementations of these networking primitives may be unspecified and left up to the device that implements the primitives.
- the device model 112 generated by the controller 110 may specify all the routing/forwarding functionality within the network 100 .
- the controller 110 may generate a plurality of device models. For example, the controller 110 may generate a first device model 112 to be used under certain circumstances, such as periods of high or low network traffic or upon the receipt of certain types of packets.
- the controller 110 may generate a second device model 112 ′ formed of network primitives 114 ′ where the second device model 112 ′ may be used under other circumstances.
- a network administrator may cause the network 100 to exhibit different network forwarding behaviors.
- the controller 110 may send the generated device model 112 and/or 112 ′ to the target device 120 .
- the device model 112 and/or 112 ′ may represent a complete set of functionality required of the target device 120 .
- the target device 120 may interpret the information contained in the device model 112 and/or 112 ′ within constraints known to the target device 120 .
- the target device 120 may translate the intended behavior described in the device model 112 and/or 112 ′ into implementation.
- the target device 120 may include a translator 126 provided at a hardware abstraction layer (HAL) 122 of the target device 120 .
- HAL hardware abstraction layer
- the translator 126 may translate the target-independent device model 112 and/or 112 ′ into implementation on the target device 120 based on the capabilities of, for example, the application specific integrated circuit (ASIC) 124 of the target device 120 . Accordingly, high-level generic desired forwarding behaviors may be mapped to low-level ASIC features.
- ASIC application specific integrated circuit
- the device model 112 and/or 112 ′ may include one or more identifiers associated with one or more portions of the device model 112 and/or 112 ′.
- the target device 120 may be familiar with the identifiers of the device model 112 and/or 112 ′.
- the target device 120 may have previously received the one or more identifiers and translated the identifiers into implementation.
- the target device 120 may know the mapping between the one or more known identifiers and their implementations on the target device.
- the known mappings may be stored, for example, in a database of known mappings. If the target device 120 knows the mapping, the translator 126 may retrieve the known mapping from the database and statically translate the device model 112 and/or 112 ′ to implementation on the target device 120 . That is, instead of dynamically translating one or more portions of the received device model 112 and/or 112 ′ to implementation, the target device 120 may statically translate the device model 112 and/or 112 ′ into implementation using a pre-mapping
- FIG. 2 depicts how elements of the exemplary network 100 may interact according to an exemplary embodiment.
- the controller 202 provided in a network 200 may send at least one device model 204 to a target device 250 .
- the device model 204 may include one or more identifiers.
- the target device 250 Upon receiving the device model with identifiers 202 , the target device 250 checks a storage 208 , such as a database, for pre-determined mappings between identifiers and their implementations. If the target device 250 finds pre-determined mappings for the identifiers in the received device model 204 , the target device 250 may retrieve the mappings.
- the translator 210 of the target device 250 may statically translate the identifiers into implementation using the pre-determined mappings retrieved from the storage 208 .
- the translator 210 of the target device 250 may dynamically translate the identifiers into implementation based on the capabilities of the target device 250 .
- the intended behavior described in the device model 202 is passed to implementation 212 on the target device.
- FIG. 3 depicts an exemplary device model 300 generated by a controller according to an exemplary embodiment.
- the device model 300 is provided as a unified modeling language (UML) activity diagram. It is understood that UML activity diagram is used for illustrative purposed and that the device model 300 may be provided using other graphical and/or textual modeling languages.
- the device model 300 illustrates a representation of the network behavior for implementing a media access control (MAC) bridge.
- the device model 300 includes a plurality of network primitives 302 - 318 .
- the ASIC of the target device is given the specific behavior expected of the network for an efficient implementation by the target device.
- the device model 300 may also be expressed using textual code, such as a pseudo code.
- textual code such as a pseudo code.
- a portion of an exemplary pseudo code representing the device model 300 is provided below.
- the pseudo code is provided for exemplary purposes and should not be construed as limiting.
- the pseudo code may have an entry for the network primitives of the device model 300 .
- the portion of the pseudo code provided above has an entry for table definition network primitive 306 , the tableops_match network primitive 304 , the tableops_modify network primitive 308 and the tableops_insert network primitive 310 .
- the target device upon receiving the device model 300 in the graphical format or in the pseudo code format, translates the device model 300 into an implementation.
- the translation of the exemplary device model 300 in the implementation of a MAC bridge will allow communications between one or more end stations coupled to the target device in the network.
- the intended behavior represented in the device model 300 allows the interconnection of one or more end stations as if they were attached to a single local area network (LAN), even if the one or more end satiations are attached to separate LANs.
- LAN local area network
- the controller may send the device model to the target device for implementation.
- the controller may send the device model in the graphical format and/or in a textual format such as a pseudo code. Both the graphical format and the pseudo code include one or more network primitives generated in a target-independent universal language. The steps performed by the controller and the target device are discussed below.
- FIG. 4 is a flowchart describing exemplary steps performed by a controller in accordance with an exemplary embodiment.
- the controller may generate a device model in a target-independent format (step 402 ).
- the device model may describe the intended forwarding behavior for the target device.
- the intended forwarding behavior may be a high-level indication of the intent of the developer.
- the controller may send the generated device model to the target device for implementation (step 404 ).
- FIG. 5 is a flowchart describing exemplary steps performed by a target device in accordance with an exemplary embodiment.
- the target device receives the device model generated by the controller (step 502 ).
- the device model may be described in target-independent format.
- the device model may include one or more identifiers associated with one or more portions of the device model.
- the one or more identifiers may be known to the target device.
- the target device may have previously received the one or more identifiers.
- the target device may retrieve, for example from a storage, a previously-generated mapping between the one or more known identifiers and implementations thereof on the target device (step 504 ).
- the target device may statically translate the device model into implementation using the mapping retrieved from the storage (step 506 ).
- the target device may be configured based on the translating (step 508 ).
- the target device may forward the received input packets to one or more elements of the network based on the configuring (step 512 ).
- FIG. 6 depicts an example of an electronic device 600 that may be suitable for use with one or more acts disclosed herein.
- the electronic device 600 may take many forms, including but not limited to a computer, workstation, server, network computer, quantum computer, optical computer, Internet appliance, mobile device, a pager, a tablet computer, a smart sensor, application specific processing device, etc.
- the electronic device 600 is illustrative and may take other forms.
- an alternative implementation of the electronic device 600 may have fewer components, more components, or components that are in a configuration that differs from the configuration of FIG. 6 .
- the components of FIG. 6 and/or other figures described herein may be implemented using hardware based logic, software based logic and/or logic that is a combination of hardware and software based logic (e.g., hybrid logic); therefore, components illustrated in FIG. 6 and/or other figures are not limited to a specific type of logic.
- the processor 602 may include hardware based logic or a combination of hardware based logic and software to execute instructions on behalf of the electronic device 600 .
- the processor 602 may include logic that may interpret, execute, and/or otherwise process information contained in, for example, the memory 604 .
- the information may include computer-executable instructions and/or data that may implement one or more embodiments of the invention.
- the processor 602 may comprise a variety of homogeneous or heterogeneous hardware.
- the hardware may include, for example, some combination of one or more processors, microprocessors, field programmable gate arrays (FPGAs), application specific instruction set processors (ASIPs), application specific integrated circuits (ASICs), complex programmable logic devices (CPLDs), graphics processing units (GPUs), or other types of processing logic that may interpret, execute, manipulate, and/or otherwise process the information.
- the processor may include a single core or multiple cores 603 .
- the processor 602 may include a system-on-chip (SoC) or system-in-package (SiP).
- the electronic device 600 may include one or more tangible non-transitory computer-readable storage media for storing one or more computer-executable instructions or software that may implement one or more embodiments of the invention.
- the non-transitory computer-readable storage media may be, for example, the memory 604 or the storage 618 .
- the memory 604 may comprise a ternary content addressable memory (TCAM) and/or a RAM that may include RAM devices that may store the information.
- TCAM ternary content addressable memory
- the RAM devices may be volatile or non-volatile and may include, for example, one or more DRAM devices, flash memory devices, SRAM devices, zero-capacitor RAM (ZRAM) devices, twin transistor RAM (TTRAM) devices, read-only memory (ROM) devices, ferroelectric RAM (FeRAM) devices, magneto-resistive RAM (MRAM) devices, phase change memory RAM (PRAM) devices, or other types of RAM devices.
- DRAM dynamic random access memory
- SRAM zero-capacitor RAM
- ZRAM twin transistor RAM
- ROM read-only memory
- FeRAM ferroelectric RAM
- MRAM magneto-resistive RAM
- PRAM phase change memory RAM
- One or more computing devices 600 may include a virtual machine (VM) 605 for executing the instructions loaded in the memory 604 .
- VM virtual machine
- a virtual machine 605 may be provided to handle a process running on multiple processors so that the process may appear to be using only one computing resource rather than multiple computing resources. Virtualization may be employed in the electronic device 600 so that infrastructure and resources in the electronic device may be shared dynamically. Multiple VMs 605 may be resident on a single computing device 600 .
- a hardware accelerator 606 may be implemented in an ASIC, FPGA, or some other device.
- the hardware accelerator 606 may be used to reduce the general processing time of the electronic device 600 .
- the electronic device 600 may include a network interface 608 to interface to a Local Area Network (LAN), Wide Area Network (WAN) or the Internet through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., T1, T3, 56kb, X.25), broadband connections (e.g., integrated services digital network (ISDN), Frame Relay, asynchronous transfer mode (ATM), wireless connections (e.g., 802.11), high-speed interconnects (e.g., InfiniBand, gigabit Ethernet, Myrinet) or some combination of any or all of the above.
- LAN Local Area Network
- WAN Wide Area Network
- the Internet may include a network interface 608 to interface to a Local Area Network (LAN), Wide Area Network (WAN) or the Internet through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., T1, T3, 56kb, X.25), broadband connections (e.g., integrated services digital network (IS
- the network interface 608 may include a built-in network adapter, network interface card, personal computer memory card international association (PCMCIA) network card, card bus network adapter, wireless network adapter, universal serial bus (USB) network adapter, modem or any other device suitable for interfacing the electronic device 600 to any type of network capable of communication and performing the operations described herein.
- PCMCIA personal computer memory card international association
- USB universal serial bus
- the electronic device 600 may include one or more input devices 610 , such as a keyboard, a multi-point touch interface, a pointing device (e.g., a mouse), a gyroscope, an accelerometer, a haptic device, a tactile device, a neural device, a microphone, or a camera that may be used to receive input from, for example, a user.
- input devices 610 such as a keyboard, a multi-point touch interface, a pointing device (e.g., a mouse), a gyroscope, an accelerometer, a haptic device, a tactile device, a neural device, a microphone, or a camera that may be used to receive input from, for example, a user.
- input devices 610 such as a keyboard, a multi-point touch interface, a pointing device (e.g., a mouse), a gyroscope, an accelerometer, a haptic device, a tactile device, a neural device, a
- the input devices 610 may allow a user to provide input that is registered on a visual display device 614 .
- a graphical user interface (GUI) 616 may be shown on the display device 614 .
- a storage device 618 may also be associated with the computer 600 .
- the storage device 618 may be accessible to the processor 602 via an I/O bus.
- the information may be executed, interpreted, manipulated, and/or otherwise processed by the processor 602 .
- the storage device 618 may include, for example, a storage device, such as a magnetic disk, optical disk (e.g., CD-ROM, DVD player), random-access memory (RAM) disk, tape unit, and/or flash drive.
- the information may be stored on one or more non-transient tangible computer-readable media contained in the storage device.
- This media may include, for example, magnetic discs, optical discs, magnetic tape, and/or memory devices (e.g., flash memory devices, static RAM (SRAM) devices, dynamic RAM (DRAM) devices, or other memory devices).
- memory devices e.g., flash memory devices, static RAM (SRAM) devices, dynamic RAM (DRAM) devices, or other memory devices.
- the information may include data and/or computer-executable instructions that may implement one or more embodiments of the invention
- the storage device 618 may further store applications 624 , and the electronic device 600 can be running an operating system (OS) 626 .
- OS 626 may include the Microsoft® Windows® operating systems, the Unix and Linux operating systems, the MacOS® for Macintosh computers, an embedded operating system, such as the Symbian OS, a real-time operating system, an open source operating system, a proprietary operating system, operating systems for mobile electronic devices, or other operating system capable of running on the electronic device and performing the operations described herein.
- the operating system may be running in native mode or emulated mode.
- the storage device 618 may further include rules 628 which describe how messages should be forwarded in a communications network.
- the rules 628 may be used to forward messages or information received at the electronic device 628 .
- the electronic device 600 may serve as a forwarding device, switch, or router.
- the storage device 618 may store an implementation database 630 .
- the implementation database 630 may be a data structure, such as a table or matrix, which stores identifiers identifying predetermined functions that are implemented by the electronic device 630 .
- the implementation database may further store the implementation details of the predetermined functions.
- the storage device 618 may further include logic for implementing a communications protocol 640 .
- the communications protocol 640 may be a protocol which provides an interface for accessing and modifying the functionality of the forwarding plane of the electronic device 600 .
- Exemplary communications protocols 640 include, but are not limited to, the OpenFlow protocol (see, e.g., McKeown, Nick et al., “OpenFlow: Enabling Innovation in Campus Networks,” ACM SIGCOMM Computer Communication Review Archive, vol. 38 issue 2, pp. 69-74 (April 2008), the contents of which are incorporated herein by reference) or custom communications protocols.
- the electronic device 600 may serve as a remote controller, such as the controller 110 described above with respect to FIG. 1 .
- the communications protocol 640 may allow the details of the forwarding plane implemented by the electronic device 600 to be defined and/or modified. Accordingly, the communications protocol 640 allows a communications network to be made programmable.
- the communications protocol 640 may support the use of one or more device models 642 to implement the functionality of the forwarding plane.
- a device model 642 may represent the complete set of network routing functionality to be implemented by the electronic device 640 .
- the device model 642 may define the functionality and performance of the forwarding plane.
- the device model 642 may include one or more network primitives.
- a network primitive is a basic unit of functionality to be implemented by the electronic device 600 .
- a network primitive may be, for example, a description of a particular functionality to be used in the communications network.
- a network primitive may describe what actions the electronic device 600 is meant to perform, but typically will not include requirements for how those actions are to be carried out.
- a network primitive may describe a desired outcome without providing implementation details for achieving the outcome. The implementation details may be left to the particular device implementing the network primitive, or may be specified by an external device.
- a network primitive related to queuing may specify that the electronic device 600 (acting as a forwarding device) is to implement flat queuing, hierarchical queuing, buffer resource sharing, dynamic buffer sizing, tail drop queue management, weighted tail drop queue management, or queue high and low watermarks.
- Scheduling primitives may specify that scheduling should be in a round robin fashion, as a weighted round robin, low latency queuing or strict priority queuing, weighted fair queuing, or class-based weighted fair queuing.
- Metering primitives may make use of one rate two color (1R2C) IP packet marking, 1R3C marking, or 2R3C marking. Numerous other network primitives may also be utilized. The details of the implementations of these network primitives may be unspecified and left up to the device that implements the primitives.
- a device model 642 may be constructed as a collection of one or more network primitives.
- one device model 642 might specify that the electronic device 600 is to use flat queuing with round robin scheduling.
- One or more device models 642 may specify all the network routing/forwarding functionality of the electronic device 600 .
- a first device model 642 may be used under certain circumstances, such as periods of high or low network traffic or upon the receipt of certain types of packets, and that a second device model 642 may be used under other circumstances.
- a network administrator may cause the electronic device 600 to exhibit different network forwarding behaviors.
- the communications protocol 640 may reference a device model 642 and implement the functionality defined by the device model 642 using the functionality defined by the implementation database 630 .
- the communications protocol 640 may use default or generic implementations stored locally with the communications protocol 640 or provided from a remote location, such as a remote controller.
- One or more embodiments of the invention may be implemented using computer-executable instructions and/or data that may be embodied on one or more non-transitory tangible computer-readable mediums.
- the mediums may be, but are not limited to, a hard disk, a compact disc, a digital versatile disc, a flash memory card, a Programmable Read Only Memory (PROM), a Random Access Memory (RAM), a Read Only Memory (ROM), Magnetoresistive Random Access Memory (MRAM), a magnetic tape, or other computer-readable media.
- FIG. 7 depicts a network implementation that may implement one or more embodiments of the invention.
- a system 700 may include a computing device 600 , a network 712 , a service provider 713 , a target environment 714 , and a cluster 715 .
- the embodiment of FIG. 7 is exemplary, and other embodiments can include more devices, fewer devices, or devices in arrangements that differ from the arrangement of FIG. 7 .
- the network 712 may transport data from a source to a destination.
- Embodiments of the network 712 may use network devices, such as routers, switches, firewalls, and/or servers (not shown) and connections (e.g., links) to transport data.
- Data may refer to any type of machine-readable information having substantially any format that may be adapted for use in one or more networks and/or with one or more devices (e.g., the computing device 600 , the service provider 713 , etc.).
- Data may include digital information or analog information. Data may further be packetized and/or non-packetized.
- the network 712 may be a hardwired network using wired conductors and/or optical fibers and/or may be a wireless network using free-space optical, radio frequency (RF), and/or acoustic transmission paths.
- the network 712 may be a substantially open public network, such as the Internet.
- the network 712 may be a more restricted network, such as a corporate virtual network.
- the network 712 may include Internet, intranet, Local Area Network (LAN), Wide Area Network (WAN), Metropolitan Area Network (MAN), wireless network (e.g., using IEEE 802.11), or other type of network
- the network 712 may use middleware, such as Common Object Request Broker Architecture (CORBA) or Distributed Component Object Model (DCOM). Implementations of networks and/or devices operating on networks described herein are not limited to, for example, any particular data type, protocol, and/or architecture/configuration.
- CORBA Common Object Request Broker Architecture
- DCOM Distributed Component Object Model
- the service provider 713 may include a device that makes a service available to another device.
- the service provider 713 may include an entity (e.g., an individual, a corporation, an educational institution, a government agency, etc.) that provides one or more services to a destination using a server and/or other devices.
- Services may include instructions that are executed by a destination to perform an operation (e.g., an optimization operation).
- a service may include instructions that are executed on behalf of a destination to perform an operation on the destination's behalf.
- the server 714 may include a device that receives information over the network 712 .
- the server 714 may be a device that receives user input from the computer 600 .
- the cluster 715 may include a number of units of execution (UEs) 716 and may perform processing on behalf of the computer 500 and/or another device, such as the service provider 713 or server 714 .
- the cluster 715 may perform parallel processing on an operation received from the computer 600 .
- the cluster 715 may include UEs 716 that reside on a single device or chip or that reside on a number of devices or chips.
- the units of execution (UEs) 716 may include processing devices that perform operations on behalf of a device, such as a requesting device.
- a UE may be a microprocessor, field programmable gate array (FPGA), and/or another type of processing device.
- UE 716 may include code, such as code for an operating environment. For example, a UE may run a portion of an operating environment that pertains to parallel processing activities.
- the service provider 713 may operate the cluster 715 and may provide interactive optimization capabilities to the computer 500 on a subscription basis (e.g., via a web service).
- a hardware unit of execution may include a device (e.g., a hardware resource) that may perform and/or participate in parallel programming activities.
- a hardware unit of execution may perform and/or participate in parallel programming activities in response to a request and/or a task it has received (e.g., received directly or via a proxy).
- a hardware unit of execution may perform and/or participate in substantially any type of parallel programming (e.g., task, data, stream processing, etc.) using one or more devices.
- a hardware unit of execution may include a single processing device that includes multiple cores or a number of processors.
- a hardware unit of execution may also be a programmable device, such as a field programmable gate array (FPGA), an application specific integrated circuit (ASIC), a digital signal processor (DSP), or other programmable device.
- FPGA field programmable gate array
- ASIC application specific integrated circuit
- DSP digital signal processor
- Devices used in a hardware unit of execution may be arranged in many different configurations (or topologies), such as a grid, ring, star, or other configuration.
- a hardware unit of execution may support one or more threads (or processes) when performing processing operations.
- a software unit of execution may include a software resource (e.g., a technical computing environment) that may perform and/or participate in one or more parallel programming activities.
- a software unit of execution may perform and/or participate in one or more parallel programming activities in response to a receipt of a program and/or one or more portions of the program.
- a software unit of execution may perform and/or participate in different types of parallel programming using one or more hardware units of execution.
- a software unit of execution may support one or more threads and/or processes when performing processing operations.
- parallel programming may be understood to include multiple types of parallel programming, e.g. task parallel programming, data parallel programming, and stream parallel programming.
- Parallel programming may include various types of processing that may be distributed across multiple resources (e.g., software units of execution, hardware units of execution, processors, microprocessors, clusters, labs) and may be performed at the same time.
- parallel programming may include task parallel programming where a number of tasks may be processed at the same time on a number of software units of execution.
- task parallel programming a task may be processed independently of other tasks executing, for example, at the same time.
- Parallel programming may include data parallel programming, where data (e.g., a data set) may be parsed into a number of portions that may be executed in parallel using, for example, software units of execution.
- data parallel programming the software units of execution and/or the data portions may communicate with each other as processing progresses.
- Parallel programming may include stream parallel programming (sometimes referred to as pipeline parallel programming).
- Stream parallel programming may use a number of software units of execution arranged, for example, in series (e.g., a line) where a first software unit of execution may produce a first result that may be fed to a second software unit of execution that may produce a second result given the first result.
- Stream parallel programming may also include a state where task allocation may be expressed in a directed acyclic graph (DAG) or a cyclic graph.
- DAG directed acyclic graph
- Other parallel programming techniques may involve some combination of task, data, and/or stream parallel programming techniques alone or with other types of processing techniques to form hybrid-parallel programming techniques.
- one or more implementations consistent with principles of the invention may be implemented using one or more devices and/or configurations other than those illustrated in the Figures and described in the Specification without departing from the spirit of the invention.
- One or more devices and/or components may be added and/or removed from the implementations of the figures depending on specific deployments and/or applications.
- one or more disclosed implementations may not be limited to a specific combination of hardware.
- logic may perform one or more functions.
- This logic may include hardware, such as hardwired logic, an application-specific integrated circuit, a field programmable gate array, a microprocessor, software, or a combination of hardware and software.
- the article “a” is intended to include one or more items. Where only one item is intended, the term “a single” or similar language is used. Further, the phrase “based on,” as used herein is intended to mean “based, at least in part, on” unless explicitly stated otherwise.
- the term “user”, as used herein, is intended to be broadly interpreted to include, for example, an electronic device (e.g., a workstation) or a user of an electronic device, unless otherwise stated.
Abstract
A routing controller in a communication network may be responsible for generating a device model that defines intended forwarding behavior of the network. The device model may be generated using a target-independent universal language of network primitives. The controller may send the device model to a target device. The device controller may include one or more known identifiers associated with one or more portions of the model. The target device may know the mapping between the known identifiers and the capabilities of the target device. Upon receiving the device model from the controller, the target device may retrieve the known mapping to statically translate the device model to implementation. The static translation of the device model provides reusability of the previously determined mappings. The target device is not required to have a translator for dynamically translating the device model each time that the device model is received from the controller.
Description
- In communication networks, such as telephone networks and data networks, including the Internet, information may be sent along a path from a source device to a destination device. The source device and the destination device may be, for example personal computers, servers such as email servers, web servers, or file servers, or other electronic devices capable of sending and/or receiving information via the network.
- The information may pass through one or more forwarding devices, such as routers or other electronic devices having the ability to forward the information to another device. The intermediate devices may receive the information and use functions, algorithms, data structures, and rules to determine where and how to forward the information so that the information moves towards its intended destination. These functions, algorithms, data structures, and rules form the “forwarding plane” of the network. The functions, algorithms, data structures, and rules of the forwarding plane may be implemented and/or enforced by one or more forwarding devices in the network.
- For example, a forwarding device may receive a packet on an inbound interface, look up the destination address of the packet, and apply a rule which causes the forwarding device to look up the destination address in a particular routing table. The routing table may provide a list of “next destinations” which represent a device to which the packet should be sent. The next destination for a particular packet might be, for example, the final destination device or another intermediate forwarding device. The next destination may be identified by an address stored in the routing table. The next destinations stored in the routing table may be indexed by a final destination of the packet—thus, by looking up the final destination of the packet (e.g., as identified by a header of the packet), the next destination can be retrieved from the routing table. The forwarding device may then forward the packet on an outbound interface to the identified next destination.
- Certain aspects of the forwarding plane can affect the efficiency of the network. These aspects include the specific rules, algorithms, data structures, and functions employed, the manner in which the forwarding plane is implemented, and the location at which the forwarding plane is implemented and/or enforced.
- A routing controller in a communication network may be responsible for generating a device model for a target device using a universal language of network primitives. The target device may have forwarding capabilities. Exemplary embodiments allow the target device to determine how to forward the incoming data packets based on the intended behavior of the network. The target device may translate the desired behavior described using the universal language into implementation based on the capabilities of the target device. The translation may generate a mapping between the desired behaviors and the implementations thereof.
- The universal language is a target-independent description that is used to define the intent of the network, i.e. the intended forwarding behavior. The universal language may describe a requested capability (e.g., “find the longest prefix match of a subnet mask in a routing table”) without specifying how to implement the requested capability (e.g., without specifying a particular algorithm for performing a longest prefix match). The universal language may support multiple implementations of the specified functionality (e.g., a first algorithm for finding a longest prefix match, and a second algorithm for finding a longest prefix match).
- According to exemplary embodiments, the device model may include one or more known identifiers associated with one or more portions of the model. The mapping between the known identifiers and the capabilities of a target device is known. The known mappings may be stored, for example, in a database of known mappings. The target device, upon receiving the device model with known identifiers from the controller, may retrieve and use the mapping to statically translate the device model to implementation. Absent a known mapping, the translator of the target device would have to dynamically translate intents described in the device model to implementation. Accordingly, the device model provides reusability of the previously determined mappings and does not require the translator to dynamically translate the device model each time the device model is received from the controller.
- In some embodiments, a non-transitory electronic device readable storage medium is provided. The storage medium holds instructions that, when executed, cause one or more processors to receive a device model described in a target-independent format. The device model describes an intended forwarding behavior for a target device. The device model includes one or more known identifiers associated with one or more portions of the device model. The storage medium further holds instructions that, when executed, cause one or more processors to retrieve a mapping that maps the one or more known identifiers of the device model to implementation of one or more capabilities of a target device having a forwarding or switching capability. The storage medium further holds instructions that, when executed, cause one or more processors to configure the target device by statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping.
- According to various embodiments, a method is provided. The method entails receiving a device model described in a target-independent format. The device model describes an intended forwarding behavior for a target device. The method further entails retrieving a mapping that maps one or more elements of the device model to implementation of one or more capabilities of the target device having a forwarding or switching capability. The method also involves configuring the target device by statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping. The method further involves receiving one or more input packets and forwarding the one or more input packets to one or more elements of the network based on the configuring.
- In some embodiments, a system is provided. The system comprises a routing controller, a target device and a storage. The routing controller generates a device model described in a target-independent format. The target device receives the device model. The device model describes an intended forwarding behavior for the target device. The target device has a forwarding or switching capability. The storage stores one or more mappings that map one or more portions of the device model to implementation of one or more capabilities of the target device. The target device is configured to retrieve one or more mappings from the storage for statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping.
-
FIG. 1 depicts anexemplary network 100 including a routing controller and a target device according to an exemplary embodiment. -
FIG. 2 depicts an exemplary manner how elements of theexemplary network 100 interact according to an exemplary embodiment. -
FIG. 3 depicts an exemplary device model generated by a controller according to an exemplary embodiment. -
FIG. 4 is a flowchart describing exemplary steps performed by a controller in accordance with an exemplary embodiment. -
FIG. 5 is a flowchart describing exemplary steps performed by a target device in accordance with an exemplary embodiment. -
FIG. 6 depicts an exemplary electronic device suitable for use with exemplary embodiments described herein. -
FIG. 7 depicts an exemplary network implementation of processing performed according to an exemplary embodiment. - As described in more detail below, exemplary embodiments allow abstracting of the forwarding plane of a software defined network. Conventionally, the abstraction of setting forwarding table entries loses too much information about the intents of the application developer. Thus, conventional techniques cannot leverage all the features of the forwarding device to deliver scalable and efficient end-to-end implementations. The present application aims at mapping high-level forwarding intents to low-level features of the forwarding device.
- A routing controller in the network may be responsible for generating a device model using a universal language of network primitives. The device model may define the intent of the network, i.e. the intended forwarding behavior. The device model may include one or more identifiers associated with one or more portions of the model.
- The controller may send the device model to a target device. The target device translates the desired behavior described in the device model into an implementation based on the capabilities of the target device. For example, the target device may include predetermined hardware or software logic for implementing the desired behavior defined in the device model. Accordingly, the target device may implement a requested capability defined in the device model without receiving instructions prescribing how to implement the requested capability. If the identifiers included in the device model are known to the target device, i.e. the target device previously received and translated the identifiers, the target device would also know the mapping between the identifiers and the implementation for the identifiers. The target device, upon receiving the device model from the controller, may retrieve and use the known mapping to statically translate the device model into an implementation. Absent known mapping, the translator of the target device would have to translate the device model into an implementation dynamically. Accordingly, static translation of the device model provides reusability of the previously determined mappings and does not require the translator to dynamically translate the device model each time the device model is received from the routing controller.
-
FIG. 1 depicts anexemplary network 100 including arouting controller 110 and atarget device 120 according to an exemplary embodiment. Thecontroller 110 may include a processor, a server or other device implemented in hardware, software or a combination thereof. Thenetwork 100 may be a communications network such as the Internet, an intranet, or a telephone network, among other possibilities. Thenetwork 100 may include one or more optical, electronic, or other transmission mediums. - The
controller 110 of thenetwork 100 may be in communication with thetarget device 120. Thecontroller 110 may be connected to thetarget device 120 directly or indirectly. It is understood that thenetwork 100 is for explanatory purposes only, and a network suitable for use with the exemplary embodiments described herein may have other elements or capabilities. For example, the controller may generate a plurality of device models according to various embodiments. - According to an exemplary embodiment, the
target device 120 may have forwarding functionality such that thetarget device 120 is capable of receiving incoming information on an inbound interface, processing the information to determine a next destination of the information, and forwarding the information to the next destination on an outbound interface. - The
controller 110 may generate adevice model 112 using a universal language. Thedevice model 112 may define the intent of the network 100 (e.g., the intended forwarding behavior within the network 100) using the universal language. For example, thedevice model 112 may describe a desired behavior of a node of thenetwork 100 under certain conditions, such as upon the receipt of an incoming packet. - As used herein, the universal language is a target-independent language that can be interpreted by all recipient devices. The universal language may be formed of building blocks called “network primitives”. The
device model 112 may include one ormore network primitives 114. A network primitive 114 is a basic unit of functionality to be implemented by elements of thenetwork 100. A network primitive 114 may be, for example, a description of a particular functionality to be used in thenetwork 100. A network primitive 114 may describe what actions elements of thenetwork 100 are meant to perform, but typically will not include requirements for how those actions are to be carried out. Thus, a networking primitive 114 may describe a desired outcome without providing implementation details for achieving the outcome. The implementation details may be left to the particular device implementing the network primitive 114, or may be specified by an external device. Thedevice model 112 may be constructed as a collection of one ormore network primitives 114. - According to various embodiments, a network primitive 114 related to queuing may specify that a recipient device of the
device model 112 is to implement flat queuing, hierarchical queuing, buffer resource sharing, dynamic buffer sizing, tail drop queue management, weighted tail drop queue management, or queue high and low watermarks. Scheduling primitives may specify that scheduling should be in a round robin fashion, as a weighted round robin, low latency queuing or strict priority queuing, weighted fair queuing, or class-based weighted fair queuing. Metering primitives may make use of one rate two color (1R2C) IP packet marking, 1R3C marking, or 2R3C marking. Numerous other networking primitives may also be utilized. The details of the implementations of these networking primitives may be unspecified and left up to the device that implements the primitives. - The
device model 112 generated by thecontroller 110 may specify all the routing/forwarding functionality within thenetwork 100. In some embodiments, thecontroller 110 may generate a plurality of device models. For example, thecontroller 110 may generate afirst device model 112 to be used under certain circumstances, such as periods of high or low network traffic or upon the receipt of certain types of packets. Thecontroller 110 may generate asecond device model 112′ formed ofnetwork primitives 114′ where thesecond device model 112′ may be used under other circumstances. By modifying thedevice model network 100 to exhibit different network forwarding behaviors. - The
controller 110 may send the generateddevice model 112 and/or 112′ to thetarget device 120. Thedevice model 112 and/or 112′ may represent a complete set of functionality required of thetarget device 120. Where applicable, thetarget device 120 may interpret the information contained in thedevice model 112 and/or 112′ within constraints known to thetarget device 120. Upon receiving thedevice model 112 and/or 112′, thetarget device 120 may translate the intended behavior described in thedevice model 112 and/or 112′ into implementation. Thetarget device 120 may include atranslator 126 provided at a hardware abstraction layer (HAL) 122 of thetarget device 120. Thetranslator 126 may translate the target-independent device model 112 and/or 112′ into implementation on thetarget device 120 based on the capabilities of, for example, the application specific integrated circuit (ASIC) 124 of thetarget device 120. Accordingly, high-level generic desired forwarding behaviors may be mapped to low-level ASIC features. - The
device model 112 and/or 112′ may include one or more identifiers associated with one or more portions of thedevice model 112 and/or 112′. Thetarget device 120 may be familiar with the identifiers of thedevice model 112 and/or 112′. For example, thetarget device 120 may have previously received the one or more identifiers and translated the identifiers into implementation. Thus, thetarget device 120 may know the mapping between the one or more known identifiers and their implementations on the target device. The known mappings may be stored, for example, in a database of known mappings. If thetarget device 120 knows the mapping, thetranslator 126 may retrieve the known mapping from the database and statically translate thedevice model 112 and/or 112′ to implementation on thetarget device 120. That is, instead of dynamically translating one or more portions of the receiveddevice model 112 and/or 112′ to implementation, thetarget device 120 may statically translate thedevice model 112 and/or 112′ into implementation using a pre-mapping. -
FIG. 2 depicts how elements of theexemplary network 100 may interact according to an exemplary embodiment. Thecontroller 202 provided in anetwork 200 may send at least onedevice model 204 to atarget device 250. Thedevice model 204 may include one or more identifiers. Upon receiving the device model withidentifiers 202, thetarget device 250 checks astorage 208, such as a database, for pre-determined mappings between identifiers and their implementations. If thetarget device 250 finds pre-determined mappings for the identifiers in the receiveddevice model 204, thetarget device 250 may retrieve the mappings. Thetranslator 210 of thetarget device 250 may statically translate the identifiers into implementation using the pre-determined mappings retrieved from thestorage 208. If thetarget device 250 does not find pre-determined mappings for the identifiers in the receiveddevice model 204, thetranslator 210 of thetarget device 250 may dynamically translate the identifiers into implementation based on the capabilities of thetarget device 250. When the translation is complete, the intended behavior described in thedevice model 202 is passed toimplementation 212 on the target device. -
FIG. 3 depicts anexemplary device model 300 generated by a controller according to an exemplary embodiment. Thedevice model 300 is provided as a unified modeling language (UML) activity diagram. It is understood that UML activity diagram is used for illustrative purposed and that thedevice model 300 may be provided using other graphical and/or textual modeling languages. Thedevice model 300 illustrates a representation of the network behavior for implementing a media access control (MAC) bridge. Thedevice model 300 includes a plurality of network primitives 302-318. When thedevice model 300 is sent to a target device, the ASIC of the target device is given the specific behavior expected of the network for an efficient implementation by the target device. - According to various embodiments, the
device model 300 may also be expressed using textual code, such as a pseudo code. A portion of an exemplary pseudo code representing thedevice model 300 is provided below. One of ordinary skill in the art will appreciate that the pseudo code is provided for exemplary purposes and should not be construed as limiting. -
{ ... primitive TABLEDEF(Name = “MACTable” /* Data Structure Name */, TableShared = TRUE, TableType = ExactMatch, SearchKey = { { /*Bridging Search Key */ (Vlan, 12), (MACAddress, 48) }, {/* Learning Search Key */ (PortID, 8), (VlanID, 12), (MACAddress, 48) } }, TableResult= {BridgingResult, LearningResult}, TableSize = MacTableSize); ... primitive TABLEOPS_MATCH(MatchName = BridgeForwardingMatch, TABLE=”MACTable”, consumes(VlanID, MACDestAddress), SearchKeyMap={(Vlan:VlanID),(MACAddress:MACDestAddress)}, produces(outPortID, DropPacket), ResultMap = {(BridgingResult.oPort: outPortID), (BridgingResult.drop: DropPacket)} ); ... primitive TABLEOPS_MATCH(MatchName = BridgeLearningMatch, TABLE=”MACTable”, consumes(PortID, VlanID, MACSrcAddress), SearchKeyMap={( (PortID: PortID), (Vlan:VlanID), (MACAddress:MACSrcAddress)}, produces(LearningHit), ResultMap = {(LearningResult.Hit: LearningHit) } ); ... if (LearningHit == TRUE && STPLearningEnabled == TRUE) { /* Conditional Logic Primitive */ ... /* Record Activity for the Src MAC address */ primitive TABLEOPS_MODIFY(MatchName = UpdateMACActivity, TABLE=”MACTable”, consumes(PortID, VlanID, MACSrcAddress, CurrentTimeStamp), SearchKeyMap={(PortID: PortID), (Vlan:VlanID), (MACAddress:MACSrcAddress)}, produces( ), ResultMap = {(LearningResult.LastSeen: CurrentTimeStamp) } ); ... } else if (LearningHit == FALSE && STPLearningEnabled == TRUE) { /* Logic */ ... /* Learn the Src MAC address */ primitive TABLEOPS_INSERT(MatchName = LearnMAC, TABLE=”MACTable”, consumes(PortID, VlanID, MACSrcAddress, CurrentTimeStamp), SearchKeyMap={ (PortID : PortID), (Vlan:VlanID), (MACAddress:MACSrcAddress)}, produces( ), ResultMap = {(LearningResult.LastSeen: CurrentTimeStamp), (BridgingResult.oPort: PortID), (BridgingResult.drop: FALSE)} ); ... } - As illustrated above, the pseudo code may have an entry for the network primitives of the
device model 300. For example, the portion of the pseudo code provided above has an entry for table definition network primitive 306, the tableops_match network primitive 304, the tableops_modify network primitive 308 and the tableops_insert network primitive 310. - The target device, upon receiving the
device model 300 in the graphical format or in the pseudo code format, translates thedevice model 300 into an implementation. The translation of theexemplary device model 300 in the implementation of a MAC bridge will allow communications between one or more end stations coupled to the target device in the network. Specifically, the intended behavior represented in thedevice model 300 allows the interconnection of one or more end stations as if they were attached to a single local area network (LAN), even if the one or more end satiations are attached to separate LANs. - When the controller generates a device model, the controller may send the device model to the target device for implementation. The controller may send the device model in the graphical format and/or in a textual format such as a pseudo code. Both the graphical format and the pseudo code include one or more network primitives generated in a target-independent universal language. The steps performed by the controller and the target device are discussed below.
-
FIG. 4 is a flowchart describing exemplary steps performed by a controller in accordance with an exemplary embodiment. The controller may generate a device model in a target-independent format (step 402). The device model may describe the intended forwarding behavior for the target device. The intended forwarding behavior may be a high-level indication of the intent of the developer. The controller may send the generated device model to the target device for implementation (step 404). -
FIG. 5 is a flowchart describing exemplary steps performed by a target device in accordance with an exemplary embodiment. The target device receives the device model generated by the controller (step 502). The device model may be described in target-independent format. The device model may include one or more identifiers associated with one or more portions of the device model. The one or more identifiers may be known to the target device. For example, the target device may have previously received the one or more identifiers. The target device may retrieve, for example from a storage, a previously-generated mapping between the one or more known identifiers and implementations thereof on the target device (step 504). The target device may statically translate the device model into implementation using the mapping retrieved from the storage (step 506). The target device may be configured based on the translating (step 508). When the target device receives one or more input packets (step 510), the target device may forward the received input packets to one or more elements of the network based on the configuring (step 512). - One or more of the above-described acts may be encoded as computer-executable instructions executable by processing logic. The computer-executable instructions may be stored on one or more non-transitory computer readable media. One or more of the above described acts may be performed in a suitably-programmed electronic device.
FIG. 6 depicts an example of anelectronic device 600 that may be suitable for use with one or more acts disclosed herein. - The
electronic device 600 may take many forms, including but not limited to a computer, workstation, server, network computer, quantum computer, optical computer, Internet appliance, mobile device, a pager, a tablet computer, a smart sensor, application specific processing device, etc. - The
electronic device 600 is illustrative and may take other forms. For example, an alternative implementation of theelectronic device 600 may have fewer components, more components, or components that are in a configuration that differs from the configuration ofFIG. 6 . The components ofFIG. 6 and/or other figures described herein may be implemented using hardware based logic, software based logic and/or logic that is a combination of hardware and software based logic (e.g., hybrid logic); therefore, components illustrated inFIG. 6 and/or other figures are not limited to a specific type of logic. - The
processor 602 may include hardware based logic or a combination of hardware based logic and software to execute instructions on behalf of theelectronic device 600. Theprocessor 602 may include logic that may interpret, execute, and/or otherwise process information contained in, for example, thememory 604. The information may include computer-executable instructions and/or data that may implement one or more embodiments of the invention. Theprocessor 602 may comprise a variety of homogeneous or heterogeneous hardware. The hardware may include, for example, some combination of one or more processors, microprocessors, field programmable gate arrays (FPGAs), application specific instruction set processors (ASIPs), application specific integrated circuits (ASICs), complex programmable logic devices (CPLDs), graphics processing units (GPUs), or other types of processing logic that may interpret, execute, manipulate, and/or otherwise process the information. The processor may include a single core ormultiple cores 603. Moreover, theprocessor 602 may include a system-on-chip (SoC) or system-in-package (SiP). - The
electronic device 600 may include one or more tangible non-transitory computer-readable storage media for storing one or more computer-executable instructions or software that may implement one or more embodiments of the invention. The non-transitory computer-readable storage media may be, for example, thememory 604 or thestorage 618. Thememory 604 may comprise a ternary content addressable memory (TCAM) and/or a RAM that may include RAM devices that may store the information. The RAM devices may be volatile or non-volatile and may include, for example, one or more DRAM devices, flash memory devices, SRAM devices, zero-capacitor RAM (ZRAM) devices, twin transistor RAM (TTRAM) devices, read-only memory (ROM) devices, ferroelectric RAM (FeRAM) devices, magneto-resistive RAM (MRAM) devices, phase change memory RAM (PRAM) devices, or other types of RAM devices. - One or
more computing devices 600 may include a virtual machine (VM) 605 for executing the instructions loaded in thememory 604. Avirtual machine 605 may be provided to handle a process running on multiple processors so that the process may appear to be using only one computing resource rather than multiple computing resources. Virtualization may be employed in theelectronic device 600 so that infrastructure and resources in the electronic device may be shared dynamically.Multiple VMs 605 may be resident on asingle computing device 600. - A
hardware accelerator 606, may be implemented in an ASIC, FPGA, or some other device. Thehardware accelerator 606 may be used to reduce the general processing time of theelectronic device 600. - The
electronic device 600 may include anetwork interface 608 to interface to a Local Area Network (LAN), Wide Area Network (WAN) or the Internet through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., T1, T3, 56kb, X.25), broadband connections (e.g., integrated services digital network (ISDN), Frame Relay, asynchronous transfer mode (ATM), wireless connections (e.g., 802.11), high-speed interconnects (e.g., InfiniBand, gigabit Ethernet, Myrinet) or some combination of any or all of the above. Thenetwork interface 608 may include a built-in network adapter, network interface card, personal computer memory card international association (PCMCIA) network card, card bus network adapter, wireless network adapter, universal serial bus (USB) network adapter, modem or any other device suitable for interfacing theelectronic device 600 to any type of network capable of communication and performing the operations described herein. - The
electronic device 600 may include one ormore input devices 610, such as a keyboard, a multi-point touch interface, a pointing device (e.g., a mouse), a gyroscope, an accelerometer, a haptic device, a tactile device, a neural device, a microphone, or a camera that may be used to receive input from, for example, a user. Note thatelectronic device 600 may include other suitable I/O peripherals. - The
input devices 610 may allow a user to provide input that is registered on avisual display device 614. A graphical user interface (GUI) 616 may be shown on thedisplay device 614. - A
storage device 618 may also be associated with thecomputer 600. Thestorage device 618 may be accessible to theprocessor 602 via an I/O bus. The information may be executed, interpreted, manipulated, and/or otherwise processed by theprocessor 602. Thestorage device 618 may include, for example, a storage device, such as a magnetic disk, optical disk (e.g., CD-ROM, DVD player), random-access memory (RAM) disk, tape unit, and/or flash drive. The information may be stored on one or more non-transient tangible computer-readable media contained in the storage device. This media may include, for example, magnetic discs, optical discs, magnetic tape, and/or memory devices (e.g., flash memory devices, static RAM (SRAM) devices, dynamic RAM (DRAM) devices, or other memory devices). The information may include data and/or computer-executable instructions that may implement one or more embodiments of the invention - The
storage device 618 may further storeapplications 624, and theelectronic device 600 can be running an operating system (OS) 626. Examples ofOS 626 may include the Microsoft® Windows® operating systems, the Unix and Linux operating systems, the MacOS® for Macintosh computers, an embedded operating system, such as the Symbian OS, a real-time operating system, an open source operating system, a proprietary operating system, operating systems for mobile electronic devices, or other operating system capable of running on the electronic device and performing the operations described herein. The operating system may be running in native mode or emulated mode. - The
storage device 618 may further includerules 628 which describe how messages should be forwarded in a communications network. Therules 628 may be used to forward messages or information received at theelectronic device 628. Accordingly, theelectronic device 600 may serve as a forwarding device, switch, or router. - The
storage device 618 may store animplementation database 630. Theimplementation database 630 may be a data structure, such as a table or matrix, which stores identifiers identifying predetermined functions that are implemented by theelectronic device 630. The implementation database may further store the implementation details of the predetermined functions. - The
storage device 618 may further include logic for implementing acommunications protocol 640. Thecommunications protocol 640 may be a protocol which provides an interface for accessing and modifying the functionality of the forwarding plane of theelectronic device 600.Exemplary communications protocols 640 include, but are not limited to, the OpenFlow protocol (see, e.g., McKeown, Nick et al., “OpenFlow: Enabling Innovation in Campus Networks,” ACM SIGCOMM Computer Communication Review Archive, vol. 38 issue 2, pp. 69-74 (April 2008), the contents of which are incorporated herein by reference) or custom communications protocols. Thus, theelectronic device 600 may serve as a remote controller, such as thecontroller 110 described above with respect toFIG. 1 . - The
communications protocol 640 may allow the details of the forwarding plane implemented by theelectronic device 600 to be defined and/or modified. Accordingly, thecommunications protocol 640 allows a communications network to be made programmable. - The
communications protocol 640 may support the use of one ormore device models 642 to implement the functionality of the forwarding plane. Adevice model 642 may represent the complete set of network routing functionality to be implemented by theelectronic device 640. For example, thedevice model 642 may define the functionality and performance of the forwarding plane. - The
device model 642 may include one or more network primitives. A network primitive is a basic unit of functionality to be implemented by theelectronic device 600. A network primitive may be, for example, a description of a particular functionality to be used in the communications network. A network primitive may describe what actions theelectronic device 600 is meant to perform, but typically will not include requirements for how those actions are to be carried out. Thus, a network primitive may describe a desired outcome without providing implementation details for achieving the outcome. The implementation details may be left to the particular device implementing the network primitive, or may be specified by an external device. - For example, a network primitive related to queuing may specify that the electronic device 600 (acting as a forwarding device) is to implement flat queuing, hierarchical queuing, buffer resource sharing, dynamic buffer sizing, tail drop queue management, weighted tail drop queue management, or queue high and low watermarks. Scheduling primitives may specify that scheduling should be in a round robin fashion, as a weighted round robin, low latency queuing or strict priority queuing, weighted fair queuing, or class-based weighted fair queuing. Metering primitives may make use of one rate two color (1R2C) IP packet marking, 1R3C marking, or 2R3C marking. Numerous other network primitives may also be utilized. The details of the implementations of these network primitives may be unspecified and left up to the device that implements the primitives.
- A
device model 642 may be constructed as a collection of one or more network primitives. For example, onedevice model 642 might specify that theelectronic device 600 is to use flat queuing with round robin scheduling. - One or
more device models 642 may specify all the network routing/forwarding functionality of theelectronic device 600. For example, afirst device model 642 may be used under certain circumstances, such as periods of high or low network traffic or upon the receipt of certain types of packets, and that asecond device model 642 may be used under other circumstances. By modifying thedevice model 642, a network administrator may cause theelectronic device 600 to exhibit different network forwarding behaviors. - The
communications protocol 640 may reference adevice model 642 and implement the functionality defined by thedevice model 642 using the functionality defined by theimplementation database 630. Alternatively, thecommunications protocol 640 may use default or generic implementations stored locally with thecommunications protocol 640 or provided from a remote location, such as a remote controller. - One or more embodiments of the invention may be implemented using computer-executable instructions and/or data that may be embodied on one or more non-transitory tangible computer-readable mediums. The mediums may be, but are not limited to, a hard disk, a compact disc, a digital versatile disc, a flash memory card, a Programmable Read Only Memory (PROM), a Random Access Memory (RAM), a Read Only Memory (ROM), Magnetoresistive Random Access Memory (MRAM), a magnetic tape, or other computer-readable media.
-
FIG. 7 depicts a network implementation that may implement one or more embodiments of the invention. Asystem 700 may include acomputing device 600, anetwork 712, aservice provider 713, atarget environment 714, and acluster 715. The embodiment ofFIG. 7 is exemplary, and other embodiments can include more devices, fewer devices, or devices in arrangements that differ from the arrangement ofFIG. 7 . - The
network 712 may transport data from a source to a destination. Embodiments of thenetwork 712 may use network devices, such as routers, switches, firewalls, and/or servers (not shown) and connections (e.g., links) to transport data. Data may refer to any type of machine-readable information having substantially any format that may be adapted for use in one or more networks and/or with one or more devices (e.g., thecomputing device 600, theservice provider 713, etc.). Data may include digital information or analog information. Data may further be packetized and/or non-packetized. - The
network 712 may be a hardwired network using wired conductors and/or optical fibers and/or may be a wireless network using free-space optical, radio frequency (RF), and/or acoustic transmission paths. In one implementation, thenetwork 712 may be a substantially open public network, such as the Internet. In another implementation, thenetwork 712 may be a more restricted network, such as a corporate virtual network. Thenetwork 712 may include Internet, intranet, Local Area Network (LAN), Wide Area Network (WAN), Metropolitan Area Network (MAN), wireless network (e.g., using IEEE 802.11), or other type of network Thenetwork 712 may use middleware, such as Common Object Request Broker Architecture (CORBA) or Distributed Component Object Model (DCOM). Implementations of networks and/or devices operating on networks described herein are not limited to, for example, any particular data type, protocol, and/or architecture/configuration. - The
service provider 713 may include a device that makes a service available to another device. For example, theservice provider 713 may include an entity (e.g., an individual, a corporation, an educational institution, a government agency, etc.) that provides one or more services to a destination using a server and/or other devices. Services may include instructions that are executed by a destination to perform an operation (e.g., an optimization operation). Alternatively, a service may include instructions that are executed on behalf of a destination to perform an operation on the destination's behalf. - The
server 714 may include a device that receives information over thenetwork 712. For example, theserver 714 may be a device that receives user input from thecomputer 600. - The
cluster 715 may include a number of units of execution (UEs) 716 and may perform processing on behalf of the computer 500 and/or another device, such as theservice provider 713 orserver 714. For example, thecluster 715 may perform parallel processing on an operation received from thecomputer 600. Thecluster 715 may includeUEs 716 that reside on a single device or chip or that reside on a number of devices or chips. - The units of execution (UEs) 716 may include processing devices that perform operations on behalf of a device, such as a requesting device. A UE may be a microprocessor, field programmable gate array (FPGA), and/or another type of processing device.
UE 716 may include code, such as code for an operating environment. For example, a UE may run a portion of an operating environment that pertains to parallel processing activities. Theservice provider 713 may operate thecluster 715 and may provide interactive optimization capabilities to the computer 500 on a subscription basis (e.g., via a web service). - Units of Execution (UEs) may provide remote/distributed processing capabilities for the applications 724. A hardware unit of execution may include a device (e.g., a hardware resource) that may perform and/or participate in parallel programming activities. For example, a hardware unit of execution may perform and/or participate in parallel programming activities in response to a request and/or a task it has received (e.g., received directly or via a proxy). A hardware unit of execution may perform and/or participate in substantially any type of parallel programming (e.g., task, data, stream processing, etc.) using one or more devices. For example, a hardware unit of execution may include a single processing device that includes multiple cores or a number of processors. A hardware unit of execution may also be a programmable device, such as a field programmable gate array (FPGA), an application specific integrated circuit (ASIC), a digital signal processor (DSP), or other programmable device. Devices used in a hardware unit of execution may be arranged in many different configurations (or topologies), such as a grid, ring, star, or other configuration. A hardware unit of execution may support one or more threads (or processes) when performing processing operations.
- A software unit of execution may include a software resource (e.g., a technical computing environment) that may perform and/or participate in one or more parallel programming activities. A software unit of execution may perform and/or participate in one or more parallel programming activities in response to a receipt of a program and/or one or more portions of the program. A software unit of execution may perform and/or participate in different types of parallel programming using one or more hardware units of execution. A software unit of execution may support one or more threads and/or processes when performing processing operations.
- The term ‘parallel programming’ may be understood to include multiple types of parallel programming, e.g. task parallel programming, data parallel programming, and stream parallel programming. Parallel programming may include various types of processing that may be distributed across multiple resources (e.g., software units of execution, hardware units of execution, processors, microprocessors, clusters, labs) and may be performed at the same time.
- For example, parallel programming may include task parallel programming where a number of tasks may be processed at the same time on a number of software units of execution. In task parallel programming, a task may be processed independently of other tasks executing, for example, at the same time.
- Parallel programming may include data parallel programming, where data (e.g., a data set) may be parsed into a number of portions that may be executed in parallel using, for example, software units of execution. In data parallel programming, the software units of execution and/or the data portions may communicate with each other as processing progresses.
- Parallel programming may include stream parallel programming (sometimes referred to as pipeline parallel programming). Stream parallel programming may use a number of software units of execution arranged, for example, in series (e.g., a line) where a first software unit of execution may produce a first result that may be fed to a second software unit of execution that may produce a second result given the first result. Stream parallel programming may also include a state where task allocation may be expressed in a directed acyclic graph (DAG) or a cyclic graph.
- Other parallel programming techniques may involve some combination of task, data, and/or stream parallel programming techniques alone or with other types of processing techniques to form hybrid-parallel programming techniques.
- The foregoing description may provide illustration and description of various embodiments of the invention, but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations may be possible in light of the above teachings or may be acquired from practice of the invention. For example, while a series of acts has been described above, the order of the acts may be modified in other implementations consistent with the principles of the invention. Further, non-dependent acts may be performed in parallel.
- In addition, one or more implementations consistent with principles of the invention may be implemented using one or more devices and/or configurations other than those illustrated in the Figures and described in the Specification without departing from the spirit of the invention. One or more devices and/or components may be added and/or removed from the implementations of the figures depending on specific deployments and/or applications. Also, one or more disclosed implementations may not be limited to a specific combination of hardware.
- Furthermore, certain portions of the invention may be implemented as logic that may perform one or more functions. This logic may include hardware, such as hardwired logic, an application-specific integrated circuit, a field programmable gate array, a microprocessor, software, or a combination of hardware and software.
- No element, act, or instruction used in the description of the invention should be construed critical or essential to the invention unless explicitly described as such.
- Also, as used herein, the article “a” is intended to include one or more items. Where only one item is intended, the term “a single” or similar language is used. Further, the phrase “based on,” as used herein is intended to mean “based, at least in part, on” unless explicitly stated otherwise. In addition, the term “user”, as used herein, is intended to be broadly interpreted to include, for example, an electronic device (e.g., a workstation) or a user of an electronic device, unless otherwise stated.
- It is intended that the invention not be limited to the particular embodiments disclosed above, but that the invention will include any and all particular embodiments and equivalents falling within the scope of the following appended claims.
Claims (21)
1. A non-transitory electronic device readable storage medium holding instructions that, when executed, cause one or more processors to:
receive a device model described in a target-independent format, wherein:
the device model describes an intended forwarding behavior for a target device, and
the device model includes one or more known identifiers associated with one or more portions of the device model;
retrieve a mapping that maps the one or more known identifiers of the device model to implementation of one or more capabilities of a target device having a forwarding or switching capability; and
configure the target device by statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping.
2. The medium of claim 1 , wherein the static mapping occurs in a hardware abstraction layer (HAL) implemented in the target device.
3. The medium of claim 1 , wherein the mapping is used for subsequent implementations of the one or more identifiers on the target device.
4. The medium of claim 1 , wherein the mapping is stored at a storage device.
5. The medium of claim 4 , wherein the storage device stores additional mappings.
6. The medium of claim 4 , wherein one or more mappings can be added to the storage device.
7. The medium of claim 1 , wherein the mapping is retrieved among a plurality of mappings.
8. The medium of claim 1 , further storing instructions for:
determining a forwarding scheme for forwarding one or more input packets in the network based on the device model.
9. The medium of claim 1 , further storing instructions for:
receiving one or more input packets;
forwarding the one or more input packets to one or more elements of the network based on the mapping.
10. The medium of claim 1 , wherein the target-independent format comprises a universal language formed of one or more network primitives.
11. A method comprising:
receiving a device model described in a target-independent format, wherein the device model describes an intended forwarding behavior for a target device;
retrieving a mapping that maps one or more elements of the device model to implementation of one or more capabilities of the target device having a forwarding or switching capability;
configuring the target device by statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping;
receiving one or more input packets; and
forwarding the one or more input packets to one or more elements of the network based on the configuring.
12. The method of claim 11 , wherein the static mapping occurs in a hardware abstraction layer (HAL) implemented in the target device.
13. The method of claim 11 , wherein the mapping is used for subsequent implementations of one or more portions of the device model on the target device.
14. The method of claim 11 , wherein the mapping is stored at a storage device.
15. The method of claim 14 , wherein one or more a mappings can be added to the storage device.
16. The method of claim 11 , wherein the mapping is retrieved among a plurality of mappings.
17. The method of claim 11 , further comprising:
determining a forwarding scheme for forwarding the one or more input packets in the network based on the device model.
18. The method of claim 11 , wherein the target-independent format comprises a universal language formed of one or more network primitives.
19. A system comprising:
a routing controller for generating a device model described in a target-independent format;
a target device for receiving the device model, wherein:
the device model describes an intended forwarding behavior for the target device,
the target device has a forwarding or switching capability; and
a storage for storing one or more mappings that map one or more portions of the device model to implementation of one or more capabilities of the target device,
wherein the target device is configured to retrieve one or more mappings from the storage for statically mapping the intended forwarding behavior described in the device model to the implementation of the one or more capabilities of the target device using the retrieved mapping.
20. The system of claim 19 wherein the device model includes one or more known identifiers associated with the one or more portions of the device model.
21. The system of claim 19 wherein the target device is configured to:
receive one or more input packets, and
forward the one or more input packets to one or more elements of the network based on the retrieved mapping.
Priority Applications (4)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/776,012 US20140241347A1 (en) | 2013-02-25 | 2013-02-25 | Static translation of network forwarding plane models into target implementation in the hardware abstraction layer |
CN201480010333.0A CN105027505A (en) | 2013-02-25 | 2014-02-25 | Static translation of network forwarding plane models into target implementation in the hardware abstraction layer |
PCT/US2014/018421 WO2014131044A1 (en) | 2013-02-25 | 2014-02-25 | Static translation of network forwarding plane models into target implementation in the hardware abstraction layer |
EP14714814.2A EP2959636A1 (en) | 2013-02-25 | 2014-02-25 | Static translation of network forwarding plane models into target implementation in the hardware abstraction layer |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/776,012 US20140241347A1 (en) | 2013-02-25 | 2013-02-25 | Static translation of network forwarding plane models into target implementation in the hardware abstraction layer |
Publications (1)
Publication Number | Publication Date |
---|---|
US20140241347A1 true US20140241347A1 (en) | 2014-08-28 |
Family
ID=51388088
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/776,012 Abandoned US20140241347A1 (en) | 2013-02-25 | 2013-02-25 | Static translation of network forwarding plane models into target implementation in the hardware abstraction layer |
Country Status (1)
Country | Link |
---|---|
US (1) | US20140241347A1 (en) |
Cited By (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20140365199A1 (en) * | 2013-06-11 | 2014-12-11 | The Mathworks, Inc. | Pairing a physical device with a model element |
US9582933B1 (en) | 2012-06-26 | 2017-02-28 | The Mathworks, Inc. | Interacting with a model via a three-dimensional (3D) spatial environment |
US9607113B1 (en) | 2012-06-26 | 2017-03-28 | The Mathworks, Inc. | Linking of model elements to spatial elements |
US9672389B1 (en) | 2012-06-26 | 2017-06-06 | The Mathworks, Inc. | Generic human machine interface for a graphical model |
US10355949B2 (en) | 2013-12-04 | 2019-07-16 | Radware, Ltd. | Behavioral network intelligence system and method thereof |
US10360052B1 (en) * | 2013-08-08 | 2019-07-23 | The Mathworks, Inc. | Automatic generation of models from detected hardware |
CN112328325A (en) * | 2020-11-06 | 2021-02-05 | 深圳壹账通智能科技有限公司 | Execution method and device of model file, terminal equipment and storage medium |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20070233840A1 (en) * | 2004-07-09 | 2007-10-04 | Codemate Aps | Peer of a Peer-to-Peer Network and Such Network |
US20080307240A1 (en) * | 2007-06-08 | 2008-12-11 | Texas Instruments Incorporated | Power management electronic circuits, systems, and methods and processes of manufacture |
US20130238774A1 (en) * | 2012-03-09 | 2013-09-12 | Ciena Corporation | Generic multi-layer provisioning service management layer systems and methods |
-
2013
- 2013-02-25 US US13/776,012 patent/US20140241347A1/en not_active Abandoned
Patent Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20070233840A1 (en) * | 2004-07-09 | 2007-10-04 | Codemate Aps | Peer of a Peer-to-Peer Network and Such Network |
US20080307240A1 (en) * | 2007-06-08 | 2008-12-11 | Texas Instruments Incorporated | Power management electronic circuits, systems, and methods and processes of manufacture |
US20130238774A1 (en) * | 2012-03-09 | 2013-09-12 | Ciena Corporation | Generic multi-layer provisioning service management layer systems and methods |
Cited By (8)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9582933B1 (en) | 2012-06-26 | 2017-02-28 | The Mathworks, Inc. | Interacting with a model via a three-dimensional (3D) spatial environment |
US9607113B1 (en) | 2012-06-26 | 2017-03-28 | The Mathworks, Inc. | Linking of model elements to spatial elements |
US9672389B1 (en) | 2012-06-26 | 2017-06-06 | The Mathworks, Inc. | Generic human machine interface for a graphical model |
US20140365199A1 (en) * | 2013-06-11 | 2014-12-11 | The Mathworks, Inc. | Pairing a physical device with a model element |
US10360052B1 (en) * | 2013-08-08 | 2019-07-23 | The Mathworks, Inc. | Automatic generation of models from detected hardware |
US10355949B2 (en) | 2013-12-04 | 2019-07-16 | Radware, Ltd. | Behavioral network intelligence system and method thereof |
US10374918B2 (en) | 2013-12-04 | 2019-08-06 | Radware, Ltd. | Method and system for configuring behavioral network intelligence system using network monitoring programming language |
CN112328325A (en) * | 2020-11-06 | 2021-02-05 | 深圳壹账通智能科技有限公司 | Execution method and device of model file, terminal equipment and storage medium |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11811555B2 (en) | Multicast multipathing in an overlay network | |
Firestone | {VFP}: A virtual switch platform for host {SDN} in the public cloud | |
US20140241347A1 (en) | Static translation of network forwarding plane models into target implementation in the hardware abstraction layer | |
US20200252345A1 (en) | Boosting linked list throughput | |
CN110419200B (en) | Packet processor in virtual filtering platform | |
US10986041B2 (en) | Method and apparatus for virtual network functions and packet forwarding | |
US8976708B1 (en) | Parameterized device models for openflow | |
US9602307B2 (en) | Tagging virtual overlay packets in a virtual networking system | |
US20140241346A1 (en) | Translating network forwarding plane models into target implementation using network primitives | |
US20170026283A1 (en) | Adding multi-tenant awareness to a network packet processing device on a Software Defined Network (SDN) | |
JP2017022767A (en) | Local service chaining with virtual machines and virtualized containers in software defined networking | |
US10909067B2 (en) | Multi-node zero-copy mechanism for packet data processing | |
US10536375B2 (en) | Individual network device forwarding plane reset | |
US10225183B2 (en) | System and method for virtualized receive descriptors | |
US11343190B2 (en) | TCAM-based load balancing on a switch | |
EP2959379B1 (en) | Implementing specifications related to a network forwarding plane of an electronic device having forwarding functionality | |
US20150381492A1 (en) | Dual purpose on-chip buffer memory for low latency switching | |
US20220345422A1 (en) | Adjustable bit mask for high-speed native load balancing on a switch | |
US9426033B2 (en) | Target mapping and implementation of abstract device model | |
US10250399B1 (en) | Multicast routing | |
US8929362B1 (en) | Capability negotiation for abstract candidate device model | |
US9276771B1 (en) | Lossless multipath table compression | |
US9716657B1 (en) | TCP connection resiliency in multipath networks | |
WO2014131044A1 (en) | Static translation of network forwarding plane models into target implementation in the hardware abstraction layer | |
Desmouceaux | Network-Layer Protocols for Data Center Scalability |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:YADAV, NAVINDRA;COHN, DANIEL TODD;SIGNING DATES FROM 20130213 TO 20130220;REEL/FRAME:029993/0692 |
|
STCB | Information on status: application discontinuation |
Free format text: ABANDONED -- FAILURE TO RESPOND TO AN OFFICE ACTION |