US7315930B2 - Method of selecting heuristic class for data placement - Google Patents
Method of selecting heuristic class for data placement Download PDFInfo
- Publication number
- US7315930B2 US7315930B2 US10/698,182 US69818203A US7315930B2 US 7315930 B2 US7315930 B2 US 7315930B2 US 69818203 A US69818203 A US 69818203A US 7315930 B2 US7315930 B2 US 7315930B2
- Authority
- US
- United States
- Prior art keywords
- data
- heuristic
- constraint
- general
- specific
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0628—Interfaces specially adapted for storage systems making use of a particular technique
- G06F3/0629—Configuration or reconfiguration of storage systems
- G06F3/0631—Configuration or reconfiguration of storage systems by allocating resources to storage systems
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0602—Interfaces specially adapted for storage systems specifically adapted to achieve a particular effect
- G06F3/061—Improving I/O performance
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/06—Digital input from, or digital output to, record carriers, e.g. RAID, emulated record carriers or networked record carriers
- G06F3/0601—Interfaces specially adapted for storage systems
- G06F3/0668—Interfaces specially adapted for storage systems adopting a particular infrastructure
- G06F3/067—Distributed or networked storage systems, e.g. storage area networks [SAN], network attached storage [NAS]
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L67/00—Network arrangements or protocols for supporting network services or applications
- H04L67/01—Protocols
- H04L67/10—Protocols in which an application is distributed across nodes in the network
- H04L67/1097—Protocols in which an application is distributed across nodes in the network for distributed storage of data in networks, e.g. transport arrangements for network file system [NFS], storage area networks [SAN] or network attached storage [NAS]
Definitions
- the present invention relates to the field of data storage. More particularly, the present invention relates to the field of data storage where data is placed onto nodes of a distributed storage system.
- a distributed storage system includes nodes coupled by network links.
- the nodes store data objects, which are accessed by clients.
- An example of a distributed storage system is the Internet. According to one use, Internet users access web pages from web sites. By maintaining replicas on nodes near groups of the Internet users, access time for the Internet users is improved and network traffic is reduced.
- Replicas of data objects are placed onto nodes of a distributed storage system using a data placement heuristic.
- the data placement heuristic attempts to find a near optimal solution for placing the replicas onto the nodes but does so without an assurance that the near optimal solution will be found.
- data placement heuristics can be categorized as caching techniques or replication techniques.
- a node employing a caching technique keeps replicas of data objects accessed by the node. Variations of the caching technique include LRU (least recently used) caching and FIFO (first in first out) caching.
- a node employing LRU caching adds a new data object upon access by the node.
- the node discards a data object that was most recently accessed at a time earlier than other data objects stored on the node.
- a node employing FIFO caching also adds a new data object upon access by the node but it discards a data object based upon load time rather than access time.
- the replication techniques seek to make placement decisions about replicas of data objects typically in a more centralized manner than the caching techniques. For example, in a completely centralized replication technique, a single node of the distributed storage system decides where to place replicas of data objects for all data objects and nodes in the distributed storage system.
- a system designer or system administrator seeking to deploy a placement heuristic in order to place replicas of data objects within a distributed storage system will choose a data placement heuristic in an ad-hoc manner. That is, the system designer or administrator will choose a particular data placement heuristic based upon intuition and past experience but without assurance that the data placement heuristic will perform adequately.
- What is needed is a method of selecting a data placement heuristic with an expectation that the data placement heuristic will perform adequately and result in a low replication cost.
- the present invention is a method of selecting a data placement heuristic class for a distributed storage system.
- the method begins by forming an integer program for each of a plurality of heuristic classes for the data placement.
- Each of the integer programs comprising an objective of minimizing a replication cost.
- the method continues with solving each of the integer programs which provide a minimum replication cost for each of the heuristic classes.
- the method concludes with selecting the heuristic class having a low replication cost.
- the method of selecting the heuristic class begins with forming a general integer program which models the data placement and forming a specific integer program which models a heuristic class for the data placement.
- the general and specific integer programs each comprising an objective of minimizing a replication cost.
- the method continues with solving the general integer program which provides a general lower bound for the replication cost and solving the specific integer program which provides a specific lower bound for the replication cost.
- the method concludes with selecting the heuristic class if a difference between the general lower bound and the specific lower bound is within an allowable amount.
- FIG. 1 illustrates an embodiment of a distributed storage system of the present invention
- FIG. 2 illustrates an embodiment of a method of selecting a heuristic class for data placement in a distributed storage system of the present invention as a flow chart
- FIG. 3 provides a table of decision variables according to an embodiment of the method of selecting the heuristic class of the present invention
- FIG. 4 provides a table of specified variables according to an embodiment of the method of selecting the heuristic class of the present invention
- FIG. 5 provides a table of heuristic classes and heuristic properties which model the heuristic classes according to an embodiment of the method of selecting the heuristic class of the present invention
- FIG. 6 illustrates an embodiment of a rounding algorithm of the present invention as a flow chart
- FIG. 7 illustrates an embodiment of a method of instantiating a data placement heuristic of the present invention as a flow chart
- FIG. 8 illustrates an embodiment of a method of determining data placement of the present invention as a block diagram.
- Data is often accessed from geographically diverse locations. By placing a replica or replicas of data near a user or users, data access latencies can be improved.
- An embodiment for accomplishing the improved data access comprises a geographically distributed data repository.
- the geographically distributed data repository comprises a service that provides a storage infrastructure accessible from geographically diverse locations while meeting one or more performance requirements such as data access latency or time to update replicas.
- Embodiments of the geographically distributed data repository include a personal data repository and remote office repositories.
- the personal data repository provides an individual with an ability to access the personal data repository with a range of devices (e.g., a laptop computer, PDA, or cell phone) and from geographically diverse locations (e.g., from New York on Monday and Seattle on Tuesday).
- a range of devices e.g., a laptop computer, PDA, or cell phone
- geographically diverse locations e.g., from New York on Monday and Seattle on Tuesday.
- the provider of the personal data repository guarantees the performance requirements to the individual.
- the performance requirements comprise guaranteeing data access latency to files within a period of time, for example 1 sec.
- the performance requirements comprise a data bandwidth guarantee.
- the data bandwidth guarantee could be guaranteeing that VGA quality video will be delivered without glitches.
- the performance requirements comprise an availability guarantee.
- the availability guarantee could be guaranteeing that data will be available 99% of the time.
- the personal data repository includes data security, backup services, and retrieval services.
- the data security for the individual can be ensured by providing an access key to the individual.
- the backup and retrieval services could form an integral part of the personal data repository.
- the personal data repository also provides a convenient mechanism for the individual to share data with others, for example, by allowing the individual to maintain a personal web log. It is anticipated that the personal data repository would be available to the individual at a cost comparable to hardware based storage.
- the remote office repositories provide employees with access to shared files.
- the performance requirements for the remote office repositories could be data access latency, data bandwidth, or guaranteeing that other employees would see changes to the shared files within an update time period.
- the update time period could be 5 minutes.
- Other features envisioned for the remote office repositories include the data security, backup services, and retrieval services of the personal data repository.
- An exemplary embodiment of the remote office repositories comprises a system configured for a digital movie production studio.
- the system allows an employee to work on an animation scene from home using a laptop incapable of holding the animation scene by meeting certain performance requirements of data access latency and data bandwidth.
- Upon updating the animation scene other employees of the digital movie production studio that have authorized access would be able to see the changes to the animation scene within the update time period.
- the present invention addresses the performance requirements of geographically distributed data repositories while seeking to minimize a replication cost.
- the present invention comprises a method of selecting a heuristic class for data placement from a set of heuristic classes.
- Each of the heuristic classes comprises a method of data placement.
- the method of selecting the heuristic class seeks to minimize the replication cost by selecting the heuristic class that provides a low replication cost while meeting the performance requirement.
- Each of the heuristic classes represents a range of data placement heuristics.
- a heuristic comprises a method employed by a computer that uses an approximation technique to attempt to find a near optimal solution but without an assurance that the approximation technique will find a near optimal solution. Heuristics work well at finding the quasi optimum solution provided that a problem definition for a particular problem falls within a range of problem definitions appropriate for a selected heuristic.
- the term “heuristic” can be employed narrowly to define a search technique that does not provide a result which can be compared to a theoretical best result or it can be employed more broadly to include approximation algorithms which provide a result which can be compared to a theoretical best result.
- the term “heuristic” is used in the broad sense, which includes the approximation algorithms.
- the term “approximation technique” should be read broadly to refer to both heuristics and approximation algorithms.
- An embodiment of the method of selecting the heuristic class comprises solving a general integer program to determine a general lower bound for the replication cost, solving a specific integer program to determine a specific lower bound for the replication cost for a heuristic class, and comparing the general lower bound to the specific lower bound.
- the method selects the heuristic class if the specific lower bound is within an allowable limit of the general lower bound.
- Another embodiment of the method of selecting the heuristic class comprises solving first and second specific integer programs for each of first and second heuristic classes to determine first and second specific lower bounds for the replication cost for each of the first and second heuristic classes.
- the method selects the first or second heuristic class depending upon a lower of the first or second specific lower bounds, respectively.
- a further embodiment of the method of selecting the heuristic class comprises solving the general integer program and the first and second specific integer programs.
- the method selects the first or second heuristic class depending upon a lower of the first or second specific lower bounds, respectively, if the lower of the first or second specific lower bounds is within the allowable lime of the general lower bound.
- the general and specific integer programs for determining the general and specific lower bounds for the replication costs are NP-hard.
- NP-hard means that there is no known algorithm that can solve the problem within any feasible time period, unless the problem size is small.
- an exact solution is only available for a small system.
- the present invention comprises a method of determining a lower bound for the replication cost where the lower bound comprises the general lower bound (for any conceivable heuristic) or the specific lower bound (for a specific class of heuristics).
- An embodiment of the method of determining the lower bound comprises solving an integer program using a linear relaxation of binary variables to determine a lower limit on the lower bound and performing a rounding algorithm until all of the binary variables have binary values, which determines an upper limit on an error for the lower bound.
- the present invention comprises a method of instantiating a data placement heuristic using an input of a plurality of heuristic parameters.
- a node of a distributed storage system receives the heuristic parameters and runs an algorithm, which places data objects on nodes that are within a designated set of nodes.
- a system simulating a node of a distributed storage system receives the heuristic parameters and runs the algorithm, which simulates placing data objects on nodes that are within a node scope.
- the present invention comprises a method of determining data placement for the distributed storage system.
- a system implementing the method selects a heuristic class and instantiates a data placement heuristic using the heuristic class.
- Another embodiment comprises selecting the heuristic class, instantiating the data placement heuristic, and evaluating a resulting data placement.
- the step of evaluating the resulting data placement comprises simulating implementation of the data placement on a system experiencing a workload.
- the step of evaluating the resulting data placement comprises simulating implementation of the data placement on at least two different system configurations experiencing a workload in order to determine which of the system configurations provides better efficiency or better performance.
- the step of evaluating the resulting data placement comprises implementing the data placement on a distributed storage system experiencing an actual workload.
- the distributed storage system 100 comprises first through fourth nodes, 102 . . . 108 , coupled by network links 110 .
- Clients 112 coupled to the first through fourth nodes, 102 . . . 108 access data objects within the distributed storage system 100 .
- Additional network links 114 couple the first through fourth storage nodes, 102 . . . 108 , to additional nodes 116 .
- Each of the first through fourth nodes, 102 . . . 108 , and the additional nodes 116 comprises a storage media for storing the data objects.
- the storage media comprises one or more disks.
- the storage media comprises some other storage media such as a tape.
- a data placement heuristic of the present invention places replicas of the data objects onto the first through fourth nodes, 102 . . . 108 , and the additional nodes 116 .
- the first through fifth nodes, 102 . . . 108 , and the additional nodes 116 are discussed as n nodes where n ⁇ 1, 2, 3, . . . N ⁇ , where N is the number of nodes.
- the data objects are discussed mathematically as k data objects where k ⁇ 1, 2, 3, . . . K ⁇ , where K is the number of data objects.
- the method of selecting the heuristic class 200 begins in a first step 202 of receiving inputs.
- the inputs comprise a system configuration, a workload, and a performance requirement.
- the system configuration represents the distributed storage system 100 .
- the workload represents users requesting data objects from the n nodes.
- the performance requirement comprises a bi-modal performance metric, which comprises a criterion and a ratio of successful attempts to total attempts.
- the performance requirement comprises a data access latency specified as a period of time for fulfilling a ratio of successful data accesses to total data accesses.
- An exemplary data access latency comprises data access within 250 ms for 99% of data access requests.
- the performance requirement comprises a data access bandwidth, a data update time, an availability, or an average data access latency.
- the method of selecting the heuristic class 200 continues in a second step 204 of forming integer programs.
- the integer programs comprise the general integer program and the specific integer program.
- the general integer program models data placement irrespective of a data placement heuristic used to place the data objects. Solving the general integer program provides the general lower bound for the replication cost, which provides a reference for evaluating the heuristic class.
- the specific integer program models the heuristic class.
- the specific integer program comprises the general integer program plus one or more additional constraints.
- the general and specific integer programs model the n nodes storing replicas of the k data objects.
- Each of the n nodes has a demand for some of the k data objects, which are requests from one or more users on the node.
- the one or more users can be one or more of the clients 112 or the user can be the node itself.
- the replicas of the k data objects can be created on or removed from any of the n nodes. These changes occur at the beginning of an evaluation interval.
- the evaluation interval comprises a time period between executions of the data placement heuristic for one of the n nodes. For example, a caching heuristic which is run upon the first node 102 for every access of any of the k data objects from the first node 102 has an evaluation interval of every access. In contrast, a complex centralized placement heuristic which is run once a day has an evaluation interval of 24 hours.
- an evaluation interval period ⁇ i.e., a unit of time, is used to model the evaluation intervals even for the caching heuristic.
- An execution of a data placement heuristic comprises a set of all of the evaluation intervals modeled by the general and specific integer programs.
- the evaluation intervals are discussed herein as i evaluation intervals where i ⁇ 1, 2, 3, . . . I ⁇ , where I is the number of evaluation intervals.
- a selection of the evaluation interval period ⁇ should reflect the heuristic class that is modeled by the specific integer program for at least two reasons. First, as the evaluation interval period ⁇ decreases, a total number of the i evaluation intervals increases.
- the integer programs include decision variables and specified variables.
- the decision variables comprise variables selected from variables listed in Table 1, which is provided as FIG. 3 .
- the specified variables comprise variables selected from variables listed in Table 2, which is provided as FIG. 4 .
- the general integer program comprises an objective of minimizing the replication cost.
- the objective of minimizing the replication cost is given as follows.
- the general integer program further comprises general constraints.
- a first general constraint imposes the performance requirement on each of the nodes by constraining the decision variables so that the ratio of the successful accesses to the total accesses is at least a specified ratio T qos .
- the first general constraint is given as follows.
- a second general constraint imposes a condition that, if a replica of a kth data object is created on an nth node in an ith evaluation interval, the replica exists for the ith evaluation interval.
- the second general constraint is given as follows. create nik ⁇ store nik ⁇ store n,i ⁇ 1,k ⁇ n,i,k
- a third general constraint imposes a condition that initially no replicas exist in the distributed storage system.
- the third general constraint is modified to account for an initial placement of replicas of the k data objects on the n nodes.
- a fourth general constraint imposes the condition that the nth node can access an mth node within a latency threshold T lat .
- the fourth general constraint is given as follows.
- a fifth general constraint imposes a condition that variables store nik , covered nik , and create nik are binary variables. According to an embodiment, the fifth general constraint is given as follows. store nik , covered nik , create nik ⁇ 0, 1 ⁇ ⁇ n,i,k
- a penalty term is added to the objective of minimizing the replication cost.
- the penalty term reflects a secondary objective of minimizing data access latencies latency nm which exceed the latency threshold T lat .
- the penalty term is given as follows.
- a first additional cost term is added to the objective of minimizing the replication cost.
- the first additional term captures a cost of writes in the distributed storage system.
- the first additional cost term is given as follows.
- a second additional cost term is added to the objective of minimizing the replication cost.
- the second additional cost term reflects a cost of enabling a node to run a data placement heuristic and to store replicas of the k data objects.
- the second additional cost term is given as follows.
- additional general constraints are added to the general constraints.
- the additional general constraints impose conditions that an enablement variable open n is a binary variable and that the nth node must be enabled in order to store the k data objects on it.
- the additional general constraints are given as follows. open n ⁇ 0, 1 ⁇ ⁇ n open n ⁇ store nik ⁇ n,i,k
- An embodiment of the specific integer programs adds one or more supplemental constraints to the general constraints of the general integer program.
- the supplemental constraints comprise constraints chosen from a group comprising a storage constraint, a replica constraint, a routing knowledge constraint, an activity history constraint, and a reactive placement constraint.
- the storage constraint reflects a heuristic property that a fixed amount of storage is used throughout an execution of a data placement heuristic. For example, caching heuristics exhibit the heuristic property of using the fixed amount of storage. Thus, if the first integer program models a caching heuristic it would include the storage constraint.
- a global storage constraint imposes a condition of a fixed amount of storage for all of the n nodes and over all of the i intervals. According to an embodiment, the global storage constraint is given as follows.
- a local storage constraint imposes a condition of a fixed amount of storage over all of the i intervals and for each of the n nodes but it allows the fixed amount of storage to vary between the n nodes.
- the local storage constraint is given as follows.
- ⁇ k ⁇ K ⁇ store nik ⁇ k ⁇ K ⁇ store n , 0 , k ⁇ ⁇ ⁇ n , i
- the replica constraint reflects a heuristic property that a fixed number of replicas for each of the k data objects are used throughout an execution of a data placement heuristic.
- centralized data placement heuristics use the fixed number of replicas.
- the second integer program models a centralized data placement heuristic, it is likely to include the replica constraint.
- a first replica constraint imposes a condition of a fixed number of replicas for all of the k data objects and over all of the i intervals irrespective of demand for the k data objects.
- the first replica constraint is given as follows.
- a second replica constraint imposes a condition of a fixed number of replicas over all of the i intervals and for each of the k data objects but it allows the number of replicas to vary between the k data objects.
- the second replication constraint is given as follows.
- ⁇ n ⁇ N ⁇ store nik ⁇ n ⁇ N ⁇ store n , 0 , k ⁇ ⁇ ⁇ i , k
- the routing knowledge constraints reflect a heuristic property of whether a node has knowledge of which others of the n nodes hold replicas of the k data objects. For example, if the nodes of a distributed storage system are using a caching heuristic, a node knows of the replicas stored on itself but has no knowledge of other replicas stored on other nodes. In such a scenario, if the node receives a request for a data object not stored on the node, the node requests the data object from an origin node. If the nodes of the distributed storage system are running a cooperative caching heuristic, a node knows of the replicas stored on nearby nodes or possibly all nodes.
- the routing knowledge constraints are given as follows.
- An embodiment of the activity history constraint discussed below makes use of a sphere of knowledge matrix know nm .
- the data placement heuristic takes into account activity at the node and potentially other nodes in the distributed storage system.
- a caching heuristic makes placement decisions for a node based only on accesses to the node running the caching heuristic.
- the caching heuristic is employed, the sphere of knowledge for a node is local.
- a centralized heuristic makes placement decisions for all nodes in a distributed storage system based on accesses to all of the nodes.
- the sphere of knowledge for a node is global. If a cooperative caching heuristic is employed, the sphere of knowledge for a node is regional.
- the activity history constraint reflects whether a data placement heuristic makes a placement decision based upon activity in one or more evaluation intervals.
- the one or more evaluation intervals include a current evaluation interval and previous evaluation intervals up to a specified number of intervals. If the current evaluation interval is used to make the placement decision, the placement decision is a forecast of a future event since the placement decision is made at the beginning of an evaluation interval. This is referred to as prefetching. If the previous evaluation interval is used to make the placement decision, the placement decision is based upon previous accesses for a data object.
- the activity history constraint imposes the condition that a replica of a data object can be created if the data object has been created within the history and if the history is within a node's sphere of knowledge. For example, if a caching heuristic is employed, a replica of a data object is created if the data object was accessed within a single preceding interval by a node running the caching heuristic. Or for example, if a centralized placement heuristic is employed and if the history is all intervals, a data placement heuristic considers the data objects accessed within the global sphere of knowledge.
- the activity history constraint is given as follows.
- the reactive placement constraint reflects whether the prefetching is precluded. If the prefetching is precluded for a data placement heuristic, it is reactive heuristic.
- the reactive placement constraint imposes the condition that the activity history constraint cannot consider a current evaluation interval. For example, if a simple caching heuristic is employed, a replica of a data object is created if the data object was accessed within a single preceding interval by a node running the simple caching heuristic. Thus, for the simple caching heuristic, the prefetching is precluded.
- the reactive placement constraints are given as follows.
- Solving the general integer program provides a general lower bound for the replication cost that applies to any data placement heuristic or algorithm.
- Solving the specific integer program provides the specific lower bound for the replication cost corresponding to a heuristic class for data placement.
- the heuristic class is described by heuristic properties, which comprise the supplemental constraints and other heuristic properties such as the sphere of knowledge matrix know nm and the activity history matrix hist nik .
- some heuristic classes along with the heuristic properties which model them are listed in Table 3, which is provided as FIG. 5 .
- the method of selecting the heuristic class 200 continues in a third step 206 of solving the general and specific integer programs.
- solving each of the general and specific integer programs comprises an instantiation of the method of determining the lower bound.
- the method of determining the lower bound of the present invention is discussed above and more fully below.
- the third step 206 of solving the general and specific integer programs comprises an exact solution of the general or specific integer program. The alternative embodiment is less preferred because the exact solution is only available for a system configuration having a limited number of nodes.
- the method of selecting the heuristic class 200 concludes in a fourth step 208 of selecting the heuristic class corresponding to the specific integer program if the specific lower bound for the replication cost of the heuristic class is within an allowable limit of the general lower bound.
- the allowable limit comprises a judgment made by an implementer depending upon such factors as the general lower bound (a lower general bound makes a larger allowable limit palatable), a cost of solving an additional specific integer program, and prior acceptable performance of the heuristic class modeled by the specific integer program.
- the implementer will be a system designer or system administrator who makes similar judgments as a matter of course in performing their tasks.
- An alternative embodiment of the method of selecting the heuristic class comprises forming and solving the general integer program and a plurality of specific integer programs where each of the specific integer programs model a heuristic class. For example, a specific integer program could be formed for each of seven heuristic classes identified in Table 3 ( FIG. 5 ).
- the alternative embodiment further comprises selecting the heuristic class which corresponds to the specific lower bound for the replication cost having a low value if the specific lower bound is within the allowable limit of the general lower bound.
- An embodiment of the method of determining the lower bound of the present invention comprises solving an integer program using a linear relaxation of binary variables and performing a rounding algorithm.
- the integer program comprises the general integer program or the specific integer program.
- the binary variables comprise the decision variables store nik of the general integer program or of the specific integer program. Solving the integer program using the linear relaxation of the binary variables provides a lower limit for the lower bound.
- the rounding algorithm provides an upper limit for the lower bound.
- the rounding algorithm 600 begins in a first step 602 of receiving a cost, which has an initial value of the lower limit for the lower bound determined from the solution of the integer program using the linear relaxation of the binary variables.
- the first step 602 further comprises receiving a performance, which has an initial value of the performance requirement.
- the performance requirement comprises the specified ratio of successful accesses to total accesses T qos .
- a second step 604 of the rounding algorithm 600 comprises determining whether any of the decision variables store nik have non-binary values. If not, the method ends because the linear relaxation of the binary variables has provided a binary result. However, this is unlikely.
- the decision variables store nik which have the non-binary values comprise a first subset.
- the rounding algorithm continues in a third step 606 , which comprises calculating a cost penalty, a performance increase, and a performance reward for each of the decision variables store nik within the first subset.
- the performance increase PerfIncrease is given as follows.
- PerfIncrease ( covered nik ) binary - ( covered nik ) nonbinary ⁇ i ⁇ I ⁇ ⁇ k ⁇ K ⁇ read nik Because the value of covered nik is constrained by the fourth general constraint above to a value no greater than one and because the non-binary value of covered nik may already have a value of one, the performance increase PerfIncrease may be found to be zero.
- the performance reward PerfReward is given as follows.
- PerfReward ( covered nik ) binary ⁇ i ⁇ I ⁇ ⁇ k ⁇ K ⁇ read nik Unlike the performance increase PerfIncrease, the performance reward PerfReward will have a value greater than zero provided that the binary value of covered nik is one.
- a fourth step 608 the rounding algorithm picks the binary variable store nik from the subset which corresponds to a lowest ratio of the cost penalty CostPenalty to the performance reward PerfReward (i.e., a lowest value of CostPenalty/PerfReward) and removes it from the first subset.
- a fifth step 610 calculates the cost as a current cost value plus the cost penalty CostPenalty and calculates the performance as the current performance plus the performance increase PerfIncrease.
- a sixth step 612 determines whether any of the decision variables store nik remain in the first subset. If not, the method ends. Otherwise, the method continues.
- a seventh step 614 the rounding algorithm 600 determines which of the decision variables store nik within the first subset may be rounded down without violating the performance requirement.
- the decision variables store nik within the first subset which may be rounded down without violating the performance requirement comprise a second subset.
- An eighth step 616 determines whether the second subset includes any of the decision variables store nik . If not, the rounding algorithm 600 returns to the third step 606 . If so, the method continues.
- the performance increase PerfPenalty is given as follows.
- a tenth step 620 determines whether the second subset contains one or more binary variables store nik with the performance reward PerfReward having a value of zero. If so, the one or more binary variables are rounded to zero and removed from the first subset. If not, an eleventh step 622 finds the binary variable store nik within the second subset with a highest ratio of the cost reward CostReward to the performance reward PerfReward (i.e., a highest value CostReward/PerfReward), rounds this binary variable to zero, and removes it from the first subset. A twelfth step 624 calculates the cost as a current cost value minus the cost reward CostReward and calculates the performance as a current performance minus the performance penalty PerfPenalty. An thirteenth step 626 determines whether any of the decision variables store nik remain in the first subset. If not, the method ends. Otherwise, the method continues by returning to the seventh step 314 .
- a fourteenth step 628 determines whether the integer program includes the storage constraint. If so, a fifteenth step 630 calculates the cost with storage maximized within an allowable storage.
- the storage constraint comprises a global storage constraint. According to an embodiment which includes the global storage constraint, the cost calculated in the fifteenth step 630 is given as follows.
- cost cost c + ⁇ ⁇ ⁇ i ⁇ I ⁇ ⁇ n ⁇ N ⁇ ( c max - ⁇ k ⁇ K ⁇ store nik ) + ⁇ ⁇ ⁇ n ⁇ N ⁇ ( c max - c n )
- cost c is the cost determined by the rounding algorithm prior to reaching the fiffourteenth step 630
- c max is a maximum number of data objects stored on any of the n nodes during any of the i intervals
- c n is a maximum number of data objects stored on an nth node during any of the i intervals.
- the storage constraint comprises a nodal storage constraint.
- the cost calculated in the fifteenth step 630 is given as follows.
- cost cost c + ⁇ ⁇ ⁇ i ⁇ I ⁇ ⁇ n ⁇ N ⁇ ( c n - ⁇ k ⁇ K ⁇ store nik )
- a sixteenth step 632 determines whether the integer program includes the replica constraint. If so, a seventeenth step 634 calculates the cost with replicas maximized within an allowable number of replicas.
- the replica constraint comprises a global replica constraint. According to an embodiment which includes the global replica constraint, the cost calculated in the seventeenth step 634 is given as follows.
- the replica constraint comprises an object specific replica constraint.
- the cost calculated in the seventeenth step 634 is given as follows.
- cost cost c + ⁇ ⁇ ⁇ i ⁇ I ⁇ ⁇ k ⁇ K ⁇ ( d n - ⁇ n ⁇ N ⁇ store nik )
- the method of determining the lower bound ends when the rounding algorithm 600 finds that no binary variables store nik remain in the subset and after considering whether the integer program includes the storage or replica constraint. If the integer program does not include the storage or replica constraint, the cost calculated in the fifth or twelfth step, 610 or 624 , forms the upper limit on the lower bound. If the integer program includes the storage constraint, the cost calculated in the fifteenth step 630 forms the upper limit on the lower bound. And if the integer program includes the replica constraint, the cost calculated in the seventeenth step 634 forms the upper limit on the lower bound.
- the lower limits comprise the lower bounds for the general and specific integer programs.
- the upper limits provide a measure of confidence for the lower bounds.
- the lower limit comprises the lower bound for the general integer program and the upper limit comprises the upper bound for the specific integer program.
- the lower and upper bounds provide a worst case comparison between data placement irrespective of a data placement heuristic used to place the data and data placement according to a heuristic class modeled by the specific integer program.
- the method of selecting the data placement heuristic of the present invention provides inputs for selecting heuristic parameters used in the method of instantiating the data placement heuristic of the present invention.
- An embodiment of the method of instantiating the data placement heuristic comprises receiving heuristic parameters and running an algorithm to place data objects onto one or more nodes of a distributed storage system.
- the heuristic parameters comprise a cost function, a placement constraint, a metric scope, an approximation technique, and an evaluation interval.
- the heuristic parameters comprise a plurality of placement constraints.
- the heuristic parameters further comprise a routing knowledge parameter.
- the heuristic parameters further comprise an activity history parameter.
- the heuristic parameters are defined with reference to the distributed storage system 100 ( FIG. 1 ).
- the distributed storage system 100 comprises the first through fourth nodes, 102 . . . 108 , and the additional nodes 116 , represented mathematically as the n nodes where n ⁇ 1, 2, 3, . . . , N ⁇ .
- the distributed storage system further comprises the clients 112 .
- the clients 112 are represented mathematically as j clients where j ⁇ 1, 2, 3, . . . , J ⁇ .
- the data placement heuristics place the k data objects onto the n nodes where k ⁇ 1, 2, 3, . . . , K ⁇ .
- the distributed storage system 100 further comprises the network links and the additional network links, 110 and 114 , which are represented mathematically as l ⁇ 1, 2, 3, . . . , L ⁇ .
- the heuristic parameters are further defined according to problem definition constraints.
- a first problem definition constraint imposes a condition that each of the j clients sends a request for a kth data object to one and only one node.
- a request variable y jnk indicates whether the ith client sends a request for a kth data object to an nth node.
- the first problem definition constraint is given as follows.
- a second problem definition constraint imposes a condition that only an nth node that stores a kth data object can respond to a request for the kth data object.
- a storage variable store nk indicates whether an nth node stores a kth data object.
- the second problem definition constraint is given as follows. y jnk ⁇ store nk ⁇ j,n,k
- Third and fourth problem definition constraints impose conditions that the request variable y jnk and the storage variable store nk comprise binary variables. According to an embodiment, the third and fourth problem definition constraints are given as follows. y jnk , store nk ⁇ 0, 1 ⁇ ⁇ j,n,k
- the cost function comprises a client perceived performance or an infrastructure cost.
- a goal of the data placement heuristic comprises optimizing the cost function.
- the cost function comprises a sum of distances traversed by j clients accessing n nodes to retrieve k data objects. According to an embodiment, the sum of the distances is given as follows.
- a read variable reads jk indicates a rate of read accesses by a jth client reading a kth data object and where a distance variable dist jn indicates the distance between the jth client and an nth node.
- the distance variable dist jn comprises a network latency between the jth client and the nth node.
- the distance variable dist jn comprises a link cost between the jth client and the nth node.
- the cost function comprises a sum of distances traversed by j clients accessing n nodes to write k data objects.
- the sum of the distances is given as follows.
- the sum of the distances for retrievals is given as follows.
- a size variable size k indicates a size of the kth data object.
- the cost function comprises a sum of storage costs for storing a kth data object on an nth node.
- the sum of the storage costs is given as follows.
- a storage cost variable sc nk indicates a cost of storing the kth data object on the nth node.
- the storage cost variable sc nk indicates a size of the kth data object, a throughput of the nth node, or an indication that the kth data object resides at the nth node.
- the cost function comprises an access time, which indicates a most recent time that a kth data object was accessed on an nth node.
- the cost function comprises a load time, which indicates a time of storage for a kth data object on an nth node.
- the cost function comprises a hit ratio, which indicates a ratio of hits of transparent en route caches along a path from a jth client to an nth node.
- the one or more placement constraints comprise a storage capacity constraint, a load capacity constraint, a node bandwidth capacity constraint, a link capacity constraint, a number of replicas constraint, a delay constraint, an availability constraint, or another placement constraint.
- each of the placement constraints are categorized as an increasing constraint, a decreasing constraint, or a neutral constraint.
- the increasing constraints are violated by allocating too many of the k data objects.
- the decreasing constraints are violated by not allocating enough of the k data objects.
- the neutral constraints are not capable of being characterized as an increasing or decreasing constraints and can be violated in situation which allocate too many of the k data objects or too few of the k data objects.
- the storage capacity constraint places an upper limit on a storage capacity for an nth node.
- the storage capacity constraint comprises an increasing constraint. According to an embodiment, the storage capacity constraint is given as follows.
- SC n indicates the storage capacity for the nth node.
- the load capacity constraint places an upper limit on a rate of requests that an nth node can serve.
- the load capacity constraint comprises a neutral constraint. According to an embodiment, the load capacity constraint is given as follows.
- a load capacity variable LC n indicates the load capacity for the nth node.
- the node bandwidth capacity constraint places an upper limit on a bandwidth for an nth node.
- the node bandwidth capacity constraint comprises a neutral constraint. According to an embodiment, the node bandwidth capacity constraint is given as follows.
- bandwidth capacity variable BW n indicates the bandwidth for the nth node.
- the link capacity constraint places an upper limit on a bandwidth between two nodes.
- the link capacity constraint comprises a neutral constraint.
- the link capacity constraint is given as follows.
- link capacity constraint is given as follows.
- the number of replicas constraint places an upper limit on the number of replicas.
- the number of replicas comprises an increasing constraint. According to an embodiment, the number of replicas constraint is given as follows.
- the delay constraint places an upper limit on a response time for a jth client accessing a kth data object.
- the delay constraint comprises a decreasing constraint.
- the availability constraint places a lower limit on availability of the k data objects.
- the availability constraint comprises a decreasing constraint.
- the metric scope comprises a client scope, a node scope, and an object scope.
- the client scope comprises the j clients considered by the data placement heuristic.
- the client scope ranges from local clients to global clients and includes regional clients, which comprise clients accessing a plurality of nodes within a region.
- the node scope comprises the n nodes considered by the data placement heuristic.
- the node scope ranges form a single node to all nodes and includes regional nodes.
- the object scope comprises the k data objects considered by the data placement heuristic.
- the object scope ranges from local objects (data objects stored on a local node) to global objects (all data objects stored within a distributed storage system) and includes regional objects.
- the approximation technique places the k data objects with the goal of optimizing the cost function but without an assurance that the technique will provide an optimal cost value.
- the approximation technique comprises a ranking technique, a threshold technique, an improvement technique, a hierarchical technique, a multi-phase technique, a random technique, or another approximation technique.
- the terms “heuristic” and “approximation technique” in the context of the present invention have a broad meaning and apply to both heuristics and approximation algorithms.
- the ranking technique begins with determining costs from the cost function for all combinations of clients, nodes, and objects within the metric scope. Next, the ranking technique sorts the costs according to ascending or descending values. The ranking technique then takes a first cost, which represent a jth client accessing a kth data object from an nth node and makes a decision to place the kth data object onto the nth node according to the one or more placement constraints. If a decreasing constraint or a neutral constraint is violated prior to placing the kth data object onto the nth node, the kth data object is placed onto the nth node.
- the kth data object is placed onto the nth node.
- the ranking technique continues to consider placements according to the sorted costs until all of the combinations of clients, nodes, and objects within the metric scope have been considered.
- An alternative of the ranking technique comprises a greedy ranking technique.
- the greedy ranking technique comprises the ranking technique plus an additional step of recomputing the costs of remaining items in the sorted list and sorting the remaining items according to the recomputed costs after each placement decision.
- the threshold technique comprises the ranking technique with the additional step of limiting the sorted list to costs above or below a threshold.
- the random technique comprises randomly placing the k data objects onto the n nodes.
- the improvement technique comprises taking an initial placement of data objects on nodes and attempts to improve the initial placement by swapping placements of particular placements of objects on nodes. If the swapped placement provides a higher cost, the objects are returned to their previous placement. If an increasing constraint is violated with the swapped placement, the objects are returned to their previous placement. If a decreasing or neutral constraint was previously not violated but is violated with the swapped placement, the objects are returned to their previous placement. The improvement technique continues to swap object placements for a number of iterations.
- the hierarchical technique comprises performing the ranking, threshold, or improvement technique at least twice where a following instance of the technique applies a broader metric scope.
- the multiphase technique comprises performing two of the approximation techniques in succession.
- the evaluation interval comprises a measure of how often the method of instantiating the data placement heuristic is executed. According to an embodiment, the evaluation interval comprises a time period between executions of the data placement heuristic for one of the n nodes. According to another embodiment, the evaluation interval comprises a number of accesses by clients of a node such as every access or every tenth access.
- the routing knowledge parameter comprises a specification for each of the n nodes regarding whether the node knows of the replicas stored on it or whether the node knows of all of the replicas stored within the distributed storage system or anything in between.
- FIGS. 7A , 7 B, and 7 C An embodiment of the method of instantiating the data placement heuristic is illustrated in FIGS. 7A , 7 B, and 7 C as a flow chart.
- the method 700 begins in a first step 702 of receiving the cost function, a set of placement constraints, the metric scope, and a set of approximation techniques.
- the set of placement constraints comprises a single placement constraint.
- the set of placement constraints comprises a plurality of placement constraints.
- the set of approximation techniques comprise a single approximation technique.
- the set of approximation techniques comprise a plurality of approximation techniques.
- a third step 706 comprises sorting the costs in ascending or descending order as appropriate for the cost function, which forms a queue.
- the method 700 chooses the ranking technique, the threshold technique, or the improvement technique, respectively. According to an alternative embodiment, the method 700 chooses the random technique. According to another alternative embodiment, the method 700 chooses another approximation technique.
- a seventh step 714 picks a placement of a kth data object on an nth node corresponding to a cost at a head of the queue.
- An eighth step 716 determines whether a neutral or decreasing constraint is currently violated. If the neutral or decreasing constraint is currently not violated, a ninth step 718 determines whether a neutral or increasing constraint will not become violated by placing the kth data object on the nth node. If the eighth or ninth step, 716 or 718 , provides an affirmative response, a tenth step 720 places the kth data object on the nth node. An eleventh step 722 determines whether the queue includes additional costs and, if so, the ranking technique continues.
- the ranking technique continues in a twelfth step 724 of determining whether the ranking technique comprises a greedy technique. If so, a thirteenth step 726 recomputes the costs remaining in the queue and a fourteenth step 728 resorts the costs to reform the queue. The ranking technique then returns to the seventh step 714 .
- a fifteenth step 730 removes costs form the queue which do not meet a threshold.
- a sixteenth step 732 picks a placement of a kth data object on an nth node corresponding to the cost at a head of the queue.
- a seventeenth step 734 determines whether a neutral or decreasing constraint is currently violated. If the neutral or decreasing constraint is currently not violated, an eighteenth step 736 determines whether a neutral or increasing constraint will not become violated by placing the kth data object on the nth node. If the seventeenth or eighteenth step, 734 or 736 , provides an affirmative response, a nineteenth step 738 places the kth data object on the nth node.
- a twentieth step 740 determines whether the queue includes additional costs and, if so, the threshold technique continues.
- an initial placement of the k data objects on the n nodes within the metric scope has preferably been determined using the ranking or threshold technique.
- the initial placement of the k data objects on the n nodes within the metric scope is determined using the random technique.
- the initial placement of the k data objects on the n nodes within the metric scope is determined using another technique. Since the improvement technique begins with the initial placement of the k data objects placed on the n nodes, the improvement technique forms part of the multiphase technique where a first phase comprises the ranking, threshold, random, or other technique and where a second phase comprises the improvement technique.
- a twenty-first step 742 the improvement technique swaps a placement of two of the k data objects within the metric scope, which forms a swapped placement.
- a twenty-second step 744 determines whether the swapped placement incurs a worse cost.
- a twenty-third step 746 determines whether the swapped placement violates an increasing constraint.
- a twenty-fourth step 748 determines whether a neutral or decreasing constraint is violated and whether the placement prior to swapping did not violate the neutral or decreasing constraint. If the twenty-first, twenty-second, or twenty-third step, 742 , 744 , or 746 , provides an affirmative response, a twenty-fifth step 750 reverts the placement to the placement prior to swapping.
- a twenty-sixth step 752 determines whether to perform more iterations of the improvement technique. If so, the improvement technique returns to the twenty-first step 742 .
- the method 700 determines whether to perform the hierarchical technique and, if so, the method 700 returns to the second step 704 with a broader metric scope. In a twenty-eighth step 756 , the method 700 determines whether to perform the multiphase technique and, if so, the returns to the second step 704 to begin a next phase of the multiphase technique.
- the method of instantiating the data placement heuristic along with the method of selecting the heuristic class forms the method of determining the data placement of the present invention.
- FIG. 8 An embodiment of the method of determining the data placement of the present invention is illustrated in FIG. 8 as a block diagram.
- the method 800 begins by inputting a workload, a system configuration, and a performance requirement to a first block 802 , which select a heuristic class.
- a second block 804 receives the heuristic class and instantiates a data placement heuristic resulting in a placement of data objects on nodes of a distributed storage system.
- a third block 806 evaluates the data placement by applying a workload to the distributed storage system and measuring a performance and a replication cost, which are provided as outputs.
- the outputs are provided to the first block 802 , which begins an iteration of the method 800 .
- the method 800 functions as a control loop.
- the distributed storage system comprises an actual distributed storage system.
- the method 800 functions as a component of the distributed storage system.
- the distributed storage system comprises a simulation of a distributed storage system.
- the method 800 functions as a simulator.
- the outputs comprise an actual workload, the performance, and the replication cost.
- the outputs comprise the performance and the replication cost.
- the outputs comprise the workload, the performance, and the replication cost.
- the outputs comprise the system configuration, the performance, and the replication cost.
- the first block 802 receives the inputs and selects the heuristic class.
- the first block 802 provides the heuristic class to the second block 804 as a single parameter indicating the heuristic class.
- the single parameter could indicate one of the heuristic classes identified in Table 3 ( FIG. 8 ), such as storage constrained heuristics or local caching.
- the first block 802 provides the heuristic class to the second block 804 as the heuristic parameters of the method of instantiating the data placement heuristic.
- the first block 802 sets some of the heuristic parameters to defaults because the heuristic class does not specify these parameters.
- the first block 802 provides some of the heuristic parameters to the second block 804 and the second block 804 assigns defaults to the heuristic parameters not provided by the first block 802 .
- the second block 804 instantiates the data placement heuristic for each evaluation interval within an execution of the second block 804 . For example, if the evaluation interval is one hour and the execution is twenty four hours, the second block instantiates the data placement heuristic every hour for the twenty four hours.
- the outputs from the third block 806 comprise the performance and the replication cost for twenty four instantiations of the data placement heuristic.
- the evaluation interval is twenty-four hours and the execution is twenty-four hours.
- the outputs from the third block 806 comprise the performance and the replication cost for a single instantiation of the data placement heuristic.
- a first operation of the control loop begins with the inputs comprising an anticipated workload, the system configuration, and the performance requirement.
- Second and subsequent operations of the control loop use an actual workload, the performance, and the replication cost from the third block 806 to improve operation of the distributed storage system.
- the control loop improves the performance by tuning the heuristic parameters provided by the first block 802 to the second block 804 .
- the heuristic parameters tuned by the first block 804 comprise previously provided heuristic parameters or previously provided defaults.
- control loop improves the performance by keeping a history of actual workloads so that the first block 802 provides the heuristic parameters to the second block based upon time, such as by hour of day or day of week.
- the second block instantiates different data placement heuristics depending upon the time.
- a first operation of the control loop begins with the inputs comprising an initial workload, the system configuration, and the performance requirement.
- the third block 806 outputs the workload, the performance, and the replication cost. Second and subsequent operations of the control loop vary the workload in order to identify heuristic parameters that instantiate a data placement heuristic that operates well under a range of workloads.
- a first operation of the control loop begins with inputs comprising the workload, an initial system configuration, and the performance requirement.
- the third block 806 outputs the system configuration, the performance, and the replication cost. Second and subsequent operations of the control loop vary the system configuration in order to identify a particular system configuration that operates well under the workload.
- a first operation of the control loop begins with inputs comprising an initial workload, an initial system configuration, and the performance requirement.
- the third block outputs the workload, the system configuration, the performance, and the replication cost.
- Second and subsequent operations of the control loop vary the workload or the system configuration in order to identify a particular system configuration and a data placement heuristic that operates well under a range of workloads.
Abstract
Description
createnik≧storenik−storen,i−1,k ∀n,i,k
storen,−1,k=0 ∀n,k
In an alternative embodiment, the third general constraint is modified to account for an initial placement of replicas of the k data objects on the n nodes.
storenik, coverednik, createnikε{0, 1} ∀n,i,k
opennε{0, 1} ∀n
openn≧storenik ∀n,i,k
A local storage constraint imposes a condition of a fixed amount of storage over all of the i intervals and for each of the n nodes but it allows the fixed amount of storage to vary between the n nodes. According to an embodiment, the local storage constraint is given as follows.
A second replica constraint imposes a condition of a fixed number of replicas over all of the i intervals and for each of the k data objects but it allows the number of replicas to vary between the k data objects. According to an embodiment, the second replication constraint is given as follows.
routenmik−fetchnm≦0 ∀n,m,i,k
Because the value of coverednik is constrained by the fourth general constraint above to a value no greater than one and because the non-binary value of coverednik may already have a value of one, the performance increase PerfIncrease may be found to be zero.
Unlike the performance increase PerfIncrease, the performance reward PerfReward will have a value greater than zero provided that the binary value of coverednik is one.
where costc is the cost determined by the rounding algorithm prior to reaching the
where dmax is a maximum number of replicas of any of the k data objects stored during any of the i intervals and where dn is a maximum number of replicas of a kth data object during any of the i intervals. According to an embodiment, the replica constraint comprises an object specific replica constraint. According to an embodiment which includes the object specific replica constraint, the cost calculated in the
yjnk≦storenk ∀j,n,k
yjnk, storenkε{0, 1} ∀j,n,k
where a read variable readsjk indicates a rate of read accesses by a jth client reading a kth data object and where a distance variable distjn indicates the distance between the jth client and an nth node. According to an embodiment, the distance variable distjn comprises a network latency between the jth client and the nth node. According to an alternative embodiment, the distance variable distjn comprises a link cost between the jth client and the nth node.
where a write variable writesjk indicates that a jth client writes a kth data object.
where a size variable sizek indicates a size of the kth data object.
where a storage cost variable scnk indicates a cost of storing the kth data object on the nth node. According to embodiments, the storage cost variable scnk indicates a size of the kth data object, a throughput of the nth node, or an indication that the kth data object resides at the nth node.
where a storage capacity variable SCn indicates the storage capacity for the nth node.
where a load capacity variable LCn indicates the load capacity for the nth node. According to an alternative embodiment, the load capacity constraint is given as follows.
where a bandwidth capacity variable BWn indicates the bandwidth for the nth node. According to an alternative embodiment, the bandwidth capacity constraint is given as follows.
where an alternative access variable zjlk indicates whether a jth client uses an ith link to access a kth data object and where link capacity variable CLl indicates the bandwidth for the lth link. According to an alternative embodiment, the link capacity constraint is given as follows.
where a number of replicas variable P indicates the number of replicas.
Claims (27)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/698,182 US7315930B2 (en) | 2003-10-30 | 2003-10-30 | Method of selecting heuristic class for data placement |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/698,182 US7315930B2 (en) | 2003-10-30 | 2003-10-30 | Method of selecting heuristic class for data placement |
Publications (2)
Publication Number | Publication Date |
---|---|
US20050097283A1 US20050097283A1 (en) | 2005-05-05 |
US7315930B2 true US7315930B2 (en) | 2008-01-01 |
Family
ID=34550560
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/698,182 Expired - Fee Related US7315930B2 (en) | 2003-10-30 | 2003-10-30 | Method of selecting heuristic class for data placement |
Country Status (1)
Country | Link |
---|---|
US (1) | US7315930B2 (en) |
Cited By (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20140032200A1 (en) * | 2010-02-09 | 2014-01-30 | Google Inc. | Systems and Methods of Simulating the State of a Distributed Storage System |
US8862814B2 (en) | 2011-08-10 | 2014-10-14 | International Business Machines Corporation | Video object placement for cooperative caching |
US9098201B2 (en) | 2011-06-23 | 2015-08-04 | Cohort Fs, Llc | Dynamic data placement for distributed storage |
US9747322B2 (en) | 2010-02-09 | 2017-08-29 | Google Inc. | Storage of data in a distributed storage system |
Families Citing this family (17)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7343459B2 (en) | 2004-04-30 | 2008-03-11 | Commvault Systems, Inc. | Systems and methods for detecting & mitigating storage risks |
US20110010518A1 (en) * | 2005-12-19 | 2011-01-13 | Srinivas Kavuri | Systems and Methods for Migrating Components in a Hierarchical Storage Network |
US20080065704A1 (en) * | 2006-09-12 | 2008-03-13 | Microsoft Corporation | Data and replica placement using r-out-of-k hash functions |
US20100257403A1 (en) * | 2009-04-03 | 2010-10-07 | Microsoft Corporation | Restoration of a system from a set of full and partial delta system snapshots across a distributed system |
US8261126B2 (en) | 2009-04-03 | 2012-09-04 | Microsoft Corporation | Bare metal machine recovery from the cloud |
US8805953B2 (en) * | 2009-04-03 | 2014-08-12 | Microsoft Corporation | Differential file and system restores from peers and the cloud |
US8706782B2 (en) * | 2011-06-12 | 2014-04-22 | International Business Machines Corporation | Self-contained placement of data objects in a data storage system |
US10379988B2 (en) * | 2012-12-21 | 2019-08-13 | Commvault Systems, Inc. | Systems and methods for performance monitoring |
US9633041B2 (en) | 2013-09-26 | 2017-04-25 | Taiwan Semiconductor Manufacturing Co., Ltd. | File block placement in a distributed file system network |
US10341208B2 (en) | 2013-09-26 | 2019-07-02 | Taiwan Semiconductor Manufacturing Co., Ltd. | File block placement in a distributed network |
US10291503B2 (en) | 2013-09-26 | 2019-05-14 | Taiwan Semiconductor Manufacturing Co., Ltd. | File block placement in a distributed network |
US10956299B2 (en) | 2015-02-27 | 2021-03-23 | Commvault Systems, Inc. | Diagnosing errors in data storage and archiving in a cloud or networking environment |
US10275320B2 (en) | 2015-06-26 | 2019-04-30 | Commvault Systems, Inc. | Incrementally accumulating in-process performance data and hierarchical reporting thereof for a data stream in a secondary copy operation |
US10176036B2 (en) | 2015-10-29 | 2019-01-08 | Commvault Systems, Inc. | Monitoring, diagnosing, and repairing a management database in a data storage management system |
US11032350B2 (en) | 2017-03-15 | 2021-06-08 | Commvault Systems, Inc. | Remote commands framework to control clients |
US10831591B2 (en) | 2018-01-11 | 2020-11-10 | Commvault Systems, Inc. | Remedial action based on maintaining process awareness in data storage management |
US20200192572A1 (en) | 2018-12-14 | 2020-06-18 | Commvault Systems, Inc. | Disk usage growth prediction system |
Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6240414B1 (en) * | 1997-09-28 | 2001-05-29 | Eisolutions, Inc. | Method of resolving data conflicts in a shared data environment |
US6374227B1 (en) * | 1999-04-15 | 2002-04-16 | I2 Technologies Us, Inc. | System and method for optimizing the allocation of a resource |
US20020177989A1 (en) * | 2001-05-25 | 2002-11-28 | Guillermo Alvarez | Method and apparatus for predicting multi-part performability |
US20020184555A1 (en) * | 2001-04-23 | 2002-12-05 | Wong Joseph D. | Systems and methods for providing automated diagnostic services for a cluster computer system |
US7107596B2 (en) * | 2002-03-14 | 2006-09-12 | International Business Machines Corporation | Statistically-triggered heuristics |
-
2003
- 2003-10-30 US US10/698,182 patent/US7315930B2/en not_active Expired - Fee Related
Patent Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6240414B1 (en) * | 1997-09-28 | 2001-05-29 | Eisolutions, Inc. | Method of resolving data conflicts in a shared data environment |
US6374227B1 (en) * | 1999-04-15 | 2002-04-16 | I2 Technologies Us, Inc. | System and method for optimizing the allocation of a resource |
US20020184555A1 (en) * | 2001-04-23 | 2002-12-05 | Wong Joseph D. | Systems and methods for providing automated diagnostic services for a cluster computer system |
US20020177989A1 (en) * | 2001-05-25 | 2002-11-28 | Guillermo Alvarez | Method and apparatus for predicting multi-part performability |
US7107596B2 (en) * | 2002-03-14 | 2006-09-12 | International Business Machines Corporation | Statistically-triggered heuristics |
Non-Patent Citations (24)
Title |
---|
Alec Wolman, Geoffrey M. Voelker, Nitin Sharm, Neal Cardwell, Anna Karlin, and Henry M. Levy, On the Scale and Performance of Cooperative Web Proxy Caching, Proceedings of the 17th ACM Symposium on Operating Systems Principles, Kiawah Island, SC, pp. 16-31, ACM Press, New York, NY, 1999. |
Arun Venkataramani, Phoebe Weidmann, and Mike Dahlin, Bandwidth Constrained Placement in a WAN, 2001. |
Christos Karamanolis, and Magnus Karlsson, U.S. Appl. No. 10/698,264, Oct. 30, 2003. |
Gehlsen et al. "A Framework for Distributed Simulation Optimization", 2001, pp. 508-514. * |
Haifeng Yu, and Amin Vahdat, Minimal Replication Cost for Availability, Jul. 2002. |
Kamal Jain, Mohammad Mahdian, Evangelos Markakis, Amin Saberi, and Vijay V. Vazirani, Greedy Facility Location Algorithms Analyzed Using Dual Fitting With Factor-Revealing LP, ArXiv, Cornell University, Ithica, NY, Jul. 9, 2002. < http://arxiv.org/PS<SUB>-</SUB>cache/cs/pdf/0207/0207028.pdf>. |
Law rence W. Dowdy, Derrell V. Foster, Comparative Models of the File Assignment Problem, ACM Computing Surveys (CSUR), vol. 14, No. 2, pp. 287-313, ACM Press, New York, NY, Jun. 1982. |
Lili Qiu, Venkata N. Padmananabhan and Geoffrey M. Voelker, On the Placement of Web Server Replicas, INFOCOM, 2001. |
Lo "Heuristics algorithms for task assignment in distributed systems" 1988 IEEE, pp. 1384-1397. * |
Magnus Karlsson and Christos Karamanolis, Bounds on the Replication Cost for QoS, Technical Report HPL-2003-156, Hewlett-Packard Company, Palo Alto, CA, Jul. 24, 2003. <http://www.hpl.hp.com/techreports/2003/HPL-2003-156.pdf>. |
Magnus Karlsson and Christos Karamanolis, U.S. Appl. No. 10/698,263, Oct. 30, 2003. |
Magnus Karlsson and Christos Karamanolis, U.S. Appl. No. 10/698,265, Oct. 30, 2003. |
Magnus Karlsson, and Mallik Mahalingam, Do We Need Replica Placement Algorithms in Content Delivery Networks?, Technical Report HPL-2002-220, Hewlett-Packard Company, Palo Alto, CA, Aug. 16, 2002. < http://www.hpl.hp.com/techreports/2002/HPL-2002-220.pdf>. |
Magnus Karlsson, Christos Karamanolis, and Mallik Mahalingam, A Framework for Evaluating Replica Placement Algorithms, Technical Report, HPL-2002-219, Hewlett-Packard Company, Palo Alto, CA, Aug. 16, 2002. < http://www.hpl.hp.com/techreports/2002/HPL-2002-219.pdf>. |
Mahmood, A. and H. U. Khan and H. A. Fatmi, Adaptive File Allocation in Distributed Computer Systems, Nov. 2, 1993, King's College London, University of London, 354-361. * |
Mark S. Daskin and Susan H. Owen, Partial Covering P-Center and Partial Covering Set Covering Models, Presentation, International Symposium on Location Decisions (ISOLDE VIII), Portugal, Jun. 23-29, 1999. |
P. Krishnan, Danny Raz, and Yuval Shavitt, The Cache Location Problem, IEEE/ACM Transactions on Networking, vol. 8, No. 5, pp. 568-582, ACM Press, New York, NY, Oct. 2000. |
Pierre Chardaire, Facility Location Optimization and Cooperative Games, Ph.D. Thesis, pp. 46-62, Chapter 3 and pp. 175-184, Bibliography, School of Information Systems, University of East-Anglia, Norwich UK, 1998. |
Poonawala, Mustafa, "Reusable Strategies for Testing Safety-Critical Systems", University of Minnesota, Sep. 1999, 136-150. * |
Raj Tewari and Nabil R. Adam, Distributed File Allocation with Consistency Constraints, 1992. |
Samy Mahmoud and J. S. Riordon, Optimal Allocation of Resources in Distributed Information Networks, ACM Transactions on Database Systems, vol. 1, No. 1, pp. 66-78, ACM Press, New York, NY, Mar. 1976. |
Sridhar Rajagopalan, and Vijay V. Vazirani, Primal-dual RNC Approximation of Covering Integer Programs, 1999. |
Sugih Jamin, Cheng Jin, Anthony R. Kurc, Danny Raz and Yuval Shavitt, Constrained Mirror Placement on the Internet, INFOCOM, 2001. |
Susan Hesse Owen and Mark S. Daskin, Strategic Facility Location: A Review, vol. 111, Issue 3, pp. 423-447, European Journal of Operational Research, Elsevier Science B.V., Amsterdam, Netherlands, 1998. |
Cited By (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20140032200A1 (en) * | 2010-02-09 | 2014-01-30 | Google Inc. | Systems and Methods of Simulating the State of a Distributed Storage System |
US9659031B2 (en) * | 2010-02-09 | 2017-05-23 | Google Inc. | Systems and methods of simulating the state of a distributed storage system |
US9747322B2 (en) | 2010-02-09 | 2017-08-29 | Google Inc. | Storage of data in a distributed storage system |
US9098201B2 (en) | 2011-06-23 | 2015-08-04 | Cohort Fs, Llc | Dynamic data placement for distributed storage |
US8862814B2 (en) | 2011-08-10 | 2014-10-14 | International Business Machines Corporation | Video object placement for cooperative caching |
Also Published As
Publication number | Publication date |
---|---|
US20050097283A1 (en) | 2005-05-05 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US7315930B2 (en) | Method of selecting heuristic class for data placement | |
US20050283487A1 (en) | Method of determining lower bound for replication cost | |
Berger | Towards lightweight and robust machine learning for cdn caching | |
Yu et al. | Stochastic load balancing for virtual resource management in datacenters | |
CN104899286B (en) | Distributed content is stored and is fetched | |
US6223206B1 (en) | Method and system for load balancing by replicating a portion of a file being read by a first stream onto second device and reading portion with a second stream capable of accessing | |
US20050097285A1 (en) | Method of determining data placement for distributed storage system | |
US6125396A (en) | Method and apparatus for implementing bandwidth allocation with a reserve feature | |
Li et al. | Accurate learning or fast mixing? Dynamic adaptability of caching algorithms | |
US20150319230A1 (en) | Dimension based load balancing | |
Chen et al. | Approximation Algorithms for Data Distribution with Load Balancing of Web Servers. | |
CN101226542A (en) | Method for caching report | |
US20050097286A1 (en) | Method of instantiating data placement heuristic | |
Chauhan et al. | Optimal admission control policy based on memetic algorithm in distributed real time database system | |
Chen et al. | Performance analysis of admission control algorithms based on reward optimization for real-time multimedia servers | |
Al Mistarihi et al. | Replica management in data grid | |
Selvi et al. | Popularity (hit rate) based replica creation for enhancing the availability in cloud storage | |
Adamaszek et al. | An O (log k)-competitive algorithm for generalized caching | |
Rahman et al. | Study of different replica placement and maintenance strategies in data grid | |
Huang et al. | Qos-based resource discovery in intermittently available environments | |
Cohen et al. | Self-adjusting advertisement of cache indicators with bandwidth constraints | |
CN104767822A (en) | Data storage method based on version | |
US20050097284A1 (en) | Method of determining bounds for minimum cost | |
Zhang | A QoS-enhanced data replication service in virtualised cloud environments | |
Zhuo et al. | Efficient cache placement scheme for clustered time-shifted TV servers |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: HEWLETT-PACKARD DEVELOPMENT COMPANY, TEXASFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:KARLSSON, MAGNUS;KARAMANOLIS, CHRISTOS;REEL/FRAME:014168/0838Effective date: 20031030 |
|
CC | Certificate of correction | ||
REMI | Maintenance fee reminder mailed | ||
FPAY | Fee payment |
Year of fee payment: 4 |
|
SULP | Surcharge for late payment | ||
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:HEWLETT-PACKARD DEVELOPMENT COMPANY, L.P.;HEWLETT-PACKARD COMPANY;REEL/FRAME:027661/0258Effective date: 20111025 |
|
REMI | Maintenance fee reminder mailed | ||
LAPS | Lapse for failure to pay maintenance fees | ||
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20160101 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044142/0357Effective date: 20170929 |