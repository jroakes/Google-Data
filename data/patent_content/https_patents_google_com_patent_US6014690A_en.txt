US6014690A - Employing multiple channels for deadlock avoidance in a cache coherency protocol - Google Patents
Employing multiple channels for deadlock avoidance in a cache coherency protocol Download PDFInfo
- Publication number
- US6014690A US6014690A US08/957,531 US95753197A US6014690A US 6014690 A US6014690 A US 6014690A US 95753197 A US95753197 A US 95753197A US 6014690 A US6014690 A US 6014690A
- Authority
- US
- United States
- Prior art keywords
- memory
- nodes
- processor
- steps
- data
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime
Links
- 230000015654 memory Effects 0.000 claims abstract description 258
- 238000000034 method Methods 0.000 claims abstract description 88
- 230000004044 response Effects 0.000 claims description 56
- 230000005540 biological transmission Effects 0.000 claims description 16
- 230000001419 dependent effect Effects 0.000 claims description 12
- 230000008878 coupling Effects 0.000 claims description 9
- 238000010168 coupling process Methods 0.000 claims description 9
- 238000005859 coupling reaction Methods 0.000 claims description 9
- 239000000872 buffer Substances 0.000 abstract description 207
- 238000012545 processing Methods 0.000 abstract description 61
- 230000003111 delayed effect Effects 0.000 abstract description 32
- 230000003139 buffering effect Effects 0.000 abstract description 11
- 230000007334 memory performance Effects 0.000 abstract description 3
- 238000010586 diagram Methods 0.000 description 54
- 239000000523 sample Substances 0.000 description 34
- 230000007246 mechanism Effects 0.000 description 29
- 239000003550 marker Substances 0.000 description 23
- 238000004891 communication Methods 0.000 description 21
- 238000013461 design Methods 0.000 description 16
- 238000012546 transfer Methods 0.000 description 16
- 235000008694 Humulus lupulus Nutrition 0.000 description 10
- 230000001427 coherent effect Effects 0.000 description 10
- 238000003780 insertion Methods 0.000 description 10
- 230000037431 insertion Effects 0.000 description 10
- 230000008569 process Effects 0.000 description 10
- 230000001965 increasing effect Effects 0.000 description 8
- 238000005266 casting Methods 0.000 description 6
- 238000012544 monitoring process Methods 0.000 description 5
- 230000003068 static effect Effects 0.000 description 5
- 230000009471 action Effects 0.000 description 4
- 230000006870 function Effects 0.000 description 4
- 238000012423 maintenance Methods 0.000 description 4
- 238000013459 approach Methods 0.000 description 3
- AMHIJMKZPBMCKI-PKLGAXGESA-N ctds Chemical compound O[C@@H]1[C@@H](OS(O)(=O)=O)[C@@H]2O[C@H](COS(O)(=O)=O)[C@H]1O[C@H]([C@@H]([C@H]1OS(O)(=O)=O)OS(O)(=O)=O)O[C@H](CO)[C@H]1O[C@@H](O[C@@H]1CO)[C@H](OS(O)(=O)=O)[C@@H](OS(O)(=O)=O)[C@@H]1O[C@@H](O[C@@H]1CO)[C@H](OS(O)(=O)=O)[C@@H](OS(O)(=O)=O)[C@@H]1O[C@@H](O[C@@H]1CO)[C@H](OS(O)(=O)=O)[C@@H](OS(O)(=O)=O)[C@@H]1O[C@@H](O[C@@H]1CO)[C@H](OS(O)(=O)=O)[C@@H](OS(O)(=O)=O)[C@@H]1O[C@@H](O[C@@H]1CO)[C@H](OS(O)(=O)=O)[C@@H](OS(O)(=O)=O)[C@@H]1O2 AMHIJMKZPBMCKI-PKLGAXGESA-N 0.000 description 3
- 230000001934 delay Effects 0.000 description 3
- 230000000694 effects Effects 0.000 description 3
- 238000005192 partition Methods 0.000 description 3
- 230000037361 pathway Effects 0.000 description 3
- 235000002595 Solanum tuberosum Nutrition 0.000 description 2
- 244000061456 Solanum tuberosum Species 0.000 description 2
- 230000003190 augmentative effect Effects 0.000 description 2
- 230000008901 benefit Effects 0.000 description 2
- 230000008859 change Effects 0.000 description 2
- 238000001514 detection method Methods 0.000 description 2
- 235000003642 hunger Nutrition 0.000 description 2
- 230000000977 initiatory effect Effects 0.000 description 2
- 230000003993 interaction Effects 0.000 description 2
- 230000000644 propagated effect Effects 0.000 description 2
- 230000037351 starvation Effects 0.000 description 2
- 230000007704 transition Effects 0.000 description 2
- 238000013519 translation Methods 0.000 description 2
- 101100339496 Caenorhabditis elegans hop-1 gene Proteins 0.000 description 1
- 230000006399 behavior Effects 0.000 description 1
- 230000015556 catabolic process Effects 0.000 description 1
- 230000001186 cumulative effect Effects 0.000 description 1
- 238000006731 degradation reaction Methods 0.000 description 1
- 230000002708 enhancing effect Effects 0.000 description 1
- 238000011156 evaluation Methods 0.000 description 1
- 239000004744 fabric Substances 0.000 description 1
- 239000000796 flavoring agent Substances 0.000 description 1
- 235000019634 flavors Nutrition 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 238000005259 measurement Methods 0.000 description 1
- 238000012986 modification Methods 0.000 description 1
- 230000004048 modification Effects 0.000 description 1
- 230000002093 peripheral effect Effects 0.000 description 1
- 229920006395 saturated elastomer Polymers 0.000 description 1
- 238000000638 solvent extraction Methods 0.000 description 1
- 230000009897 systematic effect Effects 0.000 description 1
- 230000001052 transient effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/02—Addressing or allocation; Relocation
- G06F12/08—Addressing or allocation; Relocation in hierarchically structured memory systems, e.g. virtual memory systems
- G06F12/0802—Addressing of a memory level in which the access to the desired data or data block requires associative addressing means, e.g. caches
- G06F12/0806—Multiuser, multiprocessor or multiprocessing cache systems
- G06F12/0815—Cache consistency protocols
- G06F12/0817—Cache consistency protocols using directory methods
- G06F12/0828—Cache consistency protocols using directory methods with concurrent directory accessing, i.e. handling multiple concurrent coherency transactions
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/02—Addressing or allocation; Relocation
- G06F12/08—Addressing or allocation; Relocation in hierarchically structured memory systems, e.g. virtual memory systems
- G06F12/0802—Addressing of a memory level in which the access to the desired data or data block requires associative addressing means, e.g. caches
- G06F12/0806—Multiuser, multiprocessor or multiprocessing cache systems
- G06F12/0813—Multiuser, multiprocessor or multiprocessing cache systems with a network or matrix configuration
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/02—Addressing or allocation; Relocation
- G06F12/08—Addressing or allocation; Relocation in hierarchically structured memory systems, e.g. virtual memory systems
- G06F12/0802—Addressing of a memory level in which the access to the desired data or data block requires associative addressing means, e.g. caches
- G06F12/0806—Multiuser, multiprocessor or multiprocessing cache systems
- G06F12/0815—Cache consistency protocols
- G06F12/0817—Cache consistency protocols using directory methods
Definitions
- This invention relates in general to the field of computer architecture and more specifically to distributed shared-memory multi-processing systems.
- symmetric multi-processing computers allow for high performance application processing.
- Typical symmetric multi-processing computer systems include a number of processors coupled together by a bus.
- One characteristic of a symmetric multi-processing system is that memory space is shared among all of the processors.
- One or more operating systems are stored in memory and control the distribution of processes or threads among the various processors.
- FIG. 1A a typical prior art multi-processor system 2 including eight processors coupled together via a common interconnect bus is shown.
- each of the processors 3a-3h communicate with the other processors and with a shared memory 4 via a shared interconnect bus 5.
- the symmetric multi-processing arrangement of FIG. 1A has been adequate for multi-processors built to date.
- a common shared interconnect is not capable of sufficiently exercising the full performance potential of the coupled microprocessors. Because the only communication link between the processors and memory is the shared bus, the bus may rapidly become saturated with requests from the processors, thereby increasing delays as each processor attempts to gain access to the system bus. Therefore, although the processors may be able to operate at enhanced speeds, the limiting factor in teens of performance is the available bandwidth of the system bus.
- Bisection bandwidth is a key factor in the performance of SMP systems. Since bandwidth may not be uniform between pairs or subsets of nodes in the SMP system, the industry uses a "bisection bandwidth" measurement for determining the communication bandwidth of an SMP system. Bisection bandwidth is determined in the following manner. All possible ways of partitioning the system into two portions of equal compute power (equal number of processors) are ascertained. For each partition, the sustainable bandwidth between the two partitions is determined. The minimum of all of the sustainable bandwidths is the bisection bandwidth of the interconnect. The minimum bandwidth between the two partitions indicates the communication bandwidth sustainable by the multiprocessor system in the presence of worst-case communication patterns. Thus, a large bisection bandwidth is desirable.
- topologies have been used in the prior art to overcome bus saturation problems. These topologies include meshes, touri, hypercubes and enhanced hypercubes.
- a mesh interconnect is shown as system 7 in FIG. 1B.
- the major advantage of the mesh network is its simplicity and ease of wiring.
- Each node is connected to a small number of other neighboring nodes.
- the mesh interconnect has tree significant drawbacks.
- each of the messages may traverse different paths within the mesh, there are no natural ordering points within an SMP system, and therefore the cache coherence protocols required to implement the mesh topology are often quite complex.
- the torus, hypercube, and enhanced hypercube topologies are all topologies wherein the nodes are interconnected in various complex arrangements, for example in a torus arrangement or a cube arrangement.
- the torus, hypercube and enhanced hypercube interconnects are more complex than the mesh interconnect, but offer better latency and bandwidth than the mesh interconnect.
- the torus, hypercube and enhanced hypercube topologies do not provide natural ordering points, and thus a complex cache coherence protocol must be implemented for each of those systems.
- processors In shared-memory multiprocessor systems, processors typically employ private caches to store data determined likely to be accessed in the future. Since processors may read data from their private cache and may update data in the private cache without writing it back to memory, a mechanism is needed to ensure that the private coaches of each of the processors are kept consistent, or coherent. The mechanism that is used to ensure coherency of data in the SMP system is referred to as the cache coherence protocol.
- Cache coherency protocols may introduce latencies, bottlenecks, inefficiencies or complexity in several ways.
- the latency of load and store operations is often directly affected by the protocol of the design. For example, in some protocols, a store operation is not considered complete until all invalidate messages have made it to their target processors and acknowledgment messages have made it all the way back to the original processor.
- the latency of stores here is much higher than a protocol wherein the original processor does not have to wait for the Invalidates to make it to their destination. Further, the acknowledgments consume a significant fraction of the system bandwidth.
- Bottlenecks are often introduced due to high occupancy of controllers. "Occupancy" is a term of art; it indicates the amount of time a controller is unavailable after it receives a request. In some protocols, when a directly controller receives a request corresponding to a memory location, it becomes unavailable for other requests to the same memory location until certain acknowledgments corresponding to the former command arrive at the directory. If the controller receives conflicting requests at a higher than average rate, it becomes a bottleneck.
- the present invention is advantageously employed in a cache coherent shared memory system where multiple nodes are coupled together via a switch.
- a cache coherency protocol is provided wherein memory references are apportioned into a series of different transactions, with each transaction representing a transition, or ⁇ hop ⁇ between processors, memory or serialization points. Each transaction includes a message. Each of the transactions in the series therefore represents a stage of execution of the memory reference.
- a memory reference may perform a number of hops.
- the first hop may be from a processor issuing a memory request to a serialization point that includes status information for the memory reference, for example indicating the processor at which data associated with the memory reference is stored.
- the second hop may be from the serialization point to the processor storing the data
- the third hop may return the data from the processor storing the data to the processor requesting the data.
- deadlock can occur due to cycles of dependencies between messages.
- a set of one or more messages may constitute a dependence cycle when each depends on the next to make progress and the last one depends on the first. Thus, none can make progress and deadlock results.
- Two types of dependencies are considered. The first type, resource dependence, is encountered when a message cannot make progress unless a second message frees up a resource for the former.
- the second type, flow dependence, is encountered when the cache coherence protocol requires a message to wait until a second message has made progress and reaches its destination. Cycles of resource dependencies are eliminated by assigning messages associated with each of the different hops to different channels. A priority level is assigned to the channels, where the priority increases as the associated transaction advances in execution.
- a data coherency protocol is established that uses channel communication to maintain data accuracy and eliminate the potential of deadlock by ensuring that messages in lower priority channels do not block messages in higher priority channels. Accordingly, with such a protocol, no acknowledgments or retries need be introduced to the system, and therefore the overall performance of the multi-processor system is improved. Further, the resulting deterministic behavior leads to a significantly simpler cache coherence protocol as compared to prior art solutions.
- a method for avoiding deadlock in cache coherency protocols in a computer system includes a plurality of nodes, where each of the nodes includes a portion of a shared memory of the computer system and wherein the shared memory is apportioned into a plurality of blocks.
- Each of the nodes further includes a plurality of elements including at least one processor with each of the at least one processors capable of performing a plurality of memory reference operations.
- Each of the plurality of memory reference operations executes in a series of steps, wherein each of the series of steps forwards at least one message between a pair of the elements in the computer system.
- the method includes the steps of providing a plurality of channels, each of the channels for transmitting messages associated with the corresponding step of the memory reference operation, wherein the channels are prioritized such that steps that are relatively later in the memory reference operation are transmitted on higher priority charmels and controlling the flow of messages on the plurality of channels such that the transmission of messages on higher priority channels is not dependent upon the transmission of messages on relatively lower priority channels.
- a method for maintaining cache coherency in a computer system includes a number of nodes with each of the nodes performing a plurality of operations for accessing a shared memory distributed among the nodes. Each of the operations comprises a plurality of steps. Each of the nodes includes a directory storing ownership information for a portion of the shared memory residing at the node.
- the method includes the steps of providing, at each of the nodes, a plurality of channels corresponding to the plurality of steps for executing at least one of the plurality of operations, wherein the channels are prioritized in response to an order of execution of the plurality of steps, issuing, at each node, the plurality of operations, each of the plurality of steps of cach of the plurality of operations including a message, where the messages of each one of the plurality of steps are provided on different ones of the plurality of chanmels and selecting one of the plurality of messages for forwarding to the shared memory such that the transmission of messages in higher priority channels is not dependent upon the transmission of messages on lower priority channels.
- a memory control architecture for use in a computer system comprising a number of nodes.
- Each of the nodes performs a plurality of operations for accessing a memory distributed among the nodes.
- Each of the plurality of operations includes a plurality of transactions, with each of the plurality of transactions forwarding a message.
- the memory control architecture includes a plurality of data paths, each one of the data paths corresponding to one of the plurality of transactions performed during execution of at least one of the plurality of operations, wherein the data paths are assigned a priority according to a relative order of execution of an associated transaction, each of the data paths for carrying the message associated with the corresponding transaction.
- the memory control architecture includes a serialization point, coupled to each of the plurality of nodes and to the plurality of data paths, each of the transactions from each of the data paths being received at the serialization point and forwarded from the serialization point in a selected order, the order selected such that transactions on higher priority channels arc not blocked by transactions on lower priority channels.
- FIGS. 1A-1B are block diagrams of two prior art symmetric multi-processor computer systems
- FIG. 2 is a block diagram of one embodiment of a multi-processor computer node of one embodiment of the invention comprising a switch;
- FIG. 3 is a block diagram illustrating the data path of the switch of FIG. 1 comprising a number of Simultaneous Insertion Buffers;
- FIG. 4A is a block diagram of one embodiment of one of the Simultaneous Insertion Buffers of FIG. 3;
- FIG. 4B is a block diagram of one implementation of logic for controlling one of the Simultaneous Input Buffers of FIG. 4;
- FIGS. 5A and 5B are a block diagram of a second embodiment of one of the Simultaneous Insertion Buffers of FIG. 3;
- FIG. 6 is a block diagram of the multi-processor computer node of FIG. 2, augmented for connection into a larger network of similar nodes;
- FIG. 7A is one embodiment of an SMP system implemented using multiple nodes similar to the multi-processor node of FIG. 6;
- FIG. 7B is another embodiment of an SMP system implemented using multiple nodes similar to the multi-processor node of FIG. 6;
- FIG. 8 is a block diagram of a global port of FIG. 6;
- FIG. 9 illustrates an entry in a directory of the multi-processor node of FIG. 6;
- FIG. 10 illustrates a Transaction Tracking Table (TTT) for use in the global port of FIG. 8;
- FIG. 11 is a block diagram of a hierarclicl switch for coupling the multiple nodes in FIG. 7A;
- FIG. 12A is a block diagram of one embodiment of interconnect logic for the hierarchical switch that eliminates deadlock
- FIG. 12B is a flow diagram of the operation of the interconnect logic of FIG. 12A;
- FIG. 13 is a flow diagram of the method used in the interconnect logic of FIG. 12A to assert flow control to stop data being transmitted from one of the multi-processing nodes;
- FIG. 14 is a timing diagram illustrating the transfer of address and data packets on the busses to and from the hierarchical switch
- FIG. 15 is a block diagram of one embodiment of buffer logic for maintaining order at the hierarchical switch
- FIG. 16 is a block diagram of another embodiment of buffer logic for maintaining order for the hierarchical switch.
- FIG. 17 is a flow diagram illustrating one method of operating the buffer logic of FIG. 16;
- FIG. 18 is a block diagram of another embodiment of buffer logic for maintaining order at the hierarchical switch.
- FIG. 19 is a table illustrating the translation of processor instructions to network instructions for use in the SMP of FIGS. 7A or 7B;
- FIGS. 20A-20J illustrate a number of communication flows for transferring packets between nodes in the SMP of FIGS. 7A or 7B;
- FIG. 21 is a block diagram illustrating the layout of a memory module for use in the multi-processor system of FIGS. 2 or 6;
- FIG. 22 is a timing diagram illustrating the control logic used by the memory module of FIG. 21 for delayed write operations
- FIG. 23 is a flow diagram illustrating the use of discrete transactions that are mapped to channels for maintaining cache coherency in one embodiment of the invention.
- FIG. 24 is a block diagram illustrating one implementation of a shared queue structure for handling virtual channels in the SMP of FIGS. 7A or 7B;
- FIG. 25 is a block diagram illustrating an implementation of individual channel buffering in the nodes and hierarchical switches of the SMP of FIGS. 7A or 7B;
- FIG. 26 is a block diagram for illustrating the problems that may arise if some amount of ordering between virtual channels in not maintained
- FIGS. 27A-27C are block diagrams illustrating the flow and ordering constraints on the Q1 channel for providing coherent communication in the SMP of FIGS. 7A or 7B;
- FIGS. 28A and 28B are a block diagram illustrating the ambiguity problems that arise because of the coarse vector presence bits of the directory entries of the SMP of FIGS. 7A and 7B;
- FIG. 29 is a block diagram illustrating the method used to prevent data ambiguity from arising as a result of the problem described in FIG. 28;
- FIG. 30 is a block diagram for illustrating a coherency issue that arises from packets on different channels being received out of sequence
- FIG. 31 is a block diagram illustrating the use of Fill Markers for preventing the coherency problem described in FIG. 29;
- FIG. 32 is an entry in the TTT reflecting the status of an instruction during the flow described with regard to FIG. 31;
- FIGS. 33A-33B are block diagrams illustrating the operation of Change to Dirty commands in the SMP system
- FIG. 34 is a block diagram illustrating the use of Shadow commands for remedying the problem described with regard to FIG. 33;
- FIG. 35 is an entry in the TTT reflecting the status of an instruction during the flow described with regard to FIG. 34.
- FIG. 36 is a flow diagram illustrating permissible sequential ordering of instructions in the example described in FIG. 35.
- a hierarchical Symmetric Multi-Processing (SMP) system includes a number of SMP nodes coupled together via a high performance switch.
- SMP nodes act as a building block in the SMP system.
- the components and operation of one SMP node building block is first described, followed by a description of the operation of the SMP system and subsequently a description of a cache coherence protocol that is used to maintain memory coherency in the large SMP system.
- a multi-processor node 10 includes four processor modules 12a, 12b, 12c, and 12d.
- Each processor module comprises a central processing unit (CPU).
- CPU central processing unit
- Alpha® 21264 processor chips manufactured by Digital Equipment Corporation® are used, although other types of processor chips capable of supporting the below described coherency protocol may alternatively be used.
- Multi-processor node 10 includes a memory 13, which may include a number of memory modules 13a-13d.
- the memory may provide 32 GBytes of storage capacity, with each of the 4 memory modules storing 8 Gigabytes.
- Each of the memory modules is apportioned into a number of blocks of memory, where each block may include, for example 64 bytes of data. Data is generally retrieved from memory in blocks.
- multi-processing node 10 includes an I/O processor (IOP) module 14 for controlling transfer of data between external devices (not shown) and the multi-processor node 10 via a coupled I/O bus 14a.
- IOP I/O processor
- the I/O bus may operate according to the Peripheral Computer Interconnect (PCI) protocol.
- the IOP 14 includes an IOP cache 14c and an IOP tag store 14b.
- the IOP cache 14c provides temporary storage for data from memory 13 that is transferred to external devices on the PCI bus 14a.
- the IOP tag store 14b is a 64 entry tag store for storing coherency information for data being moved between external devices, processors and memory.
- the coherency of data stored in the memory 13 of the multi-processor node is maintained by means of a Duplicate Tag store (DTAG) 20.
- the DTAG 20 is shared by all of the processors 12a-12d, and is apportioned into 4 banks, where each bank is dedicated to storing status information corresponding to data used by an associated one of the processors.
- the DTAG, Memory and IOP are coupled to a logical bus referred to as the Arb bus 17.
- Memory block requests issued by the processor are routed via the local switch 15 to the Arb bus 17.
- the DTAG 20 and IOP 14 look up the state of the block in the processors' and IOP's caches and atomically update their state for the memory block.
- the Arb bus 17 acts as a serialization point for all memory references. The order in which memory request appear on the Arb bus is the order in which processors perceive the results of the requests.
- the processor modules 12a-12d, memory modules 13a-13d and IOP module 14 are coupled together via a local, 9 port switch 15.
- Each of the interfacing modules 12a-12d, 13a-13d and 14 are connected to the local switch by means of a like number of bi-directional, clock forwarded data links 16a-16i.
- each of the data links forwards 64 bits of data and 8 bits of error correcting code (ECC) one each edge of a system clock operating at a rate of 150 MHZ.
- ECC error correcting code
- the data bandwidth of each of the data links 16a-16i is 2.4 Gigabytes/sec.
- Local switch 15 includes an Quad Switch Address control chip (QSA chip) 18 and a Quad Switch data slice chip (QSD chip) 19.
- QSA chip 18 includes an arbiter (QS Arb) 11 for controlling address paths between the processor modules, IOP, and memory.
- QSA chip 18 provides control to the QSD chip 19 to control the flow of data tlirough the local switch 15 as described below.
- QSD chip 19 provides a switch interconnect for all data paths between the processor modules, memory modules and IOP. Altough not shown in FIG. 2, is will be described below, if the multi-processor node 10 were coupled to other multi-processor nodes via a global port, the QSD and OSA would additionally provide a switch interconnect for the global port.
- Each of the processors may request data from one of the available resources, such as the memory devices 13a-13d, other processors 12a-12d, IOP 14 or alternatively resources in other multi-processor nodes via the global port.
- the local switch 15 should be able to accommodate simultaneous input from a variety of resources while maintaining the high bus bandwidth of 2.4 GBytes.
- the local switch is able to handle mulitple concurrent transactions. Since each transaction typically uses multiple resources (such as memory banks, datapaths, queues), the control functions of the local switch can be very complex. For instance, a transaction may require a memory banlc to be available in stage 0 of the transaction, the datapath from memory bank to processor port be available in stage 1, and the datapath from processor port to processor be available in stage 2.
- the local switch arbiter (QSA Arb 11 in the QSA 18) arbitrates among requests in such a manner that once a transaction is initiated, resources required by a transaction in each stage are available as required.
- the arbiter guarantees that all requests and processors get fair access to the resources by ensuring that particular requests do not fail to win arbitration for a long time (potentially indefinitely) while others make progress. For instance, consider a transaction T that requires three resources A, B, and C. Transaction T may not win arbitration until all three resources are guaranteed to be available in the appropriate stages of the transaction. If the artiber bases its decision only on the availability of resources, then it is possible that T may not succeed for a long time while other transactions which consume one of A, B, or C (along with other resources D,E, etc). continue to win arbitration.
- the QSA arb 11 arbitrates for only one resource (the memory bank) before scheduling a particular transaction.
- a second resource which is a queue leading up to the processors, does not need to be checked for availability at the time of arbitration by the QSA arb 11 for the first resource. This is because the architecture of the QSD guarantees that datapaths and queue slots leading up to the queue are always available.
- the fair arbitration for resources may be provided without much complexity in the QSA arb 11.
- the QSD is able to simultaneously receive input from all of the sources (processors, memory, IOP and global port) without requiring any upfront arbitration for the buffers leading up to corresponding destinations. All sources of data may then independently forward data to the switch without having to arbitrate for access to the datapath or queue slots in the switch because the QSD includes a number of simultaneous insertion buffers capable of receiving, substantially simultaneously, data from all of the sources. Two embodiments of simultaneous insertion buffers are described below.
- the processor 12a-12d, IOP 14 and memory devices 13a-13d in the multi-processing node each serve as resources for handling requests from the processors and IOP in the multi-processing node.
- Data is transferred between each of the resource elements and the requesting elements in the form of packets.
- Each packet comprises 512 bits of data and 64 bits of ECC.
- each of the data links carries 64 bits of data and 8 bits of ECC on each edge of a 150 MHZ clock.
- there are 8 data transfer cycles per packet Internal to the QSD, however, data is gathered only on one edge of the clock.
- each packet comprises 512 bits of data and 64 bits of ECC
- there are 4 data transfer cycles for each packet with 128 bits of data and 16 bits of ECC being transferred from a processor, IOP or memory device to the QSD each QSD clocking cycle.
- the QSD 19 is shown in more detail to include five Simultaneous Insertion Buffers (SIBs) 25a-25e.
- SIB is dedicated to one of the requester elements, i.e., processors 12a-12d or the IOP.
- Each SIB controls the data path for transfer of packets between its associated requester element and the other resource elements in the node; i.e., processors 12a-12d, memory 13a-13d, IOP 14 and advantageously a global port.
- the global port acts as an interconnect to other multi-processor nodes and is described in detail below.
- the SIBs allow for the simultaneous receipt of packets by the requester from any of the resources coupled to the switch without requiring arbitration between the requesters for access to the switch.
- the QSA Arb 11 is coupled to provide control to the switch 19.
- a main arbiter 27 included in QSA Arb 11 is a main arbiter 27.
- the main arbiter 27 manages the data movement between the resources (the IOP, processors 12a-12d and memory 13a-13d) and the switch 19.
- Each of the processors 12a-12d and IOP 14 issues requests for access to one of the resources on lines 28a-28c that are forwarded to the main arbiter 27.
- the main arbiter in turn forwards these requests to the associated resources when each resource is able to receive a request.
- no arbitration for the switch 19 is required because each of the SIBs are capable of receiving input from all of the inputs substantially simultaneously, i.e., within the same data cycle.
- each of the arbiters 23a-23d is used to manage a datapath between an associated one of the processors 12a-12d and their corresponding SIB 25b-25c, respectively.
- a similar arbitrer (not shown) is included in the IOP 14 for managing the datapath between IOP 14 and SIB 25a. As each processor is able to receive data from their associated SIB, the associated arbiter forwards the data on the coupled datapath.
- the arbitration pathway between a requester and a resource may be broken up into two distinct sections; a first arbitration section where the main arbiter 27 arbitrates for a resource in response to a request from a processor independent of the availability of the requesting processor to receive data from the coupled resource, and a second arbitration section where the arbiter associated with the processor arbitrates for access to the processor for forwarding data from the switch.
- FIG. 4A a more detailed diagram of one embodiment of the SIB 25a is shown to include an input arbiter 36 coupled to provide mux select signals ⁇ 31:0> on line 36a to eight coupled multiplexers 34a-34h, where four of the mux select signals are forwarded to each of the eight multiplexers to select one of nine inputs at each multiplexer.
- All of the SIBs 25a-25d are similarly architected, and thus only one is described in detail.
- One of the ten resources is a requestor device that receives output from the SIB, while the other nine resources provide input to the SIB.
- each of the multiplexers 34a-34h receives input from nine resources coupled to the SIB.
- the inputs from tlhee of the coupled processors are received on lines Px, Py, and Pz.
- Another input, from either the fourth processor (when the SIB is associated with the IOP device) or from the IOP device (when the SIB is associated with one of the processors) is received on line PW/IOP.
- the inputs from memory banks 13a-13d are received on lines mem0, mem1, mem2 and mem3, respectively, and input from the global polt is received on line global port.
- Each output from each of the multiplexers 34a-34h is coupled to one of eight banks of a buffer 32.
- Each bank has eight entries, with each entry storing 128 bits of data and 16 bits of ECC.
- each packet of data that is received by the SIB is written to four different banks in the same row of the buffer 32.
- the input arbiter 36 maintains status bits for indicating the banks of the buffer that are available for storing data.
- the input arbiter 36 selects one of the possible nine resource inputs at each multiplexer 34a-34h for forwarding the cycle of packet data to the associated bank 32a-32h depending upon the availability status of the banks.
- the input arbiter also provides bypass data on line 36b to a multiplexer 30.
- the status bits in the input arbiter indicate that all of the banks 32a-32h are empty, one of the nine resource inputs may be bypassed directly to the associated requestor via the input arbiter 36.
- Each of the banks 32a-32h are coupled to multiplexer 30.
- Multiplexer 30 is controlled by an output arbiter 38.
- the output arbiter forwards one of the eight entries from the banks 32a-32h to the requester.
- the output arbiter forwards the bypass data on line 36b to the requester if none of the banks have data pending transfer and data is available on line 36b from the input arbiter.
- one of the eight banks is selected for storing the first 128 bits of packet data.
- the bank adjacent to the bank that was used to perform the previous write is selected for writing the next 128 of packet data. For example, if bank 32a were selected as an available bank for writing a first cycle of packet data from source mem0, the second cycle of packet data would be written to bank 32b, the third to bank 32c, and the fourth to bank 32d.
- the selection of which bank to use for writing the subsequent cycles of packet data is thus performed on a rotating basis, starting at a bank selected by the input arbiter and continuing at an adjacent bank for each successive packet write.
- the received packet is spread across four banks in a common row of the buffer 32.
- each buffer in a SIB operates under the First-In, First-Out (FIFO) protocol. Because two portions of packets may be received simultaneously, an order is selected for them to be ⁇ read ⁇ into the switch. Since logic in the requestor that arbitrates for the resource does not communicate with the SIB and does not communicate with other requestors for arbitrating for the resource, a standard rule is followed to ensure data integrity. For example, a rule such as ⁇ data from a lower number input resource is always written to the switch before data from a higher number input resource ⁇ may be followed, where the resources are assigned a fixed priority number.
- FIFO First-In, First-Out
- the use of eight banks has been described because eight corresponds to the number of outstanding memory requests that a requestor can have at any given instant of time. If, however, the design constraints require that fewer banks be provided, the design could easily be modified by one of skill in the art to allow for multiple chunks of data to be written to different locations in a common bank simultaneously using interleaving or a similar technique. Therefore, the present invention is not limited to the particular embodiment illustrated in FIG. 4A.
- FIG. 4B An example embodiment of an input arbiter 36 for controlling the inputs to the SIB is shown in FIG. 4B.
- an indication signal such as ⁇ input1 ⁇
- the latch chain 40 is used as a counter mechanism. For purposes of this example, assume that the packet data is received in four successive data transfer cycles. During the four data transfer cycles, the input1 signal propagates through the latch chain. Coupled to the latch chain is an OR gate 46. As the input1 value propagates through the latch chain 40, the output of the OR gate 46 is asserted.
- the output of the OR gate 46 provides a shift signal to a shift register 48.
- the shift register comprises 8 bit locations; one for each of the banks of the SIB.
- the shift register 48 is loaded, upon the initial receipt of the input1 signal sample, with a bit vector from bank select logic 44.
- the bit vector received from bank select logic 44 has only one bit set, with the relative location of the bit within the vector indicating the bank at which the write of the packet data is to be initiated.
- Bank select logic 44 thus controls the write destination of the first cycle of packet data.
- the bank select logic 44 receives, as input, an available vector 42, with the relative locations of bits in the available vector indicating the associated buffers that are not able to receive write data.
- the de-multiplexer 49 When the bank select logic provides a bit to the shift register 48, the value of the shift register 48 is forwarded to a de-multiplexer 49.
- the de-multiplexer 49 also receives as input a numerical representation of the input of the multiplexers 34a-34h to which the input1 source is connected. For example, the de-multiplexer 49 receives a ⁇ 1 ⁇ input value, indicating that the input1 resource data would be forwarded through multiplexer 34a using a multiplexer select value of ⁇ 1 ⁇ .
- the ⁇ 1 ⁇ value is propagated to the appropriate location of the Mux SELECT ⁇ 31:0> signal 36a.
- Each de-multiplexer for each input resource drives all of the Mux SELECT signals, with their outputs being ORed before the signals drive the multiplexers 34a-34h.
- a straightforward and efficient switching mechanism is provided that is capable of ensuring that multiple, simultaneously received inputs reach their destination requestors.
- the source may rely on the fact that the resource is always going to be able to obtain access to the switch buffer 32. Allowing the source arbiters to operate independently of each other for managing a resource provides a mechanism that ensures fair arbitration with minimal complexity.
- the SIB is capable of storing data for the maximum number of outstanding reads of the requestor, even if the data is received simultaneously from all of the resources there is no need for arbitration among the resources for the buffer 32, and the overall complexity of the resource logic is reduced.
- SIB Simultaneous Insertion Buffer
- the SIB 61 includes nine multiplexers 60a-60i, eight of which are coupled to a respective one of eight buffers 62a-62h.
- the ninth multiplexer 60i is used to provide a bypass path as described below.
- the multiplexers 60a-60i each receive nine inputs including four inputs from the coupled memory devices mem0-mem3, one input from the global port, and three inputs from the coupled processors on lines Px, Py and Pz, and one input from either the IOP (if the device associated with the SIB is a processor) or from another processor (if the device associated with the SIB is the IOP) on line PW/IOP.
- Each of the buffers 62a-62h include four 128 bit entries. Consequently, each of the input buffers stores one 512 bit packet of information that is received in four 128 bit portions in successive cycles at the SIB. Coupled to each of the buffers is a four to one multiplexer 64a-64h respectively. The multiplexers 64a-64h are used to select one of the four entries of the associated buffers for forwarding through a multiplexer 66 to the output of the SIB.
- each requestor may have at most eight outstanding read references to different resources at any given instant in time.
- eight buffers have been shown in FIG. 5 it is not a limit of the invention. Rather the number of buffers selected depends upon buffering characteristics of the associated processor or IOP device.
- the input arbiter 67 selects one of the input lines at each of the multiplexers for forwarding the packet of data to a free buffer.
- the same buffer is selected for the duration of a packet write from a given resource such that all portions of a packet are maintained in a single buffer.
- Once at least one portion of the packet has been written to the buffer it may be provided to the multiplexer 66 for forwarding to the associated requestor when the requestor is ready.
- a bypass path may be used by forwarding packet data directly through multiplexer 60i to the output via the multiplexer 66.
- the SIB device 61 is able to receive data from each of the coupled resources substantially simultaneously (i.e., in the same data cycle).
- no arbitration is required between the requestors for access to the SIB.
- the availability of the of the local switch is guaranteed when the resource is ready to use it.
- an arbitration scheme is provided that is inherently fair, because no request to a resource is blocked by other requests to other resources as a result of arbitrating for the switch. Accordingly, a fair and relatively simple structure is provided that allows for maximum bus bandwidth to be maintained while minimizing arbitration complexity.
- the multi-processor node 10 has been provided that makes optimum use of processing resources by implementing a local switch that uses a simultaneous insertion buffer to support a high bus bandwidth.
- a central ordering point is provided that facilitates maintenance of coherency of the memory of the multi-processor 10. While the possibility exists for increasing the processing power by increasing the number of processor modules coupled to the local switch, the four processors/local switch arrangement of FIG. 2 provides a system having high performance with low latency and low cost.
- the number of processors that may be included in a monolithic multi-processor node is limited by two factors. First, the number of processor that can be coupled together via a local switch is limited by the number of pins available on chips constituting the local switch. Second, the data bandwidth supported by a single, monolithic, switch is limited. Hence, increasing the number of coupled processors beyond some point does not yield any performance gains.
- a large symmetric multi-processor may be provided by interconnecting a plurality of the multi-processing nodes via a hierarchical switch.
- eight of the multi-processor nodes may be coupled via the hierarchical switch to provide a symmetric multi-processing (SMP) system including tthirty-two processor modules, eight IOP devices, and 256 Gigabytes of memory.
- SMP symmetric multi-processing
- a SMP that includes at least two multi-processor nodes will be referred to as a large SMP.
- the multi-processor is augmented to include a global port interface.
- FIG. 6 a modified multi-processor node 100 is shown. Similar to the multi-processor node of FIG. 2, a local switch 110 couples four processor modules, four memory modules and an IOP module. Like elements in FIGS. 2 and 6 have the same reference numerals.
- the local switch 110 of the multi-processor node 100 is a 10 port switch, including 9 ports 116a-116i constructed similarly to ports 16a-16i of FIG. 2.
- An additional port 116j provides a full-duplex, clock forwarded data link to a global port 120 via global link 132.
- a large SMP system 150 is shown to include eight nodes 100a-100h coupled together via an 8 ⁇ 8 hierarchical switch 155. Each of the nodes 100a-100h is substantially identical to the node 100 shown in FIG. 6.
- Each of the nodes 100a-100h is coupled to the hierarchical switch 155 by a respective full-duplex clock forwarded data link 170a-170h.
- the data links 170a-170h are operated at a clock speed of 150 Mhz, and thus support 2.4 GBytes/sec of data bandwidth for transferring data to and from switch 155. This provides the switch with a maximum of 38.4 GBytes/sec of raw interconnect data bandwidth, and 19.2 GBytes/scc of bisection data bandwidth.
- the large SMP system is a distributed shared memory system, wherein each of the multi-processing nodes 100a-100h includes an addressable portion of either the overall system memory or a sub-divided portion of physical memory. In one embodiment of the invention, there are 2 43 physical address locations in the overall system memory.
- One embodiment of the SMP multi-processing system 100 supports 2 address formats, referred to as "Large Format” and "Small Format.” Large format maps the 43 bit physical address upon which the processors in each node operate directly into a 43 bit physical address for use in the multi-processor system. Using large format addressing, bits ⁇ 38:36> of the physical memory address may be used to as a node identification number.
- Address bits 38:36 directly decode the home node of a memory space address, while the inverse of address bits 38:36 decode the home node of an I/O space address, where ⁇ home ⁇ refers to the physical multi-processor node on which the memory and I/O devices associated with the memory space or I/O space reside.
- Small format addressing mode assumes that no more than 4 nodes exist in the multi-processing system. Small format allows the processors in each node to operate in a 36-bit physically addressed system. In small format, bits 34:33 of the physical address identify the home node number of data or an I/O device.
- the multi-processor system consistently uses the 43 bit physical addresses for specifying data location, where bits 37:36 of the physical address identify the home node number of data or an I/O device. Accordingly, some translation is performed between the small format address issued by the CPU and that which is transmitted over the data lines 13a-13h to the hierarchical switch 155.
- the illustrated arrangement of the multi-proccssing system 150 is capable of providing high bandwidth cache-coherent shared memory between 32 processors.
- Another embodiment of a large SMP according to one embodiment of the invention is provided in FIG. 7B, where two multi-processor nodes 100a and 100b are coupled together without the use of a hierarchical switch. Rather, the two multi-processor nodes are coupled directly by coupling together their global port outputs.
- the result is a multi-processor system with large addressing space and processing power.
- system memory address space and I/O address space are physically distributed in segments among all the nodes 100a-100h.
- Each node in the system includes a portion of the main memory which is accessed using the upper three bits of the memory space physical address.
- each memory or I/O address maps to one and only one memory location or I/O device in only one of the nodes.
- the upper three address bits consequently provide a node number for identifying the ⁇ home ⁇ node the node to which the memory or I/O address maps to.
- Each multi-processor node may access portions of the shared memory stored at their home node, or at other multi-processing nodes.
- a processor accesses (loads or stores to) a shared memory block for which the home node is the processor's own node.
- the reference is referred to as a "local" memory reference.
- the reference is to a block for which the home node is a node other than the processor's own node, the reference is referred to as a "remote" or "global” memory reference.
- the SMP system is said to have a Non Uniform Memory Access (NUMA) architecture. Further, since the system provides coherent caches, the system is called a cache-coherent NUMA architecture.
- NUMA Non Uniform Memory Access
- the cache coherent NUMA architecture disclosed herein includes several aspects that contribute to its high performance and low complexity.
- One aspect of the design is its adherence to and exploitation of order among messages. By guaranteeing that messages flow through the system in accordance with certain ordering properties, latencies of operations can be significantly reduced. For instance, store operations do not require that Invalidate messages be delivered to their ultimate destination processors before the store is considered complete; instead, a store is considered complete as soon as Invalidate messages have been posted to certain ordered queues leading to the destination processors.
- the design eliminates the need for acknowledgment or completion messages. Messages are guaranteed to reach their destinations in the order they are enqueued to certain queues. Hence, the need to return an acknowledgment when the message reaches its destination is eliminated. This enhances the bandwidth of the system.
- event orderings and message orderings are used to achieve "hot potato" operation.
- controllers such as the Directory or DTAG controller are able to retire requests in a single visit. It is not necessary to negatively acknowledge and retry a request due to conflicts with other requests. As a consequence of the "hot potato" operation, fairness and starvation problems are eliminated.
- Virtual channels are a scheme for categorizing messages into "channels", wherein channels may share physical resources (and hence are “virtual") but each channel is flow-controlled independently of the others.
- Virtual channels are used to eliminating deadlock in the cache coherence protocol by eliminating flow-dependence and resource-dependence cycles among messages in the system. This is in contrast to cache coherence protocols in prior art NUMA multiprocessors, which employ mechanisms to detect deadlock and then resolve the deadlock situation by negatively acknowledging selected messages and retrying corresponding commands.
- channels are included in one embodiment of the invention: a Q0 channel for carrying transactions from a requesting processor to the Arb bus on the home node corresponding to the address of the transactions, a Q1 channel, for carrying transactions from the home Arb bus to one or more processors and IOP, and a Q2 channel, for carrying data fill transactions from an owner processor to the requesting processor.
- a Q0Vic channel may be provided for carrying Victim transactions from a processor to memory for writing modified data.
- the Q0Vic channel may be used to carry Q0 transactions that must remain behind Victim transactions.
- a QIO channel is provided to carry IO-space transactions from a processor to an IOP.
- the channels constitute a hierarchy as shown below:
- a large SMP system may be provided by coupling together any number of the SMP nodes of FIG. 2.
- the operation of a large SMP system such as that shown in FIGS. 7A and 7B is provided below and described in three portions.
- the hardware components that may be included in the large SMP are described.
- a cache coherence protocol that provides for coherent data sharing between processors in the SMP is described.
- the implementation and use of virtual channels is described, including support mechanisms that are provided for virtual channels in the hierarchical switch.
- each of the multi-processing nodes for implementing coherent data sharing using channels.
- these elements include the directory 140, the DTAG 20, the IOP tag 14b, the global port 120 and a directory 140.
- a hierarchy of serialization points allows for an order of references to be maintained to facilitate cache coherency protocol.
- the global port 120 allows for the multi-processor node 100 to be coupled directly to one or more similarly constructed multi-processing nodes via an hierarchical switch link 170. Because each node 100 operates as a symmetric multi-processing system, as more nodes are added into the system the available addressing space and processing power is increased.
- the global port includes a transaction tracking table (TTT) 122, a victim cache 124, packet queues 127, 122, 123 and 125 for storing packets being forwarded from the multi-processor node to the hierarchical switch, and a packet queue 121 for storing packets being received from the hierarchical switch.
- TTT transaction tracking table
- the global port 120 communicates with the other logic in the node (in particular the QSA chip) via Arb bus 130 and two dedicated ports on the local switch; i.e., GP Link In 132b and GP link out 132a.
- the TTT keeps track of outstanding transactions at the multi-processor node; i.e., those transactions that have been issued from the node over the global port and are awaiting responses from other multi-processor nodes or from the hierarchical switch. Each time a command is sent to the global port, an entry is created in the TTT. When corresponding responses have been received at the node, the TTT entry is cleared.
- the TTT consists of two parts: the Q0 TTT and the Q1 TTT, where Q0 and Q1 refer to packets traveling on the Q0 and Q1 channels as described above. The particulars of how an entry is allocated to the TTT, and when it is retired are described in further detail below.
- the global port 120 also includes the victim cache 124.
- the victim cache 124 stores victimized data received from each of the processors of the multi-processor node and destined for memory on another multi-processor node.
- Victimized data is data that was stored at a cache location in the processor and modified by that processor. When new data is received at the processor that needs to be stored at the cache location storing the modified data, the modified data is said to be victimized, and is referred to as victim data.
- the victim cache 124 provides temporary storage of victim data from victim data directed from a processor to a memory on a remote multi-processor node.
- a multiplexer 167 is switched to provide data from the victim cache 124 onto the output portion of bus 170.
- Providing a victim cache at the global port allows for the processors to empty their respective victim data buffers without having the individual processors wait out the memory write latency of the global system. Rather, victim writes may be controlled by the global port such that writes are performed whenever there is an available data cycle. There are some control issues surrounding the appropriateness of releasing data from the Victim cache, but these are described below.
- the DTAG and IOP tag are also included in the small SMP system, but are described below in more detail.
- the DTAG 20 stores status information for each of the blocks of data stored in caches of the processors of the multi-processor node.
- the IO Tag 14a stores status information for each of the blocks of data stored in the IOP. While the directory provides coarse information identifying which of the multi-processing nodes stores copies of the data, the DTAG and IO tag may be used to provide a more precise indication as to which of the processors within a multi-processing node stores copies of the data. Therefore, the DTAG and IO tag are used to determine, once a reference has reached a multi-processor node, which processors in the node should be targeted.
- the DTAG 20 and the IOP tag 14b are coupled to the Arb bus 130 for monitoring addresses that reference the memory region coupled to the QSA chip 18.
- the DTAG is apportioned into 4 segments corresponding to the four processors 12a-12d.
- Each of the processors includes a cache (not shown) for temporary storage of a subset of data from the memory 13.
- a tag store Associated with each cache is a tag store, for storing the upper address bits (tags) of blocks of memory stored in the cache of each processor.
- Each segment of the DTAG 20 maintains data that indicates the state of the associated processor's cache tags.
- the IOP tag 14a stores the upper address bits of each of the blocks of data stored in the IOP cache 14c.
- the IOP tag store is similar to the tag stores maintained in each of the processors 12a-12d.
- Each entry in the DTAG 20 and the IOP tag 14a includes a number of status bits.
- DTAG status bits indicate one of the four following states: Invalid, Clean, Dirty -- Not -- Probed, Dirty -- Probed.
- the status bits of an entry in the IOP tag indicate one of the two following states: Valid and Dirty.
- a Valid bit indicates that the data stored in the corresponding entry of the associated cache matches the data stored in memory.
- a Dirty bit indicates that the data stored in the corresponding entry of the associated cache has been modified by the associated processor and does not match the data stored in memory.
- the DTAG 20 and IOP tag 14b are accessed each time a command appears on the Arb bus of a multiprocessor node 100. If a status of Invalid is returned in response to the DTAG access for processor one, then processor one on the node does not store a valid copy of the data associated with tile memory address. If a status of Valid is returned from an access to the IOP tag 14a, then the IOP cache 14c stores a valid copy of the data. If a status of Clean is returned in response to a DTAG access for processor one, this indicates that processor one has an unmodified copy of the data corresponding to the memory address but no attempts have been made by any other processor to read that data.
- a status of Dirty -- Not -- Probed is returned in response to a DTAG, this indicates that the processors one has a modified copy of the data corresponding to the memory address, and that at least one processor has attempted to read the data since the processor last modified the data.
- the directory is used to provide ownership information for each block of memory at the associated multi-processing node (the home node), where a block of memory is generally the smallest amount of data that is transferred between memory and a processor in the SMP system.
- a block is analogous to the size of a packet; i.e., 512 bits (64 bytes) of data.
- the directory indicates which multi-processing nodes store copies of the block of memory data.
- the directory identifies the location of the most recent version of the data.
- victim type commands where a modified block of data is written back to memory, the directory is examined to determine whether the modified block of data is current and should be written to memory. Therefore the directory is the first access point for any reference to a block of memory at the associated multi-processor node, whether the reference is issued by a processor at a remote multi-processor node or a local multi-processor node.
- the directory stores one 14 bit entry for each 64 byte block of data (also referred to hereinafter as a cache line) of memory 13 at the corresponding node 100.
- the directory is physically distributed across the nodes in the system, such that if a memory address resides on node N, the corresponding directory entry also resides on node N.
- a directory entry 140a is shown to include an owner ID field 142 and a node presence field 144.
- the owner ID field comprises six bits of owner information for each 64 byte block.
- the owner ID specifies the current owner of the block, where the current owner is either one of the 32 processors in the system, one of the eight I/O processors in the system, or memory.
- the eight bits of node presence information indicate which of the eight nodes in the system have acquired a current version of the cache line.
- the node presence bit is a coarse vector, where one bit represents the cumulative state of four processors at the same node. In the case of shared data, more than one node presence bit may be set if more than one node has at least one processor storing the information.
- the state information from the DTAG is preferable used since it is retrieved much faster. For example, if the owner processor of a memory address is located at the home node for the address, the DTAG may be used to supply the owner ID.
- the directory 140 is the focal point for all coherence decisions, and as such performs a number of functions.
- the directory identifies the owner of a block of memory data.
- the owner may either be a processor or memory.
- the owner information from the directory is used by read type commands (e.g., Read, Read-Modify) to determine the source of the most recent version of the data block.
- the owner information is also used for determining whether victimized data should be written back to memory as will be described in more detail below.
- the directory is used to resolve Clean-to-Dirty and Shared-to-Dirty commands from the processor.
- a Clean-to-Dirty command is issued by a processor when it wants to modify a cache line currently in Clean state in its cache.
- a Shared-to-Dirty commands is issued when it wants to modify a cache line in Dirty-Shared state.
- the commands are routed to the home Arb bus, wherein the Directory determines whether the processor has an up-to-date version of the cache line. If so, the command succeeds and the processor is allowed to modify the cache line. Otherwise, the command fails and the processor must first acquire a up-to-date version of the cache line.
- the presence bits of the directory identify the multi-processing node with copies of each data block when store type commands are issued. Store commands indicate that the contents of the cache line are going to be updated.
- the nodes with their presence bit are used to identify those multi-processing nodes with copes of the cache line at that node so that the cache lines at each of the nodes can be invalidated.
- the directory and the DTAG operate in conjunction to provide status information for each of the data block in the memory of the local multi-processor and each of the data blocks stored in the caches of local processors.
- the directory at the home node provides coarse information about the status of copies of a cache block.
- Invalidate commands go to those nodes identified by the directory, where the DTAG is accessed to further refine the copy information.
- the DTAG at those nodes indicates which processors at the respective nodes store copies of the line in their cache.
- the TTT The TTT:
- the TTT is used to keep track of transactions outstanding from a multi-processor node; i.e., references awaiting responses from another multi-processing node or the hierarchical switch. Information on outstanding transactions is used by the cache coherence protocol in the processing of subsequent commands to related memory addresses.
- one embodiment of the TTT 122 is shown to include an address field 152, a command field 154, a commander ID field 156, and a number of status bits 158 including bits 158a-158c.
- the address field 152 stores the address of the cache line for a transaction that is currently in flight, while the command field stores the command associated with the cache line for the transaction currently in flight.
- the commander ID field 156 stores the processor number of the processor that initiated the command stored in the command field.
- the status bits 158 reflect the status of the command as it is in flight. Alternatively, the status bits 158 may be used to reflect various properties of the command that is in flight.
- a Fill status bit 158a is updated when a Fill data response is received in response to a Read-type command.
- a Shadow status bit 158b is set if the command that is issued over the global port is a Shadow-type command (described in more detail below).
- the ACK status bit 158c is set if a message expecting an acknowledge type response has received the response. If the response arrives, the bit is cleared. Note that not all of the status bits that may be included in the TITT have been shown. Rather, those status bits that will have relevance to later description have been included. In addition it is envisioned that other status bits may alternatively be provided as deemed necessary to maintain memory coherency, and thus the present invention should not be limited to any particular assignment of bits in the TTT.
- cache coherency Each of these components interfaces with the global port to provide coherent communication between the multi-processor nodes coupled to the hierarchical switch 155.
- serialization point at each multi-processing node is the arb bus 130. All Q0 references, whether issued by a local processor or a remote processor, are forwarded to the directory 140 and DTAG 20 on the arb bus 130 by the QSA. Once the references have accessed the directory and/or the DTAG, resulting Q1 channel commands are output in a strict order on the Arb bus, where the order is the serialization order of the references.
- the hierarchical switch 155 provides a second serialization point in the SMP system.
- the hierarchical switch conforms to certain ordering rules that ensure that the coherency introduced at the first serialization point is maintained in the large SMP system.
- FIG. 11 a block diagram of the hierarchical switch 155 is shown including eight input ports 155i0-155i7 and eight output ports 155o0-155o7.
- Input ports 155o0-155i7 of the hierarchical switch 155 receive packets from the global ports of each of the coupled multi-processing nodes.
- Output ports 155o0-155o7 of the hierarchical switch forward packets to the global ports of each of the coupled multi-processing nodes.
- each input port is a buffer 160a-160h for buffering received packets.
- buffers may alternatively be shared among any number of input ports.
- each of the packets may be associated with any one of five channels.
- portions of each input buffer 160a-160h are dedicated for storing packets of certain channels. Accordingly, flow control from the global ports to the hierarchical switch 155 is performed on a channel basis. By controlling the flow of data into the switch on a channel basis, and by dedicating portions of the input buffers to selected ones of the channels, the switch provides for dead-lock free communication between multi-processor nodes in the SMP system.
- the hierarchical switch 155 additionally is designed to support ordering constraints of the SMP system in order to ensure memory coherency. Ordering constraints are imposed by controlling the order of packets that are forwarded out of the switch 155 to the global ports of the associated multi-processor nodes. Packets from any of the input buffers 160a-160h may be forwarded to any of the output ports via multiplexers 182a-182h. As will be described in more detail below, in addition, the switch 155 is capable of multi-casting packets. Accordingly, packets from one input buffer may be forwarded to any number of output ports. By enforcing order at the global port outputs, the serialization order obtained at each of the multi-processor nodes may be maintained to provide an overall coherent data sharing mechanism in the SMP system.
- each one of the eight nodes of FIG. 7A forwards data to the hierarchical switch, and it may occur that all of the nodes are forwarding data simultaneously.
- the packets are apportioned into a number of different channel types (Q0, Q0Vic, Q1, Q2 and QIO) that are forwarded on different virtual channels, where a virtual channel is essentially a datapath dedicated to packets of a specific type that may share a common interconnect with other channels, but is buffered independently on either end of the interconnect. Because there is only one datapath between the global port of each of the nodes and the hierarchical switch, all of the packets from different virtual channels are written to the hierarchical switch using the one datapath.
- each of the eight nodes 100a-100h is capable of sending data to the hierarchical switch, some form of control is necessary to properly ensure that all messages are received by the switch and forwarded out of the switch in an appropriate order.
- the order of packets, from highest order to lowest order is Q2, Q1, Q0, Q0Vic and QIO.
- a scheme for flow-controlling packets arriving at the input ports of the switch is provided that ensures that the deadlock-avoidance rule above is always satisfied. Further, the buffers available in the switch must be utilized optimally and maximum bandwidth must be maintained.
- a control apparatus for controlling the writing of data to the hierarchical switch is implemented by providing, for each of the types of packets, dedicated slots in a buffer of the hierarchical switch.
- the buffer also includes a number of generic slots that may be used for storing packets of any type.
- deadlock can be avoided by guaranteeing that higher order packet types always have a path available through the switch.
- a straightforward flow control scheme may be implemented to preclude nodes from writing to the buffer of the hierarchical switch when the buffer reaches capacity.
- FIG. 12A an example of control logic for use in controlling the writing, by multiple source nodes, of a common destination buffer is provided.
- the global ports 120a and 120b of two different nodes has been shown.
- FIG. 12A portions of the global ports 120a and 120b of nodes 100a and 100b, respectively, are shown in more detail to include a buffer 135 including entries 135a-135b for respectively storing Q0/Q0Vic, Q1, Q2 and generic type packets (either Q0, Q0Vic, Q1, Q2 or QIO packets) for transfer to the hierarchical switch 155.
- a multiplexer 167a is coupled to the buffer 135 to select one of the packet types for forwarding over the link to the hierarchical switch using a select signal from the GP arbiter 134.
- each global port includes a dedicated count register 136.
- the dedicated count register stores a count, for each Q0/Q0Vic, Q1 and Q2 channel type of packet, of the number of packets of that channel type that are currently pending at the hierarchical switch 155. The count is incremented when the packet of the respective channel type is transferred to the hierarchical switch, and decremented when the packet is transferred out of the hierarchical switch.
- the hierarchical switch 155 includes one buffer for each of the eight input sources.
- FIG. 12A only two buffers 160a and 160b, corresponding to the two global ports 120a and 120b have been shown.
- each of the buffers includes eight entries. Five of the entries are generic entries, and may store any type of packet that is forwarded from the global port 135. Each of the remaining three entries are dedicated to storing a specific type of packet, with one entry being dedicated to storing Q0/Q0Vic packets, one entry being dedicated to storing Q1 type packets and one entry being dedicated to storing Q2 type packets.
- any of the locations of the buffer may be the dedicated buffer location; i.e., there is always one dedicated entry in the buffer for each specific type of packet, regardless of the location of the entry.
- the hierarchical switch additionally includes, for each buffer 160a and 160b, a dedicated counter 162a and 162b, and a flag register 163a and 163b, respectively.
- the dedicated counter 162a includes four entries, three entries for storing the number of Q0/Q0 Vic, Q1 and Q2 packets that are currently stored in the buffer 160a, and one entry for storing a count of the number of used generic entries in the buffer.
- the flag register comprises three bits, with each bit corresponding to one of the Q0/Q0 Vic, Q1 and Q2 types of packets, and indicating whether associated dedicated counter is zero (i.e., whether the dedicated entry for that type of packet has been used).
- the values in the flag register are either a one, indicating that at least one packet of that type is stored in the buffer, or zero, indicating that no packets of that type are stored in the buffer.
- the hierarchical switch 155 includes, for each buffer 160a and 160b, a transit count 164a and 164b, respectively.
- the transit count maintains, for each source, the number of outstanding packets of any type that may be in transit during a given data cycle.
- the number of packets that may be in transit during any given data cycle is directly related to the flow control latency between the hierarchical switch and the global port.
- a flow control signal is forwarded from the hierarchical switch to the global port to signal the global port to stop sending data to the hierarchical switch.
- the flow control latency (L) is measured as the number of data transfer cycles that accrue between the assertion of a flow control signal by the hierarchical switch and the stop of data transmission by the global port.
- the hierarchical switch also includes write control logic 166a and 166b for controlling the writing of the respective buffers 168a and 168b.
- the write control logic controls the flow of data into the associated buffer by asserting the Flow Control signal on line 168a and the Acknowledgment (ACK) signals ⁇ 3:0> on lines 168b.
- the Flow Control and ACK signals are sent each data transfer cycle.
- the Flow Control signal is used to stop transmission of packet data by the coupled global port.
- the ACK signals ⁇ 3:0> on lines 168b include one bit for each of the dedicated types of packets, and are used to signal the coupled global port that a packet of that type has been released from the associated buffer. The ACK signals are thus used by the global count to increment the values in the dedicated counter 136.
- the write control logic asserts flow control when it is determined that the total of the available generic entries in the buffer and are not sufficient to accommodate all of the possible packets that may be in transit to the hierarchical switch.
- the number of available generic slots can be determined by the below Equation I:
- the write control logic 166 monitors the number of generic and dedicated slots in use, the transit count and the total buffer size to determine when to assert a Flow Control signal.
- the assertion of the Flow Control signal does not stop all transmission by a global port of a source node.
- the global port may always transfer dedicated packet data to the hierarchical switch if the dedicated slot corresponding to that dedicated packet type is available in the buffer of the hierarchical switch.
- the global port may always transfer packet data of the corresponding dedicated packet type. Accordingly, providing dedicated entries in the buffer effectively guarantees that the progress of packets of one type through the hierarchical switch does not depend on the progress of any other packets through the switch.
- the use of the dedicated and generic slots in the buffers 160a and 160b allows a minimum number of slots to be reserved for each packet type. By keeping track of the number of packets in transit, flow control may be achieved in a finely-grained manner. Both buffer utilization and bus bandwidth are maximized. For example, when only X generic slots are available, flow control may be deserted for one cycle and then reasserted in the next cycle. As a result, up to X more messages may be received within the time period.
- FIG. 12B a flow diagram is shown outlining a method used by the global port for forwarding data to the hierarchical switch. The process is described with reference to one type of packet, although it is equally applicable to packets of other types.
- step 172 If it is determined at step 172 that the dedicated count is equal to zero, then at step 173 the GP arbiter 134 asserts the appropriate select signal to the multiplexer 167 in order to forward the desired packet to the hierarchical switch 155.
- the dedicated count corresponding to the selected type of packet is incremented at the dedicated count registers 134 in the global port and at the dedicated count register 162a in the hierarchical switch 155, and the associated flag in the flag register 163a is asserted.
- the flag register 163a is used together with the generic count and the transit count to determine the status of the Flow Control signal for the next data cycle.
- FIG. 13 one embodiment of a process for controlling the assertion of the Flow Control signal by the hierarchical switch is shown.
- the flag register 163a is examined to count the number of dedicated count entries that is equal to zero.
- the number of zeros indicates the number of potential dedicated packets that may be forwarded by each of the nodes coupled to the buffer even after Flow Control is asserted. Accordingly, if none of the dedicated slots for any of the nodes were used in the example of FIG. 11, then all of the entries of the flag register would be equal to zero, thus indicating that there are 3 buffer locations that should be reserved for the dedicated packets.
- the total available generic slots are determined using above equation I.
- the transit count for each node is determined.
- the transit count indicates the number of messages that may be in transit between the global port and the hierarchical switch for any given data cycle.
- the worst case count transit count is equal to the flow control latency L times the number of nodes using the buffer N.
- the determination of the transit count takes into consideration whether or not the Flow Control signal was asserted for previous cycles. As noted, if the Flow Control signal was asserted in a previous cycle, no packets are in transit between the global port and the hierarchical switch. For example, if Flow control has been zero for the previous J periods, up to J ⁇ N messages can be in transit. However, if the flow control signal has been zero for J-1 of the previous data cycles, only (J-1) ⁇ N messages are in transit.
- one embodiment of the invention intelligently determines the number of packets in transit by examining the total latency between the source (global port) and destination (hierarchical switch), and also by examining the interaction between the source and destination in previous data cycles.
- a determination is made as to whether there are enough available generic entries in the buffer to accommodate the outstanding dedicated packets and the packets in transit using the above Equation II. If the total number of available generic packets is less than the number of packets in transit times the number of nodes sharing the buffer, then at step 178 the Flow Control signal is asserted to the global port 120a to preclude the forwarding of data to the hierarchical switch 155. However, if the total count indicates that the number of potentially received packets may be accommodated by the buffer 160a, the Flow Control signal is not asserted and the process then returns to step 175 for the next data cycle.
- flow control may be fine-tuned to ensure that the use of the data link coupling the global port to the hierarchical switch is maximized.
- FIGS. 11-13 have been described with regard to the transmission of data from the nodes to the hierarchical switch, it should be noted that the present invention is not limited to such a construct. Rather, one embodiment of the invention may be used in any environment where there are multiple sources feeding a common receiver and deadlock needs to be avoided.
- Reading data from the hierarchical switch essentially involves forwarding data from an input buffer to a number of output sources such that both ordering of the packets and the data dependencies between the packets are maintained.
- packets are delivered on a variety of channels. Associated with the packets on different channels are certain ordering constraints or dependencies.
- one ordering constraint is that all packets on the Q1 channel be maintained in order.
- Another packet ordering dependency is that packets traveling on higher priority channels should not be blocked by packets traveling on lower priority channels, where the priority of channels, from highest to lowest, is Q2, Q1, Q0, Q0Vic and QIO.
- the maintenance of order is achieved throughout the SMP using various techniques described below.
- At the hierarchical switch three basic guidelines are followed to ensure that data dependencies and Q1 channel ordering are satisfied. The guidelines are presented below.
- Guideline 2 When Q1 packets from multiple input ports at the hierarchical switch are multi-casting to common output ports, the Q1 packets appear in the same order at all of the output ports that they target.
- Guideline 3 When ordered lists of Q1 packets from multiple input ports of the hierarchical switch target multiple output ports, the Q1 packets appear at the output ports in a manner consistent with a single, common ordering of all incoming Q1 packets. Each output port may transmit some or all of the packets in the common ordered list.
- FIG. 14 a timing diagram illustrating the utilization of the address and data bus structure of the HS link 170 is shown.
- the HS link 170 is coupled to each of the multi-processor nodes 100 by two pairs of uni-directional address and data busses.
- the data bus carries 512 bit data packets
- the address bus carries 80 bit address packets.
- the transmission of a data packet takes twice the number of cycles as the transmission of the address packet.
- Some commands, such as a write command include both an address and a data packet.
- address packet 179a corresponds to data packet 179d. If every command included both an address and a data packet, every other address slot on the address bus would be idle.
- many commands, such as a read command include only address packets, and do not require a slot on the data bus for transferring data packets.
- a switch that selects packets to forward out of the bus in such an order that both the data portion and the address portion are ⁇ packed ⁇ , i.e., there is an address and data in every possible time slot of the address and data portions of the HS link.
- the HS link is optimally utilized.
- a variety of embodiments are provided for implementing a hierarchical switch capable of simultaneously receiving data from multiple sources via multiple input ports and forwarding data to multiple destinations via multiple output ports while satisfying data dependencies, maintaining system order and maximizing the data transfer rate.
- the various embodiments are described with reference to FIGS. 15-18.
- the switch 155 includes a plurality of buffers 160a-16h.
- Each of the input buffers is a one write port/eight read port buffer and is coupled to receive packets from one of eight respective inputs.
- the switch also includes eight output ports, although the logic for only one output port, output port ⁇ 0> is shown. The logic for the remaining output ports is similar and, for purposes of clarity, is not described in detail herein.
- each entry of each buffer includes a channel field 185, identifying the chanmels of a packet stored in the entry of the buffer.
- each entry includes a series of link indices 186.
- Each link index is an index to one of the entries in the input buffers 160a-160h.
- the link indices are used to provide a link list addressing structure to access successive packets on the same channel from the buffer 160a in accordance with packet ordering constraints.
- Each entry also includes dependency flags 189.
- the dependency flags are used to mark dependencies between channels.
- Dependency flag F1 is set if the packet at the corresponding entry is a packet traveling on either a Q1, QI0 or Q0Vic channel.
- Dependency flag F2 is set if the packet at the corresponding entry is a packet traveling on either a Q0 or Q0Vic channel.
- the dependency flags help to maintain an order of processing of packets in the following manner.
- the received packets are apportioned into five ordered queues including a Q2 channel queue, a combination Q1/QI0/Q0Vic channel queue, a combination Q0/Q0Vic channel queue, a Q0Vic channel queue and a QIO queue.
- a packet may be included in more than one queue.
- the head pointers include one pointer 187a-187e for each of the queues. The head points are used to provide an index into the buffers 160a-160h identifying the next packet in the buffer corresponding to that queue.
- the head pointers 187 thus include a Q2 head pointer 187a, a Q1/QIO/Q0Vic head pointer 187b, a Q0/Q0Vic head pointer 187c, a Q0Vic head pointer 187d and a QIO head pointer 187e.
- a packet is first written into the input buffer, it is placed in one or more of the ordered queues.
- one or more of the dependency flags 189 are asserted.
- the channel type and dependency flags are examined to select an appropriate entry in the buffer to output such that channel dependencies are satisfied.
- Each of the entries of each of the eight input buffers 160a-160h are forwarded to multiplexer 182.
- Multiplexer 182 selects one of the packets from one of the input buffers in response to a select signal from the manager 180.
- the manager 180 selects entries from the 64 possible read ports of the input buffers 160a-160h as outputs for the associated output port.
- the manager 180 selects packets such that a total system order and channel dependencies are satisfied.
- the channel type is written to the channel field of the entry and any associated flags for that entry are asserted in flag field 189.
- the multiple link indices are used for multi-casting the packet to three different output ports.
- the link index values are buffer index values for addressing the next packet of the corresponding type in the buffers 160a-160h. Accordingly, the link index value is not written until a subsequent packet of the corresponding type is written into the buffer. When the subsequent packet is written to the buffer, the address of the subsequent packet is written to the linked index of the previous packet, thereby providing an index to the next packet of that channel type. Because each of the entries includes three possible link index fields, in addition to writing the address in the previous entry, a two bit field (not shown) is stored with the address to enable the entry to identify the appropriate one of the three link indices for constructing the ordered list.
- the manager 180 selects one of the packets in the buffers 160a-160h for forwarding to the output port in the following manner.
- the head pointers 187a-187e store the buffer index corresponding to the top of each of the queues.
- the manager selects the entry indicated by the corresponding head pointer. If one or more of the flags 189 are set, and packets in that queue associated with higher priority channels have not been processed, the packet may not be processed until all previous packets of having higher priority in the queue have been processed.
- the output manager For example, if the output manager is processing Q0 type packets, it examines the entries indicated by the Q1/QIO/Q0Vic and Q0/Q0Vic head pointers. If the packet is a Q0 channel packet, but processing of Q1 packets has not yet been completed, the entry may not be processed. Processing of packets may be indicated by providing, with each of the flags F1 and F2, processing flags (not shown) that indicate that either channel Q1 or Q0 packets have already been processed. Once processing of all packets in the queue having higher priority channels has occurred, (as indicated by the processing flags), then the packet associated with the entry is free for processing.
- the manager selects the head pointer associated with the queue that the entry is in, as the buffer index.
- the buffer index is forwarded to multiplexer 182, and the buffer entry is forwarded to the output port.
- the link indices are forwarded back to the head pointer, and the head list pointer is updated with the buffer index of the next packet in that queue.
- the switch embodiment of FIG. 15 uses a linked list data structure, ordered queues and flags for providing packets to an output port such that total system order is maintained.
- the linked list data structure that includes multiple link indices provides a straightforward mechanism for multi-casting packets while adhering to multi-cast packet ordering rules.
- FIG. 15 thus uses flags and ordered queues to ensure that channel ordering is maintained.
- a buffer 200 is provided for every output port of the switch.
- the buffer 200 may be coupled to receive inputs from each of the buffers 160a-160h (FIG. 11) on an input packet receipt path 201, where packets from the input buffers are forwarded to the appropriate buffer of the output port depending upon the destination of the packets.
- the buffer is implemented as a collapsing FIFO, although other buffering architectures known to those of skill in the art may alternatively be used.
- Buffer 200 is shown storing a variety of packets which are to be forwarded out of the switch.
- the buffer 200 stores packets transmitted on five different channels: Q0, Q1, Q2, Q3 and Q4.
- the channels Q0-Q4 are not analogous to the previously described channels Q0, Q1, Q2, Q0VIC and QIO. Rather, they are used merely for the purpose of describing the output operation of the switch. Packets Q0-Q4 thus represent generic packets on different channels, with the channel dependencies being defined according arrows in the flow diagram of FIG. 16A. In the diagram of FIG.
- an arrow directed from one channel to another indicates that the packets in the first channel may not be forwarded to an output port while there is a packet in the second channel, received prior to the packet in the first channel, pending processing by the switch.
- packets in channel Q0 are shown to be dependent upon the processing of packets in channel Q3 and thus it is said that packets in channel Q0 ⁇ pushed ⁇ packets in channel Q3.
- the additional dependencies represented by the flow diagram of FIG. 16A indicate that packets in channel Q1 pushed packets in channels Q2 and Q3.
- the dependencies represented by the flow diagram of FIG. 16A do not represent dependencies of the Q0, Q1, Q2, Q0VIC and QIO channels described previously.
- the dependencies of the packets in Q0, Q1, Q2, Q0VIC and QIO channels are complex and thus the generic packets and dependencies have been provided for ease of explanation of the operation of the buffer 200.
- Each packet entry in each output buffer, such as entry 200a includes a source and destination field, indicating the sending and receiving nodes for the packet, a channel field, indicating the channel on which the packet is transmitted, and a series of bits 206a-206e.
- the series of bits 206a-206e includes one bit for each channel that forwards packets through the hierarchal switch. For example, in the embodiment of FIG. 16, the series of bits includes one bit each for channel Q0, Q1, Q2, Q3 and Q4.
- Write control logic 205 coupled to the input packet receipt path for the output port controls the setting of each of the series of bits according to the channel of the received packet and according to the dependencies between the channels indicated in the flow dependency diagram of FIG. 16A.
- the write control logic may also update the bits by recognizing dependencies, either statically or dynamically. When recognizing dependencies statically, the dependencies defined for the channels are applied without regard to the other packets that are in the buffer. When recognizing dependencies dynamically, the dependencies for the channels are applied by considering the channel and address destinations of the other packets in the buffer 200.
- each search engine searches the associated column of bits to select an entry in the buffer 200 having the corresponding bit of the column set.
- the selected entry is indicated, for each column (or channel) by a series of signals S4-S0 to an output buffer manager 202.
- the output buffer manager selects one of the packets from the output buffer 200 to provide at that global port output.
- the channel of the packet is evaluated by the write control logic 205 and the bit in the series of bits 206a-206e corresponding to that channel asserted.
- the bit that is set to indicate the type of packet is indicated by a ⁇ x ⁇ and is referred to as a channel identifier flag.
- packet1 is a Q3 type packet.
- a bit is additionally asserted for each of the channels that the packet on that channel pushes.
- Each of these bits is referred to as a dependency flag, and are indicated by an ⁇ x ⁇ in FIG. 16. Therefore, for packet2, which is a Q0 channel packet, the bit associated with the Q3 channel packet is additionally asserted since, as indicated in the flow diagram of FIG. 16A, Q0 packets push Q3 packets.
- each of the search engines 208a-208e associated with each column of bits selects the first entry in the buffer having a bit set. Therefore, the select value for search engine 208a would point to packet2, the select value for search engine 208b would point to packet3, and so on.
- the S0-S4 signals are forwarded to the manager 202.
- the manager 202 selects one of the packets in response to the assertion of the select signals by the search engines and addition to the dependencies existing in the system. For example, according to one embodiment of the invention, a packet such as packet2, which is on channel Q0, is not forwarded out of the switch unless the search engine for channel Q0 (208a) as well as the search engine for channel Q3 (208d) are both selecting the same packet. Accordingly, whenever multiple flags are set for a given packet, the manager 202 does not select that packet for output unless the search engines corresponding to the flags that are set both select the given packet.
- the search engine could clear the dependency flag, and proceed down the buffer to select the next entry with either the dependency flag or identity flag set.
- the processing of packets is improved because the search engines are not stalled pending processing by other channels.
- the effect of asserting the multiple flags to identify the dependencies helps to maintain an overall system order of packets as they propagate through the switch.
- the relationship between Q0 and Q3 packets is that the Q0 channel packets pushes every previous Q3 channel packet before executing.
- Packet1 is a Q3 channel packet, received before the packet2 Q0 channel packet.
- the S3 value will not point to packet2 until packet1 has been processed.
- the channel is effectively blocked until the packets that are pushed by the given channel are processed.
- the overall system order is maintained.
- the buffer control logic of FIG. 16 may be operated to recognize either static or dynamic dependencies.
- Static dependencies are those dependencies as indicated by the flow diagram of FIG. 16A.
- Dynamic dependencies are recognized by evaluating the contents of the buffer to determine whether a static dependency actually exists between two packets in the buffer.
- the static dependencies are used to provide ordering rules to ensure that memory data does not lose coherency in the SMP.
- data coherency is only affected if the packets access the same block of memory data. Therefore, dynamic dependencies examine the contents of the buffer on a finer granularity by examining the destination addresses of the packets already in the buffer to determine whether or not a dependency actually exists between two packets of differing channels.
- One advantage of dynamically recognizing the dependencies between packets in the buffer 200 is that it reduces the amount of time required to process the packets in the buffer. For example, using the above description of the packet1 and packet2 operation, if the Q0 packet2 and the Q3 packet1 do not map to the same address, then there is no problem with allowing the Q0 packet to be processed before the Q3 packet. The delay time incurred in waiting for the processing of the previous Q3 packet is eliminated, thereby improving the overall performance of the SMP system.
- a flow diagram illustrating the operation of the selection of a packet to process by recognizing dynamic dependencies is shown.
- a packet is received at the buffer 200.
- the bit for the channel of the packet is set in the series of bits 206 by write control logic 205.
- the previous packets stored in the buffer 200 are examined to determine whether any packets on the channel that the packet pushes are at the same block of memory. If they are at the same block of memory, then at step 226 the bits corresponding to the packets on that channel that the packet pushes and reside in the same memory block are asserted. Accordingly, using the example of FIG. 16 for packet2, the bit for packet type Q3 is only asserted if packet1 is accessing the same block of memory as packet2. Accordingly, by dynamically recognizing dependencies, memory coherency may be maintained while enhancing the overall system performance.
- FIG. 18 another embodiment of a method for outputting data received from multiple input sources to multiple output sources while maintaining an overall system order is shown.
- the embodiment of FIG. 18 is shown to include elements similar to those of FIG. 16.
- write control logic 209 of FIG. 18 updates each of the series of bits 206a-206e by analyzing the dependencies of the packets in a different manner.
- one of the series of bits is set for each packet to indicate that the packet is of the associated channel.
- bits are set for the packets in channel that push packets of that channel.
- packet1 is a Q3 channel packet. Packets on the Q3 channel block the execution of Q1 and Q0 packets until the Q3 packet is executed as indicated in the dependency flow diagram of FIG. 18A. Accordingly, bits 206d, 206b and 206a are set for packet1. Packet2, however, is a Q0 packet that does not block the execution of any other packet. As a result, only the bit 206b is set for packet2.
- the switch implementation of FIG. 18 thus provides an alternate method of forwarding data to an output port while maintaining system ordering by statically recognizing dependencies. It should be noted that the buffer implementation of FIG. 18 may not be used to recognize dynamic dependencies, since doing so would require knowledge of the addresses of data before the data is written to buffer 200. All of the static and dynamic methods described, however, may be used in order to insure that the dependencies between packets are satisfied.
- a linked list buffering scheme has been described, where ordering dependencies are accommodated through the use of multiple queues that store flags and where the queues are selected to identify dependencies.
- an output buffer that receives data in order from an input buffer of the switch includes a series of bits that are used to block packets of certain types in order to ensure that data dependency and coherency constraints are met.
- ordering dependencies are tracked through the use of ordered queues including flags that are set to mark potential dependency conflicts.
- the cache coherency protocol of one embodiment of the invention is a write-invalidate ownership-based protocol.
- "Write-Invalidate” implies that when a processor modifies a cache line, it invalidates stale copies in other processors' caches, rather than updating them with the new value.
- the protocol is termed an "ownership protocol" because there is always an identifiable owner for a cache line, whether it is memory or one of the processors or IOPs in the system.
- the owner of the cache line is responsible for supplying the up-to-date value of the cache line when requested.
- a processor/IOP may own a cache line "exclusively" or “shared". If a processor has exclusive ownership of a cache line, it may update it without informing the system. Otherwise it must inform the system and potentially invalidate copies in other processors'/IOP's caches.
- the large SMP system 150 includes a number of nodes coupled together via a switch 155.
- Each of the processors in each of the nodes generates commands to access data in memory.
- the commands may be handled entirely within the source node or may be transmitted to other nodes in the system based on the address and type of the request.
- Address space is partitioned into memory space and IO space.
- the processors and IOP use private caches to store data for memory-space addresses alone and IO space data is not cached in private caches.
- the cache coherence protocol concerns itself with memory space commands alone.
- a key component of any cache coherence protocol is its approach to serialization of loads and stores.
- a cache coherence protocol must impose an order on all loads and stores to each memory address X. The order is such that all "stores" to X are ordered; there should be a first store, a second store, a third store, and so on.
- the i'th store updates the cache line as determined by the (I-1)'st store. Further, associated with each load is a most recent store from which the load gets the value of the cache line. We will henceforth refer to this order as the "load-store serialization order".
- Arb bus In the small SMP node system shown in FIG. 2, there is one Arb bus. This bus is the serialization point for all memory loads and stores in the small SMP.
- the DTAG coupled to the Arb bus, captures all of the state required by the small SMP protocol.
- the DIR at the home Arb bus captures the coarse state for the protocol; the TTTs and DTAGs capture state information at a finer level.
- DIR, DTAG, and TTT state When a request R arrives at the home Arb bus, DIR, DTAG, and TTT state is examined; probe commands to other processors and/or response commands to the source processor may be generated. Further, the state of the DIR, DTAG, and TTT is atomically updated to reflect the "serialization" of the request R. Thus, a request Q with requested address equal to that of R and arriving at home Arb after request R, will appear after R in the load-store serialization order.
- the home Arb bus is the defined to be the "serialization point" for all requests to a memory address. For each memory address X, stores will appear to have been executed in the order in which the corresponding requests (RdMods or CTDs) arrive at the home Arb bus. Loads to address X will get the version of X corresponding to the store X most recently serialized at the home Arb.
- system refers to all components of the large SMP excluding the processors and IOPs.
- the processors and the system interact with each other by sending "command packets" or simply "commands".
- Commands may be classified into three types: Requests, Probes, and Responses.
- the commands issued by a processor to the system and those issued by the system to the processors are a function of the memory system interface of the given processor.
- requests and commands that are issued according to the Alpha® system interface definition from Digital Equipment Corporation will be described, though it should be understood that other types of processors may alternatively be used.
- Requests are commands that are issued by a processor when, as a result of executing a load or store operation, it must obtain a copy of data. Requests are also used to gain exclusive ownership to a piece of data from the system. Requests include Read commands, Read/Modify (RdMod) commands, Change-to-Dirty commands. Victim commands, and Evict commands (where a cache line of data is removed from the respective cache).
- Probe commands are commands issued by the system to one or more processors requesting data and/or cache Tag status updates. Probe commands include Forwarded Read (FRd) commands, Forwarded Read Modify commands (FRdMod), and Invalidate commands.
- FRd Forwarded Read
- FRdMod Forwarded Read Modify commands
- Invalidate commands When a processor P issues a request to the system, the system may have to issue one or more probes to other processors. If P requests a copy of a cache line (with a Read request), the system will send a probe to the owner processor (if any). If P requests exclusive ownership of a cache line (with a CTD request), the system sends Invalidate probes to one or more processors with copies of the cache line.
- FRdMod Forwarded Read Modify
- FRdMod Forwarded Read Modify
- An Invalidate command may be issued by the system to a processor storing a copy of the cache line in its cache when the cache line is to be updated by another processor.
- Responses are commands from the system to processors/IOPs which carry the data requested by the processor or an acknowledgment corresponding to a request.
- the response is a Fill or FillMod commands, respectively--each of which carry the data requested.
- the response is a CTD-Success or CTD-Failure commands, indicating success or failure of the CTD.
- Victim commands the response is a Victim-Release commands.
- FIG. 19 a table is provided for illustrating the relation between requests and the state of corresponding cache lines in individual processors.
- FIG. 19 also illustrates the resulting probe type commands for each of the requests and states of the cache lines.
- Columns 300 and 300a indicate the requests issued by the processor
- columns 305 and 305a indicate the status of the cache line in other processors in the system
- columns 320 and 320a indicate the resulting probe command that is generated by the system.
- Processor A issues a request to the system.
- Processor B interacts with one or more other processors, referred to as Processor B. If the cache line addressed by processor A is stored in the cache of Processor B, as determined using DTAG and/or directory information, then the cache state of the processor B will determine if a probe command needs to be issued to Processor B, and what type of probe command should be issued.
- a memory request emanating from a processor or IOP is first routed to the home Arb bus.
- the request is routed via the local switch if the request is local: it goes over the hierarchical switch if it is global. In the latter case, it traverses the local switch and the GP Link to get to the GP: then, it goes over the HS Link to the hierarchical switch: then, over the GP and the local switch at the home node to the home Arb bus.
- global requests do not first appear on the source node's Arb bus; instead, they are routed directly to the HS via the GP Link.
- a global requests accessed state on the source node before it was sent out to another node.
- the present invention reduces the average latency of global requests by issuing global requests directly to the HS.
- FIGS. 20A-20J example flow diagrams of a number of basic memory transactions are provided.
- a request is forwarded to the home arb bus from a source processor 320.
- the directory 322 determines which processor owns the memory block. If local memory 323 is owner, a short Fill command is issued from the home arb bus to source processor 320.
- processor 320 of node 325 issues a read to a cache line of memory whose ⁇ home ⁇ is at node 326.
- the (global) Read command is routed through the switch 324 to the ⁇ home ⁇ Arb bus and directory 321 via the pathway indicated by line 327. If the memory 330 of node 326 is the owner of the cache line, then data is returned from node 326 to node 325 by node 326 issuing a ShortFill Response.
- processor 320 issues a Read to a cache line of memory whose ⁇ home ⁇ is node 326, the Read is again routed to the home Arb bus and Directory 321 via pathway 327.
- the entry of directory 321, as mentioned above, includes, for each cache line of memory, 14 bits of status information including owner information.
- the owner information in this instance, identifies the owner as processor 342 at node 328.
- node 326 In response to the directory's indication that node 328 owns the required cache line, two events occur. First the ⁇ home ⁇ node, node 326, issues a Forwarded Read probe to owner processor 342 as indicated by line 329. At the same time, the home node 326 transmits a Fill Marker response to processor 320 as indicated by line 331. The role of the Fill Marker responses is described in a later section.
- processor 342 In response to the Forwarded Read, processor 342 issues a Fill command to processor 320, where the Fill command includes the cache line in question.
- This type of response to a Read request is referred to as a Long Fill, because it requires a sequence of three commands for data return.
- the Read transactions can be broken into two types; a Short Fill, which is a response from memory, and a Long Fill, which is a response from an owner a processor.
- a local Read-Modify transaction operates similarly to a local Read transaction, with the exception that (1) Invalidate probes are sent to all processors that have obtained a copy of the current version of the cache line and (2) and FRMod and FillMods are sent to the owner instead of an Frds and Fills.
- the directory at the home node indicates that a local processor or memory owns the block.
- the directory 322 identifies all external nodes that have obtained the current version of the block.
- An Invalidate command is sent to the HS 324, with all pertinent nodes identified in a the multi-cast vector.
- the HS multi-casts Invalidate messages to all nodes identified in the vector.
- the Invalidate messages go the Arb bus at each of the nodes, where the DTAG further filters them, sending Invalidate probes to only those processors or IOPs that are identified as having a current version of the cache line.
- a Read Modify transaction operates similarly to the Read transactions described with regard to FIGS. 20A and 20B.
- a Read Modify (RdMod) command is first routed from processor 320 to the home Arb and home directory 321 of the cache line. If the memory at node 326 at the home nodes stores the cache line, then a Short Fill Modify command is forwarded from node 326 to processor 320, including the requested data. The directory 321 is updated as a result of this transaction.
- the Read Modify command indicates that processor 320 requires exclusive ownership of the cache line so that it can modify the contents of the cache line. Therefore, in addition to the Short Fill Modify command, node 326 also issues Invalidate commands to all other processors that have obtained a copy of the current version of the cache line.
- the DIR identifies the nodes on which one or more processors have obtained a copy of the current version of the cache line.
- the DIR's presence bits contain this information.
- the DTAG identifies all home node processors that have obtained a copy of the cache line. Invalidates are sent to all nodes having their respective DIR presence bits set. At each of the nodes that receive the Invalidate, the DTAG is accessed to determined which processors currently store a copy of the cache line. Invalidates are sent only to those processors.
- the IOP tag is used to determined if the IOP has a copy; if so, the IOP receives an Invalidate probe too.
- the home node For the case where a processor other than the requesting processor is the owner, the home node generates a Fill Modify Marker, a Forwarded Read Modify and zero or more Invalidates as one command.
- the command is multi-cast to all of the destination nodes.
- the command is segregated into its components, and the global port of each node determines what action should be taken at the respective node.
- a Forwarded Read Mod is processed by processor 342 and a Fill Modify Marker is processed by processor 320.
- Invalidates are performed at the home node, at the node that receives the Fill Modify Marker, and at the node that receives the Forwarded Modify in accordance with their DTAG entries.
- the dirty data is forwarded from processor 342 to processor 320 via a Long Fill Modify command.
- the Read Modify command may perform either two or three node connections, or ⁇ hops ⁇ .
- only Read-type commands Read and Read Modify
- the third hop is a Fill-type command (either Fill or Fill Mod).
- the invention may be easily modified to include other transactions that require 3 or more hops by appropriate allocation of those added commands in the virtual channel qucues described below.
- FIGS. 20G and 20H the basic flows for Clean-to-Dirty (CTD) and Invalidate-to-dirty (ITD) are shown.
- CTD Clean-to-Dirty
- ITD Invalidate-to-dirty
- a Clean-to-Dirty is issued from processor 320 to the directory 321 at the home node.
- Either an Acknowledgment command (ACK) or a No-Acknowledgment command (NACK) are returned to processor 320, depending upon whether the clean cache line that processor 320 wants to update is current or stale.
- the CTD is said to succeed or fail.
- Invalidates are sent to all of the nodes indicated by the presence bits of directory 321 as having a copy of the cache line of data if the CTD succeeds.
- the ITD command operates substantially similarly to the CTD. However, the ITD never fails. An ACK is always returned to the processor 320, and Invalidates are sent to other nodes in the system storing a copy of the cache line of data.
- the Write Victim command forwards dirty data from the processor's cache back to the appropriate home memory.
- FIGS. 20I and 20J it can be seen that the flow for Write Victims differs slightly depending upon whether or not the ⁇ home ⁇ memory is at the same node as the processor issuing the Write Victim. As shown in FIG. 20I, if the ⁇ home ⁇ node is the processor's node, then the processor 320 issues the Write Victim, and data is forwarded directly to the memory of the same node.
- the victim cache line is forwarded out of the cache (or victim buffer) of processor 320, and stored in the Victim cache (FIG. 6, element 124) at the global port of the processor's node.
- the Victim cache responds to the processor with a Victim Release signal, indicating that it is okay for the processor to re-use that victim buffer entry.
- the victim data is forwarded from the victim cache to the memory of the home processor via a Write Victim command.
- victim data sent to home memory by source processor P may be stale by the time it gets to memory. In such a case, the victim is said to "fail" and home memory is not updated.
- This scenario occurs when another processor acquires ownership of the cache line in the interval between P acquiring ownership of the line and P's victim reaching the home directory. In such a case, an Invalidate or FrdMod probe for the cache line must have been sent to the processor P before P's victim reached the home Arb.
- the DTAG is used to decide the success or failure of a Write Victim command in the case where the Write Victim command is local.
- the DTAG and DIR are both able to provide the information needed to determine success or failure of the Write Victim request.
- the DTAG is used instead of the DIR simply because the DTAG-based mechanisms is already provided for in the small SMP node hardware.
- two or more related message packets can be combined into one for efficiency.
- the combined packet is then split into its components at the HS or on the Arb bus at a node.
- an FrdMod message to the HS splits into an FrdMod message to the node with the owner processor into Invalidate messages to nodes with copies of the cache line and FillMarkerMod message to the source node.
- the FrdMod to the owner processor's node further splits at the node's Arb bus into an FrdMod to the owner processor and zero or more Invalidate messages to other processors on the node.
- victim data sent to home memory may be stale by the time it arrives as a result of an intervening Invalidate or FrdMod probe for the cache line received before the Write Victim reached the home Arb.
- One method of determining whether victim data should be written to memory is to look up the directory entry for each write victim command. If the directory indicates that the processor issuing the victim write command is the dirty-owner, then the victim should be allowed to proceed. Otherwise, it should fail. This methodology is desirable because it obviates the need for complex comparison logic structures to match victim write commands between the processor and the serialization point with probe commands between the serialization point and the processor.
- each time the system executes a victim write command it must first access directory status, then evaluate the status and finally, based on the status, execute a DRAM write of the victim data. Since the memory and directory are accessed atomically, if the system were designed according to prior art design methodologies, the total victim write cycle would be equal to the sum of the directory lookup time, the status evaluation time and the DRAM write time. Such a system would suffer a severe performance penalty with respect to systems whose total victim cycle consists of just a DRAM write.
- One embodiment of the invention overcomes this memory bank utilization degradation problem by providing a delayed write buffer at each bank of memory.
- the memory system responds by executing the following functions in parallel: storing the victim write data in a delayed write buffer at the target memory bank and marking the block as "unwritable” or “invalid”, accessing the directory status associated with the victim write, and executing, in place of the current victim write, a DRAM write of a previously buffered victim write that is marked as "writable” or "valid". If, when the directory access is complete, the directory status associated with the victim write indicates that victim write should succeed, the delayed write buffer in which the victim resides is transitioned to the "writeable" or "valid" state.
- the "writable" or "valid" state of a data block in a delayed write buffer indicates that the data in the buffer is a more up to data version of the cache line than the version stored in the memory DRAMs. If the buffer is marked as “writeable” or "valid", its data will be written into DRAM as a result of the subsequent issue of a victim write to the memory system.
- the delayed write buffer includes an associative address register.
- the address of the victim write block is stored into the associative address register at the same time its associated data is stored in the delayed write buffer.
- the memory system identifies those that address blocks in the delayed write buffers by means of an address match against the address register. By this means the memory system will service all references to blocks in the delayed write buffers with the more up to data from the buffers instead of the stale data in the memory DRAMs.
- the above technique of providing delayed write buffering of victim data may be also be used in snoopy-bus based systems which do not include a directly but do use DTAG status to determine the validity of a data block.
- a memory control system for providing delayed write operations includes a memory controller 332, coupled to receive an Owner -- Match signal on line 140a from directory 140.
- the memory controller 332 receives input from the QS Arb 11 (which also feeds directory 140), for tracking the commands that are input to the directory.
- the memory controller 332 includes a delayed write buffer 336.
- Each entry in the delayed write buffer 336 includes a data portion 336a, a flag portion 336b, and an address portion 336c.
- the delayed write buffer holds only one address, data and flag entry, although the invention is not restricted to such an arrangement.
- the delayed write buffer operates as follows. During operation, as a command, address and data are received on Arb -- bus 130, they are forwarded to the directory 140 and also to the memory controller 332. The memory controller 332 stores the command, address and data in the write buffer 336 for one transaction period (here 18 clock cycles). During the transaction period, the directory 140 is accessed, and the results of the access are asserted on the Owner -- Match line 140a. The Owner -- Match line is asserted if the director entry indicates that the processor ID of the processor seeking to update memory is in fact the owner of the cache line of data. The Owner -- Match signal is used to set the flag 336b of the delayed write buffer entry 336.
- memory 334 is written with the stored data.
- only write operations are buffered; an incoming Read operation is allowed to access the memory bus without being delayed. Subsequent read operations to victim data stored in the delayed write buffer are serviced from the delayed write buffer.
- a timing diagram of the operation of a delayed write operation is shown.
- a Read0 operation is received on the Arb bus. This Read operation is propagated immediately to the memory for accessing the DRAM 334.
- a Write1 operation is received on Arb -- bus.
- the directory 140 is accessed and, at the completion of the T1 cycle, the Owner -- Match signal is asserted indicating a match of the WRITE1 address.
- the flag 336b of the delayed write buffer entry is set.
- a Read operation is received and is forwarded to the memory ahead of the WRITE1 operation.
- time T3 if the flag corresponding to the WRITE1 operation is asserted, when the next WRITE3 operation is received at the delayed write buffer, the WRITE1 operation is forwarded to the memory for handling by the DRAM 334.
- the DTAGs may alternatively be used for setting the flag bit in the delayed write buffer.
- One of the cache lines from local memory may be stored in one of the caches of the processors at the local node.
- the DTAG entries for that cache line may be examined to determine whether or not the cache line was resident in one of the processors. If the cache line was resident in one of the processors, the validity bit of the DTAG entry is examined to ensure that the copy that the processor is victimizing was valid.
- the DTAG may set the flag in the delayed write buffer to cause the cache line to be written to local memory. This allows simple, snoopy-bus based (i.e. no directory) systems to apply this same simplifying algorithm.
- the memory control logic of FIG. 21 thus allows READ operations to be executed immediately in a READ cycle, and a WRITE operation to be executed for each WRITE cycle (even though it is a delayed write). As a result, a steady stream of data is forwarded to the DRAMS without delays being incurred as a result of directory accesses, and performance is increased while coherency is maintained.
- the delayed write buffering technique has been described herein with regard to victim write operations, it may be used in any system where coherency state is centralized and stationary to improve memory performance.
- each memory reference may include a number of transactions, or hops, between nodes, where messages for the memory reference are transferred before the entire reference is complete. If dependencies between the messages cause a reference to be blocked indefinitely, the multiprocessor system deadlocks.
- one embodiment of the invention manages the traffic between nodes and maintains data coherence without deadlock through the use of virtual channel flow control.
- Virtual channels were first introduced for providing deadlock free routing in interconnection networks.
- virtual channels may additionally be used to prevent resource deadlocks in a cache coherence protocol for a shared memory computer system.
- the inter-connect uses two channels: a requests channel (or lower order channel) and a response channel (or higher order channel).
- the channels are typically physical; that is, they use distinct buffers and queues.
- a heuristic is typically implemented to detect a potential deadlock. For instance, a controller may signal a potential deadlock when a queue is full and no message has been dequeued from the queue for some time.
- a deadlock resolution mechanism is implemented wherein selected messages are negatively acknowledged so as to free up resources, thus allowing other messages to make progress. Negatively acknowledge messages cause the corresponding command to be retried.
- the large system solution above has two principal problems including a fairness/starvation problem and a performance penalty problem. Because some messages may be negtively acknowledged, it is possible that some commands may not complete for long time (potentially indefinitely). If a command are not guaranteed to complete within a given period of time, the resource issuing the command is not obtaining fair access to the system data. In addition, because the resource is not obtaining fair access to the system data, it may become starved for data, potentially deadlocking the system. In addition, since some messages may be negatively acknowledged and thus fail to reach their destinations, protocol messages such as invalidate messages must generate an acknowledgment to indicate that they successfully reach their destination. Further, a controller must wait until all acknowledgments have been received before it can consider the corresponding command complete. This non-determinism results in a messaging overhead as well as extraneous latency which reduces the overall performance of the cache coherence protocol.
- a cache coherence protocol is used that adopts a systematic and deterministic approach to deadlock-avoidance. Rather than detect potential deadlock and then take corrective action, deadlock is eliminated by design. Consequently, there is no need for deadlock-detection and resolution mechanisms. Second, since messages are never negatively acknowledge for deadlock avoidance, acknowledgments are not required for protocol messages such as Invalidates, and therefore bandwidth and latency are improved.
- a message M1 is defined to "depend" on message M2 if M1 cannot make progress unless M2 makes progress. Further, dependence is defined to be transitive.
- M1 is defined to be "resource dependent” on M2 if M1 cannot make progress until M2 frees up a resource, such as a queue slot.
- M1 is defined to be "flow dependent” on M2 if the cache coherence protocol requires that M1 not make progress until M2 does. For instance, the cache coherence protocol may require that M1 block until the directory reaches a certain state, and it is M2 that sets the directory state to the desired value.
- M1 is then defined to be dependent on M2 if there exists a chain of either resource or flow dependencies from M1 to M2.
- Dependence cycle A "dependence cycle" is defined to exist among a set of messages M1, MK ( ⁇ 2) when the progress of M1 depends on the progress of M2; that of M2 depends on that of M3; that of Mk-1 depends on that of Mk; and finally, that of Mk depends on that of M1.
- M1 depends on Mk, which in turn depends on M1, none of the messages in the cycle can make progress.
- the method and apparatus disclosed herein uses virtual channels to deterministically avoid deadlock in cache coherence protocols. We describe both the hardware mechanism needed and the set of rules to be followed in the design of the cache coherence protocol.
- the cache coherence protocol defines that all memory operations complete in at most three stages. At each stage, one or more messages are transferred between components of the system. Therefore, each stage is also referred to as a "hop". Hops are numbered, 0, 1, and 2. In Hop-0, a requests from a Processor or IO-Processors is routed to the home directory. In HOP-1, messages generated by the home directory are routed to one or more Processors or IO-Processes. In Hop-2, messages travel from an owner processor to the source processor. The hops are illustrated in FIG. 23.
- the predeterined number is three, although the invention is not limited any particular number of hops, so long as the number selected is relatively low and consistent. This property is key to guaranteeing that all messages can be routed to their destinations without any mechanism for detecting deadlock and failing and retrying messages to resolve deadlock.
- the maximum number of hops is three.
- the system thus provides three channels, which are labeled Q0, Q1. and Q2 respectively.
- the channels are logically independent data paths through the system interconnect.
- the channels may be physical or virtual (or partly physical and partly virtual). When physical, each channel has distinct queue and buffer resources throughout the system. When virtual, the channels share queue and buffer resources subject to constraints and rules states below.
- the three channels constitute a hierarchy: Q0 is lowest order, Q1, is next and Q2 is the highest order channel.
- the cardinal rule for a deadlock avoidance in the system is: A message in channel Qi may never depend on a message in a channel lower than Qi.
- a QI0 channel is added to eliminate flow dependence cycles between response messages from the IO system and memory space commands from the IO system.
- a Q0Vic channel is employed for Victim messages and subsequent dependent messages issued while victim messages issued while victim messages are outstanding.
- a given command packet that is issued to the switch may generate a series number of discrete transactions.
- each discrete transaction for a given command packet is allocated to a channel.
- the channels in essence, provide an ordered structure for defining the completion stage and dependencies of a given command packet.
- FIG. 23 a flow diagram illustrating the assignment of channels to the discrete transitions of the operations described in FIGS. 20A-20J is shown.
- the discrete transactions are identified by the following nomenclature; the first transaction in a series of transactions resulting from a reference is referred to as a Q0 or Q0Vic transaction, the second transaction in the series of transactions is a Q1 transaction, and the third transaction in the series of transactions is a Q2 transaction.
- a Q0 or Q0Vic channel carries initial commands from processors and IOPs that have not yet visited a directory. Thus, the destination of a Q0/Q0Vic packet is always a directory.
- the Q0Vic channel is specifically reserved for Write Victim commands, while the Q0 channel carries all other types of commands initiated by the processor or IOP.
- a command issued at step 380 may seek to obtain data or update status. Thie status is always available at the home directory corresponding the address of the data.
- the home directory is accessed, and it is determined whether the available cache line is owned by home memory (relative to the directory) or by another processor. In either case, a response is issued over the Q1 channel. If at step 382 it is determined that the status or data is available at the second node, then at step 384 the response on the Q1 channel is directed back to the first node.
- Q1 type transactions include ShortFill, Short Fill Mod, VicAck, CTD-ACK/NACK, etc.
- a Q1 type transaction of either a Forwarded Read or a Forwarded Read Modify is issued on the Q1 channel to a remote node at step 386.
- an Invalidate Q1 type transaction is forwarded to other concerned nodes in the system.
- the Q1 channel is for carrying packets that are on their second ⁇ hop ⁇ , the first hop being to the directory.
- the destination of the second ⁇ hop ⁇ is always a processor, the processor being either at the node initiating the original command, or at another remote node in the system.
- a Q2 channel carries either a Long Fill or a Long Fill Mod transaction.
- the Q2 channel carries data from the third node by a third ⁇ hop ⁇ back to the node initiating the original command.
- the allocation of commands into Q0/Q0Vic, Q1 and Q2 type commands may be used in a SMP system to ensure deadlock-free messaging in the following manner.
- the flow diagram of FIG. 23 illustrates the interaction between four virtual chamnels, in one embodiment of the invention, five virtual channels may be used for the purpose of maintaining cache coherency.
- the Additional channel includes a QIO channel.
- the QIO channel carries all reads and writes to IO address space including control status register (CSR) accesses.
- CSR control status register
- One implementation of virtual channels in a switch-based system involves the use of physically distinct queues, buffers or paths for each channel.
- the queues, buffers or data paths may be shared between the channels, and are thus truly ⁇ virtual ⁇ .
- a combination of these techniques is used to make optimum use of the hardware.
- Buffer 400 is shown to include a number of ⁇ slots ⁇ .
- Each of the slots is dedicated for use by only one of the channels.
- slot 402 comprises a number of buffer entries that are dedicated to Q2 type commands
- slot 404 comprises a number of buffer entries that are dedicated to Q1 type commands, etc.
- the remaining slots 410 may be used by messages for any of the channels, are therefore referred to as ⁇ shared ⁇ or ⁇ generic ⁇ slots.
- a Busy signal is provided for each channel. The Busy signal indicates that a buffer is not capable of storing any more messages, and that therefore nothing should be transmitted to that buffer.
- ⁇ M ⁇ here defines the number of dedicated slots available per channel.
- FIG. 25 an example embodiment is provided where virtual channels are implemented using separate resources for each channel. Portions of two nodes 420 and 424 are shown coupled together via a hierarchical switch (HS) 422.
- HS hierarchical switch
- Global port 420 is coupled to receive input data from the switch 422 on bus 421a and to transmit data to the switch 422 on bus 421b.
- Global port 424 is coupled to transmit data on bus 423a to the switch 422 and to receive data from the switch 422 on bus 423b.
- Data busses 421a, 421b, 423a, and 423b each transmit or receive all types of channel commands.
- a queuing mechanism such as queuing mechanism 425 is provided at each input and output terminal of each resource.
- the queuing mechanism comprises a number individually controlled buffers 425a-425e, each of the buffers being dedicated to storing only one type of channel command.
- Buffer 425a stores only Q0 channel commands
- buffer 425b stores only Q0Vic channel commands, etc.
- the type of the command is parsed, and the packet is forwarded to the appropriate buffer.
- the command packets are ready to be forwarded to the appropriate processors or IOP of the node, they are selected from the appropriate buffer and forwarded via the Arb bus and the QSA (FIG. 6).
- each channel is flow-controlled independently and a slot is reserved for each but the lowest channel in the hierarchy, throughout the system. This guarantees that a channel may never be blocked by a lower channel due to resource dependencies. The movement of higher channel messages will not be blocked due to occupation of resources by lower channel messages will not be blocked due to occupation of resources by lower channel messages.
- the progress of a message should not depend on progress of a lower channel message, where Q2 is a higher order channel, and Q0 is a lower order channel.
- Arbiters should maintain flow control of each channel independently of the others. For instance, if a Busy flow-control signal is asserted for Q1, but not for Q2, arbiters should let Q2 messages make progress. All search engines that are used to search a resource for outstanding command packets should support the same property.
- any resource that is shared between two or more channels should incorporate some dedicated slots for each of the higher channels to allow higher channels to make progress if lower channels are blocked.
- All channels commands should operate consistently.
- the endpoint of a Q0 command is always a Directory.
- the endpoint of a Q1 command and a Q2 command is always a processor.
- an apparatus and a method for providing virtual channels in either a bus-based system or a switch based system is provided.
- virtual channels By using virtual channels and the above ordering constraints, it may be guaranteed that references, once they are serviced by the directory complete.
- NACKS where one processor indicates to another that a process did not complete
- Retries are eliminated.
- one embodiment of the invention is not limited to a given number of channels, or limited to a symmetric multi-processing system. Rather, the number of channels selected should be the number necessary for supporting coherent communication, given the control and hardware overhead inherent in each channel.
- the virtual channel control method and apparatus thus allows for high performance, deadlock free communication in any multi-processor system.
- all Q0 type commands first access the home directory of the related memory address. Ensuring that the home directory is first accessed for any command allows each command to be viewed in order from a common source.
- serialization order is the order in which Q0 commands for X appear on the arb bus after winning arbitration from the directory for address X.
- a Load type command is ordered when the corresponding Read command accesses the home directory.
- a Store type command is ordered when either the corresponding Read Modify command accesses the directory, or when the corresponding Clean-to-Dirty command accesses the directory and appears on the arb bus.
- the version of the cache line is updated as a result of each store operation.
- command one creates version one command five creates version two
- command six creates version three command ten creates version four.
- Serialization order ensures that each sequence of events that reaches the directory obtains the correct version of the cache line X. For example, commands two through four should obtain version one. When Processor P1's command five performs the store, it should send invalidates to all version one cache lines (at processors P2, P3 and P5). Similarly, when processor P2's command six updates X with version three data, it should invalidate processor P1's version two data. Processors P4, P6, and P7 obtain version three data, which is later invalidated by processor P8's store of version four of the data.
- a number of techniques are used to help the system maintain serialization order and concomitantly maintain data coherence. These techniques include strict ordering of Q1 channel commands, CTD disambiguation, Shadow Commands, Fill Markers and Delayed Victim Write Buffering. Each technique is described in detail below.
- the first method that is used to maintain coherency is to ensure that all messages that travel on the Q1 channel, i.e. those sent from the directory, travel in First-In, First-Out order. That is, the Q1-type messages that are forwarded from the directory to another processor or IOP are forwarded according to the order in which the commands were serialized at the directory.
- first processor P1 (431) at node 430 stores a cache line X in its cache Dirty.
- Processor P16 (433) at node 432 issues a Read X on the Q0 channel, which is forwarded to the home directory 437 of X at node 436.
- processor P17, at node 432 issues an Inval-to-Dirty command on the Q0 channel, which is also forwarded to the home directory 437 of X at node 436.
- a Forwarded Read X is sent to processor P1 (431) on the Q1 channel.
- an Invalidate is sent to the Hierarchical Switch 435, which forwards invalidates on the Q1 channel to processor P1 and processor P16.
- FIFO-order is only maintained for channel Q1, where FIFO order means that all messages corresponding to the same memory address stay in FIFO order.
- the present invention is not limited to merely maintaining order for the Q1 channel, but may be expanded to include maintenance of order for any combinations of channels.
- the QS Arb 11 in the QSA chip serializes all Q0 transactions to the node's home memory space. As a result, a serial stream of Q1 packets is generated that is directed at both the local processors at the node and processors that are remote to the node via the global port and hierarchical switch.
- the first ordering rule is stated as follows: All Q1 packets that are generated by any given QS Arb are generated in serial order. All processors that are targeted by some or all of the Q1 packets from a given QS Arb see these Q1 packets in the order that they were generated by the QS Arb.
- the QSA chip maintains order on all Q1 packets transferred to and from the coupled processors in the node.
- Logic in the global port maintains FIFO order on all packets transferred between the hierarchical switch and the QSA chip.
- the hierarchical switch maintains order on all Q1 packets from any given input to any given output.
- Q1 packets from one QS Arb and Q1 packets from another node's QS Arb are serialized with the Q1 packets generated by the home node via the hierarchical switch as follows. All Q1 packets targeted at processors in remote nodes are processed by the QS Arb of the remote nodes. These Q1 packets are serialized with Q1 packets generated by the remote node by the hierarchical switch. All recipients of Q1 packets from a given QS Arb should see the Q1 packets in the same order as they were serialized at the QS Arb.
- FIG. 27A a block diagram is shown for illustrating the ordering of a number of Q0 and Q1 commands being processed through the SMP according to the above ordering guidelines.
- processor Px at node 440 issues command Q0a
- processor Py issues command Q0b
- processor Pz issues command Q0c.
- QS Arb 441 receives from global port 443 Q1 messages from processors Pr and Pq.
- the QS Arb 441 processes the Q0a, Q0b, and Q0c to generate Q1a, Q1b and Q1c responses. These generated Q1 commands are combined with the incoming Q1 commands, to provide an ordered stream of commands to FIFO 442 for forwarding to the local processors. The order of the FIFO commands reflects the order of the commands processed by the QS Arb.
- the Q1a, Q1b, and Q1c commands are forwarded to the global port 443 for transmission to a remote node.
- the output buffer 444 of the global port stores these commands in the same order in which they were processed by the QS Arb. This order is maintained by hierarchical switch 446 as the messages are forwarded to remote CPU 454 using the methods described above with regard to FIGS. 14-19.
- FIG. 27A also illustrates another ordering guideline that is followed at the hierarchical switch.
- the hierarchical switch maintains order by ensuring that multiple packets that appear at a given input port of the hierarchical switch, and that are targeted at a common output port of the hierarchical switch appear in the same order at the output port as they appeared at the input port.
- the hierarchical switch is also responsible for multi-casting input messages; i.e. sending one received Q1 packet to more than one destination node.
- a packet that is multi-cast by the switch is the invalidate packet.
- the Q1 packets should appear in the same order at all of the output ports. For example, if packet one and packet two are both received at hierarchical switch 460, then one permissible method of multi-casting the two messages to processors 464 and 466 is as illustrated, with message two reaching both processors before message one. Another permissible method would be to have both message one packets reach both processors before message two packets. However, the two processors should not receive the two packets in a different order.
- Another ordering rule that should be followed by the hierarchical switch is to ensure that when ordered lists of Q1 packets from multiple input ports are targeted to common output ports, the Q1 packets appear at the output ports in a manner consistent with a single common ordering of all incoming Q1 packets.
- packet two is received before packet four.
- packet one is received before packet three.
- the total order of these instructions should be preserved to prevent deadlock.
- One permissible order to provide the output packets is to have packet three transmitted first to node 464, and packet one transmitted first to node 466. This transmission is illustrated in FIG. 27C.
- Another permissible output would be to have packets two and four received first by the recipient processors. However, if one processor receives packet three first, and another receives packet four first, then deadlock could occur as the processors stall awaiting receipt of the other packet of their original sequence.
- Q0 and Q2 commands are not ordered. As such, precautions are taken to ensure that coherency problems do not arise at the directory as a result of the relative timing of received Q0 and Q2 commands.
- each directory entry includes an ownership field and one presence bit for each node.
- the presence bit is a coarse vector, representing the presence of data in one of the four processors of the associated node. Operations by any of the four processors may result in the presence bit being set.
- This ambiguity can result in coherence problems in certain instances.
- Node 470 [node ID three of the global system] includes processors P12, P13, P14 and P15, while node 472 [node ID seven of the global system] includes nodes P28, P29, P30 and P31.
- the state of the directory entry for a given cache line X at various sequential periods of time T0-T3 is indicated in Directory State Table 455 in FIG. 28B.
- the home node of cache line X is a node other than node 470 or 472.
- the owner of cache line X is memory as indicated by the owner ID 80.
- processor 30 at node ID seven stores a clean copy of cache line X.
- processor 14 transmits a Store command that is translated to a Read Block Modify X and is forwarded to the home directory of cache line X. Because memory is the owner, processor P14 can obtain data from memory and becomes owner of the cache line. An invalidate is transmitted to node seven to invalidate the older version of cache line X, and node seven's presence bit is cleared. In addition, processor P14 sets its node presence bit 456 (bit three). Cache line X is sent from home memory to processor P14 for modification and storage.
- another processor such as processor 31, issues a Read of cache line X.
- the Read obtains data via a Fill from processor P14.
- the directory indicates that both node ID three (Processor P14) and node ID seven (processor P31) store a copy of cache line X, as indicated by node presence bits 458 and 456.
- a CTD is issued by a processor 30, the state of cache line X as viewed by different processors in the system may become incoherent for the following reason.
- the CTD reaches the directory, it reads the directory entry for X and determines that the presence bit 458 for its node, node ID seven, is already on. As a result, processor 30 then assumes that it has succeeded in the CTD request.
- Processor 30 invalidates processor 14's copy of cache line X, and updates the owner field of the directory. This action may cause unpredictable results, since processor P14 is storing a more up-to-date version of data than processor P30.
- processor 30 is still storing an out-of-date version of the cache line created by processor 14, and processor 14 was told to invalidate the most recent version of the data. Such a situation could cause serious coherence problems with the SMP system.
- One method is to expand the presence field of the directory entry to provide one bit for each processor in the system.
- the resolution is changed from a node level to a processor level.
- This solution would undesirably increase the size of the directory.
- One embodiment of the invention provides a more straightforward method of preventing the above ambiguity problem by slowing down the CTD commands when an outstanding reference to the same address is in transit for that node. If there is an outstanding request to the same address, the CTD is held back until that previous request is retired.
- the transaction tracking table (TTT) (FIG. 10) of a given node is used to monitor outstanding global references for that node. In addition, requests received after the CTD is received at the TTT are failed.
- the TTT is a fully associative, multi-functional control structure.
- the TTT performs two general tasks. It stores the addresses of all remote references issued by its associated node. Thus the TTT stores one entry of information for each remote access issued by a node until that transaction is considered complete.
- the TTT provides coherency information, with regard to transient coherency states, in response to requests to local addresses.
- the TTT is a table for tracking the status of accesses while they are in transit.
- the SMP of the present invention allows multiple references to the same cache line to be in flight at any given instant in time. As a result, the overall performance of the SMP is improved.
- the TTT 522 is used by logic in the QSA chip 535 to determine the state of transactions that have been issued over the global port. Before issuing the response to the global port, the QSA first accesses the TTT to determine what references to the same cache line are outstanding. A reference is outstanding if it has not been retired from the TTT in response to the last received transaction.
- How a reference is retired from the TTT is dependent upon the type of reference indicated in the command field 584. For example, Read X reference that made it to the global port for storage in the TTT requires both the Fill Here 588a and Fill Marker Here 588b status bits to be received. (Fill Markers are described in more detail below). For status type references, such as CTD or ITD, setting the ACK/NACK bit 588c in the TTT is sufficient to retire that entry.
- FIG. 29 a flow diagram illustrating the use of the TTT for eliminating ambiguous directory entries is provided.
- cache line X is stored in memory at its home node and processor 30 of node seven stores a copy of the data.
- a ReadMod X is issued by processor P14. As a result, invalidate is forwarded toward node seven.
- processor P31 issues a Read X which creates an entry in the TTT at node seven with the following state:
- processor P30 issues a CTD X.
- the QSA chip examines the address of the CTD instruction, determines that it is a remote CTD, and forwards it to the global port over the GP Link to the TTT. The contents of the TTT are then as shown below:
- the global port uses information from the TTT to determine which commands are permitted to be sent out of the hierarchical switch. In one embodiment of the invention, If the TTT determines that a pending Read is in transit, it precludes the global port from forwarding the CTD to the switch until the Read results have been returned.
- an outstanding read request to the address X is identified by the TTT.
- the CTD is held off until a Read is no longer outstanding.
- the Read is outstanding until both a Fill and Fill Marker are returned to node seven. During this period of time, the invalidate issued by the ReadMod at step 502 reaches node seven and updates the DTAGS of the respective node. When the invalidate for X reaches the TTT, the TTT marks any CTD that is held in the TTT as a failure and it is released immediately. If at step 510 the CTD is still in the TTT, it is transmitted over the global port.
- Q2 type messages include Fills and Fill Modifies.
- nodes 520 and 532 are shown. Only the portions of the nodes that are needed for explanation purposes are shown. Assume processor P2 (524) and processor P4 (534) store a copy of cache line X. The home node of cache line X is node 532.
- Q0 commands are indicated by single line arrows
- Q1 commands are indicated by double line arrows
- Q2 commands are indicated by dashed line arrows.
- processor P4 issues a CTD X to gain exclusive ownership of cache line X.
- directory 542 issues an invalidate to node 520. This invalidate will update the DTAGS at node 520 on the Q1 channel and send an invalidate probe to all processors (here processor P2) that have a copy.
- Processor P1 then issues a ReadMod X to X's home directory 542.
- X is currently owned by processor P4, and therefore according to the coherence protocol, a Forwarded Read Mod X is forwarded to processor P4.
- Processor P4 in response, issues a FillMod to processor P1 on the Q2 channel.
- the Q2 FillMod may reach processor P1 before the Inval from the CTD X reaches node 520.
- the effect would be that valid data would be written to the cache of P1, but that soon thereafter the DTAGS would be set to invalidate any copies of X at the node and an Inval would be sent to P2 and P1.
- the Inval only corresponds to the version in P2, not the later one in P1.
- the system would now be in an incoherent state.
- the directory 544 records P1 as the owner, yet P1 has been invalidated.
- One embodiment of the invention overcomes this problem through the use of Fill Markers and the Transaction Tracking Table (FIG. 10) in the global port of each node.
- a Fill Marker or a Fill Marker Mod is a packet that is generated in response to a Read or Read Mod request for data that is not currently stored in memory at the home node. That is, the Fill Marker or Fill Marker Mod is generated at the same time as the Forwarded Read or Forwarded Read Mod.
- Fill Marker and Fill Marker Mods are Q1 channel commands. While the Forwarded Read or Forwarded Read Mod commands are sent to the processor storing a cache line, the destination of the Fill Marker or Fill Marker Mod is the processor that sourced the original Read or Read Mod.
- the Fill Markers allow the originating processor to determine the serialization order that occurred at the directory.
- the application of Fill Markers remedies the above problem as follows. As before, assume processor 53A issues a CTD of X, to the home directory of X, resulting in an Inval 550 being sent on Q1 channel to node 520.
- TTT entry is generated for that request.
- An example TTT table entry for this request is shown in FIG. 32. Note that the TTT table entry includes Fill Here and Fill Marker Here status bits. Each of these bits are set in response to the representative packet being received at the global port of node 520. The TTT entry is not cleared until both the Fill and Fill Marker are returned.
- the Read Mod X from processor 522 will result in a FRdModX to processor 53A.
- a Fill Marker Mod X 552 is forwarded back to processor P1. Both the Inval and the Fill Mod Marker are on the same Q1 channel.
- the TTT is accessed to determine the status of the Forwarded Read instruction.
- the TTT entry has the Fill Here bit set, but the Fill Marker Here bit is not set.
- the TTT provides an indication as to the relative timing of the Invalidate and the remote read operation. Because of the serialization of Q1 commands, it can be inferred that the invalidate was generated earlier in time at the directory 542 than the RdMod X from processor 522, and hence the Fill Mod is a newer version and the invalidate does not apply to processor 522's copy of the data. As a result, the DTAG entry for processor P1 is not invalidated.
- each of the processors of each of the nodes could track the status of remote requests to common addresses by monitoring the requests to the directory.
- the Fill Markers would be forwarded to the associated processor by the directory, rather than being forwarded merely to the TTT.
- the TTT may serve two purposes. By monitoring the types of commands that are sent out of the multi-processor node, the TTT can inhibit the forwarding of certain commands (such as the CTD) until other commands to the same address are complete. In addition, by providing a marking mechanism that indicates to the TTT when a request has transitioned to the Q2 channel (such as the Fill Marker), the TTT can be used to provide a relative timing indication between commands returned on different channels (i.e. Q2 fill and Q1 commands), and accordingly can preclude commands that could corrupt memory from being forwarded to a processor.
- a marking mechanism that indicates to the TTT when a request has transitioned to the Q2 channel (such as the Fill Marker)
- the TTT can be used to provide a relative timing indication between commands returned on different channels (i.e. Q2 fill and Q1 commands), and accordingly can preclude commands that could corrupt memory from being forwarded to a processor.
- processor 564 at node 560, issues a CTD X.
- cache line X is local to node 560, and when the CTD succeeds, it forwards an Inval to processor P1 (and also to processor P5, is shown).
- each of the processors includes logic for stalling probes to a cache if there is an outstanding read for the same cache location.
- the effect of the Read X would be to store address X in Miss Address File (MAF) 574.
- MAF Miss Address File
- the contents of the MAF are compared against incoming probes, and when there is a match between the address of an incoming probe and the MAF the probe queue is stalled.
- the probe queue is released when the Fill data is returned from processor 582. However, if the same type of transactions (i.e., P5 performing a remote Rd Y and then P6 issuing a CTD Y) are occurring at node 580, the probe queue of processor P5 may be stalled pending satisfaction of the Read Y request.
- One embodiment of the invention overcomes the deadlock potential posed by the commingling of local and remote references through the use of command shadowing.
- FIG. 35 illustrates the contents of the TTT for this example.
- First processor P1 issues a RdX to the Arbiter. As before, this results in a FRdX to processor P5, which is recorded in the TTT.
- processor P2 issues a CTD X to the Arb.
- the Arb examines the TTT, determines that there is an outstanding local read forwarded to a remote processor, and forwards the Inval X out of the global port and to processor P5. An entry is also created in the TTT reflecting this operation, with its shadow bit set.
- Processor P5 issues a RdY, that is forwarded to node 560 and is logged in the TTT, by including the P5 address in the entry.
- Processor P6 subsequently issues a CTD Y.
- the Arbiter at node 580 matches the CTD address against an outstanding read in the TTT, and ⁇ shadows ⁇ the CTD Y over the global port.
- An entry is created in the TTT for that CTD Y, with that entry having its shadow bit set in the TTT, indicating that the CTD Y was a local reference that was forwarded remote in order to ensure proper ordering of requests to Y.
- One of the nodes may still receive an Inval in the probe queue followed by the Forwarded Read. For example, using serialization order, processor P5's probe queue may be stalled by the Inval Y, and the Frd X may be stalled pending the fill. However, note that in this example, the Frd Y is not behind the Inval X, and therefore is able to provide Fill data to unblock the P5 probe queue.
- the TTT entry corresponding to the reference is dropped. There may be other references in the TTT that shadowed the original reference. As those commands are received from the hierarchical switch, the TTT entries for each of the shadowed commands are also dropped. Eventually, when the remote access and shadowed accesses are all complete, and the TTT no longer contains any entries that map to the cache line, any subsequent local references to that cache line need not be shadowed.
- Shadow command method is equally applicable to other types of instructions multi-processor/In general, whenever there is a reference to a local address X, and a prior message to the local address X has been forwarded to a remote processor (as indicated by the TTT) or any prior reference to X is still being shadowed, the present reference to X is also shadowed.
- the method may be used in other types of architectures that include even more levels of hierarchy than simply the multi-processor/switch hierarchy described above.
- the above method may be used for computer systems that include multiple levels of hierarchy, with the commands being forwarded to the appropriate level in the hierarchy, depending upon the hierarchical level of a previous, outstanding reference to the cache line.
- the architecture of the SMP system includes a hierarchical switch structure which allows for a number of multi-processor nodes to be coupled to the switch to operate at an optimum performance.
- a simultaneous buffering system is provided that allows all of the processors of the multi-processor node to operate at peak performance.
- a memory is shared among the nodes, with a portion of the memory resident at each of the multi-processor nodes.
- Each of the multi-processor nodes includes a number of elements for maintaining memory coherency, including a victim cache, a directory and a transaction tracking table.
- the victim cache allows for selective updates of victim data destined for memory stored at a remote multi-processing node, thereby improving the overall performance of memory.
- Memory performance is additionally improved by including, at each memory, a delayed write buffer which is used in conjunction with the directory to identify victims that are to be written to memory.
- An arb bus coupled to the output of the directory of each node provides a central ordering point for all messages that are transferred through the SMP.
- the messages comprise a number of transactions, and each transaction is assigned to a number of different virtual channels, depending upon the processing stage of the message.
- the use of virtual channels thus helps to maintain data coherency by providing a straightforward method for maintaining system order. Using the virtual channels and the directory structure, cache coherency problems that would previously result in deadlock may be avoided.
Abstract
Description
Generic.sub.-- count=Buffer Size-# of used Generic entries in buffer-# unasserted Flags
Generic.sub.-- Count>=Transit count*Number of nodes using the buffer.
TABLE II ______________________________________ QIO All IO-space requests RdByteIO, RdWordIO, WrByteIO, to CPU WrWordIO Q0 All memory-space requests Rd, RdMod, Fetch, CTD, ITD, from CPU or TOP Vic, RdVic, RdModVic Q0Vic All memory-space requests WrVic, Full Cache line Write, from CPU or IOP that QV.sub.-- Rd, QV.sub.-- RdMod, transfer data QV.sub.-- Fetch Q1 All Forwarded Commands FRd, FRdMod, Ffetch All Shadow Commands SFRd, SFRdMod, SFEtch, Sinval, Ssnap Short Fills SFill, SfilMod All Flavors of FM, FMMod, Pseudo-FM, Fill Markers PSeudo-DMMod, FRdMod with FM Others CTD-ACK,CTD-NACK, ITD-ACK, Vic-ACK, VicRel IO-Space Responses IOFillMarker, IOWriteAck Consig related Invl-Ack, LoopComSig Q2 Long Fills Fill, FillMod IO-Space Fills IOFill ______________________________________
M=(flow-control latency in frame clocks)/(packet length in frame clocks)
TABLE IV ______________________________________ 1 P1:Store X.sub.1 (1) 2 P2:Load X.sub.1 3 P3:Load X.sub.1 4 P5:Load X.sub.1 5 P1:Store X.sub.2 (2) 6 P2:Store X.sub.1 (3) 7 P4:Load X.sub.1 8 P5:Load X.sub.2 9 P6:Load X.sub.1 10 P2:Store X.sub.1 (4) ______________________________________
______________________________________ Address Command ID Status ______________________________________ Fill Fmark Shadow ACK/NACK X Read 31 ______________________________________
______________________________________ Address Command ID Status ______________________________________ Fill Fmark Shadow ACK/NACK X Read 30X Read 31 ______________________________________
Claims (39)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US08/957,531 US6014690A (en) | 1997-10-24 | 1997-10-24 | Employing multiple channels for deadlock avoidance in a cache coherency protocol |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US08/957,531 US6014690A (en) | 1997-10-24 | 1997-10-24 | Employing multiple channels for deadlock avoidance in a cache coherency protocol |
Publications (1)
Publication Number | Publication Date |
---|---|
US6014690A true US6014690A (en) | 2000-01-11 |
Family
ID=25499715
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US08/957,531 Expired - Lifetime US6014690A (en) | 1997-10-24 | 1997-10-24 | Employing multiple channels for deadlock avoidance in a cache coherency protocol |
Country Status (1)
Country | Link |
---|---|
US (1) | US6014690A (en) |
Cited By (69)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6148378A (en) * | 1997-05-26 | 2000-11-14 | Bull S.A. | Process for operating a machine with non-uniform memory access and cache coherency and a machine for implementing the process |
US6167430A (en) * | 1998-05-12 | 2000-12-26 | Unisys Corporation | Multicomputer with distributed directory and operating system |
US6195731B1 (en) * | 1997-05-26 | 2001-02-27 | Bull, S.A. | Instrumentation device for a machine with non-uniform memory access |
US6195728B1 (en) * | 1997-06-02 | 2001-02-27 | Bull, S.A. | Detection of hot points in a non-uniform memory access machine |
US20010003839A1 (en) * | 1999-12-09 | 2001-06-14 | Hidetoshi Kondo | Data access method in the network system and the network system |
US6349366B1 (en) * | 1998-06-18 | 2002-02-19 | Compaq Information Technologies Group, L.P. | Method and apparatus for developing multiprocessor cache control protocols using a memory management system generating atomic probe commands and system data control response commands |
US20020184345A1 (en) * | 2001-05-17 | 2002-12-05 | Kazunori Masuyama | System and Method for partitioning a computer system into domains |
US20020186711A1 (en) * | 2001-05-17 | 2002-12-12 | Kazunori Masuyama | Fault containment and error handling in a partitioned system with shared resources |
US6510471B1 (en) * | 1999-09-09 | 2003-01-21 | International Business Machines Corporation | Method for choosing device among plurality of devices based on coherncy status of device's data and if device supports higher-performance transactions |
US20030023776A1 (en) * | 2001-06-28 | 2003-01-30 | Nokia Corporation | Method for enabling a communication between processes, processing system, integrated chip and module for such a chip |
US6529999B1 (en) * | 1999-10-27 | 2003-03-04 | Advanced Micro Devices, Inc. | Computer system implementing system and method for ordering write operations and maintaining memory coherency |
US20030120806A1 (en) * | 2001-12-21 | 2003-06-26 | Clune David E. | Method and apparatus for maintaining multicast lists in a data network |
US20030191905A1 (en) * | 2002-04-09 | 2003-10-09 | Via Technologies, Inc. | Remote node accessing local memory by using distributed shared memory |
US20030189944A1 (en) * | 2002-04-09 | 2003-10-09 | Via Technologies, Inc. | Distributed shared memory system and data-maintenance method of same |
US6633967B1 (en) | 2000-08-31 | 2003-10-14 | Hewlett-Packard Development Company, L.P. | Coherent translation look-aside buffer |
US6640289B2 (en) * | 2000-11-15 | 2003-10-28 | Unisys Corporation | Software controlled cache line ownership affinity enhancements in a multiprocessor environment |
US6647453B1 (en) | 2000-08-31 | 2003-11-11 | Hewlett-Packard Development Company, L.P. | System and method for providing forward progress and avoiding starvation and livelock in a multiprocessor computer system |
US20040068622A1 (en) * | 2002-10-03 | 2004-04-08 | Van Doren Stephen R. | Mechanism for resolving ambiguous invalidates in a computer system |
US20040068619A1 (en) * | 2002-10-03 | 2004-04-08 | Van Doren Stephen R. | Linked-list early race resolution mechanism |
US20040068621A1 (en) * | 2002-10-03 | 2004-04-08 | Van Doren Stephen R. | Generalized active inheritance consistency mechanism for a computer system |
US20040068620A1 (en) * | 2002-10-03 | 2004-04-08 | Van Doren Stephen R. | Directory structure permitting efficient write-backs in a shared memory computer system |
US20040068616A1 (en) * | 2002-10-03 | 2004-04-08 | Tierney Gregory E. | System and method enabling efficient cache line reuse in a computer system |
US20040066758A1 (en) * | 2002-10-03 | 2004-04-08 | Van Doren Stephen R. | Channel-based late race resolution mechanism for a computer system |
US20040068613A1 (en) * | 2002-10-03 | 2004-04-08 | Tierney Gregory E. | Retry-based late race resolution mechanism for a computer system |
US6754776B2 (en) | 2001-05-17 | 2004-06-22 | Fujitsu Limited | Method and system for logical partitioning of cache memory structures in a partitoned computer system |
US6766360B1 (en) * | 2000-07-14 | 2004-07-20 | Fujitsu Limited | Caching mechanism for remote read-only data in a cache coherent non-uniform memory access (CCNUMA) architecture |
US6862634B2 (en) | 2001-06-29 | 2005-03-01 | Fujitsu Limited | Mechanism to improve performance in a multi-node computer system |
US6865645B1 (en) | 2000-10-02 | 2005-03-08 | International Business Machines Corporation | Program store compare handling between instruction and operand caches |
US20050065962A1 (en) * | 2003-09-23 | 2005-03-24 | Revivio, Inc. | Virtual data store creation and use |
US20050066118A1 (en) * | 2003-09-23 | 2005-03-24 | Robert Perry | Methods and apparatus for recording write requests directed to a data store |
US20050066222A1 (en) * | 2003-09-23 | 2005-03-24 | Revivio, Inc. | Systems and methods for time dependent data storage and recovery |
US20050066225A1 (en) * | 2003-09-23 | 2005-03-24 | Michael Rowan | Data storage system |
US20050076264A1 (en) * | 2003-09-23 | 2005-04-07 | Michael Rowan | Methods and devices for restoring a portion of a data store |
US6888843B2 (en) | 1999-09-17 | 2005-05-03 | Advanced Micro Devices, Inc. | Response virtual channel for handling all responses |
US6901450B1 (en) * | 2000-09-22 | 2005-05-31 | Hitachi, Ltd. | Multiprocessor machine and cache control method for providing higher priority to shared cache that is accessed by multiprocessors |
US6938094B1 (en) * | 1999-09-17 | 2005-08-30 | Advanced Micro Devices, Inc. | Virtual channels and corresponding buffer allocations for deadlock-free computer system operation |
US6950438B1 (en) | 1999-09-17 | 2005-09-27 | Advanced Micro Devices, Inc. | System and method for implementing a separate virtual channel for posted requests in a multiprocessor computer system |
US20050249201A1 (en) * | 2003-02-20 | 2005-11-10 | Beshai Maged E | Circulating switch |
US20060047903A1 (en) * | 2004-08-24 | 2006-03-02 | Ron Passerini | Systems, apparatus, and methods for processing I/O requests |
US20060047902A1 (en) * | 2004-08-24 | 2006-03-02 | Ron Passerini | Processing storage-related I/O requests using binary tree data structures |
US20060047989A1 (en) * | 2004-08-24 | 2006-03-02 | Diane Delgado | Systems and methods for synchronizing the internal clocks of a plurality of processor modules |
US20060047999A1 (en) * | 2004-08-24 | 2006-03-02 | Ron Passerini | Generation and use of a time map for accessing a prior image of a storage device |
US20060047895A1 (en) * | 2004-08-24 | 2006-03-02 | Michael Rowan | Systems and methods for providing a modification history for a location within a data store |
US20060047925A1 (en) * | 2004-08-24 | 2006-03-02 | Robert Perry | Recovering from storage transaction failures using checkpoints |
US20060047998A1 (en) * | 2004-08-24 | 2006-03-02 | Jeff Darcy | Methods and apparatus for optimally selecting a storage buffer for the storage of data |
US20060062232A1 (en) * | 2004-08-27 | 2006-03-23 | Board Of Regents, The University Of Texas System | Methods for memory assignment schemes and architecture for shareable parallel memory module based internet switches |
US20060153226A1 (en) * | 2004-11-23 | 2006-07-13 | Gostin Gary B | Systems and methods for a unified computer system fabric |
US20070073977A1 (en) * | 2005-09-29 | 2007-03-29 | Safranek Robert J | Early global observation point for a uniprocessor system |
US20070088973A1 (en) * | 2005-10-14 | 2007-04-19 | Revivio, Inc. | Technique for timeline compression in a data store |
US20070174558A1 (en) * | 2005-11-17 | 2007-07-26 | International Business Machines Corporation | Method, system and program product for communicating among processes in a symmetric multi-processing cluster environment |
US20070180155A1 (en) * | 2006-02-01 | 2007-08-02 | International Business Machines Corporation | Method and apparatus for implementing transfer ordering using hardware linked list |
US20080196073A1 (en) * | 2005-06-24 | 2008-08-14 | Hiroshi Tango | Image Data Communication Apparatus |
US7533236B1 (en) * | 2006-05-11 | 2009-05-12 | Nvidia Corporation | Off-chip out of order memory allocation for a unified shader |
US7533237B1 (en) * | 2006-05-11 | 2009-05-12 | Nvidia Corporation | Off-chip memory allocation for a unified shader |
US20100017194A1 (en) * | 2008-07-17 | 2010-01-21 | Mette Hammer | System and method for suggesting recipients in electronic messages |
US20100118819A1 (en) * | 2000-03-22 | 2010-05-13 | Texas Instruments Incorporated | Systems, processes and integrated circuits for improved packet scheduling of media over packet |
US7796629B1 (en) * | 2007-12-12 | 2010-09-14 | Integrated Device Technology, Inc. | Packet switch with configurable bandwidth allocation precision |
US20110035037A1 (en) * | 1998-06-26 | 2011-02-10 | Eveready Battery Company, Inc. | Control System and Method Therefor |
US7907625B1 (en) | 2008-08-04 | 2011-03-15 | Integrated Device Technology, Inc. | Power reduction technique for buffered crossbar switch |
WO2013063311A1 (en) | 2011-10-26 | 2013-05-02 | Arteris SAS | Integrated circuits with cache-coherency |
US8605717B2 (en) | 2004-02-19 | 2013-12-10 | Rockstar Consortium Us Lp | Two-dimensional circulating switch |
US8898254B2 (en) | 2002-11-05 | 2014-11-25 | Memory Integrity, Llc | Transaction processing using multiple protocol engines |
US9454556B2 (en) | 2012-10-15 | 2016-09-27 | Apple Inc. | Indexing using a lockless burst trie |
US10073778B1 (en) * | 2006-09-29 | 2018-09-11 | Mellanox Technologies Ltd. | Caching in multicore and multiprocessor architectures |
US10795820B2 (en) * | 2017-02-08 | 2020-10-06 | Arm Limited | Read transaction tracker lifetimes in a coherent interconnect system |
US10846230B2 (en) * | 2016-12-12 | 2020-11-24 | Intel Corporation | Methods and systems for invalidating memory ranges in fabric-based architectures |
CN112463652A (en) * | 2020-11-20 | 2021-03-09 | 海光信息技术股份有限公司 | Data processing method and device based on cache consistency, processing chip and server |
US11030102B2 (en) * | 2018-09-07 | 2021-06-08 | Apple Inc. | Reducing memory cache control command hops on a fabric |
US11228458B2 (en) * | 2015-09-10 | 2022-01-18 | Lightfleet Corporation | Group-coherent memory |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5469549A (en) * | 1990-04-12 | 1995-11-21 | British Aerospace Public Limited Company | Computer system having multiple asynchronous processors interconnected by shared memories and providing fully asynchronous communication therebetween |
US5701403A (en) * | 1994-06-03 | 1997-12-23 | Mitsubishi Denki Kabushiki Kaisha | Cad system |
US5754789A (en) * | 1993-08-04 | 1998-05-19 | Sun Microsystems, Inc. | Apparatus and method for controlling point-to-point interconnect communications between nodes |
-
1997
- 1997-10-24 US US08/957,531 patent/US6014690A/en not_active Expired - Lifetime
Patent Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5469549A (en) * | 1990-04-12 | 1995-11-21 | British Aerospace Public Limited Company | Computer system having multiple asynchronous processors interconnected by shared memories and providing fully asynchronous communication therebetween |
US5754789A (en) * | 1993-08-04 | 1998-05-19 | Sun Microsystems, Inc. | Apparatus and method for controlling point-to-point interconnect communications between nodes |
US5701403A (en) * | 1994-06-03 | 1997-12-23 | Mitsubishi Denki Kabushiki Kaisha | Cad system |
Cited By (118)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6195731B1 (en) * | 1997-05-26 | 2001-02-27 | Bull, S.A. | Instrumentation device for a machine with non-uniform memory access |
US6148378A (en) * | 1997-05-26 | 2000-11-14 | Bull S.A. | Process for operating a machine with non-uniform memory access and cache coherency and a machine for implementing the process |
US6195728B1 (en) * | 1997-06-02 | 2001-02-27 | Bull, S.A. | Detection of hot points in a non-uniform memory access machine |
US6167430A (en) * | 1998-05-12 | 2000-12-26 | Unisys Corporation | Multicomputer with distributed directory and operating system |
US6393459B1 (en) | 1998-05-12 | 2002-05-21 | Unisys Corporation | Multicomputer with distributed directory and operating system |
US6349366B1 (en) * | 1998-06-18 | 2002-02-19 | Compaq Information Technologies Group, L.P. | Method and apparatus for developing multiprocessor cache control protocols using a memory management system generating atomic probe commands and system data control response commands |
US20110035037A1 (en) * | 1998-06-26 | 2011-02-10 | Eveready Battery Company, Inc. | Control System and Method Therefor |
US6510471B1 (en) * | 1999-09-09 | 2003-01-21 | International Business Machines Corporation | Method for choosing device among plurality of devices based on coherncy status of device's data and if device supports higher-performance transactions |
US6888843B2 (en) | 1999-09-17 | 2005-05-03 | Advanced Micro Devices, Inc. | Response virtual channel for handling all responses |
US6950438B1 (en) | 1999-09-17 | 2005-09-27 | Advanced Micro Devices, Inc. | System and method for implementing a separate virtual channel for posted requests in a multiprocessor computer system |
US6938094B1 (en) * | 1999-09-17 | 2005-08-30 | Advanced Micro Devices, Inc. | Virtual channels and corresponding buffer allocations for deadlock-free computer system operation |
US6529999B1 (en) * | 1999-10-27 | 2003-03-04 | Advanced Micro Devices, Inc. | Computer system implementing system and method for ordering write operations and maintaining memory coherency |
US7093078B2 (en) * | 1999-12-09 | 2006-08-15 | Nec Corporation | Data access method in the network system and the network system |
US20010003839A1 (en) * | 1999-12-09 | 2001-06-14 | Hidetoshi Kondo | Data access method in the network system and the network system |
US8009688B2 (en) * | 2000-03-22 | 2011-08-30 | Texas Instruments Incorporated | Decoding packets with deadlines in communications channels processing unit |
US20100118819A1 (en) * | 2000-03-22 | 2010-05-13 | Texas Instruments Incorporated | Systems, processes and integrated circuits for improved packet scheduling of media over packet |
US6766360B1 (en) * | 2000-07-14 | 2004-07-20 | Fujitsu Limited | Caching mechanism for remote read-only data in a cache coherent non-uniform memory access (CCNUMA) architecture |
US20040093455A1 (en) * | 2000-08-31 | 2004-05-13 | Duncan Samuel H. | System and method for providing forward progress and avoiding starvation and livelock in a multiprocessor computer system |
US6633967B1 (en) | 2000-08-31 | 2003-10-14 | Hewlett-Packard Development Company, L.P. | Coherent translation look-aside buffer |
US6832282B2 (en) | 2000-08-31 | 2004-12-14 | Hewlett-Packard Development Company, L.P. | System and method for providing forward progress and avoiding starvation and livelock in a multiprocessor computer system |
US6647453B1 (en) | 2000-08-31 | 2003-11-11 | Hewlett-Packard Development Company, L.P. | System and method for providing forward progress and avoiding starvation and livelock in a multiprocessor computer system |
US6901450B1 (en) * | 2000-09-22 | 2005-05-31 | Hitachi, Ltd. | Multiprocessor machine and cache control method for providing higher priority to shared cache that is accessed by multiprocessors |
US6865645B1 (en) | 2000-10-02 | 2005-03-08 | International Business Machines Corporation | Program store compare handling between instruction and operand caches |
US6640289B2 (en) * | 2000-11-15 | 2003-10-28 | Unisys Corporation | Software controlled cache line ownership affinity enhancements in a multiprocessor environment |
US7380001B2 (en) | 2001-05-17 | 2008-05-27 | Fujitsu Limited | Fault containment and error handling in a partitioned system with shared resources |
US20020186711A1 (en) * | 2001-05-17 | 2002-12-12 | Kazunori Masuyama | Fault containment and error handling in a partitioned system with shared resources |
US6754776B2 (en) | 2001-05-17 | 2004-06-22 | Fujitsu Limited | Method and system for logical partitioning of cache memory structures in a partitoned computer system |
US20020184345A1 (en) * | 2001-05-17 | 2002-12-05 | Kazunori Masuyama | System and Method for partitioning a computer system into domains |
US6961761B2 (en) | 2001-05-17 | 2005-11-01 | Fujitsu Limited | System and method for partitioning a computer system into domains |
US20030023776A1 (en) * | 2001-06-28 | 2003-01-30 | Nokia Corporation | Method for enabling a communication between processes, processing system, integrated chip and module for such a chip |
US9817705B2 (en) | 2001-06-28 | 2017-11-14 | Nokia Technologies Oy | Method for enabling a communication between processes, processing system, integrated chip and module for such a chip |
US6862634B2 (en) | 2001-06-29 | 2005-03-01 | Fujitsu Limited | Mechanism to improve performance in a multi-node computer system |
US20030120806A1 (en) * | 2001-12-21 | 2003-06-26 | Clune David E. | Method and apparatus for maintaining multicast lists in a data network |
US8688853B2 (en) * | 2001-12-21 | 2014-04-01 | Agere Systems Llc | Method and apparatus for maintaining multicast lists in a data network |
US6990516B2 (en) * | 2002-04-09 | 2006-01-24 | Via Technologies, Inc. | Distributed shared memory system and data-maintenance method of same |
US7082501B2 (en) | 2002-04-09 | 2006-07-25 | Via Technologies, Inc. | Remote node accessing local memory by using distributed shared memory |
US20030191905A1 (en) * | 2002-04-09 | 2003-10-09 | Via Technologies, Inc. | Remote node accessing local memory by using distributed shared memory |
US20030189944A1 (en) * | 2002-04-09 | 2003-10-09 | Via Technologies, Inc. | Distributed shared memory system and data-maintenance method of same |
US20060095673A1 (en) * | 2002-10-03 | 2006-05-04 | Van Doren Stephen R | Mechanism for resolving ambiguous invalidates in a computer system |
US20040068613A1 (en) * | 2002-10-03 | 2004-04-08 | Tierney Gregory E. | Retry-based late race resolution mechanism for a computer system |
US6895476B2 (en) | 2002-10-03 | 2005-05-17 | Hewlett-Packard Development Company, L.P. | Retry-based late race resolution mechanism for a computer system |
US20040066758A1 (en) * | 2002-10-03 | 2004-04-08 | Van Doren Stephen R. | Channel-based late race resolution mechanism for a computer system |
US6892290B2 (en) | 2002-10-03 | 2005-05-10 | Hewlett-Packard Development Company, L.P. | Linked-list early race resolution mechanism |
US20040068616A1 (en) * | 2002-10-03 | 2004-04-08 | Tierney Gregory E. | System and method enabling efficient cache line reuse in a computer system |
US7174431B2 (en) | 2002-10-03 | 2007-02-06 | Hewlett-Packard Development Company, L.P. | Mechanism for resolving ambiguous invalidates in a computer system |
US20040068622A1 (en) * | 2002-10-03 | 2004-04-08 | Van Doren Stephen R. | Mechanism for resolving ambiguous invalidates in a computer system |
US7051163B2 (en) | 2002-10-03 | 2006-05-23 | Hewlett-Packard Development Company, L.P. | Directory structure permitting efficient write-backs in a shared memory computer system |
US6990559B2 (en) | 2002-10-03 | 2006-01-24 | Hewlett-Packard Development Company, L.P. | Mechanism for resolving ambiguous invalidates in a computer system |
US7000080B2 (en) * | 2002-10-03 | 2006-02-14 | Hewlett-Packard Development Company, L.P. | Channel-based late race resolution mechanism for a computer system |
US7003635B2 (en) | 2002-10-03 | 2006-02-21 | Hewlett-Packard Development Company, L.P. | Generalized active inheritance consistency mechanism having linked writes |
US20040068621A1 (en) * | 2002-10-03 | 2004-04-08 | Van Doren Stephen R. | Generalized active inheritance consistency mechanism for a computer system |
US7024520B2 (en) | 2002-10-03 | 2006-04-04 | Hewlett-Packard Development Company, L.P. | System and method enabling efficient cache line reuse in a computer system |
US20040068619A1 (en) * | 2002-10-03 | 2004-04-08 | Van Doren Stephen R. | Linked-list early race resolution mechanism |
US20040068620A1 (en) * | 2002-10-03 | 2004-04-08 | Van Doren Stephen R. | Directory structure permitting efficient write-backs in a shared memory computer system |
US8898254B2 (en) | 2002-11-05 | 2014-11-25 | Memory Integrity, Llc | Transaction processing using multiple protocol engines |
US20050249201A1 (en) * | 2003-02-20 | 2005-11-10 | Beshai Maged E | Circulating switch |
US7856010B2 (en) * | 2003-02-20 | 2010-12-21 | Nortel Networks Limited | Circulating switch |
US20090262731A1 (en) * | 2003-02-20 | 2009-10-22 | Beshai Maged E | Circulating switch |
US7961649B2 (en) | 2003-02-20 | 2011-06-14 | Nortel Networks Limited | Circulating switch |
US20050065962A1 (en) * | 2003-09-23 | 2005-03-24 | Revivio, Inc. | Virtual data store creation and use |
US20050066222A1 (en) * | 2003-09-23 | 2005-03-24 | Revivio, Inc. | Systems and methods for time dependent data storage and recovery |
US7725667B2 (en) | 2003-09-23 | 2010-05-25 | Symantec Operating Corporation | Method for identifying the time at which data was written to a data store |
US7904428B2 (en) | 2003-09-23 | 2011-03-08 | Symantec Corporation | Methods and apparatus for recording write requests directed to a data store |
US20050066118A1 (en) * | 2003-09-23 | 2005-03-24 | Robert Perry | Methods and apparatus for recording write requests directed to a data store |
US20050063374A1 (en) * | 2003-09-23 | 2005-03-24 | Revivio, Inc. | Method for identifying the time at which data was written to a data store |
US7725760B2 (en) | 2003-09-23 | 2010-05-25 | Symantec Operating Corporation | Data storage system |
US20050066225A1 (en) * | 2003-09-23 | 2005-03-24 | Michael Rowan | Data storage system |
US7991748B2 (en) | 2003-09-23 | 2011-08-02 | Symantec Corporation | Virtual data store creation and use |
US20050076264A1 (en) * | 2003-09-23 | 2005-04-07 | Michael Rowan | Methods and devices for restoring a portion of a data store |
US20050076261A1 (en) * | 2003-09-23 | 2005-04-07 | Revivio, Inc. | Method and system for obtaining data stored in a data store |
US8605717B2 (en) | 2004-02-19 | 2013-12-10 | Rockstar Consortium Us Lp | Two-dimensional circulating switch |
US20060047989A1 (en) * | 2004-08-24 | 2006-03-02 | Diane Delgado | Systems and methods for synchronizing the internal clocks of a plurality of processor modules |
US20060047895A1 (en) * | 2004-08-24 | 2006-03-02 | Michael Rowan | Systems and methods for providing a modification history for a location within a data store |
US20090019459A1 (en) * | 2004-08-24 | 2009-01-15 | Symantec Operating Corporation | Systems and methods for providing a modification history for a location within a data store |
US20060047903A1 (en) * | 2004-08-24 | 2006-03-02 | Ron Passerini | Systems, apparatus, and methods for processing I/O requests |
US20060047902A1 (en) * | 2004-08-24 | 2006-03-02 | Ron Passerini | Processing storage-related I/O requests using binary tree data structures |
US8521973B2 (en) | 2004-08-24 | 2013-08-27 | Symantec Operating Corporation | Systems and methods for providing a modification history for a location within a data store |
US20060047999A1 (en) * | 2004-08-24 | 2006-03-02 | Ron Passerini | Generation and use of a time map for accessing a prior image of a storage device |
US20060047925A1 (en) * | 2004-08-24 | 2006-03-02 | Robert Perry | Recovering from storage transaction failures using checkpoints |
US7827362B2 (en) | 2004-08-24 | 2010-11-02 | Symantec Corporation | Systems, apparatus, and methods for processing I/O requests |
US20060047998A1 (en) * | 2004-08-24 | 2006-03-02 | Jeff Darcy | Methods and apparatus for optimally selecting a storage buffer for the storage of data |
US7730222B2 (en) | 2004-08-24 | 2010-06-01 | Symantec Operating System | Processing storage-related I/O requests using binary tree data structures |
US20060062232A1 (en) * | 2004-08-27 | 2006-03-23 | Board Of Regents, The University Of Texas System | Methods for memory assignment schemes and architecture for shareable parallel memory module based internet switches |
WO2006026461A3 (en) * | 2004-08-27 | 2007-12-21 | Univ Texas | Methods for memory assignment schemes and architecture for shareable parallel memory module based internet switches |
US7532635B2 (en) | 2004-08-27 | 2009-05-12 | Board Of Regents, The University Of Texas System | Methods for memory assignment schemes and architecture for shareable parallel memory module based internet switches |
US20060153226A1 (en) * | 2004-11-23 | 2006-07-13 | Gostin Gary B | Systems and methods for a unified computer system fabric |
US7471623B2 (en) * | 2004-11-23 | 2008-12-30 | Hewlett-Packard Development Company, L.P. | Systems and methods for a unified computer system fabric |
US20080196073A1 (en) * | 2005-06-24 | 2008-08-14 | Hiroshi Tango | Image Data Communication Apparatus |
US20070073977A1 (en) * | 2005-09-29 | 2007-03-29 | Safranek Robert J | Early global observation point for a uniprocessor system |
US20070088973A1 (en) * | 2005-10-14 | 2007-04-19 | Revivio, Inc. | Technique for timeline compression in a data store |
US20070174558A1 (en) * | 2005-11-17 | 2007-07-26 | International Business Machines Corporation | Method, system and program product for communicating among processes in a symmetric multi-processing cluster environment |
US7958513B2 (en) * | 2005-11-17 | 2011-06-07 | International Business Machines Corporation | Method, system and program product for communicating among processes in a symmetric multi-processing cluster environment |
US20070180155A1 (en) * | 2006-02-01 | 2007-08-02 | International Business Machines Corporation | Method and apparatus for implementing transfer ordering using hardware linked list |
US7533237B1 (en) * | 2006-05-11 | 2009-05-12 | Nvidia Corporation | Off-chip memory allocation for a unified shader |
US8407443B1 (en) | 2006-05-11 | 2013-03-26 | Nvidia Corporation | Off-chip out of order memory allocation for a unified shader |
US7739473B1 (en) | 2006-05-11 | 2010-06-15 | Nvidia Corporation | Off-chip memory allocation for a unified shader |
US7533236B1 (en) * | 2006-05-11 | 2009-05-12 | Nvidia Corporation | Off-chip out of order memory allocation for a unified shader |
US10073778B1 (en) * | 2006-09-29 | 2018-09-11 | Mellanox Technologies Ltd. | Caching in multicore and multiprocessor architectures |
US7974278B1 (en) | 2007-12-12 | 2011-07-05 | Integrated Device Technology, Inc. | Packet switch with configurable virtual channels |
US8014288B1 (en) | 2007-12-12 | 2011-09-06 | Integrated Device Technology, Inc. | Packet latency based arbitration technique for a packet switch |
US8081646B1 (en) | 2007-12-12 | 2011-12-20 | Integrated Device Technology, Inc. | Old virtual queues technique for routing data packets in a packet switch |
US7796629B1 (en) * | 2007-12-12 | 2010-09-14 | Integrated Device Technology, Inc. | Packet switch with configurable bandwidth allocation precision |
US8306809B2 (en) | 2008-07-17 | 2012-11-06 | International Business Machines Corporation | System and method for suggesting recipients in electronic messages |
US20100017194A1 (en) * | 2008-07-17 | 2010-01-21 | Mette Hammer | System and method for suggesting recipients in electronic messages |
US7907625B1 (en) | 2008-08-04 | 2011-03-15 | Integrated Device Technology, Inc. | Power reduction technique for buffered crossbar switch |
EP2771793A4 (en) * | 2011-10-26 | 2015-07-15 | Qualcomm Technologies Inc | Integrated circuits with cache-coherency |
JP2014532923A (en) * | 2011-10-26 | 2014-12-08 | クゥアルコム・テクノロジーズ・インコーポレイテッド | Integrated circuit with cache coherency |
JP2016157462A (en) * | 2011-10-26 | 2016-09-01 | クゥアルコム・テクノロジーズ・インコーポレイテッド | Integrated circuits with cache coherency |
CN104115128A (en) * | 2011-10-26 | 2014-10-22 | 高通科技公司 | Integrated circuits with cache-coherency |
WO2013063311A1 (en) | 2011-10-26 | 2013-05-02 | Arteris SAS | Integrated circuits with cache-coherency |
US9454556B2 (en) | 2012-10-15 | 2016-09-27 | Apple Inc. | Indexing using a lockless burst trie |
US11228458B2 (en) * | 2015-09-10 | 2022-01-18 | Lightfleet Corporation | Group-coherent memory |
US10846230B2 (en) * | 2016-12-12 | 2020-11-24 | Intel Corporation | Methods and systems for invalidating memory ranges in fabric-based architectures |
US11609859B2 (en) | 2016-12-12 | 2023-03-21 | Intel Corporation | Methods and systems for invalidating memory ranges in fabric-based architectures |
US10795820B2 (en) * | 2017-02-08 | 2020-10-06 | Arm Limited | Read transaction tracker lifetimes in a coherent interconnect system |
US11030102B2 (en) * | 2018-09-07 | 2021-06-08 | Apple Inc. | Reducing memory cache control command hops on a fabric |
CN112463652A (en) * | 2020-11-20 | 2021-03-09 | 海光信息技术股份有限公司 | Data processing method and device based on cache consistency, processing chip and server |
CN112463652B (en) * | 2020-11-20 | 2022-09-27 | 海光信息技术股份有限公司 | Data processing method and device based on cache consistency, processing chip and server |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6014690A (en) | Employing multiple channels for deadlock avoidance in a cache coherency protocol | |
US6085276A (en) | Multi-processor computer system having a data switch with simultaneous insertion buffers for eliminating arbitration interdependencies | |
US6154816A (en) | Low occupancy protocol for managing concurrent transactions with dependencies | |
US6101420A (en) | Method and apparatus for disambiguating change-to-dirty commands in a switch based multi-processing system with coarse directories | |
US6108752A (en) | Method and apparatus for delaying victim writes in a switch-based multi-processor system to maintain data coherency | |
US6094686A (en) | Multi-processor system for transferring data without incurring deadlock using hierarchical virtual channels | |
US6122714A (en) | Order supporting mechanisms for use in a switch-based multi-processor system | |
US6279084B1 (en) | Shadow commands to optimize sequencing of requests in a switch-based multi-processor system | |
US6249520B1 (en) | High-performance non-blocking switch with multiple channel ordering constraints | |
US6286090B1 (en) | Mechanism for selectively imposing interference order between page-table fetches and corresponding data fetches | |
US6055605A (en) | Technique for reducing latency of inter-reference ordering using commit signals in a multiprocessor system having shared caches | |
US6085263A (en) | Method and apparatus for employing commit-signals and prefetching to maintain inter-reference ordering in a high-performance I/O processor | |
US6209065B1 (en) | Mechanism for optimizing generation of commit-signals in a distributed shared-memory system | |
EP0817051B1 (en) | Multiprocessing system having coherency related error logging capabilities and method therefor | |
US5958019A (en) | Multiprocessing system configured to perform synchronization operations | |
EP0817042B1 (en) | A multiprocessing system including an apparatus for optimizing spin-lock operations | |
US5734922A (en) | Multiprocessing system configured to detect and efficiently provide for migratory data access patterns | |
KR100348947B1 (en) | Non-uniform memory access(numa) data processing system that speculatively issues requests on a node interconnect | |
US6266743B1 (en) | Method and system for providing an eviction protocol within a non-uniform memory access system | |
US8103791B2 (en) | Synchronized communication in a data processing system | |
US10437725B2 (en) | Master requesting missing segments of a cache line for which the master has coherence ownership | |
US20080175272A1 (en) | Data processing system, method and interconnect fabric for selective link information allocation in a data processing system | |
US20030076831A1 (en) | Mechanism for packet component merging and channel assignment, and packet decomposition and channel reassignment in a multiprocessor system | |
US11449489B2 (en) | Split transaction coherency protocol in a data processing system | |
US7944932B2 (en) | Interconnect fabric for a data processing system |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: DIGITAL EQUIPMENT CORPORATION, MASSACHUSETTSFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:SHARMA, MADHUMITRA;VAN DOREN, STEPHEN R.;STEELY, JR., SIMON C.;REEL/FRAME:008798/0944Effective date: 19970905 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: COMPAQ INFORMATION TECHNOLOGIES GROUP, L.P., TEXASFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:DIGITAL EQUIPMENT CORPORATION;COMPAQ COMPUTER CORPORATION;REEL/FRAME:012447/0903;SIGNING DATES FROM 19991209 TO 20010620 |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
AS | Assignment |
Owner name: HEWLETT-PACKARD DEVELOPMENT COMPANY, L.P., TEXASFree format text: CHANGE OF NAME;ASSIGNOR:COMPAQ INFORMANTION TECHNOLOGIES GROUP LP;REEL/FRAME:014102/0224Effective date: 20021001 |
|
FEPP | Fee payment procedure |
Free format text: PAYER NUMBER DE-ASSIGNED (ORIGINAL EVENT CODE: RMPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYFree format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
REMI | Maintenance fee reminder mailed | ||
FPAY | Fee payment |
Year of fee payment: 12 |
|
SULP | Surcharge for late payment |
Year of fee payment: 11 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:HEWLETT-PACKARD DEVELOPMENT COMPANY, L.P.;HEWLETT-PACKARD COMPANY;REEL/FRAME:027661/0258Effective date: 20111025 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |