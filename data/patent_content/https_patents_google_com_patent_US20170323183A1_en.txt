US20170323183A1 - Large-scale classification in neural networks using hashing - Google Patents
Large-scale classification in neural networks using hashing Download PDFInfo
- Publication number
- US20170323183A1 US20170323183A1 US15/656,192 US201715656192A US2017323183A1 US 20170323183 A1 US20170323183 A1 US 20170323183A1 US 201715656192 A US201715656192 A US 201715656192A US 2017323183 A1 US2017323183 A1 US 2017323183A1
- Authority
- US
- United States
- Prior art keywords
- nodes
- hash
- particular layer
- hash table
- vector
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- G06K9/6267—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/082—Learning methods modifying the architecture, e.g. adding, deleting or silencing nodes or connections
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F18/00—Pattern recognition
- G06F18/20—Analysing
- G06F18/24—Classification techniques
-
- G06K9/66—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
Definitions
- This specification relates to image recognition using neural networks.
- Deep neural networks with several levels and hierarchies of features may have very large learning capacity and be used in speech or image recognition.
- Deep neural networks typically have several layers of units connected in a feed-forward fashion between the input and output spaces.
- Each layer in a deep neural network may perform a specific function, e.g., convolution, pooling, normalization, or matrix multiplication and non-linear activation.
- a system uses matrix multiplication to determine an output for a particular layer in a neural network.
- the matrix multiplication is a combination of an activation vector, e.g., input for the particular layer, and a weight matrix, e.g., the weights for some of the nodes in the particular layer.
- the neural network uses a fast locality-sensitive hashing technique to approximate a result of the matrix multiplication to allow the neural network to generate scores for a large number, e.g., millions, of output classes.
- the neural network may approximate computation of a matrix product of weights W for a particular layer in the neural network and an activation vector x so that the number nodes in the particular layer, e.g., output dimensions, can be increased by several orders of magnitude.
- the particular layer may be an output layer in a neural network, e.g., a final classification layer, which is used to determine a classification of an input to the neural network.
- each of the multiple layers of the neural network includes respective multiple nodes include the actions of for a particular layer of the multiple layers: receiving, by a classification system, an activation vector as input for the particular layer, selecting one or more nodes in the particular layer using the activation vector and a hash table that maps numeric values to nodes in the particular layer, and processing the activation vector using the selected nodes to generate an output for the particular layer.
- Other embodiments of this aspect include corresponding computer systems, apparatus, and computer programs recorded on one or more computer storage devices, each configured to perform the actions of the methods.
- a system of one or more computers can be configured to perform particular operations or actions by virtue of having software, firmware, hardware, or a combination of them installed on the system that in operation causes or cause the system to perform the actions.
- One or more computer programs can be configured to perform particular operations or actions by virtue of including instructions that, when executed by a data processing apparatus, cause the apparatus to perform the actions.
- the method may include creating a modified activation vector by setting the values in the activation vector that correspond to the nodes that were not selected to zero. Processing the activation vector using the selected nodes to generate the output for the particular layer may include processing the modified activation vector to generate the output for the particular layer.
- the hash table stores, for each of the nodes of the particular layer, a respective hash of weight values of the node.
- Selecting the one or more nodes may include computing a hash code for at least a portion of the activation vector, determining one or more most similar hashes in the hash table to the hash code of the portion of the activation vector, and selecting the nodes corresponding to the one or more most similar hashes.
- the hash table stores, for each of the nodes of the particular layer, a respective node identifier of the node.
- the activation vector includes real number values.
- the method may include converting each of the real numbers in the activation vector to binary values to create a binary vector, determining multiple portions of the binary vector, and converting, for each of the portions, the binary values in the respective portion into an integer.
- Selecting the nodes in the particular layer using the activation vector and the hash table may include selecting the one or more nodes in the particular layer by using the integers as input to the hash table.
- the integers may include a first subset and a second, mutually exclusive subset.
- the method may include determining, for at least some output values in the output, an accuracy value of a respective output value, and updating at least some of the mappings in the hash table using the accuracy values by updating time stamps for a first node entry in the hash table for a particular node in the particular layer and not updating time stamps for a second node entry in the hash table that does not correspond to any nodes in the particular layer.
- the method may include determining, by the classification system, old entries in the hash table that have an old timestamp, and removing the old entries from the hash table.
- the particular layer may include an output layer of the neural network.
- the method may include determining a best output value from the output for the particular layer, and using the best output value as output for the neural network.
- the classification system may be an image classification system. Each of the nodes in the output layer may correspond to a respective object class.
- the method may include receiving an image, and using the image as input to the neural network. Using the best output value as output for the neural network may include classifying an object in the image as belonging to the class corresponding to the node that generated the best output value.
- Receiving the image may include receiving, from a device, data identifying the image, and using the image as input to the neural network may include using, by the classification system on another device, the image as input to the neural network in response to receiving the data identifying the image.
- a classification system may train large scale neural networks at a faster rate, e.g., in terms of number of steps, total time, or both, compared to other systems that do not use the methods described below, e.g., standard soft-max layers or hierarchical soft-max layers.
- a classification system's computation cost may depend only on K, the number of weight vectors used or the number of classes identified in an output layer, and may be independent of the total number of classes in an output layer of a neural network.
- a classification system may classify objects using on the order of hundreds of thousands to millions of classes with approximately the same computational cost of a classification system, e.g., a conventional deep neural network, with a few thousands of classes.
- a classification system may be used to train large scale neural networks, e.g., using additional data structures.
- the classification system may include an inverted hash table with timestamps for keeping track of, and updating, the hash table as the weight matrix is continuously updated during the training process.
- a classification system with a neural network that has N classes in an output layer and that selects at most the top K weight vectors for the classes in the output layer may have an improved speed of N/K compared to other classification systems that do not use a hash table in the same manner.
- a classification system only performs comparisons when computing a hash code, e.g., which allows the classification system to determine the hash code using integer arithmetic.
- a classification system computes a hash code without accruing branch prediction penalties.
- the complexity of the classification system described below may depend on the dimensionality of an activation vector x, the number of M portions into which the activation vector x is divided, the number of nodes K for which the classification system performs matrix multiplication, or a combination of two or more of these. For example, since these values are independent of a number of classes in an output layer of a neural network, a classification system may accommodate any number of classes in the output layer, e.g., while providing a tradeoff between time complexity and accuracy.
- FIG. 1 is an example of a classification system that uses a hash table to determine for which nodes in a particular layer y to perform matrix multiplication using an activation vector x.
- FIG. 2 is a flow diagram of a process for processing an activation vector using selected nodes in a layer to generate an output for the layer.
- FIG. 3 is a flow diagram of a process for selecting nodes in a layer using integers as input to a hash table.
- a neural network may use matrix multiplication W*x during a classification process, where x is the input from a layer and W refers to the weights of the connections to the next layer's outputs.
- W refers to the weights of the connections to the next layer's outputs.
- the use of matrix multiplication may enable large-scale classification in the order of hundreds of thousands to millions of classes, e.g., during real-time computation to provide a user with a classification value based on input received from the user.
- a deep neural network may use matrix multiplication for multi-class classification or binary classification.
- a neural network uses a winner takes all (WTA) hash method to reduce the computation time for the matrix multiplication.
- WTA winner takes all
- a classification system stores a weight matrix W of a particular neural network layer y in a hash table using the WTA function.
- the classification system computes hash codes using the activations from the previous layer x, e.g., the output values from the previous layer, and uses the hash codes to determine which nodes in the current layer y are most likely to be triggered based on the activations.
- the classification system uses the hash codes as input to the hash table to determine the nodes and then determines the corresponding weight vectors W (K) for those nodes.
- the classification system retrieves the top K of those weight vectors, e.g., from the hash table or another location in memory, with K being much smaller than the number of nodes in the particular neural network layer y, e.g., much smaller than the number of classes N in an output layer of the neural network when the particular layer is the output layer, or than the size of the weight matrix W. Since hash table lookups can be performed in O(1), in some implementations the overall speed-up that can be obtained is proportional to N/K. For instance, the classification system's computation cost may depend only on K, the number of weight vectors used for the particular layer y or the number of classes identified in an output layer, and may be independent of the total number of classes in an output layer, e.g., N.
- the classification system when a classification system classifies objects in an image or a video, the classification system may have a large number of classes, e.g., hundreds of thousands to millions, into which a given an object can be classified. For instance, the classification system may use a neural network to determine what a particular object is in an image, e.g., whether the object is a car, a truck, or a tree, with the neural network including one node in the output layer for each class into which the object can potentially be classified.
- the classification system may take the activation vector from the second to last layer in the neural network and use the values from the activation vector as input to a hash table to determine for which nodes in the output layer the computation should be performed. For instance, the classification system determines K nodes, identified in the hash table, for which to perform the computation using the activation vector as input. The classification system then uses the output from those K nodes in the output layer to determine what the object in the image is, e.g., that the object is a car.
- the classification system determines the output values for each of the K nodes and the greatest of those output values and classifies the object using the classification of the node with the greatest of the output values, e.g., without having to perform the computation for all of the nodes in the output layer.
- the classification system may perform K lookups in the hash table, or in multiple hash tables, and may determine that some of the lookups do not identify a node in the output layer. In these examples, the classification system performs the computation for less than K nodes in the output layer.
- FIG. 1 is an example of a classification system 100 that uses a hash table to determine for which nodes in a particular layer y to perform matrix multiplication using an activation vector x.
- the classification system 100 is an example of a system implemented as computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below are implemented.
- the particular layer y may be a soft-max or a logistic regression output layer in a neural network 102 .
- the matrix multiplication may be a product of the activation vector x from a previous layer in the neural network or an initial input for the neural network, e.g., when the particular layer is an input layer in the neural network, and the weights W.
- the classification system 100 may use a hashing technique, e.g., a fast locality-sensitive hashing technique, to approximate the actual matrix multiplication to determine the output for the particular layer y.
- the classification system 100 computes hash codes for the weight vectors of the weights W of the particular layer y and stores indices for the nodes in the particular layer y in a hash table 104 in indices that correspond to the hash codes. For instance, the classification system 100 trains the neural network 102 and determines the binary hash codes and the indices at which to store the indices for the nodes in the particular layer particular layer y during training, as described in more detail below.
- the classification system 100 uses an input activation vector x to determine one or more hash codes.
- the classification system 100 uses the hash codes to determine a set of nodes y k in the particular layer y that are closest to the activation vector in the hash space and computes the matrix product for x and the set of nodes y k to determine the output for the particular layer y.
- the classification system 100 may set the output values for all other nodes in the particular layer y, other than the nodes in the set of nodes y k , to zero.
- the classification system 100 maintains the order of the set of nodes y k when generating output for the particular layer y. For instance, each time the classification system 100 generates an output vector using a particular neural network, the output value for a particular node in layer y is always in the same location of an output vector.
- the classification system 100 When the number of nodes in a particular layer y of the neural network 102 is large, the classification system 100 only needs output from the K nodes with the highest probabilities of activating based on the activation vector x. For instance, when the particular layer y is an output layer, the classification system 100 only needs output for the top K classes of the output layer and can determine the top K vectors W (K) , from a weight matrix W, that have the largest dot products with the activation vector x. The classification system 100 computes the probabilities for only these K classes, and sets the probabilities of all other classes to zero.
- the classification system 100 uses, for a particular node in the particular layer y, the corresponding weight vector to compute the hash code for the particular node.
- the classification system 100 stores, in the hash table 104 , identifiers for each of the nodes in the particular layer y using the corresponding hash codes as indices.
- the classification system 100 generates the hash codes from the weight vectors once to initialize the hash table 104 before performing training using training examples.
- the classification system 100 determines a hash code for an activation vector x by permuting the elements, e.g., numerical values, of the activation vector x.
- the classification system 100 may use P distinct permutations, described in more detail below, of the activation vector x to determine the hash code for the activation vector x.
- the classification system 100 determines the K nodes with the highest probabilities of activating and stores identifiers for those K nodes in the hash table 104 at the index specified by the determined hash code.
- the classification system 100 receives an input example and provides the input example to the neural network 102 .
- the neural network 102 uses the input example as input to a first layer and processes the input example through all layers leading up to the particular layer y. For the particular layer y, the neural network 102 computes a hash code using an activation vector x generated from the previous layer, or the input example when the particular layer y is the first layer.
- the neural network 102 queries the hash table using the hash code to determine the top K nodes in the particular layer y that have the highest probability of activating given the activation vector x.
- the neural network 102 determines the weight vectors W (K) for the top K nodes and computes the probabilities for the top K nodes using the activation vector x and the weight vectors W (K) .
- the classification system 100 trains the neural network 102 using downpour stochastic gradient descent (SGD). During back-propagation, the classification system 100 only propagates gradients based on the top K nodes that were retrieved during the forward pass of the neural network 102 . The classification system 100 may update only the weight vectors for the top K nodes that were retrieved during the forward pass of the neural network 102 using an error vector for the output of the neural network 102 .
- SGD downpour stochastic gradient descent
- the classification system 100 may propagate gradients for positive output nodes, e.g., in order to always provide a positive gradient.
- the classification system 100 may update the weight vectors for the top K nodes that were retrieved during the forward pass and the positive output nodes, e.g., the output nodes that identify a correct classification of the input example.
- the classification system uses the updated weight vectors to compute updated hash codes for the top K nodes and moves the identifiers for the top K nodes, or a subset of these nodes, to the locations in the hash table 104 pointed to by the updated hash codes.
- the neural network 102 may identify the top K nodes for the input image in the output layer y as nodes that represent a truck (y 0 ) or a tree (y 3 ).
- the neural network 102 may determine that the correct classification of the input is for node y 2 which identifies the image as a car.
- the classification system 100 updates the nodes in the output layer y of the neural network 102 that classify input as a car (y 2 )—the correct classification, a truck (y 0 )—an incorrect classification, a tree (y 3 )—an incorrect classification, or two or more of these as part of the training process, by determining gradients for these nodes.
- the classification system 100 determines updated weight vectors for these nodes using the gradients.
- the classification system 100 uses the updated weight vectors to determine new hash codes for these nodes and places identifiers for these nodes in the hash table 104 at the location pointed to by the new hash codes.
- the hash table 104 includes the weight vectors for the corresponding nodes.
- the classification system 100 stores an identifier for each of the nodes, the corresponding weight vector, or both in the hash table 104 .
- the classification system 100 may use a hash code to retrieve the node identifiers and determine the corresponding weight vector, e.g., from a parameter server.
- the classification system 100 may use a hash code to retrieve the node identifiers and determine the corresponding weight vectors during run-time, e.g., using data stored with the classification system 100 .
- the classification system 100 may use the hash code to retrieve both the node identifiers and the corresponding weight vector from the hash table 104 .
- the neural network 102 uses the retrieved weight vectors to determine output for the particular layer y. For instance, when the particular layer y is an output layer of the neural network 102 , the neural network 102 determines an output value for each of the nodes identified in the hash table 104 . The neural network 102 may apply a function to the output values for each of the nodes identified in the hash table 104 to determine corresponding modified output values, e.g., the same function to each of the output values. The neural network 102 may determine a largest output value or a largest modified output value and uses the identifier for the largest output value or largest modified output value to classify the input.
- the neural network 102 or the classification system 100 determine the output values for each of the nodes identified in the hash table 104 , apply a function to the output values, and use the modified output values to create an output vector for the particular layer y.
- the classification system 100 updates some of the weight vectors during each iteration of training but not all of the weight vectors, or some of the weights in a particular vector but not all of the weights in the particular vector. For instance, when the neural network 102 incorrectly determines that an image of a car has a highest probability of being either an image of a truck, e.g., node y 0 , or an image of a tree, e.g., node y 3 , based on a hash code identifying index I 0 of the hash table 104 , the classification system 100 creates a new entry for the index I 0 that associates the index I 0 for the hash code with the node y 2 for a car classification and includes a time stamp with the entry, e.g., with a current time or a time at which the most recent training of the neural network 102 ended. Similarly, when a node's classification is correct, the classification system 100 may update an old time stamp for the entry
- the classification system 100 may update or otherwise change values of the weight vector of a node in addition to updating the time stamp associating a node with a particular index in the hash table 104 . For instance, during backward propagation, the classification system 100 may update values in the weight vector for the positive output node and update the corresponding time stamp to a current time stamp. In some examples, during backward propagation, the classification system 100 may update values in the weight vectors for incorrect output nodes and update the corresponding time stamp to a current time stamp.
- the classification system 100 may periodically remove entries in the hash table 104 that do not have a current time stamp. For instance, the classification system may update the indices in the hash table 104 to which the nodes in the particular layer y are associated, the weights for each of the nodes, or both, over the course of server hundred or thousand training iterations. The classification system 100 may remove entries in the hash table 104 that do not have a current time stamp when all nodes in the particular layer y have been updated, e.g., either the index to which the node is associated or the corresponding weight vector, or both. In some examples, the classification system 100 may remove entries in the hash table 104 that do not have a current time stamp after a predetermined number of training iterations, e.g., one thousand, or using any other appropriate method.
- a predetermined number of training iterations e.g., one thousand
- the classification system 100 receives an activation vector x and permutes the elements of the activation vector x using P distinct permutations to determine a hash code, e.g., the same P permutations used during training.
- the classification system 100 uses the hash code to determine the index of the top K nodes in the hash table 104 .
- the classification system 100 may convert each real number in the activation vector x to a binary value to create a binary vector.
- the classification system 100 converts the binary vector into an integer, e.g., by combining the binary values, and uses the integer as input to the hash table 104 , e.g., as an index value for the hash table 104 to identify one or more nodes for which to compute matrix multiplication using the activation vector x.
- the classification system 100 divides the activation vector x that contains n elements into M portions that each contain n/M elements.
- the classification system 100 determines the hash code for each portion x m of the activation vector x, using the method described above or another appropriate method, and uses the resulting hash code as an index to the corresponding hash table T m .
- the classification system 100 similarly determines the hash code for each portion x m of a corresponding activation vector x and uses the portions x m as indices to the corresponding hash tables T m to determine a set of all identifiers of the nodes for which to perform matrix multiplication.
- each hash table T m has only one entry for each index and the classification system 100 determines the set of all identifiers of the nodes using the corresponding hash codes, e.g., to determine at most M nodes.
- the hash table or hash tables 104 include only one entry for each of the nodes in the particular layer y.
- the classification system 100 may retrieve a corresponding count for each node from the hash table 104 . For instance, each count may provide a lower bound for the dot product between the activation vector x and the weight vector for the node. The count may represent the ordinal similarity between the two vectors.
- the classification system 100 may select the K nodes with the greatest ordinal similarity between the two vectors, e.g., when a greater ordinal similarity may represent a larger dot product between two vectors, and perform matrix multiplication for those nodes to determine output for the particular layer y, e.g., to determine probabilities for each classification when the particular layer y is an output layer.
- the K nodes with the greatest ordinal similarity may have weight vectors that are the nearest neighbors to the activation vector x based on dot product similarity.
- each index is represented using log(2K) bits resulting in P*log(2K) bits for the entire hash code.
- the classification system 100 uses a binary representation for the hash codes to reduce a memory footprint used by the classification system.
- the classification system 100 may use a WTA hash function that defines an ordinal embedding. For instance, as P ⁇ , the dot product between two WTA hashes tends to the rank correlation between the underlying vectors and WTA hashes are well suited as a basis for locality-sensitive hashing. This may result in a more robust proxy for dot product similarity and may be used to determine a count for each of the nodes that represents the ordinal similarity between the node and the activation vector x.
- the classification system 100 may map some of the hash codes to empty entries in the hash table 104 . For instance, the classification system 100 may divide the activation vector x into two portions and determine two hash codes that map to indices I 0 and I 1 . The classification system 100 may determine that index I 0 includes two node identifiers, one for node y 0 and one for node y 3 . The classification system 100 may determine that index I 1 does not include any node identifiers. In some examples, when the classification system 100 determines an index that does not map to any node identifiers, the classification system 100 may determine the top K nodes using M indices, when K is not equal to M, e.g., when K is less than M.
- the neural network 102 may include multiple layers for which approximate computation of matrix products is performed.
- the classification system may use a hashing technique to approximate output for both one of the hidden layers of the neural network 102 and the output layer of the neural network 102 .
- FIG. 2 is a flow diagram of a process 200 for processing an activation vector using selected nodes in a layer to generate an output for the layer.
- the process can be implemented by one or more computer programs installed on one or more computers.
- the process 200 can be used by the classification system 100 .
- Part of the process 200 e.g., steps 202 through 210
- Part of the process 200 may be performed at run-time.
- Part of the process 200 e.g., steps 202 through 216 , may be performed only during a training process.
- the classification system receives an activation vector as input for a particular layer of a neural network.
- the classification system computes a hash code for at least a portion of the activation vector.
- the classification system may divide the activation vector x into M portions and use any appropriate method to determine a hash code for each of the portions.
- the classification system determines one or more most similar hashes, in the hash table that maps numeric values to nodes in the particular layer, to the hash code of the portion of the activation vector. For example, the classification system uses each hash code m to determine a corresponding entry in a respective hash table T m and one or more node identifiers for each entry. The classification system may retrieve a weight vector from the hash table T m with the respective node identifier or may use the node identifier to retrieve the weight vector from another system, e.g., a parameter server.
- the classification system selects the nodes corresponding to the one or more host similar hashes. For instance, the classification system selects the top K nodes. In some examples, when each entry in the hash table(s) maps a single index value to a single node identifier, the classification system may determine the top K nodes when K is less than M, the number of hash codes used to access the hash table(s).
- the classification system processes the activation vector using the selected nodes to generate an output for the particular layer. For example, the classification system performs matrix multiplication using the activation vector x and the determined weight vectors and then applies a function to the result of the matrix multiplication to generate an output for each selected node and sets all other output values for the particular layer y to zero.
- the classification system determines, for at least some output values in the output, an accuracy of a respective output value. For instance, the classification system determines the accuracy of the respective output values for backward propagation as part of a training process.
- the classification system updates at least some of the mappings in the hash table using the accuracy values.
- the classification system performs backward propagation to update some of the mappings, e.g., of node identifiers to hash codes, and weight vectors while leaving other mappings, weight vectors, or a combination of both, unchanged. For instance, the classification system may leave a majority of the mappings in a hash table unchanged for each iteration of training, e.g., for each training example.
- the classification system removes old entries from the hash table. For example, the classification system periodically removes old entries from the hash table during training to reduce the time necessary for training. For instance, if the classification system removed old entries during each iteration of training, the classification system would require more time for training.
- processing the activation vector using the selected nodes in the layer to generate the output for the layer can be performed in different orders.
- the classification system may remove old entries from the hash table prior to receiving the activation vector, e.g., during a training process.
- the process 300 can include additional steps, fewer steps, or some of the steps can be divided into multiple steps.
- the classification system may perform steps 202 through 210 without performing steps 212 through 216 , e.g., during run-time.
- FIG. 3 is a flow diagram of a process 300 for selecting nodes in a layer using integers as input to a hash table.
- the process can be implemented by one or more computer programs installed on one or more computers.
- the process 300 can be used by the classification system 100 .
- the classification system converts each real number in an activation vector to a binary value to create a binary vector. For instance, the classification system rounds each real number to one or zero.
- the classification system determines multiple portions of the binary vector. For example, the classification system determines the number of binary values that should be included in each of M portions of the binary vector so that each portion has the same, or approximately the same, number of binary values. In some examples, some of the portions may have one more or one fewer binary value than some of the other portions. The classification system uses the same number of portions M and the same number of binary values in each of the respective portions during training and run-time.
- the classification system converts, for each of the portions, the binary values into an integer. For instance, the classification system uses any appropriate method to use all of the binary values in a particular portion to an integer. The classification system may use the sum of the binary values in the particular portion to determine the corresponding integer value.
- the classification system selects one or more nodes in a particular layer by using the integers as input to a hash table. For example, the classification system uses each of the integers as a hash code as an index in a corresponding hash table. The classification system may determine zero, one, or more node identifiers for each of the hash codes used as an index in a corresponding hash table.
- the classification system may determine multiple portions M of the activation vector and then convert each reach number in each of the portions, or a subset of the portions, to a binary value to create multiple binary vectors, or a single binary vector with multiple portions.
- the process 300 can include additional steps, fewer steps, or some of the steps can be divided into multiple steps.
- the classification system may perform steps 302 , 306 , and 308 without performing step 304 .
- Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non-transitory program carrier for execution by, or to control the operation of, data processing apparatus.
- the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- the computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them. The computer storage medium is not, however, a propagated signal.
- data processing apparatus encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers.
- the apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- the apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- a computer program (which may also be referred to or described as a program, software, a software application, a module, a software module, a script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.
- a computer program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub-programs, or portions of code.
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- an “engine,” or “software engine,” refers to a software implemented input/output system that provides an output that is different from the input.
- An engine can be an encoded block of functionality, such as a library, a platform, a software development kit (“SDK”), or an object.
- SDK software development kit
- Each engine can be implemented on any appropriate type of computing device, e.g., servers, mobile phones, tablet computers, notebook computers, music players, e-book readers, laptop or desktop computers, PDAs, smart phones, or other stationary or portable devices, that includes one or more processors and computer readable media. Additionally, two or more of the engines may be implemented on the same computing device, or on different computing devices.
- the processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output.
- the processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- special purpose logic circuitry e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit.
- a central processing unit will receive instructions and data from a read-only memory or a random access memory or both.
- the essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
- PDA personal digital assistant
- GPS Global Positioning System
- USB universal serial bus
- Computer-readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks
- magneto-optical disks e.g., CD-ROM and DVD-ROM disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), e.g., the Internet.
- LAN local area network
- WAN wide area network
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network.
- the relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
Abstract
Description
- This application is a continuation of U.S. application Ser. No. 14/933,256, filed Nov. 5, 2015, which claims the benefit of U.S. Provisional Application No. 62/094,768, filed on Dec. 19, 2014, the contents of each are incorporated herein by reference.
- This specification relates to image recognition using neural networks.
- Deep neural networks with several levels and hierarchies of features may have very large learning capacity and be used in speech or image recognition. Deep neural networks typically have several layers of units connected in a feed-forward fashion between the input and output spaces. Each layer in a deep neural network may perform a specific function, e.g., convolution, pooling, normalization, or matrix multiplication and non-linear activation.
- In some implementations, a system uses matrix multiplication to determine an output for a particular layer in a neural network. For instance, the matrix multiplication is a combination of an activation vector, e.g., input for the particular layer, and a weight matrix, e.g., the weights for some of the nodes in the particular layer. The neural network uses a fast locality-sensitive hashing technique to approximate a result of the matrix multiplication to allow the neural network to generate scores for a large number, e.g., millions, of output classes.
- When a neural network uses a hashing technique, the neural network may approximate computation of a matrix product of weights W for a particular layer in the neural network and an activation vector x so that the number nodes in the particular layer, e.g., output dimensions, can be increased by several orders of magnitude. In some examples, the particular layer may be an output layer in a neural network, e.g., a final classification layer, which is used to determine a classification of an input to the neural network.
- In general, one innovative aspect of the subject matter described in this specification can be embodied in methods for processing an input through each of multiple layers of a neural network to generate an output, wherein each of the multiple layers of the neural network includes respective multiple nodes include the actions of for a particular layer of the multiple layers: receiving, by a classification system, an activation vector as input for the particular layer, selecting one or more nodes in the particular layer using the activation vector and a hash table that maps numeric values to nodes in the particular layer, and processing the activation vector using the selected nodes to generate an output for the particular layer. Other embodiments of this aspect include corresponding computer systems, apparatus, and computer programs recorded on one or more computer storage devices, each configured to perform the actions of the methods. A system of one or more computers can be configured to perform particular operations or actions by virtue of having software, firmware, hardware, or a combination of them installed on the system that in operation causes or cause the system to perform the actions. One or more computer programs can be configured to perform particular operations or actions by virtue of including instructions that, when executed by a data processing apparatus, cause the apparatus to perform the actions.
- The foregoing and other embodiments can each optionally include one or more of the following features, alone or in combination. The method may include creating a modified activation vector by setting the values in the activation vector that correspond to the nodes that were not selected to zero. Processing the activation vector using the selected nodes to generate the output for the particular layer may include processing the modified activation vector to generate the output for the particular layer. The hash table stores, for each of the nodes of the particular layer, a respective hash of weight values of the node. Selecting the one or more nodes may include computing a hash code for at least a portion of the activation vector, determining one or more most similar hashes in the hash table to the hash code of the portion of the activation vector, and selecting the nodes corresponding to the one or more most similar hashes. The hash table stores, for each of the nodes of the particular layer, a respective node identifier of the node.
- In some implementations, the activation vector includes real number values. The method may include converting each of the real numbers in the activation vector to binary values to create a binary vector, determining multiple portions of the binary vector, and converting, for each of the portions, the binary values in the respective portion into an integer. Selecting the nodes in the particular layer using the activation vector and the hash table may include selecting the one or more nodes in the particular layer by using the integers as input to the hash table. The integers may include a first subset and a second, mutually exclusive subset. Selecting the one or more nodes in the particular layer by using the integers as input to the hash table may include determining, for each of the integers in the first subset, that the hash table does not include a corresponding first entry for a node, determining, for each of the integers in the second subset, that the hash table includes a corresponding second entry for a node, and selecting the one or more nodes in the particular layer as the nodes identified by the second entries. Determining, for each of the integers in the first subset, that the hash table does not include a corresponding first entry for a node may include determining, for at least some of the integers in the first subset, that the hash table does not include a corresponding first entry with a current time stamp. The method may include determining, for at least some output values in the output, an accuracy value of a respective output value, and updating at least some of the mappings in the hash table using the accuracy values by updating time stamps for a first node entry in the hash table for a particular node in the particular layer and not updating time stamps for a second node entry in the hash table that does not correspond to any nodes in the particular layer. The method may include determining, by the classification system, old entries in the hash table that have an old timestamp, and removing the old entries from the hash table.
- In some implementations, the particular layer may include an output layer of the neural network. The method may include determining a best output value from the output for the particular layer, and using the best output value as output for the neural network. The classification system may be an image classification system. Each of the nodes in the output layer may correspond to a respective object class. The method may include receiving an image, and using the image as input to the neural network. Using the best output value as output for the neural network may include classifying an object in the image as belonging to the class corresponding to the node that generated the best output value. Receiving the image may include receiving, from a device, data identifying the image, and using the image as input to the neural network may include using, by the classification system on another device, the image as input to the neural network in response to receiving the data identifying the image.
- The subject matter described in this specification can be implemented in particular embodiments and may result in one or more of the following advantages. In some implementations, a classification system may train large scale neural networks at a faster rate, e.g., in terms of number of steps, total time, or both, compared to other systems that do not use the methods described below, e.g., standard soft-max layers or hierarchical soft-max layers. In some implementations, a classification system's computation cost may depend only on K, the number of weight vectors used or the number of classes identified in an output layer, and may be independent of the total number of classes in an output layer of a neural network. In some implementations, a classification system may classify objects using on the order of hundreds of thousands to millions of classes with approximately the same computational cost of a classification system, e.g., a conventional deep neural network, with a few thousands of classes. In some implementations, a classification system may be used to train large scale neural networks, e.g., using additional data structures. For instance, the classification system may include an inverted hash table with timestamps for keeping track of, and updating, the hash table as the weight matrix is continuously updated during the training process.
- In some implementations, a classification system with a neural network that has N classes in an output layer and that selects at most the top K weight vectors for the classes in the output layer may have an improved speed of N/K compared to other classification systems that do not use a hash table in the same manner. In some implementations, a classification system only performs comparisons when computing a hash code, e.g., which allows the classification system to determine the hash code using integer arithmetic. In some implementations, a classification system computes a hash code without accruing branch prediction penalties. In some implementations, the complexity of the classification system described below may depend on the dimensionality of an activation vector x, the number of M portions into which the activation vector x is divided, the number of nodes K for which the classification system performs matrix multiplication, or a combination of two or more of these. For example, since these values are independent of a number of classes in an output layer of a neural network, a classification system may accommodate any number of classes in the output layer, e.g., while providing a tradeoff between time complexity and accuracy.
- The details of one or more embodiments of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
-
FIG. 1 is an example of a classification system that uses a hash table to determine for which nodes in a particular layer y to perform matrix multiplication using an activation vector x. -
FIG. 2 is a flow diagram of a process for processing an activation vector using selected nodes in a layer to generate an output for the layer. -
FIG. 3 is a flow diagram of a process for selecting nodes in a layer using integers as input to a hash table. - Like reference numbers and designations in the various drawings indicate like elements.
- This specification describes a method for neural networks, e.g., deep neural networks, that enables approximate computation of matrix products at various layers so that the number of output dimensions at a particular layer in the neural network can be increased by several orders of magnitude, while keeping the computation cost about the same and with little loss in accuracy. For instance, a neural network may use matrix multiplication W*x during a classification process, where x is the input from a layer and W refers to the weights of the connections to the next layer's outputs. The use of matrix multiplication may enable large-scale classification in the order of hundreds of thousands to millions of classes, e.g., during real-time computation to provide a user with a classification value based on input received from the user. In some examples, a deep neural network may use matrix multiplication for multi-class classification or binary classification.
- In some implementations, a neural network uses a winner takes all (WTA) hash method to reduce the computation time for the matrix multiplication. For instance, a classification system stores a weight matrix W of a particular neural network layer y in a hash table using the WTA function. At run-time, the classification system computes hash codes using the activations from the previous layer x, e.g., the output values from the previous layer, and uses the hash codes to determine which nodes in the current layer y are most likely to be triggered based on the activations. For instance, the classification system uses the hash codes as input to the hash table to determine the nodes and then determines the corresponding weight vectors W(K) for those nodes.
- The classification system retrieves the top K of those weight vectors, e.g., from the hash table or another location in memory, with K being much smaller than the number of nodes in the particular neural network layer y, e.g., much smaller than the number of classes N in an output layer of the neural network when the particular layer is the output layer, or than the size of the weight matrix W. Since hash table lookups can be performed in O(1), in some implementations the overall speed-up that can be obtained is proportional to N/K. For instance, the classification system's computation cost may depend only on K, the number of weight vectors used for the particular layer y or the number of classes identified in an output layer, and may be independent of the total number of classes in an output layer, e.g., N.
- In one example, when a classification system classifies objects in an image or a video, the classification system may have a large number of classes, e.g., hundreds of thousands to millions, into which a given an object can be classified. For instance, the classification system may use a neural network to determine what a particular object is in an image, e.g., whether the object is a car, a truck, or a tree, with the neural network including one node in the output layer for each class into which the object can potentially be classified.
- To reduce the number of computations performed, the classification system may take the activation vector from the second to last layer in the neural network and use the values from the activation vector as input to a hash table to determine for which nodes in the output layer the computation should be performed. For instance, the classification system determines K nodes, identified in the hash table, for which to perform the computation using the activation vector as input. The classification system then uses the output from those K nodes in the output layer to determine what the object in the image is, e.g., that the object is a car. For example, the classification system determines the output values for each of the K nodes and the greatest of those output values and classifies the object using the classification of the node with the greatest of the output values, e.g., without having to perform the computation for all of the nodes in the output layer.
- In some examples, the classification system may perform K lookups in the hash table, or in multiple hash tables, and may determine that some of the lookups do not identify a node in the output layer. In these examples, the classification system performs the computation for less than K nodes in the output layer.
-
FIG. 1 is an example of aclassification system 100 that uses a hash table to determine for which nodes in a particular layer y to perform matrix multiplication using an activation vector x. Theclassification system 100 is an example of a system implemented as computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below are implemented. For example, the particular layer y may be a soft-max or a logistic regression output layer in aneural network 102. The matrix multiplication may be a product of the activation vector x from a previous layer in the neural network or an initial input for the neural network, e.g., when the particular layer is an input layer in the neural network, and the weights W. Theclassification system 100 may use a hashing technique, e.g., a fast locality-sensitive hashing technique, to approximate the actual matrix multiplication to determine the output for the particular layer y. - The
classification system 100 computes hash codes for the weight vectors of the weights W of the particular layer y and stores indices for the nodes in the particular layer y in a hash table 104 in indices that correspond to the hash codes. For instance, theclassification system 100 trains theneural network 102 and determines the binary hash codes and the indices at which to store the indices for the nodes in the particular layer particular layer y during training, as described in more detail below. - The
classification system 100 uses an input activation vector x to determine one or more hash codes. Theclassification system 100 uses the hash codes to determine a set of nodes yk in the particular layer y that are closest to the activation vector in the hash space and computes the matrix product for x and the set of nodes yk to determine the output for the particular layer y. Theclassification system 100 may set the output values for all other nodes in the particular layer y, other than the nodes in the set of nodes yk, to zero. - The
classification system 100 maintains the order of the set of nodes yk when generating output for the particular layer y. For instance, each time theclassification system 100 generates an output vector using a particular neural network, the output value for a particular node in layer y is always in the same location of an output vector. - When the number of nodes in a particular layer y of the
neural network 102 is large, theclassification system 100 only needs output from the K nodes with the highest probabilities of activating based on the activation vector x. For instance, when the particular layer y is an output layer, theclassification system 100 only needs output for the top K classes of the output layer and can determine the top K vectors W(K), from a weight matrix W, that have the largest dot products with the activation vector x. Theclassification system 100 computes the probabilities for only these K classes, and sets the probabilities of all other classes to zero. - During initialization of training, the
classification system 100 uses, for a particular node in the particular layer y, the corresponding weight vector to compute the hash code for the particular node. Theclassification system 100 stores, in the hash table 104, identifiers for each of the nodes in the particular layer y using the corresponding hash codes as indices. Theclassification system 100 generates the hash codes from the weight vectors once to initialize the hash table 104 before performing training using training examples. - During training, the
classification system 100 determines a hash code for an activation vector x by permuting the elements, e.g., numerical values, of the activation vector x. Theclassification system 100 may use P distinct permutations, described in more detail below, of the activation vector x to determine the hash code for the activation vector x. Theclassification system 100 determines the K nodes with the highest probabilities of activating and stores identifiers for those K nodes in the hash table 104 at the index specified by the determined hash code. - The
classification system 100 receives an input example and provides the input example to theneural network 102. Theneural network 102 uses the input example as input to a first layer and processes the input example through all layers leading up to the particular layer y. For the particular layer y, theneural network 102 computes a hash code using an activation vector x generated from the previous layer, or the input example when the particular layer y is the first layer. Theneural network 102 queries the hash table using the hash code to determine the top K nodes in the particular layer y that have the highest probability of activating given the activation vector x. Theneural network 102 determines the weight vectors W(K) for the top K nodes and computes the probabilities for the top K nodes using the activation vector x and the weight vectors W(K). - In some implementations, the
classification system 100 trains theneural network 102 using downpour stochastic gradient descent (SGD). During back-propagation, theclassification system 100 only propagates gradients based on the top K nodes that were retrieved during the forward pass of theneural network 102. Theclassification system 100 may update only the weight vectors for the top K nodes that were retrieved during the forward pass of theneural network 102 using an error vector for the output of theneural network 102. - In some examples, when the particular layer y is an output layer, the
classification system 100 may propagate gradients for positive output nodes, e.g., in order to always provide a positive gradient. In these examples, theclassification system 100 may update the weight vectors for the top K nodes that were retrieved during the forward pass and the positive output nodes, e.g., the output nodes that identify a correct classification of the input example. The classification system uses the updated weight vectors to compute updated hash codes for the top K nodes and moves the identifiers for the top K nodes, or a subset of these nodes, to the locations in the hash table 104 pointed to by the updated hash codes. - For instance, when the
neural network 102 receives an image of a car as input, theneural network 102 may identify the top K nodes for the input image in the output layer y as nodes that represent a truck (y0) or a tree (y3). Theneural network 102 may determine that the correct classification of the input is for node y2 which identifies the image as a car. Theclassification system 100 updates the nodes in the output layer y of theneural network 102 that classify input as a car (y2)—the correct classification, a truck (y0)—an incorrect classification, a tree (y3)—an incorrect classification, or two or more of these as part of the training process, by determining gradients for these nodes. Theclassification system 100 determines updated weight vectors for these nodes using the gradients. Theclassification system 100 uses the updated weight vectors to determine new hash codes for these nodes and places identifiers for these nodes in the hash table 104 at the location pointed to by the new hash codes. - In some implementations, the hash table 104 includes the weight vectors for the corresponding nodes. For instance, when creating the hash table 104, the
classification system 100 stores an identifier for each of the nodes, the corresponding weight vector, or both in the hash table 104. During training theclassification system 100 may use a hash code to retrieve the node identifiers and determine the corresponding weight vector, e.g., from a parameter server. Theclassification system 100 may use a hash code to retrieve the node identifiers and determine the corresponding weight vectors during run-time, e.g., using data stored with theclassification system 100. In some examples, theclassification system 100 may use the hash code to retrieve both the node identifiers and the corresponding weight vector from the hash table 104. - The
neural network 102 uses the retrieved weight vectors to determine output for the particular layer y. For instance, when the particular layer y is an output layer of theneural network 102, theneural network 102 determines an output value for each of the nodes identified in the hash table 104. Theneural network 102 may apply a function to the output values for each of the nodes identified in the hash table 104 to determine corresponding modified output values, e.g., the same function to each of the output values. Theneural network 102 may determine a largest output value or a largest modified output value and uses the identifier for the largest output value or largest modified output value to classify the input. In some examples, when the particular layer y is not an output layer, e.g., and is a first layer or a hidden layer, theneural network 102 or theclassification system 100 determine the output values for each of the nodes identified in the hash table 104, apply a function to the output values, and use the modified output values to create an output vector for the particular layer y. - In some implementations, the
classification system 100 updates some of the weight vectors during each iteration of training but not all of the weight vectors, or some of the weights in a particular vector but not all of the weights in the particular vector. For instance, when theneural network 102 incorrectly determines that an image of a car has a highest probability of being either an image of a truck, e.g., node y0, or an image of a tree, e.g., node y3, based on a hash code identifying index I0 of the hash table 104, theclassification system 100 creates a new entry for the index I0 that associates the index I0 for the hash code with the node y2 for a car classification and includes a time stamp with the entry, e.g., with a current time or a time at which the most recent training of theneural network 102 ended. Similarly, when a node's classification is correct, theclassification system 100 may update an old time stamp for the entry in the hash table 104 with the current time. - In some examples, the
classification system 100 may update or otherwise change values of the weight vector of a node in addition to updating the time stamp associating a node with a particular index in the hash table 104. For instance, during backward propagation, theclassification system 100 may update values in the weight vector for the positive output node and update the corresponding time stamp to a current time stamp. In some examples, during backward propagation, theclassification system 100 may update values in the weight vectors for incorrect output nodes and update the corresponding time stamp to a current time stamp. - The
classification system 100 may periodically remove entries in the hash table 104 that do not have a current time stamp. For instance, the classification system may update the indices in the hash table 104 to which the nodes in the particular layer y are associated, the weights for each of the nodes, or both, over the course of server hundred or thousand training iterations. Theclassification system 100 may remove entries in the hash table 104 that do not have a current time stamp when all nodes in the particular layer y have been updated, e.g., either the index to which the node is associated or the corresponding weight vector, or both. In some examples, theclassification system 100 may remove entries in the hash table 104 that do not have a current time stamp after a predetermined number of training iterations, e.g., one thousand, or using any other appropriate method. - During run-time, the
classification system 100 receives an activation vector x and permutes the elements of the activation vector x using P distinct permutations to determine a hash code, e.g., the same P permutations used during training. Theclassification system 100 uses the hash code to determine the index of the top K nodes in the hash table 104. - For instance, the
classification system 100 may convert each real number in the activation vector x to a binary value to create a binary vector. Theclassification system 100 converts the binary vector into an integer, e.g., by combining the binary values, and uses the integer as input to the hash table 104, e.g., as an index value for the hash table 104 to identify one or more nodes for which to compute matrix multiplication using the activation vector x. - In some implementations, during training and run-time, the
classification system 100 divides the activation vector x that contains n elements into M portions that each contain n/M elements. Theclassification system 100, during training, creates a hash table 104 for each portion, {Tm:m=1 . . . M}. For instance, theclassification system 100 determines the hash code for each portion xm of the activation vector x, using the method described above or another appropriate method, and uses the resulting hash code as an index to the corresponding hash table Tm. - During run-time, the
classification system 100 similarly determines the hash code for each portion xm of a corresponding activation vector x and uses the portions xm as indices to the corresponding hash tables Tm to determine a set of all identifiers of the nodes for which to perform matrix multiplication. In some examples, each hash table Tm has only one entry for each index and theclassification system 100 determines the set of all identifiers of the nodes using the corresponding hash codes, e.g., to determine at most M nodes. In some examples, the hash table or hash tables 104 include only one entry for each of the nodes in the particular layer y. - In some implementations, the
classification system 100 may retrieve a corresponding count for each node from the hash table 104. For instance, each count may provide a lower bound for the dot product between the activation vector x and the weight vector for the node. The count may represent the ordinal similarity between the two vectors. Theclassification system 100 may select the K nodes with the greatest ordinal similarity between the two vectors, e.g., when a greater ordinal similarity may represent a larger dot product between two vectors, and perform matrix multiplication for those nodes to determine output for the particular layer y, e.g., to determine probabilities for each classification when the particular layer y is an output layer. For example, the K nodes with the greatest ordinal similarity may have weight vectors that are the nearest neighbors to the activation vector x based on dot product similarity. - In some examples, when the
classification system 100 uses P distinct permutations, each index is represented using log(2K) bits resulting in P*log(2K) bits for the entire hash code. In some implementations, theclassification system 100 uses a binary representation for the hash codes to reduce a memory footprint used by the classification system. In some implementations, theclassification system 100 may use a WTA hash function that defines an ordinal embedding. For instance, as P→∞, the dot product between two WTA hashes tends to the rank correlation between the underlying vectors and WTA hashes are well suited as a basis for locality-sensitive hashing. This may result in a more robust proxy for dot product similarity and may be used to determine a count for each of the nodes that represents the ordinal similarity between the node and the activation vector x. - In some implementations, the
classification system 100 may map some of the hash codes to empty entries in the hash table 104. For instance, theclassification system 100 may divide the activation vector x into two portions and determine two hash codes that map to indices I0 and I1. Theclassification system 100 may determine that index I0 includes two node identifiers, one for node y0 and one for node y3. Theclassification system 100 may determine that index I1 does not include any node identifiers. In some examples, when theclassification system 100 determines an index that does not map to any node identifiers, theclassification system 100 may determine the top K nodes using M indices, when K is not equal to M, e.g., when K is less than M. - In some implementations, the
neural network 102 may include multiple layers for which approximate computation of matrix products is performed. For instance, the classification system may use a hashing technique to approximate output for both one of the hidden layers of theneural network 102 and the output layer of theneural network 102. -
FIG. 2 is a flow diagram of aprocess 200 for processing an activation vector using selected nodes in a layer to generate an output for the layer. The process can be implemented by one or more computer programs installed on one or more computers. For example, theprocess 200 can be used by theclassification system 100. Part of theprocess 200, e.g., steps 202 through 210, may be performed at run-time. Part of theprocess 200, e.g., steps 202 through 216, may be performed only during a training process. - At 202, the classification system receives an activation vector as input for a particular layer of a neural network.
- At 204, the classification system computes a hash code for at least a portion of the activation vector. The classification system may divide the activation vector x into M portions and use any appropriate method to determine a hash code for each of the portions.
- At 206, the classification system determines one or more most similar hashes, in the hash table that maps numeric values to nodes in the particular layer, to the hash code of the portion of the activation vector. For example, the classification system uses each hash code m to determine a corresponding entry in a respective hash table Tm and one or more node identifiers for each entry. The classification system may retrieve a weight vector from the hash table Tm with the respective node identifier or may use the node identifier to retrieve the weight vector from another system, e.g., a parameter server.
- At 208, the classification system selects the nodes corresponding to the one or more host similar hashes. For instance, the classification system selects the top K nodes. In some examples, when each entry in the hash table(s) maps a single index value to a single node identifier, the classification system may determine the top K nodes when K is less than M, the number of hash codes used to access the hash table(s).
- At 210, the classification system processes the activation vector using the selected nodes to generate an output for the particular layer. For example, the classification system performs matrix multiplication using the activation vector x and the determined weight vectors and then applies a function to the result of the matrix multiplication to generate an output for each selected node and sets all other output values for the particular layer y to zero.
- As part of a training process, at 212, the classification system determines, for at least some output values in the output, an accuracy of a respective output value. For instance, the classification system determines the accuracy of the respective output values for backward propagation as part of a training process.
- As part of a training process, at 214, the classification system updates at least some of the mappings in the hash table using the accuracy values. The classification system performs backward propagation to update some of the mappings, e.g., of node identifiers to hash codes, and weight vectors while leaving other mappings, weight vectors, or a combination of both, unchanged. For instance, the classification system may leave a majority of the mappings in a hash table unchanged for each iteration of training, e.g., for each training example.
- As part of a training process, at 216, the classification system removes old entries from the hash table. For example, the classification system periodically removes old entries from the hash table during training to reduce the time necessary for training. For instance, if the classification system removed old entries during each iteration of training, the classification system would require more time for training.
- The order of steps in the
process 200 described above is illustrative only, and processing the activation vector using the selected nodes in the layer to generate the output for the layer can be performed in different orders. For example, the classification system may remove old entries from the hash table prior to receiving the activation vector, e.g., during a training process. - In some implementations, the process 300 can include additional steps, fewer steps, or some of the steps can be divided into multiple steps. For example, the classification system may perform
steps 202 through 210 without performingsteps 212 through 216, e.g., during run-time. -
FIG. 3 is a flow diagram of a process 300 for selecting nodes in a layer using integers as input to a hash table. The process can be implemented by one or more computer programs installed on one or more computers. For example, the process 300 can be used by theclassification system 100. - At 302, the classification system converts each real number in an activation vector to a binary value to create a binary vector. For instance, the classification system rounds each real number to one or zero.
- At 304, the classification system determines multiple portions of the binary vector. For example, the classification system determines the number of binary values that should be included in each of M portions of the binary vector so that each portion has the same, or approximately the same, number of binary values. In some examples, some of the portions may have one more or one fewer binary value than some of the other portions. The classification system uses the same number of portions M and the same number of binary values in each of the respective portions during training and run-time.
- At 306, the classification system converts, for each of the portions, the binary values into an integer. For instance, the classification system uses any appropriate method to use all of the binary values in a particular portion to an integer. The classification system may use the sum of the binary values in the particular portion to determine the corresponding integer value.
- At 308, the classification system selects one or more nodes in a particular layer by using the integers as input to a hash table. For example, the classification system uses each of the integers as a hash code as an index in a corresponding hash table. The classification system may determine zero, one, or more node identifiers for each of the hash codes used as an index in a corresponding hash table.
- The order of steps in the process 300 described above is illustrative only, and selecting nodes in the layer using integers as input to the hash table can be performed in different orders. For example, the classification system may determine multiple portions M of the activation vector and then convert each reach number in each of the portions, or a subset of the portions, to a binary value to create multiple binary vectors, or a single binary vector with multiple portions.
- In some implementations, the process 300 can include additional steps, fewer steps, or some of the steps can be divided into multiple steps. For example, the classification system may perform
steps step 304. - Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non-transitory program carrier for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them. The computer storage medium is not, however, a propagated signal.
- The term “data processing apparatus” encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
- A computer program (which may also be referred to or described as a program, software, a software application, a module, a software module, a script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub-programs, or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- As used in this specification, an “engine,” or “software engine,” refers to a software implemented input/output system that provides an output that is different from the input. An engine can be an encoded block of functionality, such as a library, a platform, a software development kit (“SDK”), or an object. Each engine can be implemented on any appropriate type of computing device, e.g., servers, mobile phones, tablet computers, notebook computers, music players, e-book readers, laptop or desktop computers, PDAs, smart phones, or other stationary or portable devices, that includes one or more processors and computer readable media. Additionally, two or more of the engines may be implemented on the same computing device, or on different computing devices.
- The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit. Generally, a central processing unit will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.
- Computer-readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's client device in response to requests received from the web browser.
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), e.g., the Internet.
- The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
- Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
- Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.
Claims (22)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/656,192 US10049305B2 (en) | 2014-12-19 | 2017-07-21 | Large-scale classification in neural networks using hashing |
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201462094768P | 2014-12-19 | 2014-12-19 | |
US14/933,256 US9721190B2 (en) | 2014-12-19 | 2015-11-05 | Large-scale classification in neural networks using hashing |
US15/656,192 US10049305B2 (en) | 2014-12-19 | 2017-07-21 | Large-scale classification in neural networks using hashing |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/933,256 Continuation US9721190B2 (en) | 2014-12-19 | 2015-11-05 | Large-scale classification in neural networks using hashing |
Publications (2)
Publication Number | Publication Date |
---|---|
US20170323183A1 true US20170323183A1 (en) | 2017-11-09 |
US10049305B2 US10049305B2 (en) | 2018-08-14 |
Family
ID=54770857
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/933,256 Active 2035-11-12 US9721190B2 (en) | 2014-12-19 | 2015-11-05 | Large-scale classification in neural networks using hashing |
US15/656,192 Active US10049305B2 (en) | 2014-12-19 | 2017-07-21 | Large-scale classification in neural networks using hashing |
Family Applications Before (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/933,256 Active 2035-11-12 US9721190B2 (en) | 2014-12-19 | 2015-11-05 | Large-scale classification in neural networks using hashing |
Country Status (3)
Country | Link |
---|---|
US (2) | US9721190B2 (en) |
EP (1) | EP3035250B1 (en) |
CN (1) | CN105719001B (en) |
Families Citing this family (71)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9536293B2 (en) * | 2014-07-30 | 2017-01-03 | Adobe Systems Incorporated | Image assessment using deep convolutional neural networks |
US9953425B2 (en) | 2014-07-30 | 2018-04-24 | Adobe Systems Incorporated | Learning image categorization using related attributes |
US9721190B2 (en) * | 2014-12-19 | 2017-08-01 | Google Inc. | Large-scale classification in neural networks using hashing |
US11275747B2 (en) * | 2015-03-12 | 2022-03-15 | Yahoo Assets Llc | System and method for improved server performance for a deep feature based coarse-to-fine fast search |
US9633306B2 (en) * | 2015-05-07 | 2017-04-25 | Siemens Healthcare Gmbh | Method and system for approximating deep neural networks for anatomical object detection |
EP3535704A1 (en) * | 2016-11-04 | 2019-09-11 | Google LLC | Mixture of experts neural networks |
KR20180060257A (en) * | 2016-11-28 | 2018-06-07 | 삼성전자주식회사 | Metohd and apparatus for object recognition |
CN106557332A (en) * | 2016-11-30 | 2017-04-05 | 上海寒武纪信息科技有限公司 | A kind of multiplexing method and device of instruction generating process |
US10373049B2 (en) * | 2016-12-20 | 2019-08-06 | Google Llc | Generating an output for a neural network output layer |
US10621349B2 (en) * | 2017-01-24 | 2020-04-14 | Cylance Inc. | Detection of malware using feature hashing |
WO2018184194A1 (en) * | 2017-04-07 | 2018-10-11 | Intel Corporation | Methods and systems using improved convolutional neural networks for image processing |
US10417734B2 (en) | 2017-04-24 | 2019-09-17 | Intel Corporation | Compute optimization mechanism for deep neural networks |
US10417731B2 (en) | 2017-04-24 | 2019-09-17 | Intel Corporation | Compute optimization mechanism for deep neural networks |
US20190138511A1 (en) * | 2017-05-15 | 2019-05-09 | Adnomus, Inc. | Systems and methods for real-time data processing analytics engine with artificial intelligence for content characterization |
US11531859B2 (en) | 2017-08-08 | 2022-12-20 | Samsung Electronics Co., Ltd. | System and method for hashed compressed weighting matrix in neural networks |
EP3679524A4 (en) * | 2017-09-05 | 2020-10-28 | Panasonic Intellectual Property Corporation of America | Execution method, execution device, learning method, learning device, and program for deep neural network |
WO2019081705A1 (en) * | 2017-10-27 | 2019-05-02 | Deepmind Technologies Limited | Using hierarchical representations for neural network architecture searching |
JP7043596B2 (en) * | 2017-10-27 | 2022-03-29 | グーグル エルエルシー | Neural architecture search |
US11288297B2 (en) * | 2017-11-29 | 2022-03-29 | Oracle International Corporation | Explicit semantic analysis-based large-scale classification |
CN107835073B (en) * | 2017-12-15 | 2019-05-17 | 卫盈联信息技术（深圳）有限公司 | The encryption and decryption method of multiple digital bits number and encryption, decryption server |
US11157745B2 (en) * | 2018-02-20 | 2021-10-26 | Scenera, Inc. | Automated proximity discovery of networked cameras |
EP3738081A1 (en) * | 2018-03-22 | 2020-11-18 | Amazon Technologies Inc. | Processing for multiple input data sets |
US11468024B2 (en) * | 2018-03-27 | 2022-10-11 | Sap Se | Structural data matching using neural network encoders |
US11314537B2 (en) * | 2018-04-30 | 2022-04-26 | Bank Of America Corporation | Computer architecture for establishing data encryption in a correlithm object processing system |
US10983786B2 (en) * | 2018-08-20 | 2021-04-20 | Accenture Global Solutions Limited | Automatically evaluating software project requirements |
US10725753B2 (en) * | 2018-11-26 | 2020-07-28 | Sap Se | Compiler for context-dependent code global data types |
US11710034B2 (en) * | 2019-02-27 | 2023-07-25 | Intel Corporation | Misuse index for explainable artificial intelligence in computing environments |
US11080364B2 (en) | 2019-03-11 | 2021-08-03 | Bank Of America Corporation | Computer architecture for performing error detection and correction using demultiplexers and multiplexers in a correlithm object processing system |
US10915344B2 (en) * | 2019-03-11 | 2021-02-09 | Bank Of America Corporation | Computer architecture for emulating coding in a correlithm object processing system |
US10990649B2 (en) | 2019-03-11 | 2021-04-27 | Bank Of America Corporation | Computer architecture for emulating a string correlithm object velocity detector in a correlithm object processing system |
US10949494B2 (en) | 2019-03-11 | 2021-03-16 | Bank Of America Corporation | Computer architecture for emulating a correlithm object processing system using mobile correlithm object devices |
US11003735B2 (en) | 2019-03-11 | 2021-05-11 | Bank Of America Corporation | Computer architecture for emulating recording and playback in a correlithm object processing system |
US11036825B2 (en) | 2019-03-11 | 2021-06-15 | Bank Of America Corporation | Computer architecture for maintaining a distance metric across correlithm objects in a correlithm object processing system |
US11100120B2 (en) | 2019-03-11 | 2021-08-24 | Bank Of America Corporation | Computer architecture for performing error detection and correction in a correlithm object processing system |
US11036826B2 (en) | 2019-03-11 | 2021-06-15 | Bank Of America Corporation | Computer architecture for emulating a correlithm object processing system with transparency |
US10949495B2 (en) | 2019-03-11 | 2021-03-16 | Bank Of America Corporation | Computer architecture for emulating a correlithm object processing system with traceability |
US10915345B2 (en) * | 2019-04-11 | 2021-02-09 | Bank Of America Corporation | Computer architecture for emulating intersecting multiple string correlithm objects in a correlithm object processing system |
US11263290B2 (en) | 2019-04-11 | 2022-03-01 | Bank Of America Corporation | Computer architecture for emulating a bidirectional string correlithm object generator in a correlithm object processing system |
US11250104B2 (en) | 2019-04-11 | 2022-02-15 | Bank Of America Corporation | Computer architecture for emulating a quadrilateral lattice correlithm object generator in a correlithm object processing system |
US11094047B2 (en) | 2019-04-11 | 2021-08-17 | Bank Of America Corporation | Computer architecture for emulating an irregular lattice correlithm object generator in a correlithm object processing system |
US10929158B2 (en) * | 2019-04-11 | 2021-02-23 | Bank Of America Corporation | Computer architecture for emulating a link node in a correlithm object processing system |
US11107003B2 (en) | 2019-04-11 | 2021-08-31 | Bank Of America Corporation | Computer architecture for emulating a triangle lattice correlithm object generator in a correlithm object processing system |
US11055120B2 (en) | 2019-05-07 | 2021-07-06 | Bank Of America Corporation | Computer architecture for emulating a control node in conjunction with stimulus conditions in a correlithm object processing system |
US10990424B2 (en) | 2019-05-07 | 2021-04-27 | Bank Of America Corporation | Computer architecture for emulating a node in conjunction with stimulus conditions in a correlithm object processing system |
US10922109B2 (en) * | 2019-05-14 | 2021-02-16 | Bank Of America Corporation | Computer architecture for emulating a node in a correlithm object processing system |
CN110162403B (en) * | 2019-05-28 | 2021-07-13 | 首都师范大学 | Hardware resource allocation method and system based on artificial neural network |
US11676034B2 (en) * | 2019-06-27 | 2023-06-13 | The Nielsen Company (Us), Llc | Initialization of classification layers in neural networks |
US11334760B2 (en) | 2019-07-24 | 2022-05-17 | Bank Of America Corporation | Computer architecture for mapping correlithm objects to sequential values in a correlithm object processing system |
US11301544B2 (en) | 2019-07-24 | 2022-04-12 | Bank Of America Corporation | Computer architecture for performing inversion using correlithm objects in a correlithm object processing system |
US11468259B2 (en) | 2019-07-24 | 2022-10-11 | Bank Of America Corporation | Computer architecture for performing division using correlithm objects in a correlithm object processing system |
US10936348B2 (en) * | 2019-07-24 | 2021-03-02 | Bank Of America Corporation | Computer architecture for performing subtraction using correlithm objects in a correlithm object processing system |
US11250293B2 (en) | 2019-07-24 | 2022-02-15 | Bank Of America Corporation | Computer architecture for representing positional digits using correlithm objects in a correlithm object processing system |
US11645096B2 (en) | 2019-07-24 | 2023-05-09 | Bank Of America Corporation | Computer architecture for performing multiplication using correlithm objects in a correlithm object processing system |
US10915346B1 (en) * | 2019-07-24 | 2021-02-09 | Bank Of America Corporation | Computer architecture for representing an exponential form using correlithm objects in a correlithm object processing system |
US10936349B2 (en) * | 2019-07-24 | 2021-03-02 | Bank Of America Corporation | Computer architecture for performing addition using correlithm objects in a correlithm object processing system |
KR20210045225A (en) | 2019-10-16 | 2021-04-26 | 삼성전자주식회사 | Method and apparatus for performing operation in neural network |
US11455331B2 (en) | 2019-12-12 | 2022-09-27 | Motorola Solutions, Inc. | Device, system and method for anonymously comparing query images to reference images |
US11347526B2 (en) | 2020-01-03 | 2022-05-31 | Bank Of America Corporation | Computer architecture for representing phase and frequency components using correlithm objects in a correlithm object processing system |
US11086647B2 (en) * | 2020-01-03 | 2021-08-10 | Bank Of America Corporation | Computer architecture for determining phase and frequency components from correlithm objects in a correlithm object processing system |
CN111753978B (en) * | 2020-01-19 | 2024-03-01 | 杭州海康威视数字技术股份有限公司 | Forward time consumption determination method, device and equipment |
US11055121B1 (en) | 2020-01-30 | 2021-07-06 | Bank Of America Corporation | Computer architecture for emulating an integrator in a correlithm object processing system |
US11055323B1 (en) | 2020-01-30 | 2021-07-06 | Bank Of America Corporation | Computer architecture for emulating a differential amlpifier in a correlithm object processing system |
US11126450B2 (en) | 2020-01-30 | 2021-09-21 | Bank Of America Corporation | Computer architecture for emulating a differentiator in a correlithm object processing system |
CN111628866B (en) * | 2020-05-22 | 2021-08-31 | 深圳前海微众银行股份有限公司 | Neural network verification method, device and equipment and readable storage medium |
CN111881312B (en) * | 2020-07-24 | 2022-07-05 | 成都成信高科信息技术有限公司 | Image data set classification and division method |
KR102519210B1 (en) * | 2020-08-31 | 2023-04-06 | 성균관대학교산학협력단 | Method and apparatus for accelerating artificial neural network using double-stage weight sharing |
US11620583B2 (en) | 2020-09-08 | 2023-04-04 | International Business Machines Corporation | Federated machine learning using locality sensitive hashing |
US20210110269A1 (en) * | 2020-12-21 | 2021-04-15 | Intel Corporation | Neural network dense layer sparsification and matrix compression |
KR102648499B1 (en) * | 2021-03-11 | 2024-03-19 | 한국전자통신연구원 | Apparatus and method for generating key based on machine learning |
US11462268B1 (en) | 2021-04-30 | 2022-10-04 | Hewlett Packard Enterprise Development Lp | Generating hash codes for locality sensitive hashing |
CN114513593B (en) * | 2022-01-25 | 2024-04-16 | 重庆医药高等专科学校 | Mass picture acquisition working method |
Citations (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8065248B1 (en) * | 2006-06-22 | 2011-11-22 | Google Inc. | Approximate hashing functions for finding similar content |
US9721190B2 (en) * | 2014-12-19 | 2017-08-01 | Google Inc. | Large-scale classification in neural networks using hashing |
Family Cites Families (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN101211341A (en) * | 2006-12-29 | 2008-07-02 | 上海芯盛电子科技有限公司 | Image intelligent mode recognition and searching method |
CN101706870A (en) * | 2009-10-26 | 2010-05-12 | 中山大学 | GPU-based system for realizing media qualification characteristic recognition and method |
CN104008520B (en) * | 2014-05-09 | 2015-05-13 | 河南大学 | Color image encryption method based on SHA-384 function, spatiotemporal chaotic system, quantum chaotic system and neural network |
-
2015
- 2015-11-05 US US14/933,256 patent/US9721190B2/en active Active
- 2015-11-27 EP EP15196866.6A patent/EP3035250B1/en active Active
- 2015-12-17 CN CN201510954701.3A patent/CN105719001B/en active Active
-
2017
- 2017-07-21 US US15/656,192 patent/US10049305B2/en active Active
Patent Citations (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8065248B1 (en) * | 2006-06-22 | 2011-11-22 | Google Inc. | Approximate hashing functions for finding similar content |
US9721190B2 (en) * | 2014-12-19 | 2017-08-01 | Google Inc. | Large-scale classification in neural networks using hashing |
Also Published As
Publication number | Publication date |
---|---|
EP3035250A2 (en) | 2016-06-22 |
US20160180200A1 (en) | 2016-06-23 |
US9721190B2 (en) | 2017-08-01 |
EP3035250A3 (en) | 2017-03-22 |
EP3035250B1 (en) | 2022-01-05 |
CN105719001B (en) | 2019-12-24 |
US10049305B2 (en) | 2018-08-14 |
CN105719001A (en) | 2016-06-29 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10049305B2 (en) | Large-scale classification in neural networks using hashing | |
US11829860B2 (en) | Processing and generating sets using recurrent neural networks | |
US11481631B1 (en) | Using embedding functions with a deep network | |
US11741366B2 (en) | Compressed recurrent neural network models | |
US20210201116A1 (en) | Progressive neural networks | |
US11657231B2 (en) | Capturing rich response relationships with small-data neural networks | |
EP3446260B1 (en) | Memory-efficient backpropagation through time | |
CN113887701B (en) | Method, system and storage medium for generating output for neural network output layer | |
CN106776673B (en) | Multimedia document summarization | |
US20190370659A1 (en) | Optimizing neural network architectures | |
US11675975B2 (en) | Word classification based on phonetic features | |
US11550871B1 (en) | Processing structured documents using convolutional neural networks | |
CN109313720B (en) | Enhanced neural network with sparsely accessed external memory | |
US11010664B2 (en) | Augmenting neural networks with hierarchical external memory | |
CN111566654A (en) | Machine learning integrating knowledge and natural language processing | |
WO2018093926A1 (en) | Semi-supervised training of neural networks | |
CN112789626A (en) | Scalable and compressed neural network data storage system | |
CN108475346B (en) | Neural random access machine |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:VIJAYANARASIMHAN, SUDHEENDRA;YAGNIK, JAY;SIGNING DATES FROM 20150811 TO 20150826;REEL/FRAME:043064/0578 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044567/0001Effective date: 20170929 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |