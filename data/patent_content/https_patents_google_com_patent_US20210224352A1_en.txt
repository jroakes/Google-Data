US20210224352A1 - Deep Multi-View Network Embedding on Incomplete Data - Google Patents
Deep Multi-View Network Embedding on Incomplete Data Download PDFInfo
- Publication number
- US20210224352A1 US20210224352A1 US17/154,123 US202117154123A US2021224352A1 US 20210224352 A1 US20210224352 A1 US 20210224352A1 US 202117154123 A US202117154123 A US 202117154123A US 2021224352 A1 US2021224352 A1 US 2021224352A1
- Authority
- US
- United States
- Prior art keywords
- nodes
- embedding
- view
- views
- computing system
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F17/00—Digital computing or data processing equipment or methods, specially adapted for specific functions
- G06F17/10—Complex mathematical operations
- G06F17/16—Matrix or vector computation, e.g. matrix-matrix or matrix-vector multiplication, matrix factorization
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
- G06N5/02—Knowledge representation; Symbolic representation
- G06N5/022—Knowledge engineering; Knowledge acquisition
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/045—Combinations of networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L41/00—Arrangements for maintenance, administration or management of data switching networks, e.g. of packet switching networks
- H04L41/12—Discovery or management of network topologies
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L41/00—Arrangements for maintenance, administration or management of data switching networks, e.g. of packet switching networks
- H04L41/16—Arrangements for maintenance, administration or management of data switching networks, e.g. of packet switching networks using machine learning or artificial intelligence
Definitions
- the present disclosure relates generally to graph networks. More particularly, the present disclosure relates to generating a unified embedding for the nodes a graph network from partial multi-view data descriptive of the network.
- Network embedding is an effective technique to learn the low-dimensional representations of nodes in networks.
- Real-world data are usually with multiple modalities or having multi-view representations from different sources.
- most existing multi-view approaches assume that each node appears in all views, or at least there is one view containing all nodes. But in real applications, it is often the case that a view suffers from the missing of some data and therefore results in partial multi-view data.
- network embedding is often designed for learning low-dimensional and typically non-linear representations of nodes in the network, which is able to preserve network information.
- Network embedding has been shown to be useful in many downstream tasks, such as node classification, node clustering, link prediction, and community detection.
- a variety of network embedding techniques have been proposed in the literature. However, most of these methods focus on single-view networks, where nodes in the networks are only associated with one type of features or relationships.
- data usually have multi-view representations, where nodes are associated with multiple features from different sources. Multiple types of edges/relations are then generated from these disparate features.
- a document has hyperlink feature that connects to other related documents. It can also have semantic representation such as attribute or tag feature. Documents are linked together in the attribute view if they share at least one attribute.
- users can be represented with their friendship to others, public comments, photos, reviews, tags, etc. Similarly, users can be linked in the photo network or tag network if they share same photos or tags.
- One example aspect of the present disclosure is directed to a computer-implemented method to generate embeddings from partial view data.
- the method can include obtaining, by one or more computing devices, a plurality of datasets that respectively correspond to a plurality of views of a graph network comprising a plurality of nodes.
- the plurality of datasets comprise one or more partial view datasets for one or more partial views that comprise data for only a respective subset of the plurality of nodes of the graph network.
- the method can include defining, by the one or more computing devices, a unified embedding for the plurality of nodes, wherein the unified embedding comprises: a common embedding set that contains respective embeddings for common subset of the plurality of nodes that are common among all of plurality of views; and one or more independent embedding sets that contain respective embeddings for one or more respective independent subsets of the plurality of nodes that are described by only a respective subset of the plurality of views.
- the method can include processing, by the one or computing devices, each of the plurality of datasets with an encoder model to obtain, for each of the plurality of datasets, respective encoded representations of the plurality of nodes described by the corresponding view.
- the method can include modifying, by the one or more computing devices, the respective embeddings for one or more of the plurality of nodes to reduce an objective function that, for each of the plurality of views, performs a comparison of the respective encoded representations of the plurality of nodes described by such view with the respective embeddings for the nodes described by such view.
- the comparison is performed using a respective embedding matrix that comprises separate respective entries for the common embedding set and at least one of the one or more independent embedding sets.
- the one or more independent embedding sets can include a plurality of independent embedding sets.
- At least one of the one or more independent embedding sets can contain respective embeddings for a respective independent subset of the plurality of nodes that is described by only a single view.
- At least one of the one or more independent embedding sets can contain respective embeddings for a respective independent subset of the plurality of nodes that is described by two or more but not all of plurality of views.
- the respective embedding matrix can consist of a first entry for the common embedding set and a second entry for a respective independent subset of the plurality of nodes that are described by only such view.
- the method can further include modifying, by the one or more computing devices, one or more parameter values of the encoder model to reduce the objective function.
- said modifying the respective embeddings for one or more of the plurality of nodes to reduce the objective function can include minimizing the objective function.
- the computer-implemented method of claim 1 wherein the objective function further comprises a proximity preservation term that enforces preservation of proximity within each view.
- the objective function evaluates, for each of the plurality of views, the respective difference between the respective encoded representations of the plurality of nodes obtained for such view and the respective embeddings for the nodes described by such view multiplied by a respective basis matrix for such view.
- the objective function evaluates, for each of the plurality of views, a Frobenius norm of the respective difference between the respective encoded representations of the plurality of nodes obtained for such view and the respective embeddings for the nodes described by such view multiplied by a respective basis matrix for such view.
- the objective function comprises a sum of respective distances evaluated for the plurality of views.
- At least two of the plurality of datasets comprise different respective modalities of data.
- Another example aspect of the present disclosure is directed to a computing system, comprising one or more processors and one or more non-transitory computer-readable media that collectively store instructions that when executed by the one or more processors cause the computing system to perform operations.
- the operations can include obtaining a unified embedding for a graph network comprising a plurality of nodes.
- the operations can include analyzing one or more of the plurality of nodes or the graph network based on the unified embedding.
- the graph network comprises a social network that describes social connections between entities, a logistics network that describes logistical connections between logistical nodes, a biological network that describes biological units, or a chemical network that describes chemical units.
- analyzing one or more of the plurality of nodes based on the unified embedding can include: using the respective embedding for a first node of the plurality of nodes to: identify one or more other nodes of the plurality of nodes that are similar to the first node; classify the first node; predict a link between the first node and at least one other node of the plurality of nodes; cluster the first node with one or more other nodes; and/or identify a community to which the first node belongs.
- the unified embedding was generated by a second, different computing system that is distinct from the computing system.
- the unified embedding was generated by same the computing system.
- FIG. 1A depicts a block diagram of an example computing system according to example embodiments of the present disclosure.
- FIG. 1B depicts a block diagram of an example computing device according to example embodiments of the present disclosure.
- FIG. 1C depicts a block diagram of an example computing device according to example embodiments of the present disclosure.
- FIG. 2 depicts a graphical diagram of example embedding sets generated from multiple partial views of a graph network according to example embodiments of the present disclosure.
- the present disclosure provides a novel Deep Partial Multiview Network Embedding approach to deal with incomplete data.
- the network embeddings can be learned by simultaneously enforcing the data consistency between different views via deep latent subspace learning and preserving the data topological structure within the same view through graph Laplacian.
- the present disclosure provides a unified learning framework that enables learning of the network embedding.
- Example implementations of the framework simultaneously enforce the data consistency between different views via deep latent subspace learning and preserve data proximity within the same view through graph Laplacian.
- a coordinate descent algorithm can be applied as the optimization procedure.
- the proposed framework can also be applied to hashing methods based on the orthogonal invariant property of example proposed formulations.
- Example experiments on two datasets have demonstrated the advantages of the proposed approach over several state-of-the-art single-view and multi-view network embedding methods.
- one aspect of the present disclosure relates to a unified network embedding approach to deal with partial multi-view data scenario, which is able to generate effective embedding representations for all data.
- Another example aspect relates to a coordinate descent method for the joint optimization problem.
- the systems and methods of the present disclosure provide a number of technical effects and benefits.
- the systems and methods of the present disclosure can enable improved classification results, thereby improving the performance of a computer or computerized system.
- the systems and methods of the present disclosure can enable improved handling of multi-partial-view datasets, which were heretofore not able to be handled by learning-based computer systems, thereby improving the performance of a computer or computerized system.
- DPMNE Deep Partial Multi-View Network Embedding
- An example objective function of DPMNE can be composed of two components: (1) Data consistency between views, where deep latent subspace learning is utilized to ensure that the node embeddings generated from different views are consistent. (2) Proximity preservation within view, where graph Laplacian is applied to enforce that similar nodes within each view should have close embeddings.
- some example implementations adopt a deep encoder to map the input data to the representation space:
- h i is the hidden representation from the encoder.
- W and b are model parameters.
- ⁇ (.) denotes the non-linear activation function.
- k is the index number of the layers.
- ⁇ circumflex over (X) ⁇ (1,2) , ⁇ circumflex over (X) ⁇ (1) , ⁇ circumflex over (X) ⁇ (2) are represented by heterogeneous features of dimensions (d 1 +d 2 ), d 1 , d 2 , which makes it difficult for learning their embeddings.
- the nodes are sharing the same feature space.
- the two different views are coupled/bridged by the shared common nodes.
- Some example implementations can learn a common latent subspace for the two views, where embeddings belonging to the same node between different views are consistent, while at the same time for each view, the representations for similar nodes are close in the latent subspace.
- ⁇ circumflex over (X) ⁇ (1,2) [ ⁇ circumflex over (X) ⁇ c (1) , ⁇ circumflex over (X) ⁇ c (2) ], where ⁇ circumflex over (X) ⁇ c (1) ⁇ c ⁇ d 1 , ⁇ circumflex over (X) ⁇ c (2) ⁇ c ⁇ d 2 are the instances of the common nodes coming from the two views.
- X (1) [ ⁇ circumflex over (X) ⁇ c (1) , ⁇ circumflex over (X) ⁇ (1) ] ⁇ (c+n 1 ) ⁇ d 1
- X (2) [ ⁇ circumflex over (X) ⁇ c (2) , ⁇ circumflex over (X) ⁇ (2) ] ⁇ (c+n 2 ) ⁇ d 2 .
- B (1) ⁇ d ⁇ d 1 and B (2) ⁇ d ⁇ d 2 are the basis matrix for each view's latent space.
- Y (1) [ ⁇ c (1) , ⁇ (1) ] ⁇ (c+n 1 ) ⁇ d
- Y (2) [ ⁇ c (2) , ⁇ (2) ] ⁇ (c+n 2 ) ⁇ d are the latent representation/embedding of nodes in the latent space.
- H are the encoders described in Eqn. 1. The same latent space dimension d is shared between the two views.
- Eqn. 3 is different from previous subspace based multi-view network embedding approaches, which either requires Y (1) and Y (2) to be the same or do not require Y (1) and Y (2) to share any common part.
- Y (1) and Y (2) share one common representation Y c , while at the same time have their own individual components.
- the individual basis matrix B (1) and B (2) which are learned from all available instances from both views, are connected by the common ⁇ c .
- FIG. 2 provides an illustration of example embedding sets generated from multiple partial views of a graph network.
- proximity preserving which indicates that similar nodes should be mapped to similar embedding within a close distance. Therefore, besides the data consistency between different views, some example implementations also preserve the data proximity within each individual view. In other words, some example implementations cause the learned embedding Y to preserve the proximity structure in each view. As an example, some example implementations use the L 2 distance to measure the proximity between y i and y j as ⁇ y i ⁇ y j ⁇ 2 as in most network embedding work. Then one natural way to preserve the proximity in each view is to minimize the weighted average distance as follows:
- S (t) is the proximity matrix in t-th view, which can be obtained from the edges in t-th network E (t) .
- the first-order proximity is usually very sparse and insufficient to fully model the relationships between nodes in most cases, especially under the partial data setting.
- some example implementations adopt high-order proximity and define S as:
- l is the order
- w 1 , . . . , w l are the weights for each term.
- Matrix E l denotes the l-order proximity matrix.
- some example implementations seek to minimize the quantity in Eqn. 4 in each view since it incurs a heavy penalty if two similar nodes have very different embedding representations.
- Eqn. 4 can be rewritten as:
- L is called graph Laplacian and tr( ⁇ ) is the matrix trace function.
- H (t) H (t) ( X (t) ) is the short representation of the encoded input in Eqn. 1. Note that Y (1) and Y (2) share an identical part ⁇ c . corresponding to the common nodes present in both views. Directly minimizing the objective function in Eqn. 7 is intractable since it is a non-convex optimization problem with Y, B and H coupled together. We propose to use coordinate descent scheme by iteratively solving the optimization problem with respect to Y, B and H as follows:
- Example hashing methods learn compact binary representations of the data examples for efficient similarity search tasks. This section first proves the following orthogonal invariant property:
- Quantization-based hashing methods directly binarize the low-dimensional representation to achieve the binary codes.
- Some example implementations of the present disclosure can easily obtain the binary codes C for the nodes in the network by binarizing the learned embedding Y.
- the quantization error can be further reduced based on the orthogonal invariant property of the embedding, i.e., minimizing the quantization error between the binary hashing codes and the orthogonal rotation of the embedding as follows:
- One example optimization algorithm of DPMNE consists of three steps in each iteration to update Y, B and H.
- the time complexities for solving Y and B are bounded by O(ndd 1 +ndd 2 +nd 2 +n 2 d) and O(nd 2 +ndd 1 +ndd 2 ) respectively.
- L is usually a sparse matrix, and the cost can be reduced from O(n 2 d) to O(ld) with sparse matrix multiplication, where l is the number of non-zero elements in L.
- the cost of updating H depends on the number of hidden layers and units in the neural network, which is roughly O(nmd 1 +nmd 2 ).
- m is the number of unique units in the neural network.
- the total time complexity of the learning algorithm is bounded by O(ndd 1 +ndd 2 +ld+nd 2 +nmd 1 +nmd 2 ).
- FIG. 1A depicts a block diagram of an example computing system 100 according to example embodiments of the present disclosure.
- the system 100 includes a user computing device 102 , a server computing system 130 , and a training computing system 150 that are communicatively coupled over a network 180 .
- the user computing device 102 can be any type of computing device, such as, for example, a personal computing device (e.g., laptop or desktop), a mobile computing device (e.g., smartphone or tablet), a gaming console or controller, a wearable computing device, an embedded computing device, or any other type of computing device.
- a personal computing device e.g., laptop or desktop
- a mobile computing device e.g., smartphone or tablet
- a gaming console or controller e.g., a gaming console or controller
- a wearable computing device e.g., an embedded computing device, or any other type of computing device.
- the user computing device 102 includes one or more processors 112 and a memory 114 .
- the one or more processors 112 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 114 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 114 can store data 116 and instructions 118 which are executed by the processor 112 to cause the user computing device 102 to perform operations.
- the user computing device 102 can store or include one or more machine-learned models 120 .
- the machine-learned models 120 can be or can otherwise include various machine-learned models such as neural networks (e.g., deep neural networks) or other types of machine-learned models, including non-linear models and/or linear models.
- Neural networks can include feed-forward neural networks, recurrent neural networks (e.g., long short-term memory recurrent neural networks), convolutional neural networks or other forms of neural networks.
- Additional example machine-learning models include self-attention-based models such as transformer models.
- the one or more machine-learned models 120 can be received from the server computing system 130 over network 180 , stored in the user computing device memory 114 , and then used or otherwise implemented by the one or more processors 112 .
- the user computing device 102 can implement multiple parallel instances of a single machine-learned model 120 .
- one or more machine-learned models 140 can be included in or otherwise stored and implemented by the server computing system 130 that communicates with the user computing device 102 according to a client-server relationship.
- the machine-learned models 140 can be implemented by the server computing system 140 as a portion of a web service (e.g., a network analysis service).
- a web service e.g., a network analysis service.
- one or more models 120 can be stored and implemented at the user computing device 102 and/or one or more models 140 can be stored and implemented at the server computing system 130 .
- the user computing device 102 can also include one or more user input component 122 that receives user input.
- the user input component 122 can be a touch-sensitive component (e.g., a touch-sensitive display screen or a touch pad) that is sensitive to the touch of a user input object (e.g., a finger or a stylus).
- the touch-sensitive component can serve to implement a virtual keyboard.
- Other example user input components include a microphone, a traditional keyboard, or other means by which a user can provide user input.
- the server computing system 130 includes one or more processors 132 and a memory 134 .
- the one or more processors 132 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 134 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 134 can store data 136 and instructions 138 which are executed by the processor 132 to cause the server computing system 130 to perform operations.
- the server computing system 130 includes or is otherwise implemented by one or more server computing devices. In instances in which the server computing system 130 includes plural server computing devices, such server computing devices can operate according to sequential computing architectures, parallel computing architectures, or some combination thereof.
- the server computing system 130 can store or otherwise include one or more machine-learned models 140 .
- the models 140 can be or can otherwise include various machine-learned models.
- Example machine-learned models include neural networks or other multi-layer non-linear models.
- Example neural networks include feed forward neural networks, deep neural networks, recurrent neural networks, and convolutional neural networks.
- Additional example machine-learning models include self-attention-based models such as transformer models.
- the user computing device 102 and/or the server computing system 130 can train the models 120 and/or 140 via interaction with the training computing system 150 that is communicatively coupled over the network 180 .
- the training computing system 150 can be separate from the server computing system 130 or can be a portion of the server computing system 130 .
- the training computing system 150 includes one or more processors 152 and a memory 154 .
- the one or more processors 152 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 154 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 154 can store data 156 and instructions 158 which are executed by the processor 152 to cause the training computing system 150 to perform operations.
- the training computing system 150 includes or is otherwise implemented by one or more server computing devices.
- the training computing system 150 can include a model trainer 160 that trains the machine-learned models 120 and/or 140 stored at the user computing device 102 and/or the server computing system 130 using various training or learning techniques, such as, for example, backwards propagation of errors.
- a loss function can be backpropagated through the model(s) to update one or more parameters of the model(s) (e.g., based on a gradient of the loss function).
- Various loss functions can be used such as mean squared error, likelihood loss, cross entropy loss, hinge loss, and/or various other loss functions.
- Gradient descent techniques can be used to iteratively update the parameters over a number of training iterations.
- performing backwards propagation of errors can include performing truncated backpropagation through time.
- the model trainer 160 can perform a number of generalization techniques (e.g., weight decays, dropouts, etc.) to improve the generalization capability of the models being trained.
- the model trainer 160 can train the machine-learned models 120 and/or 140 based on a set of training data 162 .
- the training data 162 can include, for example, multiple partial or complete views of a network.
- the training examples can be provided by the user computing device 102 .
- the model 120 provided to the user computing device 102 can be trained by the training computing system 150 on user-specific data received from the user computing device 102 . In some instances, this process can be referred to as personalizing the model.
- the model trainer 160 includes computer logic utilized to provide desired functionality.
- the model trainer 160 can be implemented in hardware, firmware, and/or software controlling a general purpose processor.
- the model trainer 160 includes program files stored on a storage device, loaded into a memory and executed by one or more processors.
- the model trainer 160 includes one or more sets of computer-executable instructions that are stored in a tangible computer-readable storage medium such as RAM hard disk or optical or magnetic media.
- the network 180 can be any type of communications network, such as a local area network (e.g., intranet), wide area network (e.g., Internet), or some combination thereof and can include any number of wired or wireless links.
- communication over the network 180 can be carried via any type of wired and/or wireless connection, using a wide variety of communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), encodings or formats (e.g., HTML, XML), and/or protection schemes (e.g., VPN, secure HTTP, SSL).
- FIG. 1A illustrates one example computing system that can be used to implement the present disclosure.
- the user computing device 102 can include the model trainer 160 and the training dataset 162 .
- the models 120 can be both trained and used locally at the user computing device 102 .
- the user computing device 102 can implement the model trainer 160 to personalize the models 120 based on user-specific data.
- FIG. 1B depicts a block diagram of an example computing device 10 that performs according to example embodiments of the present disclosure.
- the computing device 10 can be a user computing device or a server computing device.
- the computing device 10 includes a number of applications (e.g., applications 1 through N). Each application contains its own machine learning library and machine-learned model(s). For example, each application can include a machine-learned model.
- Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
- each application can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components.
- each application can communicate with each device component using an API (e.g., a public API).
- the API used by each application is specific to that application.
- FIG. 1C depicts a block diagram of an example computing device 50 that performs according to example embodiments of the present disclosure.
- the computing device 50 can be a user computing device or a server computing device.
- the computing device 50 includes a number of applications (e.g., applications 1 through N). Each application is in communication with a central intelligence layer.
- Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc.
- each application can communicate with the central intelligence layer (and model(s) stored therein) using an API (e.g., a common API across all applications).
- the central intelligence layer includes a number of machine-learned models. For example, as illustrated in FIG. 1C , a respective machine-learned model (e.g., a model) can be provided for each application and managed by the central intelligence layer. In other implementations, two or more applications can share a single machine-learned model. For example, in some implementations, the central intelligence layer can provide a single model (e.g., a single model) for all of the applications. In some implementations, the central intelligence layer is included within or otherwise implemented by an operating system of the computing device 50 .
- a respective machine-learned model e.g., a model
- two or more applications can share a single machine-learned model.
- the central intelligence layer can provide a single model (e.g., a single model) for all of the applications.
- the central intelligence layer is included within or otherwise implemented by an operating system of the computing device 50 .
- the central intelligence layer can communicate with a central device data layer.
- the central device data layer can be a centralized repository of data for the computing device 50 . As illustrated in FIG. 1C , the central device data layer can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, the central device data layer can communicate with each device component using an API (e.g., a private API).
- an API e.g., a private API
- the technology discussed herein makes reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and from such systems.
- the inherent flexibility of computer-based systems allows for a great variety of possible configurations, combinations, and divisions of tasks and functionality between and among components.
- processes discussed herein can be implemented using a single device or component or multiple devices or components working in combination.
- Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
Abstract
The present disclosure provides a novel Deep Partial Multiview Network Embedding approach to deal with incomplete data. In particular, the network embeddings can be learned by simultaneously enforcing the data consistency between different views via deep latent subspace learning, and preserving the data topological structure within the same view through graph Laplacian.
Description
- This application claims priority to and the benefit of U.S. Provisional patent Application No. 62/963,756, which is hereby incorporated by reference in its entirety.
- The present disclosure relates generally to graph networks. More particularly, the present disclosure relates to generating a unified embedding for the nodes a graph network from partial multi-view data descriptive of the network.
- Network embedding is an effective technique to learn the low-dimensional representations of nodes in networks. Real-world data are usually with multiple modalities or having multi-view representations from different sources. Recently, there has been increasing interest in network embedding on multi-view data. However, most existing multi-view approaches assume that each node appears in all views, or at least there is one view containing all nodes. But in real applications, it is often the case that a view suffers from the missing of some data and therefore results in partial multi-view data.
- In particular, network embedding is often designed for learning low-dimensional and typically non-linear representations of nodes in the network, which is able to preserve network information. Network embedding has been shown to be useful in many downstream tasks, such as node classification, node clustering, link prediction, and community detection. A variety of network embedding techniques have been proposed in the literature. However, most of these methods focus on single-view networks, where nodes in the networks are only associated with one type of features or relationships.
- In many real-world applications, data usually have multi-view representations, where nodes are associated with multiple features from different sources. Multiple types of edges/relations are then generated from these disparate features. For example, in document corpus, a document has hyperlink feature that connects to other related documents. It can also have semantic representation such as attribute or tag feature. Documents are linked together in the attribute view if they share at least one attribute. In a social photo-sharing application, users can be represented with their friendship to others, public comments, photos, reviews, tags, etc. Similarly, users can be linked in the photo network or tag network if they share same photos or tags.
- Previous research on multi-view representation learning has demonstrated improved performance by leveraging complementary information from different views. Therefore, there is a growing interest in multi-view network embedding that effectively integrates information from disparate views.
- Although existing multi-view network embedding methods generate promising results in dealing with multi-view data, most of them assume that all nodes in the network have full information in all views. However, in real-world tasks, it is often the case that a view suffers from some missing information, which results in incomplete data. For instance, in document corpus, many documents may not contain any hyperlink or tag information. In a social photo-sharing application, a user might have no friends, reviews or tags, resulting in an isolated node in the corresponding relationship network. Moreover, it is also common that users do not share some of their information, such as photos and comments, for privacy consideration. Therefore, it is a practical and important research problem to design effective network embedding methods on incomplete multi-view data.
- There are several ways to apply existing multi-view network embedding methods to incomplete data. One can either remove the data that suffer from missing information or preprocess the partial data by first filling in the missing data. The first strategy is clearly not suitable since the purpose is to map all nodes to their corresponding embedding vectors and empirical experiments show that the second strategy does not achieve good performance either.
- Aspects and advantages of embodiments of the present disclosure will be set forth in part in the following description, or can be learned from the description, or can be learned through practice of the embodiments.
- One example aspect of the present disclosure is directed to a computer-implemented method to generate embeddings from partial view data. The method can include obtaining, by one or more computing devices, a plurality of datasets that respectively correspond to a plurality of views of a graph network comprising a plurality of nodes. In some implementations, the plurality of datasets comprise one or more partial view datasets for one or more partial views that comprise data for only a respective subset of the plurality of nodes of the graph network. The method can include defining, by the one or more computing devices, a unified embedding for the plurality of nodes, wherein the unified embedding comprises: a common embedding set that contains respective embeddings for common subset of the plurality of nodes that are common among all of plurality of views; and one or more independent embedding sets that contain respective embeddings for one or more respective independent subsets of the plurality of nodes that are described by only a respective subset of the plurality of views. The method can include processing, by the one or computing devices, each of the plurality of datasets with an encoder model to obtain, for each of the plurality of datasets, respective encoded representations of the plurality of nodes described by the corresponding view. The method can include modifying, by the one or more computing devices, the respective embeddings for one or more of the plurality of nodes to reduce an objective function that, for each of the plurality of views, performs a comparison of the respective encoded representations of the plurality of nodes described by such view with the respective embeddings for the nodes described by such view. In some implementations, for at least one of the plurality of views, the comparison is performed using a respective embedding matrix that comprises separate respective entries for the common embedding set and at least one of the one or more independent embedding sets.
- In some implementations, the one or more independent embedding sets can include a plurality of independent embedding sets.
- In some implementations, at least one of the one or more independent embedding sets can contain respective embeddings for a respective independent subset of the plurality of nodes that is described by only a single view.
- In some implementations, at least one of the one or more independent embedding sets can contain respective embeddings for a respective independent subset of the plurality of nodes that is described by two or more but not all of plurality of views.
- In some implementations, for the at least one of the plurality of views, the respective embedding matrix can consist of a first entry for the common embedding set and a second entry for a respective independent subset of the plurality of nodes that are described by only such view.
- In some implementations, the method can further include modifying, by the one or more computing devices, one or more parameter values of the encoder model to reduce the objective function.
- In some implementations, said modifying the respective embeddings for one or more of the plurality of nodes to reduce the objective function can include minimizing the objective function.
- The computer-implemented method of
claim 1, wherein the objective function further comprises a proximity preservation term that enforces preservation of proximity within each view. - In some implementations, the objective function evaluates, for each of the plurality of views, the respective difference between the respective encoded representations of the plurality of nodes obtained for such view and the respective embeddings for the nodes described by such view multiplied by a respective basis matrix for such view.
- In some implementations, the objective function evaluates, for each of the plurality of views, a Frobenius norm of the respective difference between the respective encoded representations of the plurality of nodes obtained for such view and the respective embeddings for the nodes described by such view multiplied by a respective basis matrix for such view.
- In some implementations, the objective function comprises a sum of respective distances evaluated for the plurality of views.
- In some implementations, at least two of the plurality of datasets comprise different respective modalities of data.
- Another example aspect of the present disclosure is directed to a computing system, comprising one or more processors and one or more non-transitory computer-readable media that collectively store instructions that when executed by the one or more processors cause the computing system to perform operations. The operations can include obtaining a unified embedding for a graph network comprising a plurality of nodes. The operations can include analyzing one or more of the plurality of nodes or the graph network based on the unified embedding.
- In some implementations, the graph network comprises a social network that describes social connections between entities, a logistics network that describes logistical connections between logistical nodes, a biological network that describes biological units, or a chemical network that describes chemical units.
- In some implementations, analyzing one or more of the plurality of nodes based on the unified embedding can include: using the respective embedding for a first node of the plurality of nodes to: identify one or more other nodes of the plurality of nodes that are similar to the first node; classify the first node; predict a link between the first node and at least one other node of the plurality of nodes; cluster the first node with one or more other nodes; and/or identify a community to which the first node belongs.
- In some implementations, the unified embedding was generated by a second, different computing system that is distinct from the computing system.
- In some implementations, the unified embedding was generated by same the computing system.
- Other aspects of the present disclosure are directed to various systems, apparatuses, non-transitory computer-readable media, user interfaces, and electronic devices.
- These and other features, aspects, and advantages of various embodiments of the present disclosure will become better understood with reference to the following description and appended claims. The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate example embodiments of the present disclosure and, together with the description, serve to explain the related principles.
- Detailed discussion of embodiments directed to one of ordinary skill in the art is set forth in the specification, which makes reference to the appended figures, in which:
-
FIG. 1A depicts a block diagram of an example computing system according to example embodiments of the present disclosure. -
FIG. 1B depicts a block diagram of an example computing device according to example embodiments of the present disclosure. -
FIG. 1C depicts a block diagram of an example computing device according to example embodiments of the present disclosure. -
FIG. 2 depicts a graphical diagram of example embedding sets generated from multiple partial views of a graph network according to example embodiments of the present disclosure. - The present disclosure provides a novel Deep Partial Multiview Network Embedding approach to deal with incomplete data. In particular, the network embeddings can be learned by simultaneously enforcing the data consistency between different views via deep latent subspace learning and preserving the data topological structure within the same view through graph Laplacian.
- More particularly, the present disclosure provides a unified learning framework that enables learning of the network embedding. Example implementations of the framework simultaneously enforce the data consistency between different views via deep latent subspace learning and preserve data proximity within the same view through graph Laplacian. A coordinate descent algorithm can be applied as the optimization procedure.
- The proposed framework can also be applied to hashing methods based on the orthogonal invariant property of example proposed formulations. Example experiments on two datasets have demonstrated the advantages of the proposed approach over several state-of-the-art single-view and multi-view network embedding methods.
- Thus, one aspect of the present disclosure relates to a unified network embedding approach to deal with partial multi-view data scenario, which is able to generate effective embedding representations for all data. Another example aspect relates to a coordinate descent method for the joint optimization problem.
- The systems and methods of the present disclosure provide a number of technical effects and benefits. As one example technical effect, the systems and methods of the present disclosure can enable improved classification results, thereby improving the performance of a computer or computerized system. As another example technical effect, the systems and methods of the present disclosure can enable improved handling of multi-partial-view datasets, which were heretofore not able to be handled by learning-based computer systems, thereby improving the performance of a computer or computerized system.
- Example Problem Definition
- While any number of views can be accommodated, for the sake of simplicity only, the following explanation will assume there are data from two views, i.e., given a multi-view network G=(V,E), where V={v1, v2, . . . , vn} denotes the set of nodes. X={(xi 1, xi 2), i=1, . . . , n} are the multi-view features associated with the nodes, where xi 1∈
1 is the feature of the i-th node in the first view and xi 2∈2 is the i-th node in the second view (usually d1 - In the incomplete data setting, a partial data {circumflex over (X)}={{circumflex over (X)}(1,2),{circumflex over (X)}(1),{circumflex over (X)}(2)} instead of X is given, where {circumflex over (X)}(1,2)={(x1 1,x1 2), . . . , (xc 1,xc 2)}∈
1 +d2 ) denotes the common nodes present in both views, {circumflex over (X)}(1)={xc+1 1, . . . , xc+n1 1}∈1 ×d1 denotes the nodes only present in the first view and {circumflex over (X)}(2)={xc+n1 +1 2, . . . , xc+n1 +n2 2}∈2 ×d2 denotes the nodes only present in the second view. Note that the number of nodes present and only present in both views, the first view, and the second view are c, n1 and n2 (n=c+n1+n2). One example purpose of Deep Partial Multi-View Network Embedding (DPMNE) is to learn a low-dimensional embedding representation Y={y1, y2, . . . , yn}∈ - An example objective function of DPMNE can be composed of two components: (1) Data consistency between views, where deep latent subspace learning is utilized to ensure that the node embeddings generated from different views are consistent. (2) Proximity preservation within view, where graph Laplacian is applied to enforce that similar nodes within each view should have close embeddings.
- Example Data Consistency Between Views
- To capture the sparsity and highly non-linear structure in the feature space, some example implementations adopt a deep encoder to map the input data to the representation space:
-
h 1=σ(W 1 x+b 1) -
h k=σ(W k h k−1 +b k) (1) - where hi is the hidden representation from the encoder. W and b are model parameters. σ(.) denotes the non-linear activation function. k is the index number of the layers.
- In the partial data setting, {circumflex over (X)}(1,2),{circumflex over (X)}(1),{circumflex over (X)}(2) are represented by heterogeneous features of dimensions (d1+d2), d1, d2, which makes it difficult for learning their embeddings. But investigating the problem from view perspective, in each individual view, the nodes are sharing the same feature space. The two different views are coupled/bridged by the shared common nodes. Some example implementations can learn a common latent subspace for the two views, where embeddings belonging to the same node between different views are consistent, while at the same time for each view, the representations for similar nodes are close in the latent subspace. Then the embeddings can be directly learned from this subspace, and some example implementations do not need to fill in or complete the partial data. Let {circumflex over (X)}(1,2)=[{circumflex over (X)}c (1),{circumflex over (X)}c (2)], where {circumflex over (X)}c (1)∈
1 ,{circumflex over (X)}c (2)∈2 are the instances of the common nodes coming from the two views. We denote the instances of each view as:X (1)=[{circumflex over (X)}c (1),{circumflex over (X)}(1)]∈1 )×d1 ,X (2)=[{circumflex over (X)}c (2),{circumflex over (X)}(2)]∈2 )×d2 . Following the above idea, the deep latent subspace learning can be formulated as: -
- where B(1)∈
1 and B(2)∈2 are the basis matrix for each view's latent space.Y (1)=[Ŷc (1),Ŷ(1)]∈1 )×d andY (2)=[Ŷc (2),Ŷ(2)]∈2 )×d are the latent representation/embedding of nodes in the latent space. H are the encoders described in Eqn. 1. The same latent space dimension d is shared between the two views. R(⋅)=∥⋅∥F 2 is the regularization term and λ is the trade-off parameter. By solving Eqn. 2, the deep encoder H, the latent space basis B and corresponding node embedding Y can be simultaneously learned to minimize the reconstruction error from each individual view. - In the above equation, the latent space are learned independently for each view. But in the partial data setting, for nodes present in both views {circumflex over (X)}c (1), {circumflex over (X)}c (2), their embedding 7, should also be consistent. Incorporating the above formulations by ensuring Ŷ(1)=Ŷc (2)=Ŷc, we seek to minimize:
-
- By solving the above problem, some example implementations can obtain the homogeneous feature representation for all nodes as Y=[Ŷc,Ŷ(1),Ŷ(2)]∈
1 +n2 )×d whether they are originally partial or not. Note that Eqn. 3 is different from previous subspace based multi-view network embedding approaches, which either requiresY (1) andY (2) to be the same or do not requireY (1) andY (2) to share any common part. In the above formulation,Y (1) andY (2) share one common representationY c, while at the same time have their own individual components. Moreover, the individual basis matrix B(1) and B(2), which are learned from all available instances from both views, are connected by the common Ŷc. - This principle can be applied to any number of shared nodes among any number of different views. As another example,
FIG. 2 provides an illustration of example embedding sets generated from multiple partial views of a graph network. - Example Proximity Preservation within View
- One of the key problems in network embedding algorithms is proximity preserving, which indicates that similar nodes should be mapped to similar embedding within a close distance. Therefore, besides the data consistency between different views, some example implementations also preserve the data proximity within each individual view. In other words, some example implementations cause the learned embedding Y to preserve the proximity structure in each view. As an example, some example implementations use the L2 distance to measure the proximity between yi and yj as ∥yi−yj∥2 as in most network embedding work. Then one natural way to preserve the proximity in each view is to minimize the weighted average distance as follows:
-
- Here, S(t) is the proximity matrix in t-th view, which can be obtained from the edges in t-th network E(t). A simple way to define S is to directly use the first-order proximity, i.e., S=E. However, the first-order proximity is usually very sparse and insufficient to fully model the relationships between nodes in most cases, especially under the partial data setting. In order to characterize the connections between nodes better, some example implementations adopt high-order proximity and define S as:
-
S=w 1 E+w 2 E 2 + . . . +w l E l (5) - where l is the order, and w1, . . . , wl are the weights for each term. Some example implementations set l to 5, w1 to 1 and wi=0.5wi−1.
- Matrix El denotes the l-order proximity matrix. To meet the proximity preservation criterion, some example implementations seek to minimize the quantity in Eqn. 4 in each view since it incurs a heavy penalty if two similar nodes have very different embedding representations. By introducing a diagonal matrix D(t), whose entries are given by Dii (t)=Σj=1 nSij (t). Eqn. 4 can be rewritten as:
-
tr(Y (t)T (D (t) −S (t))Y (t))=tr(Y (t)T L (t)Y (t))=1,2 (6) - where L is called graph Laplacian and tr(⋅) is the matrix trace function. By minimizing the above objective in both views, the proximity between different nodes can be preserved in the learned embedding.
- Example Overall Objective and Optimization
- Some example entire objective functions consist of two components: the data consistency between views in Eqn. 3 and proximity preservation within view given in Eqn. 6 as follows:
-
- where α and λ are trade-off parameters to balance the weights among the terms.
H (t)=H(t)(X (t)) is the short representation of the encoded input in Eqn. 1. Note thatY (1) andY (2) share an identical part Ŷc. corresponding to the common nodes present in both views. Directly minimizing the objective function in Eqn. 7 is intractable since it is a non-convex optimization problem with Y, B and H coupled together. We propose to use coordinate descent scheme by iteratively solving the optimization problem with respect to Y, B and H as follows: - (1) Update Ŷc, Ŷ(1) and Ŷ(2) by fixing B and H. Given the basis matrix B(t) and encoders H(t) for both views, we can decompose the objective since Ŷc and Ŷ(t) will not depend on each other.
-
- where {circumflex over (L)}(t) and {circumflex over (L)}c (t) can be simply derived from L(1) with some addition mathematical operation. const is the constant value independent with the parameter that to be optimized with. Although Eqn. 8 and Eqn. 9 are still non-convex, they are smooth and differentiable which enables gradient descent methods for efficient optimization. We omit the gradients calculation due to space limitation.
- (2) Update B(t) by fixing Y and H. It is equivalent to solve the following least square problems:
-
- By taking the derivative of Eqn. 10 w.r.t. B(t) and setting it to 0, a closed form solution can be simply obtained.
- (3) Update H(t) by fixing Y and B. It is a standard regression problem with deep neural network:
-
- Some example implementations then alternate the process of updating Y, B and H for several iterations to find a locally optimal solution. One example of a full learning algorithm is described in Algorithm 1:
- Algorithm 1: Example Deep Partial Multi-View Network Embedding (DPMNE)
- Input: Partial data {{circumflex over (X)}(1,2),{circumflex over (X)}(1),{circumflex over (X)}(2)}, edge sets E(1) and E(2), trade-off parameters α and λ
- Output: Unified embedding Y.
- Initialize B and H, Calculate L.
- repeat
-
- Optimize Eqns. 8 and 9 and update Ŷc, Ŷ(1) and Ŷ(2).
- Optimize Eqn. 10 and update B(1) and B(2).
- Optimize Eqn. 11 and update H(1) and H(2).
- until the solution converges
- Example Extension to Hashing
- This section connects the techniques described elsewhere herein to example quantization-based hashing techniques. Example hashing methods learn compact binary representations of the data examples for efficient similarity search tasks. This section first proves the following orthogonal invariant property:
-
Theorem 1 Assume Q is a d×d orthogonal matrix, i.e., QTQ=Id. If Y, B and H are an optimal solution to the problem in Eqn. 7, then Y′=YQ, B′=QTB and H′=H are also an optimal solution. - Proof. By substituting YQ and QTB into Eqn. 7, it is obvious that: ∥
H (t)−Y (t)QQTB(t)∥F 2=∥H (t)−Y (t)B(t)∥F 2, tr((Y (t)Q)TL(t)Y (t)Q)=tr(QTY (t)T L(t)Y (t)Q)=tr(Y (t)T L(t)Y (t)), and ∥YQ∥F 2=∥Y∥F 2, ∥QTB∥F 2=∥B∥F 2. Thus, the value of the objective function in Eqn. 7 does not change by the orthogonal rotation. - Quantization-based hashing methods directly binarize the low-dimensional representation to achieve the binary codes. Some example implementations of the present disclosure can easily obtain the binary codes C for the nodes in the network by binarizing the learned embedding Y. However, the quantization error can be further reduced based on the orthogonal invariant property of the embedding, i.e., minimizing the quantization error between the binary hashing codes and the orthogonal rotation of the embedding as follows:
-
- Example Analysis
- This section provides some complexity analysis on the training cost of example learning algorithms. One example optimization algorithm of DPMNE consists of three steps in each iteration to update Y, B and H. The time complexities for solving Y and B are bounded by O(ndd1+ndd2+nd2+n2 d) and O(nd2+ndd1+ndd2) respectively. In practice, L is usually a sparse matrix, and the cost can be reduced from O(n2d) to O(ld) with sparse matrix multiplication, where l is the number of non-zero elements in L. The cost of updating H depends on the number of hidden layers and units in the neural network, which is roughly O(nmd1+nmd2). Here m is the number of unique units in the neural network. Thus, the total time complexity of the learning algorithm is bounded by O(ndd1+ndd2+ld+nd2+nmd1+nmd2).
-
FIG. 1A depicts a block diagram of anexample computing system 100 according to example embodiments of the present disclosure. Thesystem 100 includes auser computing device 102, aserver computing system 130, and atraining computing system 150 that are communicatively coupled over anetwork 180. - The
user computing device 102 can be any type of computing device, such as, for example, a personal computing device (e.g., laptop or desktop), a mobile computing device (e.g., smartphone or tablet), a gaming console or controller, a wearable computing device, an embedded computing device, or any other type of computing device. - The
user computing device 102 includes one ormore processors 112 and amemory 114. The one ormore processors 112 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. Thememory 114 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. Thememory 114 can storedata 116 andinstructions 118 which are executed by theprocessor 112 to cause theuser computing device 102 to perform operations. - In some implementations, the
user computing device 102 can store or include one or more machine-learnedmodels 120. For example, the machine-learnedmodels 120 can be or can otherwise include various machine-learned models such as neural networks (e.g., deep neural networks) or other types of machine-learned models, including non-linear models and/or linear models. Neural networks can include feed-forward neural networks, recurrent neural networks (e.g., long short-term memory recurrent neural networks), convolutional neural networks or other forms of neural networks. Additional example machine-learning models include self-attention-based models such as transformer models. - In some implementations, the one or more machine-learned
models 120 can be received from theserver computing system 130 overnetwork 180, stored in the usercomputing device memory 114, and then used or otherwise implemented by the one ormore processors 112. In some implementations, theuser computing device 102 can implement multiple parallel instances of a single machine-learnedmodel 120. - Additionally or alternatively, one or more machine-learned
models 140 can be included in or otherwise stored and implemented by theserver computing system 130 that communicates with theuser computing device 102 according to a client-server relationship. For example, the machine-learnedmodels 140 can be implemented by theserver computing system 140 as a portion of a web service (e.g., a network analysis service). Thus, one ormore models 120 can be stored and implemented at theuser computing device 102 and/or one ormore models 140 can be stored and implemented at theserver computing system 130. - The
user computing device 102 can also include one or moreuser input component 122 that receives user input. For example, theuser input component 122 can be a touch-sensitive component (e.g., a touch-sensitive display screen or a touch pad) that is sensitive to the touch of a user input object (e.g., a finger or a stylus). The touch-sensitive component can serve to implement a virtual keyboard. Other example user input components include a microphone, a traditional keyboard, or other means by which a user can provide user input. - The
server computing system 130 includes one ormore processors 132 and amemory 134. The one ormore processors 132 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. Thememory 134 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. Thememory 134 can storedata 136 andinstructions 138 which are executed by theprocessor 132 to cause theserver computing system 130 to perform operations. - In some implementations, the
server computing system 130 includes or is otherwise implemented by one or more server computing devices. In instances in which theserver computing system 130 includes plural server computing devices, such server computing devices can operate according to sequential computing architectures, parallel computing architectures, or some combination thereof. - As described above, the
server computing system 130 can store or otherwise include one or more machine-learnedmodels 140. For example, themodels 140 can be or can otherwise include various machine-learned models. Example machine-learned models include neural networks or other multi-layer non-linear models. Example neural networks include feed forward neural networks, deep neural networks, recurrent neural networks, and convolutional neural networks. Additional example machine-learning models include self-attention-based models such as transformer models. - The
user computing device 102 and/or theserver computing system 130 can train themodels 120 and/or 140 via interaction with thetraining computing system 150 that is communicatively coupled over thenetwork 180. Thetraining computing system 150 can be separate from theserver computing system 130 or can be a portion of theserver computing system 130. - The
training computing system 150 includes one ormore processors 152 and amemory 154. The one ormore processors 152 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. Thememory 154 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. Thememory 154 can storedata 156 andinstructions 158 which are executed by theprocessor 152 to cause thetraining computing system 150 to perform operations. In some implementations, thetraining computing system 150 includes or is otherwise implemented by one or more server computing devices. - The
training computing system 150 can include amodel trainer 160 that trains the machine-learnedmodels 120 and/or 140 stored at theuser computing device 102 and/or theserver computing system 130 using various training or learning techniques, such as, for example, backwards propagation of errors. For example, a loss function can be backpropagated through the model(s) to update one or more parameters of the model(s) (e.g., based on a gradient of the loss function). Various loss functions can be used such as mean squared error, likelihood loss, cross entropy loss, hinge loss, and/or various other loss functions. Gradient descent techniques can be used to iteratively update the parameters over a number of training iterations. - In some implementations, performing backwards propagation of errors can include performing truncated backpropagation through time. The
model trainer 160 can perform a number of generalization techniques (e.g., weight decays, dropouts, etc.) to improve the generalization capability of the models being trained. - In particular, the
model trainer 160 can train the machine-learnedmodels 120 and/or 140 based on a set oftraining data 162. Thetraining data 162 can include, for example, multiple partial or complete views of a network. - In some implementations, if the user has provided consent, the training examples can be provided by the
user computing device 102. Thus, in such implementations, themodel 120 provided to theuser computing device 102 can be trained by thetraining computing system 150 on user-specific data received from theuser computing device 102. In some instances, this process can be referred to as personalizing the model. - The
model trainer 160 includes computer logic utilized to provide desired functionality. Themodel trainer 160 can be implemented in hardware, firmware, and/or software controlling a general purpose processor. For example, in some implementations, themodel trainer 160 includes program files stored on a storage device, loaded into a memory and executed by one or more processors. In other implementations, themodel trainer 160 includes one or more sets of computer-executable instructions that are stored in a tangible computer-readable storage medium such as RAM hard disk or optical or magnetic media. - The
network 180 can be any type of communications network, such as a local area network (e.g., intranet), wide area network (e.g., Internet), or some combination thereof and can include any number of wired or wireless links. In general, communication over thenetwork 180 can be carried via any type of wired and/or wireless connection, using a wide variety of communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), encodings or formats (e.g., HTML, XML), and/or protection schemes (e.g., VPN, secure HTTP, SSL). -
FIG. 1A illustrates one example computing system that can be used to implement the present disclosure. Other computing systems can be used as well. For example, in some implementations, theuser computing device 102 can include themodel trainer 160 and thetraining dataset 162. In such implementations, themodels 120 can be both trained and used locally at theuser computing device 102. In some of such implementations, theuser computing device 102 can implement themodel trainer 160 to personalize themodels 120 based on user-specific data. -
FIG. 1B depicts a block diagram of anexample computing device 10 that performs according to example embodiments of the present disclosure. Thecomputing device 10 can be a user computing device or a server computing device. - The
computing device 10 includes a number of applications (e.g.,applications 1 through N). Each application contains its own machine learning library and machine-learned model(s). For example, each application can include a machine-learned model. Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc. - As illustrated in
FIG. 1B , each application can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, each application can communicate with each device component using an API (e.g., a public API). In some implementations, the API used by each application is specific to that application. -
FIG. 1C depicts a block diagram of anexample computing device 50 that performs according to example embodiments of the present disclosure. Thecomputing device 50 can be a user computing device or a server computing device. - The
computing device 50 includes a number of applications (e.g.,applications 1 through N). Each application is in communication with a central intelligence layer. Example applications include a text messaging application, an email application, a dictation application, a virtual keyboard application, a browser application, etc. In some implementations, each application can communicate with the central intelligence layer (and model(s) stored therein) using an API (e.g., a common API across all applications). - The central intelligence layer includes a number of machine-learned models. For example, as illustrated in
FIG. 1C , a respective machine-learned model (e.g., a model) can be provided for each application and managed by the central intelligence layer. In other implementations, two or more applications can share a single machine-learned model. For example, in some implementations, the central intelligence layer can provide a single model (e.g., a single model) for all of the applications. In some implementations, the central intelligence layer is included within or otherwise implemented by an operating system of thecomputing device 50. - The central intelligence layer can communicate with a central device data layer. The central device data layer can be a centralized repository of data for the
computing device 50. As illustrated inFIG. 1C , the central device data layer can communicate with a number of other components of the computing device, such as, for example, one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, the central device data layer can communicate with each device component using an API (e.g., a private API). - The technology discussed herein makes reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and from such systems. The inherent flexibility of computer-based systems allows for a great variety of possible configurations, combinations, and divisions of tasks and functionality between and among components. For instance, processes discussed herein can be implemented using a single device or component or multiple devices or components working in combination. Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
- While the present subject matter has been described in detail with respect to various specific example embodiments thereof, each example is provided by way of explanation, not limitation of the disclosure. Those skilled in the art, upon attaining an understanding of the foregoing, can readily produce alterations to, variations of, and equivalents to such embodiments. Accordingly, the subject disclosure does not preclude inclusion of such modifications, variations and/or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art. For instance, features illustrated or described as part of one embodiment can be used with another embodiment to yield a still further embodiment. Thus, it is intended that the present disclosure cover such alterations, variations, and equivalents.
Claims (20)
1. A computer-implemented method to generate embeddings from partial view data, the method comprising:
obtaining, by one or more computing devices, a plurality of datasets that respectively correspond to a plurality of views of a graph network comprising a plurality of nodes, wherein the plurality of datasets comprise one or more partial view datasets for one or more partial views that comprise data for only a respective subset of the plurality of nodes of the graph network;
defining, by the one or more computing devices, a unified embedding for the plurality of nodes, wherein the unified embedding comprises:
a common embedding set that contains respective embeddings for common subset of the plurality of nodes that are common among all of plurality of views; and
one or more independent embedding sets that contain respective embeddings for one or more respective independent subsets of the plurality of nodes that are described by only a respective subset of the plurality of views;
processing, by the one or computing devices, each of the plurality of datasets with an encoder model to obtain, for each of the plurality of datasets, respective encoded representations of the plurality of nodes described by the corresponding view; and
modifying, by the one or more computing devices, the respective embeddings for one or more of the plurality of nodes to reduce an objective function that, for each of the plurality of views, performs a comparison of the respective encoded representations of the plurality of nodes described by such view with the respective embeddings for the nodes described by such view, and wherein, for at least one of the plurality of views, the comparison is performed using a respective embedding matrix that comprises separate respective entries for the common embedding set and at least one of the one or more independent embedding sets.
2. The computer-implemented method of claim 1 , wherein the one or more independent embedding sets comprise a plurality of independent embedding sets.
3. The computer-implemented method of claim 1 , wherein at least one of the one or more independent embedding sets contains respective embeddings for a respective independent subset of the plurality of nodes that is described by only a single view.
4. The computer-implemented method of claim 1 , wherein at least one of the one or more independent embedding sets contains respective embeddings for a respective independent subset of the plurality of nodes that is described by two or more but not all of plurality of views.
5. The computer-implemented method of claim 1 , wherein, for the at least one of the plurality of views, the respective embedding matrix consists of a first entry for the common embedding set and a second entry for a respective independent subset of the plurality of nodes that are described by only such view.
6. The computer-implemented method of claim 1 , further comprising:
modifying, by the one or more computing devices, one or more parameter values of the encoder model to reduce the objective function.
7. The computer-implemented method of claim 1 , wherein said modifying the respective embeddings for one or more of the plurality of nodes to reduce the objective function comprises minimizing the objective function.
8. The computer-implemented method of claim 1 , wherein the objective function further comprises a proximity preservation term that enforces preservation of proximity within each view.
9. The computer-implemented method of claim 1 , wherein the objective function evaluates, for each of the plurality of views, the respective difference between the respective encoded representations of the plurality of nodes obtained for such view and the respective embeddings for the nodes described by such view multiplied by a respective basis matrix for such view.
10. The computer-implemented method of claim 1 , wherein the objective function evaluates, for each of the plurality of views, a Frobenius norm of the respective difference between the respective encoded representations of the plurality of nodes obtained for such view and the respective embeddings for the nodes described by such view multiplied by a respective basis matrix for such view.
11. The computer-implemented method of claim 1 , wherein the objective function comprises a sum of respective distances evaluated for the plurality of views.
12. The computer-implemented method of claim 1 , wherein at least two of the plurality of datasets comprise different respective modalities of data.
13. A computing system, comprising:
one or more processors; and
one or more non-transitory computer-readable media that collectively store instructions that when executed by the one or more processors cause the computing system to perform operations, the operations comprising:
obtaining a unified embedding for a graph network comprising a plurality of nodes, wherein the unified embedding has been generated from a plurality of datasets that respectively correspond to a plurality of views of the graph network, wherein the plurality of datasets comprise one or more partial view datasets for one or more partial views that comprise data for only a respective subset of the plurality of nodes of the graph network, and wherein the unified embedding comprises:
a common embedding set that contains respective embeddings for common subset of the plurality of nodes that are common among all of plurality of views; and
one or more independent embedding sets that contain respective embeddings for one or more respective independent subsets of the plurality of nodes that are described by only a respective subset of the plurality of views; and
analyzing one or more of the plurality of nodes or the graph network based on the unified embedding.
14. The computing system of claim 13 , wherein the graph network comprises a social network that describes social connections between entities.
15. The computing system of claim 13 , wherein the graph network comprises a logistics network that describes logistical connections between logistical nodes.
16. The computing system of claim 13 , wherein the graph network comprises a biological network that describes biological units.
17. The computing system of claim 13 , wherein the graph network comprises a chemical network that describes chemical units.
18. The computing system of claim 13 , wherein analyzing one or more of the plurality of nodes based on the unified embedding comprises:
using the respective embedding for a first node of the plurality of nodes to:
identify one or more other nodes of the plurality of nodes that are similar to the first node;
classify the first node;
predict a link between the first node and at least one other node of the plurality of nodes;
cluster the first node with one or more other nodes; or
identify a community to which the first node belongs.
19. The computing system of claim 13 , wherein the unified embedding was generated by a second, different computing system that is distinct from the computing system.
20. The computing system of claim 13 , wherein the unified embedding was generated by the computing system.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US17/154,123 US20210224352A1 (en) | 2020-01-21 | 2021-01-21 | Deep Multi-View Network Embedding on Incomplete Data |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202062963756P | 2020-01-21 | 2020-01-21 | |
US17/154,123 US20210224352A1 (en) | 2020-01-21 | 2021-01-21 | Deep Multi-View Network Embedding on Incomplete Data |
Publications (1)
Publication Number | Publication Date |
---|---|
US20210224352A1 true US20210224352A1 (en) | 2021-07-22 |
Family
ID=76857838
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US17/154,123 Pending US20210224352A1 (en) | 2020-01-21 | 2021-01-21 | Deep Multi-View Network Embedding on Incomplete Data |
Country Status (1)
Country | Link |
---|---|
US (1) | US20210224352A1 (en) |
-
2021
- 2021-01-21 US US17/154,123 patent/US20210224352A1/en active Pending
Similar Documents
Publication | Publication Date | Title |
---|---|---|
Montavon et al. | Layer-wise relevance propagation: an overview | |
Ross et al. | Right for the right reasons: Training differentiable models by constraining their explanations | |
US20180247227A1 (en) | Machine learning systems and methods for data augmentation | |
US11113293B2 (en) | Latent network summarization | |
US10395182B2 (en) | Privacy and modeling preserved data sharing | |
US20190303535A1 (en) | Interpretable bio-medical link prediction using deep neural representation | |
Larrañaga et al. | A review on probabilistic graphical models in evolutionary computation | |
JP2023514282A (en) | Automated data analysis method, related system and apparatus for non-tabular data | |
CN113570064A (en) | Method and system for performing predictions using a composite machine learning model | |
US11556852B2 (en) | Efficient ground truth annotation | |
CN114830133A (en) | Supervised contrast learning with multiple positive examples | |
EP4120138B1 (en) | System and method for molecular property prediction using hypergraph message passing neural network (hmpnn) | |
Ren et al. | Correntropy-based robust extreme learning machine for classification | |
Gasimov et al. | Separation via polyhedral conic functions | |
US20230045690A1 (en) | System and method for molecular property prediction using edge conditioned identity mapping convolution neural network | |
US20220198266A1 (en) | Using disentangled learning to train an interpretable deep learning model | |
Chopra et al. | Introduction to machine learning with Python | |
Alshareet et al. | Incorporation of ISO 25010 with machine learning to develop a novel quality in use prediction system (QiUPS) | |
Ming | A deep learning-based framework for human resource recommendation | |
US20210224352A1 (en) | Deep Multi-View Network Embedding on Incomplete Data | |
Doboszewski | Non-uniquely extendible maximal globally hyperbolic spacetimes in classical general relativity: a philosophical survey | |
US20220207368A1 (en) | Embedding Normalization Method and Electronic Device Using Same | |
US20230162518A1 (en) | Systems for Generating Indications of Relationships between Electronic Documents | |
US20210256374A1 (en) | Method and apparatus with neural network and training | |
Chu et al. | Network embedding based on deep extreme learning machine |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:WANG, QIFAN;HE, RUINING;REEL/FRAME:054992/0323Effective date: 20200203 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: APPLICATION DISPATCHED FROM PREEXAM, NOT YET DOCKETED |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |