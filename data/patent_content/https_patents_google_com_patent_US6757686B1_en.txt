US6757686B1 - Method and apparatus for representing database and query information using interval hash tree - Google Patents
Method and apparatus for representing database and query information using interval hash tree Download PDFInfo
- Publication number
- US6757686B1 US6757686B1 US09/593,131 US59313100A US6757686B1 US 6757686 B1 US6757686 B1 US 6757686B1 US 59313100 A US59313100 A US 59313100A US 6757686 B1 US6757686 B1 US 6757686B1
- Authority
- US
- United States
- Prior art keywords
- interval
- tree
- query
- dimensional
- database
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/50—Information retrieval; Database structures therefor; File system structures therefor of still image data
- G06F16/51—Indexing; Data structures therefor; Storage structures
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99933—Query processing, i.e. searching
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99933—Query processing, i.e. searching
- Y10S707/99936—Pattern matching access
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99941—Database schema or data structure
- Y10S707/99944—Object-oriented database structure
- Y10S707/99945—Object-oriented database structure processing
Definitions
- the present invention is directed to a method and apparatus for representing indexing information in a database, and more particularly to a method and system for representing indexing and query information using an interval hash tree to allow efficient query object localization.
- index structures for fast navigation become important.
- traditional index structures used in databases such as B-tree, R-tree, R*-tree, etc., become unsuitable, especially, since the query object must be localized in the presence of pose changes, occlusions and spurious data in images.
- An efficient data structure and algorithm for the solution to this problem is important not only in content-based retrieval of image databases, but also in a number of other applications such as map-based navigation systems, VLSI design and testing, and flight simulation.
- state-of-the-art cars are equipped with vehicle navigation systems that help the user determine his/her position and guide to the user to his/her destination.
- vehicle navigation systems that help the user determine his/her position and guide to the user to his/her destination.
- Such a system stores a whole roadmap of for example, the entire U.S. It also keeps track of where the user is, so that it can show the appropriate part of the roadmap at any time on a small computer screen. This will usually be a rectangular region around the user's present position.
- the map should contain sufficient detail.
- a detailed map contains an enormous amount of data, not all of which can be displayed on the screen at one time.
- the system Given a query region isolated by a user, the system must find that part of the map (roads, cities, and so on) that lie in the window, and display them. This will require finding all regions of the map represented by possibly overlapping bounding boxes that overlap with the query window(s). Checking every single feature of the map to see if it lies inside the query window is not feasible due to the amount of data.
- R-trees and their variants [Guttman, Proc. SIGMOD, 1984, pp. 47-57, Beckman et al., Proc. SIGMOD, 1990, pp. 322-331, Sellis, Roussopolous and Faloustous, VLDB 1987, pp. 507-519, Katayama and Satoh, SIGMOD 1997, pp. 369-380 White and Jain, Int. Conf. On Data Engg., 1996, pp. 516-523, Robinson, Proc. SIGMOD 1981, pp.
- an object of the present invention is to provide a method and structure in which the above problems are solved.
- a system and method for representing database information for multiple windows using a two-way interval tree called the interval hash tree is presented.
- a second aspect of the present invention is the notion of representing the query interval information also as an interval hash tree and matching the query interval tree nodes to the database interval tree nodes in a manner that avoids redundant exploration of nodes for overlapping query intervals.
- a method and system are provided for supporting fast indexing of spatial layout queries.
- the invention creates a novel data structure called the 2-way interval hash tree.
- the method of matching query and interval hash trees nodes for nodes is the first method that can find simultaneously the set of database windows that overlap a set of query windows without ever repeating the search for overlapping query windows.
- representing and indexing of overlapping database intervals allows a novel way of locating object queries that avoids repetitious search of the database, and has implications as a new addition to index structures available to spatial databases.
- FIG. 1 illustrates a method 100 of representing database and query information for multiple windows according to the present invention
- FIGS. 2 ( a )- 2 ( c ) illustrate affine intervals and their corresponding interval hash tree (IHT), and more specifically:
- FIG. 2 ( a ) illustrates regions in an example object
- FIG. 2 ( b ) illustrates overlapping windows, and more particularly the affine intervals (rectangles) of the spatial layout of all regions with respect to region 1 using the middle basis triple from those on the boundary curve of region 1 e.
- FIG. 2 ( c ) illustrates an interval hash tree for the rectangles in FIG. 2 ( b );
- FIG. 3A illustrates a method of constructing an interval hash tree (IHT) according to the invention
- FIG. 3B illustrates a flow chart of a query y-interval hash tree step of searching an IHT using a single query window
- FIG. 3C illustrates a flowchart of a multiple query y-interval hash tree step of searching for multiple query windows
- FIG. 3D illustrates a flowchart of a query-x-interval hashtree step of searching the IHT using a single query window
- FIG. 3E illustrates a flowchart of a top-level search of query and data base interval hash trees
- FIGS. 4 ( a )- 4 ( c ) illustrate an IHT search using a set of query rectangles, and more specifically:
- FIG. 4 ( a ) illustrates the problem of finding overlap between query and database rectangles, the database rectangles being labeled R 11 , R 12 , etc., and the query rectangles being labeled Rpp, Rpt, etc.;
- FIG. 4 ( b ) illustrates the interval hash tree of the query rectangles shown in FIG. 4 ( a );
- FIG. 4 ( c ) illustrates the search path taken during matching of query IHT nodes to database IHT nodes for this example
- FIG. 5 illustrates an exemplary hardware/information handling system 500 for incorporating the present invention therein.
- FIG. 6 illustrates a signal bearing medium 600 (e.g., storage medium) for storing steps of a program of a method according to the present invention.
- a signal bearing medium 600 e.g., storage medium
- FIGS. 1-6 there are shown preferred embodiments of the method and structures according to the present invention.
- the present invention provides a novel index structure called an interval hash tree that is used to represent overlapping window information in both the database and the query.
- the interval hash tree is a two-way interval tree for storing rectangular regions. If elements of a database and a query can be represented by a collection of rectangular regions, then the interval hash tree data structure can be used to represent the combined information of the overlapping nature of database or query rectangles.
- the set of query rectangles that match a set of database rectangles is found efficiently by representing both database and query rectangles in separate interval hash trees and matching the trees node for node as will be described in detail below.
- region hashing The actual method of representing the spatial layout of objects through affine intervals, and the use of interval hash tree to find regions in images of a database that contain possible appearances of query objects, is termed region hashing, and is the subject of another related invention as disclosed in the above-mentioned commonly assigned U.S. patent application Ser. No. 09/59,3469, U.S. Pat. No. 6,691,126 to T. Syeda-Mahmood, incorporated by reference, concurrently filed herewith and having IBM Docket No. AM9-99-0238.
- the same method of finding overlapping intervals using interval hash tree can be applied to the problem of determining map areas spanned by a query area and is of use in car navigation systems.
- finding overlapping rectangles has implications in chip design and routing.
- the interval hash tree has several desirable properties. First, it is a balanced binary search tree on each of the coordinates (x and y). Secondly, the tree can be constructed in time O(nlogn) for n elements. Third, each database rectangle, and hence the region in space spanned by it, is represented only once in the tree giving rise to storage efficiency (O(n) for n elements) unlike in the case of data structures such as R-trees in which the same space is represented multiple times through hierarchical region grouping. Next, using a balanced binary search tree based on median-based partitioning of space, the search for overlapping intervals for a single query interval is made efficient. Finally, the search for matching database rectangles for each query is made efficient by consolidating the query rectangles in a query IHT, and carefully exploring node-by-node matching so as to avoid repeated exploration of database IHT.
- the windows come from several data units in the database.
- each image is a data unit, and is represented by multiple, possibly overlapping windows.
- the windows in turn, can represent several different types of information.
- the windows can be the bounding boxes of color regions found in images.
- the windows could represent the range in which affine coordinates of features of a region lie, when computed with respect to features within the region itself or with respect to features from other adjacent regions.
- step 101 the interval hash tree is created, as described below (and shown in greater detail in the method of FIG. 3 A).
- step 102 the overlapping of windows in the images of the database are recorded in the interval hash tree.
- step 103 a second, similar interval hash tree is generated for query intervals.
- each node of the query interval hash tree is used to search for matching overlapping intervals in the database interval hash tree.
- step 105 the results of matches of all nodes of the query interval hash tree are consolidated to find the best data units (e.g., Images) in the database likely to contain the query.
- the various operations involving the interval hash tree are described in detail below.
- IHT interval hash tree
- the overall tree is organized as an interval tree on one of the coordinates called the x-coordinate. If the windows are in cartesian coordinates, then it is indeed, the x-coordinate. If the coordinates are in affine coordinates, then the x-coordinate stands for the alpha-coordinate. As would be known by one of ordinary skill in the art taking the present specification as a whole, for other applications there may be other coordinate interpretations.
- the central branch node at each level is further organized as an interval tree based on the other coordinate called the y-coordinate, which is the y-coordinate in the Cartesian system or the beta-coordinate in case of an affine-base.
- the interval hash tree can be generalized so that it can be a multi-level interval tree, with nodes at successive levels being further expanded into interval trees using successive coordinates to represent multi-dimensional overlapping windows in databases (e.g., rather than the two-dimensional case being described herein).
- the invention is scalable to multiple dimensions and is not just limited to the exemplary two-dimensional case being described herein.
- FIG. 3A illustrates a brief flowchart of the method of constructing the interval hash tree, and its steps are described below.
- step 301 associate with each rectangle, the identity of the data units it comes from.
- this involves associating with each rectangle (affine interval) its image index, its region pair index, and the basis triple index.
- each affine interval ⁇ ( ⁇ mim , ⁇ min ), ( ⁇ max , ⁇ max ) ⁇ is associated with the set ⁇ R i , R j , I p , B ik ⁇ where I p is the image within which region pairs (R i , R j ) are present, and where the affine coordinates of features of region R j computed with respect to a basis triple B ik in region R i lie in the stated affine interval.
- the resulting set of rectangles are sorted based on the first coordinate (i.e. the ⁇ coordinate) (step 302 ).
- the sorted set of intervals be denoted by I.
- Xmid be the median end point in set I (step 303 ).
- the interval I is split into three subsets, namely, I xleft , I xright , and I xmid , to correspond to the set of intervals whose left and right x-end points are to left of Xmid, to the right of Xmid, and whose left x-end point is to the left and right x-end points are to the right of Xmid respectively (step 304 ).
- a bounding rectangle for the rectangles spanned by the set I can additionally be included for ease of searching at the node.
- interval I xmid then forms the central branch of a node of the x-interval tree and the I xleft and I xright form left and right subareas (denoted by Lcx(Vx) and Rcx(Vx)) of the node Vx of the x-interval tree as indicated below:
- Each of the left and right subareas are recursively constructed in a similar manner (steps 305 and 306 ) by repeatedly picking their median x-end point and splitting into the three subsets explained above.
- the algorithm for the x-interval tree construction directly follows from the description of the node above.
- each node of the x-interval tree Ixmid is organized as a y-interval tree as follows.
- the set I xmid of affine intervals is now sorted based on the second coordinate, and the median y-end point Ymid is picked (step 307 ).
- the set I xmid is then divided into three subsets, I ybelow , I yabove and I ymid (step 308 ) that contain affine intervals whose above and below y-end points are below Ymid, above Ymid, and whose above and below y-end point are on either side of Ymid respectively.
- a bounding rectangle of the set I xmid can additionally be stored at this node for ease of interval search.
- interval I ymid then forms the central branch of a node of the y-interval tree and the I ybelow and I yabove form left and right subareas (denoted by Lcy(Vy) and Rcy(Vy)) of the y-interval tree node V y as indicated below.
- the set I ymid is actually represented as two lists L Ybelow and L Yabove that capture the below and above end-points respectively, of the intervals in I xmid which straddle Ymid (step 311 ).
- L Ybelow sorted in increasing order while L Yabove is sorted in decreasing order to enable range searching as we will show later.
- the above and below branches of the y-interval tree are recursively generated by going back to step 307 (as indicated by steps 309 , 310 ). It is noted that unlike in the case of non-leaf nodes of the x-interval tree, the data associated with rectangles is listed under the central branch of a node in the y-interval tree. In the case of region hashing, this data constitutes the image index, the region index, and the basis triple index, necessary for query localization.
- FIG. 2 ( c ) depicts an interval hash tree for a set of rectangles (affine intervals). These intervals are obtained by pairing region marked 1 on the object depicted in FIG. 2 ( a ) with respect to all other marked regions on the object.
- the affine intervals themselves are indicated in FIG. 2 ( b ).
- Xlij, Xrij stand for the left and right end points of the affine interval of region j computed with respect to a basis triple in region i (in this case, the middle basis triple on region 1 's contour).
- the empty branches of the tree are denoted by circles and single interval branches by the interval itself.
- an interval hash tree construction includes the following steps (or equivalents thereof), as shown in FIG. 3 A. That is, the interval hash tree construction includes first associating with each window, the identity of the data unit it comes from. Thus, if the data unit in the database is an image, then associate with the window, the number of the image that contains it.
- step 1013 the X-interval hash tree is constructed by running CONSTRUCT_X_INTERVAL_HASH_TREE(I) algorithm.
- the x-interval hash tree in turn is constructed using the y-interval hash tree by running CONSTRUCT_X_INTERVAL_HASH_TREE(I) as follows.
- a node V x is created by picking a median coordinate Xmid of the set I and storing Xmid with V.
- I xleft is the set of windows whose left and right x-end points are to the left of Xmid.
- Ixright is the set of windows whose left and right x-end points are to the right of Xmid.
- I xmid is the set of windows whose left-x-end point is to the left of Xmid, and whose right x-end-point is to the right of the Xmid.
- the windows left in I xmid are sorted based on their second coordinate (again, this example assumes a two-dimensional case), called the y-coordinate (In the case of affine coordinates, the y-coordinate is the beta-coordinate).
- Vy CONSTRUCT_Y_INTERVAL_HASH_TREE( Ixmid )
- Vy CONSTRUCT_Y_INTERVAL_HASH_TREE( Ixmid )
- the y-interval hash tree in turn is constructed using the following steps.
- I yabove is the set of windows whose above and below y-end points are above Ymid.
- I ybelow is the set of windows whose above and below y-end points are below Ymid.
- I ymid is the set of windows whose above y-end points are above Ymid, and whose below y-end points are below Ymid.
- the Iymid list is divided into two sublists called L yabove (Vy) sorted on the above y-end point, and L ybeow (Vy) sorted on the below y-end point. Then, these two lists are stored at Vy.
- CONSTRUCT_Y_INTERVAL_HASH_TREE(I yabove ) is run which includes repeating the above steps on the I ybelow list for Rcy(Vy).
- CONSTRUCT_Y_INTERVAL_HASH_TREE(I ybelow ) is run in which Lcy(Vy) is made the left child of Vy and Rcv(Vy) is made the right child of Vy, and (Vy) is returned.
- V x is not a leaf. If V x is not a leaf, and if Qix ⁇ Xmid(V x ) and Qrx>Xmid(V x ), then the I xmid portion of the tree is explored as QUERY_Y_INTERVAL_HASH_TREE(Vy,Q).
- QUERY_X_INTERVAL_HASH_TREE(Lex(V x ),Q) and QUERY_X_INTERVAL_HASH_TREE(Lex(V x ),Q) are run.
- QUERY_Y_INTERVAL_HASH_TREE(Vy,Q) and QUERY_X_INTERVAL_HASH_TREE(Rex(V x ),Q) are run.
- first QUERY_Y_INTERVAL_HASH_TREE(Vy,Q) is run. That is, if Qay>Ymid(Vy) and Qby ⁇ Ymid(Vy), then all windows within the Iymid are determined to be overlapping. Then, the process walks along the list L yabove (Vy) starting with the top-most endpoint and computes an overlap with all the windows spanned in L yabove (Vy).
- QUERY_V_INTERVAL_HASH_TREE(Lcy(Vy),Q) and QUERY_Y_INTERVAL_HASH_TREE(Lcy(Vy),Q) are run.
- the query window is below Ymid, and the process walks along the L ybelow (Vy) starting at the interval with the bottom-most endpoint, reporting all windows that contain Qay.
- FIG. 3B shows a flow chart of the query y-interval hash tree step of searching an IHT using a single query window
- FIG. 3D shows a flowchart of a query-x-interval hash tree step of searching the IHT using a single query window.
- the above concept is extended by the invention to advantageously address the problem of searching for all database intervals that overlap with a given set of query intervals.
- the invention organizes the rectangles affine intervals of the query also as an interval hash tree, and performs a careful simultaneous search of database and query IHT in a way that maintains the property that a database interval that overlaps more than one query interval is discovered only once.
- a version of the IHT construction is used that retains the bounding box of all affine intervals under a tree node (x or y-tree node) as part of the node information.
- nodes of the query IHT are successively searched against the nodes of the database IHT.
- the range (Qlx,Qrx) in which the left and right x-end points of the interval I xmid are noted along with V x .
- the range in which the top and bottom y-end points of windows (Qay,Qby) in the interval I ymid are stored at Vy.
- searching for multiple query windows is done by using the range at each node to identify candidate nodes to search in the database interval hash tree.
- the search within the I ymid of a node is done by sequentially scanning bottom endpoints in reverse sorted order, and simultaneously incrementing the overlap count for all overlapping query windows.
- the following algorithm does a pre-order traversal of the query interval hash tree, each such traversal results in updating the set of overlapping windows for each query window.
- V x refers to the node of the database interval hash tree.
- the Q stands for the query node which includes the windows spanned by the range (Qlx,Qrx,Qay,Qby) in the Iymid of the Vq, the current node being explored in SEARCH_MULTIPLE_QUERY_WINDOWS.
- an interval hash tree is created for supporting the searching of the multiple query windows in which MULTIPLE_X_INTERVAL_HASH_TREE(Vx,Q) is run.
- V x it is determined whether V x is a leaf or not. If V x is not a leaf and if it determined that Qlx ⁇ Xrnid(V x ) and Qrx>Xmid(V x ), then the I xmid portion of the tree is explored as MULTIPLE_QUERY_Y_INTERVAL_HASH_TREE(Vy,Q) is run. Then, MULTIPLE_QUERY_X_INTERVAL_HASH_TREE(Lcx(V x ),Q) and MULTIPLE_QUERY_X_INTERVAL_HASH_TREE(Rcx(V x ),Q) are run.
- MULTIPLE_QUERY_Y_INTERVAL_HASH_TREE(Lcy(Vy),Q) and MULTIPLE_QUERY_Y_INTERVAL_HASH_TREE(Rcy(Vy),Q) are run.
- the order of exploration is V qx ⁇ V qy , Lcy(V qy ), Rcy(V qy ) ⁇ followed by Lcx(V qx ) and Rcx(V qx ).
- the bounding rectangle range Qlx, Qrx, Qby, Qay is used to determine which of the subareas to explore.
- V xd For example, if Qlx ⁇ Xmid (V xd ) ⁇ Qly, then matching intervals can be found in either the y-interval tree under V xd i.e. V yd , or the left and right subareas Lcx(V xd ) and Rcx(V d ) of V xd .
- the algorithm for searching x-interval hash tree is reproduced above.
- FIG. 3C shows a flowchart of the multiple query y-interval hash tree step of searching for multiple query windows whereas, FIG. 3E shows a flowchart of a top-level search of query and data base interval hash trees.
- the database IHT is shown in FIG. 2 ( c ).
- the corresponding rectangles are labeled as R 11 ,R 12 ,R 13 ,R 14 and R 15 in FIG. 4 ( a ).
- a query is selected whose intervals are as shown in FIG. 4 ( a ) labeled as Rpp,Rpq,Rpr,Rps,and Rpt.
- the corresponding query IHT is shown in FIG. 4 ( b ).
- a node number is assigned to each node in the two trees to illustrate the order of navigation. The order in which nodes will be examined and the overlap discovered is shown in FIG. 4 ( c ).
- the left or the right subtree branches are left out during some recursive traversals (e.g., (q 2 ,v 7 ) (q 2 ,v 6 ) but not (q 2 ,v 5 )).
- the overlap of region-pair (pt, 14 ) is automatically derived from the overlap of region pair (ps, 14 ) without explicit search. It is further noted that all overlapping intervals are found by this process.
- an interval hash tree for a set of n affine intervals uses O(n) storage and can be built in O(nlogn) time. This is because each affine interval is stored in at most one tree node.
- the dominating time for construction is the sorting of the intervals done at most once on each coordinate, taking O(nlogn) time. Since the tree was generated using median end-points for node splitting, it is a balanced search tree.
- the search for matches can explore only the left subtree, the right subtree, or the middle branch and/or both left and right subtrees. That is, for query affine intervals that lie to one side of the median point at any node level, only one of the branches is explored. However, for query intervals that straddle a median point, both branches of the tree are explored, suggesting that in some worst cases, it is possible to incur O(n) search. While this may appear wasteful for query intervals that overlap only a few database intervals, it is still better than a linear search per query interval (an O(n 2 ) operation overall).
- the total time for search of all windows that overlap a query window takes time O(log 2 n+K) where K is the actual number of intersections, and can be searched in O(log n) time where n is the number of windows.
- the total time for search for all windows that overlap a query window is O(log n+k) where k is the number of overlapping windows. It is noted also that each window of the database is examined only once since it is only one place in the interval hash tree.
- the overlap within database intervals also affects search complexity. Large overlaps within database intervals have the effect of flattening the database IHT so that most of the intervals end up in Iymid branch at each node. In such cases, however, the region ordering in the lists L yabove and L ybelow can actually reduce the search time, since the operation stops as soon as a non-overlapping interval is found.
- R-trees and their variants also address the problem of finding database rectangles that overlap with query rectangle, their relative merits can be compared in a qualitative manner.
- the R-tree variants are targeted towards achieving good paging performance assuming secondary disk storage for data.
- the IHT is primarily a main-memory data structure. Because of the two-way interval tree organization, however, it is possible to arrive at efficient paging schemes even for IHT by storing the y-interval trees under nodes of x-interval trees in separate pages.
- the intermediate nodes in IHT are meant as guiding information, with leaves storing the actual data.
- the number of nodes searched in both cases is a function of relative position of the query rectangle and the amount of overlap between database rectangles.
- R-trees can may detect such outliers faster.
- bounding rectangles at each interval tree node the search for such outliers can be made fast even in IHT.
- FIG. 5 illustrates a typical hardware configuration of an information handling/computer system for use with the invention and which preferably has at least one processor or central processing unit (CPU) 511 .
- processor or central processing unit (CPU) 511 .
- the CPUs 511 are interconnected via a system bus 512 to a random access memory (RAM) 514 , read-only memory (ROM) 516 , input/output (I/O) adapter 518 (for connecting peripheral devices such as disk units 521 and tape drives 540 to the bus 512 ), user interface adapter 522 (for connecting a keyboard 524 , mouse 526 , speaker 528 , microphone 532 , and/or other user interface device to the bus 512 ), a communication adapter 534 for connecting an information handling system to a data processing network, the Internet, an Intranet, a personal area network (PAN), etc., and a display adapter 536 for connecting the bus 512 to a display device 538 and/or printer.
- RAM random access memory
- ROM read-only memory
- I/O input/output
- user interface adapter 522 for connecting a keyboard 524 , mouse 526 , speaker 528 , microphone 532 , and/or other user interface device to the bus 512
- the IHT can be provided in either the main memory (e.g., RAM 514 ) or can be organized such that part of it lies in the main memory module (RAM 514 ), while other portions of the tree lie in secondary memory (e.g., disk units 521 , tape drives 540 , etc.).
- main memory e.g., RAM 514
- secondary memory e.g., disk units 521 , tape drives 540 , etc.
- a different aspect of the invention includes a computer-implemented method for performing the above method. As an example, this method may be implemented in the particular environment discussed above.
- Such a method may be implemented, for example, by operating a computer, as embodied by a digital data processing apparatus, to execute a sequence of machine-readable instructions. These instructions may reside in various types of signal-bearing media.
- This signal-bearing media may include, for example, a RAM contained within the CPU 511 , as represented by the fast-access storage for example.
- the instructions may be contained in another signal-bearing media, such as a magnetic data storage diskette 600 (FIG. 6 ), directly or indirectly accessible by the CPU 511 .
- the instructions may be stored on a variety of machine-readable data storage media, such as DASD storage (e.g., a conventional “hard drive” or a RAID array), magnetic tape, electronic read-only memory (e.g., ROM, EPROM, or EEPROM), an optical storage device (e.g. CD-ROM, WORM, DVD, digital optical tape, etc.), paper “punch” cards, or other suitable signal-bearing media including transmission media such as digital and analog and communication links and wireless.
- DASD storage e.g., a conventional “hard drive” or a RAID array
- magnetic tape e.g., magnetic tape, electronic read-only memory (e.g., ROM, EPROM, or EEPROM), an optical storage device (e.g. CD-ROM, WORM, DVD, digital optical tape, etc.), paper “punch” cards, or other suitable signal-bearing media including transmission media such as digital and analog and communication links and wireless.
- the machine-readable instructions may comprise software object code,
- a novel method for simultaneously finding overlap of multiple query windows to multiple, possibly overlapping database windows. Further, the invention uses an interval hash tree, and allows a method of matching two interval hash trees.
- a method for representing indexing information in the database using an interval hash tree.
- the interval hash tree can be used to localize queries in unsegmented images.
Abstract
Description
Claims (25)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/593,131 US6757686B1 (en) | 2000-06-14 | 2000-06-14 | Method and apparatus for representing database and query information using interval hash tree |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/593,131 US6757686B1 (en) | 2000-06-14 | 2000-06-14 | Method and apparatus for representing database and query information using interval hash tree |
Publications (1)
Publication Number | Publication Date |
---|---|
US6757686B1 true US6757686B1 (en) | 2004-06-29 |
Family
ID=32508276
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/593,131 Expired - Lifetime US6757686B1 (en) | 2000-06-14 | 2000-06-14 | Method and apparatus for representing database and query information using interval hash tree |
Country Status (1)
Country | Link |
---|---|
US (1) | US6757686B1 (en) |
Cited By (23)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20020193975A1 (en) * | 2001-06-19 | 2002-12-19 | International Business Machines Corporation | Manipulation of electronic media using off-line media |
US20050063545A1 (en) * | 2003-09-19 | 2005-03-24 | Ntt Docomo, Inc | Structured document signature device, structured document adaptation device and structured document verification device |
US20050187907A1 (en) * | 2004-02-20 | 2005-08-25 | Microsoft Corporation | Systems and methods for updating a query engine opcode tree |
US20050187947A1 (en) * | 2004-02-20 | 2005-08-25 | Microsoft Corporation | Systems and methods for parallel evaluation of multiple queries |
US20050203932A1 (en) * | 2001-06-22 | 2005-09-15 | Oracle International Corporation | Pruning of spatial queries on geodetic data when query window has holes |
US20060004715A1 (en) * | 2004-06-30 | 2006-01-05 | Sap Aktiengesellschaft | Indexing stored data |
US20060143206A1 (en) * | 2004-12-29 | 2006-06-29 | Lock Hendrik C | Interval tree for identifying intervals that intersect with a query interval |
US20060271540A1 (en) * | 2005-03-11 | 2006-11-30 | Williams Ross N | Method and apparatus for indexing in a reduced-redundancy storage system |
US20060282457A1 (en) * | 2005-03-11 | 2006-12-14 | Williams Ross N | Method and apparatus for storing data with reduced redundancy using data clusters |
WO2007053295A1 (en) * | 2005-11-01 | 2007-05-10 | Microsoft Corporation | Hash function constructions from expander graphs |
US20070192548A1 (en) * | 2005-03-11 | 2007-08-16 | Williams Ross N | Method and apparatus for detecting the presence of subblocks in a reduced-redundancy storage system |
US20090100007A1 (en) * | 2004-07-04 | 2009-04-16 | Yahoo! Inc. | Customized geographical location indexing |
US20090112846A1 (en) * | 2007-10-31 | 2009-04-30 | Vee Erik N | System and/or method for processing events |
US20100082636A1 (en) * | 2008-09-25 | 2010-04-01 | Nec Laboratories America, Inc. | Methods and Apparatus for Content-Defined Node Splitting |
US20140081930A1 (en) * | 2001-03-05 | 2014-03-20 | Sap Ag | Compression scheme for improving cache behavior in database systems |
US8781255B2 (en) | 2011-09-17 | 2014-07-15 | Adobe Systems Incorporated | Methods and apparatus for visual search |
US20140245127A1 (en) * | 2013-02-28 | 2014-08-28 | Nokia Corporation | Method and apparatus for automated real-time detection of overlapping painted markup elements |
US8874557B2 (en) | 2011-09-02 | 2014-10-28 | Adobe Systems Incorporated | Object retrieval and localization using a spatially-constrained similarity model |
US8880563B2 (en) | 2012-09-21 | 2014-11-04 | Adobe Systems Incorporated | Image search by query object segmentation |
US9223789B1 (en) * | 2013-03-14 | 2015-12-29 | Amazon Technologies, Inc. | Range retrievals from archived data objects according to a predefined hash tree schema |
US10387495B2 (en) * | 2016-06-10 | 2019-08-20 | Palo Alto Research Center Incorporated | System and method for efficient interval search using locality-preserving hashing |
CN110413807A (en) * | 2019-06-24 | 2019-11-05 | 华中科技大学 | A kind of image inquiry method and system based on contents semantic metadata |
US11120052B1 (en) * | 2018-06-28 | 2021-09-14 | Amazon Technologies, Inc. | Dynamic distributed data clustering using multi-level hash trees |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5875445A (en) * | 1997-05-29 | 1999-02-23 | Oracle Corporation | Performance-related estimation using pseudo-ranked trees |
US5920857A (en) * | 1997-08-04 | 1999-07-06 | Naphtali Rishe | Efficient optimistic concurrency control and lazy queries for B-trees and other database structures |
US6321232B1 (en) * | 1998-12-18 | 2001-11-20 | Xerox Corporation | Method for creating a geometric hash tree in a document processing system |
US6505191B1 (en) * | 1998-07-24 | 2003-01-07 | Jarg Corporation | Distributed computer database system and method employing hypertext linkage analysis |
-
2000
- 2000-06-14 US US09/593,131 patent/US6757686B1/en not_active Expired - Lifetime
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5875445A (en) * | 1997-05-29 | 1999-02-23 | Oracle Corporation | Performance-related estimation using pseudo-ranked trees |
US5920857A (en) * | 1997-08-04 | 1999-07-06 | Naphtali Rishe | Efficient optimistic concurrency control and lazy queries for B-trees and other database structures |
US6505191B1 (en) * | 1998-07-24 | 2003-01-07 | Jarg Corporation | Distributed computer database system and method employing hypertext linkage analysis |
US6321232B1 (en) * | 1998-12-18 | 2001-11-20 | Xerox Corporation | Method for creating a geometric hash tree in a document processing system |
Cited By (43)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20140081930A1 (en) * | 2001-03-05 | 2014-03-20 | Sap Ag | Compression scheme for improving cache behavior in database systems |
US9069809B2 (en) * | 2001-03-05 | 2015-06-30 | Sap Se | Compression scheme for improving cache behavior in database systems |
US7085693B2 (en) | 2001-06-19 | 2006-08-01 | International Business Machines Corporation | Manipulation of electronic media using off-line media |
US20020193975A1 (en) * | 2001-06-19 | 2002-12-19 | International Business Machines Corporation | Manipulation of electronic media using off-line media |
US7379936B2 (en) * | 2001-06-22 | 2008-05-27 | Oracle International Corporation | Pruning of spatial queries on geodetic data when query window has holes |
US20050203932A1 (en) * | 2001-06-22 | 2005-09-15 | Oracle International Corporation | Pruning of spatial queries on geodetic data when query window has holes |
US20050063545A1 (en) * | 2003-09-19 | 2005-03-24 | Ntt Docomo, Inc | Structured document signature device, structured document adaptation device and structured document verification device |
US7639818B2 (en) * | 2003-09-19 | 2009-12-29 | Ntt Docomo, Inc. | Structured document signature device, structured document adaptation device and structured document verification device |
US20050187907A1 (en) * | 2004-02-20 | 2005-08-25 | Microsoft Corporation | Systems and methods for updating a query engine opcode tree |
US20050187947A1 (en) * | 2004-02-20 | 2005-08-25 | Microsoft Corporation | Systems and methods for parallel evaluation of multiple queries |
US7664728B2 (en) | 2004-02-20 | 2010-02-16 | Microsoft Corporation | Systems and methods for parallel evaluation of multiple queries |
US7539691B2 (en) * | 2004-02-20 | 2009-05-26 | Microsoft Corporation | Systems and methods for updating a query engine opcode tree |
US7761474B2 (en) | 2004-06-30 | 2010-07-20 | Sap Ag | Indexing stored data |
US20060004715A1 (en) * | 2004-06-30 | 2006-01-05 | Sap Aktiengesellschaft | Indexing stored data |
US20090100007A1 (en) * | 2004-07-04 | 2009-04-16 | Yahoo! Inc. | Customized geographical location indexing |
US8051087B2 (en) * | 2004-07-04 | 2011-11-01 | Yahoo! Inc. | Customized geographical location indexing |
US20060143206A1 (en) * | 2004-12-29 | 2006-06-29 | Lock Hendrik C | Interval tree for identifying intervals that intersect with a query interval |
US7512617B2 (en) * | 2004-12-29 | 2009-03-31 | Sap Aktiengesellschaft | Interval tree for identifying intervals that intersect with a query interval |
US20070192548A1 (en) * | 2005-03-11 | 2007-08-16 | Williams Ross N | Method and apparatus for detecting the presence of subblocks in a reduced-redundancy storage system |
US20060282457A1 (en) * | 2005-03-11 | 2006-12-14 | Williams Ross N | Method and apparatus for storing data with reduced redundancy using data clusters |
US20060271540A1 (en) * | 2005-03-11 | 2006-11-30 | Williams Ross N | Method and apparatus for indexing in a reduced-redundancy storage system |
US7814129B2 (en) | 2005-03-11 | 2010-10-12 | Ross Neil Williams | Method and apparatus for storing data with reduced redundancy using data clusters |
US8051252B2 (en) | 2005-03-11 | 2011-11-01 | Ross Neil Williams | Method and apparatus for detecting the presence of subblocks in a reduced-redundancy storage system |
US8214607B2 (en) | 2005-03-11 | 2012-07-03 | Ross Neil Williams | Method and apparatus for detecting the presence of subblocks in a reduced-redundancy storage system |
US8356021B2 (en) * | 2005-03-11 | 2013-01-15 | Ross Neil Williams | Method and apparatus for indexing in a reduced-redundancy storage system |
WO2007053295A1 (en) * | 2005-11-01 | 2007-05-10 | Microsoft Corporation | Hash function constructions from expander graphs |
US7382876B2 (en) | 2005-11-01 | 2008-06-03 | Microsoft Corporation | Hash function constructions from expander graphs |
KR101292927B1 (en) | 2005-11-01 | 2013-08-02 | 마이크로소프트 코포레이션 | Hash function constructions from expander graphs |
US7890494B2 (en) * | 2007-10-31 | 2011-02-15 | Yahoo! Inc. | System and/or method for processing events |
US20090112846A1 (en) * | 2007-10-31 | 2009-04-30 | Vee Erik N | System and/or method for processing events |
US20100082636A1 (en) * | 2008-09-25 | 2010-04-01 | Nec Laboratories America, Inc. | Methods and Apparatus for Content-Defined Node Splitting |
US8874557B2 (en) | 2011-09-02 | 2014-10-28 | Adobe Systems Incorporated | Object retrieval and localization using a spatially-constrained similarity model |
US8983940B2 (en) | 2011-09-02 | 2015-03-17 | Adobe Systems Incorporated | K-nearest neighbor re-ranking |
US8805116B2 (en) | 2011-09-17 | 2014-08-12 | Adobe Systems Incorporated | Methods and apparatus for visual search |
US8781255B2 (en) | 2011-09-17 | 2014-07-15 | Adobe Systems Incorporated | Methods and apparatus for visual search |
US8880563B2 (en) | 2012-09-21 | 2014-11-04 | Adobe Systems Incorporated | Image search by query object segmentation |
US20140245127A1 (en) * | 2013-02-28 | 2014-08-28 | Nokia Corporation | Method and apparatus for automated real-time detection of overlapping painted markup elements |
US9367938B2 (en) * | 2013-02-28 | 2016-06-14 | Nokia Technologies Oy | Method and apparatus for automated real-time detection of overlapping painted markup elements |
US9223789B1 (en) * | 2013-03-14 | 2015-12-29 | Amazon Technologies, Inc. | Range retrievals from archived data objects according to a predefined hash tree schema |
US10387495B2 (en) * | 2016-06-10 | 2019-08-20 | Palo Alto Research Center Incorporated | System and method for efficient interval search using locality-preserving hashing |
US11120052B1 (en) * | 2018-06-28 | 2021-09-14 | Amazon Technologies, Inc. | Dynamic distributed data clustering using multi-level hash trees |
CN110413807A (en) * | 2019-06-24 | 2019-11-05 | 华中科技大学 | A kind of image inquiry method and system based on contents semantic metadata |
CN110413807B (en) * | 2019-06-24 | 2021-04-20 | 华中科技大学 | Image query method and system based on content semantic metadata |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6757686B1 (en) | Method and apparatus for representing database and query information using interval hash tree | |
US5978794A (en) | Method and system for performing spatial similarity joins on high-dimensional points | |
Lee et al. | Computational geometry—a survey | |
Sheikholeslami et al. | SemQuery: semantic clustering and querying on heterogeneous features for visual data | |
Hjaltason et al. | Ranking in spatial databases | |
US6154746A (en) | High-dimensional index structure | |
Traina et al. | Fast indexing and visualization of metric data sets using slim-trees | |
US5806061A (en) | Method for cost-based optimization over multimeida repositories | |
Stefanovic et al. | Object-based selective materialization for efficient implementation of spatial data cubes | |
Tao et al. | Efficient skyline and top-k retrieval in subspaces | |
Hjaltason et al. | Index-driven similarity search in metric spaces (survey article) | |
US5920856A (en) | System for selecting multimedia databases over networks | |
US5799312A (en) | Three-dimensional affine-invariant hashing defined over any three-dimensional convex domain and producing uniformly-distributed hash keys | |
JP2004178605A (en) | Information retrieval device and its method | |
Siqueira et al. | The SB-index and the HSB-index: efficient indices for spatial data warehouses | |
CN106991141A (en) | A kind of association rule mining method based on depth pruning strategy | |
Kiranyaz et al. | Hierarchical cellular tree: An efficient indexing scheme for content-based retrieval on multimedia databases | |
Theodoridis et al. | Range queries involving spatial relations: A performance analysis | |
WO2005008519A1 (en) | Combined search method for content-based image retrieval | |
Al Aghbari | Array-index: a plug&search K nearest neighbors method for high-dimensional data | |
Tan et al. | Indexing shapes in image databases using the centroid–radii model | |
Park et al. | An enhanced technique for k-nearest neighbor queries with non-spatial selection predicates | |
Syed et al. | Incremental and scalable computation of dynamic topography information landscapes | |
JP2001134593A (en) | Method and device for neighborhood data retrieval and storage medium stored with neighborhood data retrieving program | |
Abel et al. | Caching strategies for spatial joins |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:SYEDA-MAHMOOD, TANVEER FATHIMA;RAGHAVAN, PRABHAKAR;MEGIDDO, NIMROD;REEL/FRAME:011237/0385;SIGNING DATES FROM 20000928 TO 20001003 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026894/0001Effective date: 20110817 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
FPAY | Fee payment |
Year of fee payment: 12 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |