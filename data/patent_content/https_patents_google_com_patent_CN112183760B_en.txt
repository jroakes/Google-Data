CN112183760B - System and method for reducing idle of machine learning training system using data echo - Google Patents
System and method for reducing idle of machine learning training system using data echo Download PDFInfo
- Publication number
- CN112183760B CN112183760B CN202010459362.2A CN202010459362A CN112183760B CN 112183760 B CN112183760 B CN 112183760B CN 202010459362 A CN202010459362 A CN 202010459362A CN 112183760 B CN112183760 B CN 112183760B
- Authority
- CN
- China
- Prior art keywords
- training
- operations
- machine learning
- computing devices
- data
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
- 238000012549 training Methods 0.000 title claims abstract description 616
- 238000010801 machine learning Methods 0.000 title claims abstract description 126
- 238000000034 method Methods 0.000 title claims abstract description 63
- 239000000872 buffer Substances 0.000 claims description 46
- 238000012545 processing Methods 0.000 claims description 24
- 230000006870 function Effects 0.000 claims description 15
- 230000009466 transformation Effects 0.000 claims description 13
- 230000008569 process Effects 0.000 claims description 11
- 238000004364 calculation method Methods 0.000 claims description 8
- 230000008859 change Effects 0.000 claims description 7
- 230000002708 enhancing effect Effects 0.000 claims description 7
- 238000011156 evaluation Methods 0.000 claims description 5
- 230000003190 augmentative effect Effects 0.000 claims description 3
- 238000012544 monitoring process Methods 0.000 claims description 3
- 239000000306 component Substances 0.000 description 85
- 238000002592 echocardiography Methods 0.000 description 46
- 238000013528 artificial neural network Methods 0.000 description 24
- 238000011144 upstream manufacturing Methods 0.000 description 24
- 230000015654 memory Effects 0.000 description 21
- 238000002474 experimental method Methods 0.000 description 20
- 238000004422 calculation algorithm Methods 0.000 description 12
- 230000008901 benefit Effects 0.000 description 11
- 238000010586 diagram Methods 0.000 description 10
- 230000001133 acceleration Effects 0.000 description 9
- 238000004891 communication Methods 0.000 description 9
- 230000000694 effects Effects 0.000 description 7
- 230000000875 corresponding effect Effects 0.000 description 6
- 230000006872 improvement Effects 0.000 description 6
- 238000007781 pre-processing Methods 0.000 description 6
- 230000003993 interaction Effects 0.000 description 5
- 238000012986 modification Methods 0.000 description 5
- 230000004048 modification Effects 0.000 description 5
- 230000008521 reorganization Effects 0.000 description 5
- 238000000844 transformation Methods 0.000 description 5
- 230000006399 behavior Effects 0.000 description 4
- 230000002596 correlated effect Effects 0.000 description 4
- 238000013434 data augmentation Methods 0.000 description 4
- 238000003780 insertion Methods 0.000 description 4
- 230000037431 insertion Effects 0.000 description 4
- 238000001514 detection method Methods 0.000 description 3
- 238000013459 approach Methods 0.000 description 2
- 230000002860 competitive effect Effects 0.000 description 2
- 238000011143 downstream manufacturing Methods 0.000 description 2
- 230000002779 inactivation Effects 0.000 description 2
- 238000013383 initial experiment Methods 0.000 description 2
- 239000011159 matrix material Substances 0.000 description 2
- 238000010606 normalization Methods 0.000 description 2
- 230000002688 persistence Effects 0.000 description 2
- 230000000306 recurrent effect Effects 0.000 description 2
- 230000009467 reduction Effects 0.000 description 2
- 230000003068 static effect Effects 0.000 description 2
- 238000012360 testing method Methods 0.000 description 2
- 238000007476 Maximum Likelihood Methods 0.000 description 1
- AVUYXHYHTTVPRX-UHFFFAOYSA-N Tris(2-methyl-1-aziridinyl)phosphine oxide Chemical compound CC1CN1P(=O)(N1C(C1)C)N1C(C)C1 AVUYXHYHTTVPRX-UHFFFAOYSA-N 0.000 description 1
- 230000009471 action Effects 0.000 description 1
- 238000007792 addition Methods 0.000 description 1
- 230000003416 augmentation Effects 0.000 description 1
- 230000003139 buffering effect Effects 0.000 description 1
- 239000003795 chemical substances by application Substances 0.000 description 1
- 239000003086 colorant Substances 0.000 description 1
- 230000001276 controlling effect Effects 0.000 description 1
- 239000008358 core component Substances 0.000 description 1
- 238000013461 design Methods 0.000 description 1
- 230000001627 detrimental effect Effects 0.000 description 1
- 238000011161 development Methods 0.000 description 1
- 238000005516 engineering process Methods 0.000 description 1
- 230000002349 favourable effect Effects 0.000 description 1
- 230000002452 interceptive effect Effects 0.000 description 1
- 239000012464 large buffer Substances 0.000 description 1
- 230000007787 long-term memory Effects 0.000 description 1
- 238000005259 measurement Methods 0.000 description 1
- 230000008450 motivation Effects 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 238000005457 optimization Methods 0.000 description 1
- 230000001737 promoting effect Effects 0.000 description 1
- 230000002787 reinforcement Effects 0.000 description 1
- 230000003362 replicative effect Effects 0.000 description 1
- 238000005070 sampling Methods 0.000 description 1
- 230000006403 short-term memory Effects 0.000 description 1
- 238000006467 substitution reaction Methods 0.000 description 1
- 229920002803 thermoplastic polyurethane Polymers 0.000 description 1
- 230000001131 transforming effect Effects 0.000 description 1
Abstract
A method for reducing idleness in a machine learning training system may include performing, by a computing device, operations. The first set of training operations may access and prepare a plurality of training examples of the training data set. The second set of training operations may train the machine learning model based at least in part on the set of training data and may include one or more iterations in which at least a portion of the second set of training operations are repeatedly performed such that training examples are repeated for training the machine learning model. The rate of the repeated iterations may be based at least in part on an echo factor, which may be based at least in part on a comparison of a first computation time of the first set of training operations to a second computation time of the second set of training operations.
Description
Technical Field
The present disclosure relates generally to training of machine learning models. More particularly, the present disclosure relates to a system and method for reducing idleness in a machine learning training system.
Background
Training of machine learning models can generally be divided into a data preprocessing step and a subsequent training step using processed data. The data preprocessing step may generally take longer than the subsequent training steps. For example, specialized hardware has been developed that can greatly increase the speed of parallel processing, as is common in training steps. In various cases, such specialized hardware may be referred to as "acceleration" hardware, "accelerators," Application Specific Integrated Circuits (ASICs), and/or other terminology. Example dedicated hardware includes a Graphics Processing Unit (GPU), a Tensor Processing Unit (TPU), and/or the like. Because of this dedicated hardware (and other factors), execution of the training steps may start and stop as the preprocessed training data becomes intermittently available. Accordingly, systems and methods for reducing idleness in machine learning training systems would be welcome in the art.
Disclosure of Invention
Aspects and advantages of embodiments of the disclosure will be set forth in part in the description which follows, or may be learned from the description, or may be learned by practice of the embodiments.
One example aspect of the present disclosure relates to a method for reducing idleness in a machine learning training system, which may include: executing, by the one or more computing devices, the first set of training operations to access and prepare a plurality of training examples included in the training data set; and performing, by the one or more computing devices, the second set of training operations to train the machine learning model based at least in part on the set of training data. Performing the second set of training operations may include: one or more iterations are performed by the one or more computing devices, wherein at least a portion of the second set of training operations is repeatedly performed on at least one training example of the plurality of training examples included in the training data set such that the at least one training example is repeatedly used to train the machine learning model. The rate of one or more iterations may be based at least in part on an echo factor based at least in part on a comparison of a first computation time associated with performing a first set of training operations and a second computation time associated with performing a second set of training operations.
Another example aspect of the disclosure relates to a computing system configured to perform a training process to train a machine learning model based on a training data set that may include a plurality of training examples. The computing system may include: a computer readable storage disk configured to store a plurality of training examples; and a first set of hardware components configured to run a first set of training operations to access a plurality of training examples from a computer-readable storage disk, prepare the plurality of training examples for training the machine learning model, and store the prepared training examples in an intermediate data buffer. The intermediate data buffer may be configured to store the prepared training examples. The computing system may include a second set of hardware components configured to run a second set of training operations to access the prepared training examples from the intermediate data buffer and train the machine learning model using the prepared training examples. The second set of hardware components may be configured to perform one or more iterations, wherein the second set of hardware components repeatedly accesses the at least one prepared training example from the intermediate data buffer and repeatedly uses the at least one prepared training example to train the machine learning model. The rate at which the second set of hardware components is configured to perform one or more iterations is based at least in part on an echo factor based at least in part on a comparison of a first computation time associated with performing a first set of training operations by the first set of hardware components and a second computation time associated with performing a second set of training operations by the second set of hardware components.
Other aspects of the disclosure are directed to various systems, apparatuses, non-transitory computer-readable media, user interfaces, and electronic devices.
These and other features, aspects, and advantages of various embodiments of the present disclosure will become better understood with reference to the following description and appended claims. The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate exemplary embodiments of the disclosure and together with the description, serve to explain the principles of interest.
Drawings
A detailed discussion of embodiments directed to one of ordinary skill in the art is set forth in the specification with reference to the accompanying drawings, in which:
FIG. 1A depicts a block diagram of an example computing system for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure.
FIG. 1B depicts a block diagram of an example computing system for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure.
FIG. 1C depicts a block diagram of an example computing system for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure.
FIG. 2 is a simplified schematic diagram of a computing system for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure.
FIG. 3 depicts a block diagram of an example machine learning model, according to an example embodiment of the present disclosure.
FIG. 4 depicts a flowchart of an example method for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure.
FIG. 5 depicts a flowchart of another example method for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure.
Fig. 6 depicts a typical neural network training pipeline.
FIG. 7 depicts a case where overlapping computation times upstream and downstream of pipeline stages of a data echo insertion point are provided if stages are executed in parallel and t upstreamÔºù2tdownstream.
Fig. 8 depicts a case where e=2 data echoes, or the number of fresh examples required to reach the target out-of-sample performance is reduced or not changed, the dashed line indicating the expected value that would be useful if the examples were repeated as the fresh examples.
Fig. 9 depicts a case where the training time score assuming different R values varies, R being the ratio of the upstream and downstream computation times, the data echo may reduce the training time of a series of echo factors around the optimal value e=r, especially when e R is equal to or smaller than R, the y-axis being the logarithmic scale.
Fig. 10 depicts a case where the example echo reduces the number of fresh examples required for the transducer on LM1B for echo factors up to (at least) 16. For batch size 1024 there is a maximum useful echo factor somewhere between 4 and 8, while for batch size 4096 the maximum useful echo factor is greater than 16, the dashed line indicates the expected value that would be useful if the example were repeated as with the fresh example.
FIG. 11 depicts the case where the performance of the batch echo relative to the baseline either remains the same or increases as the batch size increases, while for an example echo, by increasing the score of the duplicate example at each batch, its performance either does not change or deteriorates, with the dashed line indicating the expected value that would be useful if the duplicate example were as fresh.
Fig. 12 depicts a situation where the data echo with more reorganization performs better, the dashed line indicates the expected values that would be useful if the example were repeated as the fresh example.
FIG. 13 depicts a trial to obtain the best out-of-sample performance within the fresh example budget.
Detailed Description
Overview
In general, the present disclosure is directed to systems and methods for reducing idleness in machine learning training systems. The computing system may include a first set of hardware components (e.g., a general purpose processor and associated memory components) configured to perform a first set of training operations to access and prepare a plurality of training examples included in a training data set. The computing system may also include a second set of hardware components (e.g., one or more dedicated hardware units included in the model training system) configured to perform a second set of training operations to train the machine learning model based at least in part on the set of training data (e.g., in parallel with execution of the first set of operations). The first set of training operations (which may also be referred to as, for example, "upstream" processing tasks) may include reading, decoding, shuffling, enhancing, and/or batching training data to prepare training data. However, the first set of training operations takes longer to complete than the second set of training operations (which may also be referred to as a "downstream" process), which may include training the model based on the prepared training data (e.g., by performing gradient descent techniques and/or other training techniques). According to an aspect of the disclosure, a computing system may execute data echo (echo) to reduce "downstream" processing and/or idle time of a second set of hardware components. More specifically, training iterations may be repeatedly performed on some or all of the training examples such that the second set of hardware components may continue to perform the second set of operations (e.g., training a machine learning model) even when no new or "fresh" training examples are available in the first set of hardware components. Thus, performing repeated iterations may reduce the idleness of the system by reducing "idle time" when the first set of training operations is being performed but the second set of training operations is not being performed. Furthermore, experiments have shown that this can reduce the number of fresh training examples required to train the machine learning model to reach a given performance benchmark. Appendix a, which is incorporated into and forms a part of the present disclosure, includes data from experiments, showing and quantifying the benefits achieved by performing data echoes in accordance with the present disclosure.
More specifically, for the same training example, a number of iterations of repeating (e.g., by the second set of computing hardware components) based on the echo factor may be performed. The number of iterations of a given training example may be positively correlated with or otherwise based on an echo factor. For example, an echo factor of 2 may correspond to performing a single iteration of each training example, resulting in a total of two iterations per training example. The echo factor may be selected to reduce (e.g., minimize, eliminate, etc.) idle time. As described above, idle time may be defined as a first set of training operations being performed (e.g., preprocessing training data) but not a second set of training operations being performed (e.g., training a model based on the preprocessed training data).
According to another aspect of the disclosure, the echo factor may be based on a computation time and/or rate associated with accessing data and/or training a machine learning model to minimize idle time. More specifically, the echo factor may be based on a comparison of a first computation time associated with performing a first set of training operations and a second computation time associated with performing a second set of training operations. The first computing time and/or the second computing time may include or describe an average computing time (e.g., a total average time of processing times for a set of training examples having a known size, complexity, etc.) and/or an average computing rate (e.g., training examples per unit time or other suitable metrics) associated with accessing training data and/or training a machine learning model. The comparison of the first calculation time and the second calculation time may be used to determine an expected time for the second set of training operations to become idle without data echo. The echo factor may then be determined such that the first computation time and the adjusted second computation time (including the data echo) are approximately equal, thereby reducing or eliminating the idleness of the second set of training operations.
In some implementations, each iteration of repetition may include a series of training steps. The number of repetitions of the series of training steps may be based at least in part on the echo factor. For example, a second set of hardware components (which may be referred to, for example, as a "model trainer") may input training examples into the machine learning model and receive training output as output of the machine learning model. The second set of hardware components may evaluate the training output and adjust parameters of the machine learning model based at least in part on the evaluation of the training output. For example, evaluating the training output may include back-propagating errors for layers of the neural network of the machine learning model with respect to the loss function. Parameters of the machine learning model may be adjusted based on the loss function using a variety of suitable methods, including, for example, random gradient descent.
In some implementations, data enhancement may be performed on some or all of the training data. The data enhancement may include applying the transformation to the training examples to generate training examples of additional transformations. As an example, training examples including images may be resized, mirrored, rotated, cropped, and/or tiled. Additionally or in combination, one or more attributes of the training examples, such as brightness, contrast, saturation, etc., may be adjusted. Any suitable transformation known in the art may be used. Other types of transformations may be applicable to other types of training data (e.g., audio, preferences, statistics, etc.).
In some implementations, data augmentation may be included in the second set of training operations (e.g., performed by the second set of hardware components) such that the training example(s) are augmented during one or more iterations. As a result, repeated iterations may be performed with the enhanced training example(s). In some cases, this may increase the training value of the repeated iterations as compared to repeating the same training example.
However, in other implementations, data enhancements may be included in the first set of training operations (e.g., performed by the first set of hardware components) such that the training example(s) remain unchanged during the iterative iteration(s). In this way, the machine learning model may be trained on the same training examples that are repeated. This configuration is useful where the training value of the training example(s) is greatest without enhancement. However, it should be appreciated that in some implementations, the augmentation may be performed in each of the first set of training operations and the second set of training operations.
In some implementations, an intermediate data buffer may be used to store training data output by the first set of hardware components. The second set of hardware components may access training data stored in the intermediate data buffer to train the machine learning model using the training data. Training examples included in the training data may also be shuffled (e.g., reordered) in the intermediate data buffer or accessed from the intermediate data buffer in a non-continuous manner (e.g., randomly, probabilistic, etc.). Thus, the intermediate data buffer may facilitate storing and accessing training examples for training the machine learning model, including using iterative iterations.
In some implementations, training examples may be selected probabilistically for iterating based on echo factors such that iterating is performed on some training examples and not others. This may facilitate data echo at an echo factor rather than at an integer value. Training examples may be retrieved from the intermediate data buffer as needed. As described above, training examples may be reorganized and/or accessed discontinuously in an intermediate data buffer. However, in other implementations, training examples may be accessed continuously such that the same training example is repeated continuously in repeated iterations. In one example, an echo factor of 2 may result in each training example of the plurality of training examples iterating, for a total of two iterations. An echo factor of 1 may result in no repetition of the iteration. The probabilistic selection of the training example(s) may facilitate implementation of an echo factor between one and two by probabilistically selecting the training example for iterating based on the echo factor, thereby performing iterating at a desired average rate corresponding to the echo factor. For example, an echo factor of 1.5 may result in half of the training examples being selected probabilistically for repeated iterations such that the total number of iterations (including fresh training examples and repeated iterations) is equal to 150% of the number of fresh training examples.
The above repeated iterations may be performed for each training example, and thus may be described as "example-level" data echoes. Rather, a "batch level" data echo may be employed in other implementations. For batch-level data echoes, a iterative iteration may be performed for each training example of a batch of training examples (e.g., prior to iterating over any members of the batch of training examples). More specifically, the training steps may be performed on the first training example, then on the second training example, and so on, until the training steps are performed on each training example of the batch. The training steps may then be repeated in the same manner for each training example in the set of training examples. The training step may be repeated for this batch, the number of repetitions being based on the echo factor. Thus, batch level echoes may be employed by iterating through a batch of training examples rather than iterating through individual training examples. Batch processing echoes may sometimes be better than example-level echoes having relatively larger batch sizes.
In some implementations, the echo factor may be a static hyper-parameter that is manually selected or determined by a user or operator of the computing system. The echo factor may also be determined (e.g., by a user, operator, or automatically by a computing system) based on information about the hardware components (processing power, available buffer size, etc.) and/or training data (size, complexity, etc.). Thus, the echo factors may be system-customized to minimize idleness and optimize the efficiency of the model training system.
However, in other implementations, the computing system may dynamically adjust the echo factor (e.g., during training of the machine learning model). For example, the computing system may increase the echo factor when a new training example is unavailable or is expected to become unavailable. Thus, the model training system may dynamically adjust the number of repeated iterations of the training examples in real-time based on the availability (or expected availability) of fresh training examples (e.g., from a data buffer).
As another example, the echo factor may be dynamically adjusted based on real-time monitoring information about the training process and/or hardware components used to train the machine learning model. For example, the computing system may monitor in real-time a first computing time associated with performing a first set of training operations (e.g., by a first set of hardware components) and/or a second computing time associated with performing a second set of training operations (e.g., by a second set of hardware components). The computing system may dynamically adjust the echo factor in real-time based at least in part on a comparison of the first computing time and the second computing time to reduce idle time in real-time (e.g., during training of the machine learning model). As described above, the idle time may be defined as when the first set of training operations is being performed and the second set of training operations is not being performed.
As another example, the echo factor may be adjusted based on a loss function. The loss function may be evaluated against the machine learning model and the given training examples to determine loss values for the training examples. The echo factor may be positively correlated with the loss value of the training example such that more iterations of repetition may be performed for training examples that induce higher loss values than training examples that induce lower loss values. Alternatively, the echo factors may remain the same, but training examples may be selected more probabilistically for repeated iterations based on having a relatively higher correlation loss value. Thus, the number of repeated iterations for a particular training example may be intelligently selected to maximize the value of repeating the selected training example.
Repeated iterations may be performed with fewer than all training examples of the training data. As one example, the training example(s) may be selected for repeated iterations based on a loss function that evaluates at least some of the plurality of training examples and the machine learning model to determine respective loss values for the training examples. Training examples with higher correlation loss values (e.g., relatively higher than loss values of other training examples in the training data) may facilitate repeated iterations. Training example(s) with relatively lower correlation loss values may not be advantageous for repeated iterations. For example, the amount of training examples required for repeated iterations may be calculated. The corresponding penalty value for the training examples may then be calculated. Training examples may then be ranked according to their respective penalty values. A subset of the plurality of training examples may then be selected for repeated iterations based on the respective loss value ranks of the plurality of training examples and the amount of training examples required (e.g., avoiding or reducing idleness). Thus, the computing system may be configured to intelligently enhance or maximize effectiveness in performing repeated iterations of training the machine learning model.
As another example, the training example(s) may be selected for repeated iterations based on their relative locations within the training data. More recent (or more recent) training examples for training the machine learning model may be selected for repeated iterations. This may provide the benefit of being easy to implement and potentially requiring less computing resources. For example, calculation of the loss value for the training example may potentially be avoided, e.g., for machine learning methods, where the loss value need not be calculated.
As another example, training example(s) may be selected for repeated iterations based on their respective data sources. Training examples may be received from multiple data sources including a publicly available set of training data (e.g., a set of image data, a set of audio data, etc.) and/or from a user of the mobile device (if the user has agreed). For example, training data may be obtained or generated based on interactions with a user of the mobile device, user preferences, and the like (e.g., customizing a machine learning model for the user). The training examples collected from the user of the mobile device may be given priority over training examples collected from other sources for repeated iterations. Importantly, a control can be provided to the user that allows the user to make a selection of whether and when the systems, programs, or features described herein can enable collection of user information (e.g., preferences). In addition, certain data may be processed in one or more ways before being stored or used to remove identifiable personal information (personally identifiable information). For example, the identity of the user may be processed such that identifiable personal information cannot be determined for the user. Thus, the user can control what information is collected about the user, how that information is used, and what information is provided to the user.
In some implementations, the methods described herein may be performed across multiple hardware components. As described above, the first set of hardware components may be configured to run a first set of training operations to access and prepare a plurality of training examples. The first set of hardware components may store the prepared training examples in an intermediate data buffer. The second set of hardware components may be configured to run a second set of training operations to access the prepared training examples from the intermediate data buffer and to train the machine learning model using the prepared training examples.
In some implementations, the first set of hardware components may include one or more general-purpose processors and the second set of hardware components may include one or more application-specific integrated circuits. For example, the application specific integrated circuit may include a hardware accelerator that includes a graphics processing unit(s) or tensor processing unit(s).
The systems and methods of the present disclosure may provide a number of technical effects and benefits. For example, the use of data echoes may reduce the degree of idleness, thereby increasing the efficiency of training the machine learning model, resulting in reduced use of computing resources, such as processor time, network bandwidth, memory usage, and the like. Furthermore, experiments have shown that data echoes can reduce the number of fresh training examples required to reach a given performance benchmark. Appendix a, which is incorporated into and forms a part of the present disclosure, includes data from experiments that show and quantify some of the benefits achieved by performing data echoes in accordance with the present disclosure. Thus, fewer computing resources are required to access, pre-process, and/or buffer such fresh training examples. In contrast, using data echoes with a given number of training examples may enable improved model performance compared to prior art training methods. Accordingly, the present methods and systems provide a technical improvement to the technical problem of training a machine learning model. Benefits include reduced idleness during training, greater computational efficiency during training, and improved performance of models trained in accordance with the present systems and methods.
As one example, the systems and methods of the present disclosure may be included or otherwise employed in the context of an application, browser plug-in, or other context. Thus, in some implementations, the model of the present disclosure may be included in or stored and implemented by a user computing device such as a laptop, tablet, or smart phone. As yet another example, the model may be included in or stored and implemented by a server computing device that communicates with the user computing device according to a client-server relationship. For example, the model may be implemented by a server computing device as part of a web service (e.g., a web email service).
Example embodiments of the present disclosure will now be discussed in further detail with reference to the accompanying drawings.
Example devices and systems
FIG. 1A depicts a block diagram of an example computing system 100 performing reduced idleness in a machine learning training system, according to an example embodiment of the present disclosure. The system 100 includes a user computing device 102, a server computing system 130, and a training computing system 150 communicatively coupled by a network 180.
The user computing device 102 may be any type of computing device, such as a personal computing device (e.g., a notebook or desktop), a mobile computing device (e.g., a smart phone or tablet), a game console or controller, a wearable computing device, an embedded computing device, or any other type of computing device.
The user computing device 102 includes one or more processors 112 and memory 114. The one or more processors 112 may be any suitable processing device (e.g., processor core, microprocessor, ASIC, FPGA, controller, microcontroller, etc.) and may be one or more processors operatively connected. Memory 114 may include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, disks, and the like, as well as combinations thereof. Memory 114 may store data 116 and instructions 118 that are executed by processor 112 to cause user computing device 102 to perform operations.
The user computing device 102 may store or include one or more machine learning models 120. For example, the machine learning model 120 may be or include various machine learning models, such as a neural network (e.g., deep neural network) or other multi-layer nonlinear model. The neural network may include a recurrent neural network (e.g., a long and short term memory recurrent neural network), a feed-forward neural network, or other form of neural network. An example machine learning model 120 is discussed with reference to fig. 2.
In some implementations, one or more machine learning models 120 may be received from the server computing system 130 over the network 180, stored in the user computing device memory 114, and used or otherwise implemented by the one or more processors 112. In some implementations, the user computing device 102 may implement multiple parallel instances of a single machine learning model 120 (e.g., perform parallel operations between multiple instances of the machine learning model 120).
Additionally or alternatively, one or more machine learning models 140 may be included in or stored and implemented by a server computing system 130, the server computing system 130 in communication with the user computing device 102 according to a client-server relationship. For example, the machine learning model 140 may be implemented by the server computing system 140 as part of a web service. Accordingly, one or more machine learning models 120 may be stored and implemented at the user computing device 102, and/or one or more models 140 may be stored and implemented at the server computing system 130.
The user computing device 102 may also include one or more user input components 122 that receive user input. For example, the user input component 122 may be a touch-sensitive component (e.g., a touch-sensitive display screen or touchpad) that is sensitive to touch by a user input object (e.g., a finger or stylus). The touch sensitive component may be used to implement a virtual keyboard. Other example user input components include a microphone, a conventional keyboard, or other device through which a user may input communications.
The server computing system 130 includes one or more processors 132 and memory 134. The one or more processors 132 may be any suitable processing device (e.g., processor core, microprocessor, ASIC, FPGA, controller, microcontroller, etc.) and may be one or more processors operatively connected. Memory 134 may include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, and the like, as well as combinations thereof. Memory 134 may store data 136 and instructions 138 that are executed by processor 132 to cause server computing system 130 to perform operations.
In some implementations, the server computing system 130 includes or is implemented by one or more server computing devices. Where the server computing system 130 includes multiple server computing devices, such server computing devices may operate in accordance with a sequential computing architecture, a parallel computing architecture, or some combination thereof.
As described above, the server computing system 130 may store or otherwise include one or more machine learning models 140. For example, the model 140 may be or otherwise include various machine learning models, such as a neural network (e.g., a deep-loop neural network) or other multi-layer nonlinear model. An example model 140 is discussed with reference to fig. 2.
The server computing system 130 may train the model 140 through interactions with a training computing system 150 communicatively coupled through a network 180. The training computing system 150 may be separate from the server computing system 130 or may be part of the server computing system 130.
The training computing system 150 includes one or more processors 152 and memory 154. The one or more processors 152 may be any suitable processing device (e.g., processor core, microprocessor, ASIC, FPGA, controller, microcontroller, etc.) and may be one or more processors operatively connected. Memory 154 may include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, and the like, as well as combinations thereof. Memory 154 may store data 156 and instructions 158 that are executed by processor 152 to cause training computing system 150 to perform operations. In some implementations, the training computing system 150 includes or is implemented by one or more server computing devices.
The training computing system 150 may include a first set of hardware components 160 and a second set of hardware components 162 configured to perform training operations on one or both of the machine learning models 140, 120 or machine learning models stored in the training computing system 150, for example as described herein with reference to fig. 2. The first and second sets of hardware components 160, 162 may employ various training or learning techniques, such as, for example, back propagation of errors. In some implementations, performing the back-propagation of the error may include performing truncated back-propagation over time. Model trainer 160 may perform a variety of generalization techniques (e.g., weight decay (WEIGHT DECAY), random inactivation (dropout), etc.) to improve the generalization ability of the trained model.
In some implementations, if the user has provided consent, the training examples may be provided by the user computing device 102 (e.g., based on communications previously provided by the user of the user computing device 102). Thus, in such implementations, the model 120 provided to the user computing device 102 may be trained by the training computing system 150 for user-specific communication data received from the user computing device 102. In some cases, this process may be referred to as a personalized model.
Model trainer 160 includes computer logic for providing the desired functionality. Model trainer 160 may be implemented in hardware, firmware, and/or software that controls a general purpose processor. For example, in some implementations, model trainer 160 includes program files stored on a storage device, loaded into memory, and executed by one or more processors. In other implementations, model trainer 160 includes one or more sets of computer-executable instructions stored in a tangible computer-readable storage medium, such as a RAM hard disk or an optical or magnetic medium.
The network 180 may be any type of communication network, such as a local area network (e.g., an intranet), a wide area network (e.g., the internet), or some combination thereof, and may include any number of wired or wireless links. In general, communications over network 180 may be carried via any type of wired and/or wireless connection using various communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), coding or formats (e.g., HTML, XML), and/or protection schemes (e.g., VPN, secure HTTP, SSL).
FIG. 1A illustrates one example computing system that may be used to implement the present disclosure. Other computing systems may also be used. For example, in some implementations, the user computing device 102 may include a model trainer 160 and a training data set 164. In such implementations, the model 120 may be trained and used locally at the user computing device 102. In some such implementations, the user computing device 102 may implement the model trainer 160 to personalize the model 120 based on user-specific data.
FIG. 1B depicts a block diagram of an example computing device 10, performed in accordance with an example embodiment of the present disclosure. Computing device 10 may be a user computing device or a server computing device.
Computing device 10 includes a plurality of applications (e.g., applications 1 through N). Each application contains its own machine learning library and machine learning model(s). For example, each application may include a machine learning model. Example applications include text messaging applications, email applications, dictation applications, virtual keyboard applications, browser applications, and the like.
As shown in fig. 1B, each application may communicate with a number of other components of the computing device, such as one or more sensors, a context manager, a device state component, and/or additional components. In some implementations, each application can communicate with each device component using an API (e.g., public API). In some implementations, the API used by each application is specific to that application.
Fig. 1C depicts a block diagram of an example computing device 50, performed in accordance with an example embodiment of the present disclosure. Computing device 50 may be a user computing device or a server computing device.
Computing device 50 may include multiple applications (e.g., applications 1 through N). Each application communicates with a central intelligence layer. Example applications include text messaging applications, email applications, dictation applications, virtual keyboard applications, browser applications, and the like. In some implementations, each application can communicate with the central intelligence layer (and the model stored therein) using an API (e.g., a generic API between all applications).
The central intelligence layer includes a number of machine learning models. For example, as shown in FIG. 1C, a corresponding machine learning model (e.g., model) may be provided for each application and managed by a central intelligence layer. In other implementations, two or more applications may share a single machine learning model. For example, in some implementations, the central intelligence layer can provide a single model (e.g., single model) for all applications. In some implementations, the central intelligence layer is included within or implemented by the operating system of computing device 50.
The central intelligence layer may communicate with the central device data layer. The central device data layer may be a centralized data store for computing devices 50. As shown in fig. 1C, the central device data layer may communicate with a plurality of other components of the computing device, such as one or more sensors, a context manager, a device status component, and/or additional components. In some implementations, the central device data layer can communicate with each device component using an API (e.g., a proprietary API).
FIG. 2 is a simplified schematic diagram of a computing system 200 configured to perform a training process to train a machine learning model based on a training data set including a plurality of training examples. In some implementations, elements of computing system 200 may be included in model trainer 160 of training computing system 150 of fig. 1. The computing system 200 may include a computer-readable storage disk 201, a first set of hardware components 202, an intermediate data buffer 204, and a second set of hardware components 206. The computer-readable storage disk 201 and/or the intermediate data buffer 204 may correspond to the memory 154 of fig. 1A. The first set of hardware components 202 and the second set of hardware components 206 may correspond to the first set of hardware components 160 and the second set of hardware components 162 of fig. 1A. The computing system 200 may be configured to perform a training process to train a machine learning model, for example, as described below with reference to the machine learning model 300 of fig. 3 and the methods 400, 500 of fig. 4 and 5. The computing system 200 may train the machine learning model 300 based on training data including a plurality of training examples. The computer-readable storage disk 201 may be configured to store a plurality of training examples.
The first set of hardware components 202 may be configured to run a first set of training operations to access a plurality of training examples from the computer-readable storage disk 201 and prepare the plurality of training examples for training the machine learning model. The first set of hardware components 202 may include one or more general purpose processors. The first set of hardware components 202 may store the prepared training examples at an intermediate data buffer 204, which intermediate data buffer 204 may be configured to store the prepared training examples.
More specifically, the intermediate data buffer 204 may be used to store training data output by the first set of hardware components 202. The second set of hardware components 206 may access training data stored in the intermediate data buffer 204 to train the machine learning model using the training data. Training examples included in the training data may also be shuffled in the intermediate data buffer 204 or accessed from the intermediate data buffer 204 in a non-continuous manner (e.g., randomly, probabilistically, etc.). Thus, the intermediate data buffer 204 may facilitate storing and accessing training examples for training the machine learning model, including using iterative iterations.
The second set of hardware components 206 may include one or more application specific integrated circuits. For example, the application specific integrated circuit may include a hardware accelerator that includes a graphics processing unit(s) or tensor processing unit(s).
The second set of hardware components 206 may be configured to run a second set of training operations to access the prepared training examples from the intermediate data buffer 204 and train the machine learning model using the prepared training examples. The second set of hardware components 206 may be configured to perform one or more iterative iterations, wherein the second set of hardware components 206 repeatedly accesses the prepared training example(s) from the intermediate data buffer 204 and repeatedly trains the machine learning model using the prepared training example(s). The rate at which the second set of hardware components 206 is configured to perform the iterative iteration(s) may be based at least in part on an echo factor, e.g., as described herein. The echo factor may be based at least in part on a comparison of a first computation time associated with the first set of hardware components 202 performing a first set of training operations and a second computation time associated with the second set of hardware components 206 performing a second set of training operations.
Example model arrangement
Fig. 3 depicts a block diagram of an example machine learning model 300, according to an example embodiment of the present disclosure. In some implementations, the machine learning model 300 may be trained to receive training example(s) 302 included in a training data set and provide training output 304 as a result of receiving the training example(s) 302, e.g., through the second set of hardware components 206 described above with reference to fig. 2. Training output 304 may include any suitable output of machine learning model 300. Examples include object detection/recognition output, voice recognition/identification output, natural language output, embedded, and/or any other output suitable for use with a machine learning model.
Training example(s) 302 may include various suitable training data types (e.g., images, audio, video, sensor data, statistics, etc.). The plurality of training examples (or plurality) 302 may be received from a plurality of data sources including publicly available training data sets (e.g., image data sets, audio data sets, sensor data sets, etc.) and/or from a user of a mobile device (e.g., user computing device 102 of fig. 1A). For example, training data may be obtained or generated based on interactions with a user of the mobile device, user preferences, and the like (e.g., customizing the machine learning model 300 for the user). In some implementations, the training examples collected from the user of the mobile device may be given priority over training examples collected from other sources for repeated iterations. Importantly, a control can be provided to the user that allows the user to make a selection of whether and when the systems, programs, or features described herein can enable collection of user information (e.g., preferences). In addition, certain data may be processed in one or more ways before being stored or used in order to remove identifiable personal information. For example, the identity of a user may be processed such that identifiable personal information cannot be determined for the user. Thus, the user can control which information is collected about the user, how that information is used, and which information is provided to the user.
Example method
Fig. 4 depicts a flowchart of an example method 400 for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure. Although fig. 4 depicts steps performed in a particular order for purposes of illustration and discussion, the methods of the present disclosure are not limited to the particular order or arrangement shown. The various steps of method 400 may be omitted, rearranged, combined, and/or adjusted in various ways without departing from the scope of the present disclosure.
At 402, a computing system may execute a first set of training operations to access and prepare a plurality of training examples included in a training data set. As an example, the first set of training operations may include reading, decoding, shuffling, enhancing, and/or batching training data. The first set of training operations may be performed by the first set of hardware components, for example, as described with reference to fig. 3 and 5. However, other suitable training operations may be performed to access and prepare training examples. The appropriate training operation may be selected depending on the attributes of the machine learning model being trained and/or the attributes of the training data (e.g., size, complexity, type, etc.).
At 404, the computing system may perform a second set of training operations to train the machine learning model based at least in part on the training data set. The second set of training operations may include inputting training examples into the machine learning model and adjusting parameters of the machine learning model based on an evaluation of training output received from the machine learning model, e.g., as described with reference to fig. 5. The second set of training operations may be performed by a second set of hardware components, for example, as described herein with reference to fig. 3 and 5.
At 406, the computing system may iterate (e.g., part or all of the second set of training operations 404) based on an echo factor based at least in part on a comparison of a first computation time associated with performing the first set of training operations 402 and a second computation time associated with performing the second set of training operations 404. The repeated iterations may be included in and/or performed by the second set of training operations 404.
More specifically, for the same training example, a number of iterations of repeating the iterations (e.g., by the second set of computing hardware components) based on the echo factor may be performed at 406. The number of iterations of a given training example may be positively correlated with or otherwise based on an echo factor. For example, an echo factor of two may correspond to a single iteration being performed for each training example, resulting in a total of two iterations per training example. The echo factor may be selected to reduce (e.g., minimize, eliminate, etc.) idle time (e.g., idle time of the second set of computing devices). As described above, idle time may be defined as when a first set of training operations (e.g., preprocessing training data) at 402 is being performed and a second set of training operations (e.g., training a model based on the preprocessed training data) at 404 is not being performed.
The echo factor may be based on a computation time and/or rate associated with accessing data and/or training a machine learning model to minimize idle time. More specifically, the echo factor may be based on a comparison of a first computation time associated with performing the first set of training operations 402 and a second computation time associated with performing the second set of training operations 404. As an example, the first or second computation time may include or describe an average computation time (e.g., a total average time of processing times for a training example set of known size, complexity, etc.) and/or an average computation rate (e.g., training examples per unit time or other suitable metrics) associated with the first and/or second training operation sets 402, 404. The calculated time may include other suitable metrics that may be used to estimate when the idle time occurs or to determine the number of iterations needed to reduce or eliminate the idle time.
For example, a comparison of the first calculation time and the second calculation time may be used to determine an expected time when the second set of training operations 404 will become idle without data echoes. The echo factor may then be determined such that the first computation time and the adjusted second computation time (including the data echo) are approximately equal, thereby reducing or eliminating the idleness of the second set of training operations 404.
In some implementations, training example(s) may be selected probabilistically for iterating based on echo factors at 406 such that iterating is performed on some training examples and not others. This may facilitate data echo at echo factors other than integer values. For example, in one example, an echo factor of 2 may result in each training example of the plurality of training examples repeating iterations consecutively, with each training example repeating iterations twice in total. An echo factor of 1 may result in no repetition of the iteration. The probabilistic selection of training example(s) may facilitate implementation of non-integer echo factors (e.g., between one and two) by probabilistically skipping training examples for iterating based on the echo factors, thereby performing iterating at a desired average rate corresponding to the echo factors. For example, an echo factor of 1.5 may result in a probabilistic skipping of about half of the training examples such that the total number of iterations (including fresh training examples and repeated iterations) may be equal to 150% of the number of fresh training examples. Thus, the probabilistic selection of training examples may be used to implement non-integer echo factors, which may be used to more precisely adjust or tune the number of repeated iterations, thereby reducing idle time.
The above iterative iterations may be performed for each training example at 406, and thus may be described as "example-level" data echoes. Rather, a "batch level" data echo may be employed in other implementations. For batch-level data echoes, a repeated iteration (e.g., sequentially) may be performed for each training example of a batch of training examples. More specifically, a set of training steps (e.g., some or all of the second set of training operations 404) may be performed on the first training example, then on the second training example, etc., until the training steps of the second set of training operations 404 are performed on each training example of the batch. The set of training steps of the second set of training operations 404 may then be repeated in the same manner for each training example in the set of training examples. The training step (e.g., part or all of the second set of training operations 404) may be repeated for this batch, the number of repetitions being based on the echo factor. Thus, batch processing echoes may include iterating over multiple batches of training examples rather than iterating over individual training examples.
It has been found that batch echoes may sometimes be better than example level echoes, for example, in cases with relatively larger batch sizes. Example level echoes sometimes also require more shuffling than batch level echoes. Appendix a, incorporated in and forming a part of this disclosure, provides additional description and experimental data regarding batch-level and example-level echoes.
In some implementations, the echo factor may be a static hyper-parameter that is manually selected or determined by a user or operator of the computing system. The echo factor may also be determined (e.g., automatically by a user, operator, or by a computing system) based on information about the hardware components (e.g., processing power, available buffer size, etc.) and/or training data (e.g., size, complexity, etc.). Thus, the echo factors can be customized or personalized to the system to minimize idle time and optimize the efficiency of the model training system.
In other implementations, the computing system may dynamically adjust the echo factor (e.g., during execution of the first set of training operations 402 and/or the second set of training operations 404). For example, the computing system may increase the echo factor when a new training example is unavailable or is expected to become unavailable (e.g., from the first set of training operations 402). Thus, the model training system may dynamically adjust the number of iterations of the training examples in real-time based on the availability (or expected availability) of fresh training examples.
As another example, the echo factor may be dynamically adjusted based on real-time monitoring information about the training process and/or hardware components used to train the machine learning model. For example, the computing system may monitor in real-time a first computing time associated with performing the first set of training operations 402 (e.g., by the first set of hardware components) and/or a second computing time associated with performing the second set of training operations 403 (e.g., by the second set of hardware components). The computing system may dynamically adjust the echo factor in real time based at least in part on a comparison of the first computing time and the second computing time to reduce idle time in real time (e.g., during training of the machine learning model). As described above, idle time may be defined as when the first set of training operations 402 is being performed and the second set of training operations 404 is not being performed.
As another example, the echo factor may be adjusted based on a loss function. The loss function may be evaluated with respect to the machine learning model and the given training examples to determine loss values for the training examples, for example, as described below with reference to step 518 of method 500 of fig. 5. The echo factor may be positively correlated with the loss value of the training example such that at 406, more iterations of repetition may be performed for training examples that induce higher loss values than training examples that induce lower loss values. Thus, the number of repeated iterations for a particular training example may be intelligently selected to maximize the value of repeating the selected training example.
A repeated iteration may be performed for less than all training examples of the training data at 406. As one example, at 406, training example(s) may be selected for repeated iterations based on a loss function that evaluates at least some of the plurality of training examples and the machine learning model to determine respective loss values for the training examples. At 406, training examples with higher correlation loss values (e.g., relatively higher than loss values of other training examples in the training data) may facilitate iterative iterations. At 406, training examples with relatively more relevant loss values may not be advantageous for repeated iterations. For example, at 406, an amount of training examples required for the repeated iterations may be calculated (e.g., to prevent or minimize idle time). The corresponding penalty value for the training examples may then be calculated. Training examples may then be ranked according to their respective penalty values. Then, at 406, a subset of the plurality of training examples may be selected for repeated iterations based on the respective penalty value ranks of the plurality of training examples and the amount of training examples required (e.g., avoiding or reducing idleness). Thus, at 406, the computing system may be configured to intelligently enhance or maximize the effectiveness of performing the iterative iterations to train the machine learning model.
As another example, at 406, training example(s) may be selected for repeated iterations based on the relative position of training data in the training examples. At 406, a training example that is more recent (or more recent) for training the machine learning model may be selected for repeated iterations. This may provide the benefit of being easy to implement and potentially requiring less computing resources. For example, calculation of the loss value for the training example may potentially be avoided, e.g., for machine learning methods, where the loss value need not be calculated.
As another example, at 406, training example(s) may be selected for repeated iterations based on their respective data sources. As described above, training examples may be received from multiple data sources including publicly available training data sets (e.g., image data sets, audio data sets, etc.) and/or from a user of the mobile device (if the user has agreed). Training data may be obtained or generated based on interactions with a user of the mobile device, user preferences, etc. (e.g., customizing a machine learning model for the user). The training examples collected from the user of the mobile device may be given priority over training examples collected from other sources for repeated iterations.
Fig. 5 depicts a flowchart of an example method 500 for reducing idleness in a machine learning training system, according to an example embodiment of the present disclosure. Although fig. 5 depicts steps performed in a particular order for purposes of illustration and discussion, the methods of the present disclosure are not limited to the particular order or arrangement shown. The various steps of method 500 may be omitted, rearranged, combined, and/or adjusted in various ways without departing from the scope of the present disclosure.
The method 500 may include: a first set of training operations 502 accessing and preparing a plurality of training examples included in a training data set; and a second set of training operations 504 to train the machine learning model based at least in part on the set of training data. The first set of training operations 502 may be performed by a first set of hardware components and the second set of training operations 504 may be performed by a second set of hardware components, e.g., as described above with reference to fig. 3 and 4.
The first set of operations 502 may include various preparatory operations with respect to training data. For example, the first set of operations 502 may include reading and/or decoding training data at 506, shuffling the training data at 508, enhancing the training data at 510, and/or batching the training data at 512. However, other suitable training operations may be performed to access and prepare training examples. The appropriate training operation may be selected depending on the attributes of the machine learning model to be trained and/or the attributes (e.g., size, complexity, type, etc.) of the training data.
Enhancing the training data at 510 may include applying the transformation to the training examples to generate training examples of additional transformations. As an example, training examples including images may be resized, mirrored, rotated, cropped, and/or tiled. Additionally or in combination, one or more attributes of the training examples, such as brightness, contrast, saturation, etc., may be adjusted. Any suitable transformation known in the art may be used. Other types of transformations may be applicable to other types of training data (e.g., audio, preferences, statistics, etc.).
Thus, at 510, one or more training examples may be enhanced by applying a transformation to training example(s) in first set of training operations 502 (e.g., by a first set of hardware components) such that, at 522, in second set of operations 504, training example(s) remain unchanged during the repeated iteration(s). Thus, the machine learning model may be trained on the same training examples repeated. This configuration is useful where the training value of the training example(s) is greatest without enhancement. However, it should be appreciated that in some implementations, data augmentation may additionally or alternatively be included in the second set of training operations 504, e.g., as described below with reference to augmenting training data at 524.
The second set of operations 504 may include a series of training operations to train the machine learning model based at least in part on the training data. For example, at 514, the second set of hardware components may input training example(s) in the training data set into the machine learning model. At 516, the second set of hardware components may receive one or more training outputs as outputs of the machine learning model, e.g., as described above with reference to fig. 3.
At 518, the second set of hardware components may evaluate the training output(s), e.g., as described above with reference to fig. 3. Evaluating 518 the training output may include evaluating a loss function on the training output of the machine learning model. For the loss function, errors may be counter-propagated through layers of the neural network of the machine learning model.
At 520, the second set of hardware components may adjust parameters of the machine learning model based at least in part on the evaluation of the at least one training output. Parameters of the machine learning model may be adjusted based on the loss function using a variety of suitable methods, including, for example, random gradient descent.
At 522, a iterative iteration may be performed on some or all of the training examples based on an echo factor based at least in part on a comparison of a first computation time associated with performing the first set of training operations 502 and a second computation time associated with performing the second set of training operations 504, e.g., as described above with reference to fig. 4. For example, training example(s) may be selected probabilistically for iterative iterations (e.g., steps 514-520) based on echo factors such that iterative iterations are performed for some training examples and not for other training examples. This may facilitate data echo at echo factors other than integer values. Training examples may be retrieved from the intermediate data buffer as needed. As described above, training examples may be reorganized and/or accessed discontinuously in an intermediate data buffer. However, in other implementations, training examples may be accessed continuously such that the same training examples are repeated continuously in repeated iterations.
In one example, in each training example, an echo factor of 2 may result in repeated iterations for each training example of the plurality of training examples, for a total of two repeated iterations for each training example, at 522. At 522, an echo factor of 1 may result in no iteration being performed. The probabilistic selection of the training example(s) may facilitate implementation of an echo factor between one and two by probabilistically selecting the training example(s) for the iterative iteration based on the echo factor at 522, such that the iterative iteration is performed at a desired average rate corresponding to the echo factor at 522. For example, an echo factor of 1.5 may result in a probabilistic selection of half of the training examples for repeated iterations at 522 such that the total number of iterations (including fresh training examples and repeated iterations) equals 150% of the number of fresh training examples.
The repeated iterations at 522 above may be performed for various training examples, and thus may be described as "example-level" data echoes. Rather, a "batch level" data echo may be employed in other implementations. For batch-level data echoes, a iterative iteration may be performed 522 for each training example of a batch of training examples (e.g., prior to iterating over any members of the batch of training examples). More specifically, training steps (e.g., steps 514-520) may be performed on the first training example, then on the second training example, and so on, until the training steps are performed on each training example of the batch. The training steps may then be repeated in the same manner for each training example in the set of training examples. The training steps (e.g., steps 514-520) may be repeated for the batch at 522, the number of repetitions being based on the echo factor. Thus, batch level echoes may be employed by iterating through the batch of training examples at 522 instead of iterating through individual training examples. For relatively larger batch sizes, batch echoes may sometimes perform better than example-level echoes.
In some implementations, the data augmentation at 524 may be performed in the second set of training operations 504. One or more training examples may be enhanced at 524 such that the training example(s) are enhanced during one or more repeated iterations. Although shown after the repeated iterations at 522, it should be appreciated that the enhanced training data at 524 may be performed in conjunction with the repeated iterations at 522 such that some or all of the repeated iterations at 522 may be performed using an enhanced version of the fresh training example(s). In some cases, this may increase the training value of the repeated iterations as compared to repeating the same training example. In some implementations, data augmentation may be performed in the first set of training operations 502 (e.g., at 510) and the second set of training operations 504 (e.g., at 524).
Additional disclosure
The technology discussed herein refers to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to such systems. The inherent flexibility of computer-based systems allows for a variety of possible configurations, combinations, and divisions of tasks and functions between components. For example, the processes discussed herein may be implemented using a single device or component or multiple devices or components working in combination. The database and applications may be implemented on a single system or may be distributed across multiple systems. Distributed components may operate sequentially or in parallel.
While the present subject matter has been described in detail with respect to various specific example embodiments thereof, each example is provided by way of illustration and not limitation of the present disclosure. Substitutions, modifications and equivalents will now occur to those skilled in the art upon understanding the foregoing. Accordingly, the present disclosure does not preclude inclusion of such modifications, variations and/or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art. For example, features illustrated or described as part of one embodiment can be used with another embodiment to yield still a further embodiment. Accordingly, the present disclosure is intended to cover such alternatives, modifications, and equivalents.
Appendix A
Faster neural network training with data echoes
Anonymous authors
Unit (B)
Address of
E-mail
Abstract
In mor's law of dawn, GPUs and other specialized hardware accelerators have greatly accelerated the training speed of neural networks. But the early stages of the training pipeline (such as disk I/O and data preprocessing) do not run on the accelerator. With the continued improvement of accelerators, these early stages will become increasingly bottlenecks. Herein we introduce a "data echo" which reduces the total amount of computation used in early pipeline stages and speeds up training when training time is occupied upstream of the accelerator computation. Data echo reuse (or "echo") is an intermediate output of early pipeline stages to reclaim free capacity. We studied the behavior of different data echo algorithms under various workloads, various amounts of echo, and various batch sizes. We have found that at least one data echo algorithm can use fewer upstream calculations to match the predicted performance of the baseline under all settings. In some cases, the data echo may even compensate for an input pipeline that is 4 times slower.
1. Introduction to the invention
In the last decade, the significant increase in neural network training speed has enabled researchers to train larger models using larger data sets and explore new ideas more quickly, thereby promoting significant increases in predictive performance. As moore's law ends, general purpose processors no longer get faster, but specialized hardware continues to drive significant acceleration by optimizing a narrower set of operations. For example, GPU and TPU 1 optimize highly parallel matrix operations, which are a core component of neural network training algorithms.
However, training a neural network not only requires good operation on the accelerator, so we cannot rely solely on the accelerator modification to maintain acceleration in all cases. Training programs may require reading and decompressing training data, shuffling, batching, and even transforming or enhancing it. These steps may use a number of system components including CPU, disk, network bandwidth, and memory bandwidth. It is impractical to design dedicated hardware for all of these general operations involving so many different components. Meanwhile, the improvement of accelerators is exceeding the improvement of general-purpose computing, and such workload already exists: code running on the accelerator consumes only a small portion of the total wall time. Thus, if we want to continue to train the neural network faster, we must either (1) make the non-accelerator work faster, or (2) reduce the amount of non-accelerator work required to reach the expected predicted performance. Although scheme (1) is attractive, it may require a lot of engineering effort or difficult to popularize techniques (e.g., zhu et al, 2018; ying et al, 2018; kumar et al, 2017). Adding more workers, if possible, may be too expensive or add too much complexity to the system. Instead, we focus on option (2) and explore techniques that reduce the total effort performed in the early stages of the training pipeline.
We can consider the neural network training procedure as a data pipeline of buffering and overlap computations. For example, fig. 6 shows a typical small batch random gradient descent (SGD) training pipeline and its variants, which is a virtually standard algorithm for training neural networks. The training program first reads and decodes the input data, then reorganizes the data, applies a set of transformations to enhance the data, and gathers the examples in batches. Finally, the program iteratively updates parameters of the neural network to reduce the loss function of the continuous batch processing; we call this stage "SGD update" regardless of which SGD variant is used. Alternative sequences of these stages are also possible, some pipelines may omit stages or add new stages. Since the output of any pipeline stage can be buffered, the computation of the different stages will overlap and the slowest stage dominates the training time. Modern accelerators emphasize any slowness of other pipeline stages by making the optimized matrix operations less likely to dominate the overall training time.
In this work, we studied how to speed up neural network training by reducing the total time spent in the early part of the training pipeline, which exceeds the time spent in the later part of the pipeline (see (a) in fig. 7). This situation is today realistic and will become more common if the accelerator improvements continue to exceed the general purpose CPU and I/O. Specifically, we consider an algorithm that re-uses the output of the first part of the pipeline for multiple SGD updates to take advantage of the idle processing capability. We call this type of algorithm data echo and each intermediate output uses an echo factor number of times.
The data echo algorithm inserts a repetition phase (optional shuffling) at a certain position in the training pipeline before the SGD update. If the time spent by the upstream task (before the repetition phase) exceeds the time spent by the downstream task (after the repetition phase), this technique will reclaim the free downstream computation capacity and increase the SGD update rate of the model (see (b) in fig. 7). By varying the choice of insertion points in the pipeline, the echo factors and the amount of modification, different data echo algorithms with different behavior can be implemented.
Here, we demonstrate:
1. the data echo reduces the amount of upstream computation required to achieve a competitive sample out-of-error rate across various data sets and model architectures;
2. the data echo can support a wide range of echo factors;
3. the effectiveness of the data echo depends on the insertion point in the training pipeline;
4. data echo may benefit from additional reorganization after echo, but it is not required; and
5. Contrary to expectations, the data echo achieves the same error rate as the adjusted baseline.
1.1 Related work
Data echo is similar to empirical playback (Mnih et al, 2015) in that the latter samples batches from buffers containing the past experience of the reinforcement learning agent to prevent recent interactive control updates. While both data echo and empirical playback have duplicated previous data, our data echo implementation chooses to repeat each instance a number of times, while most implementations of empirical playback do not explicitly control this. In addition, the local SGD algorithm (Zinkevich et al, 2010; zhang et al, 2016) performs multiple local model updates prior to global communication, which can be viewed as reusing data to save computation. However, the local SGD targets the communication overhead between workers and is therefore orthogonal to the data echoes.
We know that the two previous papers describe variations of data echo. Fischer et al (2018) describe a special data echo case called "small lot persistence" that reuses small lots for multiple consecutive SGD updates. They run experiments on CIFAR-10, but do not adjust meta-parameters for baseline or method. In their experiments, neither their method nor baseline reached a competitive test set number, leaving a pending problem as to whether small lot persistence is more advantageous than a well-tuned baseline. Likewise, hoffer et al (2019) describe a special data echo case called "bulk enhancement," where examples are repeated multiple times within a given bulk, but with different enhancements. None of their experiments adjusted the optimization meta-parameters, although the settings used by their baselines were taken from the original papers that were introduced into each model. Fischer et al (2018) and Hoffer et al (2019) primarily drive their work as a method of improving generalization, only slightly mentioning the possibility of reclaiming free computing capacity. For a fixed number of SGD updates, we do not want the data echo to increase generalization capability, because duplicate data is more valuable than new data. Our experiments in the third section only show that the data echo can get better off-sample errors at the same fresh data volume.
2. Data echo
We implement the data echo by inserting a stage in the training pipeline that repeats the output of the previous stage (echo). In some cases we also reorganize the output of the echo stage, but this may require additional memory. If the overhead of repeating data is negligible and the stages on either side of the echo are performed in parallel (e.g., chien et al, 2018), then the data echo takes on average the time of completing one upstream step and e downstream steps as
max{tupstream,e√ótdownstream}Ôºå (1)
Where t upstream is the time spent by all upstream phases of the echo, t downstream is the time spent by all downstream phases of the echo, and e is the echo factor. We assume t upstream‚â•tdownstream because this is the primary motivation for using data echoes. If we denote the ratio of upstream and downstream processing times by r=t upstream/tdownstream, then the time to complete one upstream step and e downstream steps is the same for all echo factors e to R. In other words, the additional downstream steps are "free" in that they utilize free downstream capacity. Non-integer echo factors may be expected to be reached by probabilistically repeating the data items.
When using data echoes, the reduction in training time (if any) depends on the tradeoff between upstream and downstream steps. On the one hand, because duplicate data may not be as valuable as completely fresh data, data echoes may require more downstream SGD updates to achieve the expected predictive performance. On the other hand, data echo requires only 1/e (rather than 1) upstream steps per downstream step. If the number of required downstream steps increases by a factor less than e, the total number of upstream steps (and thus the total training time) will decrease. R is the maximum likelihood acceleration of the data echo, which would be achieved if e=r and the repeated data is as valuable as the new data.
Considering that each operation in the training pipeline requires some time to perform, R is maximal if the data echo is applied just before the SGD update, which will result in the same batch being used multiple times in each epoch. However, despite the overhead, we may prefer to insert data echoes earlier in the pipeline if a more favorable tradeoff is provided between the number of upstream and downstream steps. In particular, the following factors affect the behavior of the data echo at different insertion points.
Pre-batch echo or post-batch echo: pre-batch echo refers to the repetition and shuffling of data at the sample level, rather than the batch level. This increases the likelihood that neighboring batches will be different, but at the cost of potentially replicating the instance in a batch. Batch operation is also more important, which is an empirical problem we discuss in section 3. We refer to the class of algorithms at the example level echo as the example echo and to the class of algorithms at the batch level echo as the batch echo.
Pre-or post-enhancement echoes: the echo before data enhancement allows the repeated data to be transformed in a different way, bringing the repeated data closer to the new data. A similar objective can be achieved by adding noise during the SGD update, e.g. random inactivation, even without enhancement or post-enhancement echo (Hoffer et al, 2019).
Table 1: service profile
The behavior of the data echo is also affected by the amount of shuffling, if any, performed after the echo phase. Where applicable, we implement the shuffling stage as a buffer in which the previous pipeline stages randomly sample the items. The larger the buffer size, the more echo data is reorganized and the more closely the training algorithm approaches the procedure of loading the entire training set into memory before randomly sampling the data. For some workloads a relatively large buffer size may be very realistic, but we are mainly interested in that in this case we can only provide one buffer size, which is a small fraction of the (enhanced) data set size.
3. Experiment
We evaluate the data echoes of two language modeling tasks, two image classification tasks and one object detection task. For language modeling, we trained a transducer self-attention model on LM1B (Chelba et al, 2014) and Common Crawl 2 datasets (Vaswani et al, 2017). For image classification, we trained the ResNet model (He et al, 2016) on CIFAR-10 (Krizhevsky and Hinton, 2009) and ImageNet dataset (Russakovsky et al, 2015). For object detection, we trained a single point detector (SSD, liu et al, 2016) on the COCO dataset (Lin et al, 2014).
The primary question we have studied is whether data echo can provide training acceleration. The training time we measure is the number of "fresh" training examples required to reach the target sample extrinsic metric value. The data of the echoes is not calculated as new data, but for models trained for multiple epochs, each reading of a given instance is calculated as a fresh instance. The number of fresh example reads is proportional to the number of upstream steps in the training pipeline (see section 2). If e.ltoreq.R, the number of fresh examples required is a proxy for the total training time, and any reduction in this value will be reflected in the wall time proportionally (provided that the overhead of the data echo is negligible). In our experiments we did not assume or measure the actual value of R, as R depends on implementation and may change with future hardware development. In our execution, not all tasks satisfy R.gtoreq.1. Instead, we have devised our experiments to investigate whether data echo can reduce the number of fresh examples required for different tasks, since this measurement is implementation independent. In the best case, the duplicate data is as useful as the fresh data, and the number of fresh examples required will reduce the echo factor. In the worst case, the number of fresh examples required will increase, or the model will not be able to achieve the target sample extrinsic metric values. However, neither of these cases occurred in any of our experiments‚Äîin the worst case, we observed no change in the number of fresh examples (within the error bars) needed to reach the target magnitude.
For each workload we run a set of initial experiments without data echo and adjust metapa parameters to obtain the best off-sample performance within the actual computational budget. We then choose the target metric value to be slightly below the optimal value to ensure that this value can be reliably reached. We demonstrate that minor changes to the target do not affect our conclusion. Table 1 summarizes the workload and target scale values we used in the experiments.
We trained SSD models using a phasor SGD (Polyak, 1964; rumelhart et al, 1986), and using a nestrov momentum training transducer and ResNet model (Nesterov, 1983; sutskever et al, 2013). We use a constant learning rate for the converter and a learning rate table for ResNet (linear decay) and SSD (piecewise exponential decay after linear warm-up). We have performed the same preprocessing on the text dataset as Shallue et al (2018). We enhance the image dataset during training by adjusting the size of each image, randomly cropping, and randomly horizontal reflection cropping the image. We randomly warp the image colors of ImageNet and COCO. Unless otherwise stated, we use a batch size of 1024 for the variator, 128 for ResNet-50, and 256 for ResNet-32. We used batch normalization (Ioffe and Szegedy, 2015) for ResNet-50 and SSD, with virtual batch sizes (Hoffer et al, 2017) of 32 and 128, respectively.
In each experiment we independently adjusted the learning rate, momentum and, where applicable, parameters controlling the learning rate schedule. We manually select the search space on the basis of the initial experiment and verify after each experiment whether the optimal meta-parameter values are far from the search space boundaries. We used a quasi-random search (Bousquet et al, 2017) to adjust the meta-parameters of the non-divergent 3 trial with a fixed budget (100 for transformers and ResNet-32, 50 for ResNet-50 and SSD). We then selected the trial that reached the target magnitude using the least fresh example selection. We repeat this meta-parameter search 5 times for each search space. All figures in this section show the average number of new line examples required for these 5 experiments, with the minimum and maximum values shown as error bars.
Our experiments evaluate the effect of adding data echoes in a typical neural network training pipeline (fig. 6). We consider three variants of data echo: example pre-enhancement echoes, example post-enhancement echoes, and bulk echoes. For the example echo variant, we omitted the baseline "shuffling example" buffer and inserted a shuffling buffer of the same size as the baseline buffer after the echo phase. For batch echoes, we keep a "shuffling example" buffer of baselines and simply repeat the batch (no shuffling) after "batch example". Thus, in all cases, our training pipeline always has one buffer of the same size, so all data echo variants use the same amount of memory as the baseline. We selected the buffer size so that the examples were reasonably reorganized within each epoch (10 6 for LM1B and Common Crawl, 10 4 for CIFAR-10, 10 5 for ImageNet, and 10 4 for COCO). The effect of increasing the buffer size is discussed in section 3.5.
3.1 Data echo can reduce the number of fresh examples required for training
Fig. 8 shows the effect of the data echo e=2 for all workloads in table 1. In all but one cases, the data echo requires less fresh examples than the baseline to achieve the target out-of-sample performance. The only exception (the batch echo on ResNet-50) requires as many fresh examples as the baseline-while the data echo does not have the benefit, it does not impair training. The earlier echoes are inserted in the pipeline, the fewer fresh examples are needed: the example echo requires less fresh examples than the batch echo, and the echo before data enhancement requires less fresh examples than the echo after. For ResNet-50 or SSD, we did not observe any negative interaction between data echo and batch normalization.
3.2 Data echo can reduce training time
Fig. 9 shows the fractional change in training time (assuming negligible overhead for echo), different echo factors assume different R values. If r=1, the data echo either increases or does not change the training time significantly. If R >1, any choice of e R will reduce training time by setting the maximum acceleration achieved by e=r. Setting e > R does not reduce the training time of the LM1B up-converter, but it does provide acceleration for ResNet-50 on ImageNet, even though e=4 and r=1.5. These results indicate that the data echo can reduce the training time of a series of echo factors around the optimal value e=r, especially when e R.
3.3 Data echo is useful within a reasonable upper limit of echo coefficients
Fig. 10 shows the effect of an example echo with an echo factor of up to 16 for the transformer on LM 1B. For a batch size 1024, the maximum effective echo factor is between 4 and 8; beyond this value, the number of fresh examples required is greater than the number required for smaller echo factors. As the echo factor increases, the number of fresh examples required eventually must exceed the baseline, but even with an echo factor as large as 16, far fewer fresh examples than the baseline are required. For a batch size of 4096, the maximum effective echo factor is even greater than 16, indicating that a larger batch size may support a larger echo factor than a smaller batch size.
3.4 Data echo when the batch size increases
With larger batch sizes, batch processing echo performs better, but example echoes sometimes require more shuffling. Fig. 11 shows the data echo effect for different batch sizes, e=2. As the batch size increases, the batch echo performance relative to baseline either remains unchanged or increases. This effect is significant because as the batch size approaches the training set size, the repeated batch should approximate a new batch, and thus, within limits, the batch echoes must be reduced by the echo factor by the number of fresh examples required. On the other hand, FIG. 11 shows that the performance of the example echo relative to baseline either remains unchanged or slightly worsens as the batch size increases. Because the expected fraction of repeated examples in each batch increases with batch size, in practice, examples with larger batches may behave more like smaller batch sizes. Smaller batch sizes may increase the number of required SGD updates (Shallue et al, 2018), which may explain the results of the example echoes in fig. 11. Increasing the amount of shuffling of repeated examples (at the cost of additional memory) can improve the performance of example echoes at larger batch sizes by reducing the probability of repeated examples in each batch.
3.5 Data echo performs better with more reorganizations
All batch echo experiments in the first few sections were repeated without shuffling. Fig. 12 (a) shows that if repeated batches are reorganized, the performance of the echo of the batch for e=2 will increase (at the cost of additional memory), while more reorganization will lead to better performance. Similarly, all of the example echo experiments in the previous section use the "shuffling example" phase of the original pipeline to shuffle repeated examples. Fig. 12 (b) shows that the performance of the example echo with e=2 improves (at the cost of additional memory) as the size of the buffer for shuffling increases, even though it does not help the baseline pipeline. This is because, as described in section 3.4, more shuffling reduces the likelihood of duplicate examples in each batch.
3.6 Data echo does not impair predictive performance
While one may worry that re-use of the data may compromise the final predicted performance, we have not observed any data echoes that use reasonable echo factors that fail to reach the target magnitude. To further demonstrate that data echo does not degrade the quality of the solution, we have experimented with using a transducer on LM1B and ResNet-50 on ImageNet to find the best achievable performance, including data echo and no data echo, within the given fresh example budget. We have chosen a fresh example budget such that the baseline converter pipeline will achieve a cross entropy error better than 3.9 and the baseline ResNet-50 pipeline will achieve at least 75% accuracy. We performed all data echo experiments using e=4. We use 500 transducer trials and 100 ResNet-50 trials to adjust the baseline and data echo meta-parameters. In each case we selected the test that performed best at any time during the training process. Fig. 13 shows that for both tasks, all data echo variants achieved at least the same performance as the baseline.
4. Conclusion(s)
When the training pipeline encounters a bottleneck at some upstream stage, data echo is a simple strategy to improve hardware utilization. While a priori people may be concerned that updating the SGD with duplicate data is useless, or even detrimental, for each workload we consider, at least one data echo variant reduces the total number of examples we need to read from disk. Even for the Common Crawl transducer, because this dataset is too large to train for even a full period of time. In this case, the data echo achieves the target predictive performance, and only a subset of the examples seen by the baseline are seen. The post-enhancement echo is still effective in reducing the example total number of reads from disk, which makes it attractive for image datasets enhanced with expensive data running on the CPU.
Data echo is a simple and effective alternative to optimizing the training pipeline or adding additional personnel to perform upstream data processing, which may not always be possible or desirable. Although the exact acceleration depends on the model structure, dataset, batch size, and extent of reorganization of the duplicate data, setting the echo factor to a ratio of upstream and downstream processing times maximizes the potential acceleration and works well in our experiments even at large ratios. As improvements in specialized accelerators such as GPUs and TPUs continue to exceed general purpose computing, we expect that data echoes and similar strategies will become an increasingly important part of the neural network training toolkit.
1
https://www.blog.google/products/google-cloud/google-cloud-offer-tpus-mach ine-learning/
2http://commoncrawl.org/2017/07/june-2017-crawl-archive-now-available/
3 We discarded the trial with divergent training loss, which occurred when the learning rate was too high
Reference to the literature
Olivier Bousquet,Sylvain Gelly,Karol Kurach,Olivier Teytaud,and Damien Vincent.Critical hyper-parameters:No random,no cry.arXiv preprint arXiv:1706.03200,2017.
Ciprian Chelba,Tomas Mikolov,Mike Schuster,Qi Ge,Thorsten Brants,Phillipp Koehn,and Tony Robinson.One billion word benchmark for measuring progress in statistical language modeling.In Conference of the International Speech Communication Association,2014.
Steven WD Chien,Stefano Markidis,Chaitanya Prasad Sishtla,Luis Santos,Pawel Herman,Sai Narasimhamurthy,and Erwin Laure.Characterizing deep-learning I/O workloads in TensorFlow.arXiv preprint arXiv:1810.03035,2018.
Matteo Fischetti,Iacopo Mandatelli,and Domenico Salvagnin.Faster SGD training by minibatch persistency.arXiv preprint arXiv:1806.07353,2018.
Kaiming He,Xiangyu Zhang,Shaoqing Ren,and Jian Sun.Deep residual learning for image recognition.In Proceedings of the IEEE conference on computer vision and pattern recognition,pages 770‚Äì778,2016.
Elad Hoffer,Itay Hubara,and Daniel Soudry.Train longer,generalize better:closing the generalization gap in large batch training of neural networks.In Advances in Neural Information Processing Systems,pages 1731‚Äì1741,2017.
Elad Hoffer,Tal Ben-Nun,Itay Hubara,Niv Giladi,Torsten Hoefler,and Daniel Soudry.Augment your batch:better training with larger batches.arXiv preprint arXiv:1901.09335,2019.
Sergey Ioffe and Christian Szegedy.Batch normalization:Accelerating deep network training by reducing internal covariate shift.arXiv preprint arXiv:1502.03167,2015.
Alex Krizhevsky and Geoffrey Hinton.Learning multiple layers of features from tiny images.Technical report,Citeseer,2009.
Sameer Kumar,Dheeraj Sreedhar,Vaibhav Saxena,Yogish Sabharwal,and Ashish Verma.Efficient training of convolutional neural nets on large distributed systems.arXiv preprint arXiv:1711.00705,2017.
Tsung-Yi Lin,Michael Maire,Serge Belongie,James Hays,Pietro Perona,Deva Ramanan,Piotr Dollar,and C Lawrence Zitnick.Microsoft COCO:Common objects in context.In European conference on computer vision,pages 740‚Äì755.Springer,2014.
Wei Liu,Dragomir Anguelov,Dumitru Erhan,Christian Szegedy,Scott Reed,Cheng-Yang Fu,and Alexander C Berg.SSD:Single shot multibox detector.In European conference on computer vision,pages 21‚Äì37.Springer,2016.
Volodymyr Mnih,Koray Kavukcuoglu,David Silver,Andrei A Rusu,Joel Veness,Marc G Bellemare,Alex Graves,Martin Riedmiller,Andreas K Fidjeland,Georg Ostrovski,et al.Human-level control through deep reinforcement learning.Nature,518(7540):529,2015.
Yurii Nesterov.A method for unconstrained convex minimization problem with the rate of conver gence O(1/k2).In Doklady AN USSR,volume 269,pages 543‚Äì547,1983.
Boris T Polyak.Some methods of speeding up the convergence of iteration methods.USSR Computational Mathematics and Mathematical Physics,4(5):1‚Äì17,1964.
David E Rumelhart,Geoffrey E Hinton,and Ronald J Williams.Learning representations by back-propagating errors.Nature,323(6088):533,1986.
Olga Russakovsky,Jia Deng,Hao Su,Jonathan Krause,Sanjeev Satheesh,Sean Ma,Zhiheng Huang,Andrej Karpathy,Aditya Khosla,Michael Bernstein,et al.ImageNet large scale visual recognition challenge.International Journal of Computer Vision,115(3):211‚Äì252,2015.
Christopher J Shallue,Jaehoon Lee,Joe Antognini,Jascha Sohl-Dickstein,Roy Frostig,and George E Dahl.Measuring the effects of data parallelism on neural network training.arXiv preprint arXiv:1811.03600,2018.
Ilya Sutskever,James Martens,George E.Dahl,and Geoffrey E.Hinton.On the importance of initialization and momentum in deep learning.In International Conference on Machine Learning,pages 1139‚Äì1147,2013.
Ashish Vaswani,Noam Shazeer,Niki Parmar,Jakob Uszkoreit,Llion Jones,Aidan N Gomez,Kaiser,and Illia Polosukhin.Attention is all you need.In Advances in Neural Information Processing Systems,pages 5998‚Äì6008,2017./>
Chris Ying,Sameer Kumar,Dehao Chen,Tao Wang,and Youlong Cheng.Image classification at supercomputer scale.arXiv preprint arXiv:1811.06992,2018.
Jian Zhang,Christopher De Sa,Ioannis Mitliagkas,and Christopher Re.Parallel SGD:When does averaging helparXiv preprint arXiv:1606.07365,2016.
Yue Zhu,Fahim Chowdhury,Huansong Fu,Adam Moody,Kathryn Mohror,Kento Sato,and Weikuan Yu.Entropy-aware I/O pipelining for large-scale deep learning on HPC systems.In2018 IEEE 26th International Symposium on Modeling,Analysis,and Simulation of Computer and Telecommunication Systems(MASCOTS),pages 145‚Äì156.IEEE,2018.
Martin Zinkevich,Markus Weimer,Lihong Li,and Alex J Smola.Parallelized stochastic gradient descent.In Advances in neural information processing systems,pages 2595‚Äì2603,2010.
Claims (18)
1. A method for reducing idleness in a machine learning training system, the method comprising:
executing, by the one or more computing devices, the first set of training operations to access and prepare a plurality of training examples included in the training data set; and
Executing, by the one or more computing devices, the second set of training operations to train the machine learning model based at least in part on the prepared training examples;
Wherein performing, by the one or more computing devices, the second set of training operations includes: performing, by the one or more computing devices, one or more iterative iterations in which at least a portion of the second set of training operations is repeatedly performed on at least one training example of the plurality of training examples included in the training data set such that the at least one training example is repeatedly used to train the machine learning model;
Wherein the rate of the one or more repeated iterations is based at least in part on an echo factor based at least in part on a comparison of a first computation time associated with performing the first set of training operations and a second computation time associated with performing the second set of training operations such that the first computation time and the adjusted second computation time are approximately equal to reduce or eliminate idleness of the second set of training operations; and
Wherein performing, by the one or more computing devices, the one or more repeated iterations reduces idle time that occurs when the one or more computing devices are performing the first set of training operations and not the second set of training operations.
2. The method of claim 1, wherein performing, by one or more computing devices, one or more iterations comprises:
For each of a plurality of iterations:
Inputting, by the one or more computing devices, at least one training example of the training data set into the machine learning model;
Receiving, by the one or more computing devices, at least one training output as an output of the machine learning model;
Evaluating, by the one or more computing devices, the at least one training output; and
Adjusting, by the one or more computing devices, parameters of the machine learning model based at least in part on the evaluation of the at least one training output;
Wherein the number of the plurality of iterations is based at least in part on the echo factor.
3. The method of claim 2, further comprising: at least one training example is enhanced by one or more computing devices by applying a transformation to the at least one training example.
4. The method of claim 3, wherein the enhancing, by the one or more computing devices, of the at least one training example is included in the first set of training operations such that the at least one training example does not change during one or more iterations.
5. The method of claim 3, wherein the enhancing, by the one or more computing devices, of the at least one training example is included in the second set of training operations such that the at least one training example is enhanced during each of the one or more iterations.
6. The method of claim 1, wherein performing, by one or more computing devices, one or more iterations further comprises:
Performing, by the one or more computing devices, a training step on each of a batch of multiple training examples of the training data set;
Repeating, by the one or more computing devices, the training step for each of the set of multiple training examples of training data is based on a number of repetitions of the echo factor.
7. The method of claim 1, further comprising: the echo factor is dynamically adjusted by one or more computing devices.
8. The method of claim 1, further comprising:
Monitoring, by one or more computing devices, one or both of:
a first computing time associated with performing the first set of training operations; and
A second calculation time associated with performing a second set of training operations; and
Dynamically adjusting, by the one or more computing devices, in real-time, to reduce idle time in real-time, based at least in part on a comparison of a first computation time associated with performing the first set of training operations and a second computation time associated with performing the second set of training operations, the idle time occurring when the one or more computing devices are performing the first set of training operations and not the second set of training operations.
9. The method of claim 1, further comprising:
Evaluating, by the one or more computing devices, the loss function for the at least one training example and the machine learning model to determine a loss value for the at least one training example; and
The echo factor is adjusted by the one or more computing devices based on the loss value.
10. The method of claim 1, further comprising:
evaluating, by the one or more computing devices, the loss function for at least two of the plurality of training examples and the machine learning model to determine a respective loss value for each of the at least two of the plurality of training examples; and
At least one training example is selected from the plurality of training examples by the one or more computing devices based on respective loss values of at least two training examples of the plurality of training examples.
11. The method of claim 1, further comprising: selecting, by the one or more computing devices, at least one training example based on at least one of:
The relative position of at least one training example among the plurality of training examples; or alternatively
At least one training example.
12. The method of claim 1, further comprising: at least one training example is probabilistically selected by one or more computing devices based on the echo factors such that repeated iterations are performed for less than all of the plurality of training examples.
13. A computing system configured to perform a training process to train a machine learning model based on a training data set comprising a plurality of training examples, the computing system comprising:
A computer readable storage disk configured to store a plurality of training examples;
a first set of hardware components configured to run a first set of training operations to access a plurality of training examples from a computer-readable storage disk, prepare the plurality of training examples for training a machine learning model, and store the prepared training examples in an intermediate data buffer;
an intermediate data buffer configured to store the prepared training samples; and
A second set of hardware components configured to run a second set of training operations to access the prepared training examples from the intermediate data buffer and train the machine learning model using the prepared training examples;
Wherein the second set of hardware components is configured to perform one or more iterations, wherein the second set of hardware components repeatedly accesses the at least one prepared training example from the intermediate data buffer and repeatedly uses the at least one prepared training example to train the machine learning model;
Wherein the rate at which the second set of hardware components is configured to perform one or more iterations is based at least in part on an echo factor based at least in part on a comparison of a first computation time associated with performing a first set of training operations by the first set of hardware components and a second computation time associated with performing a second set of training operations by the second set of hardware components such that the first computation time and the adjusted second computation time are approximately equal to reduce or eliminate idleness of the second set of training operations; and
Wherein performing one or more iterations reduces idle time that occurs when the first set of hardware components is performing the first set of training operations but the second set of hardware components is not performing the second set of training operations.
14. The computing system of claim 13, wherein the first set of hardware components comprises one or more general-purpose processors and the second set of hardware components comprises one or more application specific integrated circuits.
15. The computing system of claim 14, wherein the application specific integrated circuit comprises a hardware accelerator comprising one or more graphics processing units or tensor processing units.
16. The computing system of claim 13, wherein performing one or more iterations comprises:
For each of a plurality of iterations:
Inputting, by the one or more computing devices, at least one training example of the plurality of training examples into the machine learning model;
Receiving, by the one or more computing devices, at least one training output as an output of the machine learning model;
Evaluating, by the one or more computing devices, the at least one training output; and
Adjusting, by the one or more computing devices, parameters of the machine learning model based at least in part on the evaluation of the at least one training output;
Wherein the number of the plurality of iterations is based at least in part on the echo factor.
17. The computing system of claim 13, wherein the first set of hardware components is further configured to augment at least one training example in the first set of training operations by applying a transformation to the at least one training example such that the at least one training example does not change during one or more repeated iterations.
18. The computing system of claim 13, wherein the second set of hardware components is further configured to augment at least one training example in the second set of training operations by applying a transformation to the at least one training example such that the at least one training example is augmented during each of the one or more repeated iterations performed by the second set of hardware components.
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201962852056P | 2019-05-23 | 2019-05-23 | |
US62/852,056 | 2019-05-23 |
Publications (2)
Publication Number | Publication Date |
---|---|
CN112183760A CN112183760A (en) | 2021-01-05 |
CN112183760B true CN112183760B (en) | 2024-05-14 |
Family
ID=
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN108564164A (en) * | 2018-01-08 | 2018-09-21 | ‰∏≠Â±±Â§ßÂ≠¶ | A kind of parallelization deep learning method based on SPARK platforms |
CN108564168A (en) * | 2018-04-03 | 2018-09-21 | ‰∏≠ÂõΩÁßëÂ≠¶Èô¢ËÆ°ÁÆóÊäÄÊúØÁ†îÁ©∂ÊâÄ | A kind of design method to supporting more precision convolutional neural networks processors |
CN109754088A (en) * | 2017-11-06 | 2019-05-14 | Ë∞∑Ê≠åÊúâÈôêË¥£‰ªªÂÖ¨Âè∏ | The computing system of modular basis structure with training production confrontation network |
CN109753751A (en) * | 2019-01-20 | 2019-05-14 | Âåó‰∫¨Â∑•‰∏öÂ§ßÂ≠¶ | A kind of MEC Random Task moving method based on machine learning |
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN109754088A (en) * | 2017-11-06 | 2019-05-14 | Ë∞∑Ê≠åÊúâÈôêË¥£‰ªªÂÖ¨Âè∏ | The computing system of modular basis structure with training production confrontation network |
CN108564164A (en) * | 2018-01-08 | 2018-09-21 | ‰∏≠Â±±Â§ßÂ≠¶ | A kind of parallelization deep learning method based on SPARK platforms |
CN108564168A (en) * | 2018-04-03 | 2018-09-21 | ‰∏≠ÂõΩÁßëÂ≠¶Èô¢ËÆ°ÁÆóÊäÄÊúØÁ†îÁ©∂ÊâÄ | A kind of design method to supporting more precision convolutional neural networks processors |
CN109753751A (en) * | 2019-01-20 | 2019-05-14 | Âåó‰∫¨Â∑•‰∏öÂ§ßÂ≠¶ | A kind of MEC Random Task moving method based on machine learning |
Non-Patent Citations (2)
Title |
---|
Faster neural network training with data echoing;Choi DÁ≠â;„ÄäarXiv:1907.05550v3„Äã;1-15 * |
Èù¢ÂêëË≠¶Âä°Êï∞ÊçÆÂ§ÑÁêÜÁöÑSparkÊÄßËÉΩ‰ºòÂåñÁ†îÁ©∂‰∏éÂÆûÁé∞;ÈôàÂêõÁ≠â;„Ää‰∏≠ÂõΩ‰ºòÁßÄÁ°ïÂ£´Â≠¶‰ΩçËÆ∫ÊñáÂÖ®ÊñáÊï∞ÊçÆÂ∫ì‰ø°ÊÅØÁßëÊäÄËæë„Äã(Á¨¨9Êúü);I138-186 * |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20220222531A1 (en) | Asynchronous neural network training | |
US11928574B2 (en) | Neural architecture search with factorized hierarchical search space | |
EP3446260B1 (en) | Memory-efficient backpropagation through time | |
Park et al. | Deep learning inference in facebook data centers: Characterization, performance optimizations and hardware implications | |
Mohan et al. | Analyzing and mitigating data stalls in DNN training | |
Murray et al. | Parallel resampling in the particle filter | |
Choi et al. | Faster neural network training with data echoing | |
Esmaeilzadeh et al. | Neural acceleration for general-purpose approximate programs | |
US20150324325A1 (en) | Techniques to perform data reduction for statistical tests | |
US11450096B2 (en) | Systems and methods for progressive learning for machine-learned models to optimize training speed | |
EP3836030A1 (en) | Method and apparatus with model optimization, and accelerator system | |
Krishnan et al. | QuaRL: Quantization for fast and environmentally sustainable reinforcement learning | |
Ad√°mek et al. | GPU fast convolution via the overlap-and-save method in shared memory | |
CN114286985A (en) | Method and apparatus for predicting kernel tuning parameters | |
Yamaoka et al. | In situ adaptive timestep control and visualization based on the spatio-temporal variations of the simulation results | |
Valery et al. | Low precision deep learning training on mobile heterogeneous platform | |
Das et al. | Enabling on-device smartphone GPU based training: Lessons learned | |
CN112183760B (en) | System and method for reducing idle of machine learning training system using data echo | |
CN112771546A (en) | Operation accelerator and compression method | |
US9529942B1 (en) | Auto-optimizing out-of-core method and system for rendering of large engineering 3D CAD assemblies on handheld devices | |
Ozcan et al. | Investigation of the performance of LU decomposition method using CUDA | |
Dong et al. | Progress indication for deep learning model training: a feasibility demonstration | |
CN111448545B (en) | Parallel processing apparatus and method for parallel multi-value reduction | |
Jain et al. | Workload characterization of a time-series prediction system for spatio-temporal data | |
CN112183760A (en) | System and method for reducing idleness of machine learning training system using data echo |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
GR01 | Patent grant |