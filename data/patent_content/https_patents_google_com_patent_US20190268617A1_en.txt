US20190268617A1 - Dynamic reference motion vector coding mode - Google Patents
Dynamic reference motion vector coding mode Download PDFInfo
- Publication number
- US20190268617A1 US20190268617A1 US15/131,079 US201615131079A US2019268617A1 US 20190268617 A1 US20190268617 A1 US 20190268617A1 US 201615131079 A US201615131079 A US 201615131079A US 2019268617 A1 US2019268617 A1 US 2019268617A1
- Authority
- US
- United States
- Prior art keywords
- motion vector
- candidate motion
- candidate
- current block
- motion vectors
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/513—Processing of motion vectors
- H04N19/517—Processing of motion vectors by encoding
- H04N19/52—Processing of motion vectors by encoding by predictive encoding
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T7/00—Image analysis
- G06T7/20—Analysis of motion
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T9/00—Image coding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/103—Selection of coding mode or of prediction mode
- H04N19/109—Selection of coding mode or of prediction mode among a plurality of temporal predictive coding modes
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/136—Incoming video signal characteristics or properties
- H04N19/137—Motion inside a coding unit, e.g. average field, frame or block difference
- H04N19/139—Analysis of motion vectors, e.g. their magnitude, direction, variance or reliability
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/157—Assigned coding mode, i.e. the coding mode being predefined or preselected to be further used for selection of another element or parameter
- H04N19/159—Prediction type, e.g. intra-frame, inter-frame or bidirectional frame prediction
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/17—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object
- H04N19/176—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object the region being a block, e.g. a macroblock
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/44—Decoders specially adapted therefor, e.g. video decoders which are asymmetric with respect to the encoder
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/527—Global motion vector estimation
Definitions
- This disclosure relates to video encoding and decoding.
- Digital video streams may represent video using a sequence of frames or still images.
- Digital video can be used for various applications including, for example, video conferencing, high definition video entertainment, video advertisements, or sharing of user-generated videos.
- a digital video stream can contain a large amount of data and consume a significant amount of computing or communication resources of a computing device for processing, transmission or storage of the video data.
- Various approaches have been proposed to reduce the amount of data in video streams, including compression and other encoding techniques.
- One method for encoding a video stream having a plurality of blocks including a current block described herein includes identifying, for each previously coded block of a plurality of previously coded blocks of the video stream, a candidate motion vector used to inter predict the previously coded block to define a plurality of candidate motion vectors; determining, using a processor, for each candidate motion vector of the plurality of candidate motion vectors, a distance between the previously coded block associated with the candidate motion vector and a current block of a current frame; determining, using the processor, for each candidate motion vector of the plurality of candidate motion vectors, a popularity value based on a set of previously coded pixels associated with the candidate motion vector; ranking each candidate motion vector of the plurality of candidate motion vectors according to a priority value for each candidate motion vector, the priority value based on the distance and popularity
- Another method described herein is a method for decoding an encoded video bitstream, including determining, from bits included in the encoded video bitstream, a reference frame on a condition that a motion vector for a current block to be decoded was encoded using a reference motion vector and whether the motion vector for the current block to be decoded was encoding using single prediction or compound prediction, the current block comprising one of a plurality of blocks of a current frame of the encoded video bitstream; identifying, for each previously decoded block of a plurality of previously decoded blocks, a candidate motion vector used to inter predict the previously decoded block to define a plurality of candidate motion vectors; determining, using a processor, for each candidate motion vector of the plurality of candidate motion vectors, a distance between the previously coded block associated with the candidate motion vector and the current block; determining, using the processor, for each candidate motion vector of the plurality of candidate motion vectors, a popularity value based on a set of previously coded pixels associated with the candidate motion vector; ranking
- An example of an apparatus for encoding a video stream described herein includes a memory and a processor.
- the processor is configured to execute instructions stored in the memory to identify, for each previously coded block of a plurality of previously coded blocks, a candidate motion vector used to inter predict the previously coded block to define a plurality of candidate motion vectors; determine, for each candidate motion vector of the plurality of candidate motion vectors, a distance between the previously coded block associated with the candidate motion vector and a current block of a current frame; determine, for each candidate motion vector of the plurality of candidate motion vectors, a popularity value based on a set of previously coded pixels associated with the candidate motion vector; rank each candidate motion vector of the plurality of candidate motion vectors according to a priority value for each candidate motion vector, the priority value based on the distance and popularity value associated with the candidate motion vector; select, based on the priority values, a reference motion vector from the plurality of candidate motion vectors; and encode a motion vector for the current block using the reference motion vector.
- FIG. 1 is a schematic of a video encoding and decoding system in accordance with implementations of this disclosure
- FIG. 2 is a diagram of an example video stream to be encoded and decoded in accordance with implementations of this disclosure
- FIG. 3 is a block diagram of a video compression system in accordance with implementations of this disclosure.
- FIG. 4 is a block diagram of a video decompression system in accordance with implementations of this disclosure.
- FIG. 5 is a flow diagram of a process for encoding a video stream using reference motion vectors in accordance with an implementation of this disclosure
- FIG. 6 is a diagram of a frame including a current block used to explain the process of FIG. 5 ;
- FIG. 7 is a diagram of the current block of FIG. 6 and a set of previously coded pixel
- FIG. 8 is a diagram of a set of predicted pixels for the set of previously coded pixels of FIG. 7 ;
- FIG. 9 is a flow diagram of a process for decoding an encoded video stream using reference motion vectors in accordance with implementations of this disclosure.
- FIG. 10 is a diagram of a series of frames of a first video stream in accordance with an implementation of this disclosure.
- FIG. 11 is a diagram of a series of frames of a second video stream in accordance with an implementation of this disclosure.
- Compression schemes related to coding video streams may include breaking each image into blocks and generating a digital video output bitstream using one or more techniques to limit the information included in the output.
- a received bitstream can be decoded to re-create the blocks and the source images from the limited information.
- Encoding a video stream, or a portion thereof, such as a frame or a block can include using temporal and spatial similarities in the video stream to improve coding efficiency.
- a current block of a video stream may be encoded based on a previously encoded block in the video stream by predicting motion and color information for the current block based on the previously encoded block and identifying a difference (residual) between the predicted values and the current block. In this way, only the residual and parameters used to generate it need be added to the bitstream instead of including the entirety of the current block.
- This technique may be referred to as inter prediction.
- One of the parameters in inter prediction is a motion vector that represents the spatial displacement of the previously coded block relative to the current block.
- the motion vector can be identified using a method of motion estimation, such as a motion search.
- motion search a portion of a reference frame can be translated to a succession of locations to form a prediction block that can be subtracted from a portion of a current frame to form a series of residuals.
- the X and Y translations corresponding to the location having the smallest residual can be selected as the motion vector.
- Bits representing the motion vector can be included in the encoded bitstream to permit a decoder to reproduce the prediction block and decode the portion of the encoded video bitstream associated with the motion vector.
- a motion vector can be differentially encoded using a reference motion vector, i.e., only the difference between the motion vector and the reference motion vector is encoded.
- the reference motion vector can be selected from previously used motion vectors in the video stream, for example, the last non-zero motion vector from neighboring blocks. Selecting a previously used motion vector to encode a current motion vector can further reduce the number of bits included in the encoded video bitstream and thereby reduce transmission and storage bandwidth requirements.
- Motion vector referencing modes allow a coding block to infer motion information from previously coded neighboring blocks.
- a reference motion vector can be selected from candidate motion vectors based on the distance between the reference block and the current block and the popularity of the reference motion vector.
- the distance between the reference block and the current block can be based on the spacial displacement between the pixels in the previously coded block and the collocated pixels in the current block, measured in the unit of pixels.
- the popularity of the motion vector can be based on the amount of previously coded pixels that use the motion vector. The more previously coded pixels that use the motion vector, the higher the probability of the motion vector.
- the popularity value is the number of previously coded pixels that use the motion vector.
- the popularity value is a percentage of previously coded pixels within an area that use the motion vector.
- a candidate motion vector used in a reference block near the current block may closely resemble the actual motion vector for the current block. Additionally, a candidate motion vector that is used by the most amount of pixels in a reference block near the current block would further resemble the actual motion vector for the current block. For this reason, the motion vector of the candidate motion vectors with the highest popularity used in a nearby reference block may be selected as the reference motion vector for the actual motion vector of the current block. Fewer bits can be used to code the actual motion vector by coding the small difference in motion vectors, thus improving the overall coding efficiency. Other ways in which the selected motion vector may be used are discussed hereinafter.
- the candidate motion vectors may be limited to spatial-temporal neighboring motion vectors. That is, the pool of candidate motion vectors may be selected from regions neighboring regions of the current block. In some video coding schemes, particularly those where video frames are encoded out of order, it is desirable to include in the pool of candidate motion vectors motion information from video frames in the distant past or future. Encoding video frames can out of order may occur, for example, in the coding of so-called “alternate reference frames” that are not temporally neighboring to the frames coded immediately before or after them.
- An alternate reference frame may be a synthesized frame that does not occur in the input video stream or is a duplicate frame to one in the input video stream that is used for prediction and is generally not displayed following decoding.
- Such a frame can resemble a video frame in the non-adjacent future.
- Another example in which out of order encoding may occur is through the use of a so-called “golden reference frame,” which is a reconstructed video frame that may or may not be neighboring to a current video frame and is stored in memory for use as a reference frame until replaced, e.g., by a new golden reference frame.
- alternate reference frames and golden reference frames are used to infer motion vectors for a block of a frame of video data using pixels from the non-adjacent or adjacent video frames to predict reconstructed pixels spatially near the block to be predicted.
- alternate reference frames and golden reference frames also called alternate frames and golden frames
- adjacent video frames are used to infer motion vectors for a block of a frame of video data using pixels from the non-adjacent or adjacent video frames to predict reconstructed pixels spatially near the block to be predicted.
- FIG. 1 is a schematic of a video encoding and decoding system 100 in which aspects of the disclosure can be implemented.
- An exemplary transmitting station 102 can be, for example, a computer having an internal configuration of hardware including a processor such as a central processing unit (CPU) 104 and a memory 106 .
- CPU 104 is a controller for controlling the operations of transmitting station 102 .
- CPU 104 can be connected to the memory 106 by, for example, a memory bus.
- Memory 106 can be read only memory (ROM), random access memory (RAM) or any other suitable memory device.
- Memory 106 can store data and program instructions that are used by CPU 104 .
- Other suitable implementations of transmitting station 102 are possible. For example, the processing of transmitting station 102 can be distributed among multiple devices.
- a network 108 connects transmitting station 102 and a receiving station 110 for encoding and decoding of the video stream.
- the video stream can be encoded in transmitting station 102 and the encoded video stream can be decoded in receiving station 110 .
- Network 108 can be, for example, the Internet.
- Network 108 can also be a local area network (LAN), wide area network (WAN), virtual private network (VPN), a cellular telephone network or any other means of transferring the video stream from transmitting station 102 to, in this example, receiving station 110 .
- LAN local area network
- WAN wide area network
- VPN virtual private network
- Receiving station 110 can, in one example, be a computer having an internal configuration of hardware including a processor such as a CPU 112 and a memory 114 .
- CPU 112 is a controller for controlling the operations of receiving station 110 .
- CPU 112 can be connected to memory 114 by, for example, a memory bus.
- Memory 114 can be ROM, RAM or any other suitable memory device.
- Memory 114 can store data and program instructions that are used by CPU 112 .
- Other suitable implementations of receiving station 110 are possible. For example, the processing of receiving station 110 can be distributed among multiple devices.
- a display 116 configured to display a video stream can be connected to receiving station 110 .
- Display 116 can be implemented in various ways, including by a liquid crystal display (LCD), a cathode-ray tube (CRT), or a light emitting diode display (LED), such as an OLED display.
- Display 116 is coupled to CPU 112 and can be configured to display a rendering 118 of the video stream decoded in receiving station 110 .
- a video stream can be encoded and then stored for transmission at a later time by receiving station 110 or any other device having memory.
- receiving station 110 receives (e.g., via network 108 , a computer bus, or some communication pathway) the encoded video stream and stores the video stream for later decoding.
- additional components can be added to the encoder and decoder system 100 .
- a display or a video camera can be attached to transmitting station 102 to capture the video stream to be encoded.
- FIG. 2 is a diagram of an example video stream 200 to be encoded and decoded.
- Video stream 200 (also referred to herein as video data) includes a video sequence 204 .
- video sequence 204 includes a number of adjacent frames 206 . While three frames are depicted in adjacent frames 206 , video sequence 204 can include any number of adjacent frames.
- Adjacent frames 206 can then be further subdivided into individual frames, e.g., a single frame 208 . Each frame 208 can capture a scene with one or more objects, such as people, background elements, graphics, text, a blank wall, or any other information.
- single frame 208 can be divided into a set of blocks 210 , which can contain data corresponding to, in some of the examples described below, a 8 ⁇ 8 pixel group in frame 208 .
- Block 210 can also be of any other suitable size such as a block of 16 ⁇ 8 pixels, a block of 8 ⁇ 8 pixels, a block of 16 ⁇ 16 pixels, a block of 4 ⁇ 4 pixels, or of any other size.
- the term ‘block’ can include a macroblock, a subblock (i.e., a subdivision of a macroblock), a segment, a slice, a residual block or any other portion of a frame.
- a frame, a block, a pixel, or a combination thereof can include display information, such as luminance information, chrominance information, or any other information that can be used to store, modify, communicate, or display the video stream or a portion thereof.
- FIG. 3 is a block diagram of an encoder 300 in accordance with implementations of this disclosure.
- Encoder 300 can be implemented, as described above, in transmitting station 102 such as by providing a computer software program stored in memory 106 , for example.
- the computer software program can include machine instructions that, when executed by CPU 104 , cause transmitting station 102 to encode video data in the manner described in FIG. 3 .
- Encoder 300 can also be implemented as specialized hardware in, for example, transmitting station 102 .
- Encoder 300 has the following stages to perform the various functions in a forward path (shown by the solid connection lines) to produce an encoded or a compressed bitstream 320 using input video stream 200 : an intra/inter prediction stage 304 , a transform stage 306 , a quantization stage 308 , and an entropy encoding stage 310 .
- Encoder 300 may include a reconstruction path (shown by the dotted connection lines) to reconstruct a frame for encoding of future blocks.
- encoder 300 has the following stages to perform the various functions in the reconstruction path: a dequantization stage 312 , an inverse transform stage 314 , a reconstruction stage 316 , and a loop filtering stage 318 .
- Other structural variations of encoder 300 can be used to encode video stream 200 .
- each frame 208 within video stream 200 can be processed in units of blocks.
- each block can be encoded using either intra prediction (i.e., within a single frame) or inter prediction (i.e. from frame to frame). In either case, a prediction block can be formed. The prediction block is then subtracted from the block to produce a residual block (also referred to herein as residual).
- Intra prediction also referred to herein as intra-prediction or intra-frame prediction
- inter prediction also referred to herein as inter-prediction or inter-frame prediction
- intra-prediction a prediction block can be formed from samples in the current frame that have been previously encoded and reconstructed.
- a prediction block can be formed from samples in one or more previously constructed reference frames, such as the last frame (i.e., the adjacent frame immediately before the current frame), the golden frame or the constructed or alternate frame described above.
- the prediction block is then subtracted from the current block.
- the difference, or residual is then encoded and transmitted to decoders.
- Image or video codecs may support many different intra and inter prediction modes; each block may use one of the prediction modes to obtain a prediction block that is most similar to the block to minimize the information to be encoded in the residual so as to re-create the block.
- the prediction mode for each block of transform coefficients can also be encoded and transmitted so a decoder can use the same prediction mode(s) to form prediction blocks in the decoding and reconstruction process.
- the prediction mode may be selected from one of multiple intra-prediction modes.
- the prediction mode may be selected from one of multiple inter-prediction modes using one or more reference frames including, for example, last frame, golden frame, alternative reference frame, or any other reference frame in an encoding scheme.
- the bitstream syntax supports three categories of inter prediction modes.
- the inter prediction modes can include, for example, a mode (sometimes called ZERO_MV mode) in which a block from the same location within a reference frame as the current block is used as the prediction block; a mode (sometimes called a NEW_MV mode) in which a motion vector is transmitted to indicate the location of a block within a reference frame to be used as the prediction block relative to the current block; or a mode (sometimes called a REF_MV mode comprising NEAR_MV or NEAREST_MV mode) in which no motion vector is transmitted and the current block uses the last or second-to-last non-zero motion vector used by neighboring, previously coded blocks to generate the prediction block. Inter-prediction modes may be used with any of the available reference frames.
- the reference motion vector coding modes analyze the available blocks motion activity to produce a ranked reference motion vector candidate list, allowing the size of the reference motion vector modes to be dynamically extended, a generalization of the fixed NEAREST_MV mode and NEAR_MV mode, and improving the efficacy of entropy coding.
- REF_MV mode represents reference motion vector modes, including NEAR_MV and NEAREST_MV modes, as well as extended modes when the candidate motion vector list shows sufficient variation.
- the entropy coding system starts with NEW_MV mode, selecting the probability model according to the contexts of the number of reference motion vectors found and, if a neighboring block with matched reference frame is found, determining the likelihood that the neighboring block is coded in NEW_MV mode.
- the codec continues to code if the mode is ZERO_MV mode.
- the codec selects the mode probability model according to the contexts when the collocated block in the previous frame is using a zero motion vector, or close to zero motion vector (i.e., less than 1 full pixel in both row and column components), or when the spatial neighboring blocks are using zero, or close to zero, motion vectors.
- the codec decides between the REF_MV modes.
- the associated context is how many reference motion vectors checked into the candidate list and the weighing coefficients.
- the REF_MV mode syntax suggests that the effective motion vector comes from referring neighboring blocks coding information.
- a list of such possible reference motion vector candidates includes reference motion vector candidates that are ranked according to their relative distance to the current block and the overlapped amount.
- the codec needs to decode which one in the list to pick and use.
- the codec can select the candidate motion vector among the candidate motion vectors in the list that would provide the best prediction and send the index associated with that particular candidate motion vector to the decoder.
- transform stage 306 transforms the residual into a block of transform coefficients in, for example, the frequency domain.
- block-based transforms include the Karhunen-Loève Transform (KLT), the Discrete Cosine Transform (DCT), Walsh-Hadamard Transform (WHT), the Singular Value Decomposition Transform (SVD) and the Asymmetric Discrete Sine Transform (ADST).
- KLT Karhunen-Loève Transform
- DCT Discrete Cosine Transform
- WHT Walsh-Hadamard Transform
- Singular Value Decomposition Transform SVD
- ADST Asymmetric Discrete Sine Transform
- the DCT transforms the block into the frequency domain.
- the transform coefficient values are based on spatial frequency, with the lowest frequency (e.g., DC) coefficient at the top-left of the matrix and the highest frequency coefficient at the bottom-right of the matrix.
- Quantization stage 308 converts the block of transform coefficients into discrete quantum values, which are referred to as quantized transform coefficients, using a quantizer value or quantization level.
- the quantized transform coefficients are then entropy encoded by entropy encoding stage 310 .
- the entropy-encoded coefficients, together with other information used to decode the block, which can include for example the type of prediction used, motion vectors and quantization value, are then output to compressed bitstream 320 .
- Compressed bitstream 320 can be formatted using various techniques, such as variable length encoding (VLC) and arithmetic coding.
- VLC variable length encoding
- Compressed bitstream 320 can also be referred to as an encoded video stream and the terms will be used interchangeably herein.
- the reconstruction path in FIG. 3 can be used to provide both encoder 300 and a decoder 400 (described below) with the same reference frames to decode compressed bitstream 320 .
- the reconstruction path performs functions that are similar to functions that take place during the decoding process that are discussed in more detail below, including dequantizing the quantized transform coefficients at dequantization stage 312 to generate dequantized transform coefficients and inverse transforming the dequantized transform coefficients at inverse transform stage 314 to produce a derivative residual block (i.e., derivative residual).
- the prediction block that was predicted at intra/inter prediction stage 304 can be added to the derivative residual to create a reconstructed block.
- loop filtering stage 318 can be applied to the reconstructed block to reduce distortion such as blocking artifacts.
- encoder 300 can be used.
- a non-transform based encoder 300 can quantize the residual block directly without transform stage 304 .
- an encoder 300 can have quantization stage 308 and dequantization stage 312 combined into a single stage.
- FIG. 4 is a block diagram of a decoder 400 in accordance with implementations of this disclosure.
- Decoder 400 can be implemented, for example, in receiving station 110 , such as by providing a computer software program stored in memory for example.
- the computer software program can include machine instructions that, when executed by CPU 112 , cause receiving station 110 to decode video data in the manner described in FIG. 4 .
- Decoder 400 can also be implemented as specialized hardware or firmware in, for example, transmitting station 102 or receiving station 110 .
- Decoder 400 similar to the reconstruction path of encoder 300 discussed above, includes in one example the following stages to perform various functions to produce an output video stream 416 from compressed bitstream 320 : an entropy decoding stage 402 , a dequantization stage 404 , an inverse transform stage 406 , an intra/inter prediction stage 408 , a reconstruction stage 410 , a loop filtering stage 412 , and a deblocking filtering stage 414 .
- Other structural variations of decoder 400 can be used to decode compressed bitstream 320 .
- the data elements within compressed bitstream 320 can be decoded by the entropy decoding stage 402 (using, for example, arithmetic coding) to produce a set of quantized transform coefficients.
- Dequantization stage 404 dequantizes the quantized transform coefficients and inverse transform stage 406 inverse transforms the dequantized transform coefficients to produce a derivative residual that can be identical to that created by reconstruction stage 316 in encoder 300 .
- decoder 400 can use intra/inter prediction stage 408 to create the same prediction block as was created in encoder 300 , e.g., at intra/inter prediction stage 304 .
- the reference frame from which the prediction block is generated may be transmitted in the bitstream or constructed by the decoder using information contained within the bitstream.
- the prediction block can be added to the derivative residual to create a reconstructed block that can be identical to the block created by reconstruction stage 316 in encoder 300 .
- loop filtering stage 412 can be applied to the reconstructed block to reduce blocking artifacts.
- Deblocking filtering stage 414 can be applied to the reconstructed block to reduce blocking distortion, and the result is output as output video stream 416 .
- Output video stream 416 can also be referred to as a decoded video stream and the terms will be used interchangeably herein.
- decoder 400 can be used to decode compressed bitstream 320 .
- decoder 400 can produce output video stream 416 without deblocking filtering stage 414 .
- FIG. 5 is a flow diagram showing a process 500 for encoding a video stream using reference motion vectors in accordance with an implementation of this disclosure.
- Process 500 can be implemented in an encoder such as encoder 300 (shown in FIG. 3 ) and can be implemented, for example, as a software program that can be executed by computing devices such as transmitting station 102 or receiving station 110 (shown in FIG. 1 ).
- the software program can include machine-readable instructions that can be stored in a memory such as memory 106 or memory 114 , and that can be executed by a processor, such as CPU 104 , to cause the computing device to perform process 500 .
- Process 500 can be implemented using specialized hardware or firmware. Some computing devices can have multiple memories, multiple processors, or both. The steps of process 500 can be distributed using different processors, memories, or both. Use of the terms “processor” or “memory” in the singular encompasses computing devices that have one processor or one memory as well as devices that have multiple processors or multiple memories that can each be used in the performance of some or all of the recited steps. For simplicity of explanation, process 500 is depicted and described as a series of steps. However, steps in accordance with this disclosure can occur in various orders and/or concurrently. Additionally, steps in accordance with this disclosure may occur with other steps not presented and described herein. Furthermore, not all illustrated steps may be required to implement a method in accordance with the disclosed subject matter.
- Process 500 assumes that a stream of video data having multiple frames, each having multiple blocks, is being encoded using a video encoder such as video encoder 300 executing on a computing device such as transmitting station 102 .
- the video data or stream can be received by the computing device in any number of ways, such as by receiving the video data over a network, over a cable, or by reading the video data from a primary memory or other storage device, including a disk drive or removable media such as a CompactFlash (CF) card, Secure Digital (SD) card, or any other device capable of communicating video data.
- video data can be received from a video camera connected to the computing device operating the encoder. At least some of the blocks within frames are encoded using inter prediction as described in more detail below.
- process 500 identifies candidate motion vectors from previously coded blocks in the video stream.
- Process 500 analyzes the motion activity of previously coded blocks to produce a list of ranked candidate motion vectors, employing an efficient reference motion vector ranking system, and provides a dynamic motion referencing mode that fully accounts for the available motion vector candidate list, which allows the number of the reference motion vector modes to be dynamically extended or shortened and improves the efficacy of entropy coding.
- the pool of the candidate motion vectors can be dynamically extended or shortened according to the neighboring reference block condition, i.e., how the list of candidate motion vectors is created.
- the previously coded blocks in the video stream can include any block encoded using inter-prediction before the current block, such as a block from a previously coded frame or a block from the same frame as the current block that has been encoded before the current block.
- the previously coded blocks can include a block above, to the left, or to the above-left of the current block in the same frame.
- the previously coded blocks can also include, for example, a block from the immediately previous frame (i.e., last frame), a block from the golden frame (described at intra/inter prediction stage 304 ), a block from any other reference frame, or any combination thereof.
- the candidate motion vectors are obtained from previously coded blocks that correspond in some way to the current block based on the theory that such blocks, due to the proximity of their pixels to the current block, are likely to have similar motion characteristics to the current block.
- Blocks may be predicted from a single reference frame or compound, such as two, reference frames.
- process 500 identifies candidate motion vectors from the nearest spatial neighboring blocks that are associated with the reference frame.
- the candidate motion vectors may include the motion vector reference blocks within a reference coverage area, such as the motion vector from a block above the current block, the motion vector from a block to the left of the current block, the motion vector from a block to the above-right of the current block, and the motion vector of a collocated block in the previous frame.
- Process 500 determines, for each candidate motion vector, a distance between the previously coded block associated with the candidate motion vector and the current block 504 .
- the candidate motion vectors are ranked based on the distance, from nearest to furthest, from the previously coded block and the overlapped length between the previously coded block and the current block.
- the nearest candidate motion vector from the block above the current block, the nearest candidate motion vector from a block to the left of the current block, and the nearest candidate motion vector from the above-right of the current block are considered to be category 1 candidate motion vectors. Due to the proximity of the previously coded block to the current block, it is possible that the current block has similar motion characteristics as the previously coded block.
- the remaining candidate motion vectors are considered to be category 2 candidate motion vectors. Category 1 candidate motion vectors always assume a higher priority than category 2 candidate motion vectors.
- Process 500 determines, for each candidate motion vector within category 1 and category 2 , a popularity value based on a set of previously coded pixel values associated with the particular candidate motion vector 504 .
- the candidate motion vectors are ranked according to their popularity value, with category 1 candidate motion vectors always ranking higher than category 2 candidate motion vectors. The larger the number of previously coded pixel values associated with the candidate motion vector, the higher the popularity value of the candidate motion vector.
- a reference motion vector can be selected from the candidate motion vectors identified in step 504 , based on the candidate motion vector nearest the current block and having the highest popularity value.
- the motion vector of the current block can be encoded using the reference motion vector in step 510 before processing begins again for the next block of the current frame.
- the current block can be encoded according to the process described with respect to FIG. 3 .
- Blocks can be predicted from two reference frames, where the prediction will be the average of the two frames.
- the average can be a weighted average.
- process 500 finds the reference blocks that share the most reference frames with the current block.
- Process 500 identifies and assigns a higher priority to candidate motion vectors from neighboring reference blocks that share the same reference frame combination.
- process 500 identifies additional combinations of candidate motion vectors from blocks with single reference frames, as described above.
- Process 500 determines, for each candidate motion vector, a distance between the previously coded block associated with the candidate motion vector and the current block 504 .
- the distance between the previously coded block associated with the candidate motion vector and the current block can be based on the spacial displacement between the pixels in the previously coded block and the collocated pixels in the current block, measured in the unit of pixels.
- the candidate motion vectors are ranked based on the distance, from nearest to furthest, from the previously coded block to the current block and the overlapped length between the previously coded block and the current block.
- the nearest candidate motion vector from the block above the current block, the nearest candidate motion vector from a block to the left of the current block, and the nearest candidate motion vector from the above-right of the current block are considered to be category 1 candidate motion vectors.
- the remaining candidate motion vectors are considered to be category 2 candidate motion vectors.
- Process 500 determines, for each candidate motion vector identified in step 502 , a popularity value based on a set of previously coded pixel values associated with the candidate motion vector 506 .
- a popularity value is determined for each compound candidate motion vector, each category 1 candidate motion vector, and each category 2 candidate motion vector.
- the candidate motion vectors are then ranked according to a priority value based on their popularity value, with candidate motion vectors that share the same compound reference frames having a higher priority than category 1 candidate motion vectors and category 1 candidate motion vectors having a higher priority than category 2 candidate motion vectors. The larger the number of previously coded pixel values associated with the candidate motion vector, the higher the popularity value of the candidate motion vector.
- a reference motion vector can be selected from the candidate motion vectors identified in step 506 , based on the candidate motion vector having the highest priority.
- the motion vector of the current block can be encoded using the reference motion vector in step 510 before processing begins again for the next block of the current frame.
- the current block can be encoded according to the process described with respect to FIG. 3 .
- FIG. 6 is a diagram of a frame 600 including a current block 602 used to explain the process of FIG. 5 .
- Frame 600 includes blocks that have been encoded before current block 602 , such as the shaded blocks 604 to the left of or above current block 602 in FIG. 6 .
- the candidate motion vectors may include the motion vector from a block 604 A above current block 602 , the motion vector from a block 604 B to the left of current block 602 and the motion vector from a block 604 C to the above-left of current block 602 . If any of blocks 604 A, 604 B or 604 C were not intra predicted, they would not have a motion vector to contribute to the candidate motion vectors.
- the candidate motion vectors can also include motion vectors from other frames as illustrated by FIGS. 10 and 11 .
- FIG. 10 is a diagram of a series 1000 of frames F 1 , F 2 . . . F k ⁇ 1 , F k of a first video stream in accordance with an implementation of this disclosure.
- Frame F k is the current frame to be encoded following encoding and reconstructing frames F 1 , F 2 . . . F k ⁇ 1 .
- Frame F k includes the current block referred to in FIG. 5 , for example.
- Frame F k ⁇ 1 is temporally adjacent to frame F k
- frames F 1 and F 2 are temporally non-adjacent to frame F k .
- a frame (e.g., a reference frame) is temporally non-adjacent to another frame when the frames are separated within a temporal sequence of the plurality of frames of the video stream by at least one frame.
- reconstructed frame F 2 may be stored as a golden reference frame as discussed above.
- Frame F k ⁇ 1 is the reconstructed frame stored in a “last” reference frame buffer available for coding blocks of current frame F k .
- frame F 1 was used as the “last” reference frame.
- a block that spatially corresponds to the current block in last frame F k ⁇ 1 may be used to obtain a motion vector for the candidate motion vectors in step 502 .
- a motion vector used for the prediction of the block in last frame F k ⁇ 1 at the same pixel location as the current block may be added to the candidate motion vectors.
- Motion vectors from other blocks in last frame F k ⁇ 1 such as those adjacent to the same pixel location as the current block, may also be used as candidate motion vectors in some cases.
- Pixel locations may be designated by X- and Y-coordinates with the top-left pixel designated as position (0,0) for example.
- frame F 2 is a golden frame available for inter prediction of blocks in current frame F k . Therefore, one or more of the adjacent blocks to the current block in frame F k may refer to frame F 2 such that its motion vector is included among the candidate motion vectors. Further, one or more motion vectors used for the prediction of the blocks in golden frame F 2 may also be added to the candidate motion vectors. For example, a dominant motion vector of the frame could be selected. In some cases, motion vectors of inter predicted blocks in golden frame F 2 within a specified spatial neighborhood of, for example, the same pixel position as the current block may be used as candidate motion vectors. Flags may be associated with frame F k (such as bits in its header) to indicate that a motion vector used in coding frame F 2 (e.g., against frame F 1 ) is available to some blocks in frame F k as a candidate motion vector.
- FIG. 11 is a diagram of a series 1100 of frames F 1 , A 1 , F 2 , . . . . F k ⁇ 1 , F k , . . . F k+m of a second video stream in accordance with an implementation of this disclosure.
- Series 1100 is similar to series 1000 but includes an alternate reference frame A 1 .
- Alternate reference frames may be purely constructed frames and, as such, may not have the same dimensions as the remaining frames in series 1100 .
- frame A 1 resembles a future video frame F k+m .
- motion vectors may be used against reference frame F 1 , for example.
- a motion vector from encoded and reconstructed frame A 1 can now be selected and identified to be used as a candidate motion vectors in encoding one or more blocks in frame F k .
- a motion vector to be included in the candidate motion vectors may be one associated with a spatially corresponding block of alternate reference frame A 1 or one associated with another nearby block. Further, any of the blocks adjacent to the current block in frame F k may refer to frame A 1 such that the corresponding motion vector is included among the candidate motion vectors.
- FIG. 7 is a diagram of the current block 602 of FIG. 6 and a set 702 of previously coded pixels.
- Set 702 can include, for example, two rows 702 A, 702 B of pixels immediately above current block 602 and two columns 702 C, 702 D of pixels to the immediate left of current block 602 .
- Rows 702 A, 702 B are associated with block 604 A
- columns 702 C, 702 D are associated with block 604 B.
- Blocks, such as current block 602 and previously coded blocks 604 A, 604 B, are shown in FIG. 7 to have a set of 8 ⁇ 8 pixels, which can be represented by an 8 ⁇ 8 matrix of pixel values.
- any other block size can be used.
- a block is formed by a matrix of 16 ⁇ 16 pixels, for example, a 16 ⁇ 2 region from the block above and a 2 ⁇ 16 region from the block to the left of the current block may be used.
- the number of pixels can be altered to include fewer or more pixels.
- a popularity value can be determined for each candidate motion vector based on how many previously coded pixels in the reference coverage area use that particular candidate motion vector. The more previously coded pixels that use a particular candidate motion vector, the higher the popularity value will be for that particular candidate motion vector.
- Step 506 can be implemented, for example, at intra/inter prediction stage 306 of encoder 300 in FIG. 3 , and one implementation is explained using FIG. 8 .
- FIG. 8 is a diagram of a set of predicted pixels for the set of previously coded pixels 702 of FIG. 7 .
- current block 602 of current frame 600 is being encoded.
- the set of predicted values is determined using a candidate motion vector (indicated generally by arrow 802 ) identified at step 502 .
- the set of previously coded pixels 702 include, for example, two rows 702 A, 702 B and two columns 702 C, 702 D described above with reference to FIG. 7 .
- rows 702 A, 702 B can be predicted by rows 804 A, 804 B in a reference frame 800 and columns 702 C, 702 D can be predicted by columns 804 C, 804 D in reference frame 800 .
- a set of predicted pixels represented by rows 804 A, 804 B and columns 804 C, 804 D in reference frame 800 is identified.
- block 806 is shown in the same spatial position in reference frame 800 as current block 602 is in current frame 600 to illustrate the pixels of rows 804 A, 804 B and columns 804 C, 804 D selected as the prediction pixels based on the candidate motion vector.
- the reference frame used for the identification of the prediction values in step 506 may be a temporally adjacent frame (such as last frame F k ⁇ 1 ) or a temporally non-adjacent frame (such as golden frame F 2 or alternate frame A 1 ).
- each available reference frame is used as part of a rate-distortion loop within an encoder that determines the best coding mode for the current block by comparing the rate (e.g., the bit cost) of each coding mode with the resulting image distortion (e.g., the change in image due to the coding) for each tested mode.
- step 506 also includes scaling candidate motion vectors where needed, which is described by reference again to FIGS. 10 and 11 .
- Scaling up or down a motion vector so that it may be applied as a candidate motion vector means adjusting its magnitude.
- the magnitude of the candidate can be scaled depending upon the results of comparing the temporal distance and direction between the reference frame and the frame including the current block and the temporal distance and direction used to form the candidate motion vector.
- the temporal distance between frames can be determined by their respective positions in the video stream.
- a candidate motion vector is a motion vector that was used to encode a block of frame F 2 against frame F 1
- the magnitude of the motion vector can be used directly for encoding frame F k against reference frame F k ⁇ 1 since frames F k and F k ⁇ 1 are, like frames F 1 and F 2 , a frame apart temporally (that is, they are adjacent frames in the frame sequence).
- a candidate motion vector from F k ⁇ 1 and previous coded blocks of F k when a block of F k was encoded using the golden frame, i.e., F 2 in this FIGS. 10 and 11 needs to be scaled to take into account the difference of temporal distance before being used to generate the prediction pixels in step 506 .
- a motion vector used in previously coding a block of current frame F k against F k ⁇ 1 will be scaled up using a factor proportional to k ⁇ 2 to become a candidate motion vector for generation of the prediction pixels when the current block, such as block 602 of FIG. 8 , is in evaluation to be coded against reference frame F 2 .
- Scaling up or down a motion vector so that it may be applied as a candidate motion vector means adjusting its magnitude.
- the magnitude of the candidate can be scaled depending upon the results of comparing the temporal distance and direction between the reference frame and the frame including the current block and the temporal distance and direction used to form the candidate motion vector.
- An alternate reference frame such as frame A 1 may be treated similarly to other references frames, such as the last or golden reference frame. However, since an alternate reference frame may be constructed using portions of multiple frames from multiple temporal positions in the video stream, techniques may be used to determine a temporal position in the video stream that most closely matches the image data included in the alternate frame.
- the motion vector magnitude may be divided by k+m ⁇ 1 before using the candidate motion vector to generate the prediction pixels. This is because the distance between frames F k and F k ⁇ 1 is less than the distance k+m ⁇ 1, therefore the motion vector has to scaled down to approximate the motion between frames F k and F k ⁇ 1 .
- the motion vectors can be multiplied by a scaling factor proportional to the ratio of the two temporal distances.
- a reference motion vector can be selected from the candidate motion vectors identified at step 506 .
- the selection can be based on, for example, selecting the motion vector from the candidate motion vectors associated with the highest popularity value and associated with the reference block closest to the current block.
- the selection can be based on, for example, the motion vector from reference blocks that share the same reference frame combination with higher priority.
- the candidate motion vectors in compound reference frames can be appended with the combinations of reference motion vectors of single reference frames. Other selection criteria can also be used.
- the reference motion vector can be used for further processing. Namely, the motion vector of the current block can be encoded using the reference motion vector in step 510 before processing begins again for the next block of the current frame.
- the current block can be encoded according to the process described with respect to FIG. 3 .
- process 500 may be part of a rate-distortion loop used to select the inter prediction mode for the current block to be encoded.
- the actual motion vector for inter prediction of the current block may be determined through a motion search according to any number of techniques.
- One use of the reference motion vector may include using the reference motion vector as a starting parameter for the motion search algorithm based on the reasoning that the actual motion vector is likely to be close to those used in selecting the reference motion vector.
- a motion search may alternatively be performed before or in parallel with process 500 .
- step 510 may include using the reference motion vector to differentially encode the actual motion vector. For example, a difference value can be calculated by subtracting the reference motion vector from the motion vector used to encode the current block. The difference value can be encoded and included in the video stream. Since the reference motion vector was formed using previously encoded and decoded data, the same data can be available at a decoder to identify the same reference motion vector as was used in forming the motion vector at the encoder, thus no motion vector is required to be encoded and transmitted for the current block. The decoded difference value can be added to the reference motion vector identified by the decoder as described below to form a motion vector to decode the current block.
- the reference motion vector is associated with one of the available reference frames. Therefore, in the event the reference motion vector is associated with a reference frame that is different from the reference frame associated with the actual motion vector, the reference motion vector may be scaled as described previously so as to generate the difference between the reference motion vector and the actual motion vector. In some implementations, a separate indication of the reference frame used would also be encoded into the bitstream.
- the reference motion vector may be used to choose a probability distribution to encode the magnitude of the motion vector used to encode the current block.
- bits can be included in the video stream to identify the encoded magnitude of the motion vector and which predetermined probability distribution to use to form the motion vector based on the encoded magnitude.
- One or more bits indicating which reference frame to use in decoding the current block may also be included in the bitstream in some variations.
- the reference motion vector may also be scaled to the extent it is desirable.
- the reference motion vector may also be used directly in the encoding of the current block. This can occur, for example, when a comparison of the rate-distortion value involved in coding the current block using the motion vector determined by the motion search is higher than that involved in coding the current block using the reference motion vector. In this comparison, the reference frame used would desirably be the one used in selecting the reference motion vector so no scaling is needed. In some cases, the decision as to whether or not to use the reference motion vector may be tied to the difference between the reference motion vector and the motion vector resulting from the search. When the difference is small (or zero), the difference in prediction results for the reference frame resulting from the search using the reference motion vector versus the actual motion vector is also small (or zero). When the reference motion vector is used directly to encode the current block, no motion vector would need to be separately encoded at step 510 . Instead, one or more bits would be inserted into the bitstream in association with the current block to indicate use of the reference motion vector for encoding.
- the use of a reference motion vector may reduce the number of bits needed to represent the motion vector needed to decode an inter coded block.
- the motion vector used for encoding the current frame would not be done separately.
- Using the most popular motion vector reduces the overall number of motion vectors, which in turn reduces the number of motion vectors that need to be encoded and placed in the bitstream.
- Bits may be inserted into frame, slice and/or block headers indicating whether reference motion vectors are used and how they are used for encoding the current block.
- the motion vector found by the motion search or the motion vector differential and/or the reference frame used in encoding the current block are also transmitted.
- a prediction block can be determined based on a reference frame by applying a candidate motion vector to the previously coded pixel values of the reference frame.
- the prediction block can be subtracted from the current block to form a residual that can be further encoded according to the processing described with respect to FIG. 3 and included in an encoded video bitstream.
- FIG. 9 is a flow diagram of a process 900 for decoding an encoded video stream using reference motion vectors in accordance with implementations of this disclosure.
- the decoder can reproduce the same candidate motion vectors that were constructed in process 500 , shown in FIG. 5 .
- the decoder can read the index of the bitstream to determine which reference motion vector to use from the candidate motion vectors.
- Process 900 can be implemented, for example, as a software program that may be executed by computing devices such as transmitting station 102 or receiving station 110 .
- the software program can include machine-readable instructions that may be stored in a memory such as memory 106 or 114 , and that, when executed by a processor, such as CPU 104 or 112 , may cause the computing device to perform process 900 .
- Process 900 can be implemented using specialized hardware or firmware. As explained above, some computing devices may have multiple memories or processors, and the steps of process 900 can be distributed using multiple processors, memories, or both.
- process 900 is depicted and described as a series of steps. However, steps in accordance with this disclosure can occur in various orders and/or concurrently. Additionally, steps in accordance with this disclosure may occur with other steps not presented and described herein. Furthermore, not all illustrated steps may be required to implement a method in accordance with the disclosed subject matter.
- process 900 substantially conforms to process 500 . There are some differences, however, that are pointed out in the following description of process 900 . Where steps are substantially similar to those in process 500 , reference will be made to the description above.
- the decoder determines whether the motion vector for the current block was encoded using a reference motion vector, the reference frame, and whether single or compound prediction was used.
- This information can be communicated by reading and decoding bits from an encoded video bitstream that indicate the use of a reference motion vector according to one of the techniques disclosed above.
- the encoded bitstream (or encoded video data) may have been received by decoder of a computing device in any number of ways, such as by receiving the video data over a network, over a cable, or by reading the video data from a primary memory or other storage device, including a disk drive or removable media such as a DVD, CompactFlash (CF) card, Secure Digital (SD) card, or any other device capable of communicating a video stream.
- CF CompactFlash
- SD Secure Digital
- Step 902 involves decoding at least a portion of the encoded video bitstream to extract the information regarding the motion vector for the current block.
- This information can be included in a header associated with a current block or a frame header, for example.
- the information in the one or more headers indicate to the decoder that the current block is to be decoded using inter prediction and that the motion vector used for that inter prediction relies on the reference motion vector as described previously.
- information in the bitstream could indicate that the actual motion vector used in encoding the current block was differentially encoded using the reference motion vector. Alternatively, information could indicate that the reference motion vector was used directly for encoding the current block.
- process 900 advances to step 904 to identify reference candidate motion vectors from the above and left neighbor blocks of the same reference frame.
- the identified candidate reference motion vectors should be the same as those identified by the encoder in step 502 , which may be accomplished by flags as described previously and/or by a priori rules regarding the selection of candidate motion vectors that are available to both the encoder and decoder based on the position of the current block.
- the candidate reference motion vectors are ranked based on the distance between the reference block and the current block and the popularity of each candidate reference motion vector.
- the distance between the reference block and the current block is determined for each candidate reference motion vector.
- the popularity for each candidate reference motion vector is determined by a popularity value based on a set of previously coded pixel values associated with the particular candidate reference motion vector.
- the most probable candidate reference motion vector is assigned as the predicted motion vector for NEW_MV mode.
- two effective motion vectors are assigned to the REF_MV mode, comprising NEAREST_MV mode and NEAR_MV mode, based on their relative distance to the current block and the overlapped length between the reference block and the current block and their popularity value. If the list of candidate reference motion vectors includes more than two candidate reference motion vectors, the number of reference motion vector modes is dynamically extended. Step 910 process 900 determines whether to use NEW_MV mode or REF_MV mode. When REF_MV mode is selected, process 900 further determines whether to use NEAREST_MV mode or NEAR_MV mode.
- the motion vector used to encode the current block can be decoded using the selected reference motion vector at step 912 .
- the decoded motion vector may then be used to decode the current block according to the process of FIG. 4 .
- the decoder can decode the motion vector by, for example, decoding an encoded difference value that can then be added to the reference motion vector selected at step 910 to generate the actual motion vector. Then, the actual motion vector may be used to decode the current block using inter prediction.
- the reference motion vector can be used to identify a predetermined probability distribution, which can be used to decode a magnitude value of the motion vector used to encode the current block before decoding the current block using the motion vector. Similar to the discussion in step 510 of FIG. 5 , this may involve scaling the reference motion vector.
- the reference motion vector may be used directly as the motion vector to decode the current block after decoding one or more bits indicating that the reference motion vector should be so used.
- next block may be processed.
- process 900 may be repeated.
- a frame can be reconstructed from the blocks derived from reconstructed values by intra or inter prediction, or both.
- the output can be an output video stream, such as the output video stream 416 shown in FIG. 4 .
- a reference motion vector may be selected so as to reduce the number of bits required to encode a motion vector determined by, for example, motion search techniques.
- the teachings herein take advantage of temporal motion continuity to reduce the number of bits required to transmit motion vector information by referring to motion vectors from adjacent and non-adjacent video frames.
- the decoder has all the information the encoder has to select the reference motion vector, allowing the selection of the reference motion vector without explicit transfer of further information.
- encoding and decoding illustrate some exemplary encoding and decoding techniques. However, it is to be understood that encoding and decoding, as those terms are used in the claims, could mean compression, decompression, transformation, or any other processing or change of data.
- example or “exemplary” are used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as “example” or “exemplary” is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather, use of the words “example” or “exemplary” is intended to present concepts in a concrete fashion.
- the term “or” is intended to mean an inclusive “or” rather than an exclusive “or”. That is, unless specified otherwise, or clear from context, “X includes A or B” is intended to mean any of the natural inclusive permutations.
- Implementations of transmitting station 102 and/or receiving station 110 can be realized in hardware, software, or any combination thereof.
- the hardware can include, for example, computers, intellectual property (IP) cores, application-specific integrated circuits (ASICs), programmable logic arrays, optical processors, programmable logic controllers, microcode, microcontrollers, servers, microprocessors, digital signal processors or any other suitable circuit.
- IP intellectual property
- ASICs application-specific integrated circuits
- programmable logic arrays optical processors
- programmable logic controllers programmable logic controllers
- microcode microcontrollers
- servers microprocessors, digital signal processors or any other suitable circuit.
- signal processors should be understood as encompassing any of the foregoing hardware, either singly or in combination.
- signals and “data” are used interchangeably. Further, portions of transmitting station 102 and receiving station 110 do not necessarily have to be implemented in the same manner.
- transmitting station 102 or receiving station 110 can be implemented using a general purpose computer or general purpose processor with a computer program that, when executed, carries out any of the respective methods, algorithms and/or instructions described herein.
- a special purpose computer/processor can be utilized which can contain other hardware for carrying out any of the methods, algorithms, or instructions described herein.
- Transmitting station 102 and receiving station 110 can, for example, be implemented on computers in a video conferencing system.
- transmitting station 102 can be implemented on a server and receiving station 110 can be implemented on a device separate from the server, such as a hand-held communications device.
- transmitting station 102 can encode content using an encoder 300 into an encoded video signal and transmit the encoded video signal to the communications device.
- the communications device can then decode the encoded video signal using a decoder 400 .
- the communications device can decode content stored locally on the communications device, for example, content that was not transmitted by transmitting station 102 .
- Other suitable transmitting station 102 and receiving station 110 implementation schemes are available.
- receiving station 110 can be a generally stationary personal computer rather than a portable communications device and/or a device including an encoder 300 may also include a decoder 400 .
- implementations of the present disclosure can take the form of a computer program product accessible from, for example, a tangible computer-usable or computer-readable medium.
- a computer-usable or computer-readable medium can be any device that can, for example, tangibly contain, store, communicate, or transport the program for use by or in connection with any processor.
- the medium can be, for example, an electronic, magnetic, optical, electromagnetic, or a semiconductor device. Other suitable mediums are also available.
Abstract
Description
- This application claims priority to U.S. Provisional Application No. 62/288,553, filed Jan. 29, 2016, which is incorporated herein in its entirety by reference.
- This disclosure relates to video encoding and decoding.
- Digital video streams may represent video using a sequence of frames or still images. Digital video can be used for various applications including, for example, video conferencing, high definition video entertainment, video advertisements, or sharing of user-generated videos. A digital video stream can contain a large amount of data and consume a significant amount of computing or communication resources of a computing device for processing, transmission or storage of the video data. Various approaches have been proposed to reduce the amount of data in video streams, including compression and other encoding techniques.
- This disclosure relates generally to encoding and decoding video data and more particularly relates to video coding using reference motion vectors. The teachings herein can reduce the number of bits required to encode motion vectors for inter prediction. One method for encoding a video stream having a plurality of blocks including a current block described herein includes identifying, for each previously coded block of a plurality of previously coded blocks of the video stream, a candidate motion vector used to inter predict the previously coded block to define a plurality of candidate motion vectors; determining, using a processor, for each candidate motion vector of the plurality of candidate motion vectors, a distance between the previously coded block associated with the candidate motion vector and a current block of a current frame; determining, using the processor, for each candidate motion vector of the plurality of candidate motion vectors, a popularity value based on a set of previously coded pixels associated with the candidate motion vector; ranking each candidate motion vector of the plurality of candidate motion vectors according to a priority value for each candidate motion vector, the priority value based on the distance and popularity value of the candidate motion vector; and selecting, based on the priority values, a reference motion vector from the plurality of candidate motion vectors; and encoding a motion vector for the current block using the reference motion vector.
- Another method described herein is a method for decoding an encoded video bitstream, including determining, from bits included in the encoded video bitstream, a reference frame on a condition that a motion vector for a current block to be decoded was encoded using a reference motion vector and whether the motion vector for the current block to be decoded was encoding using single prediction or compound prediction, the current block comprising one of a plurality of blocks of a current frame of the encoded video bitstream; identifying, for each previously decoded block of a plurality of previously decoded blocks, a candidate motion vector used to inter predict the previously decoded block to define a plurality of candidate motion vectors; determining, using a processor, for each candidate motion vector of the plurality of candidate motion vectors, a distance between the previously coded block associated with the candidate motion vector and the current block; determining, using the processor, for each candidate motion vector of the plurality of candidate motion vectors, a popularity value based on a set of previously coded pixels associated with the candidate motion vector; ranking each candidate motion vector of the plurality of candidate motion vectors according to a priority value for each candidate motion vector, the priority value based on the distance and the popularity value associated with the candidate motion vector; determining a predicted motion vector from the plurality of candidate motion vectors, the predicted motion vector associated with the candidate motion vector having the highest popularity value; determining a first effective motion vector and a second effective motion vector, the first effective motion vector and the second effective motion vector associated with the candidate motion vectors having the shortest distance; selecting the reference motion vector from the predicted motion vector, the first effective motion vector, and the second effective motion vector; and decoding a motion vector for the current block using the reference motion vector.
- An example of an apparatus for encoding a video stream described herein includes a memory and a processor. The processor is configured to execute instructions stored in the memory to identify, for each previously coded block of a plurality of previously coded blocks, a candidate motion vector used to inter predict the previously coded block to define a plurality of candidate motion vectors; determine, for each candidate motion vector of the plurality of candidate motion vectors, a distance between the previously coded block associated with the candidate motion vector and a current block of a current frame; determine, for each candidate motion vector of the plurality of candidate motion vectors, a popularity value based on a set of previously coded pixels associated with the candidate motion vector; rank each candidate motion vector of the plurality of candidate motion vectors according to a priority value for each candidate motion vector, the priority value based on the distance and popularity value associated with the candidate motion vector; select, based on the priority values, a reference motion vector from the plurality of candidate motion vectors; and encode a motion vector for the current block using the reference motion vector.
- Variations in these and other aspects of the disclosure will be described in additional detail hereafter.
- The description herein makes reference to the accompanying drawings wherein like reference numerals refer to like parts throughout the several views, and wherein:
-
FIG. 1 is a schematic of a video encoding and decoding system in accordance with implementations of this disclosure; -
FIG. 2 is a diagram of an example video stream to be encoded and decoded in accordance with implementations of this disclosure; -
FIG. 3 is a block diagram of a video compression system in accordance with implementations of this disclosure; -
FIG. 4 is a block diagram of a video decompression system in accordance with implementations of this disclosure; -
FIG. 5 is a flow diagram of a process for encoding a video stream using reference motion vectors in accordance with an implementation of this disclosure; -
FIG. 6 is a diagram of a frame including a current block used to explain the process ofFIG. 5 ; -
FIG. 7 is a diagram of the current block ofFIG. 6 and a set of previously coded pixel; -
FIG. 8 is a diagram of a set of predicted pixels for the set of previously coded pixels ofFIG. 7 ; -
FIG. 9 is a flow diagram of a process for decoding an encoded video stream using reference motion vectors in accordance with implementations of this disclosure; -
FIG. 10 is a diagram of a series of frames of a first video stream in accordance with an implementation of this disclosure; and -
FIG. 11 is a diagram of a series of frames of a second video stream in accordance with an implementation of this disclosure. - Compression schemes related to coding video streams may include breaking each image into blocks and generating a digital video output bitstream using one or more techniques to limit the information included in the output. A received bitstream can be decoded to re-create the blocks and the source images from the limited information. Encoding a video stream, or a portion thereof, such as a frame or a block, can include using temporal and spatial similarities in the video stream to improve coding efficiency. For example, a current block of a video stream may be encoded based on a previously encoded block in the video stream by predicting motion and color information for the current block based on the previously encoded block and identifying a difference (residual) between the predicted values and the current block. In this way, only the residual and parameters used to generate it need be added to the bitstream instead of including the entirety of the current block. This technique may be referred to as inter prediction.
- One of the parameters in inter prediction is a motion vector that represents the spatial displacement of the previously coded block relative to the current block. The motion vector can be identified using a method of motion estimation, such as a motion search. In motion search, a portion of a reference frame can be translated to a succession of locations to form a prediction block that can be subtracted from a portion of a current frame to form a series of residuals. The X and Y translations corresponding to the location having the smallest residual can be selected as the motion vector. Bits representing the motion vector can be included in the encoded bitstream to permit a decoder to reproduce the prediction block and decode the portion of the encoded video bitstream associated with the motion vector.
- For video compression schemes, the number of bits used to encode the motion vectors can be significant, especially for video streams encoded at lower data rates or higher compression ratios. To improve the encoding efficiency, a motion vector can be differentially encoded using a reference motion vector, i.e., only the difference between the motion vector and the reference motion vector is encoded. In some instances, the reference motion vector can be selected from previously used motion vectors in the video stream, for example, the last non-zero motion vector from neighboring blocks. Selecting a previously used motion vector to encode a current motion vector can further reduce the number of bits included in the encoded video bitstream and thereby reduce transmission and storage bandwidth requirements. Motion vector referencing modes allow a coding block to infer motion information from previously coded neighboring blocks.
- In implementations of this disclosure, a reference motion vector can be selected from candidate motion vectors based on the distance between the reference block and the current block and the popularity of the reference motion vector. For example, the distance between the reference block and the current block can be based on the spacial displacement between the pixels in the previously coded block and the collocated pixels in the current block, measured in the unit of pixels. For example, the popularity of the motion vector can be based on the amount of previously coded pixels that use the motion vector. The more previously coded pixels that use the motion vector, the higher the probability of the motion vector. In one example, the popularity value is the number of previously coded pixels that use the motion vector. In another example, the popularity value is a percentage of previously coded pixels within an area that use the motion vector.
- Due to the proximity of the current block to the pixels in the reference block, it is likely in many cases that the current block has similar motion characteristics to those pixels. Thus, a candidate motion vector used in a reference block near the current block may closely resemble the actual motion vector for the current block. Additionally, a candidate motion vector that is used by the most amount of pixels in a reference block near the current block would further resemble the actual motion vector for the current block. For this reason, the motion vector of the candidate motion vectors with the highest popularity used in a nearby reference block may be selected as the reference motion vector for the actual motion vector of the current block. Fewer bits can be used to code the actual motion vector by coding the small difference in motion vectors, thus improving the overall coding efficiency. Other ways in which the selected motion vector may be used are discussed hereinafter.
- The candidate motion vectors may be limited to spatial-temporal neighboring motion vectors. That is, the pool of candidate motion vectors may be selected from regions neighboring regions of the current block. In some video coding schemes, particularly those where video frames are encoded out of order, it is desirable to include in the pool of candidate motion vectors motion information from video frames in the distant past or future. Encoding video frames can out of order may occur, for example, in the coding of so-called “alternate reference frames” that are not temporally neighboring to the frames coded immediately before or after them. An alternate reference frame may be a synthesized frame that does not occur in the input video stream or is a duplicate frame to one in the input video stream that is used for prediction and is generally not displayed following decoding. Such a frame can resemble a video frame in the non-adjacent future. Another example in which out of order encoding may occur is through the use of a so-called “golden reference frame,” which is a reconstructed video frame that may or may not be neighboring to a current video frame and is stored in memory for use as a reference frame until replaced, e.g., by a new golden reference frame.
- Herein, alternate reference frames and golden reference frames (also called alternate frames and golden frames), in addition to adjacent video frames are used to infer motion vectors for a block of a frame of video data using pixels from the non-adjacent or adjacent video frames to predict reconstructed pixels spatially near the block to be predicted. Other details are described herein after first describing an environment in which the disclosure may be implemented.
-
FIG. 1 is a schematic of a video encoding anddecoding system 100 in which aspects of the disclosure can be implemented. An exemplary transmitting station 102 can be, for example, a computer having an internal configuration of hardware including a processor such as a central processing unit (CPU) 104 and a memory 106. CPU 104 is a controller for controlling the operations of transmitting station 102. CPU 104 can be connected to the memory 106 by, for example, a memory bus. Memory 106 can be read only memory (ROM), random access memory (RAM) or any other suitable memory device. Memory 106 can store data and program instructions that are used by CPU 104. Other suitable implementations of transmitting station 102 are possible. For example, the processing of transmitting station 102 can be distributed among multiple devices. - A network 108 connects transmitting station 102 and a receiving station 110 for encoding and decoding of the video stream. Specifically, the video stream can be encoded in transmitting station 102 and the encoded video stream can be decoded in receiving station 110. Network 108 can be, for example, the Internet. Network 108 can also be a local area network (LAN), wide area network (WAN), virtual private network (VPN), a cellular telephone network or any other means of transferring the video stream from transmitting station 102 to, in this example, receiving station 110.
- Receiving station 110 can, in one example, be a computer having an internal configuration of hardware including a processor such as a CPU 112 and a memory 114. CPU 112 is a controller for controlling the operations of receiving station 110. CPU 112 can be connected to memory 114 by, for example, a memory bus. Memory 114 can be ROM, RAM or any other suitable memory device. Memory 114 can store data and program instructions that are used by CPU 112. Other suitable implementations of receiving station 110 are possible. For example, the processing of receiving station 110 can be distributed among multiple devices.
- A display 116 configured to display a video stream can be connected to receiving station 110. Display 116 can be implemented in various ways, including by a liquid crystal display (LCD), a cathode-ray tube (CRT), or a light emitting diode display (LED), such as an OLED display. Display 116 is coupled to CPU 112 and can be configured to display a rendering 118 of the video stream decoded in receiving station 110.
- Other implementations of the encoder and
decoder system 100 are also possible. For example, one implementation can omit network 108 and/or display 116. In another implementation, a video stream can be encoded and then stored for transmission at a later time by receiving station 110 or any other device having memory. In one implementation, receiving station 110 receives (e.g., via network 108, a computer bus, or some communication pathway) the encoded video stream and stores the video stream for later decoding. In another implementation, additional components can be added to the encoder anddecoder system 100. For example, a display or a video camera can be attached to transmitting station 102 to capture the video stream to be encoded. -
FIG. 2 is a diagram of an example video stream 200 to be encoded and decoded. Video stream 200 (also referred to herein as video data) includes avideo sequence 204. At the next level,video sequence 204 includes a number ofadjacent frames 206. While three frames are depicted inadjacent frames 206,video sequence 204 can include any number of adjacent frames.Adjacent frames 206 can then be further subdivided into individual frames, e.g., asingle frame 208. Eachframe 208 can capture a scene with one or more objects, such as people, background elements, graphics, text, a blank wall, or any other information. - At the next level,
single frame 208 can be divided into a set of blocks 210, which can contain data corresponding to, in some of the examples described below, a 8×8 pixel group inframe 208. Block 210 can also be of any other suitable size such as a block of 16×8 pixels, a block of 8×8 pixels, a block of 16×16 pixels, a block of 4×4 pixels, or of any other size. Unless otherwise noted, the term ‘block’ can include a macroblock, a subblock (i.e., a subdivision of a macroblock), a segment, a slice, a residual block or any other portion of a frame. A frame, a block, a pixel, or a combination thereof can include display information, such as luminance information, chrominance information, or any other information that can be used to store, modify, communicate, or display the video stream or a portion thereof. -
FIG. 3 is a block diagram of anencoder 300 in accordance with implementations of this disclosure.Encoder 300 can be implemented, as described above, in transmitting station 102 such as by providing a computer software program stored in memory 106, for example. The computer software program can include machine instructions that, when executed by CPU 104, cause transmitting station 102 to encode video data in the manner described inFIG. 3 .Encoder 300 can also be implemented as specialized hardware in, for example, transmitting station 102.Encoder 300 has the following stages to perform the various functions in a forward path (shown by the solid connection lines) to produce an encoded or a compressed bitstream 320 using input video stream 200: an intra/inter prediction stage 304, a transform stage 306, aquantization stage 308, and anentropy encoding stage 310.Encoder 300 may include a reconstruction path (shown by the dotted connection lines) to reconstruct a frame for encoding of future blocks. InFIG. 3 ,encoder 300 has the following stages to perform the various functions in the reconstruction path: adequantization stage 312, aninverse transform stage 314, areconstruction stage 316, and aloop filtering stage 318. Other structural variations ofencoder 300 can be used to encode video stream 200. - When video stream 200 is presented for encoding, each
frame 208 within video stream 200 can be processed in units of blocks. Referring toFIG. 3 , at intra/inter prediction stage 304, each block can be encoded using either intra prediction (i.e., within a single frame) or inter prediction (i.e. from frame to frame). In either case, a prediction block can be formed. The prediction block is then subtracted from the block to produce a residual block (also referred to herein as residual). - Intra prediction (also referred to herein as intra-prediction or intra-frame prediction) and inter prediction (also referred to herein as inter-prediction or inter-frame prediction) are techniques used in modern image/video compression schemes. In the case of intra-prediction, a prediction block can be formed from samples in the current frame that have been previously encoded and reconstructed. In the case of inter-prediction, a prediction block can be formed from samples in one or more previously constructed reference frames, such as the last frame (i.e., the adjacent frame immediately before the current frame), the golden frame or the constructed or alternate frame described above.
- The prediction block is then subtracted from the current block. The difference, or residual, is then encoded and transmitted to decoders. Image or video codecs may support many different intra and inter prediction modes; each block may use one of the prediction modes to obtain a prediction block that is most similar to the block to minimize the information to be encoded in the residual so as to re-create the block. The prediction mode for each block of transform coefficients can also be encoded and transmitted so a decoder can use the same prediction mode(s) to form prediction blocks in the decoding and reconstruction process.
- The prediction mode may be selected from one of multiple intra-prediction modes. Alternatively, the prediction mode may be selected from one of multiple inter-prediction modes using one or more reference frames including, for example, last frame, golden frame, alternative reference frame, or any other reference frame in an encoding scheme. The bitstream syntax supports three categories of inter prediction modes. The inter prediction modes can include, for example, a mode (sometimes called ZERO_MV mode) in which a block from the same location within a reference frame as the current block is used as the prediction block; a mode (sometimes called a NEW_MV mode) in which a motion vector is transmitted to indicate the location of a block within a reference frame to be used as the prediction block relative to the current block; or a mode (sometimes called a REF_MV mode comprising NEAR_MV or NEAREST_MV mode) in which no motion vector is transmitted and the current block uses the last or second-to-last non-zero motion vector used by neighboring, previously coded blocks to generate the prediction block. Inter-prediction modes may be used with any of the available reference frames.
- The reference motion vector coding modes analyze the available blocks motion activity to produce a ranked reference motion vector candidate list, allowing the size of the reference motion vector modes to be dynamically extended, a generalization of the fixed NEAREST_MV mode and NEAR_MV mode, and improving the efficacy of entropy coding. REF_MV mode represents reference motion vector modes, including NEAR_MV and NEAREST_MV modes, as well as extended modes when the candidate motion vector list shows sufficient variation. The entropy coding system starts with NEW_MV mode, selecting the probability model according to the contexts of the number of reference motion vectors found and, if a neighboring block with matched reference frame is found, determining the likelihood that the neighboring block is coded in NEW_MV mode. If the coding mode is not NEW_MV mode, the codec continues to code if the mode is ZERO_MV mode. The codec selects the mode probability model according to the contexts when the collocated block in the previous frame is using a zero motion vector, or close to zero motion vector (i.e., less than 1 full pixel in both row and column components), or when the spatial neighboring blocks are using zero, or close to zero, motion vectors. If the coding mode is not ZERO_MV mode, the codec decides between the REF_MV modes. The associated context is how many reference motion vectors checked into the candidate list and the weighing coefficients. The REF_MV mode syntax suggests that the effective motion vector comes from referring neighboring blocks coding information. Given the reference frame, a list of such possible reference motion vector candidates includes reference motion vector candidates that are ranked according to their relative distance to the current block and the overlapped amount. The codec needs to decode which one in the list to pick and use. The codec can select the candidate motion vector among the candidate motion vectors in the list that would provide the best prediction and send the index associated with that particular candidate motion vector to the decoder.
- Next, still referring to
FIG. 3 , transform stage 306 transforms the residual into a block of transform coefficients in, for example, the frequency domain. Examples of block-based transforms include the Karhunen-Loève Transform (KLT), the Discrete Cosine Transform (DCT), Walsh-Hadamard Transform (WHT), the Singular Value Decomposition Transform (SVD) and the Asymmetric Discrete Sine Transform (ADST). In one example, the DCT transforms the block into the frequency domain. In the case of DCT, the transform coefficient values are based on spatial frequency, with the lowest frequency (e.g., DC) coefficient at the top-left of the matrix and the highest frequency coefficient at the bottom-right of the matrix. -
Quantization stage 308 converts the block of transform coefficients into discrete quantum values, which are referred to as quantized transform coefficients, using a quantizer value or quantization level. The quantized transform coefficients are then entropy encoded byentropy encoding stage 310. The entropy-encoded coefficients, together with other information used to decode the block, which can include for example the type of prediction used, motion vectors and quantization value, are then output to compressed bitstream 320. Compressed bitstream 320 can be formatted using various techniques, such as variable length encoding (VLC) and arithmetic coding. Compressed bitstream 320 can also be referred to as an encoded video stream and the terms will be used interchangeably herein. - The reconstruction path in
FIG. 3 (shown by the dotted connection lines) can be used to provide bothencoder 300 and a decoder 400 (described below) with the same reference frames to decode compressed bitstream 320. The reconstruction path performs functions that are similar to functions that take place during the decoding process that are discussed in more detail below, including dequantizing the quantized transform coefficients atdequantization stage 312 to generate dequantized transform coefficients and inverse transforming the dequantized transform coefficients atinverse transform stage 314 to produce a derivative residual block (i.e., derivative residual). Atreconstruction stage 316, the prediction block that was predicted at intra/inter prediction stage 304 can be added to the derivative residual to create a reconstructed block. In some implementations,loop filtering stage 318 can be applied to the reconstructed block to reduce distortion such as blocking artifacts. - Other variations of
encoder 300 can be used. For example, a non-transform basedencoder 300 can quantize the residual block directly without transform stage 304. In another implementation, anencoder 300 can havequantization stage 308 anddequantization stage 312 combined into a single stage. -
FIG. 4 is a block diagram of a decoder 400 in accordance with implementations of this disclosure. Decoder 400 can be implemented, for example, in receiving station 110, such as by providing a computer software program stored in memory for example. The computer software program can include machine instructions that, when executed by CPU 112, cause receiving station 110 to decode video data in the manner described inFIG. 4 . Decoder 400 can also be implemented as specialized hardware or firmware in, for example, transmitting station 102 or receiving station 110. Decoder 400, similar to the reconstruction path ofencoder 300 discussed above, includes in one example the following stages to perform various functions to produce an output video stream 416 from compressed bitstream 320: anentropy decoding stage 402, a dequantization stage 404, aninverse transform stage 406, an intra/inter prediction stage 408, a reconstruction stage 410, a loop filtering stage 412, and a deblocking filtering stage 414. Other structural variations of decoder 400 can be used to decode compressed bitstream 320. - When compressed bitstream 320 is presented for decoding, the data elements within compressed bitstream 320 can be decoded by the entropy decoding stage 402 (using, for example, arithmetic coding) to produce a set of quantized transform coefficients. Dequantization stage 404 dequantizes the quantized transform coefficients and
inverse transform stage 406 inverse transforms the dequantized transform coefficients to produce a derivative residual that can be identical to that created byreconstruction stage 316 inencoder 300. Using header information decoded from compressed bitstream 320, decoder 400 can use intra/inter prediction stage 408 to create the same prediction block as was created inencoder 300, e.g., at intra/inter prediction stage 304. In the case of inter prediction, the reference frame from which the prediction block is generated may be transmitted in the bitstream or constructed by the decoder using information contained within the bitstream. - At reconstruction stage 410, the prediction block can be added to the derivative residual to create a reconstructed block that can be identical to the block created by
reconstruction stage 316 inencoder 300. In some implementations, loop filtering stage 412 can be applied to the reconstructed block to reduce blocking artifacts. Deblocking filtering stage 414 can be applied to the reconstructed block to reduce blocking distortion, and the result is output as output video stream 416. Output video stream 416 can also be referred to as a decoded video stream and the terms will be used interchangeably herein. - Other variations of decoder 400 can be used to decode compressed bitstream 320. For example, decoder 400 can produce output video stream 416 without deblocking filtering stage 414.
-
FIG. 5 is a flow diagram showing aprocess 500 for encoding a video stream using reference motion vectors in accordance with an implementation of this disclosure.Process 500 can be implemented in an encoder such as encoder 300 (shown inFIG. 3 ) and can be implemented, for example, as a software program that can be executed by computing devices such as transmitting station 102 or receiving station 110 (shown inFIG. 1 ). For example, the software program can include machine-readable instructions that can be stored in a memory such as memory 106 or memory 114, and that can be executed by a processor, such as CPU 104, to cause the computing device to performprocess 500. -
Process 500 can be implemented using specialized hardware or firmware. Some computing devices can have multiple memories, multiple processors, or both. The steps ofprocess 500 can be distributed using different processors, memories, or both. Use of the terms “processor” or “memory” in the singular encompasses computing devices that have one processor or one memory as well as devices that have multiple processors or multiple memories that can each be used in the performance of some or all of the recited steps. For simplicity of explanation,process 500 is depicted and described as a series of steps. However, steps in accordance with this disclosure can occur in various orders and/or concurrently. Additionally, steps in accordance with this disclosure may occur with other steps not presented and described herein. Furthermore, not all illustrated steps may be required to implement a method in accordance with the disclosed subject matter. -
Process 500 assumes that a stream of video data having multiple frames, each having multiple blocks, is being encoded using a video encoder such asvideo encoder 300 executing on a computing device such as transmitting station 102. The video data or stream can be received by the computing device in any number of ways, such as by receiving the video data over a network, over a cable, or by reading the video data from a primary memory or other storage device, including a disk drive or removable media such as a CompactFlash (CF) card, Secure Digital (SD) card, or any other device capable of communicating video data. In some implementations, video data can be received from a video camera connected to the computing device operating the encoder. At least some of the blocks within frames are encoded using inter prediction as described in more detail below. - At step 502,
process 500 identifies candidate motion vectors from previously coded blocks in the video stream.Process 500 analyzes the motion activity of previously coded blocks to produce a list of ranked candidate motion vectors, employing an efficient reference motion vector ranking system, and provides a dynamic motion referencing mode that fully accounts for the available motion vector candidate list, which allows the number of the reference motion vector modes to be dynamically extended or shortened and improves the efficacy of entropy coding. The pool of the candidate motion vectors can be dynamically extended or shortened according to the neighboring reference block condition, i.e., how the list of candidate motion vectors is created. The previously coded blocks in the video stream can include any block encoded using inter-prediction before the current block, such as a block from a previously coded frame or a block from the same frame as the current block that has been encoded before the current block. For example, in some encoding/decoding (codec) schemes such as ones that code in raster scan order, the previously coded blocks can include a block above, to the left, or to the above-left of the current block in the same frame. The previously coded blocks can also include, for example, a block from the immediately previous frame (i.e., last frame), a block from the golden frame (described at intra/inter prediction stage 304), a block from any other reference frame, or any combination thereof. Desirably, however, the candidate motion vectors are obtained from previously coded blocks that correspond in some way to the current block based on the theory that such blocks, due to the proximity of their pixels to the current block, are likely to have similar motion characteristics to the current block. - Blocks may be predicted from a single reference frame or compound, such as two, reference frames. For blocks with a single reference frame,
process 500 identifies candidate motion vectors from the nearest spatial neighboring blocks that are associated with the reference frame. The candidate motion vectors may include the motion vector reference blocks within a reference coverage area, such as the motion vector from a block above the current block, the motion vector from a block to the left of the current block, the motion vector from a block to the above-right of the current block, and the motion vector of a collocated block in the previous frame. -
Process 500 determines, for each candidate motion vector, a distance between the previously coded block associated with the candidate motion vector and thecurrent block 504. The candidate motion vectors are ranked based on the distance, from nearest to furthest, from the previously coded block and the overlapped length between the previously coded block and the current block. The nearest candidate motion vector from the block above the current block, the nearest candidate motion vector from a block to the left of the current block, and the nearest candidate motion vector from the above-right of the current block are considered to be category 1 candidate motion vectors. Due to the proximity of the previously coded block to the current block, it is possible that the current block has similar motion characteristics as the previously coded block. The remaining candidate motion vectors are considered to be category 2 candidate motion vectors. Category 1 candidate motion vectors always assume a higher priority than category 2 candidate motion vectors. -
Process 500 determines, for each candidate motion vector within category 1 and category 2, a popularity value based on a set of previously coded pixel values associated with the particularcandidate motion vector 504. Within each category, the candidate motion vectors are ranked according to their popularity value, with category 1 candidate motion vectors always ranking higher than category 2 candidate motion vectors. The larger the number of previously coded pixel values associated with the candidate motion vector, the higher the popularity value of the candidate motion vector. Atstep 508, a reference motion vector can be selected from the candidate motion vectors identified instep 504, based on the candidate motion vector nearest the current block and having the highest popularity value. The motion vector of the current block can be encoded using the reference motion vector in step 510 before processing begins again for the next block of the current frame. In addition, the current block can be encoded according to the process described with respect toFIG. 3 . - Blocks can be predicted from two reference frames, where the prediction will be the average of the two frames. In some cases, the average can be a weighted average. For blocks with compound reference frames,
process 500 finds the reference blocks that share the most reference frames with the current block.Process 500 identifies and assigns a higher priority to candidate motion vectors from neighboring reference blocks that share the same reference frame combination. When there are less than two identified candidate motion vectors,process 500 identifies additional combinations of candidate motion vectors from blocks with single reference frames, as described above. -
Process 500 determines, for each candidate motion vector, a distance between the previously coded block associated with the candidate motion vector and thecurrent block 504. For example, the distance between the previously coded block associated with the candidate motion vector and the current block can be based on the spacial displacement between the pixels in the previously coded block and the collocated pixels in the current block, measured in the unit of pixels. The candidate motion vectors are ranked based on the distance, from nearest to furthest, from the previously coded block to the current block and the overlapped length between the previously coded block and the current block. The nearest candidate motion vector from the block above the current block, the nearest candidate motion vector from a block to the left of the current block, and the nearest candidate motion vector from the above-right of the current block are considered to be category 1 candidate motion vectors. The remaining candidate motion vectors are considered to be category 2 candidate motion vectors. -
Process 500 determines, for each candidate motion vector identified in step 502, a popularity value based on a set of previously coded pixel values associated with the candidate motion vector 506. A popularity value is determined for each compound candidate motion vector, each category 1 candidate motion vector, and each category 2 candidate motion vector. The candidate motion vectors are then ranked according to a priority value based on their popularity value, with candidate motion vectors that share the same compound reference frames having a higher priority than category 1 candidate motion vectors and category 1 candidate motion vectors having a higher priority than category 2 candidate motion vectors. The larger the number of previously coded pixel values associated with the candidate motion vector, the higher the popularity value of the candidate motion vector. Atstep 508, a reference motion vector can be selected from the candidate motion vectors identified in step 506, based on the candidate motion vector having the highest priority. The motion vector of the current block can be encoded using the reference motion vector in step 510 before processing begins again for the next block of the current frame. In addition, the current block can be encoded according to the process described with respect toFIG. 3 . Using the most popular candidate motion vector, i.e., the candidate motion vector used by the most pixels in the reference coverage area comprising neighboring blocks, reduces the overall number of motion vectors that need to be encoded, improving the prediction accuracy of reference motion vectors and providing a further level of optimization and bandwidth efficiency. -
FIG. 6 is a diagram of aframe 600 including acurrent block 602 used to explain the process ofFIG. 5 .Frame 600 includes blocks that have been encoded beforecurrent block 602, such as the shaded blocks 604 to the left of or abovecurrent block 602 inFIG. 6 . In this example where encoding is performed in raster scan order, the candidate motion vectors may include the motion vector from a block 604A abovecurrent block 602, the motion vector from a block 604B to the left ofcurrent block 602 and the motion vector from a block 604C to the above-left ofcurrent block 602. If any of blocks 604A, 604B or 604C were not intra predicted, they would not have a motion vector to contribute to the candidate motion vectors. The candidate motion vectors can also include motion vectors from other frames as illustrated byFIGS. 10 and 11 . -
FIG. 10 is a diagram of aseries 1000 of frames F1, F2 . . . Fk−1, Fk of a first video stream in accordance with an implementation of this disclosure. Frame Fk is the current frame to be encoded following encoding and reconstructing frames F1, F2 . . . Fk−1. Frame Fk includes the current block referred to inFIG. 5 , for example. Frame Fk−1 is temporally adjacent to frame Fk, while frames F1 and F2 are temporally non-adjacent to frame Fk. A frame (e.g., a reference frame) is temporally non-adjacent to another frame when the frames are separated within a temporal sequence of the plurality of frames of the video stream by at least one frame. Among these video frames, reconstructed frame F2 may be stored as a golden reference frame as discussed above. Frame Fk−1 is the reconstructed frame stored in a “last” reference frame buffer available for coding blocks of current frame Fk. When encoding frame F2, frame F1 was used as the “last” reference frame. A block that spatially corresponds to the current block in last frame Fk−1 may be used to obtain a motion vector for the candidate motion vectors in step 502. That is, a motion vector used for the prediction of the block in last frame Fk−1 at the same pixel location as the current block may be added to the candidate motion vectors. Motion vectors from other blocks in last frame Fk−1, such as those adjacent to the same pixel location as the current block, may also be used as candidate motion vectors in some cases. Pixel locations may be designated by X- and Y-coordinates with the top-left pixel designated as position (0,0) for example. - In the example of
FIG. 10 , frame F2 is a golden frame available for inter prediction of blocks in current frame Fk. Therefore, one or more of the adjacent blocks to the current block in frame Fk may refer to frame F2 such that its motion vector is included among the candidate motion vectors. Further, one or more motion vectors used for the prediction of the blocks in golden frame F2 may also be added to the candidate motion vectors. For example, a dominant motion vector of the frame could be selected. In some cases, motion vectors of inter predicted blocks in golden frame F2 within a specified spatial neighborhood of, for example, the same pixel position as the current block may be used as candidate motion vectors. Flags may be associated with frame Fk (such as bits in its header) to indicate that a motion vector used in coding frame F2 (e.g., against frame F1) is available to some blocks in frame Fk as a candidate motion vector. -
FIG. 11 is a diagram of aseries 1100 of frames F1, A1, F2, . . . . Fk−1, Fk, . . . Fk+m of a second video stream in accordance with an implementation of this disclosure.Series 1100 is similar toseries 1000 but includes an alternate reference frame A1. Alternate reference frames may be purely constructed frames and, as such, may not have the same dimensions as the remaining frames inseries 1100. For simplicity in this explanation, it is assumed that frame A1 resembles a future video frame Fk+m. When encoding frame A1, motion vectors may be used against reference frame F1, for example. When it is time to encode frame Fk, a motion vector from encoded and reconstructed frame A1 can now be selected and identified to be used as a candidate motion vectors in encoding one or more blocks in frame Fk. As discussed in the example given above with respect to golden frame F2, a motion vector to be included in the candidate motion vectors may be one associated with a spatially corresponding block of alternate reference frame A1 or one associated with another nearby block. Further, any of the blocks adjacent to the current block in frame Fk may refer to frame A1 such that the corresponding motion vector is included among the candidate motion vectors. -
FIG. 7 is a diagram of thecurrent block 602 ofFIG. 6 and aset 702 of previously coded pixels. Set 702 can include, for example, tworows 702A, 702B of pixels immediately abovecurrent block 602 and twocolumns 702C, 702D of pixels to the immediate left ofcurrent block 602. However, other previously coded pixels (not shown inFIG. 7 ) can also be used.Rows 702A, 702B are associated with block 604A, whilecolumns 702C, 702D are associated with block 604B. Blocks, such ascurrent block 602 and previously coded blocks 604A, 604B, are shown inFIG. 7 to have a set of 8×8 pixels, which can be represented by an 8×8 matrix of pixel values. However, any other block size can be used. When a block is formed by a matrix of 16×16 pixels, for example, a 16×2 region from the block above and a 2×16 region from the block to the left of the current block may be used. The number of pixels can be altered to include fewer or more pixels. - A popularity value can be determined for each candidate motion vector based on how many previously coded pixels in the reference coverage area use that particular candidate motion vector. The more previously coded pixels that use a particular candidate motion vector, the higher the popularity value will be for that particular candidate motion vector. Step 506 can be implemented, for example, at intra/inter prediction stage 306 of
encoder 300 inFIG. 3 , and one implementation is explained usingFIG. 8 . -
FIG. 8 is a diagram of a set of predicted pixels for the set of previously codedpixels 702 ofFIG. 7 . InFIG. 8 ,current block 602 ofcurrent frame 600 is being encoded. The set of predicted values is determined using a candidate motion vector (indicated generally by arrow 802) identified at step 502. The set of previously codedpixels 702 include, for example, tworows 702A, 702B and twocolumns 702C, 702D described above with reference toFIG. 7 . To form the set of predicted values usingcandidate motion vector 802,rows 702A, 702B can be predicted byrows 804A, 804B in areference frame 800 andcolumns 702C, 702D can be predicted bycolumns 804C, 804D inreference frame 800. That is, using the X- and Y-offsets provided bycandidate motion vector 802, a set of predicted pixels represented byrows 804A, 804B andcolumns 804C, 804D inreference frame 800 is identified. InFIG. 8 , block 806 is shown in the same spatial position inreference frame 800 ascurrent block 602 is incurrent frame 600 to illustrate the pixels ofrows 804A, 804B andcolumns 804C, 804D selected as the prediction pixels based on the candidate motion vector. - The reference frame used for the identification of the prediction values in step 506 may be a temporally adjacent frame (such as last frame Fk−1) or a temporally non-adjacent frame (such as golden frame F2 or alternate frame A1). Desirably, each available reference frame is used as part of a rate-distortion loop within an encoder that determines the best coding mode for the current block by comparing the rate (e.g., the bit cost) of each coding mode with the resulting image distortion (e.g., the change in image due to the coding) for each tested mode. However, since the candidate motion vectors may be generated using frames separated by different temporal distances than the current frame and the particular reference frame under consideration. Accordingly, step 506 also includes scaling candidate motion vectors where needed, which is described by reference again to
FIGS. 10 and 11 . - Scaling up or down a motion vector so that it may be applied as a candidate motion vector means adjusting its magnitude. The magnitude of the candidate can be scaled depending upon the results of comparing the temporal distance and direction between the reference frame and the frame including the current block and the temporal distance and direction used to form the candidate motion vector. The temporal distance between frames can be determined by their respective positions in the video stream. For example, when a candidate motion vector is a motion vector that was used to encode a block of frame F2 against frame F1, the magnitude of the motion vector can be used directly for encoding frame Fk against reference frame Fk−1 since frames Fk and Fk−1 are, like frames F1 and F2, a frame apart temporally (that is, they are adjacent frames in the frame sequence). In contrast, a candidate motion vector from Fk−1 and previous coded blocks of Fk when a block of Fk was encoded using the golden frame, i.e., F2 in this
FIGS. 10 and 11 , needs to be scaled to take into account the difference of temporal distance before being used to generate the prediction pixels in step 506. For example, a motion vector used in previously coding a block of current frame Fk against Fk−1 will be scaled up using a factor proportional to k−2 to become a candidate motion vector for generation of the prediction pixels when the current block, such asblock 602 ofFIG. 8 , is in evaluation to be coded against reference frame F2. Scaling up or down a motion vector so that it may be applied as a candidate motion vector means adjusting its magnitude. The magnitude of the candidate can be scaled depending upon the results of comparing the temporal distance and direction between the reference frame and the frame including the current block and the temporal distance and direction used to form the candidate motion vector. - An alternate reference frame such as frame A1 may be treated similarly to other references frames, such as the last or golden reference frame. However, since an alternate reference frame may be constructed using portions of multiple frames from multiple temporal positions in the video stream, techniques may be used to determine a temporal position in the video stream that most closely matches the image data included in the alternate frame.
- This can be explained further using an example from
FIG. 11 assuming the use of a candidate motion vector used to predict a block in Fk from frame A1 to generate prediction pixels for analysis of the current block using reference frame Fk−1. Because the distance in frames between F1 and A1, where A1 actually resembles frame Fk+m, is k+m−1, the motion vector magnitude may be divided by k+m−1 before using the candidate motion vector to generate the prediction pixels. This is because the distance between frames Fk and Fk−1 is less than the distance k+m−1, therefore the motion vector has to scaled down to approximate the motion between frames Fk and Fk−1. In cases where the motion vectors are taken from frames temporally close together and used to form inter prediction pixels from frames with greater temporal separation, the motion vectors can be multiplied by a scaling factor proportional to the ratio of the two temporal distances. - At
step 508, a reference motion vector can be selected from the candidate motion vectors identified at step 506. For blocks using a single reference frame, the selection can be based on, for example, selecting the motion vector from the candidate motion vectors associated with the highest popularity value and associated with the reference block closest to the current block. For blocks using compound reference frames, the selection can be based on, for example, the motion vector from reference blocks that share the same reference frame combination with higher priority. When less than two candidate motion vectors are identified, the candidate motion vectors in compound reference frames can be appended with the combinations of reference motion vectors of single reference frames. Other selection criteria can also be used. The reference motion vector can be used for further processing. Namely, the motion vector of the current block can be encoded using the reference motion vector in step 510 before processing begins again for the next block of the current frame. In addition, the current block can be encoded according to the process described with respect toFIG. 3 . - There are several ways to use the reference motion vector in encoding the motion vector of the current block. For example, and as described above,
process 500 may be part of a rate-distortion loop used to select the inter prediction mode for the current block to be encoded. As part of the rate-distortion loop, the actual motion vector for inter prediction of the current block may be determined through a motion search according to any number of techniques. One use of the reference motion vector may include using the reference motion vector as a starting parameter for the motion search algorithm based on the reasoning that the actual motion vector is likely to be close to those used in selecting the reference motion vector. A motion search may alternatively be performed before or in parallel withprocess 500. - Whether or not the reference motion vector is incorporated into the motion search, step 510 may include using the reference motion vector to differentially encode the actual motion vector. For example, a difference value can be calculated by subtracting the reference motion vector from the motion vector used to encode the current block. The difference value can be encoded and included in the video stream. Since the reference motion vector was formed using previously encoded and decoded data, the same data can be available at a decoder to identify the same reference motion vector as was used in forming the motion vector at the encoder, thus no motion vector is required to be encoded and transmitted for the current block. The decoded difference value can be added to the reference motion vector identified by the decoder as described below to form a motion vector to decode the current block. Note that the reference motion vector is associated with one of the available reference frames. Therefore, in the event the reference motion vector is associated with a reference frame that is different from the reference frame associated with the actual motion vector, the reference motion vector may be scaled as described previously so as to generate the difference between the reference motion vector and the actual motion vector. In some implementations, a separate indication of the reference frame used would also be encoded into the bitstream.
- In another implementation, the reference motion vector may be used to choose a probability distribution to encode the magnitude of the motion vector used to encode the current block. In this implementation, bits can be included in the video stream to identify the encoded magnitude of the motion vector and which predetermined probability distribution to use to form the motion vector based on the encoded magnitude. One or more bits indicating which reference frame to use in decoding the current block may also be included in the bitstream in some variations. Like its use in differential encoding, the reference motion vector may also be scaled to the extent it is desirable.
- In an implementation, the reference motion vector may also be used directly in the encoding of the current block. This can occur, for example, when a comparison of the rate-distortion value involved in coding the current block using the motion vector determined by the motion search is higher than that involved in coding the current block using the reference motion vector. In this comparison, the reference frame used would desirably be the one used in selecting the reference motion vector so no scaling is needed. In some cases, the decision as to whether or not to use the reference motion vector may be tied to the difference between the reference motion vector and the motion vector resulting from the search. When the difference is small (or zero), the difference in prediction results for the reference frame resulting from the search using the reference motion vector versus the actual motion vector is also small (or zero). When the reference motion vector is used directly to encode the current block, no motion vector would need to be separately encoded at step 510. Instead, one or more bits would be inserted into the bitstream in association with the current block to indicate use of the reference motion vector for encoding.
- In each of the above ways, the use of a reference motion vector may reduce the number of bits needed to represent the motion vector needed to decode an inter coded block. In some cases, the motion vector used for encoding the current frame would not be done separately. Using the most popular motion vector reduces the overall number of motion vectors, which in turn reduces the number of motion vectors that need to be encoded and placed in the bitstream. Bits may be inserted into frame, slice and/or block headers indicating whether reference motion vectors are used and how they are used for encoding the current block. When applicable, the motion vector found by the motion search or the motion vector differential and/or the reference frame used in encoding the current block are also transmitted.
- Regardless of the motion vector used for encoding, a prediction block can be determined based on a reference frame by applying a candidate motion vector to the previously coded pixel values of the reference frame. The prediction block can be subtracted from the current block to form a residual that can be further encoded according to the processing described with respect to
FIG. 3 and included in an encoded video bitstream. -
FIG. 9 is a flow diagram of a process 900 for decoding an encoded video stream using reference motion vectors in accordance with implementations of this disclosure. The decoder can reproduce the same candidate motion vectors that were constructed inprocess 500, shown inFIG. 5 . The decoder can read the index of the bitstream to determine which reference motion vector to use from the candidate motion vectors. Process 900 can be implemented, for example, as a software program that may be executed by computing devices such as transmitting station 102 or receiving station 110. For example, the software program can include machine-readable instructions that may be stored in a memory such as memory 106 or 114, and that, when executed by a processor, such as CPU 104 or 112, may cause the computing device to perform process 900. Process 900 can be implemented using specialized hardware or firmware. As explained above, some computing devices may have multiple memories or processors, and the steps of process 900 can be distributed using multiple processors, memories, or both. - For simplicity of explanation, process 900 is depicted and described as a series of steps. However, steps in accordance with this disclosure can occur in various orders and/or concurrently. Additionally, steps in accordance with this disclosure may occur with other steps not presented and described herein. Furthermore, not all illustrated steps may be required to implement a method in accordance with the disclosed subject matter.
- Desirably, process 900 substantially conforms to process 500. There are some differences, however, that are pointed out in the following description of process 900. Where steps are substantially similar to those in
process 500, reference will be made to the description above. - At step 902, the decoder determines whether the motion vector for the current block was encoded using a reference motion vector, the reference frame, and whether single or compound prediction was used. This information can be communicated by reading and decoding bits from an encoded video bitstream that indicate the use of a reference motion vector according to one of the techniques disclosed above. The encoded bitstream (or encoded video data) may have been received by decoder of a computing device in any number of ways, such as by receiving the video data over a network, over a cable, or by reading the video data from a primary memory or other storage device, including a disk drive or removable media such as a DVD, CompactFlash (CF) card, Secure Digital (SD) card, or any other device capable of communicating a video stream. Step 902 involves decoding at least a portion of the encoded video bitstream to extract the information regarding the motion vector for the current block. This information can be included in a header associated with a current block or a frame header, for example. The information in the one or more headers indicate to the decoder that the current block is to be decoded using inter prediction and that the motion vector used for that inter prediction relies on the reference motion vector as described previously. For example, information in the bitstream could indicate that the actual motion vector used in encoding the current block was differentially encoded using the reference motion vector. Alternatively, information could indicate that the reference motion vector was used directly for encoding the current block.
- When a reference motion vector was used in the encoder to encode the motion vector for the current block, process 900 advances to step 904 to identify reference candidate motion vectors from the above and left neighbor blocks of the same reference frame. The identified candidate reference motion vectors should be the same as those identified by the encoder in step 502, which may be accomplished by flags as described previously and/or by a priori rules regarding the selection of candidate motion vectors that are available to both the encoder and decoder based on the position of the current block.
- At step 906, the candidate reference motion vectors are ranked based on the distance between the reference block and the current block and the popularity of each candidate reference motion vector. The distance between the reference block and the current block is determined for each candidate reference motion vector. The popularity for each candidate reference motion vector is determined by a popularity value based on a set of previously coded pixel values associated with the particular candidate reference motion vector. The most probable candidate reference motion vector is assigned as the predicted motion vector for NEW_MV mode.
- At step 908, two effective motion vectors are assigned to the REF_MV mode, comprising NEAREST_MV mode and NEAR_MV mode, based on their relative distance to the current block and the overlapped length between the reference block and the current block and their popularity value. If the list of candidate reference motion vectors includes more than two candidate reference motion vectors, the number of reference motion vector modes is dynamically extended. Step 910 process 900 determines whether to use NEW_MV mode or REF_MV mode. When REF_MV mode is selected, process 900 further determines whether to use NEAREST_MV mode or NEAR_MV mode.
- Once the reference motion vector is selected, the motion vector used to encode the current block can be decoded using the selected reference motion vector at step 912. The decoded motion vector may then be used to decode the current block according to the process of
FIG. 4 . - In one example of the implementation of step 912, if the reference motion vector is used to differentially encode the actual motion vector for the current block, the decoder can decode the motion vector by, for example, decoding an encoded difference value that can then be added to the reference motion vector selected at
step 910 to generate the actual motion vector. Then, the actual motion vector may be used to decode the current block using inter prediction. In other implementations, the reference motion vector can be used to identify a predetermined probability distribution, which can be used to decode a magnitude value of the motion vector used to encode the current block before decoding the current block using the motion vector. Similar to the discussion in step 510 ofFIG. 5 , this may involve scaling the reference motion vector. In other implementations, the reference motion vector may be used directly as the motion vector to decode the current block after decoding one or more bits indicating that the reference motion vector should be so used. - Once the motion vector and current block are decoded at step 912, the next block may be processed. In the next block is inter coded, process 900 may be repeated. A frame can be reconstructed from the blocks derived from reconstructed values by intra or inter prediction, or both. The output can be an output video stream, such as the output video stream 416 shown in
FIG. 4 . - According to the teachings herein, a reference motion vector may be selected so as to reduce the number of bits required to encode a motion vector determined by, for example, motion search techniques. The teachings herein take advantage of temporal motion continuity to reduce the number of bits required to transmit motion vector information by referring to motion vectors from adjacent and non-adjacent video frames. The decoder has all the information the encoder has to select the reference motion vector, allowing the selection of the reference motion vector without explicit transfer of further information.
- The aspects of encoding and decoding described above illustrate some exemplary encoding and decoding techniques. However, it is to be understood that encoding and decoding, as those terms are used in the claims, could mean compression, decompression, transformation, or any other processing or change of data.
- The words “example” or “exemplary” are used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as “example” or “exemplary” is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather, use of the words “example” or “exemplary” is intended to present concepts in a concrete fashion. As used in this application, the term “or” is intended to mean an inclusive “or” rather than an exclusive “or”. That is, unless specified otherwise, or clear from context, “X includes A or B” is intended to mean any of the natural inclusive permutations. That is, if X includes A; X includes B; or X includes both A and B, then “X includes A or B” is satisfied under any of the foregoing instances. In addition, the articles “a” and “an” as used in this application and the appended claims should generally be construed to mean “one or more” unless specified otherwise or clear from context to be directed to a singular form. Moreover, use of the term “an implementation” or “one implementation” throughout is not intended to mean the same embodiment or implementation unless described as such.
- Implementations of transmitting station 102 and/or receiving station 110 (and the algorithms, methods, instructions, etc., stored thereon and/or executed thereby, including by
encoder 300 and decoder 400) can be realized in hardware, software, or any combination thereof. The hardware can include, for example, computers, intellectual property (IP) cores, application-specific integrated circuits (ASICs), programmable logic arrays, optical processors, programmable logic controllers, microcode, microcontrollers, servers, microprocessors, digital signal processors or any other suitable circuit. In the claims, the term “processor” should be understood as encompassing any of the foregoing hardware, either singly or in combination. The terms “signal” and “data” are used interchangeably. Further, portions of transmitting station 102 and receiving station 110 do not necessarily have to be implemented in the same manner. - Further, in one aspect, for example, transmitting station 102 or receiving station 110 can be implemented using a general purpose computer or general purpose processor with a computer program that, when executed, carries out any of the respective methods, algorithms and/or instructions described herein. In addition or alternatively, for example, a special purpose computer/processor can be utilized which can contain other hardware for carrying out any of the methods, algorithms, or instructions described herein.
- Transmitting station 102 and receiving station 110 can, for example, be implemented on computers in a video conferencing system. Alternatively, transmitting station 102 can be implemented on a server and receiving station 110 can be implemented on a device separate from the server, such as a hand-held communications device. In this instance, transmitting station 102 can encode content using an
encoder 300 into an encoded video signal and transmit the encoded video signal to the communications device. In turn, the communications device can then decode the encoded video signal using a decoder 400. Alternatively, the communications device can decode content stored locally on the communications device, for example, content that was not transmitted by transmitting station 102. Other suitable transmitting station 102 and receiving station 110 implementation schemes are available. For example, receiving station 110 can be a generally stationary personal computer rather than a portable communications device and/or a device including anencoder 300 may also include a decoder 400. - Further, all or a portion of implementations of the present disclosure can take the form of a computer program product accessible from, for example, a tangible computer-usable or computer-readable medium. A computer-usable or computer-readable medium can be any device that can, for example, tangibly contain, store, communicate, or transport the program for use by or in connection with any processor. The medium can be, for example, an electronic, magnetic, optical, electromagnetic, or a semiconductor device. Other suitable mediums are also available.
- The above-described embodiments, implementations and aspects have been described in order to allow easy understanding of the present disclosure and do not limit the present disclosure. On the contrary, the disclosure is intended to cover various modifications and equivalent arrangements included within the scope of the appended claims, which scope is to be accorded the broadest interpretation so as to encompass all such modifications and equivalent structure as is permitted under the law.
Claims (30)
Priority Applications (7)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/131,079 US10397600B1 (en) | 2016-01-29 | 2016-04-18 | Dynamic reference motion vector coding mode |
GB1621809.1A GB2547754B (en) | 2016-01-29 | 2016-12-21 | Dynamic reference motion vector coding mode |
DE202016008160.9U DE202016008160U1 (en) | 2016-01-29 | 2016-12-23 | Dynamic coding mode for reference motion vectors |
PCT/US2016/068472 WO2017131908A1 (en) | 2016-01-29 | 2016-12-23 | Dynamic reference motion vector coding mode |
DE102016125593.9A DE102016125593B4 (en) | 2016-01-29 | 2016-12-23 | Dynamic reference motion vector encoding mode |
CN201611226103.5A CN107027038B (en) | 2016-01-29 | 2016-12-27 | Dynamic reference motion vector coding mode |
US16/511,389 US10484707B1 (en) | 2016-01-29 | 2019-07-15 | Dynamic reference motion vector coding mode |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201662288553P | 2016-01-29 | 2016-01-29 | |
US15/131,079 US10397600B1 (en) | 2016-01-29 | 2016-04-18 | Dynamic reference motion vector coding mode |
Related Child Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US16/511,389 Continuation US10484707B1 (en) | 2016-01-29 | 2019-07-15 | Dynamic reference motion vector coding mode |
Publications (2)
Publication Number | Publication Date |
---|---|
US10397600B1 US10397600B1 (en) | 2019-08-27 |
US20190268617A1 true US20190268617A1 (en) | 2019-08-29 |
Family
ID=67684819
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US15/131,079 Active 2037-04-16 US10397600B1 (en) | 2016-01-29 | 2016-04-18 | Dynamic reference motion vector coding mode |
US16/511,389 Active US10484707B1 (en) | 2016-01-29 | 2019-07-15 | Dynamic reference motion vector coding mode |
Family Applications After (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US16/511,389 Active US10484707B1 (en) | 2016-01-29 | 2019-07-15 | Dynamic reference motion vector coding mode |
Country Status (1)
Country | Link |
---|---|
US (2) | US10397600B1 (en) |
Cited By (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20190379888A1 (en) * | 2018-06-08 | 2019-12-12 | Tencent America LLC | Method and apparatus for temporal motion vector prediction |
US10555006B2 (en) * | 2016-12-22 | 2020-02-04 | Qualcomm Incorporated | Deriving bilateral filter information based on a prediction mode in video coding |
US20230156182A1 (en) * | 2021-11-17 | 2023-05-18 | Tencent America LLC | Joint signaling method for motion vector difference |
WO2023096668A1 (en) * | 2021-11-23 | 2023-06-01 | Tencent America LLC | Adaptive resolution for single-reference motion vector difference |
Families Citing this family (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP3435673A4 (en) * | 2016-03-24 | 2019-12-25 | Intellectual Discovery Co., Ltd. | Method and apparatus for encoding/decoding video signal |
JP6759680B2 (en) * | 2016-04-26 | 2020-09-23 | ソニー株式会社 | Image processing equipment, imaging equipment, image processing methods, and programs |
US10484695B2 (en) * | 2017-10-23 | 2019-11-19 | Google Llc | Refined entropy coding for level maps |
US10827195B2 (en) * | 2018-08-03 | 2020-11-03 | Tencent America LLC | Method and apparatus for unifying adjacent merge candidates and non-adjacent merge candidates |
US10951885B2 (en) * | 2018-08-30 | 2021-03-16 | Google Llc | Adaptive temporal filtering for alternate frame reference rendering |
US11979596B2 (en) * | 2022-02-07 | 2024-05-07 | Tencent America LLC | Joint coding for adaptive motion vector difference resolution |
CN116664630B (en) * | 2023-08-01 | 2023-11-14 | 荣耀终端有限公司 | Image processing method and electronic equipment |
Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20110194608A1 (en) * | 2010-02-05 | 2011-08-11 | Thomas Rusert | Managing Predicted Motion Vector Candidates |
Family Cites Families (48)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
DE4030703A1 (en) | 1990-09-28 | 1992-04-02 | Bosch Gmbh Robert | METHOD FOR ESTIMATING MOTION IN A TAKEN IMAGE |
US5353119A (en) | 1990-11-15 | 1994-10-04 | Sony United Kingdom Limited | Format conversion of digital video signals, integration of digital video signals into photographic film material and the like, associated signal processing, and motion compensated interpolation of images |
US5384865A (en) | 1992-06-01 | 1995-01-24 | Eastman Kodak Company | Adaptive, hybrid median filter for temporal noise suppression |
GB2302230B (en) | 1992-11-10 | 1997-05-14 | Sony Uk Ltd | Motion compensated video signal processing |
KR100268311B1 (en) | 1993-06-04 | 2000-10-16 | 윌리암 제이. 버크 | System and method for electronic image stabilization |
FI94306C (en) | 1993-07-15 | 1995-08-10 | Nokia Technology Gmbh | Method for determining motion vectors of small TV image segments |
GB2307133A (en) | 1995-11-13 | 1997-05-14 | Secr Defence | Video camera image stabilisation system |
GB2308262B (en) | 1995-12-16 | 1999-08-04 | Paul Gordon Wilkins | Method for analysing the content of a video signal |
US5801778A (en) | 1996-05-23 | 1998-09-01 | C-Cube Microsystems, Inc. | Video encoding with multi-stage projection motion estimation |
IT1296807B1 (en) | 1997-03-14 | 1999-08-02 | Alsthom Cge Alcatel | METHOD FOR ESTIMATING THE MOVEMENT IN SEQUENCES OF BLOCK-CODED IMAGES IN PARTICULAR FOR THE PROCESSING OF THE VIDEO SIGNAL |
US6741655B1 (en) | 1997-05-05 | 2004-05-25 | The Trustees Of Columbia University In The City Of New York | Algorithms and system for object-oriented content-based video search |
JP2001507552A (en) | 1997-10-29 | 2001-06-05 | コーニンクレッカ フィリップス エレクトロニクス エヌ ヴィ | Motion vector prediction and detection of hidden / exposed image parts |
US6072904A (en) | 1997-12-31 | 2000-06-06 | Philips Electronics North America Corp. | Fast image retrieval using multi-scale edge representation of images |
JP3540142B2 (en) | 1998-01-30 | 2004-07-07 | 株式会社東芝 | Motion vector detection circuit and motion vector detection method |
WO2000011863A1 (en) | 1998-08-21 | 2000-03-02 | Koninklijke Philips Electronics N.V. | Problem area location in an image signal |
US6466624B1 (en) | 1998-10-28 | 2002-10-15 | Pixonics, Llc | Video decoder with bit stream based enhancements |
US6891566B2 (en) | 2000-03-14 | 2005-05-10 | Joseph Robert Marchese | Digital video system using networked cameras |
GB2365244A (en) | 2000-07-27 | 2002-02-13 | Snell & Wilcox Ltd | Image stabilisation |
JP3659157B2 (en) | 2000-10-17 | 2005-06-15 | 日本電気株式会社 | Image compression method for weighting video content |
US20030012281A1 (en) | 2001-07-09 | 2003-01-16 | Samsung Electronics Co., Ltd. | Motion estimation apparatus and method for scanning an reference macroblock window in a search area |
US7027654B1 (en) | 2001-08-16 | 2006-04-11 | On2 Technologies | Video compression system |
EP1294194B8 (en) | 2001-09-10 | 2010-08-04 | Texas Instruments Incorporated | Apparatus and method for motion vector estimation |
US7050502B2 (en) | 2001-09-18 | 2006-05-23 | Matsushita Electric Industrial Co., Ltd. | Method and apparatus for motion vector detection and medium storing method program directed to the same |
US7085401B2 (en) | 2001-10-31 | 2006-08-01 | Infowrap Systems Ltd. | Automatic object extraction |
GB0229096D0 (en) | 2002-12-13 | 2003-01-15 | Qinetiq Ltd | Image stabilisation system and method |
WO2004082294A1 (en) | 2003-03-14 | 2004-09-23 | Koninklijke Philips Electronics N.V. | Method for motion vector determination |
US7324596B2 (en) | 2003-07-15 | 2008-01-29 | Lsi Logic Corporation | Low complexity block size decision for variable block size motion estimation |
US20050013498A1 (en) | 2003-07-18 | 2005-01-20 | Microsoft Corporation | Coding of motion vector information |
JP4198608B2 (en) | 2004-01-15 | 2008-12-17 | 株式会社東芝 | Interpolated image generation method and apparatus |
US8111752B2 (en) | 2004-06-27 | 2012-02-07 | Apple Inc. | Encoding mode pruning during video encoding |
US7953152B1 (en) * | 2004-06-28 | 2011-05-31 | Google Inc. | Video compression and encoding method |
AR049593A1 (en) | 2004-07-20 | 2006-08-16 | Qualcomm Inc | METHOD AND APPARATUS FOR PREDICTING THE MOTION VECTOR IN TEMPORARY VIDEO COMPRESSION. |
US20060062481A1 (en) | 2004-09-21 | 2006-03-23 | Markus Suvanto | Apparatuses, computer program product and method for bit rate control of digital image encoder |
GB0423578D0 (en) | 2004-10-22 | 2004-11-24 | Greenparrotpictures Ltd | Dominant motion estimation for image sequence processing |
GB0500174D0 (en) | 2005-01-06 | 2005-02-16 | Kokaram Anil | Method for estimating motion and occlusion |
JP4266939B2 (en) | 2005-02-10 | 2009-05-27 | 株式会社ソニー・コンピュータエンタテインメント | Drawing processing apparatus and drawing data compression method |
US7680355B2 (en) | 2005-05-02 | 2010-03-16 | Intel Corporation | Detection of artifacts resulting from image signal decompression |
US20080002772A1 (en) | 2006-06-28 | 2008-01-03 | Hong Kong Applied Science and Technology Research Institute Company Limited | Motion vector estimation method |
US7809212B2 (en) | 2006-12-20 | 2010-10-05 | Hantro Products Oy | Digital mosaic image construction |
US8127233B2 (en) | 2007-09-24 | 2012-02-28 | Microsoft Corporation | Remote user interface updates using difference and motion encoding |
US8761261B1 (en) | 2008-07-29 | 2014-06-24 | Marvell International Ltd. | Encoding using motion vectors |
JP4564564B2 (en) | 2008-12-22 | 2010-10-20 | 株式会社東芝 | Moving picture reproducing apparatus, moving picture reproducing method, and moving picture reproducing program |
EP2375744A1 (en) | 2010-04-12 | 2011-10-12 | Panasonic Corporation | Complexity reduction for 1/8-pel interpolation |
US9510009B2 (en) | 2010-05-20 | 2016-11-29 | Thomson Licensing | Methods and apparatus for adaptive motion vector candidate ordering for video encoding and decoding |
US8611415B1 (en) | 2010-11-15 | 2013-12-17 | Google Inc. | System and method for coding using improved motion estimation |
ES2886357T3 (en) | 2011-06-27 | 2021-12-17 | Samsung Electronics Co Ltd | Encoding and decoding of motion information |
US20130208795A1 (en) | 2012-02-09 | 2013-08-15 | Google Inc. | Encoding motion vectors for video compression |
US10554965B2 (en) | 2014-08-18 | 2020-02-04 | Google Llc | Motion-compensated partitioning |
-
2016
- 2016-04-18 US US15/131,079 patent/US10397600B1/en active Active
-
2019
- 2019-07-15 US US16/511,389 patent/US10484707B1/en active Active
Patent Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20110194608A1 (en) * | 2010-02-05 | 2011-08-11 | Thomas Rusert | Managing Predicted Motion Vector Candidates |
Cited By (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10555006B2 (en) * | 2016-12-22 | 2020-02-04 | Qualcomm Incorporated | Deriving bilateral filter information based on a prediction mode in video coding |
US20190379888A1 (en) * | 2018-06-08 | 2019-12-12 | Tencent America LLC | Method and apparatus for temporal motion vector prediction |
US11025904B2 (en) * | 2018-06-08 | 2021-06-01 | Tencent America LLC | Method and apparatus for temporal motion vector prediction |
US20230156182A1 (en) * | 2021-11-17 | 2023-05-18 | Tencent America LLC | Joint signaling method for motion vector difference |
US11800092B2 (en) * | 2021-11-17 | 2023-10-24 | Tencent America LLC | Joint signaling method for motion vector difference |
WO2023096668A1 (en) * | 2021-11-23 | 2023-06-01 | Tencent America LLC | Adaptive resolution for single-reference motion vector difference |
Also Published As
Publication number | Publication date |
---|---|
US20190342572A1 (en) | 2019-11-07 |
US10397600B1 (en) | 2019-08-27 |
US10484707B1 (en) | 2019-11-19 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10986361B2 (en) | Video coding using reference motion vectors | |
US10484707B1 (en) | Dynamic reference motion vector coding mode | |
US10142652B2 (en) | Entropy coding motion vector residuals obtained using reference motion vectors | |
US10462457B2 (en) | Dynamic reference motion vector coding mode | |
US10555000B2 (en) | Multi-level compound prediction | |
US20170347094A1 (en) | Block size adaptive directional intra prediction | |
US9344742B2 (en) | Transform-domain intra prediction | |
WO2017131908A1 (en) | Dynamic reference motion vector coding mode | |
US10506240B2 (en) | Smart reordering in recursive block partitioning for advanced intra prediction in video coding | |
US9503746B2 (en) | Determine reference motion vectors | |
US10582212B2 (en) | Warped reference motion vectors for video compression | |
US9350988B1 (en) | Prediction mode-based block ordering in video coding | |
US8396127B1 (en) | Segmentation for video coding using predictive benefit | |
WO2014058796A1 (en) | Method and apparatus for video coding using reference motion vectors | |
US9756346B2 (en) | Edge-selective intra coding | |
US10419777B2 (en) | Non-causal overlapped block prediction in variable block size video coding | |
US9729882B1 (en) | Variable-sized super block based direct prediction mode | |
US11785226B1 (en) | Adaptive composite intra prediction for image and video compression | |
GB2547754A (en) | Dynamic reference motion vector coding mode |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:XU, YAOWU;HAN, JINGNING;SIGNING DATES FROM 20160412 TO 20160413;REEL/FRAME:038319/0742 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044567/0001Effective date: 20170929 |
|
FEPP | Fee payment procedure |
Free format text: PETITION RELATED TO MAINTENANCE FEES GRANTED (ORIGINAL EVENT CODE: PTGR); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |