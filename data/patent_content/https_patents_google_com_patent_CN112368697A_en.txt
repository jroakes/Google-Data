CN112368697A - System and method for evaluating a loss function or a gradient of a loss function via dual decomposition - Google Patents
System and method for evaluating a loss function or a gradient of a loss function via dual decomposition Download PDFInfo
- Publication number
- CN112368697A CN112368697A CN201980044631.4A CN201980044631A CN112368697A CN 112368697 A CN112368697 A CN 112368697A CN 201980044631 A CN201980044631 A CN 201980044631A CN 112368697 A CN112368697 A CN 112368697A
- Authority
- CN
- China
- Prior art keywords
- blocks
- computing system
- labels
- gradient
- loss function
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000000034 method Methods 0.000 title claims abstract description 116
- 238000000354 decomposition reaction Methods 0.000 title description 16
- 230000009977 dual effect Effects 0.000 title description 11
- 239000013598 vector Substances 0.000 claims abstract description 69
- 239000011159 matrix material Substances 0.000 claims abstract description 46
- 238000012937 correction Methods 0.000 claims abstract description 29
- 230000006870 function Effects 0.000 claims description 127
- 238000012549 training Methods 0.000 claims description 64
- 238000010801 machine learning Methods 0.000 claims description 19
- 238000011156 evaluation Methods 0.000 claims description 12
- 238000009499 grossing Methods 0.000 claims description 7
- 238000000638 solvent extraction Methods 0.000 claims 1
- 239000000047 product Substances 0.000 description 14
- 238000013528 artificial neural network Methods 0.000 description 13
- 238000005070 sampling Methods 0.000 description 9
- 238000013459 approach Methods 0.000 description 8
- 238000004364 calculation method Methods 0.000 description 6
- 230000000694 effects Effects 0.000 description 6
- 230000008901 benefit Effects 0.000 description 5
- 238000010586 diagram Methods 0.000 description 5
- 238000005192 partition Methods 0.000 description 5
- 238000012545 processing Methods 0.000 description 5
- 238000002474 experimental method Methods 0.000 description 4
- 238000004891 communication Methods 0.000 description 3
- 230000007423 decrease Effects 0.000 description 3
- 230000009191 jumping Effects 0.000 description 3
- 238000012986 modification Methods 0.000 description 3
- 230000004048 modification Effects 0.000 description 3
- 230000008569 process Effects 0.000 description 3
- 230000000306 recurrent effect Effects 0.000 description 3
- 230000001133 acceleration Effects 0.000 description 2
- 230000008859 change Effects 0.000 description 2
- 238000013527 convolutional neural network Methods 0.000 description 2
- 230000006872 improvement Effects 0.000 description 2
- 230000001939 inductive effect Effects 0.000 description 2
- 238000012360 testing method Methods 0.000 description 2
- 239000010754 BS 2869 Class F Substances 0.000 description 1
- 240000006927 Foeniculum vulgare Species 0.000 description 1
- 230000009471 action Effects 0.000 description 1
- 238000007792 addition Methods 0.000 description 1
- 230000004075 alteration Effects 0.000 description 1
- 239000006227 byproduct Substances 0.000 description 1
- 239000003795 chemical substances by application Substances 0.000 description 1
- 230000000295 complement effect Effects 0.000 description 1
- 239000012141 concentrate Substances 0.000 description 1
- 238000010276 construction Methods 0.000 description 1
- 238000001816 cooling Methods 0.000 description 1
- 230000001815 facial effect Effects 0.000 description 1
- 238000007306 functionalization reaction Methods 0.000 description 1
- 230000003993 interaction Effects 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 238000005457 optimization Methods 0.000 description 1
- 238000007781 pre-processing Methods 0.000 description 1
- 238000012552 review Methods 0.000 description 1
- 230000011218 segmentation Effects 0.000 description 1
- 230000005236 sound signal Effects 0.000 description 1
- 239000000126 substance Substances 0.000 description 1
- 238000006467 substitution reaction Methods 0.000 description 1
- 230000008685 targeting Effects 0.000 description 1
- 230000009466 transformation Effects 0.000 description 1
- 238000013519 translation Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F17/00—Digital computing or data processing equipment or methods, specially adapted for specific functions
- G06F17/10—Complex mathematical operations
- G06F17/11—Complex mathematical operations for solving equations, e.g. nonlinear equations, general mathematical optimization problems
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F17/00—Digital computing or data processing equipment or methods, specially adapted for specific functions
- G06F17/10—Complex mathematical operations
- G06F17/17—Function evaluation by approximation methods, e.g. inter- or extrapolation, smoothing, least mean square method
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
- G06N5/01—Dynamic search techniques; Heuristics; Dynamic trees; Branch-and-bound
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/044—Recurrent networks, e.g. Hopfield networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/045—Combinations of networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/082—Learning methods modifying the architecture, e.g. adding, deleting or silencing nodes or connections
Abstract
Systems and methods for evaluating a loss function or a gradient of the loss function. In an example embodiment, a computer-implemented method includes: the weight matrix is partitioned into a plurality of blocks. The method comprises the following steps: a first set of tags is identified for each of the plurality of blocks having a score greater than a first threshold. The method comprises the following steps: constructing a sparse approximation of a scoring vector for each of the plurality of blocks based on the first set of labels. The method comprises the following steps: a correction value is determined for each sparse approximation of the scoring vector. The method comprises the following steps: determining an approximation of a loss or gradient of loss associated with the scoring function based on each sparse approximation of the scoring vector and the correction value associated with the sparse approximation of the scoring vector.
Description
Technical Field
The present disclosure generally relates to evaluating a loss function or a gradient of a loss function. More particularly, the present disclosure relates to a computer system and method for efficiently evaluating a loss function and/or its gradient for a problem of a large output space via dual decomposition of the loss function.
Background
Large output spaces are ubiquitous in several machine learning problems today. Such machine learning problems may include, for example, extremely multiclass or multi-label classification problems with many classes, language modeling with large vocabulary, or metric learning with large pairwise distance constraints. In all such problems, the main bottleneck in training the model is the evaluation of the loss function and its gradient. The penalty function for this problem typically requires enumerating all possible outputs, and may require a linear run time in terms of the number of outputs to evaluate. This can be a significant bottleneck in iterative methods, such as gradient descent for training the model, as each step may require a large number of operations.
Disclosure of Invention
Aspects and advantages of embodiments of the present disclosure will be set forth in part in the description which follows or may be learned by practice of the embodiments.
One example aspect of the present disclosure relates to a computer-implemented method for evaluating a loss function or a gradient of a loss function. The method comprises the following steps: a weight matrix is partitioned into a plurality of blocks by a computing system comprising one or more computing devices, the weight matrix corresponding to a scoring function. The method comprises the following steps: identifying, by the computing system, for each of the plurality of blocks, a first set of tags, the first set of tags associated with a score greater than a first threshold. The method comprises the following steps: constructing, by the computing system, a sparse approximation of a score vector for each of the plurality of blocks based at least in part on the first set of labels. The method comprises the following steps: determining, by the computing system, a correction value for each sparse approximation of the scoring vector for each of the plurality of blocks. The method comprises the following steps: determining, by the computing system, an approximation of a loss or gradient of a loss associated with the scoring function by evaluating a decomposed loss function or a gradient of the decomposed loss function based at least in part on a sparse approximation of a scoring vector for each of the plurality of blocks and a correction value associated with the sparse approximation of the scoring vector.
The computing system may determine an approximation of the loss or the gradient of the loss for each of a plurality of training examples.
The computing system may modify one or more parameters of the weight matrix or scoring function based at least in part on the determined approximation of the loss or gradient of loss associated with the scoring function.
Identifying a first set of tags for each of a plurality of blocks may include: querying, by the computing system, each of a plurality of maximum inner product search data structures respectively associated with a plurality of blocks of a weight matrix.
Constructing a sparse approximation of the score vector for each of the plurality of blocks may include: setting, by the computing system, for each of the plurality of blocks, a respective approximate score for each of a plurality of labels, each of the plurality of labels included in neither the first set of labels nor the positive label equal to zero of the block.
Constructing a sparse approximation of the score vector for each of the plurality of blocks may include: setting, by the computing system, for each of the plurality of blocks, a respective approximate score for each of a plurality of labels, each of the plurality of labels included in neither the first set of labels of the block nor a positive label equal to a true score determined from the maximum internal search product search query.
Determining a correction value for each sparse approximation of the score vector for each of the plurality of blocks may comprise: identifying, by the computing system, a second set of tags based at least in part on the first set of tags for each of the plurality of blocks, the second set of tags associated with a gradient greater than a second threshold; determining, by the computing system, an average approximate score for each label in the second set of labels across the plurality of blocks; determining, by the computing system, an approximate score for each label in the second set of labels in each of the plurality of blocks; determining, by the computing system, for each combination of a tag in the second set of tags and a block in the plurality of blocks, a difference between the average approximation score and the approximation score for each of the plurality of blocks; and updating, by the computing system, a correction value for each sparse approximation of the score vector for each of the plurality of blocks based at least in part on the determined differences for the labels in the second set of labels and each combination of blocks in the plurality of blocks.
Determining the loss or an approximation of the gradient of the loss associated with the scoring function may include: minimizing, by the computing system, across the plurality of blocks, an average of respective losses for each block evaluated by the respective approximate score vector for such block plus the correction value vector for each block, such that a sum of the correction value vectors across the plurality of blocks is equal to zero.
The decomposed penalty function may include a plurality of portions, each portion corresponding to a penalty associated with a respective sparse approximation of the score vector for each of the plurality of blocks.
The computing system may perform a smoothing technique on the loss function to construct a surrogate loss function having a continuous gradient; and determining a decomposed loss function based at least in part on the surrogate loss function.
Each of the plurality of blocks may include one or more columns of a weight matrix.
Querying each of a plurality of maximum inner product search data structures respectively associated with a plurality of blocks of the weight matrix may comprise: obtaining, by a computing system, a feature map corresponding to the weight matrix and the scoring function; segmenting, by the computing system, the feature map into a plurality of blocks corresponding to a plurality of blocks of the weight matrix; and querying, by the computing system, each of a plurality of maximum inner product search data structures respectively associated with a plurality of blocks of the weight matrix, wherein an output of the segmented feature map corresponds to the block of the weight matrix and the first threshold.
Another example aspect of the present disclosure is directed to a computer system. The computer system includes: one or more processors; and one or more non-transitory computer-readable media that, when executed by one or more processors, cause a computer system to perform the above-described method.
Another example aspect of the present disclosure is directed to a computer system. The computer system includes: one or more processors; and one or more non-transitory computer-readable media that, when executed by one or more processors, cause a computer system to perform operations. The operation includes: a first subset of the plurality of labels is identified for each of a plurality of block partitions of the weight matrix, the first subset having a score greater than a first threshold. The operation includes: for each of a plurality of block partitions, a sparse approximation of a scoring vector for such block partition is constructed based at least in part on a first subset of a plurality of labels identified for such block partition. The operation includes: the decomposed loss function is iteratively optimized by updating the correction values for at least some of the plurality of labels via one or more iterations. The operation includes: after iteratively optimizing the decomposed loss function, an evaluation of the decomposed loss function or a gradient of the decomposed loss function is returned.
Another example aspect of the present disclosure relates to a computer-implemented method of training a classifier. The method comprises the following steps: the classifier is trained using the loss function or the gradient of the loss function obtained from the method described above. For example, an approximation of the loss function and/or the gradient may be obtained by using the above-described method when training the classifier. The classifier may be configured for use with extremely multi-class or multi-label classification problems. The classifier may provide any suitable classification of the data items.
Other aspects of the disclosure relate to various systems, apparatuses, non-transitory computer-readable media, user interfaces, and electronic devices.
These and other features, aspects, and advantages of various embodiments of the present disclosure will become better understood with reference to the following description and appended claims. The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate exemplary embodiments of the disclosure and together with the description, serve to explain the relevant principles. Optional features of one aspect may be combined with other aspects as appropriate.
Drawings
A detailed discussion of embodiments directed to one of ordinary skill in the art is set forth in the specification, which makes reference to the appended drawings, in which:
FIG. 1 depicts a block diagram of an example computing device, in accordance with some embodiments of the present disclosure;
FIG. 2 depicts a plot of multiclass classification results on a Megaface dataset according to some embodiments of the present disclosure;
FIG. 3 depicts a plot of multi-label classification results on a WikilHTC dataset, according to some embodiments of the present disclosure;
FIG. 4 depicts a plot of results on word embedding with a jumping grammar target, according to some embodiments of the present disclosure; and
fig. 5 depicts a flowchart of an example method for evaluating a loss function or a gradient of a loss function, according to some embodiments of the present disclosure.
Reference numerals repeated over multiple figures are intended to identify identical components or features in various embodiments.
Detailed Description
In general, the present disclosure relates to systems and methods for evaluating a loss function or a gradient of a loss function. For large output space problems, evaluating the loss function and its gradient can be computationally expensive, often taking linear time in terms of the size of the output space. Recently, methods have been developed to accelerate learning via efficient data structures for Nearest Neighbor Searches (NNS) or Maximum Inner Product Searches (MIPS). However, the performance of such data structures typically degrades in a high dimension. The present disclosure provides systems and methods that reduce problematic high-dimensional search problems to several much easier-to-solve lower-dimensional search problems via dual decomposition of the penalty function. The present disclosure further provides a greedy messaging technique that guarantees convergence of the original loss. In this manner, the systems and methods of the present disclosure may substantially improve the accuracy of search-based gradient approximation methods and outperform sampling-based gradient approximation methods. In particular, aspects of the present disclosure provide methods of internal functionalization that are particularly suited for one or more computers.
Many schemes have been proposed to mitigate the evaluation of the loss function and its gradient as a bottleneck in the training model of the machine learning problem with large output space. One approach imposes structure on the output space. The structure may include, for example, a lower level structure, a tree structure, a local lower level structure, or a hierarchical factorization structure. However, the structural assumptions can be violated in many cases. For example, while a low-level structure is generally reasonable in a recommendation problem, it is generally not true in multi-class classification because there is exactly one correct answer for each case (i.e., classes may not be related to each other). In addition, even for valid structural assumptions, it is difficult to build the correct structure from the data, and in practice heuristics or manual annotations are required.
Another approach is sampling approximation, which computes an estimate of the gradient based on the fraction of only a small fraction of the negative output classes and also based on a set of small classes that are marked as positive. However, when the loss has a skewed distribution over classes, the approximation has a large variance. For example, in an extreme multi-class or multi-label classification, the losses are usually concentrated only on a few confusion classes, which have a small sampling probability. The variance in the gradient estimation typically results in a slow progression of the learning algorithm.
For machine learning problems with large output spaces but relatively small sets of correct outputs, the learning objective typically concentrates its gradients on a relatively small number of classes, and therefore, an efficient learning approach is to search for classes with significant gradient magnitudes. The proposed strategy for efficiently searching for classes is to maintain a sparse model during training. However, this approach is only applicable to the problem of high input dimensionality. Another strategy is to use data structures to efficiently find classes through Maximum Inner Product Search (MIPS) or Nearest Neighbor Search (NNS). The main challenge here is that as dimensions grow, it becomes difficult to perform MIPS or NNS with high recall and high precision at the same time, and therefore, gradient approximation by MIPS or NNS generally sacrifices accuracy to achieve efficiency.
Aspects of the present disclosure provide an algorithm based on applying a dual decomposition to a convex conjugate representation of a loss function. It can be viewed as a complementary technique for applying a search data structure to a learning problem. The algorithm replaces the high-dimensional search problem with several lower-dimensional searches by decoupling the dimensions via dual decomposition. Lower dimensional searches can be done more efficiently and then the different searches are coupled together via a greedy messaging algorithm. The greedy messaging algorithm is guaranteed to be convergent and, therefore, can be used to obtain a good approximation of the loss and its gradient.
The systems and methods described herein provide a number of technical effects and benefits. Systems and methods for implementing techniques that reduce high-dimensional search problems to several lower-dimensional search problems may have the technical effect of improving efficiency by reducing the computational costs associated with high-dimensional search problems. For example, the high-dimensional search problem may be solved in fewer cycles by one or more processors with smaller memory requirements, and/or the lower-dimensional search problem may be distributed over several processors and solved in parallel, thereby reducing the computational time associated with the high-dimensional search problem. Recently developed approaches that use efficient data structures for Nearest Neighbor Searching (NNS) or Maximum Inner Product Searching (MIPS) speed up learning, but the performance of such data structures degrades in a high dimension. The techniques of this disclosure improve the accuracy of search-based gradient approximation methods and outperform sampling-based gradient approximation methods.
Thus, systems and methods for implementing greedy messaging techniques may have the technical effect of ensuring that the approximate penalty converges to the original penalty. The techniques may enable decoupling variables into lower-dimensional chunks that may be optimized accordingly, and iteratively performing greedy descent on the optimal solution. Thus, the system and method of the present disclosure improves the use of processors or memory, particularly parallel processing systems.
The systems and methods of the present disclosure also provide improvements to computing techniques, such as data matching and retrieval computing techniques. For example, the systems and methods herein enable efficient assessment of loss or gradient of loss.
1. Problem setting
According to aspects of the present disclosure, let X represent the input space and Y represent the output space, and let K ═ Y |, where K is extremely large (e.g., on the order of one hundred thousand or more). The learning objective of the machine learning problem may include learning a scoring function for a large output space y from a given category F of such functions
wherein the content of the first and second substances,
To reduce the complexity of the loss and gradient evaluations, a linear structure assumption may be applied to class F of the scoring function: presence of embedding dimension parameters
f(x)＝Wφ(x)， (1)
where D < < K (e.g., on the order of hundreds or thousands) so that phi (x) can be evaluated explicitly.
Thus, it is possible to provideAt a given f and a batch of samples
In order to determine the loss f (x) without completely calculating the vector f (x)i,Pi) And a good approximation of its gradient, a data structure for preprocessing the matrix W can be constructed. Given an appropriate data structure, this approximation can be calculated in a sub-linear (in K) time.
A first example of a problem with large output space that is suitable for the framework discussed above includes extreme classification. In the extreme classification problem, popular classification loss functions include cross-entropy loss
And maximum boundary loss
For multi-class problems, | P | ═ 1, while for multi-label problems, typically | P | < < K. A typical scoring function takes the following form
f(x)：＝φ(x)。 (4)
Here, Φ (x) is a feature map constructed from either domain knowledge or via learning (e.g., neural networks). Both domain knowledge and learning fit the structural hypothesis (1).
A second example of a problem with large output space that fits in the framework includes metric learning. In the metric learning problem, learning objects during training include: learning function
Which represents the degree of dissimilarity of point x to a collection of points Y e Y. Common choices for dissimilarity functions include by targeting certain ones
And triplet state loss
This scoring function satisfies the structural assumption (1): for a scoring function f given by the squared Mahalanobis distance parameterized by ψ and M, the matrix W is composed of rows for each Y ∈ Y<-ψ(y)TMψ(y)，2ψ(y)TM，-1>And phi (x)＝<1，ψ(x)T，ψ(x)TMψ(x)>TAnd (4) forming. Thus, the embedding dimension D + 2.
A third example of a problem with large output space that fits in the framework includes word embedding. In standard word2vec training, the input space X is a set of vocabulary, and the output space Y ═ X; therefore, K is the vocabulary size. The hop grammar object learns a scoring function f of the form:
where φ (·) is a potential word embedding. This clearly fits the structural hypothesis (1): the rows of the matrix W are the embedding φ (y) for all y ∈ X.
Then, given a text corpus D, the loss function for a sample (x, P) (where P is the set of words in the corpus that occur within a certain size window around the input word x) is given by:
wherein q isxIs an empirical unary grammar frequency of x, and qy|xIs the empirical frequency of observing y within the window of x in corpus D.
1.1 loss and gradient approximation via search
The loss functions considered in the above examples share key features: their values can be well approximated by the fraction of positive tags and the maximum fraction of negative tags. Similarly, their gradients are governed by the coordinates corresponding to the positive label and the negative label with the greatest score. For example, the maximum boundary penalty (3) is determined entirely by the maximum score of the negative label and the minimum score of the positive label, and its gradient is non-zero only on the negative label with the maximum score and the positive label with the minimum score. Similarly, for the cross entropy loss (2), the coordinates of the gradients corresponding to the negative classes are controlled by those with the highest scores, which decrease exponentially as the score decreases.
According to aspects of the present disclosure, since the score function f satisfies the linear structure property (1), the maximum score may be efficiently calculated via a Maximum Inner Product Search (MIPS) data structure. This data structure stores vector v1、v2、……、
Algorithm 1 loss and gradient approximation via search
Samples (x, P) are input, the accuracy parameter τ > 0, and the MIPS data structure T for the row of W is accessed.
2: by setting for k ∈ S ≧ P
the error in this approximation is multiplied by τ
The main difficulty in applying this scheme in practice is the dimensional disaster: the dependency on D is exponential for exact methods, even for approximate methods (such as locality sensitive hashing), the cost still implicitly depends on the dimension, as the points are farther apart when the intrinsic dimension is higher.
The present disclosure enables dual decomposition based search techniques to cope with dimensional disasters. This technique and its analysis are discussed further below.
In order to apply and analyze the technique, the loss function must be smooth (e.g., with a Lipschitz continuous gradient). For non-smooth losses, such as the maximum boundary loss (3), a smoothing technique (e.g., a Nesterov smoothing technique) can be applied to construct a surrogate loss function with guaranteed approximate quality by adding strong convex terms to the Fenchel conjugate of the loss:
here, μ is a smoothing parameter that ensures that the substitution loss has
Wherein 1 isNRepresents a vector containing 0 for the index k e P and 1 for k e N, and
2. Loss decomposition
According to aspects of the present disclosure, the loss may be broken down into several portions. Review of the linear structure hypothesis (1): for all X ∈ X, f (X) ═ W Φ (X). In the following description, (x, P) is fixed and dependencies on P in L are discarded for convenience, simply using the notation L (f (x)) and
because MIPS on the D-dimensional row of W is computationally expensive, W can be decomposed by using the linear structure of f instead. In particular, can be prepared by reacting
If the total score vector z is defined, f (x) W phi (x) and for j e B]Defining a fractional vector z per chunkj＝W(j)φ(i)(x) Then, then
Theorem 1 to
and (5) proving. First, for any λ1、λ2、.......、
2.1 Loss Decomposition Guided Search (LDGS)
Theorem 1 is the basis for calculating an approximation of the loss and its gradient. This approximation is by the pair λjVariables are computed using a form of descent method (e.g., "message passing") by approximately solving the convex minimization problem (12) without computing the entire fractional vector z. The gradient calculation required for each step can be performed by using a memory for storing W(j)Is performed (approximately) by the efficient MIPS data structure of the D/B dimension row. The details of the loss-resolved guided search are given in algorithm 2.
Algorithm 2 greedy messaging
Input sample x, threshold parameter τ1、τ2> 0, and for j ∈ [ B ]]Access for storing W(j)B MIPS data structure T of a row ofj
2: by aiming for k e SjU.P setup
3: for t 1, 2,.. said. (until convergence), proceed
4: computing collections
7: update for all k ∈ A and all j ∈ [ B ]
8: end of cycle
the sub-linearity in the K-time implementation of step 5 in the algorithm depends onStep 9 in the algorithm moves the current solution towards the optimal solution
2.2 error analysis
Definition of
To analyze the algorithm, the BK-dimensional vector < λ is represented by Λ at any given step of the algorithm cycle1、λ2、……、λBSuch as (c). Similarly let Λ*Is represented by
Theorem 2 (greedy messaging) assumes that the loss function L is 1/μ smooth. Then, the suboptimal distance of Λ in the tth step of the loop can be defined as follows:
and (5) proving. Since the loss function L is 1/μ smooth, it is easy to check if G is B/μ smooth. Thus, if Δ Λ is the change in Λ at a given step of the algorithm loop, then
Note that for all j ∈ [ B ]]In addition to and
here, the fact that each coordinate of Λ lies between the corresponding coordinates of 0 and Λ may be used to obtain the world | | Δ Λ | | luminance2≤||Λ*||2. By using in iterations t
While this theorem provides proof of convergence of the algorithm to any desired error level, it provides a rather weak boundary. In practice, only the station is operatedOne step of the loop is sufficient to improve the performance of the direct search based method. If, in addition to smoothing, the loss function is also strongly convex (e.g., this may be achieved by adding some
And (5) analyzing the cost. The exact gradient assessment for a single sample can be calculated over the o (dk) time. The cost of directly applying search-based gradient approximation (Algorithm 1) is O (DQ)D(K) Wherein Q)D(K) Is the number of classes retrieved in the MIPS data structure in order to find all classes of significant gradients. Query cost QD(K) With a strong dependence on the dimension D. Exact MIPS has a cost Q that is exponential in DD(K) In that respect For approximate search methods, such as Locality Sensitive Hashing (LSH), cost QD(K) Usually implicitly only depending on the dimension. The method in Algorithm 2 divides D into B sub-problems of dimension D/B, where the cost per message-passing iteration is O (DQ)D/B(K) + DB | a |), where a is the set calculated in step 4 of algorithm 2. Note that QD/B(K) As B decreases rapidly (in exact case exponentially) and thus one can choose B such that Q isD/B(K)<<QD(K) And balance the two terms s.t.O (DQ)D/B(K)+DB|A|)<<DK。
3. Practical considerations
And (5) MIPS inquiry. In practice, when using MIPS data structures, instead of retrieving data having a value greater than the threshold τ1All categories of scores of (a), it is more efficient to retrieve the top Q categories with the highest scores. In some embodiments, spherical clusters may be used as MIPS data structures, where the number of clusters C is selected such that K/C ≦ Q and C ≦ Q. Note that this requires
And updating the data structure. During training, the model parameters used to determine f will change and the data structure T will need to be updatedj. These data structures store rows of W and treat phi (x) as a query. For lossy functions with sparse gradients, such as (3), (7) and their smoothed versions (10), the updated number of rows k of WrMuch smaller than K and Q (the number of categories retrieved for the query). Thus, the cost of re-indexing a row of W is krC(D/B)B＝krCD (where C is the number of inner products needed to index each row), this cost is much less than the cost of queries and updates. For rows (k) with a large number of updatesrQ), for larger small batch sizes NbIt is still effective. Cost in queries and updates follows NbAs the number of rows to be re-indexed increases, defined by K, the cost of maintaining the data structure becomes insignificant.
Sampling for initialization. For a randomly initialized model, the early iterations of learning have gradients that are evenly distributed across classes because the scores of all classes are close to each other. Therefore, it is not necessary to search for candidates of significant gradient magnitude at an early stage. In practice, one can switch from a sampling-based gradient approximation to a search-based gradient approximation after a few small batch updates.
The systems and methods described herein provide a number of technical effects and benefits. Systems and methods for implementing techniques that reduce high-dimensional search problems to several lower-dimensional search problems may have the technical effect of improving efficiency by reducing the computational costs associated with high-dimensional search problems. For example, the high-dimensional search problem may be solved by one or more processors with less memory requirements in fewer cycles, and/or the lower-dimensional search problem may be distributed over several processors and solved in parallel, thereby reducing the computational time associated with the high-dimensional search problem. Recently developed approaches that use efficient data structures for Nearest Neighbor Searching (NNS) or Maximum Inner Product Searching (MIPS) speed up learning, but the performance of such data structures degrades in a high dimension. The techniques of this disclosure improve the accuracy of search-based gradient approximation methods and outperform sampling-based gradient approximation methods.
Additionally, the systems and methods for implementing greedy messaging techniques may have the technical effect of ensuring that the approximate penalty converges to the original penalty. The techniques may enable decoupling variables into lower-dimensional chunks that may be optimized accordingly, and iteratively performing a greedy descent toward an optimal solution.
The systems and methods of the present disclosure also provide improvements to computing techniques, such as data matching and retrieval computing techniques. For example, the systems and methods herein enable efficient assessment of loss or gradient of loss.
Example embodiments
Referring now to the drawings, example embodiments of the disclosure will be discussed in further detail.
Fig. 1 depicts a block diagram of an example computing system 100 that may evaluate a loss function and/or a gradient of a loss function according to an example embodiment of the present disclosure. The system 100 includes a user computing device 102, a server computing system 130, and a training computing system 150 communicatively coupled through a network 180.
The user computing device 102 may be any type of computing device, such as, for example, a personal computing device (e.g., a laptop or desktop computer), a mobile computing device (e.g., a smartphone or tablet), a gaming console or controller, a wearable computing device, an embedded computing device, or any other type of computing device.
The user computing device 102 includes one or more processors 112 and memory 114. The one or more processors 112 may be any suitable processing device (e.g., processor cores, microprocessors, ASICs, FPGAs, controllers, microcontrollers, etc.) and may be one processor or a plurality of processors operably connected. Memory 114 may include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, disks, etc., and combinations thereof. The memory 114 may store data 116 and instructions 118 that, when executed by the processor 112, cause the user computing device 102 to perform operations.
In some implementations, the user computing device 102 can store or include one or more machine learning models 120. For example, the machine learning model 120 may be or may additionally include various machine learning models, such as a neural network (e.g., a deep neural network) or other types of machine learning models, including non-linear models and/or linear models. The neural network may include a feed-forward neural network, a recurrent neural network (e.g., a long-short term memory recurrent neural network), a convolutional neural network, or other form of neural network.
More specifically, the machine learning model 120 may be associated with a large output space, such as, for example, extreme multi-class or multi-label classification problems with many classes, language modeling with large vocabulary, and/or metric learning with a large number of pairwise distance constraints. In some implementations, the machine learning model 120 can be associated with a category F of the scoring function such that for each F e F, there is an embedded dimension parameter
Additionally or alternatively, one or more machine learning models 140 may be included in or otherwise stored and implemented by the server computing system 130, which communicates with the user computing device 102 according to a client-server relationship. For example, the machine learning model 140 may be implemented by the server computing system 140 as part of a web service (e.g., an extreme multi-class or multi-label classification service, a language modeling service, a metric learning service, etc.). Accordingly, one or more models 120 may be stored and implemented at the user computing device 102 and/or one or more models 140 may be stored and implemented at the server computing system 130.
The user computing device 102 may also include one or more user input components 122 for receiving user input. For example, the user input component 122 may be a touch sensitive component (e.g., a touch sensitive display screen or touchpad) that is sensitive to touch by a user input object (e.g., a finger or stylus). The touch sensitive component may be used to implement a virtual keyboard. Other example user input components include a microphone, a conventional keyboard, or other means by which a user may provide user input.
The server computing system 130 includes one or more processors 132 and memory 134. The one or more processors 132 may be any suitable processing device (e.g., processor cores, microprocessors, ASICs, FPGAs, controllers, microcontrollers, etc.) and may be one processor or a plurality of processors operably connected. Memory 134 may include one or more non-transitory computer-readable storage media, such as RAM, ROM, EEPROM, EPROM, flash memory devices, a disk, and the like, as well as combinations thereof. The memory 134 may store data 136 and instructions 138 that, when executed by the processor 132, cause the server computing system 130 to perform operations.
In some implementations, the server computing system 130 includes or is otherwise implemented by one or more server computing devices. Where the server computing system 130 includes multiple server computing devices, such server computing devices may operate according to a sequential computing architecture, a parallel computing architecture, or some combination thereof.
As described above, the server computing system 130 may store or otherwise include one or more machine-learned recursive super-resolution models 140. For example, the model 140 may be or may additionally include various machine learning models. Example machine learning models include neural networks or other multi-layered nonlinear models. Example neural networks include feed-forward neural networks, deep neural networks, recurrent neural networks, and convolutional neural networks. An example model 140 is discussed with reference to fig. 2-7.
The user computing device 102 and/or the server computing system 130 may train the models 120 and/or 140 via interaction with a training computing system 150 communicatively coupled through a network 180. The training computing system 150 may be separate from the server computing system 130 or may be part of the server computing system 130.
More specifically, model trainer 160 may apply a dual decomposition to the convex conjugate representation of the loss function. In addition to applying search data structures (e.g., MIPS data structures) to learning problems, machine trainer 160 may also apply dual decomposition. The model trainer 160 may replace a high-dimensional search problem with several lower-dimensional searches by decoupling the dimensions via dual decomposition. Model trainer 160 may couple the different lower dimensional searches via greedy messaging that may guarantee convergence to obtain a good approximation of the loss and its gradient.
In some implementations, the model trainer 160 can segment a weight matrix that corresponds to a scoring function associated with the machine-learned models 120 and/or 140. Model trainer 160 may segment the weight matrix into a plurality of blocks and store the plurality of blocks in a plurality of corresponding MIPS data structures. For example, model trainer 160 may store rows for each of a plurality of blocks in a MIPS data structure corresponding to the block. Model trainer 160 may query each of the plurality of MIPS data structures with a first threshold to identify a first set of labels associated with scores greater than the first threshold. Model trainer 160 may construct a sparse approximation of a scoring vector for each of the plurality of blocks based at least in part on the first set of labels, determining a correction value for each sparse approximation. The model trainer 160 may iteratively optimize the decomposed loss function by updating the correction values for at least some of the first set of labels. After optimizing the decomposed loss function, model trainer 160 may evaluate the decomposed loss function or a gradient of the decomposed loss function based at least in part on a sparse approximation of a score vector for each of the plurality of blocks and a correction value associated with the sparse approximation of the score vector. In this manner, model trainer 160 may determine a loss or an approximation of a gradient of the loss associated with the scoring function.
The model trainer 160 may train the machine learning models 120 and/or 140 based on the training data set 162. Training data 162 may include, for example, a training sequence having X ∈ X and
In some implementations, the training examples may be provided by the user computing device 102 if the user has provided consent. Thus, in such an implementation, the model 120 provided to the user computing device 102 may be trained by training the computing system 150 according to user-specific data received from the user computing device 102. In some cases, this process may be referred to as a personalization model.
The model trainer 160 includes computer logic for providing the desired functionality. Model trainer 160 may be implemented in hardware, firmware, and/or software that controls a general purpose processor. For example, in some embodiments, model trainer 160 includes program files stored on a storage device, loaded into memory, and executed by one or more processors. In other embodiments, model trainer 160 includes one or more sets of computer-executable instructions stored in a tangible computer-readable storage medium (such as a RAM hard disk or an optical or magnetic medium).
The network 180 may be any type of communications network, such as a local area network (e.g., an intranet), a wide area network (e.g., the internet), or some combination thereof, and may include any number of wired or wireless links. In general, communications through network 180 may occur via any type of wired connection and/or wireless connection using various communication protocols (e.g., TCP/IP, HTTP, SMTP, FTP), encodings or formats (e.g., HTML, XML) and/or protection schemes (e.g., VPN, secure HTTP, SSL).
FIG. 1 illustrates one example computing system that can be used to implement the present disclosure. Other computing systems may also be used. For example, in some implementations, the user computing device 102 may include a model trainer 160 and a training data set 162. In such an implementation, the model 120 may be both trained and used locally at the user computing device 102. In some such implementations, the user computing device 102 may implement the model trainer 160 to personalize the model 120 based on user-specific data.
FIG. 2 depicts a plot of multiclass classification results on a Megaface dataset according to some embodiments of the present disclosure.
Fig. 3 depicts a plot of multi-label classification results on a wikilsthc dataset according to some embodiments of the present disclosure.
Fig. 4 depicts a plot of results on word embedding with a skip grammar target, according to some embodiments of the present disclosure.
Thus, fig. 2-4 depict plots illustrating comparison of different loss functions to a gradient evaluation method, according to example embodiments of the present disclosure. In particular, FIG. 2 corresponds to a multi-class classification problem (e.g., facial recognition) and depicts a plot illustrating multi-class classification results on a MegaFace dataset: test accuracy versus training time (left), training accuracy versus training time (middle), and training accuracy versus number of epochs (right), where the x-axis is a logarithmic scale. FIG. 3 corresponds to a multi-label classification problem (e.g., document markup) and depicts a plot illustrating multi-label classification results on a WikilHTC dataset: test accuracy versus training time (left), training accuracy versus training time (middle), and training accuracy versus number of epochs (right), where the x-axis is a logarithmic scale. FIG. 4 corresponds to the unsupervised Word embedding problem and depicts a graph illustrating the results on Word embedding with the jumping grammar target (9), where GD-Exact, GD-MIPS and GD-Decomp-MIPS are initialized with a model trained with one epoch of Word2 vec-Neg.
With respect to fig. 2 and 3, a random gradient descent (SGD) optimization algorithm is employed, where the initial step size is selected from {1, 0.1, 0.01} to achieve the best performance for each method, and a 1/(1+ t) cooling scheme, where t is an iteration counter. The mini-batch size is 10 and all methods are processed in parallel with 10 CPU cores in a shared memory architecture running on a dedicated computer. All embodiments are C + +. The following loss functions were compared to the gradient evaluation method:
softmax: the exact gradient evaluation of the cross-entropy penalty (2), where for the multi-class in fig. 2, | P | ═ 1, and for the multi-label in fig. 3, | < < K;
Sampled-Softmax (sample Softmax): a sampling strategy that includes all positive classes of instances and that uniformly subsamples from the remaining negative classes, with a sample size of K/100;
margin (boundary): the exact gradient of the smoothed maximum boundary loss (10) was evaluated, where μ ═ 1 for the classes in fig. 2 and μ ═ 5 for the multi-labels in fig. 3. The double simplex projection (11) is calculated using O (klog (k)). For this loss, the gradient update is faster than the update of the cross entropy, because the loss gradient is very sparse, making the backward pass faster;
MIPS: search-based gradient evaluation (e.g., algorithm 1) for smoothed maximum boundary loss (10), where μ ═ 1 for the classes in fig. 2 and μ ═ 5 for the multi-labels in fig. 3. Spherical clusters with 100 centroids are used as MIPS data structures with bulk queries of size K/100; and
Decomp-MIPS (decomposed MIPS): gradient evaluation via decomposition search (e.g. algorithm 2, T ═ 1 iteration). For the multi-class in fig. 2, the inner product is divided into B-8 factors, and for the multi-label in fig. 3, B-4. Spherical clusters with 100 centroids are used as MIPS data structures with bulk queries of size K/100.
With respect to FIG. 2, a multiclass classification experiment is performed on the largest publicly available face recognition dataset MegaFace, where each identity is considered a class and each sample is an image cropped by the face detector. The MegaFace dataset statistics are shown in table 1. The FaceNet architecture is pre-trained on the MS-Celeb-1M dataset and the last layer of the FaceNet architecture is fine-tuned on the MegaFace dataset. The input to the last layer is an embedding of size 128, which in the Decomp-MIPS method is divided into factors B-8, each with dimensions of 16.
# identity | # image | Embedding dimension |
672K | 4.7M | 128 |
Table 1: statistics of MegaFace datasets
The run time of the comparison method in fig. 2 is more than one day, and the results are shown in fig. 2. A comparison of the methods for optimizing (smoothed) maximum boundary loss (Decomp-MIPS, MIPS and Margin) shows that both Decomp-MIPS and MIPS can accelerate the iteration by 1 to 2 orders of magnitude. However, MIPS converges with much lower accuracy than Decomp-MIPS, and the gap becomes larger when more iterations are run. Note that time and period are logarithmic scales. In addition, Softmax has a much slower progression than Margin. After one day, Softmax and Margin did not complete a period (4.7M samples). Margin's progress is much better, presumably because it places emphasis on confusing identities. Furthermore, compared to MIPS-based approaches, Sampled-Softmax has much faster iterations, but the progress per iteration is smaller, resulting in slower overall progress.
For fig. 3, the multi-label classification experiment was performed on wikilsthc (a benchmark dataset in an extreme classification repository), where each class is a catalog tag in Wikipedia and each sample is a document with a bag-of-words representation. The wikilsthc data statistics are shown in table 2. On average, each sample has 3.19 positive labels, and each class appears as a positive class in 17.46 samples. The single hidden layer fully connected feed forward network is trained to perform the multi-label classification task. The first layer has an input dimension equal to the vocabulary size (1.6M) and an output with dimension 100. The second layer has an output size equal to the number of classes (325K) and approximations of different loss functions and different comparison methods. The training results also produce document and word embedding as byproducts. For Decomp-MIPS, the input of the last layer is divided into B-4 factors, each with a dimension of 25.
The running time of the comparison method in fig. 3 is more than one day, and the results are shown in fig. 3. As shown, Softmax has a very good per iteration progression, significantly exceeding the progression of the other three schemes (Margin, MIPS, Decomp-MIPS) based on a smoothed maximum boundary loss. However, the iteration of Softmax is much slower than the other iterations, since it has a dense loss gradient, and therefore a slow back propagation, so that when comparing training times, Softmax performs similarly to Margin. On the other hand, when comparing Margin, Decomp-MIPS and MIPS in terms of progress per epoch, the update of Decomp-MIPS achieves almost the same progress as the exact gradient calculation of Margin, while MIPS training accuracy is significantly degraded compared to Margin and Decomp-MIPS, since it runs more iterations. Overall, MIPS-based methods result in an order of magnitude acceleration, while Decomp-MIPS retains the accuracy of the exact method. On the other hand, although the iteration of Sampled-Softmax is fast, it has an extremely slow progress per iteration, and even after one day, Sampled-Softmax cannot achieve accuracy comparable to other methods.
# Label | # sample | Embedding dimension | Size of vocabulary |
325K | 1.8 |
100 | 1.6M |
Table 2: statistics of WikilHTC dataset
With respect to FIG. 4, the gradient approximation method of the present disclosure evaluates on a Word embedding task with a jumping grammar learning objective (9) and compares against two widely used gradient approximation methods — layered Softmax (Word2vec-HS) and negative sampling (Word2vec-Neg) implemented in the Word2vec envelope. The sample size for Word2vec-Neg is chosen from {5,10,15,20,25 }.
A reference dataset BillonW consisting of a large group of approximately fifty thousand words of an album was used. Data statistics are provided in table 3. A window of size 8 is used and common words are subsampled in the corpus. Each word w is represented by a probability
Size of vocabulary | Word # word | Embedding dimension | Window size |
≈451K | ≈ |
100 | 8 |
Table 3: statistics of Billion W data sets
Note that the hop syntax object (9) is presented in a collapsed form. Here, all entries of the same input-output pair are grouped together and weighted by frequency. By empirical input-output distribution q in (9)x、qy|xA summation is performed to calculate the gradient from the positive output. Then, alternatively, for the input word { φ (x) }x∈XAnd output word [ phi (y) }y∈XPerforms a Gradient Descent (GD) update. GD. GD-MIPS and GD-Decomp-MIPS are used to represent algorithms with different loss approximation strategies. Since in early iterations the model has a fairly evenly distributed gradient for the candidates, 1 epoch of Word2vec-Neg is used to initialize GD, GD-MIPS and GD-Decomp-MIPS. For this task, there are many more negative classes of significant gradient magnitude than is the case in multi-label and multi-class experiments. For MIPS architecture, bulk queries of size K/20 are used instead of K/100.
The comparison method in fig. 4 is processed in parallel with 24 CPU cores, and the results are shown in fig. 4. After the first epoch, the alternating Gradient Descent (GD) based approach (with the folding goal (9)) has faster convergence per epoch, and the iteration of GD-demomp-MIPS is 5 times faster than the iteration of GD, while having a significantly better target value than GD-MIPS within the same training time.
Fig. 5 depicts a diagram of a method 500 for evaluating a loss function or a gradient of a loss function. In (502), the method 500 includes: the weight matrix is partitioned into blocks. For example, the training computing system 150 may segment a weight matrix corresponding to the scoring function. The training computing system 150 may partition the weight matrix into a plurality of blocks. Each of the plurality of blocks may include one or more columns of the weight matrix.
At (504), the method 500 includes: a first set of tags is identified for each block. For example, training computing system 150 may identify a first set of labels for each of the plurality of blocks. The first set of tags may be associated with a score greater than a first threshold. The training computing system 150 may query each of a plurality of maximum inner product search data structures respectively associated with a plurality of blocks of the weight matrix. Specifically, the training computing system 150 may obtain a feature map corresponding to the weight matrix and the scoring function; segmenting a feature map into a plurality of blocks corresponding to a plurality of blocks of the weight matrix; and querying each of a plurality of maximum inner product search data structures respectively associated with a plurality of blocks of the weight matrix, wherein the output of the segmented feature map corresponds to a block of the weight matrix and a first threshold.
At (506), the method 500 includes: a sparse approximation of the score vector is constructed for each block. For example, training computing system 150 may construct a sparse approximation of a score vector for each of the plurality of blocks based at least in part on the first set of labels. The training computing system 150 may set, for each of the plurality of blocks, a respective approximate score for each of a plurality of labels that are included in neither the first set of labels for the block nor the positive label equal to zero; and setting, for each of the plurality of blocks, a respective approximate score for each of a plurality of tags included in neither the first set of tags for the block nor positive tags equal to the true score determined from the maximum intra search product search query.
At (508), the method 500 includes: a correction value is determined for each score vector. For example, training computing system 150 determines a correction value for each sparse approximation of the score vector for each of the plurality of blocks. In particular, the training computing system 150 may identify a second set of labels based at least in part on the first set of labels for each of the plurality of blocks, the second set of labels associated with a gradient greater than a second threshold. The training computing system 150 may determine an average approximate score for each label in the second set of labels across the plurality of blocks. The training computing system 150 may determine an approximate score for each label in the second set of labels for each of the plurality of blocks. The training computing system 150 may determine, for each combination of a label in the second set of labels and a block in the plurality of blocks, a difference between the average approximation score and the approximation score for each of the plurality of blocks. The training computing system 150 may update the correction value for each sparse approximation of the score vector for each of the plurality of blocks based at least in part on the determined difference for the label in the second set of labels and each combination of blocks in the plurality of blocks.
At (510), the method 500 includes: the loss or gradient of loss is approximated. For example, training computing system 150 may determine an approximation of a loss or gradient of losses associated with the scoring function by evaluating a decomposed loss function or a gradient of a decomposed loss function based at least in part on a sparse approximation of a scoring vector for each of a plurality of blocks and a correction value associated with the sparse approximation of the scoring vector. The decomposed penalty function may include a plurality of portions, each portion corresponding to a penalty associated with a respective sparse approximation of the score vector for each of the plurality of blocks.
The training computing system 150 may minimize, across a plurality of blocks, an average of respective losses for each block evaluated by a respective approximate score vector for such block plus a correction value vector for each block, such that a sum of the correction value vectors across the plurality of blocks equals zero.
The training computing system 150 may determine a loss or an approximation of a gradient of the loss for each of a plurality of training examples.
The training computing system 150 may modify one or more parameters of the weight matrix or scoring function based at least in part on the determined approximation of the loss or the gradient of the loss associated with the scoring function.
The method 500 may be used in training a classifier. The classifier may be used in extreme multi-class or multi-label classification problems. The classifier may provide any suitable classification of data items and may be used, for example, to classify or discover audio clips, images or videos, e.g., based on an input sequence that may represent one or more images or videos. The data items may be data representing still images or moving images, in which case the respective numerical values contained in the data items may represent pixel values, for example values of one or more color channels of a pixel. The training image used to train the model may be a real-world image captured by a camera.
Alternatively, the data items may be data representing sound signals, such as amplitude values of audio waveforms (e.g. natural language; in this case, the training examples may be samples of natural language recorded by a microphone from the speech of a human speaker, for example). In another possibility, the data items may be text data, such as text strings or other representations of words and/or sub-word units (words) in a machine translation task. Thus, the data items may be one-dimensional, two-dimensional or higher.
The techniques discussed herein make reference to servers, databases, software applications, and other computer-based systems and actions taken and information sent to and from such systems. The inherent flexibility of computer-based systems allows for a variety of possible configurations, combinations, and divisions of tasks and functionality between and among components. For example, the processes discussed herein may be implemented using a single device or component or a plurality of devices or components operating in combination. Databases and applications may be implemented on a single system or distributed across multiple systems. The distributed components may run sequentially or in parallel.
While the present subject matter has been described in detail with respect to various specific example embodiments thereof, each example is provided by way of illustration, and not limitation, of the present disclosure. Alterations, modifications and equivalents of such embodiments may readily occur to those skilled in the art having the benefit of the teachings presented in the foregoing description. Accordingly, the subject disclosure does not preclude inclusion of such modifications, variations and/or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art. For instance, features illustrated or described as part of one embodiment, can be used with another embodiment to yield a still further embodiment. Accordingly, the present disclosure is intended to cover such alternatives, modifications, and equivalents.
Claims (22)
1. A computer-implemented method for evaluating a loss function or a gradient of the loss function, the method comprising:
partitioning, by a computing system comprising one or more computing devices, a weight matrix into a plurality of blocks, the weight matrix corresponding to a scoring function;
identifying, by the computing system, a first set of tags for each of the plurality of blocks, the first set of tags being associated with a score greater than a first threshold;
constructing, by the computing system, a sparse approximation of a scoring vector for each of the plurality of blocks based at least in part on the first set of labels;
determining, by the computing system, a correction value for each sparse approximation of the scoring vector for each block of the plurality of blocks; and
determining, by the computing system, an approximation of a loss or gradient of a loss associated with the scoring function by evaluating a gradient of a decomposed loss function or a decomposed loss function based at least in part on the sparse approximation of the scoring vector for each block of the plurality of blocks and the correction value associated with the sparse approximation of the scoring vector.
2. The computer-implemented method of claim 1, further comprising:
determining, by the computing system, for each of a plurality of training examples, an approximation of the loss or the gradient of the loss.
3. The computer-implemented method of claim 1 or 2, further comprising:
modifying, by the computing system, one or more parameters of the weight matrix or the scoring function based at least in part on the determined approximation of the loss or the gradient of the loss associated with the scoring function.
4. The computer-implemented method of claim 1, 2, or 3, wherein identifying the first set of tags for each of the plurality of blocks comprises:
querying, by the computing system, each of a plurality of maximum inner product search data structures respectively associated with the plurality of blocks of the weight matrix.
5. The computer-implemented method of any of the preceding claims, wherein constructing the sparse approximation of the scoring vector for each of the plurality of blocks comprises:
setting, by the computing system, a respective approximate score for each of the plurality of labels for each of the plurality of blocks, the each of the plurality of labels included in neither the first set of labels nor a positive label equal to zero for the block.
6. The computer-implemented method of any of claims 1 to 4, wherein constructing the sparse approximation of the scoring vector for each of the plurality of blocks comprises:
setting, by the computing system, a respective approximate score for each of the plurality of labels for each of the plurality of blocks, the each of the plurality of labels included in neither the first set of labels nor a positive label of the block, the positive label equal to a true score determined from a maximum inner search product search query.
7. The computer-implemented method of any of the preceding claims, wherein determining the correction value for each sparse approximation of the scoring vector for each of the plurality of blocks comprises:
identifying, by the computing system, a second set of labels based at least in part on the first set of labels for each of the plurality of blocks, the second set of labels associated with a gradient greater than a second threshold;
determining, by the computing system, an average approximate score for each label in the second set of labels across the plurality of blocks;
determining, by the computing system, an approximate score for each label in the second set of labels in each of the plurality of blocks;
determining, by the computing system, for each combination of a tag in the second set of tags and a block in the plurality of blocks, a difference between the average approximation score and the approximation score for each block in the plurality of blocks; and
updating, by the computing system, the correction value for each sparse approximation of the scoring vector for each of the plurality of blocks based at least in part on the difference determined for each combination of a label in the second set of labels and a block in the plurality of blocks.
8. The computer-implemented method of any of the preceding claims, wherein determining an approximation of the loss or gradient of loss associated with the scoring function comprises:
minimizing, by the computing system, across the plurality of blocks, an average of respective losses for each block evaluated at the respective approximate score vector for that block plus the correction value vector for each block, such that a sum of the correction value vectors across the plurality of blocks is equal to zero.
9. The computer-implemented method of any of the preceding claims, wherein the decomposed loss function comprises a plurality of portions, each portion corresponding to a loss associated with a respective sparse approximation of the score vector for each of the plurality of blocks.
10. The computer-implemented method of any of the preceding claims, the method further comprising:
performing, by the computing system, a smoothing technique on the loss function to construct a surrogate loss function having a continuous gradient; and
determining, by the computing system, the decomposed loss function based at least in part on the surrogate loss function.
11. The computer-implemented method of any of the preceding claims, wherein each of the plurality of blocks comprises one or more columns of the weight matrix.
12. The computer-implemented method of claim 4, wherein querying each of the plurality of maximum inner product search data structures respectively associated with the plurality of blocks of the weight matrix comprises:
obtaining, by the computing system, a feature map corresponding to the weight matrix and the scoring function;
segmenting, by the computing system, the feature map into a plurality of blocks corresponding to the plurality of blocks of the weight matrix; and
querying, by the computing system, each of the plurality of maximum inner product search data structures respectively associated with the plurality of blocks of the weight matrix, wherein an output of the segmented feature map corresponds to the block of the weight matrix and the first threshold.
13. A computing system, comprising:
one or more processors; and
one or more non-transitory computer-readable media storing instructions that, when executed by the one or more processors, cause the computing system to perform operations comprising:
identifying a first subset of a plurality of labels for each of a plurality of blocks of a weight matrix, wherein each label in the first subset has a score greater than a first threshold;
constructing, for each of the plurality of blocks, a sparse approximation of a scoring vector for the block based at least in part on the first subset of the plurality of labels identified for the block;
determining correction values for at least some of the plurality of labels, wherein the correction values are updated at each of one or more iterations to iteratively optimize a decomposed loss function; and
after iteratively optimizing the decomposed loss function, an evaluation of the decomposed loss function or a gradient of the decomposed loss function is determined.
14. The computing system of claim 13, the operations further comprising:
the operations of identifying, building, iteratively optimizing, and returning are performed for each of a plurality of training examples.
15. The computing system of claim 13 or 14, the operations further comprising:
modifying one or more parameters of the weight matrix or a machine learning scoring model approximated by the weight matrix based at least in part on the evaluation of the decomposed loss function or the gradient of the decomposed loss function.
16. The computing system of claim 13, 14, or 15, wherein identifying the first subset of the plurality of labels for each of the plurality of blocks of the weight matrix comprises:
querying each of a plurality of maximum inner product search data structures respectively associated with the plurality of blocks of the weight matrix.
17. The computing system of any of claims 13 to 16, wherein constructing, for each of the plurality of blocks, the sparse approximation of the scoring vector for that block comprises:
setting, for each of the plurality of blocks, a respective approximate score for each of the plurality of labels, wherein the each of the plurality of labels is included in neither the first subset of the block nor a positive label equal to zero.
18. The computing system of any of claims 13 to 16, wherein constructing, for each of the plurality of blocks, the sparse approximation of the scoring vector for that block comprises:
setting, for each of the plurality of blocks, a respective approximate score for each of the plurality of labels, wherein the each of the plurality of labels is included in neither the first subset of the block nor a positive label equal to a true score determined from a maximum inner search product search query.
19. The computing system of any of claims 13 to 18, wherein iteratively optimizing the decomposed loss function comprises:
for each of the one or more iterations:
identifying a second subset of the plurality of tags, the second subset having a respective sub-gradient greater than a second threshold;
determining, for each combination of a label and a block included in the second subset, a difference between an average of the approximate scores of the label across the plurality of blocks and the approximate score of the label for the block; and
updating, for each combination of tags and blocks included in the second subset, a respective correction value for that combination of tags and blocks based at least in part on a difference between the approximate score for that tag across the plurality of blocks and the approximate score for that tag for that block.
20. The computing system of any of claims 13 to 19, wherein iteratively optimizing the decomposed loss function comprises:
across the plurality of blocks, an average of respective losses for each block evaluated at the respective approximate score vector for that block plus the correction value vector for each block is minimized such that a sum of the correction value vectors across the plurality of blocks is equal to zero.
21. A computing system, the computing system comprising:
one or more processors; and
one or more non-transitory computer-readable media storing instructions that, when executed by one or more processors, cause the computing system to perform the method of any of claims 1-12.
22. A computer-implemented method for training a classifier, the method comprising: training the classifier using a decomposed loss function or a gradient of the decomposed loss function obtained from the method according to any one of claims 1 to 12.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201862682100P | 2018-06-07 | 2018-06-07 | |
US62/682,100 | 2018-06-07 | ||
PCT/US2019/036057 WO2019237000A1 (en) | 2018-06-07 | 2019-06-07 | Systems and methods for evaluating a loss function or a gradient of a loss function via dual decomposition |
Publications (1)
Publication Number | Publication Date |
---|---|
CN112368697A true CN112368697A (en) | 2021-02-12 |
Family
ID=67185710
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201980044631.4A Pending CN112368697A (en) | 2018-06-07 | 2019-06-07 | System and method for evaluating a loss function or a gradient of a loss function via dual decomposition |
Country Status (3)
Country | Link |
---|---|
US (1) | US10510021B1 (en) |
CN (1) | CN112368697A (en) |
WO (1) | WO2019237000A1 (en) |
Families Citing this family (12)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11657322B2 (en) * | 2018-08-30 | 2023-05-23 | Nec Corporation | Method and system for scalable multi-task learning with convex clustering |
US11625554B2 (en) * | 2019-02-04 | 2023-04-11 | International Business Machines Corporation | L2-nonexpansive neural networks |
US11468298B2 (en) * | 2019-09-17 | 2022-10-11 | Adobe Inc. | Neural networks for multi-label classification of sequential data |
US10956825B1 (en) * | 2020-03-16 | 2021-03-23 | Sas Institute Inc. | Distributable event prediction and machine learning recognition system |
US11816574B2 (en) * | 2019-10-25 | 2023-11-14 | Alibaba Group Holding Limited | Structured pruning for machine learning model |
US20210142210A1 (en) * | 2019-11-11 | 2021-05-13 | Alibaba Group Holding Limited | Multi-task segmented learning models |
US11687778B2 (en) | 2020-01-06 | 2023-06-27 | The Research Foundation For The State University Of New York | Fakecatcher: detection of synthetic portrait videos using biological signals |
CN111339886B (en) * | 2020-02-19 | 2024-01-09 | 中山大学 | Behavior recognition method based on similarity loss |
US11010691B1 (en) * | 2020-03-16 | 2021-05-18 | Sas Institute Inc. | Distributable event prediction and machine learning recognition system |
CN113673668A (en) * | 2020-05-13 | 2021-11-19 | 北京君正集成电路股份有限公司 | Calculation method of secondary loss function in vehicle detection training |
CN112083482B (en) * | 2020-08-06 | 2021-11-19 | 西安交通大学 | Seismic super-resolution inversion method based on model-driven depth learning |
CN114330573A (en) * | 2021-12-30 | 2022-04-12 | 济南博观智能科技有限公司 | Target detection method and device, electronic equipment and storage medium |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20120331025A1 (en) * | 2011-06-27 | 2012-12-27 | International Business Machines Corporation | Systems and methods for large-scale randomized optimization for problems with decomposable loss functions |
CN105160400A (en) * | 2015-09-08 | 2015-12-16 | 西安交通大学 | L21 norm based method for improving convolutional neural network generalization capability |
CN106250917A (en) * | 2016-07-25 | 2016-12-21 | 华东师范大学 | A kind of based on the time-sequence rating rejecting outliers method accelerating near-end gradient PCA |
-
2019
- 2019-06-07 CN CN201980044631.4A patent/CN112368697A/en active Pending
- 2019-06-07 US US16/434,627 patent/US10510021B1/en active Active
- 2019-06-07 WO PCT/US2019/036057 patent/WO2019237000A1/en active Application Filing
Patent Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20120331025A1 (en) * | 2011-06-27 | 2012-12-27 | International Business Machines Corporation | Systems and methods for large-scale randomized optimization for problems with decomposable loss functions |
CN105160400A (en) * | 2015-09-08 | 2015-12-16 | 西安交通大学 | L21 norm based method for improving convolutional neural network generalization capability |
CN106250917A (en) * | 2016-07-25 | 2016-12-21 | 华东师范大学 | A kind of based on the time-sequence rating rejecting outliers method accelerating near-end gradient PCA |
Non-Patent Citations (1)
Title |
---|
YEN I E-H ET AL: ""Dual Decomposed Learning with Factorwise Oracles for Structural SVMs of Large Output Domain"", ADVANCES IN NEURAL INFORMATION PROCESSING SYSTEMS, vol. 29, pages 5030 - 5038, XP055616313 * |
Also Published As
Publication number | Publication date |
---|---|
US10510021B1 (en) | 2019-12-17 |
WO2019237000A1 (en) | 2019-12-12 |
US20190378037A1 (en) | 2019-12-12 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN112368697A (en) | System and method for evaluating a loss function or a gradient of a loss function via dual decomposition | |
US11163947B2 (en) | Methods and systems for multi-label classification of text data | |
Majumder et al. | 500+ times faster than deep learning: A case study exploring faster methods for text mining stackoverflow | |
WO2023000574A1 (en) | Model training method, apparatus and device, and readable storage medium | |
JP7360497B2 (en) | Cross-modal feature extraction method, extraction device, and program | |
Luo et al. | Online learning of interpretable word embeddings | |
EP3295381B1 (en) | Augmenting neural networks with sparsely-accessed external memory | |
Rae et al. | Fast parametric learning with activation memorization | |
US11562203B2 (en) | Method of and server for training a machine learning algorithm for estimating uncertainty of a sequence of models | |
WO2020198855A1 (en) | Method and system for mapping text phrases to a taxonomy | |
US20190065957A1 (en) | Distance Metric Learning Using Proxies | |
Grzegorczyk | Vector representations of text data in deep learning | |
US20240061889A1 (en) | Systems and Methods for Weighted Quantization | |
Yen et al. | Loss decomposition for fast learning in large output spaces | |
Das et al. | Group incremental adaptive clustering based on neural network and rough set theory for crime report categorization | |
CN114462605A (en) | Computer-readable recording medium storing inference program and inference method | |
Heuillet et al. | Efficient automation of neural network design: A survey on differentiable neural architecture search | |
Tian et al. | Chinese short text multi-classification based on word and part-of-speech tagging embedding | |
Yang et al. | ResMem: Learn what you can and memorize the rest | |
Madushanka et al. | MDNCaching: A strategy to generate quality negatives for knowledge graph embedding | |
Badriyah et al. | Deep learning algorithm for data classification with hyperparameter optimization method | |
Altinok et al. | Learning to rank by using multivariate adaptive regression splines and conic multivariate adaptive regression splines | |
Soleimani et al. | Fast PMI-based word embedding with efficient use of unobserved patterns | |
Schelter | Amnesia-a selection of machine learning models that can forget user data very fast | |
Waykar et al. | Intent aware optimization for content based lecture video retrieval using Grey Wolf optimizer |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |