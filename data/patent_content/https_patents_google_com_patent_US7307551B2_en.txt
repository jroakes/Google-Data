US7307551B2 - Delimiter lookup using processor permutation instruction - Google Patents
Delimiter lookup using processor permutation instruction Download PDFInfo
- Publication number
- US7307551B2 US7307551B2 US11/215,694 US21569405A US7307551B2 US 7307551 B2 US7307551 B2 US 7307551B2 US 21569405 A US21569405 A US 21569405A US 7307551 B2 US7307551 B2 US 7307551B2
- Authority
- US
- United States
- Prior art keywords
- character
- bit
- string
- permutation
- sixteen
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related, expires
Links
- 238000000034 method Methods 0.000 claims description 70
- 238000003491 array Methods 0.000 claims description 3
- 230000000295 complement effect Effects 0.000 claims 1
- 238000010586 diagram Methods 0.000 description 8
- 238000004590 computer program Methods 0.000 description 4
- 230000000694 effects Effects 0.000 description 4
- 238000013500 data storage Methods 0.000 description 3
- 230000000644 propagated effect Effects 0.000 description 3
- 101150064138 MAP1 gene Proteins 0.000 description 2
- 238000006243 chemical reaction Methods 0.000 description 2
- 230000009466 transformation Effects 0.000 description 2
- 230000006978 adaptation Effects 0.000 description 1
- 238000005352 clarification Methods 0.000 description 1
- 238000005206 flow analysis Methods 0.000 description 1
- 230000006698 induction Effects 0.000 description 1
- 238000005457 optimization Methods 0.000 description 1
- 238000012795 verification Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/903—Querying
- G06F16/90335—Query processing
- G06F16/90344—Query processing by using string matching techniques
Definitions
- the present invention relates generally to looking up delimiters within character strings, such as looking up extensible Markup Language (XML) delimiters within XML code, and more particularly to looking up such delimiters within character strings by using a processor permutation instruction, such as a single instruction stream multiple data stream (SIMD) processor permutation instruction.
- XML extensible Markup Language
- SIMD single instruction stream multiple data stream
- XML eXtensible Markup Language
- W3C World Wide Web Consortium
- HTML HyperText Markup Language
- HTML defines how elements are displayed
- XML defines what those elements contain.
- HTML allows tags to be defined by developers, and provides a common manner by which data can be identified.
- XML achieves such commonality in part by using human-readable plain text as the data format in which XML files are defined and formulated.
- plain text processing can be slower than processing other types of files.
- each character of an XML file may be represented by eight or sixteen bits, such that all of the bits of the character must usually be examined to determine whether the character is a desired character.
- desired character lookup is accomplished in relation to XML files in particular to search for delimiters.
- a delimiter is a character or a combination of characters used to separate one item or set of data from another. For example, in comma-delimited records, a comma is used to separate each field of data.
- An XML parser may have to determine the first position in which a given XML delimiter occurs within a character string that represents a section of XML code. For example, an XML parser may first have to locate a less than symbol, and then a greater than symbol, to locate the opening of a tag, and then may have to locate a less than symbol followed by a slash, and then a greater than symbol, to locate the closing of a tag.
- delimiter lookup is accomplished sequentially. For a given section of XML code—that is, for a given character string—each character is examined, and it is determined whether the character is a delimiter. If not, the next character is processed, and so on, until the entire character string has been processed. Such sequential character string processing to look up delimiters is slow, however. For this and other reasons, there is a need for the present invention.
- the present invention relates to delimiter lookup using a processor permutation instruction.
- a method of the invention defines a 256-bit bitmap, and stores the 256-bit bitmap within two sixteen-byte registers. Each bit of the bitmap represents an eight-bit character occurrable within a character string, such as a section of eXtensible Markup Language (XML) code, and has a value indicating whether the character is a target character, such as a delimiter.
- the character string has a number of eight-bit characters at a corresponding number of positions.
- the method determines the first position within the character string at which one of the target characters occurs, using the 256-bit bitmap and a processor permutation instruction. The method then outputs the first position within the character string at which one of the target characters occurs, as has been determined.
- Another method of the invention defines a low 256-bit bitmap and a high 256-bit bitmap representing 256 sixteen-bit characters occurrable within a character string, such as a section of XML code, and indicating whether the characters are target characters, such as delimiters.
- the character string has a number of sixteen-bit characters at a corresponding number of positions.
- the method determines the first position within the character string at which one of the target characters occurs, using the low and the high 256-bit bitmaps and a processor permutation instruction. The method then outputs this first position within the character string at which one of the target characters occurs, as has been determined.
- Another method of the invention receives a number of target characters, against which a character string having a number of characters at a corresponding number of positions is comparable to determine the first position within the character string at which one of the target characters occurs.
- the target characters may be delimiters, and the character string may be a section of XML code.
- the method constructs a table indexable by a number of characters.
- the table has a first value for each character that is one of the target characters, and has a second value for each character that is not one of the target characters.
- the table has a total number of bits less than a total number of bits of all the characters. For example, if there are 256 characters, and each character has eight bits, then the total number of bits of all the characters is 256 times eight, or 2048, whereas the table may have just 256 bits.
- the method then replaces first computer code effecting comparison of the character string against the target characters to determine the first position within the character string at which one of the target characters occurs with second computer code.
- the second computer code effects the comparison using the table constructed, as well as a processor permutation instruction.
- the processor permutation instruction may be a single instruction stream multiple data stream (SIMD) processor permutation instruction, such as that found in the ALTIVEC, VELOCITY ENGINE, or VMX SIMD processor instruction set.
- SIMD single instruction stream multiple data stream
- Embodiments of the invention provide for performance advantages over the prior art.
- delimiter lookup has been found to increase from about twenty percent to about eighty percent, using a PowerPC 970 reduced instruction set computer (RISC) processor.
- RISC PowerPC 970 reduced instruction set computer
- FIG. 1 is a diagram of a processor permutation instruction, according to an embodiment of the invention.
- FIG. 2 is a block diagram of sample inefficient delimiter lookup code, according to an embodiment of the invention.
- FIG. 3 is a flowchart of a method for efficiently looking up delimiters, or target characters, within character strings made up of characters of eight bits in length, according to an embodiment of the invention.
- FIG. 4 is a diagram of example efficient delimiter lookup code for eight-bit characters, according to an embodiment of the invention.
- FIG. 5 is a diagram of an example 256-bit bitmap that can be used in conjunction with the method of FIG. 3 and the code of FIG. 4 , where each bit of the bitmap represents an eight-bit character and has a value indicating whether the character is a target character (i.e., a delimiter), according to an embodiment of the invention.
- a target character i.e., a delimiter
- FIG. 6 is a flowchart of a method for efficiently looking up delimiters, or target characters, within character strings made up of characters of sixteen bits in length, according to an embodiment of the invention.
- FIG. 7 is a diagram of example efficient delimiter lookup code for sixteen-bit characters, according to an embodiment of the invention.
- FIG. 8 is a diagram of an example low 256-bit bitmap and an example high 256-bit bitmap that can be used in conjunction with the method of FIG. 6 and the code of FIG. 7 , according to an embodiment of the invention.
- FIG. 9 is a diagram showing how a processor permutation instruction can be used in conjunction with the method of FIG. 6 and the code of FIG. 7 , according to an embodiment of the invention.
- FIG. 10 is a flowchart of a method for generating computer code that employs a processor permutation instruction to determine the first position within a string of characters that contains a target character, or delimiter, according to an embodiment of the invention.
- FIG. 11 is a diagram of example code to generate a conversion table for use by the computer code generated in the method of FIG. 10 , according to an embodiment of the invention.
- Embodiments of the invention employ a processor permutation, or permute, instruction, to perform target character or delimiter lookup.
- the processor permutation instruction may be a single instruction stream multiple data stream (SIMD) processor permutation instruction, such as that found in the ALTIVEC, VELOCITY ENGINE, or VMX SIMD processor instruction set.
- FIG. 1 shows an example of such a processor permutation instruction 100 , according to an embodiment of the invention.
- the processor permutation instruction 100 receives three sixteen-byte inputs 102 , 104 , and 106 , corresponding to vA, vB, and vC in FIG. 1 , and returns a sixteen-byte output 108 , corresponding to vD in FIG. 1 .
- the processor permutation instruction 100 allows any byte under the control of vC within two source registers vA and vB to be copied to a destination register vC. That is, each element of the result is selected independently by indexing the byte elements of vA and vB by the value of the corresponding element of vC.
- the vperm instruction takes the contents of vA and concatenates the contents of vB forming a 32 byte (0 . . . 1F) temporary value. Based on the value stored in each one of the sixteen eight-bit fields of vC, the corresponding byte of the temporary value is copied into the corresponding eight-bit field of vD.
- the resulting value that is placed into vD has the same value as vC because the data stored in vA and vD was generated to show the 32 bytes 0 . . . 1F for clarification purposes.
- the left-most eight bits of vC has the value of 0x01.
- the byte 0x01 is taken and placed into the left-most eight bits ( 0 : 7 ) of vD.
- the next eight bits of vC contain the value 0x14.
- the value of byte 20 (0x14) is taken and placed int original the next eight bits ( 8 : 15 ) of vD.
- the processor permutation instruction 100 may thus be considered a processor, or hardware, instruction that implements the following code:
- FIG. 2 shows sample inefficient delimiter lookup code 200 , according to an embodiment of the invention.
- the code 200 does not utilize a processor permutation instruction, and is described to provide a baseline reference against code that does utilize a processor permutation instruction and thus that is more efficient than the code 200 .
- each of 256 characters is represented within the table array.
- the table array has a value of 1 to indicate that the corresponding character is not a delimiter, or target character, and has a value of 0 (or more, generally, a value other than 1) to indicate that the corresponding character is a delimiter.
- the table array is thus indexable by the characters, and returns values indicating whether the characters are delimiters or not. For example, for the character N, the value table[N] indicates whether this character is a delimiter or not.
- the code 200 returns the position of a delimiter that occurs first in the character string data[ ].
- the character string data[ ] may be a section of eXtensible Markup Language (XML) code, for instance.
- the code 200 sequentially examines each character within the character string, and if it finds a character that has the value 0x01, returns the position of that character within the character string. Such sequential processing to determine the first occurrence of a delimiter or other target character within a character string is inefficient, however.
- Embodiments of the invention are thus concerned with optimizing the code 200 so that it performs efficiently, by using a processor permutation instruction like the processor permutation instruction 100 of FIG. 1 .
- each character is represented by a single eight-bit byte.
- characters may also be represented as sixteen bits, or two eight-bit bytes, such as Unicode characters, or double-byte character set (DBCS) characters. Therefore, another embodiment of the invention is described that is concerned with optimizing the code 200 where each character is represented by sixteen bits, or two eight-bit bytes.
- a third embodiment of the invention is then described that is concerned with converting unoptimized code, such as the code 200 , to optimized code 200 that utilizes a processor permutation instruction to speed delimiter or target character lookup.
- FIG. 3 shows a method 300 for efficiently looking up delimiters, or target characters, within character strings made up of characters of eight bits in length, according to an embodiment of the invention.
- the method 300 may be implemented by a computer program stored on a computer-readable medium, such as a recordable data storage medium, or a modulated carrier signal.
- FIG. 4 shows example efficient delimiter lookup code 400 , according to an embodiment of the invention, for efficient lookups of delimiters within character strings of eight-bit characters, and which at least partially implements the method 300 of FIG. 3 .
- FIG. 5 shows the conversion 500 of a 256-byte array to an example 256-bit bitmap that can be used in conjunction with the code 400 of FIG. 4 and the method 300 of FIG. 3 , according to an embodiment of the invention.
- FIGS. 3 , 4 , and 5 are described together.
- the method 300 begins by defining a 256-bit bitmap ( 302 ).
- Each bit of the bitmap represents an eight-bit character that is occurrable within a character string having a number of eight-bit characters at a corresponding number of positions.
- the value of each bit indicates whether or not the character is a target character, or delimiter.
- the 256-byte array table 502 indicates whether each of 256 characters is a delimiter or target character, by having a value other than one, or a non-delimiter or non-target character, by having a value of one.
- the table 502 is the table that can be used in conjunction with the code 200 of FIG. 2 , for instance.
- the table 502 is converted to the 256-bit, 32-byte bitmap 504 .
- the bitmap 504 has one bit for each character code to indicate if the character is a delimiter or not, such that the bit has a value of one if the character is a delimiter (i.e., a target character), and a value of zero if the character is not a delimiter (i.e., not a target character).
- the 256-bit bitmap is stored within two sixteen-byte registers ( 304 ). This is shown in FIG. 5 , in which the 256-bit bitmap is specifically stored in two sixteen-byte registers map 0 and map 1 . Each of these registers is specifically a variable type of sixteen unsigned one-byte integer-type vector forms.
- the first position within the character string at which a target character (or delimiter) occurs is then determined, using the 256-bit bitmap that has been defined, and using a processor permutation instruction ( 306 ).
- the performance of the part 306 of the method 300 may in one embodiment be accomplished by performing the parts 308 , 310 , 312 , 314 , and 316 , and as depicted in the example code 400 of FIG. 4 .
- the character string may be a section of extensible Markup Language (XML) code, and each target character may be an XML delimiter.
- XML extensible Markup Language
- each character of the character string is shifted by a number of bits ( 308 ).
- line 4 of the code 400 indicates that each character of the character string is shifted by three bits to the right—via the constant vec — 0x03 defined in line 2 —to yield the left most five bits of each character of the character string vchars defined in line 1 .
- the 256-bit bitmap and the character string as shifted are input into the processor permutation instruction to yield a permutation result string ( 310 ).
- line 4 of the code 400 shows that the 256-bit bitmap, represented by the two sixteen-byte registers map 0 and map 1 , as well as the three-bit-shifted-to-the-right version of the character string vchars is input into the processor permutation instruction vec_perm, which may be the instruction 100 of FIG. 1 that has been described.
- the permutation result string is the value vbytes.
- each character of the permutation result string is shifted by a number of bits as well ( 312 ).
- line 5 of the code 400 indicates that each character of the permutation result string is shifted by the bits of the character string itself. The result is that one bit value can be used to show whether or not each character is a delimiter, specifically the most significant bit of each byte of the sixteen-byte permutation result string vbytes.
- any character of the permutation result string has this predetermined bit set ( 314 ), and if so, then the first character within the permutation result string that has this predetermined bit set is located as corresponding to the first position within the character string at which one of the target characters (i.e., one of the delimiters) occurs ( 316 ).
- line 6 of the code 400 compares each byte of the permutation result string vbytes to the value 0x80, via the constant vec — 0x80 defined in line 3 , to determine whether any of the bytes of the permutation result string has the predetermined bit set, specifically the most significant bit 0x80.
- Line 7 of the code 400 represents the processing for finding the first character within the permutation result string that has this predetermined bit set, which may be accomplished in any of a number of different conventional ways. For instance, one bit from each byte of the permutation result string may be extracted and compared, using the count leading zero (cntlz) processor instruction.
- the first position of the character string within which a target character occurs is finally output ( 318 ).
- output may include providing this first position to another computer program, or simply displaying it to the user on a display device, or printing it on a sheet of paper or other media. That is, embodiments of the invention are not limited by the output in the part 318 of the method 300 of FIG. 3 .
- the method 300 of FIG. 3 and the code 400 of FIG. 4 employs permutation operation and two shifting operation, which makes delimiter or target character lookup an efficient, high-speed process.
- the method 300 does create a bitmap that is utilized in the code 400 , but the bitmap may be created statically beforehand, so that it does not contribute to the processing of delimiter or target character lookup.
- the method 300 and the code 400 have been described as assuming that the most significant five bits of each character are used to index a byte within the 32-byte (256-bit) table or bitmap, and the less significant three bits used to locate the position of the predetermined (most significant) bit within the byte. However, this was accomplished for example purposes, and other arrangements may be employed. For instance, the least significant five bits within a character may be used to locate a byte within the table, and the most significant three bits may be used to locate the predetermined bit within the bit, with a corresponding transformation of the lookup table.
- the approach that has been described in this section of the detailed description converts a 256-byte length table array into a 256-bit length bitmap, which contains one bit of information for each character to indicate whether or nor the character is a delimiter.
- This leads to higher-speed processing of the delimiter lookup, using a processor permutation instruction.
- the processor permutation instruction allows for the 32-byte table (i.e., the 256-bit bitmap) to be freely rearranged in accordance with a designated pattern. Accordingly, processing speed is increased significantly.
- FIG. 6 shows a method 600 for efficiently looking up delimiters, or target characters, within character strings made up of characters of sixteen bits in length, according to an embodiment of the invention.
- the method 600 may be implemented by a computer program stored on a computer-readable medium, such as a recordable data storage medium, or a modulated carrier signal.
- FIG. 7 shows example efficient delimiter lookup code 700 , according to an embodiment of the invention, for efficient lookups of delimiters within character strings of sixteen-bit characters, and which at least partially implements the method 600 of FIG. 6 .
- FIG. 8 shows an example low 256-bit bitmap and an example high 256-bit bitmap that can be used in conjunction with the code 700 of FIG. 7 and the method 600 of FIG. 6 , according to an embodiment of the invention.
- FIG. 9 shows how a processor permutation instruction can be used in conjunction with the code 700 of FIG. 7 and the method 600 of FIG. 6 , according to an embodiment of the invention.
- FIGS. 6 , 7 , 8 , and 9 are now described together. However, it is noted that those of ordinary skill within the art can recognize the similarity between the methods 600 of FIG. 6 and 300 of FIG. 3 , and the codes 700 of FIG. 7 and 400 of FIG. 4 , which are further highlighted herein. Therefore, the discussion that has been made in relation to FIGS. 3 and 4 is also applicable to at least some extent to FIGS. 6 and 7 here, and is not repeated at length to avoid redundancy.
- the method 600 begins by defining a low 256-bit bitmap and a high 256-bit bitmap ( 602 ).
- the two bitmaps represent 256 sixteen-bit characters occurrable within a character string having a number of sixteen-bit characters at a corresponding number of positions, and indicate whether the characters are target characters (i.e., delimiters).
- a character code set has such characters that are sixteen bits, or two bytes, in length, such as the (Universal Transformation Format) UTF-16, or another character code set
- a bitmap as used in the previous embodiment of the invention, as described in the previous section of the detailed description would have 8,192 bits, which is too long for efficient processing.
- bitmap 802 stored over two sixteen-byte values map_lo 0 and map_lo 1
- a high 256-bit bitmap 804 stored over two sixteen-byte values map_hi 0 and map_hi 1 .
- These bitmaps are generated from a table with 65,536 entries as follows. First, the i-th bit is set to one in the low 256-bit bitmap where there is even a single delimiter, or target character, where the lower byte of this character is i. Otherwise, the i-th bit of the. low 256-bit bitmap is set to zero.
- the i-th bit is set to one in the high 256-bit bitmap where there is even a single delimiter, or target character, where the upper byte of this character is.i. Otherwise, the i-th bit of the high 256-bit bitmap is set to zero.
- each i-th bit of the low 256-bit bitmap has a first value where any sixteen-bit target character has a lower eight bits equal to i. Otherwise, the i-th bit in question has a second value.
- each i-th bit of the high 256-bit bitmap has the first value where any sixteen-bit target character has an upper eight bits equal to i. Otherwise, the i-th bit in question has the second value.
- the first position within the character string at which a target character (or delimiter) occurs is then determined, using the two 256-bit bitmaps that have been defined, and using a processor permutation instruction ( 604 ).
- the performance of the part 604 of the method 600 may in one embodiment be accomplished by performing the parts 606 , 608 , 610 , 612 , 614 , 616 , 618 , and 620 , and as depicted in the example code 700 of FIG. 7 .
- the character string may be a section of eXtensible Markup Language (XML) code, and each target character may be an XML delimiter.
- XML eXtensible Markup Language
- two sixteen-byte values representing the character string and the sixteen-byte value ⁇ 0x00, 0x02, 0x04, . . . , 0x1C, 0x1E ⁇ are input into the processor permutation instruction to yield a first high permutation result string ( 606 ).
- the two sixteen-byte values representing the character string and the sixteen-byte value ⁇ 0x01, 0x03, 0x05, . . , 0x1D, 0x1F ⁇ are input into the processor permutation instruction to yield a first low permutation result string ( 608 ).
- lines 3 and 4 of the code 700 implement the parts 606 and 608 of the method 600 of FIG. 6 , respectively.
- the values vchars 1 and vchars 2 are sixteen bytes each in length, and represent sixteen two-byte (sixteen-bit) characters of the character string.
- the character string is transformed into the first high permutation result string vchars_hi, via a permutation guided by the constant vec_pack_hi, which is the sixteen-byte value ⁇ 0x00, 0x02, 0x04, . . . , 0x1C, 0x1E ⁇ as indicated by line 1 .
- the character string is transformed into the first low permutation result string vchars_lo, via a permutation guided by the constant vec_pack_lo, which is the sixteen-byte value ⁇ 0x01, 0x03, 0x05, . . . , 0x1D, 0x1F ⁇ as indicated by line 2 .
- FIG. 9 illustratively shows the permutation 900 effected by lines 3 and 4 of the code 700 , as implementing the parts 606 and 608 of the method 600 .
- lines 3 and 4 what is accomplished in lines 3 and 4 is that the high bytes of the two-byte (sixteen-bit) characters of the character strings are extracted to the first high permutation result string vchars_hi, and the low bytes of these characters are extracted to the first low permutation result string vchars_lo, as indicated by the permutation 900 in FIG. 9 .
- the code 700 of FIG. 7 presumes that the characters of the character string are encoded in a big-endian format, but alternatively they may be encoded in a little-endian format.
- the high-256 bit bitmap and a bit-shifted version of the first high permutation result string are input into the processor permutation instruction to yield a second high permutation result string ( 610 ).
- the low 256-bit bitmap and a bit-shifted version of the first low permutation result string are input into the process permutation instruction to yield a second low permutation result string ( 612 ).
- the second high permutation result string and the second low permutation result string are then bit-shifted themselves ( 614 ).
- line 5 of the code 700 implements the part 610 of the method 600
- line 6 implements the part 612
- lines 7 and 8 implement the part 614 .
- the bit-shifted version of the first high permutation result string vchars_hi in line 5 is a shifting of each character of this result string by three bits to the right.
- the bit-shifted version of the first low permutation result string vchars_lo in line 6 is a shifting of each character of this result string by three bits to the right.
- the constant vec — 0x03 is the same constant defined in line 2 of the code 400 of FIG. 4 that has been described. Lines 5 and 6 of the code 700 may be considered as corresponding to line 4 of the code 400 in effect.
- Lines 7 and 8 of the code 700 may be considered as corresponding to line 5 of the code 400 of FIG. 4 in effect.
- the second high permutation result string is logically AND'ed with the second low permutation result string to yield a third permutation result string ( 616 ), and whether any character of the third permutation result string has a predetermined bit set is determined ( 618 ). If so, and if there is not a false hit, then the first character within the third permutation result string that has the predetermined bit set is located as corresponding to the first position within the character string at which one of the target characters occurs ( 620 ). This first position determined is then output ( 622 ), as has been described in more detail in relation to the part 318 of the method 300 of FIG. 3 .
- line 9 of the code 700 is the logically AND'ing of the second high and the second low permutation result strings to yield the third permutation result string vbits.
- the logically AND'ing process is described by the operation vec_and.
- Line 10 corresponds to whether any character of the third permutation result string has a predetermined bit set, specifically a most significant bit 0x80, via the constant vec — 0x80 that is the same as that defined in line 3 of the code 400 of FIG. 4 .
- Line 10 of the code 700 thus corresponds in effect to line 6 of the code 400 of FIG. 4 .
- the code 700 of FIG. 7 and therefore the method 600 of FIG. 6 —does not obviate the need of a table to be accessed to determine if a given character of a character string is a delimiter (target character) or not.
- the code 700 does reduce how often such a table is accessed, and therefore increases processing speed. That is, the number of times the table is accessed to evaluate whether a character is a delimiter or not is significantly reduced, increasing processing speed.
- FIG. 10 shows a method 1000 for generating computer code to utilize a processor permutation instruction to locate the first position within a character string that includes a target character, according to an embodiment of the invention.
- the method 1000 may be implemented by a computer program stored on a computer-readable medium, such as a recordable data storage medium, or a modulated carrier signal.
- the method 1000 may be used to generate the computer code 400 of FIG. 4 or the computer code 600 of FIG. 6 , for instance.
- the method 1000 begins by receiving a number of target characters ( 1102 ).
- the target characters are those against which a character string having a number of characters at a corresponding number of positions is to be compared to determine the first position within the character string at which one of the target characters occurs.
- the method 1000 then constructs a table indexabIe by the target characters ( 1004 ). Examples of the table include those depicted in FIGS. 5 and 8 , for instance.
- the table has a first value for each character that is one of the target characters, and a second value for each character that is not one of the target characters.
- the table has a total number of bits less than the total number of bits of the characters themselves. For instance, where each character has eight bits, and there are 256 characters, the table may have just 256 bits, whereas the characters in total have eight times 256, or 2048, bits.
- the table may be a number of arrays in one embodiment of the invention.
- FIG. 11 shows computer code 1100 that can be employed to generate the table in the part 1004 of the method 1000 of FIG. 10 , according to an embodiment of the invention.
- the computer code 1100 examines if statements within loops in first computer code that is to be optimized that may fall in one of four categories. First, such computer code in which there is comparison of a value within a lookup target array and a constant. Second, computer code in which there is a comparison of a value obtained through some processing based on a value within the lookup target array and a constant. Third, computer code in which there is comparison of an induction variable of the loop—i.e., an index of the lookup target array—and an invariable value within the loop. And, fourth, other types of computer code.
- a set of values to be extracted from the lookup target array is prepared within each block in the loop.
- a value within the loop target array to leave the loop is found, such as by using a forward data flow analysis where the union set is determined at a confluence.
- An if statement belonging to the first category takes the product set of a set, where the path-taken or the path-not-taken value is extracted, and a set of the input of a block including the if statement is propagated.
- An if statement belonging to the second category is judged as to whether or not a set of values within the lookup target array meets the condition of the if statement is specifiable.
- the loop is not optimized, and no table is constructed, and otherwise, it can be replaced with a loop of the first category. That is, the product set of a set where the path-taken or the path-not-taken value is extracted, and a set of the input of a block including the if statement is propagated.
- An if statement belongs to the third category propagates the empty set to an edge outside of the loop, and otherwise a set of the path-taken or the path-not-taken value is extracted.
- a set of values extracted for the array and the union set of the set of values extracted for the array are determined at the location of a loading instruction from the arrays targeted for if statements, and propagated forward. Therefore, it is possible to determine a set of values that can be extracted from the lookup target array, to escape the loop.
- the method 1000 concludes by replacing first computer code with second computer code to determine the first position at which a character string contains one of the target characters ( 1006 ).
- the first computer code does not utilize a processor permutation instruction to achieve this determination, whereas the second computer code does.
- the second computer code also utilizes the table that has been constructed.
- the part 1006 is performed by replacing the computer code 200 of FIG. 2 with the computer code 400 of FIG. 4 .
- the replacement may be performed by simply scanning the first computer code for the computer code 200 , and replacing it with second computer code including the computer code 400 .
Abstract
Description
do i =0 to 15 | ||
j | ||
if c{i}[3] == 0 |
then d{i} | |
else d{i} |
end | ||
Sample Inefficient Delimiter Lookup Code
Claims (20)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US11/215,694 US7307551B2 (en) | 2005-08-30 | 2005-08-30 | Delimiter lookup using processor permutation instruction |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US11/215,694 US7307551B2 (en) | 2005-08-30 | 2005-08-30 | Delimiter lookup using processor permutation instruction |
Publications (2)
Publication Number | Publication Date |
---|---|
US20070046505A1 US20070046505A1 (en) | 2007-03-01 |
US7307551B2 true US7307551B2 (en) | 2007-12-11 |
Family
ID=37803352
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/215,694 Expired - Fee Related US7307551B2 (en) | 2005-08-30 | 2005-08-30 | Delimiter lookup using processor permutation instruction |
Country Status (1)
Country | Link |
---|---|
US (1) | US7307551B2 (en) |
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8259734B2 (en) | 2009-02-27 | 2012-09-04 | Huawei Technologies Co., Ltd. | Method and device for sending upstream transfer frame in passive optical network |
Families Citing this family (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN112200286B (en) * | 2020-08-25 | 2023-10-03 | 中国物品编码中心 | Character string coding method and device |
CN116932838B (en) * | 2023-09-13 | 2023-11-24 | 浙江寰福科技有限公司 | Database-based data query, update and storage method and device |
Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5889746A (en) * | 1996-03-25 | 1999-03-30 | Pioneer Ldc, Inc. | Information recording medium, apparatus for recording the same and apparatus for reproducing the same |
-
2005
- 2005-08-30 US US11/215,694 patent/US7307551B2/en not_active Expired - Fee Related
Patent Citations (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5889746A (en) * | 1996-03-25 | 1999-03-30 | Pioneer Ldc, Inc. | Information recording medium, apparatus for recording the same and apparatus for reproducing the same |
US6067282A (en) * | 1996-03-25 | 2000-05-23 | Pioneer Electronic Corporation | Information recording medium, apparatus for recording the same and apparatus for recording the same |
Non-Patent Citations (3)
Title |
---|
Ben Gibbs et al., vperm description, IBM eserver BladeCenter JS20 PowerPC 970 Programming Environment Redpaper, pp. 48-49, Jan. 2005. |
vec<SUB>-</SUB>perm description, AltiVec Technology Programming Interface Manual, p. 4-84, copyright 1999. |
Zhijie Shi et al., Subword Sorting with Versatile Permutation Instructions, Procs. of ICCD 2002 Int'l Conf. on Computer Design, pp. 234-241 (Sep. 2002). |
Cited By (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8259734B2 (en) | 2009-02-27 | 2012-09-04 | Huawei Technologies Co., Ltd. | Method and device for sending upstream transfer frame in passive optical network |
US8331379B2 (en) | 2009-02-27 | 2012-12-11 | Huawei Technologies Co., Ltd. | Method and device for sending upstream transfer frame in passive optical network |
US9054811B2 (en) | 2009-02-27 | 2015-06-09 | Huawei Technologies Co., Ltd. | Method and device for sending upstream transfer frame in passive optical network |
Also Published As
Publication number | Publication date |
---|---|
US20070046505A1 (en) | 2007-03-01 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9218319B2 (en) | Method and apparatus for regular expression processing with parallel bit streams | |
US7783862B2 (en) | Method and apparatus for an inductive doubling architecture | |
US20080040345A1 (en) | Method and Apparatus for String Search Using Parallel Bit Streams | |
AU2003243169B2 (en) | System and method for processing of XML documents represented as an event stream | |
US20080033974A1 (en) | Method and Apparatus for XML Parsing Using Parallel Bit streams | |
US7287217B2 (en) | Method and apparatus for processing markup language information | |
US5752020A (en) | Structured document retrieval system | |
US7802180B2 (en) | Techniques for serialization of instances of the XQuery data model | |
US7512634B2 (en) | Systems and methods for processing regular expressions | |
US7400271B2 (en) | Method and apparatus for processing character streams | |
US20050273772A1 (en) | Method and apparatus of streaming data transformation using code generator and translator | |
US20030204584A1 (en) | Apparatus and method for pattern matching in text based protocol | |
US20050257201A1 (en) | Optimization of XPath expressions for evaluation upon streaming XML data | |
US8386530B2 (en) | Systems and methods for processing regular expressions | |
US20130055065A1 (en) | Validation based on decentralized schemas | |
US20020170041A1 (en) | Retrieval of symbol attributes | |
US20180267802A1 (en) | Parsing-enhancement facility | |
US7275069B2 (en) | System and method for tokening documents | |
US7307551B2 (en) | Delimiter lookup using processor permutation instruction | |
US9477778B2 (en) | XML query optimization with order analysis of XML schema | |
WO2005111824A2 (en) | Method and system for processing of text content | |
US7461370B2 (en) | Fast hardware processing of regular expressions containing sub-expressions | |
Gagie et al. | Katka: A kraken-like tool with k given at query time | |
Mrykhin et al. | The hardest LL (k) language | |
Dörband et al. | Approximated determinisation of weighted tree automata |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:INOUE, HIROSHI;MORIYAMA, TAKAO;KAWAHITO, MOTOHIRO;AND OTHERS;REEL/FRAME:016952/0674Effective date: 20050830 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026664/0866Effective date: 20110503 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYFree format text: PAYER NUMBER DE-ASSIGNED (ORIGINAL EVENT CODE: RMPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |
|
FEPP | Fee payment procedure |
Free format text: MAINTENANCE FEE REMINDER MAILED (ORIGINAL EVENT CODE: REM.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
LAPS | Lapse for failure to pay maintenance fees |
Free format text: PATENT EXPIRED FOR FAILURE TO PAY MAINTENANCE FEES (ORIGINAL EVENT CODE: EXP.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20191211 |