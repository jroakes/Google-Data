US8407466B2 - Controlling download and playback of media content - Google Patents
Controlling download and playback of media content Download PDFInfo
- Publication number
- US8407466B2 US8407466B2 US13/280,050 US201113280050A US8407466B2 US 8407466 B2 US8407466 B2 US 8407466B2 US 201113280050 A US201113280050 A US 201113280050A US 8407466 B2 US8407466 B2 US 8407466B2
- Authority
- US
- United States
- Prior art keywords
- content
- encrypted
- client
- key
- decryption
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
- 238000000034 method Methods 0.000 claims abstract description 31
- 238000013478 data encryption standard Methods 0.000 claims description 9
- 238000004590 computer program Methods 0.000 claims description 6
- 230000006837 decompression Effects 0.000 abstract description 10
- 238000012546 transfer Methods 0.000 abstract description 7
- 238000010586 diagram Methods 0.000 description 12
- 230000015654 memory Effects 0.000 description 10
- 230000006870 function Effects 0.000 description 6
- 238000004891 communication Methods 0.000 description 4
- 238000013461 design Methods 0.000 description 4
- 230000008569 process Effects 0.000 description 4
- 230000001010 compromised effect Effects 0.000 description 3
- 230000007246 mechanism Effects 0.000 description 3
- 230000008901 benefit Effects 0.000 description 2
- 230000005540 biological transmission Effects 0.000 description 2
- 230000001413 cellular effect Effects 0.000 description 2
- 230000003287 optical effect Effects 0.000 description 2
- 238000012545 processing Methods 0.000 description 2
- 238000009877 rendering Methods 0.000 description 2
- 241001347978 Major minor Species 0.000 description 1
- 230000009471 action Effects 0.000 description 1
- 238000013459 approach Methods 0.000 description 1
- 230000009286 beneficial effect Effects 0.000 description 1
- 238000009795 derivation Methods 0.000 description 1
- 230000000977 initiatory effect Effects 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 230000008520 organization Effects 0.000 description 1
- 230000004044 response Effects 0.000 description 1
- 239000000126 substance Substances 0.000 description 1
- 238000010200 validation analysis Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/10—Protecting distributed programs or content, e.g. vending or licensing of copyrighted material ; Digital rights management [DRM]
Definitions
- the present invention relates to security for media content and, more specifically, to controlling download and playback of media content.
- the present invention provides various embodiments of methods and systems for controlling download and playback of media content.
- the system includes a client and a server, which are connected by a network.
- the client can play content.
- the server includes a permission system that can determine whether a request from the client to download or play content should be granted.
- the client-server system is designed so that all purchase, download, and playback requests require permission from the permission system. This requires the client to be connected to the server (via the network) for all such operations.
- the advantage of this design is that all of the rules used for permission are maintained with the permission system and therefore can be readily updated and changed as needed (e.g., to improve security, install business logic particular to a content owner, or adapt to newly-discovered fraud tactics).
- the permission system can thus be updated or revised, and the newly-installed operations and rules are thus applied to all transactions by all clients. Because the permission system is secure, its operations are less subject to attack by malicious parties.
- the server also includes a DD module system that transfers a DD module to the client.
- the DD module includes a content key decryption module, a content decryption module, and a content decompression module.
- the content key decryption module decrypts an encrypted content key that was received from the server.
- the decryption uses a unique DD module key that has been hard-coded into the content key decryption module.
- the content decryption module uses the content key to decrypt encrypted content.
- the content decompression module decompresses compressed content so that it can be played.
- Various levels of encryption operate to prevent malicious attacks on the client and the content.
- the content key cannot be extracted without the DD module key.
- an attack on an encrypted content key is also substantially prevented.
- the DD module key can only be used with that particular DD module and its copies. Because of the very large number of different DD modules, the attacker would have no way of knowing with which other DD modules to use the ill-gotten DD module key, thereby rendering the DD module key essentially useless.
- FIG. 1 is a block diagram illustrating a client-server architecture for transferring and playing media content, according to one embodiment of the invention.
- FIG. 2 is a message diagram illustrating the messages sent between various components of the system shown in FIG. 1 in order to purchase content, according to one embodiment of the invention.
- FIG. 3 is a message diagram illustrating the messages sent between various components of the system shown in FIG. 1 in order to initiate downloading content, according to one embodiment of the invention.
- FIG. 4 is a message diagram illustrating the messages sent between various components of the system shown in FIG. 1 in order to resume downloading content, according to one embodiment of the invention.
- FIG. 5 is a block diagram illustrating a decryption-decompression (DD) module, according to one embodiment of the invention.
- FIG. 6 is a message diagram illustrating the messages sent between various components of the system shown in FIG. 1 in order to play content, according to one embodiment of the invention.
- Media content refers to video, audio, or still images (or any combination thereof) in any format.
- a media content file can also include descriptive metadata, either encoded with the file or in a separate but associated file.
- a common example of media content is a video article including two portions—one video portion and one audio portion. However, the techniques described herein can be used with any number of file portions.
- FIG. 1 is a block diagram illustrating a client-server architecture for transferring and playing media content, according to one embodiment of the invention.
- the architecture 100 includes a client 110 , a server 120 , and a network 130 . Although only one client 110 is shown for clarity, the architecture 100 can support a large number of concurrent sessions with many clients 110 .
- the client 110 includes a first component for displaying a user interface that enables a user to specify a media content item (such as a video clip, audio clip, or still image) for transfer from the server 120 to the client 110 via the network 130 .
- the first component is a web browser software application 140 .
- the web browser 140 displays web pages and receives user input.
- the client 110 also includes a second component for playing a media content item.
- the second component is a software application referred to as a player 145 and includes, for example, the Google Video Player from Google Inc. of Mountain View, Calif.
- the player 145 supports automatic updating over the network 130 in order to enhance security and functionality. The player 145 will be further discussed below with reference to FIG. 5 .
- the client 110 receives messages from and sends messages to the network interface 150 .
- a received message is a HyperText Transfer Protocol (HTTP) message that contains a web page, such as a web page that enables a user to select a media content item.
- HTTP HyperText Transfer Protocol
- One example of a sent message is an HTTP message that contains a content identifier (content ID). The content ID identifies a particular content item that the user wants to be transferred to the client 110 .
- content ID content identifies a particular content item that the user wants to be transferred to the client 110 .
- Other messages will be described below with reference to FIGS. 2 , 3 , 4 , and 6 .
- the client also includes a network interface 150 for communicating with the network 130 and with the server 120 (via the network 130 ).
- the network interface 150 is configured to communicate using protocols such as Transmission Control Protocol (TCP)/Internet Protocol (IP).
- TCP Transmission Control Protocol
- IP Internet Protocol
- the network interface 150 can support additional communication protocols, such as wireless protocols (e.g., cellular, Bluetooth, IEEE 802.11, IEEE 802.16, and the like).
- wireless protocols e.g., cellular, Bluetooth, IEEE 802.11, IEEE 802.16, and the like.
- the web browser 140 and the player 145 are communicatively coupled to the network interface 150 .
- the client 110 is any type of computing device, such as a workstation, a desktop computer, a laptop computer, a tablet computer, a personal digital assistant (PDA), a cellular phone, or any other type of computing device.
- the client 110 is of conventional design and includes a processor, an addressable memory, and other conventional features such as a display, local memory, and input/output ports (not illustrated).
- One or more of the components of the client 110 can be located remotely and accessed via a network.
- the client 110 can be implemented on a device running any of a number of operating systems, such as Linux, UNIX, an operating system from Microsoft Corporation of Redmond, Wash., Apple Computer, Inc. of Cupertino, Calif., or Palm Source, Inc. of Sunnyvale, Calif., and/or other operating systems.
- the server 120 is a logical grouping that includes various back-end components.
- the back-end components include a front-end system 155 , a login system 160 , a checkout system 165 , a permission system 170 , a content system 175 , a key system 180 , and a decryption-decompression (DD) module system 185 .
- the components can be implemented as a single device or as multiple computer devices such as computer processors and associated storage devices. Examples of devices include servers, mainframe computers, networked computers, processor-based devices, and similar types of systems and devices.
- the server 120 includes one or more high-performance server-class computers.
- the back-end components are communicatively coupled to each other and to the network 130 .
- the server 120 and its associated devices need not be physically co-located, and there need not be any predefined mapping between storage devices and server computers.
- the server processor can be any of a number of computer processors, such as processors from Intel Corporation of Santa Clara, Calif. and Motorola Corporation of Schaumburg, Ill. In one embodiment, the server 120 has sufficient processing power and bandwidth to perform the tasks described herein.
- the network 130 communicatively couples the client 110 and the server 120 .
- the network 130 includes a partially-public or wholly-public network such as the Internet.
- the network 130 includes a private network or one or more distinct or logical private networks (e.g., virtual private networks or local area networks). Communication links to and from the network 130 can be wired or wireless (e.g., terrestrial- or satellite-based transceivers).
- the network 130 is a packet-switched network such as an IP-based wide or metropolitan area network that uses the Ethernet protocol.
- the front-end system 155 generates a media pointer.
- a media pointer is a file that enables the player 145 to retrieve a particular content item from the server 120 .
- the media pointer includes a Uniform Resource Locator (URL), the content ID (“docid”) of the content item, the duration of the content item (e.g., in seconds or milliseconds), the title of the content item, and the description of the content item.
- URL Uniform Resource Locator
- content ID (“docid”) of the content item
- the duration of the content item e.g., in seconds or milliseconds
- the title of the content item e.g., in seconds or milliseconds
- the description of the content item e.g., a media pointer.
- Google Video Pointer e.gvp file
- the “contentsystem” portion of the URL represents the address of the content system 175 .
- the URL includes four variables: secureurl, begin, len, and docid.
- secureurl which is set to “encrypteddata,” identifies encrypted data, as explained below.
- the “begin” variable which is set to 0, identifies the beginning of the requested portion of the content item (e.g., as an offset in seconds or milliseconds).
- the “len” variable which is set to 196129, identifies the length of the requested portion of the content item (e.g., in seconds or milliseconds).
- the “docid” variable which is set to 1576201954945838082, identifies the content ID of the content item.
- the value of the “secureurl” variable is generated based on the user ID of the user who requested the content, the value of the docid variable (i.e., the content ID of the requested content), the value of the begin variable (i.e., an identifier of the beginning of the requested content portion), and the value of the len variable (i.e., an identifier of the length of the requested content portion).
- the value is generated using a media pointer key.
- the media pointer key is used to encrypt and decrypt the secureurl portion of the URL that is contained within the media pointer.
- the media pointer key is known only to the server 120 , not to the client 110 . In one embodiment, the same media pointer key is used for multiple media pointers, regardless of the user ID or content ID involved.
- the front-end system 155 also sends and receives various messages, as described below with reference to FIGS. 2 and 3 .
- the login system 160 performs user validation and authentication (e.g., based on credentials such as a user identifier (“user ID”) and password).
- the login system 160 stores account information for each user such as user ID, password, real name, email address, street address, phone number, and payment information.
- Payment information includes, for example, a credit card number, expiration date, and billing address.
- the login system 160 also validates payment information.
- the login system 160 also sends and receives various messages, as described below with reference to FIGS. 2 , 3 , and 6 .
- the checkout system 165 enables a user to buy a content item. For example, the user indicates a particular item. This item is placed in a virtual “shopping cart.” When the user is finished adding items to the shopping the cart, he purchases the items using a “checkout” procedure. The checkout procedure processes the user's payment in exchange for the contents of the shopping cart.
- the checkout system 165 also sends and receives various messages, as described below with reference to FIG. 2 .
- the permission system 170 maintains records that describe transaction events (e.g., purchases, downloads, and playbacks) related to a particular user and a particular content item.
- a transaction record includes a user ID, a content ID, a transaction ID, and a transaction status. The transaction status indicates whether a purchase was successful.
- a transaction record also includes a list of download event descriptions and a list of playback event descriptions.
- a download includes information such as IP address, content key, content key ID, and timestamp.
- a playback includes information such as IP address and timestamp.
- the permission system 170 determines whether a particular download request or playback request is permitted. Download permission and playback permission can be based on one or more factors. The factors include payment requirements, limitations on the number of downloads or playbacks of the content by a particular user account, legal restrictions on particular users (based on age, location, etc.), limitations on the types of clients, and limitations on the network location, type, bandwidth, or other functional features. These constraints or limitations can be established by the content owner, the system operator, or others with control or ownership of the content. Some examples are as follows:
- the permission system 170 can determine that a particular user must pay for the content item or that the content item is free of charge. The permission system 170 can also determine that a particular user has exceeded a maximum number of download requests or playback requests for the content item. As another example, the permission system can determine whether the user is legally restricted from downloading or playing the content because the user is younger than a minimum age requirement.
- the permission system 170 can use a transaction record to determine whether a set of requests indicates unusual or forbidden conduct. If it does, the permission system 170 can disable the user's account. In one embodiment, the permission system 170 analyzes the number of attempted requests (successful and/or unsuccessful) within a particular time window (e.g., one week). In another embodiment, if a user's account is being shared by multiple people, the account is suspended.
- the permission system 170 also generates a content key, which is used to encrypt and decrypt content.
- the content key is unique for each download.
- the content key is generated dynamically based on the user (e.g., user ID), the content (e.g., content ID), and the access (e.g., time/date stamp).
- the content key is derived using a keyed one-way function such as HMAC-SHA1 (keyed-hash message authentication code—secure hash algorithm).
- the key is a strong random alpha-numeric string.
- the content key is, for example, a 128-bit Advanced Encryption Standard (AES) key.
- AES Advanced Encryption Standard
- the permission system 170 also creates a digital rights management (DRM) header for each download.
- the DRM header includes the user ID of the user that requested the content, the content ID of the requested content, a content key ID that uniquely identifies the content key, and the version of the decryption-decompression (DD) module needed to play the content.
- DD modules will be described below with reference to FIG. 5 .
- the version information includes both a major version and a minor version (e.g., 2.3, where 2 is the major version and 3 is the minor version).
- the DRM header is encrypted using a DRM header key. In one embodiment, this encryption is performed using AES and a 128-bit key.
- the DRM header key is known only to the server 120 , not to the client 110 . In one embodiment, the same DRM header key is used for multiple DRM headers, regardless of the user ID or content ID involved.
- the permission system 170 also sends and receives various messages, as described below with reference to FIGS. 2 , 3 , 4 , and 6 .
- the content system 175 has access to files that represent media content items such as video clips, audio clips, and/or still images.
- the content system 175 also has access to metadata about these items.
- metadata includes information about the content itself, such as title, author or artist, and year of publication.
- metadata includes management information about the content item, such as a content ID and how much money (if any) a user must pay to access the item.
- the content system 175 compresses content before it is sent in order to save bandwidth.
- the content system 175 compresses video files using a video codec such as DivX from DivX, Inc. of San Diego, Calif. or MPEG-4 from the Moving Picture Experts Group working group of the ISO/IEC (International Organization for Standardization/International Electrotechnical Commission).
- the content system 175 compresses audio files using an audio codec such as RealAudio from RealNetworks, Inc. of Seattle, Wash. or MPEG-1 Audio Layer 3 (“MP3”) from the MPEG working group of the ISO/IEC.
- MP3 MPEG-1 Audio Layer 3
- the content system 175 also encrypts (compressed) content using a content key. This content key is created each time an item of content is to be transmitted to a client 110 .
- encryption is performed using modified AES.
- the content system 175 also decrypts portions of URLs within media pointers using a media pointer key.
- the content system 175 also sends and receives various messages, as described below with reference to FIGS. 3 and 4 .
- the key system 180 encrypts content keys using decryption-decompression (DD) module keys.
- each DD module has a unique DD module key (also called a “master key”).
- This DD module key is derived from the DD module's identifier (“DD module ID”) using a derivation key.
- encryption of a content key is performed using the Data Encryption Standard (DES), and the DD module key is a 56-bit DES key.
- DES Data Encryption Standard
- the key system 180 also decrypts encrypted DRM headers using a DRM header key.
- the key system 180 also sends and receives various messages, as described below with reference to FIG. 6 .
- the decryption-decompression (DD) module system 185 generates DD modules for use by various players 145 .
- DD modules are used to play content that has been compressed and encrypted.
- the DD module system 185 is capable of generating thousands (even hundreds of thousands) of different DD modules, any of which can theoretically be used with any player 145 .
- the DD module system 185 generates a particular DD module by using a particular round-key. Each DD module uses a different round-key (i.e., round-keys for different DD modules are independent).
- Which particular DD module is generated and sent to a player 145 (see FIG. 6 ) is pseudo-random.
- the pseudo-randomness is based on, for example, a user's user ID and a version number of the player 145 .
- a DD module's assembly code is obfuscated for greater security.
- multiple layers of code obfuscation are used, including obfuscation of the cryptographic logic, obfuscation of the assembled code, and obfuscation of the compiled binary of the module.
- each of the thousands of different DD modules can be obfuscated in a different manner. Thus, even if a particular module is compromised by an attacker, the only use of that is to decrypt content that is already associated with that particular module.
- the DD module system 185 also sends and receives various messages, as described below with reference to FIG. 6 .
- DD modules will be discussed below with reference to FIG. 5 .
- the system architecture 100 and purchase, download, and playback processes provide several beneficial features.
- the system is designed so that all purchase, download, and playback requests require permission from the permission system 170 .
- This requires the client 110 to be connected to the server 120 (via the network 130 ) for all such operations.
- the advantage of this design is that all of the rules used for permission are maintained with the permission system 170 and therefore can be readily updated and changed as needed (e.g., to improve security, install business logic particular to a content owner, or adapt to newly-discovered fraud tactics).
- the permission system 170 can thus be updated or revised, and the newly-installed operations and rules are thus applied to all transactions by all clients 110 .
- each client 110 has to be individually updated. This leads to version drift, as well as the need for the server 120 to support multiple different versions of a client 110 simultaneously.
- the permission system 170 is secure, its operations are less subject to attack by malicious parties. This contrasts with client-based permission systems that can be attacked by such malicious parties, who can thus more readily attempt to defeat the permission rules within the client 110 .
- FIG. 2 is a message diagram illustrating the messages sent between various components of the system shown in FIG. 1 in order to purchase content. Each arrow represents a message. The arrow's reference number indicates the contents of the message and the operations associated with the sending of the message and its receipt, as follows:
- the user logs in from the client 110 .
- the client 110 sends to the login system 160 a set of credentials (e.g., a user identifier (“user ID”) and a password).
- the user ID is an email address or any other type of useful identifier for a user.
- the login system 160 attempts to authenticate the user.
- the login system 160 sends to the client 110 an authentication token (“auth token”).
- the user indicates a particular content item to purchase. This can be done through a user interface that displays content items to the user, in various categories and lists and via browsing and searching functions. User interfaces for selecting and providing access to content are well-known and are not further described here.
- the client 110 sends to the front-end system 155 the auth token and a content ID that is associated with the selected content.
- the front-end system 155 creates a shopping cart that contains the content purchase information.
- this information includes the user ID (based on the auth token), the content ID, and information about the item (e.g., whether it is a lifetime purchase (“download-to-own”) versus a rental and, if it's a rental, the expiration date/time).
- the transaction is logged.
- the front-end system 155 sends to the permission system 170 the user ID and the content ID.
- the permission system creates a transaction record for the user ID and the content ID pair.
- the purchase is made.
- the client 110 sends to the checkout system 165 the user ID, the content ID, and the auth token.
- the checkout system 165 accesses the shopping cart to complete the purchase.
- the transaction is updated.
- the checkout system 165 sends to the permission system 170 the user ID, the content ID, a transaction identifier, and the status of the transaction. Assume that the status indicates that the purchase was successful.
- the permission system 170 locates the transaction record for the user ID and the content ID and updates it with the transaction identifier and the transaction status, thereby indicating that the user has purchased the content.
- FIG. 3 is a message diagram illustrating the messages sent between various components of the system shown in FIG. 1 in order to initiate downloading content. Each arrow represents a message. The arrow's reference number indicates the contents of the message and the operations associated with the sending of the message and its receipt, as follows:
- the user indicates a particular content item to download. This can be done, for example, by the user accessing his account and selecting the content item from a list of previously requested and/or purchased content.
- the client 110 sends to the front-end system 155 the user ID, the auth token, and a content ID.
- Permission for the download is requested.
- the front-end system 155 sends to the permission system 170 the user ID and the content ID.
- the permission system 170 locates the appropriate transaction record based on the user ID and the content ID. Based on the contents of the record, the permission system 170 determines whether the download is permitted.
- the permission system 170 can use a variety of different rules to determine whether the download is permitted. For example, even if the user has purchased the content, the permission system 170 can deny the download request if the user has already downloaded the content a maximum number of times.
- Permission for the download is granted. If the download is permitted, the permission system 170 generates a media pointer and sends it to the front-end system 155 . The media pointer identifies the requested content.
- the media pointer is delivered.
- the front-end system 155 generates a media pointer that includes a URL with an encrypted portion.
- the front-end system 155 then sends the media pointer to the client 110 .
- the front-end system 155 also sends a copy of the media pointer key to the content system 175 so that the content system can subsequently decrypt the encrypted portion of the media pointer.
- the download is initiated.
- the client 110 sends to the content system 175 the media pointer with the encrypted URL.
- the content system 175 decrypts the encrypted portion of the media pointer (using the media pointer key) to reveal the user ID and the content ID.
- the content system 175 uses the content ID and the user ID to retrieve the requested content from storage.
- the download is logged.
- the content system 175 sends to the permission system 170 the user ID and the content ID.
- the permission system 170 generates a content key.
- the permission system 170 also locates the appropriate transaction record based on the user ID and the content ID and adds a download event description to the “downloads” portion of the record with the content key, a content key identifier, a timestamp, and the IP address of the client 110 .
- the permission system 170 also creates a DRM header for this item of content (as described above) and encrypts it using the DRM header key.
- the permission system 170 also sends a copy of the DRM header key to the key system 180 so that the key system can subsequently decrypt the DRM header.
- the permission system 170 sends to the content system 175 the content key and the encrypted DRM header.
- the content system 175 uses the content key to encrypt the requested content.
- the content key was generated to be unique to this particular download transaction by the user.
- the content is transferred.
- the content server 175 embeds the encrypted DRM header within the encrypted, compressed content and transfers the data to the client 110 .
- the encrypted, compressed content and accompanying encrypted DRM header are located at the client 110 .
- FIG. 4 is a message diagram illustrating messages sent between various components of the system shown in FIG. 1 in order to resume downloading content. Each arrow represents a message. The arrow's reference number indicates the contents of the message and the operations associated with the sending of the message and its receipt, as follows:
- the download is initiated.
- the client 110 sends to the content system 175 the media pointer with the encrypted portion, the encrypted DRM header, and a span that indicates desired content (e.g., content that has not yet been transferred).
- the span includes a beginning index and a duration.
- the index and duration can be measured in various units, such as bytes, blocks, seconds, milliseconds, or frames. If the beginning index is 0 and the duration is the length of the content, then the request is for the entire content item.
- the content key is requested.
- the content system 175 decrypts the encrypted portion of the media pointer (using the media pointer key) and decrypts the encrypted DRM header (using the DRM header key).
- the content system 175 then sends to the permission system 170 the user ID, the content ID, and the content key ID.
- the content key is delivered.
- the permission system 170 locates the appropriate transaction record based on the user ID and the content ID.
- the permission system 170 sends to the content system 175 the content key ID from that record.
- the content is transferred.
- the content server 175 compresses the requested content span, encrypts it using the content key, and transfers the data to the client 110 .
- the encrypted, compressed content and accompanying encrypted DRM header are located at the client 110 .
- FIG. 6 is a message diagram illustrating the messages sent between various components of the system shown in FIG. 1 in order to play content. Each arrow represents a message. The arrow's reference number indicates the contents of the message and the operations associated with the sending of the message and its receipt, as follows:
- the user starts to log in.
- the client 110 sends to the key system 180 the encrypted DRM header for the content that the user wants to play.
- the key system 180 decrypts the DRM header (using the DRM header key) to reveal a user ID. Only this user ID can be used to play the content that was accompanied by this DRM header.
- the user ID is delivered.
- the key system 180 sends to the client 110 the user ID.
- the user enters a password that matches the user ID.
- the client 110 sends to the login system 160 the user ID and the password.
- the user is authenticated. If the user ID and the password are correct, the login system 160 sends to the client 110 an auth token.
- the auth token authenticates the client 110 to the login system 160 , thereby ensuring that the user who is requesting to play the content is the same user who purchased the content. If the purchasing user were to send the content to another user, that other user would not be able to play the content without getting the first user's password. Since the user's password provides access to the user's account, including details such as the user's credit card information, the first user is unlikely to freely provide his password to others.
- the DD module information is requested.
- the client 110 sends to the DD module system 185 the encrypted DRM header, the auth token, and an identifier of the platform of the client.
- the DD module system 185 decrypts the encrypted DRM header to reveal the user ID and the version (major and minor) of the DD module that is needed to play the content that was accompanied by this DRM header. Note that the client 110 itself cannot decrypt the DRM header. In other words, the DRM header is completely opaque to the client 110 .
- the DD module information is delivered.
- the DD module system 185 sends to the client 110 the name of the version of the DD module and a DD module ID.
- the name of the version includes the same major and minor versions from the DRM header, in addition to a “revision” that represents the most recent revision of that major-minor pair.
- the DD module ID is based on the user ID and the version of the DD module.
- the DD module ID is a cryptographic function of the user ID and the version of the DD module.
- the DD module ID can be determined based on the user ID and the version of the DD module, as long as the cryptographic function is known.
- the DD module is requested.
- the client 110 sends to the DD module system 185 the encrypted DRM header, the auth token, the identifier of the platform of the client, and the name of the version of the DD module.
- the DD module is delivered.
- the DD module system 185 sends to the client 110 a DD module that will play the content on the client's platform.
- the content key is requested.
- the client 110 sends to the key system 180 the encrypted DRM header, the auth token, and a key challenge.
- the key challenge is random and is given by the following expression: Encrypt DDmodulekey (random bytes) where “random bytes” represents the data stored in a random area of memory, and Encrypt DDmodulekey (random bytes) means encrypt the value of “random bytes” using the DD module key.
- the “random area of memory” is where the content key will be stored once it has been decrypted, as explained below.
- Permission for the playback is requested.
- the key system 180 sends to the permission system 170 the user ID and the content ID.
- the permission system 170 locates the appropriate transaction record based on the user ID and the content ID. Based on the contents of the record, the permission system 170 determines whether the playback is permitted. As noted above, the permission system 170 can use a variety of different rules to determine whether the playback is permitted. For example, even if the user has purchased the content, the permission system 170 can deny the playback request if the user has already played the content a maximum number of times.
- Permission for the playback is granted. If the playback is permitted, the permission system 170 sends this information to the key system 180 .
- the encrypted content key is delivered.
- the key system 180 sends to the client 110 an encrypted content key.
- the content key is the same content key that was used to encrypt the content.
- Encrypt DDmodulekey random bytes
- the encrypted content key is determined as follows: The key system 180 determines a “delta” value, which is given by the expression
- the key response i.e., the encrypted content key
- Encrypt DDmodulekey delta
- the key challenge is decrypted using the DD module key, which is known to the client 110 . (This yields the delta.)
- the delta is XOR'ed over the “random area of memory” (whose data was used in the key challenge.
- the key challenge bytes cancel out.
- the random area of memory now stores the content key.
- the encrypted content key is located at the client 110 .
- the client 110 can now decrypt and decompress the content, as described below.
- FIG. 5 is a block diagram illustrating a DD module 500 , according to one embodiment of the invention.
- the DD module 500 includes a control module 505 , a content decryption module 510 , a content decompression module 520 , a content key decryption module 530 , and a communication mechanism.
- the communication mechanism communicatively the couples the control module 505 , the content decryption module 510 , the content decompression module 520 , and the content key decryption module 530 to each other.
- the content decryption module 510 decrypts content using a content key.
- This content key is the same content key that was generated by the permission system 170 and used to encrypt the content (see FIGS. 3 and 4 ).
- the content decompression module 520 decompresses content. For example, if the content is a video clip, the content decompression module 520 is a video codec such as DivX or MPEG-4. If the content is an audio clip, the content decompression module 520 is an audio codec such as RealAudio or MP3.
- the content key decryption module 530 decrypts a content key using a DD module key (also called a “master key”).
- the DD module key is the same DD module key that was used by the key system 180 to encrypt the content key.
- the content key is stored in non-consecutive memory locations for greater security.
- the control module 505 controls operation of the DD module 500 .
- the control module 505 performs the following tasks: Decrypt the encrypted content key using a DD module key and the content key decryption module 530 . (This yields the content key.) Decrypt the encrypted, compressed content using the content key and the content decryption module 510 . (This yields the compressed content.) Decompress the compressed content using the content decompression module 520 . (This yields the uncompressed content, which can then be played.)
- the DD module 500 uses two keys: a content key and a DD module key.
- the content key (which is used to decrypt content) is received from the key system 180 (see FIG. 6 ).
- the DD module key (which is used to decrypt the content key) is “built-in” to the DD module 500 .
- the DD module key cannot be readily extracted from the DD module by malicious parties.
- the content key decryption module 530 is an implementation of the DES decryption algorithm, and thus the DD module key is a DES key.
- the key value is “hard-coded” into the decryption logic of the module. For example, instead of decryption source code including a branch statement based on a key value, the source code instead takes the appropriate branch automatically because the key is already known.
- the system architecture 100 and associated processes provide for greater security and control than previous DRM approaches.
- the use of entirely server-side permission and authentication afford the capability to better control the access, purchase, download, and playback of content.
- the various levels of encryption, and in particular the separate encryption of the DRM header (using a key unknown to the client 110 ), the content key (using a key built into the DD module 500 within the player 145 of the client 110 ), and the content (using the unique content key), operate to prevent malicious attacks on the player 145 and the content.
- the DRM header is encrypted using a key that is never exposed to the client 110 , an attacker would generally be unable to identify the necessary DD module 500 .
- the content key itself cannot be extracted without the DD module key.
- an attack on an encrypted content key is also substantially prevented.
- the DD module key can only be used with that particular DD module 500 and its copies.
- Certain aspects of the present invention include process steps and instructions described herein in the form of an algorithm. It should be noted that the process steps and instructions of the present invention could be embodied in software, firmware or hardware, and when embodied in software, could be downloaded to reside on and be operated from different platforms used by real time network operating systems.
- the present invention also relates to an apparatus for performing the operations herein.
- This apparatus may be specially constructed for the required purposes, or it may comprise a general-purpose computer selectively activated or reconfigured by a computer program stored on a computer readable medium that can be accessed by the computer.
- a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, application specific integrated circuits (ASICs), or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus.
- the computers referred to in the specification may include a single processor or may be architectures employing multiple processor designs for increased computing capability.
- the present invention is well suited to a wide variety of computer network systems over numerous topologies.
- the configuration and management of large networks comprise storage devices and computers that are communicatively coupled to dissimilar computers and storage devices over a network, such as the Internet.
Abstract
Systems and methods provide for controlling download and playback of media content. A system includes a client, which can play content, and a server. The server includes a permission system that can determine whether a client request to download or play content should be granted. All purchase, download, and playback requests require permission from the permission system. The server also includes a DD module system that transfers a DD module to the client. The DD module includes a content key decryption module, a content decryption module, and a content decompression module. The content key decryption module decrypts an encrypted content key that was received from the server. The decryption uses a unique DD module key that has been hard-coded into the content key decryption module. The content decryption module uses the content key to decrypt encrypted content. The content decompression module decompresses compressed content so that it can be played.
Description
This application is a continuation of U.S. application Ser. No. 11/621,464, filed Jan. 9, 2007, which is incorporated by reference in its entirety.
The present invention relates to security for media content and, more specifically, to controlling download and playback of media content.
Many systems exist for transferring and playing media content. If the content is valuable, the content owner will restrict access to the content. For example, a user might be granted access in exchange for payment. Once the user has accessed the content, however, it is relatively easy for the user to copy the content and transfer it to someone else, who can then play it freely. A content owner wants to restrict playback to authorized users without preventing these users from accessing and playing the content.
The present invention provides various embodiments of methods and systems for controlling download and playback of media content. The system includes a client and a server, which are connected by a network. The client can play content. The server includes a permission system that can determine whether a request from the client to download or play content should be granted. The client-server system is designed so that all purchase, download, and playback requests require permission from the permission system. This requires the client to be connected to the server (via the network) for all such operations. The advantage of this design is that all of the rules used for permission are maintained with the permission system and therefore can be readily updated and changed as needed (e.g., to improve security, install business logic particular to a content owner, or adapt to newly-discovered fraud tactics). The permission system can thus be updated or revised, and the newly-installed operations and rules are thus applied to all transactions by all clients. Because the permission system is secure, its operations are less subject to attack by malicious parties.
The server also includes a DD module system that transfers a DD module to the client. The DD module includes a content key decryption module, a content decryption module, and a content decompression module. The content key decryption module decrypts an encrypted content key that was received from the server. The decryption uses a unique DD module key that has been hard-coded into the content key decryption module. The content decryption module uses the content key to decrypt encrypted content. The content decompression module decompresses compressed content so that it can be played.
Various levels of encryption, such as applied to the content key and to the content itself, operate to prevent malicious attacks on the client and the content. For example, the content key cannot be extracted without the DD module key. Because of the very large number of possible DD module keys (and the large number of different DD modules), an attack on an encrypted content key is also substantially prevented. Also, even if a particular instance of a DD module is compromised and the DD module key extracted, the DD module key can only be used with that particular DD module and its copies. Because of the very large number of different DD modules, the attacker would have no way of knowing with which other DD modules to use the ill-gotten DD module key, thereby rendering the DD module key essentially useless.
The description in the specification is not all inclusive and, in particular, many additional features will be apparent to one of ordinary skill in the art in view of the drawings, specification, and claims. Moreover, it should be noted that the language used in the specification has been principally selected for readability and instructional purposes and may not have been selected to delineate or circumscribe the inventive subject matter.
One skilled in the art will readily recognize from the following discussion that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles of the invention described herein.
Described herein are systems and methods for controlling download and playback of media content. Media content, as used herein, refers to video, audio, or still images (or any combination thereof) in any format. A media content file can also include descriptive metadata, either encoded with the file or in a separate but associated file. A common example of media content is a video article including two portions—one video portion and one audio portion. However, the techniques described herein can be used with any number of file portions.
1. System Architecture
In one embodiment, media content is transferred and played in the context of a client-server architecture. FIG. 1 is a block diagram illustrating a client-server architecture for transferring and playing media content, according to one embodiment of the invention. In the illustrated embodiment, the architecture 100 includes a client 110, a server 120, and a network 130. Although only one client 110 is shown for clarity, the architecture 100 can support a large number of concurrent sessions with many clients 110.
The client 110 includes a first component for displaying a user interface that enables a user to specify a media content item (such as a video clip, audio clip, or still image) for transfer from the server 120 to the client 110 via the network 130. In one embodiment, the first component is a web browser software application 140. For example, the web browser 140 displays web pages and receives user input.
The client 110 also includes a second component for playing a media content item. In one embodiment, the second component is a software application referred to as a player 145 and includes, for example, the Google Video Player from Google Inc. of Mountain View, Calif. In another embodiment, the player 145 supports automatic updating over the network 130 in order to enhance security and functionality. The player 145 will be further discussed below with reference to FIG. 5 .
The client 110 receives messages from and sends messages to the network interface 150. One example of a received message is a HyperText Transfer Protocol (HTTP) message that contains a web page, such as a web page that enables a user to select a media content item. One example of a sent message is an HTTP message that contains a content identifier (content ID). The content ID identifies a particular content item that the user wants to be transferred to the client 110. Other messages will be described below with reference to FIGS. 2 , 3, 4, and 6.
The client also includes a network interface 150 for communicating with the network 130 and with the server 120 (via the network 130). In one embodiment, the network interface 150 is configured to communicate using protocols such as Transmission Control Protocol (TCP)/Internet Protocol (IP). However, the network interface 150 can support additional communication protocols, such as wireless protocols (e.g., cellular, Bluetooth, IEEE 802.11, IEEE 802.16, and the like). The web browser 140 and the player 145 are communicatively coupled to the network interface 150.
The client 110 is any type of computing device, such as a workstation, a desktop computer, a laptop computer, a tablet computer, a personal digital assistant (PDA), a cellular phone, or any other type of computing device. In one embodiment, the client 110 is of conventional design and includes a processor, an addressable memory, and other conventional features such as a display, local memory, and input/output ports (not illustrated). One or more of the components of the client 110 can be located remotely and accessed via a network. The client 110 can be implemented on a device running any of a number of operating systems, such as Linux, UNIX, an operating system from Microsoft Corporation of Redmond, Wash., Apple Computer, Inc. of Cupertino, Calif., or Palm Source, Inc. of Sunnyvale, Calif., and/or other operating systems.
The server 120 is a logical grouping that includes various back-end components. In the illustrated embodiment, the back-end components include a front-end system 155, a login system 160, a checkout system 165, a permission system 170, a content system 175, a key system 180, and a decryption-decompression (DD) module system 185. The components can be implemented as a single device or as multiple computer devices such as computer processors and associated storage devices. Examples of devices include servers, mainframe computers, networked computers, processor-based devices, and similar types of systems and devices. In one implementation, the server 120 includes one or more high-performance server-class computers. In the illustrated embodiment, the back-end components are communicatively coupled to each other and to the network 130.
The details of the hardware aspects of the back-end components are known to those of skill in the art and are not further described herein. The server 120 and its associated devices need not be physically co-located, and there need not be any predefined mapping between storage devices and server computers. The server processor can be any of a number of computer processors, such as processors from Intel Corporation of Santa Clara, Calif. and Motorola Corporation of Schaumburg, Ill. In one embodiment, the server 120 has sufficient processing power and bandwidth to perform the tasks described herein.
The network 130 communicatively couples the client 110 and the server 120. In one embodiment, the network 130 includes a partially-public or wholly-public network such as the Internet. In other embodiments, the network 130 includes a private network or one or more distinct or logical private networks (e.g., virtual private networks or local area networks). Communication links to and from the network 130 can be wired or wireless (e.g., terrestrial- or satellite-based transceivers). In one embodiment, the network 130 is a packet-switched network such as an IP-based wide or metropolitan area network that uses the Ethernet protocol.
The front-end system 155 generates a media pointer. A media pointer is a file that enables the player 145 to retrieve a particular content item from the server 120. In one embodiment, the media pointer includes a Uniform Resource Locator (URL), the content ID (“docid”) of the content item, the duration of the content item (e.g., in seconds or milliseconds), the title of the content item, and the description of the content item. One example of a media pointer is a Google Video Pointer (.gvp file) from Google Inc.
The contents of an exemplary media pointer are as follows:
- url:http://contentsystem/videodownload?secureurl=encrypteddata&begin=0&len=196129&docid=1576201954945838082
- docid: 1576201954945838082
- duration: 196129
- title: Kelly Clarkson—Behind These Hazel Eyes
- description: Kelly Clarkson Getting Ready For Her Wedding,Kelly Clarkson Playing With A Band, Kelly Clarkson Running In A Tattered Wedding Dress, Kelly Clarkson Wallowing In Mud, Kelly Clarkson Running Out Of Her Wedding
In the above example, the URL is http://contentsystem/videodownload? secureurl=encrypteddata&begin=0&len=196129&docid=1576201954945838082. The “contentsystem” portion of the URL represents the address of the content system 175. The URL includes four variables: secureurl, begin, len, and docid. The “secureurl” variable, which is set to “encrypteddata,” identifies encrypted data, as explained below. The “begin” variable, which is set to 0, identifies the beginning of the requested portion of the content item (e.g., as an offset in seconds or milliseconds). The “len” variable, which is set to 196129, identifies the length of the requested portion of the content item (e.g., in seconds or milliseconds). The “docid” variable, which is set to 1576201954945838082, identifies the content ID of the content item.
Within the URL, the value of the “secureurl” variable is generated based on the user ID of the user who requested the content, the value of the docid variable (i.e., the content ID of the requested content), the value of the begin variable (i.e., an identifier of the beginning of the requested content portion), and the value of the len variable (i.e., an identifier of the length of the requested content portion). The value is generated using a media pointer key. The media pointer key is used to encrypt and decrypt the secureurl portion of the URL that is contained within the media pointer. The media pointer key is known only to the server 120, not to the client 110. In one embodiment, the same media pointer key is used for multiple media pointers, regardless of the user ID or content ID involved.
The front-end system 155 also sends and receives various messages, as described below with reference to FIGS. 2 and 3 .
The login system 160 performs user validation and authentication (e.g., based on credentials such as a user identifier (“user ID”) and password). In one embodiment, the login system 160 stores account information for each user such as user ID, password, real name, email address, street address, phone number, and payment information. Payment information includes, for example, a credit card number, expiration date, and billing address. In one embodiment, the login system 160 also validates payment information. The login system 160 also sends and receives various messages, as described below with reference to FIGS. 2 , 3, and 6.
The checkout system 165 enables a user to buy a content item. For example, the user indicates a particular item. This item is placed in a virtual “shopping cart.” When the user is finished adding items to the shopping the cart, he purchases the items using a “checkout” procedure. The checkout procedure processes the user's payment in exchange for the contents of the shopping cart. The checkout system 165 also sends and receives various messages, as described below with reference to FIG. 2 .
The permission system 170 maintains records that describe transaction events (e.g., purchases, downloads, and playbacks) related to a particular user and a particular content item. In one embodiment, a transaction record includes a user ID, a content ID, a transaction ID, and a transaction status. The transaction status indicates whether a purchase was successful. A transaction record also includes a list of download event descriptions and a list of playback event descriptions. A download includes information such as IP address, content key, content key ID, and timestamp. A playback includes information such as IP address and timestamp.
Based on the contents of a transaction record, the permission system 170 determines whether a particular download request or playback request is permitted. Download permission and playback permission can be based on one or more factors. The factors include payment requirements, limitations on the number of downloads or playbacks of the content by a particular user account, legal restrictions on particular users (based on age, location, etc.), limitations on the types of clients, and limitations on the network location, type, bandwidth, or other functional features. These constraints or limitations can be established by the content owner, the system operator, or others with control or ownership of the content. Some examples are as follows:
The permission system 170 can determine that a particular user must pay for the content item or that the content item is free of charge. The permission system 170 can also determine that a particular user has exceeded a maximum number of download requests or playback requests for the content item. As another example, the permission system can determine whether the user is legally restricted from downloading or playing the content because the user is younger than a minimum age requirement.
The permission system 170 can use a transaction record to determine whether a set of requests indicates unusual or forbidden conduct. If it does, the permission system 170 can disable the user's account. In one embodiment, the permission system 170 analyzes the number of attempted requests (successful and/or unsuccessful) within a particular time window (e.g., one week). In another embodiment, if a user's account is being shared by multiple people, the account is suspended.
The permission system 170 also generates a content key, which is used to encrypt and decrypt content. The content key is unique for each download. In one embodiment, the content key is generated dynamically based on the user (e.g., user ID), the content (e.g., content ID), and the access (e.g., time/date stamp). For example, the content key is derived using a keyed one-way function such as HMAC-SHA1 (keyed-hash message authentication code—secure hash algorithm). In another embodiment, the key is a strong random alpha-numeric string. The content key is, for example, a 128-bit Advanced Encryption Standard (AES) key.
The permission system 170 also creates a digital rights management (DRM) header for each download. The DRM header includes the user ID of the user that requested the content, the content ID of the requested content, a content key ID that uniquely identifies the content key, and the version of the decryption-decompression (DD) module needed to play the content. (DD modules will be described below with reference to FIG. 5 .) In one embodiment, the version information includes both a major version and a minor version (e.g., 2.3, where 2 is the major version and 3 is the minor version). The DRM header is encrypted using a DRM header key. In one embodiment, this encryption is performed using AES and a 128-bit key. The DRM header key is known only to the server 120, not to the client 110. In one embodiment, the same DRM header key is used for multiple DRM headers, regardless of the user ID or content ID involved.
The permission system 170 also sends and receives various messages, as described below with reference to FIGS. 2 , 3, 4, and 6.
The content system 175 has access to files that represent media content items such as video clips, audio clips, and/or still images. The content system 175 also has access to metadata about these items. In one embodiment, metadata includes information about the content itself, such as title, author or artist, and year of publication. In another embodiment, metadata includes management information about the content item, such as a content ID and how much money (if any) a user must pay to access the item.
The content system 175 compresses content before it is sent in order to save bandwidth. For example, the content system 175 compresses video files using a video codec such as DivX from DivX, Inc. of San Diego, Calif. or MPEG-4 from the Moving Picture Experts Group working group of the ISO/IEC (International Organization for Standardization/International Electrotechnical Commission). The content system 175 compresses audio files using an audio codec such as RealAudio from RealNetworks, Inc. of Seattle, Wash. or MPEG-1 Audio Layer 3 (“MP3”) from the MPEG working group of the ISO/IEC. The content system 175 also encrypts (compressed) content using a content key. This content key is created each time an item of content is to be transmitted to a client 110. In one embodiment, encryption is performed using modified AES. The content system 175 also decrypts portions of URLs within media pointers using a media pointer key. The content system 175 also sends and receives various messages, as described below with reference to FIGS. 3 and 4 .
The key system 180 encrypts content keys using decryption-decompression (DD) module keys. In one embodiment, each DD module has a unique DD module key (also called a “master key”). This DD module key is derived from the DD module's identifier (“DD module ID”) using a derivation key. In one embodiment, encryption of a content key is performed using the Data Encryption Standard (DES), and the DD module key is a 56-bit DES key.
The key system 180 also decrypts encrypted DRM headers using a DRM header key. The key system 180 also sends and receives various messages, as described below with reference to FIG. 6 .
The decryption-decompression (DD) module system 185 generates DD modules for use by various players 145. DD modules are used to play content that has been compressed and encrypted. In one embodiment, the DD module system 185 is capable of generating thousands (even hundreds of thousands) of different DD modules, any of which can theoretically be used with any player 145. The DD module system 185 generates a particular DD module by using a particular round-key. Each DD module uses a different round-key (i.e., round-keys for different DD modules are independent). Which particular DD module is generated and sent to a player 145 (see FIG. 6 ) is pseudo-random. The pseudo-randomness is based on, for example, a user's user ID and a version number of the player 145.
In one embodiment, a DD module's assembly code is obfuscated for greater security. Preferably, multiple layers of code obfuscation are used, including obfuscation of the cryptographic logic, obfuscation of the assembled code, and obfuscation of the compiled binary of the module. Further, each of the thousands of different DD modules can be obfuscated in a different manner. Thus, even if a particular module is compromised by an attacker, the only use of that is to decrypt content that is already associated with that particular module.
The DD module system 185 also sends and receives various messages, as described below with reference to FIG. 6 . DD modules will be discussed below with reference to FIG. 5 .
The system architecture 100 and purchase, download, and playback processes (described below with reference to FIGS. 2 , 3, 4, and 6) provide several beneficial features. The system is designed so that all purchase, download, and playback requests require permission from the permission system 170. This requires the client 110 to be connected to the server 120 (via the network 130) for all such operations. The advantage of this design is that all of the rules used for permission are maintained with the permission system 170 and therefore can be readily updated and changed as needed (e.g., to improve security, install business logic particular to a content owner, or adapt to newly-discovered fraud tactics). The permission system 170 can thus be updated or revised, and the newly-installed operations and rules are thus applied to all transactions by all clients 110.
By contrast, in a client-based permissions model, each client 110 has to be individually updated. This leads to version drift, as well as the need for the server 120 to support multiple different versions of a client 110 simultaneously. Further, because the permission system 170 is secure, its operations are less subject to attack by malicious parties. This contrasts with client-based permission systems that can be attacked by such malicious parties, who can thus more readily attempt to defeat the permission rules within the client 110.
2. Purchasing Content
200: The user logs in from the client 110. Specifically, the client 110 sends to the login system 160 a set of credentials (e.g., a user identifier (“user ID”) and a password). The user ID is an email address or any other type of useful identifier for a user. The login system 160 then attempts to authenticate the user.
210: If the credentials are correct, the login system 160 sends to the client 110 an authentication token (“auth token”).
220: The user indicates a particular content item to purchase. This can be done through a user interface that displays content items to the user, in various categories and lists and via browsing and searching functions. User interfaces for selecting and providing access to content are well-known and are not further described here. Once the user has selected a particular item of content, the client 110 sends to the front-end system 155 the auth token and a content ID that is associated with the selected content. The front-end system 155 creates a shopping cart that contains the content purchase information. In one embodiment, this information includes the user ID (based on the auth token), the content ID, and information about the item (e.g., whether it is a lifetime purchase (“download-to-own”) versus a rental and, if it's a rental, the expiration date/time).
230: The transaction is logged. The front-end system 155 sends to the permission system 170 the user ID and the content ID. The permission system creates a transaction record for the user ID and the content ID pair.
240: The purchase is made. The client 110 sends to the checkout system 165 the user ID, the content ID, and the auth token. The checkout system 165 accesses the shopping cart to complete the purchase.
250: The transaction is updated. The checkout system 165 sends to the permission system 170 the user ID, the content ID, a transaction identifier, and the status of the transaction. Assume that the status indicates that the purchase was successful. The permission system 170 locates the transaction record for the user ID and the content ID and updates it with the transaction identifier and the transaction status, thereby indicating that the user has purchased the content.
At this point in time, the user has purchased the content.
3. Initiating Download of Content
300: If the user is not logged in, he logs in. This is similar to 200 in FIG. 2 .
310: If the user has not been authenticated, he is authenticated. This is similar to 210 in FIG. 2 .
320: The user indicates a particular content item to download. This can be done, for example, by the user accessing his account and selecting the content item from a list of previously requested and/or purchased content. The client 110 sends to the front-end system 155 the user ID, the auth token, and a content ID.
330: Permission for the download is requested. The front-end system 155 sends to the permission system 170 the user ID and the content ID. The permission system 170 locates the appropriate transaction record based on the user ID and the content ID. Based on the contents of the record, the permission system 170 determines whether the download is permitted. As noted above, the permission system 170 can use a variety of different rules to determine whether the download is permitted. For example, even if the user has purchased the content, the permission system 170 can deny the download request if the user has already downloaded the content a maximum number of times.
340: Permission for the download is granted. If the download is permitted, the permission system 170 generates a media pointer and sends it to the front-end system 155. The media pointer identifies the requested content.
350: The media pointer is delivered. The front-end system 155 generates a media pointer that includes a URL with an encrypted portion. The front-end system 155 then sends the media pointer to the client 110. The front-end system 155 also sends a copy of the media pointer key to the content system 175 so that the content system can subsequently decrypt the encrypted portion of the media pointer.
360: The download is initiated. The client 110 sends to the content system 175 the media pointer with the encrypted URL. The content system 175 decrypts the encrypted portion of the media pointer (using the media pointer key) to reveal the user ID and the content ID. The content system 175 uses the content ID and the user ID to retrieve the requested content from storage.
370: The download is logged. The content system 175 sends to the permission system 170 the user ID and the content ID. The permission system 170 generates a content key. The permission system 170 also locates the appropriate transaction record based on the user ID and the content ID and adds a download event description to the “downloads” portion of the record with the content key, a content key identifier, a timestamp, and the IP address of the client 110. The permission system 170 also creates a DRM header for this item of content (as described above) and encrypts it using the DRM header key. The permission system 170 also sends a copy of the DRM header key to the key system 180 so that the key system can subsequently decrypt the DRM header.
380: The permission system 170 sends to the content system 175 the content key and the encrypted DRM header. The content system 175 uses the content key to encrypt the requested content. As noted above, the content key was generated to be unique to this particular download transaction by the user.
390: The content is transferred. The content server 175 embeds the encrypted DRM header within the encrypted, compressed content and transfers the data to the client 110.
At this point in time, the encrypted, compressed content and accompanying encrypted DRM header are located at the client 110.
4. Resuming Download of Content
If the requested content item is large, it is possible that the download will be interrupted before the entire content item has been transferred. In this situation, download is resumed in order to obtain the remaining portion of the content.
400: The download is initiated. The client 110 sends to the content system 175 the media pointer with the encrypted portion, the encrypted DRM header, and a span that indicates desired content (e.g., content that has not yet been transferred). In one embodiment, the span includes a beginning index and a duration. The index and duration can be measured in various units, such as bytes, blocks, seconds, milliseconds, or frames. If the beginning index is 0 and the duration is the length of the content, then the request is for the entire content item.
410: The content key is requested. The content system 175 decrypts the encrypted portion of the media pointer (using the media pointer key) and decrypts the encrypted DRM header (using the DRM header key). The content system 175 then sends to the permission system 170 the user ID, the content ID, and the content key ID.
420: The content key is delivered. The permission system 170 locates the appropriate transaction record based on the user ID and the content ID. The permission system 170 sends to the content system 175 the content key ID from that record.
430: The content is transferred. The content server 175 compresses the requested content span, encrypts it using the content key, and transfers the data to the client 110.
At this point in time, the encrypted, compressed content and accompanying encrypted DRM header are located at the client 110.
5. Playing Content
A. Obtaining DD Module and Content Key
600: The user starts to log in. The client 110 sends to the key system 180 the encrypted DRM header for the content that the user wants to play. The key system 180 decrypts the DRM header (using the DRM header key) to reveal a user ID. Only this user ID can be used to play the content that was accompanied by this DRM header.
610: The user ID is delivered. The key system 180 sends to the client 110 the user ID.
620: The user enters a password that matches the user ID. The client 110 sends to the login system 160 the user ID and the password.
630: The user is authenticated. If the user ID and the password are correct, the login system 160 sends to the client 110 an auth token. The auth token authenticates the client 110 to the login system 160, thereby ensuring that the user who is requesting to play the content is the same user who purchased the content. If the purchasing user were to send the content to another user, that other user would not be able to play the content without getting the first user's password. Since the user's password provides access to the user's account, including details such as the user's credit card information, the first user is unlikely to freely provide his password to others.
640: The DD module information is requested. The client 110 sends to the DD module system 185 the encrypted DRM header, the auth token, and an identifier of the platform of the client. The DD module system 185 decrypts the encrypted DRM header to reveal the user ID and the version (major and minor) of the DD module that is needed to play the content that was accompanied by this DRM header. Note that the client 110 itself cannot decrypt the DRM header. In other words, the DRM header is completely opaque to the client 110.
650: The DD module information is delivered. The DD module system 185 sends to the client 110 the name of the version of the DD module and a DD module ID. The name of the version includes the same major and minor versions from the DRM header, in addition to a “revision” that represents the most recent revision of that major-minor pair. The DD module ID is based on the user ID and the version of the DD module. For example, the DD module ID is a cryptographic function of the user ID and the version of the DD module. Thus, the DD module ID can be determined based on the user ID and the version of the DD module, as long as the cryptographic function is known.
660: The DD module is requested. The client 110 sends to the DD module system 185 the encrypted DRM header, the auth token, the identifier of the platform of the client, and the name of the version of the DD module.
670: The DD module is delivered. The DD module system 185 sends to the client 110 a DD module that will play the content on the client's platform.
680: The content key is requested. The client 110 sends to the key system 180 the encrypted DRM header, the auth token, and a key challenge. In one embodiment, the key challenge is random and is given by the following expression:
EncryptDDmodulekey(random bytes)
where “random bytes” represents the data stored in a random area of memory, and
EncryptDDmodulekey(random bytes) means encrypt the value of “random bytes” using the DD module key. The “random area of memory” is where the content key will be stored once it has been decrypted, as explained below.
EncryptDDmodulekey(random bytes)
where “random bytes” represents the data stored in a random area of memory, and
EncryptDDmodulekey(random bytes) means encrypt the value of “random bytes” using the DD module key. The “random area of memory” is where the content key will be stored once it has been decrypted, as explained below.
685: Permission for the playback is requested. The key system 180 sends to the permission system 170 the user ID and the content ID. The permission system 170 locates the appropriate transaction record based on the user ID and the content ID. Based on the contents of the record, the permission system 170 determines whether the playback is permitted. As noted above, the permission system 170 can use a variety of different rules to determine whether the playback is permitted. For example, even if the user has purchased the content, the permission system 170 can deny the playback request if the user has already played the content a maximum number of times.
690: Permission for the playback is granted. If the playback is permitted, the permission system 170 sends this information to the key system 180.
695: Assuming that playback is permitted, the encrypted content key is delivered. The key system 180 sends to the client 110 an encrypted content key. The content key is the same content key that was used to encrypt the content. Assuming that the key challenge is given by the expression EncryptDDmodulekey(random bytes), the encrypted content key is determined as follows: The key system 180 determines a “delta” value, which is given by the expression
XOR(KeyChallenge, content_key), where XOR is the bit-wise exclusive-or operator. The key response (i.e., the encrypted content key) is then given by the expression EncryptDDmodulekey(delta). Later, in order to determine the content key, the key challenge is decrypted using the DD module key, which is known to the client 110. (This yields the delta.) Then, the delta is XOR'ed over the “random area of memory” (whose data was used in the key challenge. The key challenge bytes cancel out. As a result, the random area of memory now stores the content key.
At this point in time, the encrypted content key is located at the client 110. The client 110 can now decrypt and decompress the content, as described below.
B. Decrypting and Decompressing Content
In order to play the encrypted, compressed content, the player 145 in the client 110 uses a decryption-decompression (DD) module. FIG. 5 is a block diagram illustrating a DD module 500, according to one embodiment of the invention. In the illustrated embodiment, the DD module 500 includes a control module 505, a content decryption module 510, a content decompression module 520, a content key decryption module 530, and a communication mechanism. The communication mechanism communicatively the couples the control module 505, the content decryption module 510, the content decompression module 520, and the content key decryption module 530 to each other.
The content decryption module 510 decrypts content using a content key. This content key is the same content key that was generated by the permission system 170 and used to encrypt the content (see FIGS. 3 and 4 ).
The content decompression module 520 decompresses content. For example, if the content is a video clip, the content decompression module 520 is a video codec such as DivX or MPEG-4. If the content is an audio clip, the content decompression module 520 is an audio codec such as RealAudio or MP3.
The content key decryption module 530 decrypts a content key using a DD module key (also called a “master key”). The DD module key is the same DD module key that was used by the key system 180 to encrypt the content key. In one embodiment, after the content key has been decrypted, it is stored in non-consecutive memory locations for greater security.
The control module 505 controls operation of the DD module 500. In order to play the content that has been encrypted and compressed, the control module 505 performs the following tasks: Decrypt the encrypted content key using a DD module key and the content key decryption module 530. (This yields the content key.) Decrypt the encrypted, compressed content using the content key and the content decryption module 510. (This yields the compressed content.) Decompress the compressed content using the content decompression module 520. (This yields the uncompressed content, which can then be played.)
In other words, the DD module 500 uses two keys: a content key and a DD module key. The content key (which is used to decrypt content) is received from the key system 180 (see FIG. 6 ). In contrast, the DD module key (which is used to decrypt the content key) is “built-in” to the DD module 500.
Due to the code obfuscation of the DD module 500 and the content key decryption module 530, the DD module key cannot be readily extracted from the DD module by malicious parties. In one embodiment, the content key decryption module 530 is an implementation of the DES decryption algorithm, and thus the DD module key is a DES key. Instead of the content key decryption module 530 taking a key value as a parameter, the key value is “hard-coded” into the decryption logic of the module. For example, instead of decryption source code including a branch statement based on a key value, the source code instead takes the appropriate branch automatically because the key is already known.
As can now be appreciated, the system architecture 100 and associated processes provide for greater security and control than previous DRM approaches. The use of entirely server-side permission and authentication afford the capability to better control the access, purchase, download, and playback of content. Further, the various levels of encryption, and in particular the separate encryption of the DRM header (using a key unknown to the client 110), the content key (using a key built into the DD module 500 within the player 145 of the client 110), and the content (using the unique content key), operate to prevent malicious attacks on the player 145 and the content.
For example, because the DRM header is encrypted using a key that is never exposed to the client 110, an attacker would generally be unable to identify the necessary DD module 500. Further, the content key itself cannot be extracted without the DD module key. Because of the very large number of possible DD module keys (and the large number of different DD modules 500), an attack on an encrypted content key is also substantially prevented. As noted above, even if a particular instance of a DD module 500 is compromised and the DD module key extracted, the DD module key can only be used with that particular DD module 500 and its copies. Because of the very large number of different DD modules 500, the attacker would have no way of knowing with which other DD modules 500 to use the ill-gotten DD module key, thereby rendering the DD module key essentially useless (except for decrypting content keys (and, therefore, content) that have been received by the client 110 for use with that particular DD module).
The present invention has been described in particular detail with respect to one possible embodiment. Those of skill in the art will appreciate that the invention may be practiced in other embodiments. First, the particular naming of the components, capitalization of terms, the attributes, data structures, or any other programming or structural aspect is not mandatory or significant, and the mechanisms that implement the invention or its features may have different names, formats, or protocols. Further, the system may be implemented via a combination of hardware and software, as described, or entirely in hardware elements. Also, the particular division of functionality between the various system components described herein is merely exemplary, and not mandatory; functions performed by a single system component may instead be performed by multiple components, and functions performed by multiple components may instead performed by a single component.
Some portions of above description present the features of the present invention in terms of algorithms and symbolic representations of operations on information. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. These operations, while described functionally or logically, are understood to be implemented by computer programs. Furthermore, it has also proven convenient at times, to refer to these arrangements of operations as modules or by functional names, without loss of generality.
Unless specifically stated otherwise as apparent from the above discussion, it is appreciated that throughout the description, discussions utilizing terms such as “determining” or “displaying” or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system memories or registers or other such information storage, transmission or display devices.
Certain aspects of the present invention include process steps and instructions described herein in the form of an algorithm. It should be noted that the process steps and instructions of the present invention could be embodied in software, firmware or hardware, and when embodied in software, could be downloaded to reside on and be operated from different platforms used by real time network operating systems.
The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general-purpose computer selectively activated or reconfigured by a computer program stored on a computer readable medium that can be accessed by the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, application specific integrated circuits (ASICs), or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus. Furthermore, the computers referred to in the specification may include a single processor or may be architectures employing multiple processor designs for increased computing capability.
The algorithms and operations presented herein are not inherently related to any particular computer or other apparatus. Various general-purpose systems may also be used with programs in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will be apparent to those of skill in the art, along with equivalent variations. In addition, the present invention is not described with reference to any particular programming language. It is appreciated that a variety of programming languages may be used to implement the teachings of the present invention as described herein, and any references to specific languages are provided for invention of enablement and best mode of the present invention.
The present invention is well suited to a wide variety of computer network systems over numerous topologies. Within this field, the configuration and management of large networks comprise storage devices and computers that are communicatively coupled to dissimilar computers and storage devices over a network, such as the Internet.
Finally, it should be noted that the language used in the specification has been principally selected for readability and instructional purposes, and may not have been selected to delineate or circumscribe the inventive subject matter. Accordingly, the disclosure of the present invention is intended to be illustrative, but not limiting, of the scope of the invention, which is set forth in the following claims.
Claims (20)
1. A method for controlling playback of encrypted media content, comprising:
receiving a request from a client for an encrypted content key, the request comprising a key challenge and a client-opaque encrypted DRM header, the DRM header comprising an identifier indicating a decryption-decompression module for use by the client in decrypting the encrypted media content;
determining whether playback by the client of the encrypted media content is allowed; and
responsive to determining that playback by the client is allowed:
sending the encrypted content key to the client; and
sending the decryption-decompression module associated with the identifier to the client for use in decrypting the encrypted content key and the encrypted media content.
2. The method of claim 1 , wherein the decryption-decompression module includes a content key decryption module having a built in master key.
3. The method of claim 2 , wherein the built-in master key is determined based on a unique identifier of the content key decryption module.
4. The method of claim 1 , wherein the request for the encrypted content key includes an authentication token that authenticates a user.
5. The method of claim 1 , wherein the encrypted content key comprises a key encrypted using the Data Encryption Standard (DES).
6. The method of claim 1 , wherein the encrypted media content comprises media content encrypted using the Advanced Encryption Standard (AES).
7. The method of claim 1 , wherein the decryption-decompression module comprises a content decryption module configured to decrypt the encrypted media content using a content key obtained by decrypting the encrypted content key.
8. The method of claim 1 , further comprising:
receiving a request for the decryption-decompression module.
9. The method of claim 8 , wherein the request for the decryption-decompression module comprises an identification of a version of the decryption-decompression module.
10. The method of claim 9 , wherein the identification of the version of the decryption-decompression module is encrypted.
11. The method of claim 8 , wherein the request for the decryption-decompression module includes an authentication token that authenticates a user.
12. The method of claim 8 , wherein the request for the decryption-decompression module identifies a computing platform.
13. The method of claim 1 , further comprising:
receiving a request from the client for an identification of a version of the decryption-decompression module; and
sending to the client the identification of the version of the decryption-decompression module.
14. The method of claim 13 , wherein the request for the identification of the version of the decryption-decompression module includes encrypted data, wherein the encrypted data includes the identification of the version of the decryption-decompression module.
15. A computer program product for controlling playback of encrypted media content, comprising:
a non-transitory computer-readable storage medium;
computer program code, encoded on the medium, for:
receiving a request from a client for an encrypted content key, the request comprising a key challenge and a client-opaque encrypted DRM header, the DRM header comprising an identifier indicating a decryption-decompression module for use by a client in decrypting the encrypted media content;
determining whether playback of the encrypted media content by the client is allowed; and
responsive to determining that playback by the client is allowed:
sending the encrypted content key to the client; and
sending the decryption-decompression module associated with the identifier to the client for use in decrypting the encrypted content key and the encrypted media content.
16. The method of claim 15 , wherein the encrypted content key comprises a key encrypted using the Data Encryption Standard (DES).
17. The method of claim 15 , wherein the encrypted media content comprises media content encrypted using the Advanced Encryption Standard (AES).
18. The method of claim 15 , wherein the decryption-decompression module comprises a content decryption module configured to decrypt the encrypted media content using a content key obtained by decrypting the encrypted content key.
19. A system for controlling playback of encrypted media content, comprising:
a receiving module configured to receive a request from a client for an encrypted content key, the request comprising a client-opaque encrypted DRM header, and the DRM header comprising an identifier indicating a decryption-decompression module for use by a client in playing the encrypted media content;
a determining module configured to determine whether playback of the encrypted media content by the client is allowed; and
a sending module configured to responsive to determining that playback by the client is allowed:
send the encrypted content key to the client; and
send the decryption-decompression module associated with the identifier to the client for use in decrypting the encrypted content key and the encrypted media content.
20. A computer program product, comprising non transistory computer readable medium;
a client-opaque encrypted DRM header stored on the computer readable medium, the DRM header comprising a user identifier, a content identifier indicating the encrypted media content, and an identifier indicating a decryption-decompression module for use by a client in decrypting the encrypted media content.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/280,050 US8407466B2 (en) | 2007-01-09 | 2011-10-24 | Controlling download and playback of media content |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US11/621,464 US8074083B1 (en) | 2007-01-09 | 2007-01-09 | Controlling download and playback of media content |
US13/280,050 US8407466B2 (en) | 2007-01-09 | 2011-10-24 | Controlling download and playback of media content |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/621,464 Continuation US8074083B1 (en) | 2007-01-09 | 2007-01-09 | Controlling download and playback of media content |
Publications (2)
Publication Number | Publication Date |
---|---|
US20120066494A1 US20120066494A1 (en) | 2012-03-15 |
US8407466B2 true US8407466B2 (en) | 2013-03-26 |
Family
ID=45034522
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/621,464 Expired - Fee Related US8074083B1 (en) | 2007-01-09 | 2007-01-09 | Controlling download and playback of media content |
US13/280,050 Active US8407466B2 (en) | 2007-01-09 | 2011-10-24 | Controlling download and playback of media content |
Family Applications Before (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/621,464 Expired - Fee Related US8074083B1 (en) | 2007-01-09 | 2007-01-09 | Controlling download and playback of media content |
Country Status (1)
Country | Link |
---|---|
US (2) | US8074083B1 (en) |
Families Citing this family (25)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8074083B1 (en) * | 2007-01-09 | 2011-12-06 | Google Inc. | Controlling download and playback of media content |
CN100452074C (en) * | 2007-01-17 | 2009-01-14 | 北京大学 | Copyright protection method and system for digital contents controlled by time |
US8595492B2 (en) * | 2008-08-21 | 2013-11-26 | PIX System, LLC | On-demand protection and authorization of playback of media assets |
US8458799B2 (en) * | 2009-06-30 | 2013-06-04 | Nokia Corporation | Method and apparatus for providing a scalable service platform using a network cache |
EP2507995A4 (en) | 2009-12-04 | 2014-07-09 | Sonic Ip Inc | Elementary bitstream cryptographic material transport systems and methods |
CN101925060A (en) * | 2010-08-27 | 2010-12-22 | 西安西电捷通无线网络通信股份有限公司 | Entity identification method and system of energy-constrained network |
CN102014386B (en) * | 2010-10-15 | 2012-05-09 | 西安西电捷通无线网络通信股份有限公司 | Entity authentication method and system based on symmetrical code algorithm |
US9247312B2 (en) | 2011-01-05 | 2016-01-26 | Sonic Ip, Inc. | Systems and methods for encoding source media in matroska container files for adaptive bitrate streaming using hypertext transfer protocol |
US8595211B1 (en) * | 2011-02-25 | 2013-11-26 | Symantec Corporation | Techniques for managing search engine results |
US9467708B2 (en) | 2011-08-30 | 2016-10-11 | Sonic Ip, Inc. | Selection of resolutions for seamless resolution switching of multimedia content |
US8787570B2 (en) | 2011-08-31 | 2014-07-22 | Sonic Ip, Inc. | Systems and methods for automatically genenrating top level index files |
US8909922B2 (en) | 2011-09-01 | 2014-12-09 | Sonic Ip, Inc. | Systems and methods for playing back alternative streams of protected content protected using common cryptographic information |
US8751800B1 (en) | 2011-12-12 | 2014-06-10 | Google Inc. | DRM provider interoperability |
US9191457B2 (en) | 2012-12-31 | 2015-11-17 | Sonic Ip, Inc. | Systems, methods, and media for controlling delivery of content |
JP2014171061A (en) * | 2013-03-01 | 2014-09-18 | Kddi Corp | Content delivery system, device, and program |
KR20140130283A (en) * | 2013-04-30 | 2014-11-10 | (주)잉카엔트웍스 | Terminal apparatus and method for using encrypted multimedia contents applied drm |
US9503433B2 (en) * | 2014-03-27 | 2016-11-22 | Intel Corporation | Method and apparatus for cloud-assisted cryptography |
US10225298B2 (en) | 2015-01-06 | 2019-03-05 | Divx, Llc | Systems and methods for encoding and sharing content between devices |
WO2016175976A1 (en) * | 2015-04-28 | 2016-11-03 | Alibaba Group Holding Limited | A computerized system and method for implementing digital rights management |
CN106156545B (en) * | 2015-04-28 | 2019-06-28 | 阿里巴巴集团控股有限公司 | Realize method, client and the system of digital copyright management |
US10602094B1 (en) * | 2016-06-21 | 2020-03-24 | Amazon Technologies, Inc. | Entitlement access token |
US11055437B2 (en) * | 2018-02-02 | 2021-07-06 | Florida Atlantic University Board Of Trustees | Systems and methods for ensuring privacy in online information sharing applications |
US11681781B2 (en) * | 2018-02-21 | 2023-06-20 | Comcast Cable Communications, Llc | Systems and methods for content security |
CN108768920B (en) * | 2018-03-26 | 2021-09-21 | 苏州科达科技股份有限公司 | Recorded broadcast data processing method and device |
US20220385730A1 (en) * | 2021-05-25 | 2022-12-01 | WarnerMedia Direct, LLC | Rules engine for controlling content access |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4783798A (en) * | 1985-03-14 | 1988-11-08 | Acs Communications Systems, Inc. | Encrypting transponder |
US20020053030A1 (en) * | 2000-10-27 | 2002-05-02 | Weng Chien Sen | Method and system for data encryption/decryption in a client-server architecture |
US7647507B1 (en) * | 2003-07-08 | 2010-01-12 | Marvell International Ltd. | Secure digital content distribution system and secure hard drive |
US8074083B1 (en) * | 2007-01-09 | 2011-12-06 | Google Inc. | Controlling download and playback of media content |
Family Cites Families (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6289455B1 (en) | 1999-09-02 | 2001-09-11 | Crypotography Research, Inc. | Method and apparatus for preventing piracy of digital content |
US6683954B1 (en) | 1999-10-23 | 2004-01-27 | Lockstream Corporation | Key encryption using a client-unique additional key for fraud prevention |
CN1928818A (en) * | 2005-09-09 | 2007-03-14 | 鸿富锦精密工业（深圳）有限公司 | Network device and software updating method thereof |
-
2007
- 2007-01-09 US US11/621,464 patent/US8074083B1/en not_active Expired - Fee Related
-
2011
- 2011-10-24 US US13/280,050 patent/US8407466B2/en active Active
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4783798A (en) * | 1985-03-14 | 1988-11-08 | Acs Communications Systems, Inc. | Encrypting transponder |
US20020053030A1 (en) * | 2000-10-27 | 2002-05-02 | Weng Chien Sen | Method and system for data encryption/decryption in a client-server architecture |
US7647507B1 (en) * | 2003-07-08 | 2010-01-12 | Marvell International Ltd. | Secure digital content distribution system and secure hard drive |
US8074083B1 (en) * | 2007-01-09 | 2011-12-06 | Google Inc. | Controlling download and playback of media content |
Also Published As
Publication number | Publication date |
---|---|
US8074083B1 (en) | 2011-12-06 |
US20120066494A1 (en) | 2012-03-15 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US8407466B2 (en) | Controlling download and playback of media content | |
US7975312B2 (en) | Token passing technique for media playback devices | |
US8881274B2 (en) | Method for providing data to a personal portable device via network and a system thereof | |
AU2001253243B2 (en) | Secure digital content licensing system and method | |
US7155415B2 (en) | Secure digital content licensing system and method | |
KR100605071B1 (en) | System and method for secure and convenient management of digital electronic content | |
EP1944905B1 (en) | An encrypted transmission method and equipment system for preventing copying the data resource | |
US7979697B2 (en) | Securing digital content system and method | |
JP5331920B2 (en) | Computer-readable storage medium | |
US8091137B2 (en) | Transferring a data object between devices | |
TW486902B (en) | Method capable of preventing electronic documents from being illegally copied and its system | |
JP2004046856A (en) | Method for obtaining digital license corresponding to digital content | |
AU2001253243A1 (en) | Secure digital content licensing system and method | |
KR20010106325A (en) | Wireless pda ebook contents service method and system with user authentication function for the digital rights management | |
US7802109B2 (en) | Trusted system for file distribution | |
JPH10301904A (en) | Cryptographic system provided with decoding key made into transaction code | |
JP2004038974A (en) | System and method for issuing usage license for digital content and service | |
JP2005526320A (en) | Secure content sharing in digital rights management | |
JP2011507414A (en) | System and method for protecting data safety | |
JP2002077137A (en) | System and method for protection of digital works | |
US20090282245A1 (en) | Security method and system for media playback devices | |
WO2003003213A1 (en) | System for protecting copyrighted materials | |
Diehl et al. | Protection in Unicast/Multicast |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
CC | Certificate of correction | ||
FPAY | Fee payment |
Year of fee payment: 4 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044695/0115Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 8TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1552); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 8 |