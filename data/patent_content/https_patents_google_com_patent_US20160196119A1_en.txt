US20160196119A1 - Apparatus and Methods for Virtual and Interface Method Calls - Google Patents
Apparatus and Methods for Virtual and Interface Method Calls Download PDFInfo
- Publication number
- US20160196119A1 US20160196119A1 US14/589,898 US201514589898A US2016196119A1 US 20160196119 A1 US20160196119 A1 US 20160196119A1 US 201514589898 A US201514589898 A US 201514589898A US 2016196119 A1 US2016196119 A1 US 2016196119A1
- Authority
- US
- United States
- Prior art keywords
- interface
- virtual
- entry
- runtime
- called
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Abandoned
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/44—Arrangements for executing specific programs
- G06F9/448—Execution paradigms, e.g. implementations of programming paradigms
- G06F9/4488—Object-oriented
- G06F9/449—Object-oriented method invocation or resolution
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/30—Creation or generation of source code
- G06F8/36—Software reuse
Definitions
- FIG. 4 shows a diagram of a runtime environment, in accordance with an example embodiment.
- FIG. 6 shows a computing device with source code and corresponding runtime environment that is related to the runtime environment of FIG. 4 , in accordance with an example embodiment.
- vptrs and interface method table pointers By increasing performance of method dispatch and calling, the overall performance of applications written in object-oriented languages can be increased. Further, by eliminating vptrs and interface method table pointers, some memory can be saved in the overall implementation of runtime class instances that include vtables and interface method tables, and, as indicated above, time involved in taking indirections of following vptrs and interface method table pointers can be saved. Application performance can be further enhanced by taking some additional storage to store entry points of methods in included vtables and interface method tables. Storage of entry points can lead to additional complexity in debugging if entry points are modified; e.g., a debugger may change an entry point to refer to a reporting module that indicates when a method is called. However, this additional complexity is manageable, and may be reduced or eliminated after software applications are debugged and provided to end-users as production software.
- Virtual table pointer 126 refers or points to virtual method table (vtable) 132 .
- Vtable 132 can be an array (or other data structure) of vtable entries. Each vtable entry can include a reference address for a corresponding runtime method.
- Method 200 can begin at block 210 , where the computing device can load a class instance having an interface method table pointer and a virtual table pointer, such as class instance 120 .
- the computing device can decide whether a virtual method is being called or an interface method is being called. If a virtual method is being called, the computing device can proceed to block 230 ; otherwise, an interface method is being called, and the computing device can proceed to block 240 .
- the computing device can load a vtable from a vptr of the class instance. Then, at block 232 , the computing device can use the method index of the called method to index into the vtable and find a vtable entry for the called method. Then, the computing device can use the found vtable entry to obtain a reference to a runtime method corresponding to the called method; e.g., the value of a starting address of the corresponding runtime method. Upon completing block 232 , the computing device can proceed to block 250 .
- Table 5A illustrates how computing device 400 can apply method 500 to runtime environment 602 to call interface methods IM 1 and IM 2 .
- Block IM1 Call IM2 Call Block 510 (Load Load class instance 420a at 0xa800 The procedures for blocks 510 and class instance) using class Ex2 pointer 608 of 520 of method 500 can be used for receiver instance 606.
- a call to interface method IM2 in Block 520 This is an interface method call, so the same way as described for the (Virtual/Interface proceed to block 540. call to interface method IM1.
- Method Test Block 540 (Obtain The method index for IM1 is 0.
- the method index for IM1 is 1. runtime method Index into interface method table Index into interface method table reference) 424a of class instance 420a to find 424a of class instance 420a to find entry 0. Reference (starting address entry 1.
- entries of interface method table 724 and vtable 726 of class instance 720 store additional entry point data and so utilize more space than corresponding entries of interface method table 424 and vtable 426 of class instance 420 .
- dispatching and calling a virtual/interface method can be simplified by loading entry points directly, thereby likely increasing performance of method dispatches/calls.
- FIG. 9 shows that runtime environment 702 also includes five runtime methods summarized in Table 6 below.
- Table 6 is related to Tables 2 and 4 above—Table 6 has the same information as Tables 2 and 4, save that the numbers of the runtime methods differ between the respective first columns of Tables 2, 4, and 6.
- Table 7B illustrates how computing device 700 can apply method 800 to runtime environment 902 to call virtual methods VM 1 , VM 2 , and VM 3 .
- FIG. 10 depicts a distributed computing architecture 1000 with server devices 1008 , 1010 configured to communicate, via network 1006 , with programmable devices 1004 a, 1004 b, 1004 c, 1004 d, and 1004 e, in accordance with an example embodiment.
- Network 1006 may correspond to a LAN, a wide area network (WAN), a corporate intranet, the public Internet, or any other type of network configured to provide a communications path between networked computing devices.
- the network 1006 may also correspond to a combination of one or more LANs, WANs, corporate intranets, and/or the public Internet.
- Server devices 1008 , 1010 can be configured to perform one or more services, as requested by programmable devices 1004 a - 1004 e.
- server device 1008 and/or 1010 can provide content to programmable devices 1004 a - 1004 e.
- the content can include, but is not limited to, web pages, hypertext, scripts, binary data such as compiled software, images, audio, and/or video.
- the content can include compressed and/or uncompressed content.
- the content can be encrypted and/or unencrypted. Other types of content are possible as well.
- Computing device 1100 may include a user interface module 1101 , a network-communication interface module 1102 , one or more processors 1103 , and data storage 1104 , all of which may be linked together via a system bus, network, or other connection mechanism 1105 .
- Wireline interfaces 1108 can include one or more wireline transmitters, receivers, and/or transceivers, such as an Ethernet transceiver, a Universal Serial Bus (USB) transceiver, or similar transceiver configurable to communicate via a twisted pair wire, a coaxial cable, a fiber-optic link, or a similar physical connection to a wireline network.
- wireline transmitters such as an Ethernet transceiver, a Universal Serial Bus (USB) transceiver, or similar transceiver configurable to communicate via a twisted pair wire, a coaxial cable, a fiber-optic link, or a similar physical connection to a wireline network.
- USB Universal Serial Bus
- Processors 1103 can include one or more general purpose processors and/or one or more special purpose processors (e.g., digital signal processors, graphics processing units, application specific integrated circuits, etc.). Processors 1103 can be configured to execute computer-readable program instructions 1106 that are contained in the data storage 1104 and/or other instructions as described herein.
- processors 1103 can include one or more general purpose processors and/or one or more special purpose processors (e.g., digital signal processors, graphics processing units, application specific integrated circuits, etc.).
- Processors 1103 can be configured to execute computer-readable program instructions 1106 that are contained in the data storage 1104 and/or other instructions as described herein.
- computing device 1100 can include one or more sensors.
- the sensor(s) can be configured to measure conditions in an environment for computing device 1100 and provide data about that environment.
- the data can include, but is not limited to, location data about computing device 1100 , velocity (speed, direction) data about computing device 1100 , acceleration data about computing device, and other data about the environment for computing device 1100 .
- the sensor(s) can include, but are not limited to, GPS sensor(s), location sensors(s), gyroscope(s), accelerometer(s), magnetometer(s), camera(s), light sensor(s), infrared sensor(s), and microphone(s). Other examples of sensors are possible as well.
- determining the entry point for the called software method based the at least one of the interface method table and the virtual method table can include the computing device, upon determining that the called software method is an interface method of the software interface: determining a called interface method table entry of the interface method table that is associated with the called software method and determining the entry point based on the called interface method table entry, such as discussed above in the context of at least FIGS. 4-9 .
- the computing device can call the called software method by executing instructions at the entry point, such as discussed above in the context of at least FIGS. 4-9 .
- a block that represents a processing of information may correspond to circuitry that can be configured to perform the specific logical functions of a herein-described method or technique.
- a block that represents a processing of information may correspond to a module, a segment, or a portion of program code (including related data).
- the program code may include one or more instructions executable by a processor for implementing specific logical functions or actions in the method or technique.
- the program code and/or related data may be stored on any type of computer readable medium such as a storage device including a disk or hard drive or other storage medium.
Abstract
Disclosed are apparatus and methods for calling software methods. A computing device can receive a request to call a software method of a class instance which can include an interface method table and a virtual method table (vtable). The interface method table can include interface method table entries, which can include a particular interface method table entry for a particular interface method of a software interface associated with the class instance. The particular interface method table entry can refer to the particular interface method. The vtable can include vtable entries, which can include a particular vtable entry for a particular virtual method associated with the class instance. The particular vtable entry can refer to the particular virtual method. The computing device can determine an entry point for the called software method based on the interface method table and/or the vtable. The computing device can call the called software method by executing instructions at the entry point.
Description
- Unless otherwise indicated herein, the materials described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.
- Modern software is often constructed using object-oriented principles, where a collection of objects are utilized to perform tasks of and store data related to the software. Many objects include methods, or software functions, that operate on data, including but not limited to data, stored as part of the object. An object can be defined in software as a class, which includes lists of methods and data for the object. A class can act as an archetype for a collection of more-specialized classes. For example, in object-oriented graphics software, a class of a polygon can be used as an archetype for classes of a triangle, a square, a hexagon, etc. The archetypical class can be termed the base class and the more-specialized classes can be termed subclasses of the base class.
- In one aspect, a method is provided. A computing device receives a request to call a software method of a class instance. The class instance includes an interface method table and a virtual method table. The interface method table includes one or more interface method table entries. The one or more interface method table entries include a particular interface method table entry for a particular interface method of a software interface associated with the class instance. The particular interface method table entry includes a reference related to the particular interface method. The virtual method table includes one or more virtual table entries. The one or more virtual table entries include a particular virtual table entry for a particular virtual method associated with the class instance. The particular virtual table entry includes a reference related to the particular virtual method. The computing device determines an entry point for the called software method based on at least one of the interface method table and the virtual method table. The computing device calls the called software method by executing instructions at the entry point.
- In another aspect, a computing device is provided. The computing device includes one or more processors and data storage. The data storage has instructions stored thereon that, upon execution of the instructions by the one or more processors, cause the one or more processors to perform functions. The functions include: receiving a request to call a software method of a class instance, where the class instance includes an interface method table and a virtual method table, where the interface method table includes one or more interface method table entries and the virtual method table includes one or more virtual table entries, where the one or more interface method table entries include a particular interface method table entry for a particular interface method of a software interface associated with the class instance, the particular interface method table entry including a reference related to the particular interface method, where the one or more virtual table entries include a particular virtual table entry for a particular virtual method associated with the class instance, the particular virtual table entry including a reference related to the particular virtual method; determining an entry point for the called software method based on at least one of the interface method table and the virtual method table; and calling the called software method by executing instructions at the entry point.
- In yet another aspect, an article of manufacture is provided. The article of manufacture includes data storage having instructions stored thereon that, when executed by one or more processors, cause the one or more processors to perform functions. The functions include: receiving a request to call a software method of a class instance, where the class instance includes an interface method table and a virtual method table, where the interface method table includes one or more interface method table entries and the virtual method table includes one or more virtual table entries, where the one or more interface method table entries include a particular interface method table entry for a particular interface method of a software interface associated with the class instance, the particular interface method table entry including a reference related to the particular interface method, where the one or more virtual table entries include a particular virtual table entry for a particular virtual method associated with the class instance, the particular virtual table entry including a reference related to the particular virtual method; determining an entry point for the called software method based on at least one of the interface method table and the virtual method table; and calling the called software method by executing instructions at the entry point.
- In even another aspect, a device is provided. The device includes: means for: receiving a request to call a software method of a class instance, where the class instance includes an interface method table and a virtual method table, where the interface method table includes one or more interface method table entries and the virtual method table includes one or more virtual table entries, where the one or more interface method table entries include a particular interface method table entry for a particular interface method of a software interface associated with the class instance, the particular interface method table entry including a reference related to the particular interface method, where the one or more virtual table entries include a particular virtual table entry for a particular virtual method associated with the class instance, the particular virtual table entry including a reference related to the particular virtual method; means for determining an entry point for the called software method based on at least one of the interface method table and the virtual method table; and means for calling the called software method by executing instructions at the entry point.
- In the figures:
-
FIG. 1 shows a diagram of a runtime environment, in accordance with an example embodiment. -
FIG. 2 is a flowchart of an example method, in accordance with an example embodiment. -
FIG. 3 shows a computing device with source code and corresponding runtime environment that is related to the runtime environment ofFIG. 1 , in accordance with an example embodiment. -
FIG. 4 shows a diagram of a runtime environment, in accordance with an example embodiment. -
FIG. 5 is a flowchart of another example method, in accordance with an example embodiment. -
FIG. 6 shows a computing device with source code and corresponding runtime environment that is related to the runtime environment ofFIG. 4 , in accordance with an example embodiment. -
FIG. 7 shows a diagram of a runtime environment, in accordance with an example embodiment. -
FIG. 8 is a flow chart illustrating another method, in accordance with an example embodiment. -
FIG. 9 shows a computing device with source code and a corresponding runtime environment that is related to the runtime environment ofFIG. 7 , in accordance with an example embodiment. -
FIG. 10 depicts a distributed computing architecture, in accordance with an example embodiment. -
FIG. 11A is a block diagram of a computing device, in accordance with an example embodiment. -
FIG. 11B depicts a cloud-based server system, in accordance with an example embodiment. -
FIG. 12 is a flow chart illustrating another method, in accordance with an example embodiment. - A modern computing device can include an operating system, which is software that manages hardware resources of the computing device and provides common services for computer programs, such as application programs that execute on the computing device. Application programs, or simply applications, can use the services provided by the operating system to carry out one or more tasks. Some of the services provided by the operating system can involve runtime services, or services that support execution of computer programs, including applications. For example, an operating system can have runtime services that provide and/or support a runtime system, such as a Java runtime system for executing Java programs.
- For applications written in object oriented languages such as Java, objects can have virtual and/or interface methods. A virtual method is a method of a class that is (or can be) overridden, or replaced, by a method having the same name in a subclass that inherits properties from the class. An interface method is a method that implements part or all of a specified interface. It is not unusual that some of the method calls of an application are virtual method and/or interface method calls, in order to take advantage of naming and other benefits associated with object oriented programming. As a result, the performance of virtual and interface method calls can be critical to the overall performance of the runtime system.
- To implement a method call, the run time system can first dispatch, or select, a method for execution, and then call, or execute, the dispatched method. The specification of virtual/interface method calls can involve use of complicated method resolution rules often involving iterating through a method list and traversing a corresponding class hierarchy. To speed method dispatch, the runtime system can use, on a per-class basis, “vtables” for virtual methods and interface method tables for interface methods, where the term vtable is short for virtual method table. A vtable is a variable length table (or similar data structure) of table entries, with each entry including an identifier for a virtual method and a reference to the corresponding virtual method. Similarly, each entry in an interface method table includes an identifier for an interface method and a reference to the corresponding interface method.
- By paying a one-time cost of laying out the tables, often during class linking time, no further method resolution is needed at each invocation time. At runtime, virtual/interface method dispatching is as simple as looking up vtable/interface method tables using the index of the invoked method. However, in an object layout of a managed runtime system, a number of indirections (dependent loads) can be used to finally locate and execute a dispatched method, including indirections to follow a vptr (virtual table pointer) to find a vtable for virtual method dispatch and indirections to follow an interface method table pointer to an interface method table for interface method dispatch. Those indirections can incur substantial performance penalties on modern processors and as a result hurt the performance of virtual/interface calls, and thus harm application performance.
- To reduce these indirections, a class instance can include vtables and/or interface method tables to reduce the respective indirections used for vptrs and interface method table points, thus eliminating indirections to find vtables and interface method tables. In particular embodiments, entries of vtables and/or interface method tables can be extended to store (data related to) entry points of methods, and further increase performance of virtual/interface calls. An entry point can be an address of a first executable instruction of a method; that is, the entry point can be a starting address for executing instructions that make up the method. The entry point can be inserted by a compiler, interpreter, or other translating software that generates instructions from source code that can be executed by a computing device at runtime.
- By increasing performance of method dispatch and calling, the overall performance of applications written in object-oriented languages can be increased. Further, by eliminating vptrs and interface method table pointers, some memory can be saved in the overall implementation of runtime class instances that include vtables and interface method tables, and, as indicated above, time involved in taking indirections of following vptrs and interface method table pointers can be saved. Application performance can be further enhanced by taking some additional storage to store entry points of methods in included vtables and interface method tables. Storage of entry points can lead to additional complexity in debugging if entry points are modified; e.g., a debugger may change an entry point to refer to a reporting module that indicates when a method is called. However, this additional complexity is manageable, and may be reduced or eliminated after software applications are debugged and provided to end-users as production software.
- Example Class Runtime Environments and Related Methods
- A vtable (or interface method table) can be constructed to give each virtual method (or interface method) a fixed entry. Then, when a runtime instance of a subclass is created, a copy of the superclass's vtable can be made and used to initialize the subclass's vtable. Then, the subclass's vtable can be modified; e.g., the vtable can be extended by appending new entries for new methods or overwriting entries for methods that the subclass overrides.
- An interface method table can represent all interface methods of a class. In some embodiments, a fixed-size interface method table can be used. For example, to dispatch a particular interface method, a hash value for the particular interface method can be calculated based on a method signature for the particular interface method. The method signature for a method, such as the particular interface method, can include the method's name, return type (if any), and types of any parameters for the method. For example, the method signature for an example method “int ExampleMethod1(int a, char b)” can be “int ExampleMethod1 int char”. Then, a unique index or identifier for the particular interface method can be determined based on the method signature for the particular interface method. The hash value can be the unique index or identifier, a value calculated based on the method signature, or some other value.
- The hash value for the particular interface method can be used to index into the interface method table to find an interface method table entry. To dispatch the particular interface method, the interface method table entry can store a reference to a runtime method corresponding to the particular interface method. Then, the runtime method can be executed to perform a call of the particular interface method.
- The interface method table can be constructed by iterating through each implemented interface and filling in the interface method table entries with data for corresponding methods provided by the class for that interface. In these embodiments, the interface method table has a fixed size so it is possible that two or more distinct interface methods can index to the same interface method table entry. These two or more distinct interface methods can be classified as conflicting interface methods. When conflicting interface methods are found, the entry in the interface method table corresponding to the conflicting interface methods can include a reference to a conflict-resolution software that can determine, at runtime, which of the two or more distinct interface methods was actually intended to be called, and can then call the intended interface methods. Other techniques for implementing fixed-size interface method tables are possible.
- Each virtual method has an index, called a method index, which corresponds to its vtable entry. The vtable can be a variable length data structure, depending on how many virtual methods that the class has. An interface method table on the other hand, is a fixed-size table. Each interface method is given a fixed index, also called a method index, which is used for indexing into a corresponding entry in the interface method table. If two interface methods have the same method index corresponding to the same entry of an interface method table, a conflict happens. In case of a conflict, a reference to a conflict-resolution method can be entered into the entry of the interface method table. In some scenarios, a class implements few (if any) interface methods; thus, when the rate of conflict is low enough, an interface method table can increase interface method performance.
- Table 1 below shows an outline in pseudo code for source code a software interface having a number N of interface methods and an outline in pseudo code for source code of a class that implements the N interface methods of the software interface and additionally has P virtual methods.
-
TABLE 1 // outline of a software interface interface.Intf1 { IM1( ... ); // IM1 = interface method 1IM2( ... ); // interface method 2... IMn( ... ); // interface method N, assuming N > 2. } // outline of an class that implements interface Intf1 class Ex1 implements Intf1 { // interface methods to implement Intf1 start here IM1( ... ) { ... }; IM2( ... ) { ... }; ... IMN( ... ) { ... }; // outline of additional virtual methods start here VM1( ... ) { ... }; VM2( ... ) { ... }; ... VMP( ... ) { ... }; } main(...) { ... Int1 = new Ex1; // create an instantiation of class Ex1. ... } - In other examples, the source code is not related to a software interface. In such examples, interfaces, such as interface “Intf1” shown above, would not be present in the source code, N would equal 0, and the class “Ex1” would have no interface methods. In these examples, P would usually be greater than 0, as many classes have at least one method, but both N and P can equal 0 in particular examples. In even other examples, N and/or P can be less than 3; e.g., the interface “Intf1” can have one or two methods and/or the class “Ex1” can have one or two additional virtual methods. In still other examples, the class “Ex1” can implement interface “Intf1” without using additional virtual methods; i.e., N>0, and P=0.
-
FIG. 1 shows a diagram ofruntime environment 102, in accordance with an example embodiment.Runtime environment 102 can be provided bycomputing device 100 to support a class that implements a software interface, such as example class “Ex1” implementing interface “Intf1” indicated using the source code that is outlined above in Table 1. -
FIG. 1 showsclass instance 120 withdata 122, interfacemethod table pointer 124, and virtual table pointer (VPtr) 126.Data 122 can include storage for class variables and other data. Interfacemethod table pointer 124 refers or points to interface method table 130. Interface method table 130 can be an array (or other data structure) of interface method table entries. Each table entry can include a reference address for a corresponding compiled method. Interface method table 130 includes N interface method table entries corresponding to the N interface methods of the class:entry 0 referring to an interface method IM1 or “interface method 1” of interface “Intf1” of Table 1,entry 1 for interface method IM2 or “interface method 2” of interface “Intf1” of Table 1, and so on, until reaching entry N-1 for interface method IMN or “interface method N” of interface “Intf1” of Table 1. Each of interface methods IM1, IM2 . . . IMN can be implemented by the class represented byclass instance 120 and/or by a parent class of the class represented byclass instance 120. -
FIG. 1 shows thatentry 1 of interface method table 130 refers to interface method IM2. A runtime method includes computer-executable instructions generated by compiling, interpreting, and/or otherwise translating source code of a software method; for example,runtime method 140 includes computer-executable instructions corresponding to interface method IM2. Then, asentry 1 refers to interface method IM2,entry 1 of interface method table 130 includes a reference toruntime method 140. - In the example shown in
FIG. 1 ,entry 1 of interface method table 130 includes a value of a starting address SA1 ofruntime method 140. In some embodiments, the first address of a runtime method can hold an entry point value. For example, suppose that SA1=0x010000 (hexadecimal 10000=65,536 decimal) and EP1=0x010040 (65,560 decimal). Then, the contents of starting address 0x010000 ofruntime method 140 can equal 0x010040, which is the entry point forruntime method 140. - In other embodiments, the first address of a runtime method can store data related to the entry point; e.g., the starting address can store an entry point offset from the starting address value to the entry point. For example, again suppose that SA1=0x010000 and EP1=0x010040. The offset from starting address SA1 to entry point EP1 is the difference EP1−SA1=0x010040-0x010000=0x000040 (64 decimal). Then, the contents of starting address 0x010000 of
runtime method 140 can equal 0x000040 which is the entry point offset value. - The contents of address SA1 as shown in
FIG. 1 as “<EP1>” which is the value of an entry point forruntime method 140.FIG. 1 indicates that a “First Instruction” ofruntime method 140 is stored at address EP1, and so indicates that address SA1 stores an entry point value forruntime method 140. -
Virtual table pointer 126 refers or points to virtual method table (vtable) 132.Vtable 132 can be an array (or other data structure) of vtable entries. Each vtable entry can include a reference address for a corresponding runtime method. -
Vtable 132 includes P vtable entries corresponding to the P interface methods of the class:entry 0 referring to an virtual method VM1 or “virtual method 1” of class “Ex1” of Table 1,entry 1 referring to a virtual method VM2 or “virtual method 2” of class “Ex1” of Table 1, and so on, until reaching entry P-1 for virtual method VMP or “virtual method P” of class “Ex1” of Table 1. Each of virtual methods VM1, VM2 . . . VMP can be implemented by the class represented byclass instance 120 and/or by a parent class of the class represented byclass instance 120. -
FIG. 1 shows thatentry 1 ofvtable 132 refers to virtual method VM2.Runtime method 142 includes computer-executable instructions generated by compiling, interpreting, and/or otherwise translating the source code of the software for virtual method VM2. Then, asentry 1 refers to interface method VM2,entry 1 ofvtable 132 includes a reference toruntime method 142. - In the example shown in
FIG. 1 ,entry 1 of interface method table 130 includes a value of a starting address SA2 ofruntime method 142. The contents of address SA2 as shown inFIG. 1 as “<EP2>”.FIG. 1 indicates that a “First Instruction” ofruntime method 142 is stored at address EP2, and so indicates that address SA2 stores an entry point value forruntime method 142. - As shown in
FIG. 4 ,runtime environment 102 can include class instance (CI) 120 for a class that has N>2 interface methods, and P>2 virtual methods. In other examples,class instance 120 can be associated with a class with fewer interface methods and/or virtual methods; i.e., N≦2 and/or P≦2. For example,class instance 120 can be associated a class that is unassociated with a software interface; i.e., N=0. In those examples, interfacemethod table pointer 124, interface method table 130, and/or runtime methods for interface methods may not be present inruntime environment 102. In still other examples,class instance 120 can be associated that a class that is not associated with virtual methods; i.e., P=0. In those examples,vptr 126,vtable 132, and/or runtime methods for virtual methods may not be present inruntime environment 102. -
FIG. 2 is a flowchart ofmethod 200, in accordance with an example embodiment.Method 200 can be carried out by a computing device, such ascomputing device 100 discussed above in the context ofFIG. 1 .Method 200 involves dispatching and calling a method of a class, where the method has a known method index. The called method can be either a virtual method of the class or an interface method of the class. -
Method 200 can begin atblock 210, where the computing device can load a class instance having an interface method table pointer and a virtual table pointer, such asclass instance 120. Atblock 220, the computing device can decide whether a virtual method is being called or an interface method is being called. If a virtual method is being called, the computing device can proceed to block 230; otherwise, an interface method is being called, and the computing device can proceed to block 240. - At
block 230, sincemethod 200 involves a call to a virtual method, the computing device can load a vtable from a vptr of the class instance. Then, at block 232, the computing device can use the method index of the called method to index into the vtable and find a vtable entry for the called method. Then, the computing device can use the found vtable entry to obtain a reference to a runtime method corresponding to the called method; e.g., the value of a starting address of the corresponding runtime method. Upon completing block 232, the computing device can proceed to block 250. - At
block 240, sincemethod 200 involves a call to an interface method, the computing device can load an interface method table (IMT) from an interface method table pointer of the class instance. Then, at block 242, the computing device can use the method index of the called method to index into the interface method table and find an interface method table entry for the called method. Then, the computing device can use the found interface method table entry to obtain a reference to a runtime method corresponding to the called method; e.g., the value of a starting address of the corresponding runtime method. - At
block 250, the computing device can obtain an entry point from the reference to the corresponding runtime method. For example, the starting address of the runtime method can store entry point data, such as a value of an entry point or a value of an entry point offset, for the corresponding runtime method. Then, the computing device can use the entry point data to obtain the entry point. Atblock 260, the computing device can execute instructions of the corresponding runtime method starting at the entry point, thus calling the called method. -
FIG. 3 showscomputing device 100 storingsource code 310 and providing corresponding runtime environment (RE) 302, in accordance with an example embodiment.Source code 310 is related to the source code shown in Table 1 above. In particular,source code 310 shows an outline of class “Ex2” that implements a software interface “Intf2”. Interface “Intf2” specifies two interface methods: IM1 and IM2. Class “Ex2” implements interface “Intf2” and includes an outline of software for interface methods IM1 and IM2, as well as three virtual methods: VM1, VM2, and VM3. In the context of Table 1, interface “Intf2” and class “Ex2” are an example of the outlined source code with a number of interface methods N=2 and a number of virtual methods P=3. Other classes can be supported byruntime environment 302 as well. - In a managed runtime system, such as used by computing device 300 to provide
runtime environment 302, an implementation of a receiver instance can have a two word header for each object, with one word for a reference to a class object or instance, and one word for a synchronization/hash code to for checking validity of the class object/instance.FIG. 3 showsreceiver instance 306 named “Inst1” insource code 310 that is stored by computing device 300 starting at memory address 0xa000 with a header including apointer 308 toclass instance 120 a and a synchronization/hash code 310. -
Runtime environment 302 is related toruntime environment 102 shown inFIG. 1 . In particular,class instance 120 a has the same fields asclass instance 120 inruntime environment 102. As shown inFIG. 3 ,class instance 120 a includesdata 122 a, interfacemethod table pointer 124 a, andvirtual table pointer 126 a fields, which correspond torespective data 122, interfacemethod table pointer 124, andvirtual table pointer 126 fields ofclass instance 120. -
FIG. 3 shows thatruntime environment 302 also includes five runtime methods summarized in Table 2 below: -
TABLE 2 Corresponds to/ Has computer-executable Starting Entry Runtime Method instructions for Address Point Runtime Method 332 Interface method IM1 0xb208 0xb238 Runtime Method 334 Interface method IM2 0xb340 0xb378 Runtime Method 342 Virtual method VM1 0xc088 0xc0c0 Runtime Method 344 Virtual method VM2 0xc240 0xc070 Runtime Method 346 Virtual method VM3 0xc4a0 0xc4f0 - Interface
method table pointer 124 a points to interface method table 330, which is stored starting at address 0xb000. Interface method table 330 has two entries: interfacemethod table entry 0 for interface method IM1 that includes address 0xb208, which Table 2 indicates is a starting address forruntime method 332 corresponding to interface method IM1, and interfacemethod table entry 1 for interface method IM2 that includes starting address 0xb340 forruntime method 334 corresponding to interface method IM2. -
VPtr 126 a points to vtable 340, which is stored starting at address 0xc000.Vtable 340 has three entries:vtable entry 0 for virtual method VM1 that includes starting address 0xc088 forruntime method 342 corresponding to virtual method VM1,vtable entry 1 for virtual method VM2 that includes starting address 0xc240 forruntime method 344 corresponding to virtual method VM2, andvtable entry 2 for virtual method VM3 that includes starting address 0xc4a0 forruntime method 346 corresponding to virtual method VM3. -
FIG. 3 includes black arrows leading fromrespective entries runtime method 332 and 0xb340 ofruntime method 334 to illustrate relationships between entries of interface method table 330 andruntime methods FIG. 3 also includes black arrows leading fromrespective entries vtable 340 to the respective starting addresses 0xc088 ofruntime method 342, 0xc240 ofruntime method 344, and 0xc4a0 ofruntime method 346 to illustrate relationships between entries ofvtable 340 andruntime methods - Table 3A illustrates how
computing device 100 can applymethod 200 toruntime environment 302 to call interface methods IM1 and IM2. -
TABLE 3A Method 200 Block IM1 Call IM2 Call Block 210 (Load Load class instance 120a at 0xa800The procedures for blocks 210,class instance) using class Ex2 Pointer 308 of220, and 240 of method 200 can bereceiver instance 306.used for a call to interface method Block 220 This is an interface method call, so IM2 in the same way as described (Virtual/Interface proceed to block 240. for the call to interface method Method Test) IM1. Block 240 (Load Load interface method table 330 at interface method 0xb000 using interface method table) table pointer 124a ofclass instance 120a. Block 242 (Obtain The method index for IM1 is 0. The method index for IM1 is 1. runtime method Index into interface method table Index into interface method table reference) 330 to find entry 0.Reference 330 to find entry 1. Reference (SA)(starting address (SA)) stored in stored in entry 1 is 0xb340.entry 0 is 0xb208.Block 250 (Obtain Load contents of reference 0xb208. Load contents of reference 0xb340. entry point) If the reference stores entry point If the reference stores EP, contents (EP) as EP data, contents of of 0xb340 = EP 0xb378. 0xb208 = EP 0xb238. If the reference stores EPO, If the reference stores an EP offset contents of 0xb340 = EPO 0x38. (EPO) as EP data, contents of Then, EP = SA + EPO = 0xb340 + 0xb208 = EPO 0x30. Then, EP = 0x38 = 0xb378. SA + EPO = 0xb208 + 0x30 = 0xb238. Block 260 (Execute Execute instructions starting at EP Execute instructions starting at EP instructions) 0xb238. 0xb378. - Table 3B illustrates how
computing device 100 can applymethod 200 toruntime environment 302 to call virtual methods VM1, VM2, and VM3. -
TABLE 3B Method 200 Block VM1 Call VM2 Call VM3 Call Block 210 (Load Load class instance The procedures for blocks class instance) 120a at 0xa800 using method 200 can be used for calls to virtualclass Ex2 Pointer 308methods VM2 and VM3 in the same way as of receiver instance described for the call to virtual method VM1. 306. Block 220This is an virtual (Virtual/Interface method call, so Method Test) proceed to block 230 Block 230 ( Load Load vtable 340 at vtable) 0xc000 using VPtr 126a of class instance 120a. Block 232 (Obtain The method index for The method index for The method index for runtime method VM1 is 0. Index into VM2 is 1. Index into VM3 is 2. Index into reference) vtable 340 to find vtable 340 to findvtable 340 to findentry 0.Reference entry 1. Reference entry 2. Reference (SA) stored in entry 0 (SA) stored in entry 1 (SA) stored in entry 2is 0xc088. is 0xc240. is 0xc4a0. Block 250 (Obtain Load contents of Load contents of Load contents of entry point) reference 0xc088. reference 0xc240. reference 0xc4a0. If the reference stores If the reference stores If the reference stores EP, contents of 0xc088 = EP, contents of 0xc240 = EP, contents of EP 0xc0c0. EP 0xc270. 0xc4a0 = EP 0xc4f0. If the reference stores If the reference stores If the reference stores EPO, contents of EPO, contents of EPO, contents of 0xc088 = EPO 0x38. 0xc240 = EPO 0x30. 0xc4a0 = EPO 0x50. Then, EP = SA + EPO = Then, EP = SA + EPO = Then, EP = SA + EPO = 0xc088 + 0x38 = 0xc240 + 0x30 = 0xc4a0 + 0x50 = 0xc0c0. 0xc270. 0xc4f0. Block 260 (Execute Execute instructions Execute instructions Execute instructions instructions) starting at EP 0xc0c0. starting at EP 0xc270. starting at EP 0xc4f0. -
FIG. 4 shows a diagram ofruntime environment 402, in accordance with an example embodiment.Runtime environment 402 can be provided bycomputing device 400 to support a class that implements a software interface, such as example class “Ex1” implementing interface “Intf1” indicated using the source code that is outlined above in Table 1 and as discussed above in the context ofFIGS. 1-3 . -
Class instance 420 includesdata 422, interface method table 424 andvtable 426.Data 422 can include storage for class variables and other data.Class instance 420 ofruntime environment 402 embeds interface method table 424 andvtable 426.Class instances class instance 120,class instance 420 has replaced interfacemethod table pointer 124 and interface method table 130 with interface method table 424, and replacedvirtual table pointer 126 andvtable 132 withvtable 426. - Embedding interface method tables and vtables into class instances, such as
class instance 420, can speed method dispatch/calls by eliminating loading an interface method table (or virtual method table/vtable) from an interface method table pointer (or virtual table pointer/VPtr) for each interface method (or virtual method) dispatch. Then, a runtime method can be loaded from a class instance as a result. Interface method tables can have a predetermined or fixed size and can be laid out before variable-length vtables. - Given a method index, one constant offset O1 from a starting address of
class instance 420 can be used to look up a runtime method while dispatching/calling interface methods and another constant offset O2 can be used to look up the runtime method for dispatching/calling virtual methods. For example, suppose offset O1 to interface method table 424 from the start ofclass instance 420 is determined, and a size of interface method table 424 ST1 is determined. Then, offset O2 to the start ofvtable 426 can be determined as O2=O1+ST1. Then, given a starting address SAci ofclass instance 420, then the starting address SAit of interface method table 424 is: SAit=SAci+O1, and the starting address SAvt ofvtable 426 is: SAvt=SAci+O1+O2=SAit+O2. - Since
vtable 426 is embedded intoclass instance 420 andvtable 426 can be variably sized from class to class (e.g., sub-classes can add virtual methods to those defined by a parent class, and so increase the size of vtable 426), a size ofclass instance 420 is unknown until a size ofvtable 426 is determined. For example, the size ofvtable 426 may be determined at a class linking phase of generating an application. However, storage forclass instance 420 may be allocated during application generation before the class linking phase. In these scenarios, a placeholder forclass instance 420 can be allocated and used until the vtable size is determined. Once the vtable size is determined, the placeholder can be cloned into an actual copy ofclass instance 420 havingvtable 426 of the determined size. - In the example shown in
FIG. 4 ,runtime environment 402 provided bycomputing device 400 supports a class having the same source code as the class supported byruntime environment 102 provided bycomputing device 100 ofFIG. 1 . In this example,runtime methods FIG. 4 can have the same starting addresses, entry points, and instruction asrespective runtime methods FIG. 1 . As such, interface method table 130 ofFIG. 1 and interface method table 424 can represent the same interface methods and the data in interfacemethod table entries method table entries vtable 132 ofFIG. 1 andvtable 426 can represent the same virtual methods and the data invtable entries vtable 426 can be the same as the data in therespective vtable entries vtable 132. - As shown in
FIG. 4 ,runtime environment 402 can includeclass instance 420 for a class that has N>2 interface methods, and P>2 virtual methods. In other examples,class instance 420 can be associated with a class with fewer interface methods and/or virtual methods; i.e., N≦2 and/or P≦2. For example,class instance 420 can be associated a class that is unassociated with a software interface; i.e., N=0. In those examples, interface method table 424 and/or runtime methods for interface methods may not be present inruntime environment 402. In still other examples,class instance 420 can be associated that a class that is not associated with virtual methods; i.e., P=0. In those examples,vtable 426 and/or runtime methods for virtual methods may not be present inruntime environment 402. -
FIG. 5 is a flowchart ofmethod 500, in accordance with an example embodiment.Method 500 can be carried out by a computing device, such ascomputing device 400 discussed above in the context ofFIG. 4 .Method 500 involves dispatching and calling a method of a class, where the method has a known method index. The called method can be either a virtual method of the class or an interface method of the class. -
Method 500 can begin atblock 510, where the computing device can load a class instance embedding an interface method table and a vtable, such asclass instance 420. Atblock 520, the computing device can decide whether a virtual method is being called or an interface method is being called. If a virtual method is being called, the computing device can proceed to block 530; otherwise, an interface method is being called, and the computing device can proceed to block 540. - At block 530, since
method 500 involves a call to a virtual method, the computing device can use the method index of the called method to index into the vtable of the class instance and find a vtable entry for the called method. Then, the computing device can use the found vtable entry to obtain a reference to a runtime method corresponding to the called method; e.g., the value of starting address of the corresponding runtime method. Upon completing block 530, the computing device can proceed to block 550. - At block 540, since
method 500 involves a call to an interface method, the computing device can use the method index of the called method to index into the interface method table of the class instance and find an interface method table entry for the called method. Then, the computing device can use the found interface method table entry to obtain a reference to a runtime method corresponding to the called method; e.g., the value of a starting address of the corresponding runtime method. - At
block 550, the computing device can obtain an entry point from the reference to the corresponding runtime method. For example, the starting address of the runtime method can store entry point data, such as a value of an entry point or a value of an entry point offset, for the corresponding runtime method. Then, the computing device can use the entry point data to obtain the entry point. Atblock 560, the computing device can execute instructions of the corresponding runtime method starting at the entry point, thus calling the called method. - In comparing
methods method 500 simplifiesmethod 200 by eliminating blocks related to the retrieval of interface method tables and vtables from respective interface method table pointers and virtual table pointers, as these tables are embedded into the class instances. That is, by using embedded tables,method 500 does not utilize functionality related to blocks 232 and 242 ofmethod 200. -
FIG. 6 showscomputing device 400 storingsource code 310 and providingcorresponding runtime environment 602, in accordance with an example embodiment.Source code 310 is discussed above in the context ofFIG. 3 . Other classes can be supported byruntime environment 302 as well. -
FIG. 6 showsreceiver instance 606 named “Inst1” insource code 310 that is stored by computing device 600 starting at memory address 0xa000 with a header including apointer 608 toclass instance 420 a and a synchronization/hash code 610. -
Runtime environment 602 is related toruntime environment 402 shown inFIG. 4 . In particular,class instance 420 a has the same fields asclass instance 420 inruntime environment 402. As shown inFIG. 6 ,class instance 420 a includesdata 422 a, interface method table 424 a, and virtual table 426 a fields, which correspond torespective data 422, interface method table 424, and virtual table 426 fields ofclass instance 420. -
FIG. 6 shows thatruntime environment 602 also includes five runtime methods summarized in Table 4 below. Table 4 has the same information as Table 2, Table 6 is related to Table above—Table 4 has the same information as Table 2, save that the numbers of the runtime methods differ between the respective first columns of Tables 2 and 4. -
TABLE 4 Corresponds to/ Has computer-executable Starting Entry Runtime Method instructions for Address Point Runtime Method 632 Interface method IM1 0xb208 0xb238 Runtime Method 634 Interface method IM2 0xb340 0xb378 Runtime Method 642 Virtual method VM1 0xc088 0xc0c0 Runtime Method 644 Virtual method VM2 0xc240 0xc070 Runtime Method 646 Virtual method VM3 0xc4a0 0xc4f0 - Interface method table 424 a has two entries having the same data as interface method table 330, and
vtable 426 a has three entries storing the same data as corresponding entries ofvtable 340, and all of these entries are discussed above in more detail in the context ofFIG. 3 .FIG. 6 includes black arrows leading fromrespective entries runtime method 632 and 0xb340 ofruntime method 634 to illustrate relationships between entries of interface method table 424 a andruntime methods FIG. 6 also includes black arrows leading fromrespective entries vtable 426 a to the respective starting addresses 0xc088 ofruntime method 642, 0xc240 ofruntime method 644, and 0xc4a0 ofruntime method 646 to illustrate relationships between entries ofvtable 426 a andruntime methods - Table 5A illustrates how
computing device 400 can applymethod 500 toruntime environment 602 to call interface methods IM1 and IM2. -
TABLE 5A Method 500 Block IM1 Call IM2 Call Block 510 (Load Load class instance 420a at 0xa800The procedures for blocks 510 andclass instance) using class Ex2 pointer 608 of520 of method 500 can be used forreceiver instance 606.a call to interface method IM2 in Block 520This is an interface method call, so the same way as described for the (Virtual/Interface proceed to block 540. call to interface method IM1. Method Test) Block 540 (Obtain The method index for IM1 is 0. The method index for IM1 is 1. runtime method Index into interface method table Index into interface method table reference) 424a of class instance 420a to find424a of class instance 420a to findentry 0. Reference (startingaddress entry 1. Reference (SA) stored in (SA)) stored in entry 0 is 0xb208.entry 1 is 0xb340.Block 550 (Obtain Load contents of reference 0xb208. Load contents of reference 0xb340. entry point) If the reference stores entry point If the reference stores EP, contents (EP) as EP data, contents of of 0xb340 = EP 0xb378. 0xb208 = EP 0xb238. If the reference stores EPO, If the reference stores an EP offset contents of 0xb340 = EPO 0x38. (EPO) as EP data, contents of Then, EP = SA + EPO = 0xb340 + 0xb208 = EPO 0x30. Then, EP = 0x38 = 0xb378. SA + EPO = 0xb208 + 0x30 = 0xb238. Block 560 (Execute Execute instructions starting at EP Execute instructions starting at EP instructions) 0xb238. 0xb378. - Table 5B illustrates how
computing device 400 can applymethod 500 toruntime environment 602 to call virtual methods VM1, VM2, and VM3. -
TABLE 5B Method 500 Block VM1 Call VM2 Call VM3 Call Block 510 (Load Load class instance The procedures for blocks class instance) 420a at 0xa800 using method 500 can be used for calls to virtualclass Ex2 pointer 608methods VM2 and VM3 in the same way as of receiver instance described for the call to virtual method VM1. 606. Block 520This is a virtual (Virtual/Interface method call, so Method Test) proceed to block 530. Block 530 (Obtain The method index for The method index for The method index for runtime method VM1 is 0. Index into VM2 is 1. Index into VM3 is 2. Index into reference) vtable 426a of class vtable 426a of class vtable 426a of class instance 420a to find instance 420a to findinstance 420a to findentry 0.Reference entry 1. Reference entry 2. Reference (SA) stored in entry 0 (SA) stored in entry 1 (SA) stored in entry 2is 0xc088. is 0xc240. is 0xc4a0. Block 550 (Obtain Load contents of Load contents of Load contents of entry point) reference 0xc088. reference 0xc240. reference 0xc4a0. If the reference stores If the reference stores If the reference stores EP, contents of 0xc088 = EP, contents of 0xc240 = EP, contents of EP 0xc0c0. EP 0xc270. 0xc4a0 = EP 0xc4f0. If the reference stores If the reference stores If the reference stores EPO, contents of EPO, contents of EPO, contents of 0xc088 = EPO 0x38. 0xc240 = EPO 0x30. 0xc4a0 = EPO 0x50. Then, EP = SA + EPO = Then, EP = SA + EPO = Then, EP = SA + EPO = 0xc088 + 0x38 = 0xc240 + 0x30 = 0xc4a0 + 0x50 = 0xc0c0. 0xc270. 0xc4f0. Block 560 (Execute Execute instructions Execute instructions Execute instructions instructions) starting at EP 0xc0c0. starting at EP 0xc270. starting at EP 0xc4f0. -
FIG. 7 shows a diagram ofruntime environment 702, in accordance with an example embodiment.Runtime environment 702 can be provided bycomputing device 700 to support a class that implements a software interface, such as example class “Ex1” implementing interface “Intf1” indicated using the source code that is outlined above in Table 1 and as discussed above in the context ofFIGS. 1-6 . -
Class instance 720 includesdata 722, interface method table 724 andvtable 726.Data 722 can include storage for class variables and other data. As withclass instance 420,class instance 720 ofruntime environment 402 embeds an interface method table and a vtable—these tables are shown inFIG. 7 as interface method table 724 andvtable 726. As such, the differences betweenclass instances class instances FIG. 4 . - In comparison with
class instance 420, entries of interface method table 724 andvtable 726 ofclass instance 720 include entry point data not present in entries of interface method table 424 andvtable 426 ofclass instance 420. For example,FIG. 7 shows thatentry 1 of interface method table 724 relates to interface method IM2 and stores a reference of starting address SA1 forruntime method 740 and an entry point value of EP1 for an entry point ofruntime method 740, whereruntime method 740 corresponds to interface method IM2 as discussed above in the context of at leastFIG. 1 .FIG. 7 also shows thatentry 1 ofvtable 726 relates to virtual method VM2 and stores a reference of starting address SA2 forruntime method 742 and an entry point value of EP2 for an entry point ofruntime method 742, whereruntime method 742 corresponds to virtual method VM2 as discussed above in the context of at leastFIG. 1 . - Also, entries of interface method table 724 and
vtable 726 ofclass instance 720 store additional entry point data and so utilize more space than corresponding entries of interface method table 424 andvtable 426 ofclass instance 420. However, dispatching and calling a virtual/interface method can be simplified by loading entry points directly, thereby likely increasing performance of method dispatches/calls. - In some embodiments, entries in interface method table 724 and
vtable 726 can store entry point values as entry point data. In other embodiments, such as embodiments where starting addresses of runtime methods store entry point offsets, entries in interface method table 724 and/orvtable 726 can have table entries storing entry point values or entry point offset values as entry point data; e.g., as entry point EPx of runtime method RMx is stored an offset OFFx from starting address STARTx of runtime method RMx, then interface method table 724 and/orvtable 726 can either store offset OFFx as entry point data or computed entry point EPx as an entry point data, where EPx=STARTx+OFFx. - In the example shown in
FIG. 7 ,runtime environment 702 provided bycomputing device 700 supports a class having the same source code as the class supported byrespective runtime environments respective computing devices runtime methods FIG. 7 can have the same starting addresses, entry points, and instruction asrespective runtime methods FIG. 1 andrespective runtime methods FIG. 4 . As such, interface method table 130 ofFIG. 1 , interface method table 424 ofFIG. 4 , and interface method table 724 can represent the same interface methods and the reference data in interfacemethod table entries method table entries method table entries vtable 132 ofFIG. 1 ,vtable 426 ofFIG. 4 , andvtable 726 ofFIG. 7 can represent the same virtual methods and the reference data invtable entries vtable 726 can be the same as the reference data in the respective interfacemethod table entries vtable 132 and the reference data in the respective interfacemethod table entries vtable 426; however, the entry point data ofvtable 726 is not present in eithervtable 132 orvtable 426. - As shown in
FIG. 7 ,runtime environment 702 can includeclass instance 720 for a class that has N>2 interface methods, and P>2 virtual methods. In other examples,class instance 720 can be associated with a class with fewer interface methods and/or virtual methods; i.e., N≦2 and/or P≦2. For example,class instance 720 can be associated a class that is unassociated with a software interface; i.e., N=0. In those examples, interface method table 724 and/or runtime methods for interface methods may not be present inruntime environment 702. In still other examples,class instance 720 can be associated that a class that is not associated with virtual methods; i.e., P=0. In those examples,vtable 726 and/or runtime methods for virtual methods may not be present inruntime environment 702. -
FIG. 8 is a flowchart ofmethod 800, in accordance with an example embodiment.Method 800 can be carried out by a computing device, such ascomputing device 400 discussed above in the context ofFIG. 4 .Method 800 involves dispatching and calling a method of a class, where the method has a known method index. The called method can be either a virtual method of the class or an interface method of the class. -
Method 800 can begin atblock 810, where the computing device can load a class instance embedding an interface method table and a vtable with each table having entries that store entry point references, such asclass instance 720. Atblock 820, the computing device can decide whether a virtual method is being called or an interface method is being called. If a virtual method is being called, the computing device can proceed to block 830; otherwise, an interface method is being called, and the computing device can proceed to block 840. - At block 830, since
method 800 involves a call to a virtual method, the computing device can use the method index of the called method to index into the vtable of the class instance and find a vtable entry for the called method. Then, the computing device can use the found vtable entry to obtain an entry point to a runtime method corresponding to the called method. Upon completing block 830, the computing device can proceed to block 850. - At block 840, since
method 700 involves a call to an interface method, the computing device can use the method index of the called method to index into the interface method table of the class instance and find an interface method table entry for the called method. Then, the computing device can use the found interface method table entry to obtain an entry point to a runtime method corresponding to the called method. - At
block 850, the computing device can execute instructions of the corresponding runtime method starting at the entry point, thus calling the called method. - In comparing
methods method 800 simplifiesmethods method 200 and eliminating blocks related to determining entry points from entry point data stored in runtime functions frommethods method 800 does not utilize functionality related toblocks 232, 242, and 250 ofmethod 200 or utilize functionality related to block 550 ofmethod 500. -
FIG. 9 showscomputing device 400 storingsource code 310 and providing corresponding runtime environment 802, in accordance with an example embodiment.Source code 310 is discussed above in the context of at leastFIG. 3 . Other classes can be supported byruntime environment 902 as well.FIG. 9 showsreceiver instance 906 named “Inst1” insource code 310 that is stored by computing device 900 starting at memory address 0xa000 with a header including a pointer 908 toclass instance 420 a and a synchronization/hash code 910. -
Runtime environment 602 is related toruntime environment 702 shown inFIG. 7 . In particular,class instance 720 a has the same fields asclass instance 720 inruntime environment 702. As shown inFIG. 9 ,class instance 720 a includes data 722 a, interface method table 724 a, and virtual table 726 a fields, which correspond torespective data 722, interface method table 724, and virtual table 726 fields ofclass instance 720. -
FIG. 9 shows thatruntime environment 702 also includes five runtime methods summarized in Table 6 below. Table 6 is related to Tables 2 and 4 above—Table 6 has the same information as Tables 2 and 4, save that the numbers of the runtime methods differ between the respective first columns of Tables 2, 4, and 6. -
TABLE 6 Corresponds to/ Has computer-executable Starting Entry Runtime Method instructions for Address Point Runtime Method 932 Interface method IM1 0xb208 0xb238 Runtime Method 934 Interface method IM2 0xb340 0xb378 Runtime Method 942 Virtual method VM1 0xc088 0xc0c0 Runtime Method 944 Virtual method VM2 0xc240 0xc070 Runtime Method 946 Virtual method VM3 0xc4a0 0xc4f0 - Interface method table 724 a has two entries, each storing the same runtime reference data as interface method tables 330 and 424 a, and additionally each entry of vtable 726 a stores an entry point value for a corresponding runtime function. For example,
FIG. 9 shows thatentry 0 of interface method table 724 a stores both a starting address of 0xb208 and an entry point of 0xb238 for correspondingruntime method 932—the starting address 0xb208 is stored inentry 0 of interface method table 330 and inentry 0 of interface method table 424 a, but the entry point 0xb238 is not stored in either interface method table 330 or interface method table 424 a. -
FIG. 9 includes black arrows leading fromrespective entries runtime method 932 and 0xb340 ofruntime method 934, and grey arrows leading fromrespective entries runtime method 932 and 0xb370 ofruntime method 932, to illustrate relationships between entries of interface method table 724 a andruntime methods - Vtable 726 a has three entries, each storing the same runtime reference data as
vtables FIG. 9 shows thatentry 0 of vtable 726 a stores both a starting address of 0xc088 and an entry point of 0xc0c0 for correspondingruntime method 942—the starting address 0xc088 is stored inentry 0 ofvtable 340 and inentry 0 ofvtable 426 a, but the entry point 0xc0c0 is not stored in eithervtable 340 orvtable 426 a. -
FIG. 9 includes black arrows leading fromrespective entries runtime method 942, 0xc240 ofruntime method 944, and 0xc4a0 ofruntime method 946, and grey arrows leading fromrespective entries runtime method 942, 0xc270 ofruntime method 944, and 0xc4f0 ofruntime method 946 to illustrate relationships between entries of vtable 726 a andruntime methods - Table 7A illustrates how
computing device 700 can applymethod 800 toruntime environment 902 to call interface methods IM1 and IM2. -
TABLE 7A Method 800 Block IM1 Call IM2 Call Block 810 (Load Load class instance 720a at 0xa800The procedures for blocks 810 andclass instance) using class Ex2 pointer 908 of 820 of method 800 can be used forreceiver instance 606.a call to interface method IM2 in Block 820This is an interface method call, so the same way as described for the (Virtual/Interface proceed to block 840. call to interface method IM1. Method Test) Block 540 (Obtain The method index for IM1 is 0. The method index for IM1 is 1. entry point) Index into interface method table Index into interface method table 724a of class instance 720a to find724a of class instance 720a to findentry 0. Entry point reference (EP)entry 1. Entry point reference (EP)stored in entry 0 is 0xb238.stored in entry 1 is 0xb378.Block 560 (Execute Execute instructions starting at EP Execute instructions starting at EP instructions) 0xb238. 0xb378. - Table 7B illustrates how
computing device 700 can applymethod 800 toruntime environment 902 to call virtual methods VM1, VM2, and VM3. -
TABLE 7B Method 800 Block VM1 Call VM2 Call VM3 Call Block 810 (Load Load class instance The procedures for blocks class instance) 420a at 0xa800 using method 800 can be used for calls to virtualclass Ex2 pointer 608methods VM2 and VM3 in the same way as of receiver instance described for the call to virtual method VM1. 606. Block 820This is a virtual (Virtual/Interface method call, so Method Test) proceed to block 830. Block 830 (Obtain The method index for The method index for The method index for entry point) VM1 is 0. Index into VM2 is 1. Index into VM3 is 2. Index into vtable 726a of class vtable 726a of class vtable 726a of class instance 720a to find instance 720a to findinstance 720a to findentry 0.Entry point entry 1. EP stored in entry 2. EP stored inreference (EP) stored entry 0 is 0xc270.entry 0 is 0xc4f0.in entry 0 is 0xc0c0.Block 850 (Execute Execute instructions Execute instructions Execute instructions instructions) starting at EP 0xc0c0. starting at EP 0xc270. starting at EP 0xc4f0. - Example Data Network
-
FIG. 10 depicts a distributedcomputing architecture 1000 withserver devices network 1006, withprogrammable devices Network 1006 may correspond to a LAN, a wide area network (WAN), a corporate intranet, the public Internet, or any other type of network configured to provide a communications path between networked computing devices. Thenetwork 1006 may also correspond to a combination of one or more LANs, WANs, corporate intranets, and/or the public Internet. - Although
FIG. 10 only shows three programmable devices, distributed application architectures may serve tens, hundreds, or thousands of programmable devices. Moreover,programmable devices programmable devices network 1006. In other embodiments, such as indicated withprogrammable devices network 1006 via an associated computing device, such asprogrammable device 1004 c. In this example,programmable device 1004 c can act as an associated computing device to pass electronic communications betweenprogrammable devices network 1006. In still other embodiments not shown inFIG. 10 , a programmable device can be both directly and indirectly connected tonetwork 1006. -
Server devices server device 1008 and/or 1010 can provide content to programmable devices 1004 a-1004 e. The content can include, but is not limited to, web pages, hypertext, scripts, binary data such as compiled software, images, audio, and/or video. The content can include compressed and/or uncompressed content. The content can be encrypted and/or unencrypted. Other types of content are possible as well. - As another example,
server device 1008 and/or 1010 can provide programmable devices 1004 a-1004 e with access to software for database, search, computation, graphical, audio, video, World Wide Web/Internet utilization, and/or other functions. Many other examples of server devices are possible as well. - Computing Device Architecture
-
FIG. 11A is a block diagram of a computing device 1100 (e.g., system) in accordance with an example embodiment. In particular,computing device 1100 shown inFIG. 11A can be configured to perform one or more functions related tocomputing devices runtime environments methods source code 310,network 1006,server devices programmable devices Computing device 1100 may include a user interface module 1101, a network-communication interface module 1102, one ormore processors 1103, anddata storage 1104, all of which may be linked together via a system bus, network, orother connection mechanism 1105. - User interface module 1101 can be operable to send data to and/or receive data from exterior user input/output devices. For example, user interface module 1101 can be configured to send and/or receive data to and/or from user input devices such as a keyboard, a keypad, a touch screen, a computer mouse, a track ball, a joystick, a camera, a voice recognition module, and/or other similar devices. User interface module 1101 can also be configured to provide output to user display devices, such as one or more cathode ray tubes (CRT), liquid crystal displays (LCD), light emitting diodes (LEDs), displays using digital light processing (DLP) technology, printers, light bulbs, and/or other similar devices, either now known or later developed. User interface module 1101 can also be configured to generate audible output(s), such as a speaker, speaker jack, audio output port, audio output device, earphones, and/or other similar devices.
- Network-
communications interface module 1102 can include one ormore wireless interfaces 1107 and/or one ormore wireline interfaces 1108 that are configurable to communicate via a network, such asnetwork 1006 shown inFIG. 10 .Wireless interfaces 1107 can include one or more wireless transmitters, receivers, and/or transceivers, such as a Bluetooth transceiver, a Zigbee transceiver, a Wi-Fi transceiver, a WiMAX transceiver, and/or other similar type of wireless transceiver configurable to communicate via a wireless network.Wireline interfaces 1108 can include one or more wireline transmitters, receivers, and/or transceivers, such as an Ethernet transceiver, a Universal Serial Bus (USB) transceiver, or similar transceiver configurable to communicate via a twisted pair wire, a coaxial cable, a fiber-optic link, or a similar physical connection to a wireline network. - In some embodiments, network
communications interface module 1102 can be configured to provide reliable, secured, and/or authenticated communications. For each communication described herein, information for ensuring reliable communications (i.e., guaranteed message delivery) can be provided, perhaps as part of a message header and/or footer (e.g., packet/message sequencing information, encapsulation header(s) and/or footer(s), size/time information, and transmission verification information such as CRC and/or parity check values). Communications can be made secure (e.g., be encoded or encrypted) and/or decrypted/decoded using one or more cryptographic protocols and/or algorithms, such as, but not limited to, DES, AES, RSA, Diffie-Hellman, and/or DSA. Other cryptographic protocols and/or algorithms can be used as well or in addition to those listed herein to secure (and then decrypt/decode) communications. -
Processors 1103 can include one or more general purpose processors and/or one or more special purpose processors (e.g., digital signal processors, graphics processing units, application specific integrated circuits, etc.).Processors 1103 can be configured to execute computer-readable program instructions 1106 that are contained in thedata storage 1104 and/or other instructions as described herein. -
Data storage 1104 can include one or more computer-readable storage media that can be read and/or accessed by at least one ofprocessors 1103. The one or more computer-readable storage media can include volatile and/or non-volatile storage components, such as optical, magnetic, organic or other memory or disc storage, which can be integrated in whole or in part with at least one ofprocessors 1103. In some embodiments,data storage 1104 can be implemented using a single physical device (e.g., one optical, magnetic, organic or other memory or disc storage unit), while in other embodiments,data storage 1104 can be implemented using two or more physical devices. -
Data storage 1104 can include computer-readable program instructions 1106 and perhaps additional data. In some embodiments,data storage 1104 can additionally include storage required to perform at least part of the methods and techniques and/or at least part of the functionality of the devices and networks. - In some embodiments,
computing device 1100 can include one or more sensors. The sensor(s) can be configured to measure conditions in an environment forcomputing device 1100 and provide data about that environment. The data can include, but is not limited to, location data aboutcomputing device 1100, velocity (speed, direction) data aboutcomputing device 1100, acceleration data about computing device, and other data about the environment forcomputing device 1100. The sensor(s) can include, but are not limited to, GPS sensor(s), location sensors(s), gyroscope(s), accelerometer(s), magnetometer(s), camera(s), light sensor(s), infrared sensor(s), and microphone(s). Other examples of sensors are possible as well. - Cloud-Based Servers
-
FIG. 11B depictsnetwork 1006 ofcomputing clusters Server devices 1008 and/or 1010 can be configured to perform some or all of the herein-described functions related tocomputing devices runtime environments methods source code 310. - Some or all of the modules/components of
server devices 1008 and/or 1010 can be cloud-based devices that store program logic and/or data of cloud-based applications and/or services. In some embodiments,server devices 1008 and/or 1010 can be on a single computing device residing in a single computing center. In other embodiments,server devices 1008 and/or 1010 can include multiple computing devices in a single computing center, or even multiple computing devices located in multiple computing centers located in diverse geographic locations. For example,FIG. 10 depicts each ofserver devices - In some embodiments, software and data associated with
server devices 1008 and/or 1010 can be encoded as computer readable information stored in non-transitory, tangible computer readable media (or computer readable storage media) and accessible by one or more of programmable devices 1004 a-1004 e and/or other computing devices. In some embodiments, data associated withserver devices 1008 and/or 1010 can be stored on a single disk drive or other tangible storage media, or can be implemented on multiple disk drives or other tangible storage media located at one or more diverse geographic locations. -
FIG. 11B depicts a cloud-based server system in accordance with an example embodiment. InFIG. 11B , the functions ofserver devices 1008 and/or 1010 can be distributed among threecomputing clusters Computing cluster 1109 a can include one ormore computing devices 1100 a, cluster storage arrays 1110 a, and cluster routers 1111 a connected by alocal cluster network 1112 a. Similarly,computing cluster 1109 b can include one ormore computing devices 1100 b, cluster storage arrays 1110 b, andcluster routers 1111 b connected by alocal cluster network 1112 b. Likewise,computing cluster 1109 c can include one ormore computing devices 1100 c, cluster storage arrays 1110 c, andcluster routers 1111 c connected by alocal cluster network 1112 c. - In some embodiments, each of the
computing clusters - In
computing cluster 1109 a, for example,computing devices 1100 a can be configured to perform various computing tasks ofserver devices 1008 and/or 1010. In one embodiment, the various functionalities ofserver devices 1008 and/or 1010 can be distributed among one or more ofcomputing devices Computing devices computing clusters computing devices 1100 a incomputing cluster 1109 a. On the other hand, in some embodiments,computing devices - In some embodiments, computing tasks and stored data associated with
server devices 1008 and/or 1010 be distributed acrosscomputing devices server devices 1008 and/or 1010, the storage and/or processing capabilities ofcomputing devices - The cluster storage arrays 1110 a, 1110 b, and 1110 c of the
computing clusters - Similar to the manner in which the functions of
server devices 1008 and/or 1010 can be distributed acrosscomputing devices computing clusters server devices 1008 and/or 1010, while other cluster storage arrays can store data of other modules/components ofserver devices 1008 and/or 1010. Additionally, some cluster storage arrays can be configured to store backup versions of data stored in other cluster storage arrays. - The
cluster routers computing clusters computing cluster 1109 a can include one or more internet switching and routing devices configured to provide (i) local area network communications between thecomputing devices 1100 a and the cluster storage arrays 1101 a via thelocal cluster network 1112 a, and (ii) wide area network communications between thecomputing cluster 1109 a and thecomputing clusters area network connection 1113 a tonetwork 1006.Cluster routers cluster routers computing clusters computing cluster 1109 a. - In some embodiments, the configuration of the
cluster routers cluster routers local networks area network links - Example Methods of Operation
-
FIG. 12 is a flowchart illustrating method 1200, in accordance with an embodiment.Method 1200 can be carried out by one or more computing devices, such as, but not limited to, one or more of: computingdevices network 1006,server devices computing cluster 1109 a,computing cluster 1109 b, andcomputing cluster 1109 c. -
Method 1200 can begin atblock 1210. Atblock 1210, a computing device can receive a request to call a software method of a class instance, such as discussed above in the context of at leastFIGS. 4-9 . - The class instance can include an interface method table and a virtual method table. The interface method table can include one or more interface method table entries and the virtual method table can include one or more virtual table entries. The one or more interface method table entries can include a particular interface method table entry for a particular interface method of a software interface associated with the class instance, where the particular interface method table entry can include a reference related to the particular interface method. The one or more virtual table entries can include a particular virtual table entry for a particular virtual method associated with the class instance, where the particular virtual table entry can include a reference related to the particular virtual method.
- At block 1220, the computing device can determine an entry point for the called software method based on at least one of the interface method table and the virtual method table, such as discussed above in the context of at least
FIGS. 4-9 . - In some embodiments, determining the entry point for the called software method based the at least one of the interface method table and the virtual method table can include the computing device, upon determining that the called software method is an interface method of the software interface: determining a called interface method table entry of the interface method table that is associated with the called software method and determining the entry point based on the called interface method table entry, such as discussed above in the context of at least
FIGS. 4-9 . - In particular of these embodiments, the called interface method table entry can include a runtime-method reference. Then, determining the entry point based on the called interface method table entry can include determining the entry point based on the runtime-method reference, such as discussed above in the context of at least
FIGS. 4-9 . In more particular of these embodiments, the called software method can be associated with a particular runtime method, the runtime-method reference can include a starting address of the particular runtime method, and the entry point can be based on a value stored in the starting address of the particular runtime method, such as discussed above in the context of at leastFIGS. 4-6 . - In other particular of these embodiments, the called interface method table entry can include an entry-point value. Then, determining the entry point based on the called interface method table entry includes determining the entry point based on the entry point value, such as discussed above in the context of at least
FIGS. 7-9 . In more particular of these embodiments, the called software method can be associated with a particular runtime method, and the entry point value can include an entry point for the particular runtime method, such as discussed above in the context of at leastFIGS. 7-9 . - In even other embodiments, determining the entry point for the called software method based the at least one of the interface method table and the virtual method table can include the computing device, upon determining whether the called software method is a virtual method associated with the class instance: determining a called vtable entry of the vtable that is associated with the called software method and can determine the entry point based on the called vtable entry, such as discussed above in the context of at least
FIGS. 4-9 . - In particular of the even other embodiments, the called vtable entry can include a runtime-method reference. Then, determining the entry point based on the called vtable entry includes determining the entry point based on the runtime-method reference, such as discussed above in the context of at least
FIGS. 4-9 . In more particular of the even other embodiments, the called software method can be associated with a particular runtime method, the runtime-method reference can include a starting address of the particular runtime method, and where the entry point can be based on a value stored in the starting address of the particular runtime method, such as discussed above in the context of at leastFIGS. 4-6 . - In other particular of the even other embodiments, the called vtable entry can include an entry-point value. Then, determining the entry point based on the called vtable entry can include determining the entry point based on the entry point value, such as discussed above in the context of at least
FIGS. 7-9 . In even more particular of the even other embodiments, the called software method can be associated with a particular runtime method, and the entry point value can include an entry point for the particular runtime method, such as discussed above in the context of at leastFIGS. 7-9 - At block 1230, the computing device can call the called software method by executing instructions at the entry point, such as discussed above in the context of at least
FIGS. 4-9 . - In some embodiments,
method 1200 can further include: determining a predetermined interface-table size for the interface method table; determining an estimated virtual-method-table size for the virtual method table; determining a first size for the class instance based on the predetermined interface-table size and the estimated virtual-method-table size; after determining the first size for the class instance, determining an actual virtual-method-table size; and determining a second size for the class instance based on the predetermined interface-table size and the actual virtual-method-table size. In particular of these embodiments, determining the estimated virtual-method-table size can be performed prior to linking the class instance, and determining the actual virtual-method-table size can be performed during or after linking the class instance. - In other embodiments,
method 1200 can further include: storing the class instance in a memory of the computing device starting at a base address, where the interface method table has a predetermined size and is configured to be stored at starting at a first predetermined offset address from the base address, where the virtual address table is configured to be stored starting at a second predetermined offset from the base address, and where the second predetermined offset is based on the first predetermined offset address and the predetermined size. - The above detailed description describes various features and functions of the disclosed systems, devices, and methods with reference to the accompanying figures. In the figures, similar symbols typically identify similar components, unless context dictates otherwise. The illustrative embodiments described in the detailed description, figures, and claims are not meant to be limiting. Other embodiments can be utilized, and other changes can be made, without departing from the spirit or scope of the subject matter presented herein. It will be readily understood that the aspects of the present disclosure, as generally described herein, and illustrated in the figures, can be arranged, substituted, combined, separated, and designed in a wide variety of different configurations, all of which are explicitly contemplated herein.
- With respect to any or all of the ladder diagrams, scenarios, and flow charts in the figures and as discussed herein, each block and/or communication may represent a processing of information and/or a transmission of information in accordance with example embodiments. Alternative embodiments are included within the scope of these example embodiments. In these alternative embodiments, for example, functions described as blocks, transmissions, communications, requests, responses, and/or messages may be executed out of order from that shown or discussed, including substantially concurrent or in reverse order, depending on the functionality involved. Further, more or fewer blocks and/or functions may be used with any of the ladder diagrams, scenarios, and flow charts discussed herein, and these ladder diagrams, scenarios, and flow charts may be combined with one another, in part or in whole.
- A block that represents a processing of information may correspond to circuitry that can be configured to perform the specific logical functions of a herein-described method or technique. Alternatively or additionally, a block that represents a processing of information may correspond to a module, a segment, or a portion of program code (including related data). The program code may include one or more instructions executable by a processor for implementing specific logical functions or actions in the method or technique. The program code and/or related data may be stored on any type of computer readable medium such as a storage device including a disk or hard drive or other storage medium.
- The computer readable medium may also include non-transitory computer readable media such as non-transitory computer-readable media that stores data for short periods of time like register memory, processor cache, and random access memory (RAM). The computer readable media may also include non-transitory computer readable media that stores program code and/or data for longer periods of time, such as secondary or persistent long term storage, like read only memory (ROM), optical or magnetic disks, compact-disc read only memory (CD-ROM), for example. The computer readable media may also be any other volatile or non-volatile storage systems. A computer readable medium may be considered a computer readable storage medium, for example, or a tangible storage device.
- Moreover, a block that represents one or more information transmissions may correspond to information transmissions between software and/or hardware modules in the same physical device. However, other information transmissions may be between software modules and/or hardware modules in different physical devices.
- While various aspects and embodiments have been disclosed herein, other aspects and embodiments will be apparent to those skilled in the art. The various aspects and embodiments disclosed herein are for purposes of illustration and are not intended to be limiting, with the true scope being indicated by the following claims.
Claims (20)
1. A method, comprising:
receiving a request to call a software method of a class instance at a computing device, wherein the class instance comprises an interface method table and a virtual method table, wherein the interface method table comprises one or more interface method table entries and the virtual method table comprises one or more virtual table entries, wherein the one or more interface method table entries comprise a particular interface method table entry for a particular interface method of a software interface associated with the class instance, the particular interface method table entry comprising a reference related to the particular interface method, wherein the one or more virtual table entries comprise a particular virtual table entry for a particular virtual method associated with the class instance, the particular virtual table entry comprising a reference related to the particular virtual method;
determining an entry point for the called software method based on at least one of the interface method table and the virtual method table using the computing device; and
calling the called software method by executing instructions at the entry point using the computing device.
2. The method of claim 1 , wherein determining the entry point for the called software method based the at least one of the interface method table and the virtual method table comprises:
upon determining that the called software method is an interface method of the software interface, the computing device:
determining a called interface method table entry of the interface method table that is associated with the called software method; and
determining the entry point based on the called interface method table entry.
3. The method of claim 2 , wherein the called interface method table entry comprises a runtime-method reference, and wherein determining the entry point based on the called interface method table entry comprises determining the entry point based on the runtime-method reference.
4. The method of claim 3 , wherein the called software method is associated with a particular runtime method, wherein the runtime-method reference comprises a starting address of the particular runtime method, and where the entry point is based on a value stored in the starting address of the particular runtime method.
5. The method of claim 2 , wherein the called interface method table entry comprises an entry-point value, and wherein determining the entry point based on the called interface method table entry comprises determining the entry point based on the entry point value.
6. The method of claim 5 , wherein the called software method is associated with a particular runtime method, and wherein the entry point value comprises an entry point for the particular runtime method.
7. The method of claim 1 , wherein determining the entry point for the called software method based the at least one of the interface method table and the virtual method table comprises:
upon determining that the called software method is a virtual method associated with the class instance, the computing device:
determining a called virtual method table entry of the virtual method table that is associated with the called software method; and
determining the entry point based on the called virtual method table entry.
8. The method of claim 7 , wherein the called virtual method table entry comprises a runtime-method reference, and wherein determining the entry point based on the called virtual method table entry comprises determining the entry point based on the runtime-method reference.
9. The method of claim 8 , wherein the called software method is associated with a particular runtime method, wherein the runtime-method reference comprises a starting address of the particular runtime method, and where the entry point is based on a value stored in the starting address of the particular runtime method.
10. The method of claim 7 , wherein the called virtual method table entry comprises an entry-point value, and wherein determining the entry point based on the called virtual method table entry comprises determining the entry point based on the entry point value.
11. The method of claim 10 , wherein the called software method is associated with a particular runtime method, and wherein the entry point value comprises an entry point for the particular runtime method.
12. The method of claim 1 , further comprising:
storing the class instance in a memory of the computing device starting at a base address, wherein the interface method table has a predetermined size and is configured to be stored at starting at a first predetermined offset address from the base address, wherein the virtual address table is configured to be stored starting at a second predetermined offset from the base address, and wherein the second predetermined offset is based on the first predetermined offset address and the predetermined size.
13. A computing device, comprising:
one or more processors; and
data storage having instructions stored thereon that, upon execution of the instructions by the one or more processors, cause the one or more processors to perform functions comprising:
receiving a request to call a software method of a class instance, wherein the class instance comprises an interface method table and a virtual method table, wherein the interface method table comprises one or more interface method table entries and the virtual method table comprises one or more virtual table entries, wherein the one or more interface method table entries comprise a particular interface method table entry for a particular interface method of a software interface associated with the class instance, the particular interface method table entry comprising a reference related to the particular interface method, wherein the one or more virtual table entries comprise a particular virtual table entry for a particular virtual method associated with the class instance, the particular virtual table entry comprising a reference related to the particular virtual method;
determining an entry point for the called software method based on at least one of the interface method table and the virtual method table using the computing device; and
calling the called software method by executing instructions at the entry point using the computing device.
14. The computing device of claim 13 , wherein determining the entry point for the called software method based the at least one of the interface method table and the virtual method table comprises:
upon determining that the called software method is an interface method of the software interface, the computing device:
determining a called interface method table entry of the interface method table that is associated with the called software method; and
determining the entry point based on the called interface method table entry.
15. The computing device of claim 14 , wherein the called interface method table entry comprises a runtime-method reference, and wherein determining the entry point based on the called interface method table entry comprises determining the entry point based on the runtime-method reference.
16. The computing device of claim 14 , wherein the called interface method table entry comprises an entry-point value, and wherein determining the entry point based on the called interface method table entry comprises determining the entry point based on the entry point value.
17. The computing device of claim 13 , wherein determining the entry point for the called software method based the at least one of the interface method table and the virtual method table comprises:
upon determining that the called software method is a virtual method associated with the class instance, the computing device:
determining a called virtual method table entry of the virtual method table that is associated with the called software method; and
determining the entry point based on the called virtual method table entry.
18. The computing device of claim 17 , wherein the called virtual method table entry comprises a runtime-method reference, and wherein determining the entry point based on the called virtual method table entry comprises determining the entry point based on the runtime-method reference.
19. The computing device of claim 17 , wherein the called virtual method table entry comprises an entry-point value, and wherein determining the entry point based on the called virtual method table entry comprises determining the entry point based on the entry point value.
20. An article of manufacture including data storage having instructions stored thereon that, when executed by one or more processors, cause the one or more processors to perform functions comprising:
receiving a request to call a software method of a class instance, wherein the class instance comprises an interface method table and a virtual method table, wherein the interface method table comprises one or more interface method table entries and the virtual method table comprises one or more virtual table entries, wherein the one or more interface method table entries comprise a particular interface method table entry for a particular interface method of a software interface associated with the class instance, the particular interface method table entry comprising a reference related to the particular interface method, wherein the one or more virtual table entries comprise a particular virtual table entry for a particular virtual method associated with the class instance, the particular virtual table entry comprising a reference related to the particular virtual method;
determining an entry point for the called software method based on at least one of the interface method table and the virtual method table; and
calling the called software method by executing instructions at the entry point.
Priority Applications (4)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/589,898 US20160196119A1 (en) | 2015-01-05 | 2015-01-05 | Apparatus and Methods for Virtual and Interface Method Calls |
PCT/US2015/062219 WO2016111766A1 (en) | 2015-01-05 | 2015-11-23 | Apparatus and methods for virtual and interface method calls |
CN201580072468.4A CN107111495B (en) | 2015-01-05 | 2015-11-23 | Apparatus and method for virtual and interface method calls |
EP15805698.6A EP3243132B1 (en) | 2015-01-05 | 2015-11-23 | Apparatus and methods for virtual and interface method calls |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/589,898 US20160196119A1 (en) | 2015-01-05 | 2015-01-05 | Apparatus and Methods for Virtual and Interface Method Calls |
Publications (1)
Publication Number | Publication Date |
---|---|
US20160196119A1 true US20160196119A1 (en) | 2016-07-07 |
Family
ID=54834940
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/589,898 Abandoned US20160196119A1 (en) | 2015-01-05 | 2015-01-05 | Apparatus and Methods for Virtual and Interface Method Calls |
Country Status (4)
Country | Link |
---|---|
US (1) | US20160196119A1 (en) |
EP (1) | EP3243132B1 (en) |
CN (1) | CN107111495B (en) |
WO (1) | WO2016111766A1 (en) |
Cited By (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10445071B2 (en) * | 2015-03-19 | 2019-10-15 | Dspace Digital Signal Processing And Control Engineering Gmbh | Computer-implemented method for computer-aided generation of an executable control program, and also computer-implemented method for computer-aided translation of a graphical model describing the functionality of a control program |
US11163589B2 (en) * | 2017-10-09 | 2021-11-02 | Huawei Technologies Co., Ltd. | Class unloading method and electronic device |
Families Citing this family (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN108319504B (en) * | 2018-03-19 | 2021-01-01 | 武汉斗鱼网络科技有限公司 | Memory occupation optimization method and device and readable storage medium |
CN111241217B (en) * | 2018-11-29 | 2023-05-30 | 阿里巴巴集团控股有限公司 | Data processing method, device and system |
Citations (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20050204361A1 (en) * | 2000-12-13 | 2005-09-15 | Esmertec Ag | Process and apparatus for sharing inline caches |
US20150040223A1 (en) * | 2013-07-31 | 2015-02-05 | Ebay Inc. | Systems and methods for defeating malware with polymorphic software |
Family Cites Families (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5907707A (en) * | 1997-01-14 | 1999-05-25 | International Business Machines Corporation | Object model for Java |
US6651248B1 (en) * | 2000-09-01 | 2003-11-18 | International Business Machines Corporation | Method and apparatus for efficient interface method dispatch |
US7577761B2 (en) * | 2005-08-31 | 2009-08-18 | International Business Machines Corporation | Out of user space I/O directly between a host system and a physical adapter using file based linear block address translation |
-
2015
- 2015-01-05 US US14/589,898 patent/US20160196119A1/en not_active Abandoned
- 2015-11-23 CN CN201580072468.4A patent/CN107111495B/en active Active
- 2015-11-23 WO PCT/US2015/062219 patent/WO2016111766A1/en active Application Filing
- 2015-11-23 EP EP15805698.6A patent/EP3243132B1/en active Active
Patent Citations (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20050204361A1 (en) * | 2000-12-13 | 2005-09-15 | Esmertec Ag | Process and apparatus for sharing inline caches |
US20150040223A1 (en) * | 2013-07-31 | 2015-02-05 | Ebay Inc. | Systems and methods for defeating malware with polymorphic software |
Cited By (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10445071B2 (en) * | 2015-03-19 | 2019-10-15 | Dspace Digital Signal Processing And Control Engineering Gmbh | Computer-implemented method for computer-aided generation of an executable control program, and also computer-implemented method for computer-aided translation of a graphical model describing the functionality of a control program |
US11163589B2 (en) * | 2017-10-09 | 2021-11-02 | Huawei Technologies Co., Ltd. | Class unloading method and electronic device |
Also Published As
Publication number | Publication date |
---|---|
EP3243132A1 (en) | 2017-11-15 |
EP3243132B1 (en) | 2022-06-08 |
WO2016111766A1 (en) | 2016-07-14 |
CN107111495B (en) | 2020-11-17 |
CN107111495A (en) | 2017-08-29 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN109032706B (en) | Intelligent contract execution method, device, equipment and storage medium | |
US8739147B2 (en) | Class isolation to minimize memory usage in a device | |
US20210173665A1 (en) | Bootstrapping Profile-Guided Compilation and Verification | |
US10162690B2 (en) | System and method for encapsulating computer communications | |
US10241783B2 (en) | Methods for multi-source configuration of mobile applications | |
EP3757860B1 (en) | Providing improved efficiency for metadata usages | |
EP3243132B1 (en) | Apparatus and methods for virtual and interface method calls | |
US11966331B2 (en) | Dedicated bound information register file for protecting against out-of-bounds memory references | |
US11893367B2 (en) | Source code conversion from application program interface to policy document | |
US20220197648A1 (en) | Static Identifications in Object-based Memory Access | |
US20210336994A1 (en) | Attestation support for elastic cloud computing environments | |
US11016886B2 (en) | Multi-ring shared, traversable, and dynamic advanced database | |
US9092335B2 (en) | Representing a tree structure on a flat structure | |
US11200070B2 (en) | Dynamic-link library usage based on memory size | |
US11074200B2 (en) | Use-after-free exploit prevention architecture | |
EP3872630A2 (en) | Request processing method and apparatus, electronic device, and computer storage medium | |
US20240143485A1 (en) | Presubmit Test Run Minimization Analysis Using Runtime Isolation Guarantees | |
US20230359440A1 (en) | Externally-initiated runtime type extension | |
US11188316B2 (en) | Performance optimization of class instance comparisons | |
US20210096843A1 (en) | Just-in-time code patching | |
US9501229B1 (en) | Multi-tiered coarray programming |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:YANG, MINGYAO;ROGERS, IAN ANDREW;SIGNING DATES FROM 20141223 TO 20150102;REEL/FRAME:034637/0186 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044129/0001Effective date: 20170929 |
|
STCB | Information on status: application discontinuation |
Free format text: ABANDONED -- FAILURE TO RESPOND TO AN OFFICE ACTION |