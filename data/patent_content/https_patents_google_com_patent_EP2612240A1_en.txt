EP2612240A1 - Automatic application tuning - Google Patents
Automatic application tuningInfo
- Publication number
- EP2612240A1 EP2612240A1 EP11754583.0A EP11754583A EP2612240A1 EP 2612240 A1 EP2612240 A1 EP 2612240A1 EP 11754583 A EP11754583 A EP 11754583A EP 2612240 A1 EP2612240 A1 EP 2612240A1
- Authority
- EP
- European Patent Office
- Prior art keywords
- parameter
- software application
- application
- goal
- data store
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Withdrawn
Links
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/44—Arrangements for executing specific programs
- G06F9/455—Emulation; Interpretation; Software simulation, e.g. virtualisation or emulation of application or operating system execution engines
- G06F9/45504—Abstract machines for programme code execution, e.g. Java virtual machine [JVM], interpreters, emulators
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/34—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment
- G06F11/3409—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment for performance assessment
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/34—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment
- G06F11/3466—Performance evaluation by tracing or monitoring
- G06F11/3495—Performance evaluation by tracing or monitoring for systems
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2201/00—Indexing scheme relating to error detection, to error correction, and to monitoring
- G06F2201/865—Monitoring of software
Definitions
- the present application generally relates to software application optimization and tuning.
- Embodiments described herein relate to providing a method, apparatus and computer program product for automatically tuning a software application.
- a method of automatically tuning a software application may include modifying the execution of the software application using a first parameter, and scoring the first parameter based on a log value from the software application and an improvement goal.
- the first parameter, the score of the first parameter and the log value is stored in a data store.
- the first parameter is then combined with a selected parameter retrieved from the data store, resulting in a second parameter.
- the listed steps are repeated until a criteria is met, and when the criteria is met, tuning results are generated based on the parameters, the log values and the improvement goal.
- an apparatus for automatically tuning a software application includes an extractor configured to receive log values from the operation of the software application, the operation of the software application being affected by a first parameter set, a data store configured to store the received log values and the first parameter set, and a fitness determiner configured to score the first parameter set based on the received log values and a goal.
- the apparatus may further include a hypothesizer configured to retrieve a selected parameter set from the data store and combine the first parameter set with the selected parameter set to produce a second parameter set and a terminator configured to determine, based on a criteria, whether to modify the execution of the software application using the second parameter set and repeat operations of the extractor, data store and fitness determiner for the second data set.
- a reporter is configured to generate tuning results based on the parameters, the log values and the goal.
- FIG. 1A is a block diagram depicting a software application and a tuner, according to an embodiment.
- FIG. I B is a block diagram depicting a software application having multiple instances and a tuner, according to an embodiment.
- FIG. 2 is a block diagram depicting a more detailed view of a tuner and an experiment database, according to an embodiment.
- FIG. 3A is a block diagram depicting a more detailed view of a hypothesizer and an experiment database, according to an embodiment.
- FIG. 3B is a table illustrating a combination of parameter sets, according to an embodiment.
- FIG. 4 is a block diagram depicting a tuner and a Java Virtual Machine (JVM), according to an embodiment.
- JVM Java Virtual Machine
- FIG. 5 shows a flowchart illustrating a method of automatically tuning a software application according to an embodiment of the invention.
- FIG. 6 depicts a sample computer system that may be used to implement an embodiment.
- some embodiments described herein automatically tune parameters associated with the execution of a software application.
- An embodiment described herein performs an "experiment,” by using experimental parameter values with an operating application.
- An extractor extracts results from the application, and a hypothesizer reviews the extracted results. Based on the results and a tuning goal, the hypothesizer selects new parameter values and the cycle is performed again. Once the possible experiments have been performed or a particular result is achieved, the iterative cycle is terminated and results are generated.
- FIG. 1A depicts a block diagram of system 100 according to an embodiment, such system having users 1 lOA-C, network 101 and computer system 190.
- Computer system 190 is depicted having application 150 and tuner 120.
- application 150 is a software application executing on computer system 190.
- Each of these system components depicted in FIGs. 1-6 and discussed herein may be executed on any type of computing device including, but not limited to, a computer, workstation, distributed computing system, embedded system, stand-alone electronic device, networked device, mobile device, rack server, one or more load- balanced redundant servers, server farm, television, or other type of computer system. It is important to note that embodiments of all of the components, applications, virtual machines, etc., described herein can be executed using one or more computing devices, with spanning/distributed functions. Additional discussion and illustration of example computing devices is made with reference to FIG. 6 below.
- Network 101 may be any network or combination of networks that can carry data communication.
- Such network 101 can include, but is not limited to, a local area network, medium area network, and/or wide area network such as the Internet.
- Network 101 can support protocols and technology including, but not limited to, World Wide Web protocols and/or services.
- Intermediate web servers, gateways, or other servers may be provided between components of system 100 depending upon a particular application or environment.
- some of the embodiments discussed herein are network-based applications, using network 101 to distribute functions to users 1 10A-C, for example. It is important to note that some functions described with embodiments herein do not require network 101.
- a software application e.g. , application 150
- application 150 can be any type of computer program designed to perform specific tasks.
- application 150 is server-software designed to perform tasks for users over network 101 , such software having multiple complex parameters and/or settings that configure the execution, performance, and/or efficiency of the application.
- periodic tuning of application 150 parameters can have significant benefits.
- application parameters can broadly refer to any parameter that can change the operation of application 150. This definition also includes parameters that can govern the operation of the software language environment in which application 150 is being operated, e.g. , the discussion of Java Virtual Machine (JVM) parameters with respect to FIG. 4 below.
- JVM Java Virtual Machine
- application 150 can be a Java application.
- a Java application can execute within a Java Virtual Machine.
- a JVM has multiple application parameters that can change the operation of applications running in the JVM.
- steps S 1-S9 broadly describes the setup and operation of an embodiment of tuner 120:
- Application 150 is assessed, and at least one goal associated with application execution is determined. For example, if application 150 is a high- performance application that requires a quick response, improved latency can be selected as a goal. As is discussed further below, in an embodiment, multiple, ranked goals can be selected at this step.
- a result 155 is selected that measures the progress toward the goal.
- a result 155 that can measure latency in an application is the "pause time" of the application.
- multiple, ranked results 155 can also be selected, the combination of which can measure progress toward the one or more goals. For example, in addition to selecting "pause time” an embodiment can select "throughput”— these results being ranked in order of significance toward the goal. Calculations, weighting and other combing techniques can be used by an embodiment to measure multiple results 155 from application 150.
- Application 150 has a plurality of parameters 121 , such parameters 121 affecting the operation of application 150. Based on the characteristics of application 150 and potentially, result 155, at least one of the plurality of parameters 121 is selected for use by tuner 120 in an experiment. Continuing the example above, whether to perform serial garbage collection in a virtual machine is an example parameter 121 that can affect the pause time result 155 noted in S2.
- an initial value is selected for the selected parameter 121.
- serial garbage collection is selected.
- this initial value for parameter 121 combined with the selected result 155 to be monitored can be termed an "experiment.”
- this initial value is termed an "initial experimental population.”
- the selected period could be selected so as to simulate a production system.
- application 150 exhibits diurnally cyclical traffic throughout the day and thus requires at least 24 hours of operation to generate useful results.
- Other embodiments could have longer or shorter selected periods based on their usage characteristics.
- tuner 120 analyzes the collected result 155.
- this analysis can involve different considerations and approaches. One approach is described further with FIGs. 2-3 below.
- tuner 120 Based on the analysis of S7, tuner 120 either formulates a new experiment (by selecting a new value for parameter 121) or terminates the iterative cycle. In different embodiments, this termination can be for different reasons, including that all of the different available parameter values have been tried, or that improvement toward the goal is determined not to be likely with further experimentati on.
- FIG. 1B-5 add additional detail to the operation of different items S1-S9.
- FIG. IB adds additional exemplary detail to the performance of S5
- FIG. 2 adds exemplary detail to S5-S9
- FIG. 3 adds exemplary detail to S7-S8
- FIG. 4 describes an applied example using the details discussed with FIGs. 1B-3
- FIG. 5 depicts a flowchart having portions of S 1-S9, according to an embodiment.
- FIG. IB depicts a more detailed block diagram of system 100, showing application 150 as having three instances 151A-C.
- application 150 can execute on a QA system, such system being used for internal testing and not connected an external environment.
- application 150 is executed in a production environment, having potentially thousands of users, e.g. , users 1 lOA-C.
- One additional approach taken to testing application 150 is to have multiple instances 151A-C of application 150, and only use tuner 120 on a portion of the available instances.
- tuner 120 may only be testing parameter sets on instance 151 A, while allowing instances 151B-C to execute with the currently active production parameters.
- instance 151 A may be termed a "canary” or a "canary instance.” This approach can allow for testing that produces useful data while not risking the operating of the entire production system.
- FIG. 2 depicts a detailed block diagram of tuner 120 according to an embodiment, such component having extractor 210, validator 220, hypothesizer 230, generator 250, executor 260, timer 290 and terminator 240. Result 155 and parameter 121 are shown, along with tuner 120 depicted as coupled to experiment database 270, with a link 275 to application 150 (not shown).
- the experiment is started using an initial value for parameter 121.
- executor 260 starts the experiment in the QA environment or in production on a canary. It is important to note that, as noted above, each experiment can use multiple parameters 121 and collect and/or receive multiple results 155, and also that multiple experiments can be run by one or more tuners 120 simultaneously on the same or different applications 150.
- results 155 may be gathered over a period of time.
- results 155 are gathered by extractor 210 (extractor object) via link 275 to application 150.
- extractor 210 extractor object
- One approach taken by an embodiment of extractor 210 is to scrape, parse and collate the logs of application 150, with application 150 configured to store results 155 in such logs.
- Another approach taken by an embodiment is to have application 150 send result 155 to extractor 210.
- result 155 is stored for later retrieval.
- One approach to storing result 155 is to use experiment database 270.
- any result generated by application 150— regardless of how it is transferred to extractor 210— is termed a "log value.” Log values are also equivalent to results as discussed with respect to some embodiments herein.
- timer 290 was started by executor 260 when the experiment was commenced.
- the expiration of timer 290 indicates the end of the experimental period (discussed with respect to item S6 above) and the beginning of the data extraction phase to be performed by extractor 210.
- validator 220 determines if the result 155 data is useful for analysis by later stages. Different criteria can be used by some embodiments to determine result 155 validity. For example, if the operation of application 150 was prematurely terminated due to a bad parameter value or for other reasons, this data can be detected and removed from experiment database 270 at this stage.
- hypothesizer 230 analyzes results 155 stored in experiment database 270. Generally speaking, results 155 are used by hypothesizer 230 to produce a new experiment to run.
- One approach taken by an embodiment of hypothesizer 230 is to create the "best of breed" of experiment parameters 121 by scoring results 155 of completed experiments and generating new parameters 121 for new experiments.
- FIG. 3A depicts a detailed view an embodiment of experiment database 270, terminator 240 and hypothesizer 230, such hypothesizer 230 having fitness determiner 320, footprint goal 350, throughput goal 340 and pause time goal 330.
- Experiment database 270 is depicted as having parameter sets 321A-F therein— such sets stored, in an embodiment by extractor 210 from FIG. 2.
- fitness determiner 320 analyzes results 355 A-F resulting from parameter sets 321A-F against selected goals 330, 340, 350.
- Three example optimization goals used by some embodiments include: pause time 330, application throughput 340 and memory footprint 350. These example optimization goals are discussed below with the example of FIG. 4, and also can be applied generally to other application tuning problems.
- fitness determiner 320 scores parameter sets 321 A-F
- the results/parameter set of the present experiment (e.g. , 355A/321A) can be compared to one or more previous experiments, e.g. , 355B-F/321B-F.
- results/parameter set of the present experiment e.g. , 355A/321A
- previous experiments e.g. , 355B-F/321B-F.
- goals 330, 340, 350 can be ranked in order of importance.
- the scoring approach taken by fitness determiner 320 is configurable and is specific to the application type and/or goal being tuned. As noted above in item SI , different goals (optimization goals) can be selected for use in evaluating parameter sets 321A-F.
- monitored application 150 e.g. , a service
- n[p] avgMinorPauseTime ::: 109
- An example fitness function can be an algebraic function that, considering the selected optimization goal, uses the performance measurements listed above to produce a score for parameter set 321A.
- the following is a non-limiting example of a fitness function based on parameter set 321 A listed above: function(n[p], n[i], j[p], j [i]) - n[i] / n[p] + j [i] / j [p]
- the example fitness function score (392.16) can be used to rank parameter set
- 321A against other parameter sets 321B-F. For example, if parameter set 321 B results in a score of 300, an embodiment can determine 321A to be a higher ranked/better parameter set with respect to the selected optimization goal.
- a fitness function can use weights to weight different parameters against each other. Using the above listed example parameter set 321 A, if the major pause/interval times (j) are considered twice as important as the minor times (n), the following fitness function could be used by an embodiment:
- hypothesizer 230 can use different approaches to generate new parameter sets for new experiments.
- One approach taken by an embodiment uses an evolutionary/genetic approach to combine fitness determiner 320 evaluated parameter settings into new "child" parameter set combinations.
- hypothesizer 230 can combine and reformulate parameter sets to seek improved results toward selected goals 330, 340, 350.
- steps G1-G2 broadly describes the setup and operation of an embodiment of hypothesizer 230 using an evolutionary/genetic algorithm.
- 321A-F then crosses (or combines) the population, favoring the experiments with the highest scores for crossing/combining.
- hypothesizer 230 has six parameter sets 321A-F to choose from
- the two with the highest scores can be chosen for crossing, e.g. , 321A-B.
- the third through sixth ranked parameter sets 321 C-F are not selected for crossing/combining.
- any portion of the available parameter sets 321 A-F can be chosen for crossing.
- FIG. 3B depicts an embodiment of crossing process 390, such process combining parameter set 321 A and 32 IB to form child set 331.
- Each parameter set 321 A-B and child set 331 has parameters 391 , 392 and 393.
- a random/pseudorandom result generator is used to selectively choose a value for child set 331 for each parameter 391, 392 and 393 from parameter sets 321 A-B.
- child set 331 received its parameter 391 ("C") from parameter set 32 IB, not from parameter set 321 A.
- the remainder of the parameters 392, 393 of child set 331 were selected in a similar fashion.
- each "parent" parameter set 321 A-B can be termed a "chromosome.”
- Some embodiments can use different learning techniques to modify the operation of embodiments.
- Items T1-T3 below are intended to be a non-limiting list of exemplary learning techniques used to alter the operation of some embodiments described herein.
- One having skill in the relevant art(s), given the description herein, will appreciate the operation of T1-T3 and how the approaches can apply to some embodiments:
- the learning techniques T1 -T3 can be used to alter the operation of an embodiment by improving the performance of the embodiment.
- a learning technique e.g., T1 -T3
- T1 -T3 can be used to predict how likely it is that a parameter set (chromosome) will perform well in the experiment.
- success predictions can be used to reduce the number of parameter sets that need to be tested, and therefore reduce the time for the embodiment to find a solution.
- other approaches to reducing the number of parameter sets required for testing can be used.
- Terminator 240 can terminate the experiment process described above for different reasons. Termination reasons include that all of the different available parameier values have been tri ed, or improvement toward the goal is estimated not to be likely with further experimentation,
- results 355 could be diminished in value either once or over time.
- the combination of assessing results over time, and the random combination of parameters in parameter sets using the genetic algorithm described above can beneficially avoid the "local minima'' problem (where results are temporarily diminished in value, then resume improvement).
- a report thai includes a list of the parameter names and values for each parameter in one ore more determined final parameter sets.
- P2. An electronic mail sent to a software application administrator.
- P3. Parameter sets can be created and automatically deployed to a production environment.
- Parameter sets can be created and automatically deployed to an additional QA environment for further testing.
- P5. Parameter sets can be stored in a database.
- a parameter set is generated that lists the parameter sets that have shown to have the best improvement in the latency of application 150. As noted with P2 above, these sets for example, can be emailed to an administrator responsible for the operation of application 150.
- FIG. 4 depicts an embodiment with JVM 410 and tuner 120.
- JVM 410 is depicted having Java application 450 and Java Garbage Collector (Java GC) 460, and tuner 120 is depicted as having parameter set 421.
- Java application 450 is running inside JVM 410, with Java GC cleaning up resource use, as would be appreciated by one having skill in the relevant art(s).
- a goal is selected that is designed to achieve a desired result.
- JVM GC 460 experiments are configured for three optimization goals related to GC: pause time, throughput and memory footprint. These goals are shown in FIG. 3 (330-350) and listed below as non-limiting list G1-G3:
- Gl Pause Time Goal: As noted above, in this example, the most important aspect of tuning Java GC 460 settings of JVM 410 revolves around the amount of time Java application 450 is paused. Java GC 460 pause time generally causes threads to halt during garbage collection and is directly related to application latency, which can be of primary importance to application execution. In an embodiment, this is the most important goal.
- G2. Throughput Goal Java application 450 throughput is proportional to the amount of CPU processing time devoted to useful work and is generally inversely proportional to JVM GC 460 pause time (Gl). Additionally, when a concurrent JVM GC 460 is used (not shown) then the concurrent JVM GC thread(s) potentially take up CPU resources from the application threads. In an embodiment, because this throughput can use CPU resources, it is the second most important goal.
- G3. Memory Footprint Goal The amount of memory devoted to Java application 450 is the termed the "memory footprint" and generally should be minimized to avoid resource waste. In an embodiment, this is the least important goal as compared to goals G1 -G2 listed above.
- Goals G1 -G3 are non-limiting and intended illustrate example goals for the operation of some embodiments. As would be appreciated by one having skill in the relevant art(s), given the description herein, a wide variety of other goals can be use by embodiments.
- JVM 410 settings that can be used in this example.
- one JVM setting from the list below is incremented or decremented by a selected amount per experiment.
- multiple settings can be combined together into parameter set 421.
- extractor 210 in tuner 120 gathers different Java GC 460 statistics.
- different statistics that can be collected by extractor 210 include: JVM 410 memory footprint, class instantiation parameters and sizing, and, with Java GC 460, collection statistics.
- the statistics available from Java GC 460 cover a wide amount of GC statistics in a time series aggregate form. In another embodiment, additional formats of data are available and usable.
- an embodiment of tuner 120 applied to the JVM 410 example, and other applications can accept a number of different command line arguments, commands executed at a terminal by an administrator.
- the list of commands below is intended to be non-limiting, and to illustrate the different types of commands and settings that can be used by some embodiments:
- command line arguments can be used to modify application behavior.
- Embodiments can accept command line arguments from different sources, including other related applications and application/system administrators.
- FIG. 5 illustrates a more detailed view of how embodiments described herein may interact with other aspects of embodiments.
- a method of automatically tuning a software application is shown. Initially, as shown in stage 510 on FIG. 5, the execution of a software application is modified using a first parameter.
- the first parameter is scored based on a log value from the software application and an improvement goal.
- the first parameter, the score of the first parameter and the log value are stored in a data store.
- the first parameter is combined with a selected parameter retrieved from the data store, this combining resulting in a second parameter.
- stages 510 through 540 are repeated until a criteria is met. If the criteria is met, at stage 560 tuning results are generated based on the parameters, the log values and the improvement goal.
- the method ends at 570.
- FIG. 6 illustrates an example computer system 600 in which embodiments of the present invention, or portions thereof, may be implemented as computer-readable code.
- FIGs. 1-4 and stages of method 500 of FIG. 5 may be implemented in computer system 600 using hardware, software, firmware, tangible computer readable media having instructions stored thereon, or a combination thereof and may be implemented in one or more computer systems or other processing systems.
- Hardware, software or any combination of such may embody any of the modules/components in FIGs. 1 -4 and any stage in FIG. 5.
- Users 1 10A-C and computer system 190 can also be implemented having components of computer system 600.
- programmable logic may execute on a commercially available processing platform or a special purpose device.
- a commercially available processing platform or a special purpose device.
- One of ordinary skill in the art may appreciate that embodiments of the disclosed subject matter can be practiced with various computer system and computer-implemented device configurations, including smartphones, cell phones, mobile phones, tablet PCs, multi-core multiprocessor systems, minicomputers, mainframe computers, computer linked or clustered with distributed functions, as well as pervasive or miniature computers that may be embedded into virtually any device.
- processor devices may be used to implement the above described embodiments.
- a processor device may be a single processor, a plurality of processors, or combinations thereof.
- Processor devices may have one or more processor 'cores.'
- Processor device 604 may be a special purpose or a general purpose processor device. As will be appreciated by persons skilled in the relevant art, processor device 604 may also be a single processor in a multi-core/multiprocessor system, such system operating alone, or in a cluster of computing devices operating in a cluster or server farm. Processor device 604 is connected to a communication infrastructure 606, for example, a bus, message queue, network or multi-core message-passing scheme.
- a communication infrastructure 606 for example, a bus, message queue, network or multi-core message-passing scheme.
- Computer system 600 also includes a main memory 608, for example, random access memory (RAM), and may also include a secondary memory 610.
- Secondary memory 610 may include, for example, a hard disk drive 612, removable storage drive 614 and solid state drive 616.
- Removable storage drive 614 may comprise a floppy disk drive, a magnetic tape drive, an optical disk drive, a flash memory, or the like.
- the removable storage drive 614 reads from and/or writes to a removable storage unit 618 in a well known manner.
- Removable storage unit 618 may comprise a floppy disk, magnetic tape, optical disk, etc. which is read by and written to by removable storage drive 614.
- removable storage unit 618 includes a computer usable storage medium having stored therein computer software and/or data.
- secondary memory 610 may include other similar means for allowing computer programs or other instructions to be loaded into computer system 600.
- Such means may include, for example, a removable storage unit 622 and an interface 620.
- Examples of such means may include a program cartridge and cartridge interface (such as that found in video game devices), a removable memory chip (such as an EPROM, or PROM) and associated socket, and other removable storage units 622 and interfaces 620 which allow software and data to be transferred from the removable storage unit 622 to computer system 600.
- Computer system 600 may also include a communications interface 624.
- Communications interface 624 allows software and data to be transferred between computer system 600 and external devices.
- Communications interface 624 may include a modem, a network interface (such as an Ethernet card), a communications port, a PCMCIA slot and card, or the like.
- Software and data transferred via communications interface 624 may be in electronic, electromagnetic, optical, or other forms capable of being received by communications interface 624. This data may be provided to communications interface 624 via a communications path 626.
- Communications path 626 carries the data and may be implemented using wire or cable, fiber optics, a phone line, a cellular phone link, an RF link or other communications channels.
- Computer program medium and “computer usable medium” are used to generally refer to media such as removable storage unit 618, removable storage unit 622, and a hard disk installed in hard disk drive 612.
- Computer program medium and computer usable medium may also refer to memories, such as main memory 608 and secondary memory 610, which may be memory semiconductors (e.g., DRAMs, etc.).
- Computer programs may be stored in main memory 608 and/or secondary memory 610. Computer programs may also be received via communications interface 624. Such computer programs, when executed, enable computer system 600 to implement the present invention as discussed herein. In particular, the computer programs, when executed, enable processor device 604 to implement the processes of the present invention, such as the stages in the method illustrated by flowchart 500 of FIG. 5 discussed above. Accordingly, such computer programs represent controllers of the computer system 600. Where the invention is implemented using software, the software may be stored in a computer program product and loaded into computer system 600 using removable storage drive 614, interface 620, hard disk drive 612 or communications interface 624.
- Embodiments of the invention also may be directed to computer program products comprising software stored on any computer useable medium. Such software, when executed in one or more data processing devices, causes a data processing device(s) to operate as described herein.
- Embodiments of the invention employ any computer useable or readable medium. Examples of computer useable mediums include, but are not limited to, primary storage devices (e.g. , any type of random access memory), secondary storage devices (e.g. , hard drives, floppy disks, CD ROMS, ZIP disks, tapes, magnetic storage devices, and optical storage devices, MEMS, nanotechnological storage device, etc.).
- Embodiments described herein relate to methods and apparatus for protecting connectivity in a network.
- the summary and abstract sections may set forth one or more but not all exemplary embodiments of the present invention as contemplated by the inventors, and thus, are not intended to limit the present invention and the claims in any way.
Abstract
Description
Claims
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US12/875,683 US20120060146A1 (en) | 2010-09-03 | 2010-09-03 | Automatic Application Tuning |
PCT/US2011/049394 WO2012030656A1 (en) | 2010-09-03 | 2011-08-26 | Automatic application tuning |
Publications (1)
Publication Number | Publication Date |
---|---|
EP2612240A1 true EP2612240A1 (en) | 2013-07-10 |
Family
ID=44583483
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
EP11754583.0A Withdrawn EP2612240A1 (en) | 2010-09-03 | 2011-08-26 | Automatic application tuning |
Country Status (5)
Country | Link |
---|---|
US (1) | US20120060146A1 (en) |
EP (1) | EP2612240A1 (en) |
CL (1) | CL2013000592A1 (en) |
SG (1) | SG188262A1 (en) |
WO (1) | WO2012030656A1 (en) |
Families Citing this family (8)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9875174B1 (en) * | 2011-09-21 | 2018-01-23 | Amazon Technologies, Inc. | Optimizing the execution of an application executing on a programmable execution service |
US9003404B2 (en) * | 2012-03-22 | 2015-04-07 | Verizon Patent And Licensing Inc. | Determining hardware functionality in a cloud computing environment |
US10318399B2 (en) * | 2013-03-12 | 2019-06-11 | Netflix, Inc. | Using canary instances for software analysis |
US9225621B2 (en) * | 2013-06-25 | 2015-12-29 | Netflix, Inc. | Progressive deployment and termination of canary instances for software analysis |
IT201900003667A1 (en) | 2019-03-13 | 2020-09-13 | Akamas S R L | METHOD AND APPARATUS FOR TUNING ADJUSTABLE PARAMETERS IN COMPUTING ENVIRONMENT |
CN110364042A (en) * | 2019-06-26 | 2019-10-22 | 北京航空航天大学 | A kind of wireless sensor network experiment teaching system based on cloud experiment porch |
US11340924B2 (en) | 2019-06-27 | 2022-05-24 | International Business Machines Corporation | Machine-learning based heap memory tuning |
IT202100007631A1 (en) | 2021-03-29 | 2022-09-29 | Akamas Spa | METHOD AND SYSTEM FOR DEVELOPING A COMPUTER ENVIRONMENT USING A KNOWLEDGE BASE |
Family Cites Families (13)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6249252B1 (en) * | 1996-09-09 | 2001-06-19 | Tracbeam Llc | Wireless location using multiple location estimators |
US6671874B1 (en) * | 2000-04-03 | 2003-12-30 | Sofia Passova | Universal verification and validation system and method of computer-aided software quality assurance and testing |
US6986125B2 (en) * | 2001-08-01 | 2006-01-10 | International Business Machines Corporation | Method and apparatus for testing and evaluating a software component using an abstraction matrix |
US6964042B2 (en) * | 2002-12-17 | 2005-11-08 | Bea Systems, Inc. | System and method for iterative code optimization using adaptive size metrics |
US7546598B2 (en) * | 2003-09-03 | 2009-06-09 | Sap Aktiengesellschaft | Measuring software system performance using benchmarks |
US7757216B2 (en) * | 2003-12-10 | 2010-07-13 | Orcle International Corporation | Application server performance tuning client interface |
US7434214B2 (en) * | 2004-01-21 | 2008-10-07 | International Business Machines Corporation | Method for determining a close approximate benefit of reducing memory footprint of a Java application |
US7975256B2 (en) * | 2004-06-30 | 2011-07-05 | International Business Machines Corporation | Optimizing application performance through data mining |
US20060047794A1 (en) * | 2004-09-02 | 2006-03-02 | Microsoft Corporation | Application of genetic algorithms to computer system tuning |
US20070234327A1 (en) * | 2006-03-31 | 2007-10-04 | Baxter Robert A | Configuring media applications based on performance characteristics |
US7571069B1 (en) * | 2006-12-22 | 2009-08-04 | Hewlett-Packard Development Company, L.P. | Data assurance workflow derivation and execution |
US8930926B2 (en) * | 2008-02-08 | 2015-01-06 | Reservoir Labs, Inc. | System, methods and apparatus for program optimization for multi-threaded processor architectures |
US8726254B2 (en) * | 2009-06-20 | 2014-05-13 | Microsoft Corporation | Embedded annotation and program analysis |
-
2010
- 2010-09-03 US US12/875,683 patent/US20120060146A1/en not_active Abandoned
-
2011
- 2011-08-26 EP EP11754583.0A patent/EP2612240A1/en not_active Withdrawn
- 2011-08-26 WO PCT/US2011/049394 patent/WO2012030656A1/en active Application Filing
- 2011-08-26 SG SG2013013008A patent/SG188262A1/en unknown
-
2013
- 2013-03-01 CL CL2013000592A patent/CL2013000592A1/en unknown
Non-Patent Citations (1)
Title |
---|
See references of WO2012030656A1 * |
Also Published As
Publication number | Publication date |
---|---|
WO2012030656A1 (en) | 2012-03-08 |
SG188262A1 (en) | 2013-04-30 |
CL2013000592A1 (en) | 2013-08-09 |
US20120060146A1 (en) | 2012-03-08 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
WO2012030656A1 (en) | Automatic application tuning | |
Verma et al. | Play it again, simmr! | |
Li et al. | Deepjs: Job scheduling based on deep reinforcement learning in cloud data center | |
Wang et al. | Using realistic simulation for performance analysis of mapreduce setups | |
Mann et al. | Which is the best algorithm for virtual machine placement optimization? | |
Wang et al. | Towards synthesizing realistic workload traces for studying the hadoop ecosystem | |
CN109597733B (en) | Multifunctional efficient dynamic chip verification simulation method and equipment | |
CN107562532B (en) | Method and device for predicting hardware resource utilization rate of equipment cluster | |
Jammal et al. | Evaluating high availability-aware deployments using stochastic petri net model and cloud scoring selection tool | |
JP2014186364A (en) | Dispersion system | |
US20150012629A1 (en) | Producing a benchmark describing characteristics of map and reduce tasks | |
Krevat et al. | Applying performance models to understand data-intensive computing efficiency | |
Singhal et al. | Predicting job completion time in heterogeneous mapreduce environments | |
Pitchumani et al. | Realistic request arrival generation in storage benchmarks | |
Xu | MapReduce framework optimization via performance modeling | |
Oral et al. | Supporting performance isolation in software as a service systems with rich clients | |
Huang et al. | A novel compression algorithm decision method for spark shuffle process | |
Li et al. | Breaking the boundary for whole-system performance optimization of big data | |
Zhao et al. | Cotask scheduling in cloud computing | |
KR20230037661A (en) | Systems, methods and servers for optimizing the deployment of containerized applications | |
Zeng et al. | Cross-layer SLA management for cloud-hosted big data analytics applications | |
Toth et al. | Improving the productivity of volunteer computing by using the most effective task retrieval policies | |
US9858551B2 (en) | Ranking analysis results based on user perceived problems in a database system | |
Chalvantzis et al. | BBQ: Elastic MapReduce over cloud platforms | |
Zhang et al. | Performance variations in resource scaling for mapreduce applications on private and public clouds |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PUAI | Public reference made under article 153(3) epc to a published international application that has entered the european phase |
Free format text: ORIGINAL CODE: 0009012 |
|
17P | Request for examination filed |
Effective date: 20130403 |
|
AK | Designated contracting states |
Kind code of ref document: A1Designated state(s): AL AT BE BG CH CY CZ DE DK EE ES FI FR GB GR HR HU IE IS IT LI LT LU LV MC MK MT NL NO PL PT RO RS SE SI SK SM TR |
|
REG | Reference to a national code |
Ref country code: HKRef legal event code: DERef document number: 1181154Country of ref document: HK |
|
DAX | Request for extension of the european patent (deleted) | ||
17Q | First examination report despatched |
Effective date: 20140603 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: THE APPLICATION IS DEEMED TO BE WITHDRAWN |
|
18D | Application deemed to be withdrawn |
Effective date: 20160301 |
|
REG | Reference to a national code |
Ref country code: HKRef legal event code: WDRef document number: 1181154Country of ref document: HK |
|
P01 | Opt-out of the competence of the unified patent court (upc) registered |
Effective date: 20230519 |