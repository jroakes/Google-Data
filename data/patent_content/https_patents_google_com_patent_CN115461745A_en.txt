CN115461745A - Meta-estimation of bloom filters with count vectors - Google Patents
Meta-estimation of bloom filters with count vectors Download PDFInfo
- Publication number
- CN115461745A CN115461745A CN202180030781.7A CN202180030781A CN115461745A CN 115461745 A CN115461745 A CN 115461745A CN 202180030781 A CN202180030781 A CN 202180030781A CN 115461745 A CN115461745 A CN 115461745A
- Authority
- CN
- China
- Prior art keywords
- sketch
- registers
- data structure
- data
- processing system
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
- G06F21/6227—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database where protection concerns the structure of data, e.g. records, types, queries
Abstract
Systems and methods for meta-estimating data structures representing identifiers are disclosed. The system maintains one or more data records, the one or more data records including one or more identifiers and one or more attributes. Using the data records, the system may generate a first data structure, such as a probabilistic data structure, that represents the plurality of data records. The first data structure may have a plurality of registers. The system may identify a subset of the plurality of registers equal to a predetermined value and generate a second data structure, the second data structure representing the subset of the plurality of registers. The system may then store the second data structure as a first meta-estimate, and may use the second data structure for further processing operations.
Description
RELATED APPLICATIONS
Priority and benefit of U.S. provisional patent application serial No. 63/087,791, filed on 5/10/2020, this application, U.S. provisional patent application serial No. 63/087,791, is hereby incorporated by reference herein in its entirety.
Background
In many cases, as part of data analysis or processing, the computing and data analysis system may determine an intersection or union of large data sets. Computing the union, intersection, or frequency of a large data set distributed across multiple sources typically involves sharing information about the large data set among the multiple sources. Information from each source may include private or protected information, and sharing such information may negatively impact privacy and security.
Disclosure of Invention
At least one aspect of the present disclosure is directed to a method for meta-estimating a data structure representing an identifier. The method may include maintaining a plurality of data records including one or more identifiers and one or more attributes. The method may include generating a first data structure representing a plurality of data records. The first data structure may have a plurality of first registers. At least one of the plurality of first registers may be populated based on a hash of each of the plurality of identifiers. The method may include identifying a subset of the plurality of first registers that is equal to a predetermined value. Each subset of the plurality of first registers may be identified by an index value. The method may include generating a second data structure representing a subset of the plurality of first registers. The second data structure may have a plurality of second registers. At least one of the plurality of second registers may be populated based on a hash of the index value of each subset of the plurality of first registers. The method may include storing a second data structure in the memory, the second data structure representing a subset of the plurality of first registers.
In some embodiments of the method, the method may include retrieving a third data structure having a plurality of third registers. In some embodiments of the method, each of the plurality of third registers may correspond to a respective one of the plurality of second registers of the second data structure. In some embodiments of the method, the method may include determining, using the second data structure and the third data structure, an intersection value of the information represented by the second data structure and the information represented by the third data structure.
In some embodiments of the method, the method may further include determining a union value of the information represented by the second data structure and the information represented by the third data structure using the intersection value.
These and other aspects and embodiments are discussed in detail below. The foregoing information and the following detailed description include illustrative examples of various aspects and embodiments, and provide an overview or framework for understanding the nature and character of the claimed aspects and embodiments. The accompanying drawings are included to provide an illustration and a further understanding of the various aspects and embodiments, and are incorporated in and constitute a part of this specification. Aspects may be combined, and it will be readily understood that features described in the context of one aspect of the invention may be combined with other aspects. Aspects may be implemented in any convenient form. For example, by means of a suitable computer program, which may be carried on a suitable carrier medium (computer readable medium), which may be a tangible carrier medium (e.g. a diskette) or an intangible carrier medium (e.g. a communications signal). Aspects may also be implemented using suitable apparatus which may take the form of a programmable computer running a computer program arranged to implement aspects. As used in the specification and the appended claims, the singular forms "a", "an", and "the" include plural referents unless the context clearly dictates otherwise.
Drawings
The figures are not intended to be drawn to scale. Like reference numbers and designations in the various drawings indicate like elements. For purposes of clarity, not every component may be labeled in every drawing. In the drawings:
FIG. 1 illustrates a block diagram of an example system for meta-estimation of data structures representing large datasets;
FIG. 2 illustrates a block diagram of an example data flow for meta-estimating a data structure representing a large data set;
FIG. 3 illustrates a block diagram of an example method for meta-estimating a data structure representing a large dataset;
FIG. 4 illustrates a general architecture of an illustrative computer system that may be used to implement any of the computers discussed herein;
FIG. 5 depicts a graph showing example experimental data including errors and deviations as the bloom filter size increases;
FIG. 6 depicts a graph showing example experimental data including errors and deviations as the VoC sketch size increases; and
fig. 7 depicts a graph showing example experimental data including errors and deviations as the bloom filter size increases for an exponential bloom filter embodiment.
Detailed Description
The following is a detailed description of various concepts related to techniques, approaches, methods, apparatuses, and systems for meta-estimating data structures representing identifiers, as well as embodiments thereof. The various concepts introduced above and discussed in greater detail below may be implemented in any of numerous ways, as the described concepts are not limited to any particular implementation. Examples of specific embodiments and applications are provided primarily for illustrative purposes.
Large data sets, such as data sets representing groups of client device identifiers, may be difficult to represent efficiently. In particular, analysis of large data sets, such as those maintained by large content providers, is challenging in terms of computational efficiency and privacy protection. For example, some content providers may store a list of client device identifiers associated with various attributes, such as demographic information (e.g., age, gender, location, interests, etc.), client device attributes (e.g., device type), and other information received from the client device. Typically, this information may include private information or protected information. The content provider may generate a data structure or sketch (sketch) that represents a large data set in a privacy-preserving manner. These sketches can be shared among other content providers for further analysis without presenting the information represented by each sketch.
However, a sketch representation of a large dataset, such as an Exponential Bloom Filter (EBF) sketch (sometimes referred to as a liquid threads (LL) sketch or Any Distributed Bloom Filter (ADBF) sketch), or a Bloom Filter (BF) sketch, etc., may be vulnerable to certain attacks in nature. Briefly, in some cases, if certain precautions (e.g., distributed noise) are not included in the sketch generation, certain data represented by such sketch may be retrieved from the sketch itself. This poses a security risk to systems that generate and rely on such sketches. Other types of sketches, such as count vector (VoC) sketches, do not have this problem, and can improve the overall privacy and security of the information used to generate such sketches.
However, generating a VoC sketch using a large dataset may be more computationally intensive than generating an exponential bloom filter sketch or a bloom filter sketch. For example, unlike EBF or BF sketches, the data items used to generate a VoC sketch must first be de-duplicated (de-duplication) before the sketch can be generated. The deduplication process may incur a significant amount of computational overhead for the sketch generation process. Unlike this, EBF or BF sketches do not require data deduplication prior to sketch generation, which makes their generation more efficient, but also more prone to privacy and security issues. Thus, it would be advantageous for the system to convert an EBF or BF sketch to a VoC sketch to gain the generation advantages of the EBF or BF sketch, while having the privacy and security advantages of the VoC sketch.
The system and method of this technical solution provide such improvements. After generating the EBF or BF sketch, the systems and methods described herein may generate a VoC sketch that represents the information included in the EBF or BF sketch. After the VoC sketch has been generated, the VoC sketch may be securely transmitted to other computing systems for further processing, such as for computing intersections, unions, or other set characteristics of data sets represented in a VoC-like format. The deduplication process required to generate a VoC sketch from the original data item is much more computationally intensive than first generating an EBF or BF sketch and converting it to a VoC representation. Thus, the system and method of this technical solution provides a significant improvement to data processing systems that generate sketches of extremely large data sets.
A simplified example of one algorithm for performing meta-estimation of the first EBF or BF sketch is included below in the pseudo-code of algorithm 1 below.
Inputting: object flow O, class S of sketch (e.g., S may be VoC, or any other type of probabilistic data structure (e.g., hyperLog (HLL) sketch, BF sketch, EBF sketch, ADBF sketch, LL sketch, etc.).
And (3) outputting: a sketch of type 'S' (e.g., a data structure including elements selected to probabilistically represent the input set, etc.).
the output sketch S may be used for further processing operations, for example for determining intersections (or unions) between other sketches having similar generation parameters (e.g. generated in the same way within the same identifier universe (univorse)). One way in which the sketch may be used is in algorithm 2, which may be used to estimate the Cardinality (Cardinality) of the set of identifiers (e.g., or input set, etc.) from all the raw data streams that generate the input sketch for algorithm 1 above. One embodiment of algorithm 2 is described below in the following pseudo code. In the pseudo code of algorithm 2, it should be understood that the "→" operation indicates a transition from one data type to another. For example, "Set1 → ABDF1 → VoC1" may be understood to mean that the data Set "Set 1" is used as input to algorithm 1 above to transform into an ABDF sketch "ABDF1", which is then transformed into a VoC sketch "VoC1".
Algorithm 2 in the form of pseudo-code
Inputting: a set of sketch Z created by algorithm 1 with the same settings (e.g., the same input sketch type as the above-described ABDF, but it is understood that any other sketch type may be used).
And (3) outputting: an estimate of the cardinality of the union of all the original flows of sketch Z (e.g., O for each ABDF, etc.) is generated.
Set1→ADBF1→VoC1
Set2→ADBF2→VoC2
estimate _ ion ([ VoC1, voC2 ]) = number of 1 in ABDF1| ABDF 2.
Cardinality (Set 1| Set 2) = ADBF. Estimate _ from _ ones (number of 1 in ADBF1| ADBF 2).
Therefore, the temperature of the molten metal is controlled,
Cardinality(Set1|Set2)＝ADBF.estimate_from_ones(VoC.estimate_union([VoC1,VoC2]))
in the above pseudo code, it should be understood that the "|" operator may correspond to a union operation. For example, in a context of a Set (context), the "|" operator may correspond to a Set union operation and return a Set containing elements in Set1, elements in Set2, and elements in both Set1 and Set 2. In the context of a sketch, such as an ADBF sketch, the "|" operator may correspond to the "or" operator, or more simply, a binary "or" operation across all corresponding register locations in ADBF1 and ADBF 2.
Before describing the system and method in detail, it may be helpful to consider the following pseudo-code, which may be similar to Python code. The following pseudo-code presents various algorithms for generating and controlling the data structures described herein (e.g., ADBF sketches, voC sketches, etc.).
The following pseudo code provides algorithms and functions for generating and controlling VoC sketches. Operations related to the VoC sketch may be included in a class, such as the VoCOPs class shown below.
As shown in the above pseudo code, the VoCOPs class may include functions that perform operations on VoC sketches (e.g., referred to as bit _ vector, bit _ vector1, bit _ vector2, etc.). For example, at least one function of initializing a VoC operation, at least one function of adding elements to a VoC sketch, at least one function of providing an estimated length of a VoC sketch, at least one function of returning a number of intersecting elements of an information set represented by two VoC sketches, and at least one function of returning an estimated number of elements in a union of data sets represented by two VoC sketches.
Further illustrating examples of various algorithms for performing the functions described herein, included below are algorithms and functions for generating and manipulating bloom filter data structures. Operations related to BF sketches may be included in a class, such as the BloomFilterOps class shown below.
class BloomFilterOps:
”'
Defines BloomFilter-type actions.
”'
def__init__(self,num_hash_funcs,hash_func＝default_hash_func):
”'
A bloom filter is created using a specified hash function and a specified bit vector size.
num _ hash _ funcs the number of hash functions to be used.
hash _ function (function) > integer) a hash function used to set a bit vector.
”'
self.hash_func＝hash_func
self.seeds＝[i for i in range(num_hash_funcs)]
def add(self,bit_vector,element):
”'
Elements are added to the bloom filter.
bit vector to be modified
element-an object to be consumed by a hash function.
”'
vector_size＝len(bit_vector)
for seed in self.seeds:
bit_vector[self.hash_func(element,seed)％vector_size]＝1
def contains(self,bit_vector,element):
”'
The membership of the element is checked. The false positive rate can be queried by calling false _ positive _ rate ().
”'
vector_size＝len(bit_vector)
for seed in self.seeds:
if not bit_vector[self.hash_func(element,seed)％vector_size]:
return False
return True
def expected_false_positive_rate(self,bit_vector,expected_n):
”'
Assuming a uniform hash function, the false positive rate of the bloom filter at a specified number of elements is queried. If no parameters are given, the estimated false positive rate of the bloom filter at the current capacity is checked.
”'
vector_size＝len(bit_vector)
Probability that # specific bit is not set to 1 by hash function
prob_bit_not_one＝1-1/vector_size
Probability that # specific bit is not set to 1 by all hash functions
prob_bit_not_one_all＝prob_bit_not_one**len(self.seeds)
Probability that # specific bit is not 1 after N elements
prob_bit_not_one_n＝prob_bit_not_one_all**expected_n
Probability of # specific bit being 1
prob_bit_one＝1-prob_bit_not_one_n
Probability of collision of # negative element with all 1 bits
return prob_bit_one**len(self.seeds)
def estimated_length(self,bit_vector):
return self.estimated_length_manual(np.sum(bit_vector),len(bit_vector))
def estimated_length_manual(self,num_ones,length):
m＝length
if num_ones＝＝m:
return math.inf
k＝len(self.seeds)
return-(m/k)*(math.log(1-num_ones/m))
def union(self,bit_vector1,bit_vector2):
"'size of bloom Filter union returning two-bit vector"'
bit_vector3＝np.logical_or(bit_vector1,bit_vector2)
return self.estimated_length(bit_vector3)
def intersection(self,bit_vector1,bit_vector2):
'size of bloom Filter intersection returning two bit vector "'
return(self.estimated_length(bit_vector1)+\
self.estimated_length(bit_vector2)-\
self.union(bit_vector1,bit_vector2))
As shown in the pseudo code above, the BloomFilterOps class may include functions that perform operations on BF drafts (e.g., referred to as bit _ vector, bit _ vector1, bit _ vector2, etc.). For example, at least one function that initializes a BF sketch operation, at least one function that adds elements to the BF sketch, at least one function that checks whether an element is in the BF sketch, at least one function that returns a false positive rate of BF sketch members, at least one function that returns an estimated length of the BF sketch, at least one function that returns a number of intersecting elements of an information set represented by two BF sketches, and at least one function that returns an estimated number of elements in a union of data sets represented by two BF sketches.
Further illustrating examples of various algorithms that perform the functions described herein, the following includes algorithms and functions for generating and operating the index bloom filter data structure. Operations related to EBF sketch may be included in a class, such as the expclomfilterops class shown below.
class ExpBloomFilterOps:
def__init__(self,decay_rate,hash_func＝default_hash_func):
self.hash_func＝hash_func
self.decay_rate＝decay_rate
self.seed＝0
self.seeds＝[0]
def estimated_length(self,vector):
return self.estimated_length_manual(sum(vector),len(vector))
@lru_cache()
def estimated_length_manual(self,num_ones,buckets):
a＝self.decay_rate
def_expected_num_bits(reach):
"" expected number of bits for radix activation "".
if reach<＝0:
return 0
return(1-(-special.expi(-a*reach/(np.exp(a)-1))+
special.expi(-a*np.exp(a)*reach/(np.exp(a)-1)))/a)
def_clip(x,lower_bound,upper_bound):
return max(min(x,upper_bound),lower_bound)
x＝num_ones
m＝buckets
p＝_clip(x/m,0,1)
result＝invert_monotonic(_expected_num_bits,epsilon＝1e-7)(p)*m
assert result > =0, "negative number estimation should never occur.
return result
@lru_cache()
def compute_register_probs(self,num_values):
"" calculate probability per register "" ".
probs＝np.exp(-self.decay_rate*(np.arange(num_values)+1)/
(num_values+1))
return np.cumsum(probs/np.sum(probs))
def union(self,bit_vector1,bit_vector2):
"'size of bloom Filter union returning two-bit vector"'
bit_vector3＝np.logical_or(bit_vector1,bit_vector2)
return self.estimated_length(bit_vector3)
def intersection(self,bit_vector1,bit_vector2):
'size of bloom Filter intersection returning two bit vector'
return(self.estimated_length(bit_vector1)+\
self.estimated_length(bit_vector2)-\
self.union(bit_vector1,bit_vector2))
def add(self,vector,element):
float_hash＝abs(int(self.hash_func(element,self.seed)))/2147483647
probs＝self.compute_register_probs(len(vector))
index＝bisect.bisect_left(probs,float_hash)-1
vector[index]＝1
As shown in the above pseudo code, the ExpBlomFilterOps class may include functions that perform operations on an EBF sketch (e.g., referred to as bit _ vector, bit _ vector1, bit _ vector2, etc.). For example, at least one function that initializes EBF sketch operations, at least one function that adds elements to the EBF sketch, at least one function that returns a fill probability for each register from a plurality of elements, at least one function that returns an estimated length of the EBF sketch, at least one function that returns the number of intersecting elements of the information sets represented by the two EBF sketches, and at least one function that returns an estimated number of elements in the union of the data sets represented by the two EBF sketches.
Although shown at a high level of generality with the above algorithms and pseudo code that may be or resemble python code, it should be understood that any of the computing devices described herein may perform any or any portion of the functions or operations described above. However, it should also be understood that the above pseudocode should not be viewed as limiting the scope of functions that the computing device described herein can perform.
Referring now to fig. 1, a block diagram of an example system 100 for meta-estimating a data structure representing an identifier is illustrated in accordance with one or more embodiments. System 100 may include at least one data processing system 105, at least one network 110, one or more client devices 120A-N (sometimes referred to as client devices 120), and at least one content provider 160. The data processing system 105 may include at least one data record maintainer 130, at least one data structure generator 135, at least one register identifier 140, at least one meta-estimator 145, at least one meta-estimate data manager 150, at least one union determiner 155, and at least one database 115. Database 115 may include one or more identifiers 170A-N (sometimes commonly referred to as identifiers 170) and one or more attributes 175A-N (sometimes commonly referred to as attributes 175). In some embodiments, database 115 is external to data processing system 105 and may be accessed by one or more of the computing devices described herein (e.g., data processing system 105, content provider 160, client device 120, computing system 400, etc.) via network 110.
Each of the components of system 100 (e.g., data processing system 105, network 110, client devices 120A-N, content provider 160, data record maintainer 130, data structure generator 135, register identifier 140, meta-estimator 145, meta-estimate data manager 150, union determiner 155, database 115, etc.) can be implemented using hardware components or software detailed herein in connection with diagram 400 in combination with hardware components of a computing system (e.g., computing system 400, data processing system 105, any other computing system described herein, etc.). Each of the components of the data processing system 105 may perform the functions detailed herein.
The data processing system 105 may include at least one processor and memory, such as processing circuitry. The memory may store processor-executable instructions that, when executed by the processor, cause the processor to perform one or more of the operations described herein. The processor may comprise a microprocessor, an Application Specific Integrated Circuit (ASIC), a Field Programmable Gate Array (FPGA), or the like, or a combination thereof. The memory may include, but is not limited to, electronic, optical, magnetic, or any other storage or transmission device capable of providing a processor with program instructions. The memory may further include a floppy disk, a CD-ROM, a DVD, a magnetic disk, a memory chip, an ASIC, an FPGA, a read-only memory (ROM), a Random Access Memory (RAM), an Electrically Erasable Programmable ROM (EEPROM), an Erasable Programmable ROM (EPROM), a flash memory, an optical medium, or any other suitable memory from which a processor can read instructions. The instructions may comprise code from any suitable computer-programming language. The data processing system 105 may include one or more computing devices or servers that may perform various functions as described herein. The data processing system 105 may include any or all of the components and perform any or all of the functions of the computer system 400 described herein in connection with fig. 4.
Each of the one or more client devices 120 may each include at least one processor and memory, e.g., processing circuitry. The memory may store processor-executable instructions that, when executed by the processor, cause the processor to perform one or more of the operations described herein. The processor may include a microprocessor, an Application Specific Integrated Circuit (ASIC), a Field Programmable Gate Array (FPGA), etc., or a combination thereof. The memory may include, but is not limited to, electronic, optical, magnetic, or any other storage or transmission device capable of providing a processor with program instructions. The memory may further include a floppy disk, a CD-ROM, a DVD, a magnetic disk, a memory chip, an ASIC, an FPGA, a read-only memory (ROM), a Random Access Memory (RAM), an Electrically Erasable Programmable ROM (EEPROM), an Erasable Programmable ROM (EPROM), a flash memory, an optical medium, or any other suitable memory from which a processor can read instructions. The instructions may include code from any suitable computer programming language. Client devices 120 may each include one or more computing devices or servers that may perform various functions as described herein. Client devices 120 may each include any or all of the components and perform any or all of the functions of computer system 400 described herein in connection with fig. 4.
Each of client devices 120 may be a computing device (e.g., computing device 400, etc.) configured to communicate via network 110 to transmit messages to data processing system 105 or content provider 160 or to receive messages from data processing system 105 or content provider 160. Client device 120 may be a desktop computer, laptop computer, tablet computer, smart phone, personal digital assistant, mobile device, consumer computing device, server, client, digital video recorder, television set-top box, video game console, or any other computing device configured to communicate via network 110, and so forth. Client device 120 may transmit one or more content requests to a content publisher, content provider 160, or data processing system 105. Client device 120 may receive online content from the device to which the request was transmitted, where the content is selected based on device information about client device 120 responsible for the request (e.g., device model, device type, device operating system version, device time, device date, any other contextual information described herein). Client device 120 may be associated with various attributes and identifiers that may be transmitted to content provider 160 or data processing system 105 in a request for content or other message. For example, the client device 120 may request an information resource from the content provider 160 or from the data processing system 105, may include a client device identifier and client device attributes in the request. Client device 120 may receive a response to the transmitted request (e.g., from the computing device to which the request was transmitted), which may include the content requested by client device 120.
Content provider 160 may include at least one processor and memory, such as processing circuitry. The memory may store processor-executable instructions that, when executed by the processor, cause the processor to perform one or more of the operations described herein. The processor may comprise a microprocessor, an Application Specific Integrated Circuit (ASIC), a Field Programmable Gate Array (FPGA), or the like, or a combination thereof. The memory may include, but is not limited to, electronic, optical, magnetic, or any other storage or transmission device capable of providing a processor with program instructions. The memory may further include a floppy disk, a CD-ROM, a DVD, a magnetic disk, a memory chip, an ASIC, an FPGA, a Read Only Memory (ROM), a Random Access Memory (RAM), an Electrically Erasable Programmable ROM (EEPROM), an Erasable Programmable ROM (EPROM), a flash memory, an optical medium, or any other suitable memory from which a processor may read instructions. The instructions may include code from any suitable computer programming language. Content provider 160 may include one or more computing devices or servers that may perform various functions as described herein. Content provider 160 may include any or all of the components and perform any or all of the functions of computer system 400 described herein in connection with fig. 4.
The content provider 160 may provide one or more information resources that may include content (e.g., text, images, audio, video, any combination thereof, etc.) or scripts for retrieving content. The content provider 160 may record which client devices access the online content item, including the time, identifier, and attributes of the client devices accessing the online content. Content provider 160 may provide content in response to one or more content requests from client devices. For example, the client device 120 may receive the information resource from the content provider 160, and the content provider may provide the information resource to the client device for display. The information resource may be a web page, video, image, or any other type of content described herein. The information resources provided by the content provider 160 may include one or more scripts that, when executed by the client device 120, cause the client device 120 to request additional content for insertion into the information resources. Thus, the content provider 160 may provide and record attributes and identifiers of the client device 120 in one-to-one correspondence with the client device 120 making the request. In some embodiments, the data processing system 105 may be a content provider 160 or perform the same functions as the content provider 160. In some embodiments, the content provider 160 may transmit client device identifiers and attributes extracted from content requests or from other messages to the data processing system 105.
Database 115 may be a database configured to store and/or maintain any of the information described herein. Database 115 may maintain one or more data structures that may contain, index, or otherwise store each of the values, complex numbers (pluralities), sets, variables, vectors, or thresholds described herein. The database 115 may be accessed using one or more memory addresses, index values, or identifiers of any items, structures, or regions maintained in the database 115. The database 115 may be accessed by components of the data processing system 105 or any other computing device described herein via the network 110. In some embodiments, the database 115 may be internal to the data processing system 105. In some embodiments, the database 115 may reside external to the data processing system 105 and may be accessed via the network 110. The database 115 may be distributed over many different computer systems or storage elements and may be accessed via the network 110 or a suitable computer bus interface. The data processing system 105 may store the results of any or all of the calculations, determinations, selections, identifications, generations, constructions, or computations in one or more data structures indexed or identified by appropriate values in one or more areas of memory of the data processing system 105, or in the database 115. Any or all of the values stored in database 115 may be accessed by any computing device described herein (e.g., data processing system 105) to perform any of the functionalities or functions described herein.
The database 115 may include one or more data records, which may be data structures containing indexed information. One example of an indexed data record is a client device identifier 170 (sometimes referred to as identifier 170), which may be received from client device 120 or from content provider 160. Identifier 170 may be stored in association with client device attributes 175 (sometimes commonly referred to as attributes 175). In some embodiments, the attributes may be indexed in one or more data structures in database 115 by corresponding identifiers 170. For example, the identifier 170 can point to or otherwise identify the attribute 175 received from the client device 120 to which the identifier 170 corresponds.
The identifiers 170 maintained in the database 115 may be stored in one or more data structures, such as a list or an indexed lookup table. Each of the identifiers 170 may be associated with one or more attributes 175 that describe aspects of the corresponding client device 120. Accordingly, each client device 120 can be associated with a respective identifier 170 and a respective one or more attributes 175. Attributes 175 may include attributes associated with respective client devices 120 and may be stored in one or more list or index data structures in database 115. Attributes 175 may include demographic information, such as age, gender, interests, and other demographic information, and may include various granularities of location information, including region information, coordinate information, or other types of location information, and may include device information, such as device type, device operating system version, device network speed, and any other device information described herein. Each of attributes 175 may be associated with at least one respective client device 120 and at least one respective identifier 170.
The data record maintainer 130 can maintain one or more data records that include one or more identifiers 170 or one or more attributes 175. The data record may be a data structure that stores information in computer memory and may include an identifier 170 or an attribute 175 (e.g., of the client device 120, etc.). The data record maintainer 130 can receive a message, such as a request for content, from the client device 120 and can extract an identifier 170 of the client device and attributes 175 of the client device from the message. The data record maintainer 130 can generate data records, such as data structures (e.g., in memory of the data processing system 105, etc.), to store the identifiers 170 and attributes 175 received from the client device 120. The data records may be stored in a database 115. Each of the data records stored by the data record maintainer 130 can be associated with a location, address, or pointer to a location in the database 115 at which the corresponding data record is located. Using the location of the data record, the data record maintainer 130 (e.g., or any other component of the data processing system 105) can access the data record, as well as the identifier 170 and the attributes 175 included therein. In some embodiments, the data record maintainer 130 stores the data records (e.g., as well as the identifier 170 and attributes 175, or any other data, etc.) in a memory of the data processing system 105.
The data structure generator 135 may generate a sketch data structure (e.g., a BF sketch, an EBF sketch, etc.) that represents one or more of the data records maintained by the data record maintainer 130. The sketch data structure may be a bloom filter data structure having a first number of registers initialized to zero. A bloom filter may be a register vector (sometimes referred to as a "bucket"), where each bucket is associated with a bucket identifier that corresponds to its position or index value in the bloom filter. In some embodiments, the bloom filter may be a string of bits, where each position in the string of bits is used as a register that may be set to zero or one. A bucket may have a value equal to zero or one. When initializing or generating a bloom filter, the data structure generator 135 may initialize the bloom filter bucket to an initialization value (e.g., zero, etc.). To add a data record to the bloom filter, the data structure generator may apply one or more hash functions (e.g., MD5, SHA-1, SHA-2, etc.) to the data record (e.g., the data structure including identifier 170 and attribute 175, etc.) to generate one or more hashed data records. The data structure generator 135 may extract pointers to one or more buckets of the bloom filter from the hashed data records and set the pointed buckets to set values (e.g., one or more) to a set value. The data structure generator 135 may repeat this process until all desired data records are included in the bloom filter. The data structure generator 135 may retrieve or otherwise access one or more parameters of the bloom filter when generating the sketch data structure. For example, the data structure generator 135 may receive parameters of the sketch to be generated, e.g., from an external computing device. The parameters may include the type of hash function used, the number of hash functions used, the number of buckets or locations in the bloom filter, or any other information needed to generate the bloom filter. The cardinality of the data set (e.g., data records, etc.) used to generate the bloom filter may be estimated by evaluating (e.g., by the data processing system or any component thereof, etc.) the following formula:
where k is the number of hashes used to generate the bloom filter, m is the number of bits (e.g., buckets) in the bloom filter, x is the number of padded (e.g., set) buckets in the bloom filter, and n is the estimated number of radix of the bloom filter.
In some embodiments, the data structure generator 135 may generate an Exponential Bloom Filter (EBF) as the sketch data structure. An Exponential Bloom Filter (EBF) may be similar to a bloom filter data structure, except that each bucket or bit of the exponential data structure may be assigned a different range of probability values. In some embodiments, an EBF may be a bit string, where each position in the bit string serves as a register (or bucket) that may be set to zero or one. When initializing or generating an EBF, the data structure generator 135 may initialize the bloom filter bucket to an initialization value (e.g., zero, etc.). For example, the probability assigned to each bucket of the EBF sketch may correspond to the value of an exponential distribution, as shown in the "computer _ register _ probs" pseudo-code function described above. By adjusting the decay rate of the exponential distribution of the EBF sketch, different probabilities (e.g., of bit filling (boosting) etc.) may be determined. To add the data record to the EBF, the data structure generator 135 may calculate a hash value of the data record (e.g., using a hash function on the data structure and its contents, etc.). The hash value may be converted to a number in the range [0,1] (e.g., by dividing by the range of the output of the hash function, etc.). Because each bucket in the EBF corresponds to a probability range in the field [0,1], the data structure generator 135 can identify within which probability range the converted hash value falls. The bucket associated with the corresponding range may then be set to a set value (e.g., 1). This process may be repeated until all desired data records are added to the EBF sketch. Each location (e.g., bucket, register, etc.) in the bloom filter sketch or EBF sketch may be identified by a corresponding index value.
The meta-estimator 145 may generate a second data structure, such as a VoC sketch, that represents index values for a subset of registers in the sketch generated by the data structure generator 135. The VoC sketch may include a counter register that may be set to an unset value (e.g., zero) and may be filled in by the meta-estimator 145 when filling the VoC sketch. To initialize the VoC sketch, the meta-estimator may generate a VoC sketch having a predetermined (e.g., retrieved from a setting or from another computing device, etc.) length (e.g., number of registers or buckets), where each register is initially set to an unset value (e.g., zero). To populate a VoC data structure, a meta-estimator may take an input value, such as an index value received from register identifier 140, and perform a hash function on the value to generate a hashed value. The meta-estimator 145 may then perform a modulo operation on the hashed values and the number of registers in the VoC sketch. The result of the modulo operation may have a value equal to the index value of one register in the VoC sketch. The meta-estimator may add a register associated with an index value equal to the modulo operation to fill the VoC sketch with the input values. The meta-estimator may repeat this process for each index value received from register identifier 140, thereby generating a populated second data structure representing the registers in the bloom filter or exponential bloom filter sketch that were set to the set values.
The metadata estimation data manager 150 may store a second data structure (e.g., a VoC sketch) in the memory of the data processing system 105 that represents a subset of the registers of the bloom filter or the exponential bloom filter. In some embodiments, the meta-estimation data manager 150 may store values in the database 115 in association with identifiers of the VoC sketch. In some embodiments, the identifier of the VoC sketch may correspond to a set of data records (e.g., identifier 170 and attributes 175) that are added to the initial bloom filter (or index bloom filter) sketch. In some embodiments, the meta-estimation data manager 150 may transmit the VoC sketch to another computing device, such as the content provider 160 requesting the sketch, or to an external computing device that may aggregate the sketch in a multi-party computing (MPC) protocol. In some embodiments, the meta-estimation data manager 150 may receive a request for a VoC sketch representing meta-estimates of a sketch generated from identifiers and attributes.
The request may identify events or attributes, or other parameters, that should include the identifier 170 or attributes 175 in the initial sketch. The meta-estimation data manager 150 can identify the data records (e.g., identifiers 170 or attributes) that should be included in the initial sketch by scanning the database 115 for matching attributes 175. If a matching attribute is identified, the meta-estimation data manager 150 may provide an identifier 170 associated with the matching attribute to the data structure generator 135 for inclusion in an initial (e.g., bloom filter, exponential bloom filter, etc.) sketch. In some embodiments, the data record used to generate the initial sketch does not include any attributes 175, but rather identifiers 170 corresponding to attributes that match the requirements in the meta-estimate sketch request. After generating the VoC sketch, the metadata estimation data manager 150 may transmit the sketch to the computing device responsible for the request.
To calculate a union value for two VoC sketches (e.g., a cardinality of the union of the sets of index values used to generate the two VoC sketches, etc.), union determiner 155 may use the same parameters to retrieve two VoC sketches generated from the same universe of data records (e.g., but may contain different data records). To calculate the union value, union determiner 155 may first determine an intersection value of the two VoC sketches (e.g., the cardinality of the intersection of the sets of index values used to generate the two VoC sketches, etc.). To determine the intersection values, the union determiner 155 may determine an average register value (e.g., an average of register values) in the first VoC sketch and an average register value of the second VoC sketch. The average register value of the first VoC sketch may be subtracted from each register value in the first VoC sketch to generate a first normalized VoC sketch, and the average register value of the second VoC sketch may be subtracted from each register value in the second VoC sketch to generate a second normalized VoC sketch. Next, a dot product may be made between the first normalized VoC sketch and the second normalized VoC sketch by: each corresponding register in the two normalized sketch is multiplied and summed to compute the sum of the resulting products. In some implementations, the union determiner 155 can multiply the resulting sum by an adjustment value equal to the number of locations in the first vector divided by the number of locations in the first vector minus one. In some embodiments, no adjustment value is used. The summed value, or the summed value multiplied by the adjustment value (if used), may be the intersection value of the two VoC sketches.
The union determiner 155 may then use the intersection values to determine the cardinality of the union of the index values that have been used to generate the two sketch (e.g., the number of unique index values that contribute to the two VoC sketch, etc.). To this end, the union determiner 155 may estimate the number of index values used to generate the first sketch by summing the register values of the VoC sketch. The union determiner 155 may estimate the number of index values used to generate the second sketch in the same manner. To calculate the union value, the union determiner 155 may simply add the estimated number of index values of the first VoC sketch to the estimated number of index values of the second VoC sketch and subtract the intersection value. The resulting value is a union value that represents the number of unique index values in the two VoC drafts (or set registers in the initial sketch).
The bloom filter and the exponent bloom filter may be combined using an OR operation (e.g., all corresponding registers are ored together, etc.). Thus, the resulting union value of the two VoC sketches is an estimate of the total number of settings used to generate the initial draft combination of the two VoC sketches. Since the estimation of the cardinality of the data records used to generate the initial sketch depends only on the number of set values, the cardinality of the data records used to generate the initial sketch may be calculated by evaluating the following formula:
where k is the number of hashes used to generate the bloom filter, m is the number of bits (e.g., buckets) in the bloom filter, x is the union value of the two VoC drafts, and n is the estimated number of bases of the bloom filter.
Referring now briefly to FIG. 2, a block diagram 200 of an example data flow for meta-estimating a data structure representing a large data set is depicted. In the figure, an input data set 205 may be converted into a first data structure 210, which may set registers to unset setting values. In this figure, "1" is a set value and "0" is an unset value. The index value of the set register may be used in the meta estimation 215 process described above (e.g., by the meta estimator 145, etc.). The output of the meta-estimation 215 process may be a second data structure (e.g., a VoC sketch, etc.). The second data structure may consist of a counter register that may be incremented as described above.
Referring now to FIG. 3, an illustrative flow diagram of a method 300 for meta-estimating a data structure representing an identifier is depicted. The method 300 may be performed, carried out, or otherwise implemented by the data processing system 105, the computer system 400 described herein in conjunction with fig. 4, or any other computing device described herein. Briefly, a data processing system (e.g., data processing system 105, any other computing device described herein, etc.) may maintain a data record (step 302); generating a first data structure (step 304); selecting a kth register of the first data structure (step 306); determining whether the register is equal to a predetermined value (step 308); generating a second data structure (step 310); determining if counter register k is equal to the number of registers n in the first data structure (step 312); incrementing counter register k (step 314); storing a second data structure (step 316); and determining a union value (step 318).
In more detail, the data processing system may maintain a data record (step 302). The data processing system may maintain one or more data records that include one or more identifiers (e.g., identifier 170, etc.) or one or more attributes (e.g., attribute 175, etc.). The data record may be a data structure that stores information in computer memory and may include an identifier or attribute of a client device (e.g., client device 120, etc.). The data processing system may receive a message, such as a content request, from a client device and may extract an identifier of the client device or an attribute of the client device from the message. The data processing system may generate a data record, such as a data structure (e.g., in a memory of the data processing system, etc.), to store the identifier or attribute received from the client device. The data records may be stored in a database (e.g., database 115). Each of the data records stored by the data processing system may be associated with a location, address, or pointer to a location in a database or memory where the corresponding data record resides. Using the location of the data record, the data processing system may access the data record and the identifier or attribute included therein. In some embodiments, the data processing system stores the data records in a memory of the data processing system 105.
The data processing system may generate a first data structure (step 304). The data processing system can generate a sketch data structure (e.g., a BF sketch, an EBF sketch, etc.) that represents one or more of the data records maintained by the data processing system as a first data structure. The sketch data structure may be a bloom filter data structure having a first number of registers initialized to zero. A bloom filter may be a vector of registers (sometimes referred to as "buckets"), where each bucket is associated with a bucket identifier that corresponds to its position or index value in the bloom filter. In some embodiments, the bloom filter may be a string of bits, where each position in the string of bits is used as a register that may be set to zero or one. A bucket may have a value equal to zero or one. When initializing or generating a bloom filter, the data processing system may initialize the bloom filter bucket to an initialization value (e.g., zero, etc.). To add a data record to a bloom filter, the data processing system may apply one or more hash functions (e.g., MD5, SHA-1, SHA-2, etc.) to the data record to generate one or more hashed data records. The data processing system may extract from each hashed data record pointers to one or more buckets of the bloom filter and set the pointed to buckets to a set value (e.g., one-class). The data processing system may repeat this process until all desired data records have been hashed and represented in the bloom filter. The data processing system may retrieve or otherwise access one or more parameters of the bloom filter when generating the sketch data structure. For example, the data processing system may receive parameters of a sketch to be generated, e.g., from an external computing device. The parameters may include the type of hash function used, the number of hash functions used, the number of buckets or locations in the bloom filter, or any other information needed to generate the bloom filter. The cardinality of the data set (e.g., data records, etc.) used to generate the bloom filter may be estimated by evaluating (e.g., by the data processing system or any component thereof) the following formula:
where k is the number of hashes used to generate the bloom filter, m is the number of bits (e.g., buckets) in the bloom filter, x is the number of padding (e.g., set) buckets in the bloom filter, and n is the estimated number of bases of the bloom filter.
In some embodiments, the data processing system may generate an Exponential Bloom Filter (EBF) as the sketch data structure. An Exponent Bloom Filter (EBF) may be similar to a bloom filter data structure except that each bucket or bit of the exponent data structure may be assigned a different range of probability values. In some embodiments, an EBF may be a bit string, where each position in the bit string serves as a register (or bucket) that may be set to zero or one. When initializing or generating an EBF, the data processing system may initialize the bloom filter bucket to an initialization value (e.g., zero, etc.). For example, the probability assigned to each bucket of the EBF sketch may correspond to the value of an exponential distribution, as shown in the "computer _ register _ probs" pseudo-code function described above. By adjusting the decay rate of the exponential distribution of the EBF sketch, different probabilities (e.g., of bit-stuffing, etc.) may be determined. To add a data record to the EBF, the data processing system may calculate a hash value for the data record (e.g., using a hash function on the data structure and its contents, etc.). The hash value may be converted to a number in the range 0,1 (e.g., by dividing by the range of the output of the hash function, etc.). Because each bucket in the EBF corresponds to a probability range in the field 0,1, the data processing system can identify within which probability range the converted hash value falls. The bucket associated with the corresponding range may then be set to a set value (e.g., 1). This process may be repeated until all desired data records are added to the EBF sketch. Each location (e.g., bucket, register, etc.) in the bloom filter sketch or EBF sketch may be identified by a corresponding index value.
The data processing system may select the kth register of the first data structure (step 306). To populate the second data structure with index values of registers of the first data structure set to set values, the data processing system may iteratively loop through each register of the first data structure based on the counter register k. Each register of the first data structure may be stored and indexed in the data structure by an index value (e.g., index 0, index 1, index 2, etc.). To populate the second data structure, the data processing system may select a register of the first data structure that is stored in association with an index value equal to the counter register k. If it is the first iteration of the loop, the counter register k may be initialized to an initialization value (e.g., k = 0) before the kth register is selected. Accessing the registers of the first data structure may include copying data associated with selected registers of the first data structure to a different region of computer memory, e.g., a working region of memory in a data processing system.
The data processing system may determine whether the register is equal to a predetermined value (step 308). To do so, the data processing system may compare the value of the selected register to a set value (e.g., 1, etc.) to determine whether the index value of the register should be added to the second data structure. If the value of the register is equal to the set value, the data processing system may execute (step 310). If the value of the register is not equal to the set value, the data processing system may execute (step 312).
The data processing system may generate a second data structure (step 310). The data processing system may generate a second data structure, such as a VoC sketch, that represents index values for a subset of the set registers in the first data structure. The VoC sketch may include a counter register that may be initialized to an unset value (e.g., zero) and may be incremented by the data processing system when the VoC sketch is populated. To initialize a VoC sketch, the data processing system may generate a VoC sketch having a predetermined (e.g., retrieved from a setting or from another computing device, etc.) length (e.g., number of registers or buckets), where each register is initially set to an unset value (e.g., zero). To populate a VoC data structure, the data processing system may take an input value, such as an index value of a selected register, and perform a hash function on the selected index value to generate a hash value. The data processing system may then perform a modulo operation on the hash value and the number of registers in the VoC sketch. The result of the modulo operation may have a value equal to the index value of one register in the VoC sketch. The data processing system may add a register associated with an index value equal to the modulo operation to populate the VoC sketch with the selected index value.
The data processing system may determine whether counter register k is equal to the number of registers n in the first data structure (step 312). To determine whether all index values in the first data structure have been considered by the data processing system, the data processing system may compare the counter register used to select each register in the first data structure to the total number of registers n in the first data structure. If the counter register k is not equal to (e.g., less than) the total number of registers n in the first data structure, then the data processing system can execute (step 314). If the counter register k is equal to (e.g., equal to or greater than) the total number of registers n in the first data structure, the data processing system may execute (step 316).
The data processing system may increment counter register k (step 314). To consider each register in the first data structure for addition to the second data structure, the data processing system may add an add-to-counter register k to indicate the number of registers in the first data structure that have been considered for addition to the second data structure. In some embodiments, the data processing system may set the counter register k to the memory address value of the next location in memory of the next register in the first data structure (e.g., a location in computer memory). If this is the first iteration of this loop, the data processing system may initialize the counter register k to an initial value, e.g., zero, before incrementing the counter register. After incrementing the value of counter register k, the data processing system may execute (step 306).
The data processing system may store a second data structure (step 316). The data processing system may store a second data structure (e.g., a VoC sketch) in a memory of the data processing system, the second data structure representing a selected subset of registers of the first data structure (e.g., a bloom filter or an exponential bloom filter, etc.). In some embodiments, the data processing system may store the value in a database (e.g., database 115, etc.) in association with an identifier of the second data structure (e.g., a VoC sketch, etc.). In some embodiments, the identifier of the second data structure may correspond to the set of data records (e.g., identifier 170 or attribute 175) added to the first data structure. In some embodiments, the data processing system may transmit the second data structure to another computing device, such as a content provider requesting the second data structure (e.g., content provider 160, etc.), or an external computing device that may aggregate sketches in a multi-party computing (MPC) protocol. In some embodiments, a data processing system may receive a request for a VoC sketch representing meta-estimates of the sketch generated from identifiers associated with particular attributes.
The data processing system may determine a union value (step 318). To compute a union value for two VoC sketches (e.g., a cardinality of the union of the sets of index values used to generate the two VoC sketches, etc.), the data processing system may use the same parameters to retrieve two VoC sketches generated from the same universe of data records (e.g., but may contain different data records). To compute the union value, the data processing system may first determine the intersection value of the two VoC sketches (e.g., the cardinality of the intersection of the sets of index values that have been used to generate the two VoC sketches, etc.). To determine the intersection values, the data processing system may determine an average register value (e.g., an average of register values) in the first VoC sketch and an average register value of the second VoC sketch. The average register value of the first VoC sketch may be subtracted from each register value in the first VoC sketch to generate a first normalized VoC sketch, and the average register value of the second VoC sketch may be subtracted from each register value in the second VoC sketch to generate a second normalized VoC sketch. Next, a dot product may be made between the first normalized VoC sketch and the second normalized VoC sketch by: each corresponding register in the two normalized sketch is multiplied and summed to compute the sum of the resulting products. In some embodiments, the data processing system may multiply the resulting sum by an adjustment value equal to the number of locations in the first vector divided by the number of locations in the first vector minus one. In some embodiments, no adjustment value is used. The summed value, or the summed value multiplied by the adjustment value (if used), may be the intersection value of the two VoC sketches.
The data processing system may then use the intersection value to determine a cardinality of the union of the index values used to generate the two sketch (e.g., the number of unique index values that contribute to the two VoC sketch, etc.). To this end, the data processing system may estimate the number of index values used to generate the first sketch by summing the register values of the VoC sketch. The data processing system may estimate the number of index values used to generate the second sketch in the same manner. To calculate the union value, the data processing system may simply add the estimated number of index values of the first VoC sketch to the estimated number of index values of the second VoC sketch and subtract the intersection value. The resulting value is a union value that represents the number of unique index values in the two VoC sketches (or set registers in the initial sketch).
Fig. 4 shows the general architecture of an illustrative computer system 400 that may be used to implement any of the computer systems discussed herein, in accordance with some embodiments. Computer system 400 may be used to provide information for display via network 110. The computer system 400 of fig. 4 includes one or more processors 420 communicatively coupled to a memory 425, one or more communication interfaces 405, and one or more output devices 410 (e.g., one or more display units) and one or more input devices 415. Processor 420 may be included in any of the computing devices described herein.
In computer system 400 of fig. 4, memory 425 may include any computer-readable storage medium and may store computer instructions, such as processor-executable instructions for implementing the various functions described herein for the respective system, as well as any data related thereto, generated thereby, or received via a communication interface or input device (if present). Referring again to the system 400 of fig. 4, the computer system 400 may include a memory 425 to store any of the information, variables, vectors, data structures, or other computer readable information described herein, and the like. The processor 420 shown in fig. 4 may be used to execute instructions stored in the memory 425 and, in so doing, may also read from or write to memory various information generated and/or processed in accordance with the execution of the instructions.
The processor 420 of the computer system 400 shown in fig. 4 may also be communicatively coupled to or control the communication interface 405 to transmit or receive various information according to the instructions of the instructions. For example, communication interface 405 may be coupled to a wired or wireless network, bus, or other communication device, and thus may allow computer system 400 to transmit information to other devices (e.g., other computer systems) or receive information from other devices. Although not explicitly shown in the system of fig. 4, one or more communication interfaces facilitate the flow of information between components of the system 400. In some embodiments, the communication interface may be configured to provide a website (e.g., via various hardware or software components) as an access portal to at least some aspects of computer system 400. Examples of communication interface 405 include a user interface (e.g., a web page) through which a user can communicate with computer system 400.
An output device 410 of the computer system 400 shown in fig. 4, for example, may be provided to allow various information to be viewed or otherwise perceived in connection with execution of the instructions. An input device 415 may be provided, for example, to allow a user to make manual adjustments, make selections, enter data, or interact with the processor in any of a variety of ways during execution of instructions. Additional information related to general computer system architectures that may be used for the various systems discussed herein is further provided herein.
Various experimental results related to meta-estimation of bloom filters and exponential bloom filters using count vectors are described below. It should be understood that this is merely example data and should be construed as limiting any aspect of the systems and methods described herein.
Referring now to fig. 5, depicted is a graph showing example experimental data including errors and deviations as the bloom filter size increases. The parameters and functions used to generate the graph in fig. 5 are presented below in the following pseudo code, which may be similar to Python code.
As shown in fig. 5, as the size (number of registers) of the bloom filter increases, the meta-estimation generally performs better than other techniques for bloom filter to VoC conversion in terms of error and bias.
Referring now to fig. 6, a graph is depicted showing example experimental data including errors and deviations as the VoC sketch size increases. The parameters and functions used to generate the graph in fig. 6 are presented below in the following pseudo-code, which may be similar to Python code
As shown in fig. 6, as the size (number of registers) of the VoC sketch increases, meta-estimation generally performs better than other techniques for bloom filter to VoC conversion in terms of error and bias.
Referring now to fig. 7, a graph is depicted showing example experimental data including errors and deviations as the bloom filter size increases for an exponential bloom filter embodiment.
As shown in fig. 7, as the size (number of registers) of the bloom filter sketch increases, the meta-estimation of the exponential bloom filter is competitive in terms of error and bias compared to other techniques for exponential bloom filter to VoC conversion. However, meta-estimation is computationally more efficient than other implementations, such that the difference in relative error is negligible for large data sets.
Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware embodied in tangible media, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, e.g., one or more components of computer program instructions encoded on a computer storage medium for execution by, or to control the operation of, data processing apparatus. The program instructions may be encoded on an artificially generated propagated signal, such as a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by data processing apparatus. The computer storage medium may be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more thereof. In addition, although a computer storage medium is not a propagated signal, a computer storage medium may comprise a source or destination of computer program instructions encoded in an artificially-generated propagated signal. The computer storage medium may also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
The features disclosed herein may be implemented on a smart television module (or connected television module, hybrid television module, etc.) that may include a processing module configured to integrate an internet connection with a more traditional television program source (e.g., via cable, satellite, wireless, or other signal reception). The smart television module may be physically incorporated into a television or may comprise a separate device such as a set-top box, a blu-ray or other digital media player, a game console, a hotel television system, and other companion devices. The smart television module may be configured to allow viewers to search for and locate videos, movies, photos, and other content on a network, local cable TV channel, satellite TV channel, or stored on a local hard drive. A set-top box (STB) or set-top unit (STU) may include an information appliance device that may contain a tuner and connect to a television and an external signal source to convert the signal into content that is then displayed on a television screen or other display device. The smart television module may be configured to provide a home screen or top-level screen including icons for a plurality of different applications, such as a web browser and a plurality of streaming media services, connected cable or satellite media sources, other network "channels," and so forth. The smart television module may be further configured to provide an electronic program guide to the user. The companion application of the smart television module may operate on the mobile computing device to provide additional information to the user about available programming, to allow the user to control the smart television module, and so on. In alternative embodiments, the features may be implemented on a laptop or other personal computer, smart phone, other mobile phone, handheld computer, tablet PC, or other computing device.
The operations described in this specification may be implemented as operations performed by data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
The terms "data processing apparatus," "data processing system," "client device," "computing platform," "computing device," or "apparatus" encompass all kinds of apparatus, devices, and machines for processing data, including for example, a programmable processor, a computer, a system-on-a-chip, or a plurality of systems-on-a-chip, or a combination of the foregoing. An apparatus may comprise special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). In addition to hardware, an apparatus may include code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform execution environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment may implement a variety of different computing model infrastructures, such as web services, distributed computing infrastructures, and grid computing infrastructures.
A computer program (also known as a program, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document) in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. Elements of a computer include a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Also, for example, a computer may be embedded in another device, e.g., a mobile telephone, a Personal Digital Assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a Universal Serial Bus (USB) flash drive). Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, such as internal hard disks or removable disks; a magneto-optical disk; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube), plasma, or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices may also be used to provide for interaction with a user; for example, feedback provided to the user can include any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input generated from the user can be received in any form, including acoustic, speech, or tactile input. In addition, by sending and receiving documents to and from a device used by a user; for example, a computer may interact with a user by sending web pages to a web browser on the user's client device in response to requests received from the web browser.
Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an embodiment of the subject matter described is this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network ("LAN") and a wide area network ("WAN"), the internet (e.g., the internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
A computing system, such as data processing system 105, may include clients and servers. For example, the data processing system 105 may include one or more servers in one or more data centers or server farms. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, the server transmits data (e.g., HTML pages) to the client device (e.g., for the purpose of displaying data to and receiving input from a user interacting with the client device). Data generated at the client device (e.g., due to interactions, calculations, or any other event or calculation) may be received from the client device at the server, and vice versa.
While this specification contains many specific implementation details, these should not be construed as limiting the scope of any invention or what may be claimed, but rather as descriptions of features specific to particular implementations of the systems and methods described herein. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results.
In some cases, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products. For example, the data processing system 105 may be a single module, a logical device with one or more processing modules, one or more servers, or a portion of a search engine.
Having now described some illustrative embodiments, it is apparent that the foregoing is illustrative and not limiting, having been presented by way of example. In particular, although many of the examples presented herein involve specific combinations of method acts or system elements, these acts and these elements may be combined in other ways to accomplish the same objectives. Acts, elements and features discussed only in connection with one embodiment are not intended to be excluded from a similar role in other embodiments or implementations.
The phraseology and terminology used herein is for the purpose of description and should not be regarded as limiting. The use of "including," "comprising," "having," "containing," "involving," "characterized by … …," "characterized by," and variations thereof herein, is meant to encompass the items listed thereafter, equivalents thereof, and additional items, as well as alternative embodiments consisting of the items specifically listed thereafter. In one embodiment, the systems and methods described herein consist of one described element, act, or component, each combination of more than one described element, act, or component, or all described elements, acts, or components.
Any reference to an embodiment or element or act of the systems and methods referred to herein in the singular may also encompass embodiments comprising a plurality of these elements, and any plural reference to any embodiment or element or act herein may also encompass embodiments comprising only a single element. References in the singular or plural form are not intended to limit the presently disclosed systems or methods, their components, acts or elements to the singular or plural configuration. References to any action or element based on any information, action, or element may include embodiments in which the action or element is based, at least in part, on any information, action, or element.
Any embodiment disclosed herein may be combined with any other embodiment, and references to "an embodiment," "some embodiments," "an alternative embodiment," "various embodiments," "one embodiment," etc., are not necessarily mutually exclusive and are intended to indicate that a particular feature, structure, or characteristic described in connection with the embodiment may be included in at least one embodiment. These terms, as used herein, do not necessarily all refer to the same implementation. Any embodiment may be combined with any other embodiment, inclusively or exclusively, in any manner consistent with aspects and embodiments disclosed herein.
References to "or" may be construed as inclusive, such that any term described using "or" may refer to any single, more than one, or all of the described terms.
Where technical features in the drawings, detailed description or any claim are followed by reference signs, the reference signs have been included for the sole purpose of increasing the intelligibility of the drawings, detailed description, and claims. Neither the reference numerals nor their absence therefore have any limiting effect on the scope of any claim element.
The systems and methods described herein may be embodied in other specific forms without departing from the characteristics thereof. While the examples provided may be useful for meta-estimation of data structures representing identifiers, the systems and methods described herein may be applied to other environments. The foregoing embodiments are illustrative, and not limiting, of the described systems and methods. The scope of the systems and methods described herein is, therefore, indicated by the appended claims rather than by the foregoing description, and all changes that come within the meaning and range of equivalency of the claims are intended to be embraced therein.
Claims (27)
1. A system, comprising:
one or more processors; and
one or more memory devices storing computer-readable instructions that, when executed, cause the one or more processors to perform operations comprising:
retrieving one or more generation parameters corresponding to a first initial sketch comprising a plurality of first initial sketch registers, wherein a subset of the plurality of first initial sketch registers are populated according to the one or more generation parameters and based at least in part on hashes of a plurality of data records;
retrieving a first unary estimated sketch comprising a plurality of first unary estimated sketch registers populated based at least in part on a hash of an index value of each of the subset of the plurality of first initial sketch registers; and
using the one or more generation parameters, one or more aggregate attributes are determined using the first and second meta-estimation sketches.
2. The system of claim 1, wherein the second binary estimate sketch comprises a plurality of second binary estimate sketch registers populated based at least in part on a hash of an index value of each of a subset of a plurality of second initial sketch registers of a second initial sketch.
3. The system of claim 2, wherein the one or more aggregate attributes comprise a cardinality estimate of a union of the first initial sketch and the second initial sketch.
4. The system of any one of the preceding claims, wherein determining the one or more aggregate attributes comprises: determining an intersection of the first and second unary sketch estimates.
5. The system of any one of the preceding claims, wherein determining the one or more aggregate attributes comprises: determining a union of the first and second meta-estimation sketches.
6. The system of any one of the preceding claims, wherein the first initial sketch is a bloom filter sketch.
7. The system of any one of the preceding claims, wherein the first initial sketch is an exponential bloom filter sketch.
8. The system of any of the preceding claims, wherein the plurality of data records correspond to a plurality of identifiers associated with one or more attributes.
9. The system of any one of the preceding claims, wherein the operations further comprise:
generating the first unary estimate sketch by: for a respective one of the index values of each of the subset of the plurality of first initial sketch registers,
determining a respective first unary estimated sketch index based on hashing the respective index value; and
incrementing a respective one of the plurality of first member estimate sketch registers associated with the respective first member estimate sketch index.
10. A system, comprising:
one or more processors; and
one or more memory devices storing computer-readable instructions that, when executed, cause the one or more processors to perform operations comprising:
generating a first initial sketch comprising a plurality of first initial sketch registers, wherein a subset of the plurality of first initial sketch registers are populated according to one or more generation parameters and based at least in part on hashes of a plurality of data records; and
generating a first unary estimated sketch comprising a plurality of first unary estimated sketch registers populated based at least in part on a hash of an index value of each of the subset of the plurality of first initial sketch registers.
11. The system of claim 10, wherein the first initial sketch is a bloom filter sketch.
12. The system of any of claims 10 to 11, wherein the plurality of data records correspond to a plurality of identifiers associated with one or more attributes.
13. The system of any of claims 10 to 12, wherein the operations further comprise:
generating the first unary estimate sketch by: for a respective one of the index values of each of the subset of the plurality of first initial sketch registers,
determining a respective first unary estimated sketch index based on hashing the respective index value; and
incrementing a respective one of the plurality of first member estimate sketch registers associated with the respective first member estimate sketch index.
14. The system of any of claims 10 to 13, wherein the operations further comprise:
receiving a meta-estimation sketch request from a computing device; and
transmitting the first meta-estimation sketch to the computing device in response to the meta-estimation sketch request.
15. The system of claim 14, wherein the meta-estimation sketch request identifies at least one parameter of the identifier or the attribute to be represented in the first initial sketch.
16. The system of any of claims 14 and 15, wherein the meta-estimation sketch request contains the one or more generation parameters of the first initial sketch.
17. The system of any of claims 10 to 16, wherein the one or more generation parameters include at least one parameter selected from a type of hash function used, a number of hash functions used, and a number of registers.
18. A method, comprising:
maintaining, by a data processing system comprising one or more processors and memory, a plurality of data records comprising a plurality of identifiers and one or more attributes;
generating, by the data processing system, a first data structure representing the plurality of data records, the first data structure having a plurality of first registers, wherein at least one first register of the plurality of first registers is populated based on a hash of each of the plurality of identifiers;
identifying, by the data processing system, a subset of the plurality of first registers equal to a predetermined value, each of the subset of the plurality of first registers being identified by an index value;
generating, by the data processing system, a second data structure representing the subset of the plurality of first registers, the second data structure having a plurality of second registers, wherein at least one second register of the plurality of second registers is populated based on a hash of an index value of each of the subset of the plurality of first registers;
storing, by the data processing system, the second data structure in the memory, the second data structure representing the subset of the plurality of first registers.
19. The method of claim 18, further comprising:
retrieving, by the data processing system, a third data structure having a plurality of third registers, each of the plurality of third registers corresponding to a respective one of the plurality of second registers of the second data structure; and
determining, by the data processing system, an intersection value of the information represented by the second data structure and the information represented by the third data structure using the second data structure and the third data structure.
20. The method of claim 19, further comprising: determining, by the data processing system, a union value of the information represented by the second data structure and the information represented by the third data structure using the intersection value.
21. The method of any of claims 18 to 20, wherein the first data structure is a bloom filter sketch.
22. The method of any of claims 18 to 21, wherein the first data structure is an exponential bloom filter sketch.
23. The method of any of claims 18 to 22, further comprising:
generating, by the data processing system, the second data structure by: for a respective index value of each of the subset of the plurality of first registers,
determining, by the data processing system, a respective second data structure index based on hashing the respective index value; and
incrementing, by the data processing system, a respective one of the plurality of second registers associated with the respective second data structure index.
24. The method of any of claims 18 to 23, further comprising:
receiving, by the data processing system, a meta-estimation sketch request from a computing device; and
transmitting, by the data processing system, the second data structure to the computing device in response to the meta-estimation sketch request.
25. The method of claim 24, wherein the meta-estimation sketch request identifies at least one parameter of the identifier or the attribute to be represented in the first data structure.
26. The method of any of claims 24 and 25, wherein the meta-estimation sketch request contains one or more generation parameters of the first data structure.
27. The method of claim 26, wherein the one or more generation parameters include at least one parameter selected from a type of hash function used, a number of hash functions used, and a number of registers.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202063087791P | 2020-10-05 | 2020-10-05 | |
US63/087,791 | 2020-10-05 | ||
PCT/US2021/053467 WO2022076342A1 (en) | 2020-10-05 | 2021-10-05 | Meta-estimation of bloom filters with vectors of counts |
Publications (1)
Publication Number | Publication Date |
---|---|
CN115461745A true CN115461745A (en) | 2022-12-09 |
Family
ID=78483513
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202180030781.7A Pending CN115461745A (en) | 2020-10-05 | 2021-10-05 | Meta-estimation of bloom filters with count vectors |
Country Status (6)
Country | Link |
---|---|
US (1) | US20230153454A1 (en) |
EP (1) | EP4111346A1 (en) |
JP (1) | JP7479501B2 (en) |
KR (1) | KR20220162751A (en) |
CN (1) | CN115461745A (en) |
WO (1) | WO2022076342A1 (en) |
Family Cites Families (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20200257684A1 (en) | 2019-02-07 | 2020-08-13 | Red Hat, Inc. | Higher-order data sketching for ad-hoc query estimation |
-
2021
- 2021-10-05 JP JP2022557940A patent/JP7479501B2/en active Active
- 2021-10-05 US US17/917,083 patent/US20230153454A1/en active Pending
- 2021-10-05 CN CN202180030781.7A patent/CN115461745A/en active Pending
- 2021-10-05 EP EP21801728.3A patent/EP4111346A1/en active Pending
- 2021-10-05 KR KR1020227037818A patent/KR20220162751A/en unknown
- 2021-10-05 WO PCT/US2021/053467 patent/WO2022076342A1/en unknown
Also Published As
Publication number | Publication date |
---|---|
EP4111346A1 (en) | 2023-01-04 |
KR20220162751A (en) | 2022-12-08 |
WO2022076342A1 (en) | 2022-04-14 |
JP2023524373A (en) | 2023-06-12 |
US20230153454A1 (en) | 2023-05-18 |
JP7479501B2 (en) | 2024-05-08 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11451370B2 (en) | Secure probabilistic analytics using an encrypted analytics matrix | |
US11790116B2 (en) | Systems and methods for privacy preserving determination of intersections of sets of user identifiers | |
JP2023021113A (en) | Content provider recommendations to improve targetting and other settings | |
WO2021262868A1 (en) | Differentially private frequency deduplication | |
US10943259B1 (en) | Expansion of high performing placement criteria | |
US20220091873A1 (en) | Systems and methods for cross media reporting by fast merging of data sources | |
CN115461745A (en) | Meta-estimation of bloom filters with count vectors | |
KR102324802B1 (en) | Systems and methods for encryption of content request data | |
US20230259837A1 (en) | Content provider recommendations to improve targetting and other settings | |
CN113692585A (en) | System and method for generating and selecting local content to improve security and utilization of network resources |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |