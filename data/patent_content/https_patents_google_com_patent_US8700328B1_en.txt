US8700328B1 - Better diversity for transit routing - Google Patents
Better diversity for transit routing Download PDFInfo
- Publication number
- US8700328B1 US8700328B1 US13/231,895 US201113231895A US8700328B1 US 8700328 B1 US8700328 B1 US 8700328B1 US 201113231895 A US201113231895 A US 201113231895A US 8700328 B1 US8700328 B1 US 8700328B1
- Authority
- US
- United States
- Prior art keywords
- label
- stations
- nodes
- arrival
- query graph
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active, expires
Links
- 238000000034 method Methods 0.000 claims description 79
- 230000006870 function Effects 0.000 claims description 55
- 238000012546 transfer Methods 0.000 claims description 41
- 238000001914 filtration Methods 0.000 claims description 5
- 238000005516 engineering process Methods 0.000 abstract description 50
- 230000008569 process Effects 0.000 description 50
- 238000012545 processing Methods 0.000 description 17
- 238000010845 search algorithm Methods 0.000 description 15
- 238000004590 computer program Methods 0.000 description 8
- 238000004891 communication Methods 0.000 description 7
- 230000003287 optical effect Effects 0.000 description 4
- 230000004044 response Effects 0.000 description 4
- 238000013461 design Methods 0.000 description 3
- 230000003993 interaction Effects 0.000 description 3
- 238000004422 calculation algorithm Methods 0.000 description 2
- 238000010586 diagram Methods 0.000 description 2
- 239000004973 liquid crystal related substance Substances 0.000 description 2
- 238000012986 modification Methods 0.000 description 2
- 230000004048 modification Effects 0.000 description 2
- 238000013515 script Methods 0.000 description 2
- 238000000926 separation method Methods 0.000 description 2
- 230000026676 system process Effects 0.000 description 2
- 238000013459 approach Methods 0.000 description 1
- 238000003491 array Methods 0.000 description 1
- 230000008859 change Effects 0.000 description 1
- 239000002355 dual-layer Substances 0.000 description 1
- 230000000977 initiatory effect Effects 0.000 description 1
- 230000007246 mechanism Effects 0.000 description 1
- 230000005055 memory storage Effects 0.000 description 1
- 230000002093 peripheral effect Effects 0.000 description 1
- 230000001953 sensory effect Effects 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
- 230000003068 static effect Effects 0.000 description 1
- 235000019640 taste Nutrition 0.000 description 1
- 238000012360 testing method Methods 0.000 description 1
- 230000036962 time dependent Effects 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G01—MEASURING; TESTING
- G01C—MEASURING DISTANCES, LEVELS OR BEARINGS; SURVEYING; NAVIGATION; GYROSCOPIC INSTRUMENTS; PHOTOGRAMMETRY OR VIDEOGRAMMETRY
- G01C21/00—Navigation; Navigational instruments not provided for in groups G01C1/00 - G01C19/00
- G01C21/26—Navigation; Navigational instruments not provided for in groups G01C1/00 - G01C19/00 specially adapted for navigation in a road network
- G01C21/34—Route searching; Route guidance
- G01C21/3407—Route searching; Route guidance specially adapted for specific applications
- G01C21/3423—Multimodal routing, i.e. combining two or more modes of transportation, where the modes can be any of, e.g. driving, walking, cycling, public transport
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06Q—INFORMATION AND COMMUNICATION TECHNOLOGY [ICT] SPECIALLY ADAPTED FOR ADMINISTRATIVE, COMMERCIAL, FINANCIAL, MANAGERIAL OR SUPERVISORY PURPOSES; SYSTEMS OR METHODS SPECIALLY ADAPTED FOR ADMINISTRATIVE, COMMERCIAL, FINANCIAL, MANAGERIAL OR SUPERVISORY PURPOSES, NOT OTHERWISE PROVIDED FOR
- G06Q10/00—Administration; Management
- G06Q10/04—Forecasting or optimisation specially adapted for administrative or management purposes, e.g. linear programming or "cutting stock problem"
- G06Q10/047—Optimisation of routes or paths, e.g. travelling salesman problem
-
- G06Q50/40—
Definitions
- Public transit planning systems have been developed in order to provide users with directions to travel between a starting location to a destination location via various forms of public transportation.
- the subject technology provides diversity in transit routes between one or more source stations and one or more target stations.
- the subject technology generates a query graph represented as a set of nodes.
- the subject technology searches the query graph to determine an arrival set for one or more nodes of the query graph based on a queue order and a domination function.
- the subject technology filters the arrival set of the node to remove dominated labels.
- the subject technology determines one or more optimal paths from a source station to a target station based on the filtered sets.
- the subject technology further includes a system for providing diversity in transit routes between one or more source stations and one or more target stations.
- the system includes memory, one or more processors, and one or more modules stored in memory and configured for execution by the one or more processors.
- the system includes a query graph module configured to generate a query graph represented as a set of nodes.
- the system further includes a search module configured to search the query graph to determine an arrival label set for one or more nodes of the query graph based on a queue order and a domination function.
- the system also includes a filter module configured to, for the one or more nodes of the query graph, filter the arrival label set of the one or more nodes to remove dominated labels.
- the system includes a path module configured to determine one or more optimal paths from one of the source stations to one of the target stations based on the filtered label set.
- Yet another aspect of the subject technology provides for generating a query graph represented as a set of nodes.
- the subject technology searches the query graph to determine an arrival label set for one or more nodes of the query graph based on a queue order and a domination function.
- the subject technology determines whether a first label has a greater duration time than a second label.
- the subject technology determines whether the first label includes at least a same set of lines as the second label.
- the subject technology then removes the first label if the first label has the greater duration time and includes at least the same set of lines as the second label.
- the subject technology determines one or more optimal paths from one of one or more source stations to one of one or more target stations based on a set of labels remaining in the arrival label set.
- FIG. 1 conceptually illustrates an example process for providing diversity in transit routes between one or more source stations and one or more target stations.
- FIG. 2 conceptually illustrates an example process for filtering arrival label set of a node(s) to remove dominated labels.
- FIG. 3 conceptually illustrates an example computing environment.
- FIG. 4 conceptually illustrates an example application programming interface (API) architecture.
- API application programming interface
- FIG. 5 conceptually illustrates a system with which some implementations of the subject technology may be implemented.
- Transit planning systems have been developed in order to provide users with directions to travel between a starting location and a destination using various forms of public transportation.
- a query including a starting location and a destination is received, and step by step directions are provided to reach the destination using one or more forms of public transportation.
- the query also includes an arrival or departure time.
- the directions can include a sequence of which public transit vehicles (e.g., buses, trains, etc.) are used and which stops at public transit locations need to be made in order to reach the destination of the trip.
- the directions may include a transfer to another transit vehicle required at the different transit locations along the trip.
- the directions can include a location to the first transit station and from the last transit station to the destination (e.g., a destination station or address).
- the transit planning system processes the transit information to determine optimal transfer patterns that describe transit routes between any two transit stations. The transfer patterns describe where transit vehicle transfers are made along each journey.
- a public transit planning system therefore can provide optimal public transit routes for a given trip.
- the optimal public transit routes describe the best routes for a trip relative to time and other factors using only public transportation and/or walking to reach a destination from a given starting point.
- a query graph is built from transfer patterns. In some configurations, all transfer patterns can be computed beforehand. For instance, prior to query time, the transit travel planning system processes the transit information to determine one or more transfer patterns that describe routes between any two transit stations. The transfer patterns describe where transit vehicle transfers are made along each journey.
- the query graph can be understood as a graph of transit stations. The query graph is connected by transit or walking arcs, and contains the best or optimal trip at any given departure time (but is much smaller than the whole transit network). The query graph in some configurations is used to determine the optimal route from the starting point to the destination point.
- the subject technology provides “diversity” in a set of routes to give the user more choices (e.g., because of the user's personal tastes, or because the user may know more information on fares, etc.).
- the subject technology is directed to a search algorithm for providing diversity in routes by providing different trips that use different sets of lines to reach a destination point from a given starting point.
- a label can be understood as an arrival (e.g., if a search is based on chronological order) or a departure (e.g., based on a search in a reverse chronological order) at the given station.
- a duration and a penalty are associated.
- the search algorithm of the subject technology maintains a set of labels. The subject technology allows adding a new label to the set of labels if the new label is not dominated by any other label in the set according to a domination relation. However, it is possible that one or more labels in the set are dominated by the new label.
- Adding a label to the set of labels is called “settling” a label.
- the search algorithm is not based on a classic Dijkstra algorithm in which for a given source vertex (node) in the graph, the algorithm finds the path with lowest cost (i.e. the shortest path) between that vertex and every other vertex.
- the search algorithm is based on a queue order function that only adds a label to a label set using a specified queue order. As a result, the search algorithm provides a different queue order than a domination relation.
- the subject technology implements a search algorithm on the query graph to provide diversity in the selected route(s).
- the search algorithm takes two parameters: 1) queue order: an order in which the labels are taken into account, and 2) domination relation: a relation that decides if one label is better than another label at a given station.
- the queue order is utilized by a queue order function to determine the order in which labels are to be included in a set of labels at a given station, and a domination function utilizes the domination relation to determine whether one label is better than another label (i.e., the worse label is marked as “dominated” by the domination function).
- the aforementioned queue order function can determine the queue order based on duration only, duration+penalty or some other specified cost function. Additionally, A* penalty function can also be used to adjust the queue order.
- the queue order function determines the first result that will be returned (e.g., duration+penalty will make the first result be the one with the best duration+penalty).
- a domination function then provides the diversity in routes according to the domination relation. Moreover, it is required that the domination function never dominates a label that has a better duration (e.g., in terms of total travel time) than all the labels already present at a station (e.g., in the set of labels for that station). Consequently, if the label that has the better duration is never dominated, the first result will always be determined based on the queue order from of the queue order function.
- the search algorithm maintains a queue of potentially forthcoming labels.
- the search algorithm takes the best label according to the queue order from the queue order function, and then removes it from the queue. If the station of this label has already been “settled” by a better label according to the domination function, the label is discarded. Otherwise, the label is “settled” by the search algorithm, and is added to a queue of all labels that are reachable from this label.
- the reachable labels can be understood as all the ways to reach different stations from this station by using a single vehicle (e.g., the first departing vehicle of each lines) or by short distance walking.
- the search algorithm continues until the label for an arrival station (e.g., “target station”) is settled.
- the search algorithm implements forward and backward searches.
- the search algorithm instead of keeping a label only if the label is not dominated by any other settled label(s) at a respective station, the search algorithm keeps labels that do not have the best duration so long as the number of labels at this station is less than N.
- N in one example represents an integer parameter in order to provide up to N*N routes between the departure and arrival stations. However, multiple labels with the same duration are not kept for the forward search.
- the forward search is stopped when the arrival station has been settled by N labels.
- the search algorithm then performs the backward search from each of these up to N arrival labels.
- the search algorithm also keeps labels that may be dominated by other labels so long as the number of settled labels at a given station is less than N.
- the backward search is performed starting from an arrival time determined from the forward search.
- the backward search uses a reverse graph and attempts to optimize departure time (e.g., to depart at late as possible).
- the backward search is limited so that the departure times are not earlier than the departure times of the forward search.
- the results of the backward search yields to a diverse set of trips, which are filtered afterwards (e.g., removing trips that are too similar or trips that include unnecessary loops).
- a set of lines are kept that have been used from the departing station to the label.
- a label is not settled if the label has worse duration than another settled label and:
- the set of lines can be determined by a hash of the used lines instead of the full set of lines.
- the hashing needs to be such that it allows adding a line and removing a line (e.g., by an XOR function of the IDs of the lines).
- FIG. 1 conceptually illustrates an example process 100 for providing diversity in transit routes between one or more source stations and one or more target stations. More specifically, the process 100 provides a diverse set of one or more transits routes in which optimal routes from one or more source stations to one or more target stations are included.
- the process 100 starts at 105 by generating a query graph represented as a set of nodes connected by arcs in an order described by a transfer pattern.
- Each node of the query graph represents a respective transit station and the transfer pattern describes a transit route of one or more transfers at respective transit stations between a source station and a target station.
- a transfer pattern describes a sequence of transit vehicle transfers at one or more transit stations that need to be made in order reach a destination (e.g., the target station).
- a transfer pattern is a sequence of one or more transfers along a public transit route at public transit stations (herein referred to as “stations”) where a passenger or traveler leaves (e.g., alights) a public transportation vehicle and boards (e.g., transfers to) another public transportation vehicle.
- a public transportation vehicle can include, but is not limited to, buses, trains, trolleybuses, trams, etc.
- a query graph includes transit information and is generated by the process 100 to determine the optimal route (e.g., based on different criteria) from the source station to the target station. For instance, a user can submit a query to determine a transit route starting from the source station to the target station.
- the query graph generated by the process 100 includes the source location and the target location related to the query, nodes representing stations, and arcs connecting the stations.
- the stations in the query graph represent transit stations that are included in a path(s) to reach the target station from the source station where transit vehicle transfers occur. Each arc in the query graph represents a direct connection between the pair of stations connecting the nodes.
- An arc therefore can represent one or more intermediate stations where stops (but no transfers) are made along a path to reach the target station connected by the arc. Further, an arc can represent walking from a station where a vehicle is departed to a station where a vehicle is boarded. Therefore, each arc between two respective nodes represents walking or a transit transfer between two transit stations respectively corresponding to the two respective nodes.
- the process 100 at 110 searches the query graph to determine an arrival label set for one or more nodes of the query graph based on a queue order and a domination function.
- the search at 110 can be understood as a “forward” search of the query graph.
- the arrival label set includes a first set of labels of a predetermined number N.
- N is a non-zero integer (e.g., 1, 2, 3, etc.) in some implementations.
- the queue order of some configurations is specified by a first function based on a duration time of each label or by a second function based on a duration time and a penalty of each label.
- the duration time is based on a departure time of a source node in the query graph and an arrival time at a target node in the query graph (e.g., the difference in time between the source and target nodes).
- the penalty is based on a monetary cost, a number of transfers, or a walking cost.
- the penalty can be a non-negative value or number and represents a cost associated with an arc connecting a source node to a target node (e.g., indicating traveling from the source to target node).
- the domination function utilized by the process 100 does not dominate a label that has a better duration time than another settled label (e.g., a label already included in the arrival label set).
- the process 100 in some configurations maintains a queue of labels for each node in the query graph in which each label has an associated duration and/or penalty. For each node in the query graph, the process 100 selects a label from the queue of labels according the aforementioned queue order. In one example, the process 100 determines whether the selected label is dominated by another label in the arrival label set according to the aforementioned domination function and, if so, the selected label is then discarded. If the selected label is not dominated, the process 100 settles the selected label by including it in the first set of labels of the arrival label set for the node representing the transit station.
- the process 100 can include the selected label that does not have, for example, the best duration so long as the number of labels in the arrival label set is less than the predetermined number N. However, the process 100 at 110 does not include multiple labels with the same duration. Moreover, the process 100 continues the search at 110 until the arrival label set includes N number of labels.
- the process 100 can perform a “backward” search from each label of the arrival label set.
- the process 100 can perform the backward search in order to optimize travel time by optimizing the departure time (e.g., to depart as late as possible) at each node of the query graph.
- the forward search performed at 110 optimizes an arrival time at each node but does not optimize travel time due to the time-dependent nature of the query graph.
- the process 100 utilizes a reverse graph of the query graph in order to perform aforementioned backward search of the query graph.
- the results of the backward search can yield a second set of labels of the predetermined number N mentioned above.
- the process 100 limits the backward search of the query graph by not allowing a departure time of a label from the backward search to be earlier than a departure time of the label in the arrival label set.
- the process 100 will determine the optimal trip is to take a last subway that allows the user to catch the earliest train possible.
- the process 100 can selects a label based on the aforementioned queue order that is not dominated by another label in the departure label set (e.g., according to the aforementioned domination function).
- the process 100 can (instead of including the selected label only if the selected label is not dominated by any other label) include the selected label that does not have, for example, the best duration so long as the number of labels is less than the predetermined number N.
- the process 100 then continues to 115 , for the one or more nodes of the query graph, filters the arrival label set of the one or more nodes to remove dominated labels.
- a first label dominates a second label responsive to a duration time (e.g., the first label's duration time is less than the second label's duration time).
- Another example of filtering the arrival and destination label sets is described in further detail in connection with FIG. 2 below.
- the process 100 determines one or more optimal paths at 120 from one of the source stations to one of the target stations based on the filtered label set.
- Each optimal path includes a set of lines between the source station and the target station, which forms a transfer pattern for a trip or journey between the source and target stations.
- each line can be represented by an arc or directed edge that connects a source node to a destination node forming a path between a node representing the source station and a node representing the destination station.
- the process 100 then ends.
- the subject technology can then present the one or more optimal paths to the user for the initial query for transit routes between the source station to the target station. For instance, the subject technology can provide a graphical user interface to present the one or more optimal paths (e.g., as one or more routes illustrated as a respective path(s) on a map). Additionally, the subject technology can provide directions based on the optimal paths.
- one or more templates of text and/or audible segments can be selected and populated so that natural language descriptions of a path can be viewed and/or heard.
- the path can be illustrated on a map by cross-referencing the nodes or arcs with map coordinates and tracing one or more lines, adding icons/text, etc.
- FIG. 2 conceptually illustrates an example process 200 for filtering arrival label set of a node(s) to remove dominated labels.
- the process 200 can be performed conjunctively with the process 100 in FIG. 1 described above.
- the subject technology For each label at a node of the query graph, the subject technology includes a set of lines that forms a path from a source station (e.g., the departing station) to the station (e.g., node) associated with the label.
- the process 200 can perform the operations described in further detail below to prune or filter a label at a node according to one or more different criteria.
- the process 200 begins at 205 by determining whether a first label has a worse duration time than a second label at a given node of the query graph.
- the process 200 can determine that the first label has a worse duration time if a duration time associated with the first label is a greater time period than the duration time associated with the second label.
- the process 200 continues to 210 to determine whether the first label includes at least a same set of lines as the second label (and therefore does not provide additional diversity).
- the process 200 at 215 then removes the first label if the first label has the worse duration time and includes at least the same set of lines as the second label. In this manner, a particular label is not settled in the arrival or departure label sets if the above criteria is met.
- the process 200 ends.
- the set of lines for a path is determined by a hash of used lines instead of a full set of lines.
- the hash of used lines in some implements can be an XOR function (e.g., “exclusive or” or “exclusive disjunction”).
- Each line in the set of lines includes a respective identifier that can be hashed to generate, for example, a numerical identifier.
- the process 200 of FIG. 2 can be performed conjunctively with the process 100 described above in FIG. 1 . More specifically, the subject technology can perform the operations in the process 200 to prune labels from the arrival label set (e.g., at 115 in FIG. 1 ) in order to filter a label(s) that is not considered diverse in the context of the subject technology.
- FIG. 3 conceptually illustrates an example computing environment 300 including a system for providing diversity in transit routes between one or more source stations and one or more target stations.
- FIG. 3 shows a system 305 for implementing the above described processes FIGS. 1 and 2 .
- the system 305 is part of an implementation running a particular machine (e.g., a server-based implementation).
- the system 305 includes several modules for providing different functionality.
- the system 305 is configured to include a query graph module 310 , a search module 315 , a filter module 320 , and a path module 325 .
- the query graph module 310 is configured to generate a query graph represented as a set of nodes connected by arcs in an order described by a transfer pattern. Each node represents a respective transit station and the transfer pattern describes a transit route of one or more transfers at transit stations between the source station and the target station.
- the search module 315 is configured to search the query graph to determine an arrival label set for one or more nodes of the query graph based on a queue order and a domination function.
- the arrival label set includes a first set of labels of a predetermined number N, wherein N is a non-zero integer.
- the search module 315 is further configured to, for the one or more nodes of the query graph, perform a backward search of each label of the arrival label set.
- the filter module 320 is configured to, for the one or more nodes of the query graph, filter the arrival label set of the one or more nodes to remove dominated labels.
- a first label dominates a second label responsive to a duration time in one example.
- the path module 325 is configured to determine one or more optimal paths from one of one or more source stations to one of one or more target stations based on the filtered label set.
- Each optimal path includes a set of lines between the source station and the target station. Additionally, each optimal path forms a respective transfer pattern for a trip between the one of the one or more source stations and the one of the one or more target stations.
- each of the aforementioned modules can be configured to communicate between each other. For instance, different data, messages, API calls and returns can be passed between the different modules in the system 305 .
- machine readable storage medium also referred to as computer readable medium.
- processing unit(s) e.g., one or more processors, cores of processors, or other processing units
- machine readable media include, but are not limited to, CD-ROMs, flash drives, RAM chips, hard drives, EPROMs, etc.
- the machine readable media does not include carrier waves and electronic signals passing wirelessly or over wired connections.
- the term “software” is meant to include firmware residing in read-only memory and/or applications stored in magnetic storage, which can be read into memory for processing by a processor.
- multiple software components can be implemented as sub-parts of a larger program while remaining distinct software components.
- multiple software subject components can also be implemented as separate programs.
- any combination of separate programs that together implement a software component(s) described here is within the scope of the subject technology.
- the software programs when installed to operate on one or more systems, define one or more specific machine implementations that execute and perform the operations of the software programs.
- a computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment.
- a computer program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code).
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- Some configurations are implemented as software processes that include one or more application programming interfaces (APIs) in an environment with calling program code interacting with other program code being called through the one or more interfaces.
- APIs application programming interfaces
- Various function calls, messages or other types of invocations, which can include various kinds of parameters, can be transferred via the APIs between the calling program and the code being called.
- an API can provide the calling program code the ability to use data types or classes defined in the API and implemented in the called program code.
- An API is an interface implemented by a program code component or hardware component (“API implementing component”) that allows a different program code component or hardware component (“API calling component”) to access and use one or more functions, methods, procedures, data structures, classes, and/or other services provided by the API implementing component.
- API implementing component a program code component or hardware component
- API calling component a different program code component or hardware component
- An API can define one or more parameters that are passed between the API calling component and the API implementing component.
- An API allows a developer of an API calling component (that could be a third party developer) to utilize specified features provided by an API implementing component. There may be one API calling component or there may be more than one such component.
- An API can be a source code interface that a computing system or program library provides to support requests for services from an application.
- An operating system (OS) can have multiple APIs to allow applications running on the OS to call one or more of those APIs, and a service (such as a program library) can have multiple APIs to allow an application that uses the service to call one or more of those APIs.
- An API can be specified in terms of a programming language that can be interpreted or compiled when an application is built.
- the API implementing component may provide more than one API, each providing a different view of or with different aspects that access different aspects of the functionality implemented by the API implementing component.
- one API of an API implementing component can provide a first set of functions and can be exposed to third party developers, and another API of the API implementing component can be hidden (not exposed) and provide a subset of the first set of functions and also provide another set of functions, such as testing or debugging functions which are not in the first set of functions.
- the API implementing component may itself call one or more other components via an underlying API and thus be both an API calling component and an API implementing component.
- An API defines the language and parameters that API calling components use when accessing and using specified features of the API implementing component. For example, an API calling component accesses the specified features of the API implementing component through one or more API calls or invocations (embodied for example by function or method calls) exposed by the API and passes data and control information using parameters via the API calls or invocations.
- the API implementing component may return a value through the API in response to an API call from an API calling component. While the API defines the syntax and result of an API call (e.g., how to invoke the API call and what the API call does), the API may not reveal how the API call accomplishes the function specified by the API call.
- API calls are transferred via the one or more application programming interfaces between the calling (API calling component) and an API implementing component. Transferring the API calls may include issuing, initiating, invoking, calling, receiving, returning, or responding to the function calls or messages. In other words, transferring can describe actions by either of the API calling component or the API implementing component.
- the function calls or other invocations of the API may send or receive one or more parameters through a parameter list or other structure.
- a parameter can be a constant, key, data structure, object, object class, variable, data type, pointer, array, list or a pointer to a function or method or another way to reference a data or other item to be passed via the API.
- data types or classes may be provided by the API and implemented by the API implementing component.
- the API calling component therefore can declare variables, use pointers to, use or instantiate constant values of such types or classes by using definitions provided in the API.
- an API can be used to access a service or data provided by the API implementing component or to initiate performance of an operation or computation provided by the API implementing component.
- the API implementing component and the API calling component may each be any one of an operating system, a library, a device driver, an API, an application program, or other module (it should be understood that the API implementing component and the API calling component may be the same or different type of module from each other).
- API implementing components may in some cases be embodied at least in part in firmware, microcode, or other hardware logic.
- an API may allow a client program to use the services provided by a Software Development Kit (SDK) library.
- SDK Software Development Kit
- an application or other client program may use an API provided by an Application Framework.
- an API call can report to an application the capabilities or state of a hardware device, including those related to aspects such as input capabilities and state, output capabilities and state, processing capability, power state, storage capacity and state, communications capability, etc., and the API may be implemented in part by firmware, microcode, or other low level logic that executes in part on the hardware component.
- the API calling component may be a local component (i.e., on the same data processing system as the API implementing component) or a remote component (i.e., on a different data processing system from the API-implementing component) that communicates with the API-implementing component through the API over a network.
- an API implementing component may also act as an API calling component (i.e., it may make API calls to an API exposed by a different API implementing component) and an API calling component may also act as an API implementing component by implementing an API that is exposed to a different API calling component.
- the API can allow multiple API calling components written in different programming languages to communicate with the API implementing component (thus the API may include features for translating calls and returns between the API implementing component and the API calling component).
- the API however can be implemented in terms of a specific programming language.
- An API calling component can, in one configuration, call APIs from different providers such as a set of APIs from an OS provider and another set of APIs from a plug-in provider and another set of APIs from another provider (e.g. the provider of a software library) or creator of the another set of APIs.
- FIG. 4 is a block diagram illustrating an example API architecture, which can be used in some configurations of the subject technology.
- the API architecture 400 includes the API implementing component 414 (e.g., an operating system, a library, a device driver, an API, an application program, software or other module) that implements the API 410 .
- the API 410 specifies one or more functions, methods, classes, objects, protocols, data structures, formats and/or other features of the API-implementing component that can be used by the API-calling component 404 .
- the API 410 can specify at least one calling convention that specifies how a function in the API implementing component receives parameters from the API calling component and how the function returns a result to the API calling component.
- the API calling component 404 (e.g., an operating system, a library, a device driver, an API, an application program, software or other module), makes API calls through the API 410 to access and use the features of the API implementing component 414 that are specified by the API 410 .
- the API implementing component 414 can return a value through the API 410 to the API calling component 404 in response to an API call.
- the API implementing component 414 can include additional functions, methods, classes, data structures, and/or other features that are not specified through the API 410 and are not available to the API calling component 404 . It should be understood that the API calling component 404 can be on the same system as the API implementing component 414 or can be located remotely and accesses the API implementing component 414 using the API 410 over a network. While FIG. 4 illustrates a single API calling component 404 interacting with the API 410 , it should be understood that other API calling components, which can be written in different languages (or the same language) than the API calling component 404 , can use the API 410 .
- the API implementing component 414 , the API 410 , and the API calling component 404 can be stored in a machine-readable medium, which includes any mechanism for storing information in a form readable by a machine (e.g., a computer or other data processing system).
- a machine-readable medium includes magnetic disks, optical disks, random access memory, read only memory, flash memory devices, etc.
- FIG. 5 conceptually illustrates a system 500 with which some implementations of the subject technology can be implemented.
- the system 500 can be a computer, phone, PDA, or any other sort of electronic device. Such a system includes various types of computer readable media and interfaces for various other types of computer readable media.
- the system 500 includes a bus 505 , processing unit(s) 510 , a system memory 515 , a read-only memory 520 , a storage device 525 , an optional input interface 530 , an optional output interface 535 , and a network interface 540 .
- the bus 505 collectively represents all system, peripheral, and chipset buses that communicatively connect the numerous internal devices of the system 500 .
- the bus 505 communicatively connects the processing unit(s) 510 with the read-only memory 520 , the system memory 515 , and the storage device 525 .
- the processing unit(s) 510 retrieves instructions to execute and data to process in order to execute the processes of the subject technology.
- the processing unit(s) can be a single processor or a multi-core processor in different implementations.
- the read-only-memory (ROM) 520 stores static data and instructions that are needed by the processing unit(s) 510 and other modules of the system 500 .
- the storage device 525 is a read-and-write memory device. This device is a non-volatile memory unit that stores instructions and data even when the system 500 is off. Some implementations of the subject technology use a mass-storage device (such as a magnetic or optical disk and its corresponding disk drive) as the storage device 525 .
- the system memory 515 is a read-and-write memory device. However, unlike storage device 525 , the system memory 515 is a volatile read-and-write memory, such a random access memory.
- the system memory 515 stores some of the instructions and data that the processor needs at runtime.
- the subject technology's processes are stored in the system memory 515 , the storage device 525 , and/or the read-only memory 520 .
- the various memory units include instructions for processing multimedia items in accordance with some implementations. From these various memory units, the processing unit(s) 510 retrieves instructions to execute and data to process in order to execute the processes of some implementations.
- the bus 505 also connects to the optional input and output interfaces 530 and 535 .
- the optional input interface 530 enables the user to communicate information and select commands to the system.
- the optional input interface 530 can interface with alphanumeric keyboards and pointing devices (also called “cursor control devices”).
- the optional output interface 535 can provide display images generated by the system 500 .
- the optional output interface 535 can interface with printers and display devices, such as cathode ray tubes (CRT) or liquid crystal displays (LCD). Some implementations can interface with devices such as a touchscreen that functions as both input and output devices.
- CTR cathode ray tubes
- LCD liquid crystal displays
- bus 505 also couples system 500 to a network interface 540 through a network adapter (not shown).
- the computer can be a part of a network of computers (such as a local area network (“LAN”), a wide area network (“WAN”), or an Intranet, or an interconnected network of networks, such as the Internet. Any or all components of system 500 can be used in conjunction with the subject technology.
- Some implementations include electronic components, such as microprocessors, storage and memory that store computer program instructions in a machine-readable or computer-readable medium (alternatively referred to as computer-readable storage media, machine-readable media, or machine-readable storage media).
- computer-readable media include RAM, ROM, read-only compact discs (CD-ROM), recordable compact discs (CD-R), rewritable compact discs (CD-RW), read-only digital versatile discs (e.g., DVD-ROM, dual-layer DVD-ROM), a variety of recordable/rewritable DVDs (e.g., DVD-RAM, DVD-RW, DVD+RW, etc.), flash memory (e.g., SD cards, mini-SD cards, micro-SD cards, etc.), magnetic and/or solid state hard drives, read-only and recordable Blu-Ray® discs, ultra density optical discs, any other optical or magnetic media, and floppy disks.
- CD-ROM compact discs
- CD-R recordable compact discs
- the computer-readable media can store a computer program that is executable by at least one processing unit and includes sets of instructions for performing various operations.
- Examples of computer programs or computer code include machine code, such as is produced by a compiler, and files including higher-level code that are executed by a computer, an electronic component, or a microprocessor using an interpreter.
- ASICs application specific integrated circuits
- FPGAs field programmable gate arrays
- integrated circuits execute instructions that are stored on the circuit itself.
- the terms “computer”, “server”, “processor”, and “memory” all refer to electronic or other technological devices. These terms exclude people or groups of people.
- display or displaying means displaying on an electronic device.
- computer readable medium and “computer readable media” are entirely restricted to tangible, physical objects that store information in a form that is readable by a computer. These terms exclude any wireless signals, wired download signals, and any other ephemeral signals.
- implementations of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used
- Configurations of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network.
- Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
- LAN local area network
- WAN wide area network
- inter-network e.g., the Internet
- peer-to-peer networks e.g., ad hoc peer-to-peer networks.
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device).
- client device e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device.
- Data generated at the client device e.g., a result of the user interaction
- any specific order or hierarchy of steps in the processes disclosed is an illustration of example approaches. Based upon design preferences, it is understood that the specific order or hierarchy of steps in the processes can be rearranged, or that all illustrated steps be performed. Some of the steps can be performed simultaneously. For example, in certain circumstances, multitasking and parallel processing can be advantageous. Moreover, the separation of various system components in the configurations described above should not be understood as requiring such separation in all configurations, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
- a phrase such as an “aspect” does not imply that such aspect is essential to the subject technology or that such aspect applies to all configurations of the subject technology.
- a disclosure relating to an aspect can apply to all configurations, or one or more configurations.
- a phrase such as an aspect can refer to one or more aspects and vice versa.
- a phrase such as a “configuration” does not imply that such configuration is essential to the subject technology or that such configuration applies to all configurations of the subject technology.
- a disclosure relating to a configuration can apply to all configurations, or one or more configurations.
- a phrase such as a configuration can refer to one or more configurations and vice versa.
- example is used herein to mean “serving as an example or illustration.” Any aspect or design described herein as “example” is not necessarily to be construed as preferred or advantageous over other aspects or designs.
Abstract
Description
-
- 1. The label uses the same set of lines as another settled label (because the label does not provide more diversity).
- 2. The label uses the same set of lines+one other line as another settled label (because if it is faster to stay in the same vehicle, it does not make sense to propose to change the vehicle).
Claims (31)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/231,895 US8700328B1 (en) | 2011-09-13 | 2011-09-13 | Better diversity for transit routing |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/231,895 US8700328B1 (en) | 2011-09-13 | 2011-09-13 | Better diversity for transit routing |
Publications (1)
Publication Number | Publication Date |
---|---|
US8700328B1 true US8700328B1 (en) | 2014-04-15 |
Family
ID=50441535
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/231,895 Active 2032-04-11 US8700328B1 (en) | 2011-09-13 | 2011-09-13 | Better diversity for transit routing |
Country Status (1)
Country | Link |
---|---|
US (1) | US8700328B1 (en) |
Cited By (11)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20140172890A1 (en) * | 2012-12-13 | 2014-06-19 | International Business Machines Corporation | Searching a vertex in a path |
US20150168149A1 (en) * | 2013-05-14 | 2015-06-18 | Google Inc. | Systems and Methods for Generating a Plurality of Trip Patterns |
US20150168148A1 (en) * | 2013-05-14 | 2015-06-18 | Google Inc. | Systems and Methods for Generating Guidebook Routes |
JP2016053496A (en) * | 2014-09-03 | 2016-04-14 | アイシン・エィ・ダブリュ株式会社 | Route search system, route search method, and computer program |
US20160358112A1 (en) * | 2015-06-05 | 2016-12-08 | Apple Inc. | Enriching Transit Data and Transit Data Processing |
EP3435298A1 (en) * | 2017-07-24 | 2019-01-30 | SilverRail Australia Pty Ltd | Computer implemented technologies configured to enable efficient processing of data in a transportation network based on generation of directed graph data derived from transportation timetable data |
FR3084949A1 (en) * | 2018-08-09 | 2020-02-14 | Amadeus S.A.S. | METHOD FOR GENERATING A SET OF ROUTES BY LIMITED QUERY OF DATABASES |
FR3084948A1 (en) * | 2018-08-09 | 2020-02-14 | Amadeus S.A.S. | METHOD FOR GENERATING A GRAPHICS-BASED ROUTE SET |
CN110914844A (en) * | 2017-08-03 | 2020-03-24 | 谷歌有限责任公司 | Application programming interface for vehicle routing applications |
US20210381847A1 (en) * | 2020-06-03 | 2021-12-09 | Here Global B.V. | Method, apparatus, and computer program product for generating and communicating low bandwidth map version agnostic routes |
US20210381838A1 (en) * | 2020-06-03 | 2021-12-09 | Here Global B.V. | Method, apparatus, and computer program product for generating and communicating low bandwidth map version agnostic routes |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5276768A (en) * | 1991-03-20 | 1994-01-04 | Tidewater Consultants, Inc. | Automated telephone information system |
US20090040931A1 (en) | 2007-08-10 | 2009-02-12 | Max-Planck-Gesellschaft Zur Forderung Der Wissenschaften E.V. | Method and device for determining the length of a shortest path in a network |
US20110112759A1 (en) | 2009-11-11 | 2011-05-12 | Google Inc. | Transit routing system for public transportation trip planning |
-
2011
- 2011-09-13 US US13/231,895 patent/US8700328B1/en active Active
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5276768A (en) * | 1991-03-20 | 1994-01-04 | Tidewater Consultants, Inc. | Automated telephone information system |
US20090040931A1 (en) | 2007-08-10 | 2009-02-12 | Max-Planck-Gesellschaft Zur Forderung Der Wissenschaften E.V. | Method and device for determining the length of a shortest path in a network |
US20110112759A1 (en) | 2009-11-11 | 2011-05-12 | Google Inc. | Transit routing system for public transportation trip planning |
US8417409B2 (en) * | 2009-11-11 | 2013-04-09 | Google Inc. | Transit routing system for public transportation trip planning |
Non-Patent Citations (1)
Title |
---|
Bast et al., "Fast Routing in Very Large Public Transportation Networks using Transfer Patterns", Jul. 6, 2010, pp. 1-16. |
Cited By (17)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9026517B2 (en) * | 2012-12-13 | 2015-05-05 | International Business Machines Corporation | Searching a vertex in a path |
US20140172890A1 (en) * | 2012-12-13 | 2014-06-19 | International Business Machines Corporation | Searching a vertex in a path |
US20150168149A1 (en) * | 2013-05-14 | 2015-06-18 | Google Inc. | Systems and Methods for Generating a Plurality of Trip Patterns |
US20150168148A1 (en) * | 2013-05-14 | 2015-06-18 | Google Inc. | Systems and Methods for Generating Guidebook Routes |
US9273970B2 (en) * | 2013-05-14 | 2016-03-01 | Google Inc. | Systems and methods for generating a plurality of trip patterns |
JP2016053496A (en) * | 2014-09-03 | 2016-04-14 | アイシン・エィ・ダブリュ株式会社 | Route search system, route search method, and computer program |
US20160358112A1 (en) * | 2015-06-05 | 2016-12-08 | Apple Inc. | Enriching Transit Data and Transit Data Processing |
US11080631B2 (en) * | 2015-06-05 | 2021-08-03 | Apple Inc. | Enriching transit data and transit data processing |
EP3435298A1 (en) * | 2017-07-24 | 2019-01-30 | SilverRail Australia Pty Ltd | Computer implemented technologies configured to enable efficient processing of data in a transportation network based on generation of directed graph data derived from transportation timetable data |
CN110914844A (en) * | 2017-08-03 | 2020-03-24 | 谷歌有限责任公司 | Application programming interface for vehicle routing applications |
FR3084949A1 (en) * | 2018-08-09 | 2020-02-14 | Amadeus S.A.S. | METHOD FOR GENERATING A SET OF ROUTES BY LIMITED QUERY OF DATABASES |
FR3084948A1 (en) * | 2018-08-09 | 2020-02-14 | Amadeus S.A.S. | METHOD FOR GENERATING A GRAPHICS-BASED ROUTE SET |
US11676233B2 (en) | 2018-08-09 | 2023-06-13 | Amadeus S.A S. | Method of generating a set of itineraries by limited querying of databases |
US20210381847A1 (en) * | 2020-06-03 | 2021-12-09 | Here Global B.V. | Method, apparatus, and computer program product for generating and communicating low bandwidth map version agnostic routes |
US20210381838A1 (en) * | 2020-06-03 | 2021-12-09 | Here Global B.V. | Method, apparatus, and computer program product for generating and communicating low bandwidth map version agnostic routes |
US11733059B2 (en) * | 2020-06-03 | 2023-08-22 | Here Global B.V. | Method, apparatus, and computer program product for generating and communicating low bandwidth map version agnostic routes |
US11821739B2 (en) * | 2020-06-03 | 2023-11-21 | Here Global B.V. | Method, apparatus, and computer program product for generating and communicating low bandwidth map version agnostic routes |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US8700328B1 (en) | Better diversity for transit routing | |
US9488479B2 (en) | Method, system, and device for to-do-list based navigation | |
US8775070B1 (en) | Method and system for user preference-based route calculation | |
Ahmad et al. | Characterizing the role of vehicular cloud computing in road traffic management | |
CN104596531B (en) | A kind of generation method of navigation routine, device and server | |
US9207090B2 (en) | System and method for dynamic path optimization | |
Cohen et al. | Technological advances relevant to transport–understanding what drives them | |
US20160260025A1 (en) | Travel-Related Cognitive Short Messages | |
US11262207B2 (en) | User interface | |
Ma et al. | Faster hyperpath generating algorithms for vehicle navigation | |
Korkmaz et al. | A smart school bus tracking system | |
US20140047346A1 (en) | User interface elements for transportation sharing | |
US20140047024A1 (en) | Transportation sharing based on user activities and statements | |
US8712682B1 (en) | Estimating travel time | |
Hafiddi et al. | Context-awareness for service oriented systems | |
US20140047354A1 (en) | Transportation sharing based on map locations | |
EP2630441A1 (en) | Navigation system with xpath repetition based field alignment mechanism and method of operation thereof | |
CN112288160A (en) | Travel scheme planning method and related equipment | |
Shankari | e-mission: an open source, extensible platform for human mobility systems | |
Cuesta et al. | CoMobility: a mobile platform for transport sharing | |
US9203908B2 (en) | System an method for disambiguating cookies | |
KR20150110907A (en) | Supplementary service system, method for provding supplementary service using lock screen mode and appratus thereof | |
Nunes | Public transport management systems with real-time passenger information | |
US20150178687A1 (en) | System and method for improving resource utilization | |
Gopalakrishnan et al. | A study on mobile requirements elicitation by boilerplate requirements specification language |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:RAYCHEV, VESELIN;PECH, LUCIEN;REEL/FRAME:026922/0517Effective date: 20110912 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044277/0001Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551)Year of fee payment: 4 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 8TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1552); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 8 |