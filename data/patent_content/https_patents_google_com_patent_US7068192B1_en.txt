US7068192B1 - System and method for encoding and decoding variable-length data - Google Patents
System and method for encoding and decoding variable-length data Download PDFInfo
- Publication number
- US7068192B1 US7068192B1 US10/917,745 US91774504A US7068192B1 US 7068192 B1 US7068192 B1 US 7068192B1 US 91774504 A US91774504 A US 91774504A US 7068192 B1 US7068192 B1 US 7068192B1
- Authority
- US
- United States
- Prior art keywords
- tag
- data
- fields
- subfields
- instructions
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
Images
Classifications
-
- H—ELECTRICITY
- H03—ELECTRONIC CIRCUITRY
- H03M—CODING; DECODING; CODE CONVERSION IN GENERAL
- H03M7/00—Conversion of a code where information is represented by a given sequence or number of digits to a code where the same, similar or subset of information is represented by a different sequence or number of digits
- H03M7/30—Compression; Expansion; Suppression of unnecessary data, e.g. redundancy reduction
- H03M7/40—Conversion to or from variable length codes, e.g. Shannon-Fano code, Huffman code, Morse code
Definitions
- the disclosed embodiments relate generally to data processing systems and methods, and in particular to a system and method for encoding and decoding variable-length data.
- variable-length data e.g., variable-length integers
- variable-length data can be encoded into a compressed format which represents the data in fewer bytes than would ordinarily be used to store the data.
- an integer value may be associated with a 32-bit integer data type. However, if the actual value of the integer is in the range of 0 to 255, the value can be more compactly represented by 8-bits or a single byte, resulting in a savings of 24 bits or three bytes.
- variable-length data into a compressed format typically requires the storing and maintaining of additional information for use in decoding, such as data indicating the number of bits or bytes used to represent a compressed integer value.
- additional information for use in decoding such as data indicating the number of bits or bytes used to represent a compressed integer value.
- the management of such “bookkeeping” information typically requires additional overhead bits for use during decoding.
- some conventional encoders add a “continuation bit” to each byte used to represent a compressed integer value to assist the decoder in identifying boundaries between consecutive compressed integer values.
- Such encoding techniques typically require several bitwise operations (e.g., Boolean, shift, branch, etc.) to unpack or decompress the integer values, which can slow down the decoding process and degrade overall system performance. Such degradation is especially problematic in applications that perform large-scale processing of compressed data, such as information retrieval systems.
- Data values may be stored in a variable length data structure including a data field and a tag field.
- the data field includes one or more data subfields, each capable of storing variable-length data (e.g., 1 to N bytes of data).
- the data subfields and the tag field of the data structure each start on a byte boundary which simplifies decoding.
- the tag field includes one or more tag subfields corresponding to the one or more data subfields.
- Each tag subfield includes one or more tag bits which indicate the length of the data stored in the corresponding data subfield.
- Unpacking or decompressing data values from the data structure can be achieved by using a look-up table of offsets and masks, thus reducing the number of bit operations needed to unpack data values from the data structure.
- a data structure stored in a computer-readable medium includes a tag field that occupies a contiguous space in the data structure.
- the tag field specifies storage lengths for N data values, where N is a positive integer greater than one.
- the data structure further includes N data fields contiguously arranged with the tag field for storing the N values, wherein each of the N data fields has a storage length specified by the tag field.
- a method of decoding an encoded block of data includes decoding a tag, occupying a contiguous space, so as to identify storage lengths for N fields of the encoded block of data, where N is an integer greater than one; and reading the N fields at positions in the encoded block of data determined in accordance with the tag, wherein the encoded block of data includes a contiguously stored set of fields, including the tag and the N fields.
- a method of encoding a block of data includes: generating a tag, occupying a contiguous space, comprising N subfields, each subfield specifying a respective length of a respective field of N fields in a set of fields; and storing the tag and the set of fields in a block of data comprising a contiguous set of storage locations, wherein each of the N fields has a length specified by a respective subfield of the N subfields.
- FIG. 1 is a flow diagram of an embodiment of an encoding system for encoding variable-length data.
- FIG. 2 is a flow diagram of an embodiment of a decoding system for decoding variable-length data.
- FIG. 3 illustrates an embodiment of a data structure for use in encoding variable-length data.
- FIG. 4A illustrates an embodiment of a data structure for use in encoding a group of four 32-bit variable-length unsigned integer values.
- FIG. 4B is a table illustrating tag bit pair assignments for various ranges of integer values.
- FIG. 5A illustrates an embodiment of a combined offset/mask table for decoding the encoded group of integer values of FIG. 4 .
- FIG. 5B illustrates an embodiment of the data structure of FIG. 4 showing byte offset boundaries.
- FIG. 6 is a flow diagram of an embodiment of a encoding process for encoding a group of variable-length integer values.
- FIG. 7 is a flow diagram of an embodiment of a decoding process for decoding an encoded group of variable-length integer values.
- FIG. 8 is a block diagram of an embodiment of a computer system for implementing the encoding and decoding processes of FIGS. 6 and 7 .
- FIG. 1 is a flow diagram of an embodiment of an encoding system 100 for encoding variable-length data.
- the encoding system 100 includes an optional preprocessor 110 , an optional delta encoder 120 and a variable-length data encoder 130 .
- Variable-length data can be stored as various data types including, without limitation, integers, character strings, floating-point numbers, fixed-point numbers and the like.
- the variable-length data includes but is not limited to text, images, graphics, audio samples and the like.
- raw data is received by the preprocessor 110 which orders the information for efficient encoding.
- the pre-processor 110 may order the data into a monotonic sequence using one or more sorting algorithms. If a set of integers are sorted by value, then adjacent integers will be close in magnitude, thus enabling the delta encoder 120 to generate small valued integers for encoding.
- the ordered data is received by the delta encoder 120 , which computes differences between adjacent pairs of the ordered data to obtain the small valued integers.
- the small valued integers are received by the variable-length data encoder 130 , which encodes the data into a compressed format which can be efficiently decoded, as described more fully with respect FIGS. 3–7 .
- FIG. 2 is a flow diagram of an embodiment of a decoding system 200 for decoding variable-length data.
- the decoding system 200 includes a variable-length data decoder 210 and an optional delta decoder 220 .
- encoded groups of data are received by the variable-length data decoder 210 , which decodes the groups with the assistance of one or more offset/mask tables.
- the decoded data is received by the delta decoder 220 , which computes running sums, thereby producing delta-decoded data, which is equivalent to the original raw data.
- the use of offset/mask tables in decoding group encoded variable-length integer values is described more fully with respect to FIGS. 5 and 7 .
- FIG. 3 illustrates an embodiment of a grouped variable-length data structure 300 for use in encoding variable-length data.
- the data structure 300 includes a variable length data field 302 and a fixed-length tag field 304 .
- the variable-length data field 302 includes two or more variable-length data subfields 306 and the tag field 304 includes fixed-length tag subfields 308 .
- each data subfield 306 stores a variable-length data value that can range from 1 to N bytes in length.
- Each data subfield 306 has a corresponding fixed-length tag subfield 308 which is used to represent the actual number of bytes used in the data subfield 306 .
- the data subfield 306 a corresponds to the tag subfield 308 a
- the data subfield 306 b corresponds to the tag subfield 308 b and so on.
- the tag subfields 308 include the minimum number of tag bits needed to represent the maximum length of the corresponding data subfield 306 .
- the data structure 300 occupies a contiguous space
- the tag field 304 occupies a contiguous space within the data structure 300 .
- the tag field 304 may be located anywhere within the data structure 300 or it can be stored as a separate data structure. Locating the tag field 304 at the beginning or end of a data structure 300 allows an adjacent data structure in a sequence of data structures (e.g., an encoded data stream) to be easily located and accessed using simple arithmetic operations and/or a table lookup. Storing the tag field 304 in a separate data structure also allows the tag field 304 to be processed as a separate data stream in, for example, a multi-threaded or multi-processor environment. As a separate data stream, the tag field 304 can be encoded using one or more conventional encoding schemes (e.g., run-length encoding).
- data subfields 306 of the data structure 300 and the tag field 304 each start on a byte boundary (i.e., the tag field 304 and each of the data fields 306 occupies an integer number of bytes), which greatly simplifies the decoding process, as described more fully with respect FIG. 7 .
- the data structure 300 is not limited to four data subfields 306 and four tag subfields 308 and that more or fewer data subfields 306 and tag subfields 308 can be included in the data structure 300 , as needed, depending upon the application.
- the tag field 304 may occupy an amount of space that is not an integer number of bytes, and one or more of the data fields 306 may occupy an amount of space that is not an integer number of bytes.
- the tag subfields 308 may specify the lengths of the data fields in units of 4-bit nibbles, or any other appropriate unit.
- FIG. 4A illustrates an example of a data structure 400 for use in encoding a group of four 32-bit variable-length unsigned integer values.
- the data structure 400 includes a variable-length data field 402 and a fixed-length tag field 404 .
- the data field 402 includes four variable-length data subfields 408 and the fixed-length tag field 404 includes four fixed-length tag subfields 410 .
- three of the data subfields 408 a , 408 c , 408 d each store a single byte of data and the fourth data subfield 408 b stores two bytes of data.
- each byte of data in the data structure 400 shown in FIG. 4A is represented by a decimal (base 10 ) equivalent value.
- the data subfield 408 d stores a byte having a decimal equivalent value of 251
- data subfield 408 c stores a byte having a decimal equivalent value of 13
- data subfield 408 b stores two-bytes having respective decimal equivalent values of 2 and 3
- data subfield 408 a stores a byte having a decimal equivalent value of 27.
- the tag subfields 410 a , 410 c and 410 d corresponding to data subfields 408 a , 408 c and 408 d , each include the bit pair “00,” indicating that each of the data subfields 408 a , 408 c and 408 d store one byte of data.
- the tag subfield 410 b corresponding to data subfield 408 b , includes the bit pair “01,” indicating that the data subfield 408 b is storing two bytes of data.
- the tag field 404 is one byte in length.
- FIG. 4B is a table illustrating tag bit pair assignments for various ranges of integer values. Note that the data values stored in data subfields 408 a , 408 c and 408 d , namely “27”, “13,” and “251,” all fall within the value range 0–255 and therefore can be represented by one byte of data. The value stored in data subfield 408 b , namely “515,” falls in the range of 256–65,535 and therefore can be represented by two bytes of data have decimal equivalent values of “2” and “3” respectively.
- FIG. 5A illustrates an embodiment of a combined offset/mask table 500 for decoding the data structure 400 of FIG. 4A .
- the table 500 includes 256 rows which can be indexed by tag value 510 . Each row includes: 1) an offset for the first 515 , second 520 , third 525 , and fourth 530 data subfields 408 in the data structure 400 , 2 ) masks used for efficiently reading the first 535 , second 540 , third 545 , and fourth 550 data subfields 408 from memory, and 3) an offset 555 to a next data structure. Note that if the tag field 404 is stored highest in memory, then analogous table entries would provide an offset 555 to an adjacent preceding data structure 400 in the sequence of contiguous data structures. In some embodiments, certain offsets are unneeded and those columns may be omitted from the table 500 .
- the table 500 is not limited to the number of rows and/or columns shown in FIG. 5A , but can have any number of rows and columns, as needed, depending upon the number of values that are group encoded.
- the offsets and masks are stored in separate tables or other types of data structures (e.g., lists, arrays, queues, etc.).
- the tag field 402 is one byte long and includes tag subfields 410 a , . . . , 410 d , containing tag bit pairs 00, 01, 00, and 00, respectively. These tag bit pairs in turn correspond to a total data field 402 length of 5 bytes. This particular combination of bit pairs has a decimal equivalent value of “4” and therefore could be used to index row 4 of table 500 , as indicated with cross-hatching. In row 4 of table 500 , the offsets 515 , 520 , 525 and 530 to the first bytes of data stored in data subfields 408 a , .
- . . , 408 d are 1, 2, 4, and 5 bytes, respectively (reading from left to right in FIG. 5B ).
- the offset 555 to the next data structure is 6 bytes as expected. That is, a data structure that follows the data structure 400 would begin at byte six, given that bytes zero through five are included in the data structure 400 .
- Row 4 in table 500 also includes masks 000000ff, 0000ffff, 000000ff, and 000000ff in hexadecimal notation for decoding each 1–4 byte integer value into its original 32-bit integer format.
- it may be easier to read the packed integers with an unaligned full-width read. This means that the least-significant bytes of the integer will contain the packed integer, while the other bytes will contain data from subsequent packed integers or other data structures. The number of least-significant bytes that will contain the packed integer depends on how many bytes were used to store the packed integer.
- the mask may be used with a bitwise AND operation to throw away bytes not used to store the packed integer.
- FIG. 6 is a flow diagram of an embodiment of a encoding process 600 for encoding grouped variable-length data values.
- the process 600 begins by determining the minimum storage requirements (e.g., number of bytes) for a group of N data values ( 602 ). In some embodiments, this is achieved by looking at the magnitude of each data value (e.g., integer value) and determining the minimum number of bytes required to store the data value in a data structure (e.g., data structure 400 ).
- the data values are treated as integers, even though they may represent other types of values, such as characters, symbols, other types of numeric values, and so on.
- a data value in the range of 0–255 can be represented by one byte, while a data value in the range of 256–65,535 can be represented by two bytes and so on.
- the data values are packed into a data field (e.g., data field 402 ) of the data structure ( 604 ) based on the minimum number of bytes needed to store the data values determined at 602 .
- the data values can be packed in the data field using known bit packing techniques.
- a tag field e.g., tag field 404
- the tag field After the tag field is generated, it can be appended to the data field ( 608 ).
- the tag field is appended to one end of the data structure to simplify its decoding.
- the tag field is stored as a separate data structure to be decoded into a separate data stream in, for example, a multi-threading or multi-processor environment.
- FIG. 7 is a flow diagram of an embodiment of a decoding process 700 for decoding grouped variable-length data values, which may be integer values or other data values.
- a data structure e.g., data structure 400
- the tag bits are decoded from the data structure ( 702 ).
- the tag bits are preferably located at the beginning or end of the data structure to facilitate their decoding using an offset value stored in an offset/mask table 704 , together with knowledge of the tag field size (e.g., a byte).
- the tag bits are used to index the offset/mask table 704 and to retrieve the appropriate offsets and masks to decode the encoded data values from the data structure ( 706 ) and load them into registers or memory.
- the retrieved masks are then applied to the data subfields of the data structure using the offsets ( 708 ), thus resulting in a decoded group of data values.
- the appropriate byte offsets are retrieved from the offset/mask table 500 and used to extract a set of values from the data structure 400 . These values may be stored in one or more registers or memory. A bitwise AND operation is performed on the extracted values and the corresponding 32-bit mask value retrieved from the offset/mask table 500 , resulting in the original 32-bit data value.
- the original data values can be decoded from the data structure 400 using a bitwise AND operation, and without performing branch or shift operations that can degrade performance.
- FIG. 8 is a block diagram of a computer system 800 .
- the computer system 800 can be a stand alone computer system or part of a distributed processing system including multiple computer systems 800 .
- the computer system 800 generally includes one or more processing units (CPUs) 812 , one or more network or other communications interfaces 816 , memory 818 , and one or more communication buses 814 for interconnecting these components.
- the system 800 may optionally include a user interface, for instance a display and a keyboard.
- Memory 818 may include high speed random access memory and may also include non-volatile memory, such as one or more magnetic disk storage devices. Memory 818 may include mass storage that is remotely located from the central processing unit(s) 812 .
- the memory 818 stores an operating system 820 (e.g., Linux or Unix), a network communication module 822 , an application 824 , a variable-length data encoder 826 , a variable-length data decoder 828 , an offset table and mask table which may be combined into one table 830 or two separate tables, raw data to be encoded 832 (e.g., 32-bit unsigned integers), encoded data 834 (e.g., groups of four integers), a preprocessing module 836 , a delta encoder 838 and a delta decoder 840 . In some embodiments, the memory 818 stores only a subset of these items.
- an operating system 820 e.g., Linux or Unix
- a network communication module 822 e.g., an application 824 , a variable-length data encoder 826 , a variable-length data decoder 828 , an offset table and mask table which may be combined into one table 830 or two separate tables, raw data to be
- the system 800 decodes data, but does not encode data, and as a result the system 800 does not include the preprocessor 836 , the encoder 826 and the delta encoder 838 , and the “raw data” 832 comprises decoded data produced by decoding the encoded data 834 .
- the system 800 includes the preprocessor 836 and encoder 826 , but does not include the variable-length data decoder 828 , and lookup table(s) 830 and delta decoder 840 .
- An example of an application 824 is a document compression system used to generate a tokenspace repository, as described in co-pending U.S. patent application Ser. No. 10/917,739, filed Aug. 13, 2004, entitled “Document Compression System and Method For Use With Tokenspace Repository,” which is incorporated by reference herein in its entirety.
- the preprocessing module 836 and delta encoder/decoder 838 operate as previously described with respect FIGS. 1 and 2 .
- the variable-length data encoder 826 and variable-length data decoder 828 operate as previously described with respect to FIGS. 6 and 7 .
- the encoded data 834 can be stored in memory 818 using the data structures described with respect to FIGS. 3–5 .
Abstract
Description
Claims (27)
Priority Applications (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/917,745 US7068192B1 (en) | 2004-08-13 | 2004-08-13 | System and method for encoding and decoding variable-length data |
US14/816,572 US9619565B1 (en) | 2004-08-13 | 2015-08-03 | Generating content snippets using a tokenspace repository |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/917,745 US7068192B1 (en) | 2004-08-13 | 2004-08-13 | System and method for encoding and decoding variable-length data |
Publications (1)
Publication Number | Publication Date |
---|---|
US7068192B1 true US7068192B1 (en) | 2006-06-27 |
Family
ID=36600483
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/917,745 Active US7068192B1 (en) | 2004-08-13 | 2004-08-13 | System and method for encoding and decoding variable-length data |
Country Status (1)
Country | Link |
---|---|
US (1) | US7068192B1 (en) |
Cited By (13)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20080253460A1 (en) * | 2007-04-13 | 2008-10-16 | Apple Inc. | Method and system for entropy coding |
US20100117875A1 (en) * | 2008-11-10 | 2010-05-13 | Apple Inc. | System and method for compressing a stream of integer-valued data |
US20100134331A1 (en) * | 2008-12-01 | 2010-06-03 | Arm Limited | Dynamic selection of suitable codes for variable length coding and decoding |
US20100146246A1 (en) * | 2008-12-05 | 2010-06-10 | Michael Frank | Method and Apparatus for Decompression of Block Compressed Data |
US20120173496A1 (en) * | 2010-12-30 | 2012-07-05 | Teradata Us, Inc. | Numeric, decimal and date field compression |
US8587458B2 (en) | 2011-12-07 | 2013-11-19 | International Business Machines Corporation | Unpacking a variable number of data bits |
US9378560B2 (en) | 2011-06-17 | 2016-06-28 | Advanced Micro Devices, Inc. | Real time on-chip texture decompression using shader processors |
US10142629B2 (en) * | 2015-12-28 | 2018-11-27 | Mediatek Inc. | Method and apparatus for entropy coding in image compression |
US10304155B2 (en) | 2017-02-24 | 2019-05-28 | Advanced Micro Devices, Inc. | Delta color compression application to video |
CN111600610A (en) * | 2020-05-26 | 2020-08-28 | 北京思特奇信息技术股份有限公司 | Variable-length integer universal coding method, system and electronic equipment |
US11153578B2 (en) | 2018-04-27 | 2021-10-19 | Ati Technologies Ulc | Gradient texturing compression codec |
CN114157395A (en) * | 2021-11-05 | 2022-03-08 | 在线途游（北京）科技有限公司 | Data communication method, device and system based on variable length integer coding |
CN115001628A (en) * | 2022-06-07 | 2022-09-02 | 北京百度网讯科技有限公司 | Data encoding method and device, data decoding method and device and data structure |
Citations (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5548751A (en) * | 1990-03-16 | 1996-08-20 | Fujitsu Limited | Dynamic data storage system allowing variable size records and fields by using linked record segments |
US5758360A (en) * | 1993-06-30 | 1998-05-26 | Microsoft Corporation | Meta-data structure and handling |
US5946716A (en) * | 1996-05-30 | 1999-08-31 | Hewlett-Packard Company | Sectored virtual memory management system and translation look-aside buffer (TLB) for the same |
US6553457B1 (en) * | 2000-04-19 | 2003-04-22 | Western Digital Technologies, Inc. | Tag memory disk cache architecture |
US6646577B2 (en) * | 2000-10-31 | 2003-11-11 | Intel Corporation | Method of performing Huffman decoding |
US6728722B1 (en) * | 2000-08-28 | 2004-04-27 | Sun Microsystems, Inc. | General data structure for describing logical data spaces |
US6832294B2 (en) * | 2002-04-22 | 2004-12-14 | Sun Microsystems, Inc. | Interleaved n-way set-associative external cache |
-
2004
- 2004-08-13 US US10/917,745 patent/US7068192B1/en active Active
Patent Citations (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5548751A (en) * | 1990-03-16 | 1996-08-20 | Fujitsu Limited | Dynamic data storage system allowing variable size records and fields by using linked record segments |
US5758360A (en) * | 1993-06-30 | 1998-05-26 | Microsoft Corporation | Meta-data structure and handling |
US5946716A (en) * | 1996-05-30 | 1999-08-31 | Hewlett-Packard Company | Sectored virtual memory management system and translation look-aside buffer (TLB) for the same |
US6553457B1 (en) * | 2000-04-19 | 2003-04-22 | Western Digital Technologies, Inc. | Tag memory disk cache architecture |
US6728722B1 (en) * | 2000-08-28 | 2004-04-27 | Sun Microsystems, Inc. | General data structure for describing logical data spaces |
US6646577B2 (en) * | 2000-10-31 | 2003-11-11 | Intel Corporation | Method of performing Huffman decoding |
US6832294B2 (en) * | 2002-04-22 | 2004-12-14 | Sun Microsystems, Inc. | Interleaved n-way set-associative external cache |
Cited By (24)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20080253460A1 (en) * | 2007-04-13 | 2008-10-16 | Apple Inc. | Method and system for entropy coding |
US7486211B2 (en) * | 2007-04-13 | 2009-02-03 | Apple Inc. | Method and system for entropy coding |
US20090103608A1 (en) * | 2007-04-13 | 2009-04-23 | Apple Inc. | Method and system for entropy coding |
US7800520B2 (en) | 2007-04-13 | 2010-09-21 | Apple Inc. | Method and system for entropy coding |
US20100117875A1 (en) * | 2008-11-10 | 2010-05-13 | Apple Inc. | System and method for compressing a stream of integer-valued data |
US7804428B2 (en) | 2008-11-10 | 2010-09-28 | Apple Inc. | System and method for compressing a stream of integer-valued data |
US20100134331A1 (en) * | 2008-12-01 | 2010-06-03 | Arm Limited | Dynamic selection of suitable codes for variable length coding and decoding |
US7936290B2 (en) * | 2008-12-01 | 2011-05-03 | Arm Limited | Dynamic selection of suitable codes for variable length coding and decoding |
US20100146246A1 (en) * | 2008-12-05 | 2010-06-10 | Michael Frank | Method and Apparatus for Decompression of Block Compressed Data |
US7962727B2 (en) * | 2008-12-05 | 2011-06-14 | Globalfoundries Inc. | Method and apparatus for decompression of block compressed data |
US20120173496A1 (en) * | 2010-12-30 | 2012-07-05 | Teradata Us, Inc. | Numeric, decimal and date field compression |
US8495034B2 (en) * | 2010-12-30 | 2013-07-23 | Teradata Us, Inc. | Numeric, decimal and date field compression |
US11043010B2 (en) | 2011-06-17 | 2021-06-22 | Advanced Micro Devices, Inc. | Real time on-chip texture decompression using shader processors |
US9378560B2 (en) | 2011-06-17 | 2016-06-28 | Advanced Micro Devices, Inc. | Real time on-chip texture decompression using shader processors |
US10510164B2 (en) | 2011-06-17 | 2019-12-17 | Advanced Micro Devices, Inc. | Real time on-chip texture decompression using shader processors |
US8587458B2 (en) | 2011-12-07 | 2013-11-19 | International Business Machines Corporation | Unpacking a variable number of data bits |
US10142629B2 (en) * | 2015-12-28 | 2018-11-27 | Mediatek Inc. | Method and apparatus for entropy coding in image compression |
US10304155B2 (en) | 2017-02-24 | 2019-05-28 | Advanced Micro Devices, Inc. | Delta color compression application to video |
US11153578B2 (en) | 2018-04-27 | 2021-10-19 | Ati Technologies Ulc | Gradient texturing compression codec |
CN111600610A (en) * | 2020-05-26 | 2020-08-28 | 北京思特奇信息技术股份有限公司 | Variable-length integer universal coding method, system and electronic equipment |
CN114157395A (en) * | 2021-11-05 | 2022-03-08 | 在线途游（北京）科技有限公司 | Data communication method, device and system based on variable length integer coding |
CN114157395B (en) * | 2021-11-05 | 2023-08-08 | 在线途游（北京）科技有限公司 | Data communication method, device and system based on variable-length integer codes |
CN115001628A (en) * | 2022-06-07 | 2022-09-02 | 北京百度网讯科技有限公司 | Data encoding method and device, data decoding method and device and data structure |
CN115001628B (en) * | 2022-06-07 | 2024-02-27 | 北京百度网讯科技有限公司 | Data encoding method and device, data decoding method and device and data structure |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US5572206A (en) | Data compression method and system | |
US6199064B1 (en) | Method and apparatus for sorting data blocks | |
JP2534465B2 (en) | Data compression apparatus and method | |
Williams et al. | Compressing integers for fast file access | |
US9195675B2 (en) | Decoding of variable-length data with group formats | |
US7907069B2 (en) | Fast compression method for scientific data | |
US6005503A (en) | Method for encoding and decoding a list of variable size integers to reduce branch mispredicts | |
US7068192B1 (en) | System and method for encoding and decoding variable-length data | |
Moffat et al. | On the implementation of minimum redundancy prefix codes | |
JP3225638B2 (en) | Apparatus and method for compressing data and data processing system | |
JP3229180B2 (en) | Data compression system | |
US7447814B1 (en) | Method and apparatus for fast loss-less memory data compression wherein data corresponds to a cache line of data in cache | |
US6310563B1 (en) | Method and apparatus for enhanced decompressor parsing | |
EP3120266B1 (en) | Ozip compression and decompression | |
US20090121906A1 (en) | Alternative encoding for lzss output | |
JPH0697838A (en) | Decoding device | |
US20150262385A1 (en) | Image decoder, graphics processor, image decoding method, and graphics processing method | |
US20220179849A1 (en) | Accelerated filtering, grouping and aggregation in a database system | |
US6247112B1 (en) | Bit manipulation instructions | |
US7924179B2 (en) | Variable-length code determining device and variable-length code decoding method | |
US5915041A (en) | Method and apparatus for efficiently decoding variable length encoded data | |
US7075462B2 (en) | Speeding up variable length code decoding on general purpose processors | |
KR20030016859A (en) | The decoding method of Huffman code | |
JPWO2002101935A1 (en) | Decoding device, decoding method, lookup table, and decoding program | |
Bharathi et al. | A plain-text incremental compression (pic) technique with fast lookup ability |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:DEAN, JEFFREY;BURROWS, MICHAEL;THAMBIDORAI, GAUTHAUM K.;AND OTHERS;REEL/FRAME:015094/0746Effective date: 20040813 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
CC | Certificate of correction | ||
FPAY | Fee payment |
Year of fee payment: 4 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 12TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1553)Year of fee payment: 12 |