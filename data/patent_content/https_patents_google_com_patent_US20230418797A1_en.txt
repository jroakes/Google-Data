US20230418797A1 - Approximate k nearest neighbors on hardware accelerators - Google Patents
Approximate k nearest neighbors on hardware accelerators Download PDFInfo
- Publication number
- US20230418797A1 US20230418797A1 US18/341,697 US202318341697A US2023418797A1 US 20230418797 A1 US20230418797 A1 US 20230418797A1 US 202318341697 A US202318341697 A US 202318341697A US 2023418797 A1 US2023418797 A1 US 2023418797A1
- Authority
- US
- United States
- Prior art keywords
- vector
- database
- query
- vectors
- bin
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 239000013598 vector Substances 0.000 claims abstract description 282
- 238000000034 method Methods 0.000 claims abstract description 38
- 238000011524 similarity measure Methods 0.000 claims description 47
- 238000012545 processing Methods 0.000 claims description 15
- 238000004590 computer program Methods 0.000 abstract description 7
- 239000011159 matrix material Substances 0.000 description 8
- 238000010801 machine learning Methods 0.000 description 6
- 230000002123 temporal effect Effects 0.000 description 4
- 238000013459 approach Methods 0.000 description 3
- 238000003491 array Methods 0.000 description 3
- 230000003287 optical effect Effects 0.000 description 3
- 238000005457 optimization Methods 0.000 description 3
- IMBXRZKCLVBLBH-OGYJWPHRSA-N cvp protocol Chemical compound ClCCN(CCCl)P1(=O)NCCCO1.O=C1C=C[C@]2(C)[C@H]3C(=O)C[C@](C)([C@@](CC4)(O)C(=O)CO)[C@@H]4[C@@H]3CCC2=C1.C([C@H](C[C@]1(C(=O)OC)C=2C(=C3C([C@]45[C@H]([C@@]([C@H](OC(C)=O)[C@]6(CC)C=CCN([C@H]56)CC4)(O)C(=O)OC)N3C=O)=CC=2)OC)C[C@@](C2)(O)CC)N2CCC2=C1NC1=CC=CC=C21 IMBXRZKCLVBLBH-OGYJWPHRSA-N 0.000 description 2
- 230000007423 decrease Effects 0.000 description 2
- 238000000926 separation method Methods 0.000 description 2
- 101100153586 Caenorhabditis elegans top-1 gene Proteins 0.000 description 1
- 101100370075 Mus musculus Top1 gene Proteins 0.000 description 1
- 230000005540 biological transmission Effects 0.000 description 1
- 238000001514 detection method Methods 0.000 description 1
- 230000006870 function Effects 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 230000000644 propagated effect Effects 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 239000000758 substrate Substances 0.000 description 1
- 238000012546 transfer Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
- G06F16/2228—Indexing structures
- G06F16/2237—Vectors, bitmaps or matrices
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/24569—Query processing with adaptation to specific hardware, e.g. adapted for using GPUs or SSDs
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2458—Special types of queries, e.g. statistical queries, fuzzy queries or distributed queries
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/28—Databases characterised by their database models, e.g. relational or object models
- G06F16/284—Relational databases
- G06F16/285—Clustering or classification
Definitions
- This specification generally relates to performing a k nearest neighbor (kNN) computation on a hardware accelerator.
- a kNN computation is a computation that receives a query vector and a set of database vectors and searches for the k database vectors that are most similar to the query vector according to some similarity measure.
- This specification describes a system implemented as computer programs on one or more computers in one or more locations that performs a k nearest neighbor (kNN) computation.
- the system performs the kNN computation by receiving a set of query vectors and a set of database vectors and, for each query vector, searching for the k database vectors that are most similar to the query vector according to some similarity measure.
- the most similar database vectors are those that are closest to the query vector (have the smallest similarity measure with the query vector).
- similarity measures e.g., Euclidean distance or other distance measures
- the most similar database vectors are those that have the largest similarity measure with the query vector.
- K can generally be any positive integer, i.e., any integer greater than or equal to one, but is generally much smaller than the total number of database vectors in the set. For example, if there are a million database vectors, the value of k can be less than two thousand and, in some cases, can be less than one hundred, less than fifty, or less than fifteen.
- this specification describes how the kNN computation can be performed efficiently by a hardware accelerator that has circuitry that is configured to perform matrix multiplication in hardware.
- the hardware accelerator can be a machine learning accelerator like a graphics processing unit (GPU), a tensor processing unit (TPU), or a different type of accelerator that has special-purpose hardware for performing various linear algebra computations.
- This specification describes techniques for performing a kNN computation on a hardware accelerator, e.g., a machine learning accelerator or other accelerator that includes special purpose hardware for performing linear algebra operations, e.g., matrix multiplication.
- a hardware accelerator e.g., a machine learning accelerator or other accelerator that includes special purpose hardware for performing linear algebra operations, e.g., matrix multiplication.
- the described algorithm for performing the KNN computation achieves peak performance on the target accelerator, e.g., on a TPU or a GPU, and outperforms state-of-the-art accelerator-based kNN algorithms with a similar level of recall. That is, given a target recall, the described algorithm outperforms, e.g., in terms of computational efficiency, state-of-the-art accelerator-based kNN algorithms that achieve the same target recall. For example, for a given recall, the described techniques can achieve state of the art results in terms of computation time when deployed on a suitable hardware accelerator.
- the described techniques can achieve this state-of-the-art performance by minimizing the number of coefficient-wise operations (COPs) that are required to be performed as part of the search.
- COPs coefficient-wise operations
- FIG. 1 shows an example system for performing a kNN computation.
- FIG. 2 illustrates an example process for performing a kNN computation.
- FIG. 3 illustrates an example process for identifying the most similar database vectors within each bin.
- FIG. 4 shows the performance of the described techniques relative to existing techniques.
- FIG. 1 shows an example system 100 for performing a k-nearest neighbor (kNN) search computation.
- kNN k-nearest neighbor
- Performing a kNN search has a wide range of applications in machine learning and information retrieval systems.
- Some examples of systems that make use of kNN search include image search systems, semantic textual retrieval systems, anomaly detection systems, recommendation systems, and, more generally, any of a variety of systems that serve as a component for downstream tasks.
- accurately performing the kNN search can be important to the performance of a variety of machine learning and information retrieval systems.
- the kNN search can be computationally expensive and in some cases can bottleneck the performance computational efficiency of the machine learning or information retrieval system due to excessive latency, excessive memory usage, and so on.
- the system 100 performs the kNN search in a computationally efficient manner while still maintaining a high degree of accuracy.
- the system 100 receives a set of query vectors 104 and a set of database vectors 108 and, for each query vector 104 , searches for the k database vectors 108 that are most similar to the query vector 104 according to some similarity measure.
- the query vectors 104 and the database vectors 108 generally have the same dimensionality, i.e., each query vector q and each database vector x have the same number of entries D.
- the most similar database vectors are those that are closest to the query vector (have the smallest similarity measure with the query vector).
- the most similar database vectors are those that have the largest similarity measure with the query vector.
- K can generally be any positive integer, i.e., any integer greater than or equal to one, but is generally much smaller than the total number N of database vectors in the set.
- the system 100 identifies, as the output 112 of the kNN computation, a respective set of k database vectors for each query vector 104 and provides the output 112 to, e.g., a downstream system from which the query vectors 104 were received.
- the system 100 provides the sets of k database vectors as output.
- system 100 provides data identifying the k database vectors as output, e.g., by providing the indices of the k database vectors within the set of database vectors.
- system 100 can provide an output 112 that identifies more than k database vectors for each query vector and the downstream system can further refine the database vectors identified in the output 112 to generate the k database vectors for each query vector.
- the system 100 performs the kNN computation efficiently using a hardware accelerator 120 that has circuitry 130 that is configured to perform matrix multiplication in hardware.
- the hardware accelerator 120 is a special-purpose computer chip that has circuitry 130 that performs matrix multiplication in hardware.
- the hardware accelerator 120 can be a machine learning accelerator like a graphics processing unit (GPU), a tensor processing unit (TPU), or a different type of accelerator that has special-purpose hardware for performing various linear algebra computations.
- GPU graphics processing unit
- TPU tensor processing unit
- the hardware accelerator 120 can be a machine learning accelerator like a graphics processing unit (GPU), a tensor processing unit (TPU), or a different type of accelerator that has special-purpose hardware for performing various linear algebra computations.
- the hardware accelerator 120 can be a TPU or other accelerator that includes a systolic array circuit for performing multiplication in hardware.
- the systolic array can be an array of multiply accumulate units (MACs) that performs matrix multiplication in hardware using any of a variety of computation paradigms, e.g., output stationary or input stationary computation.
- MACs multiply accumulate units
- the hardware accelerator 120 can be a GPU or other accelerator that includes a tensor core circuit for performing multiplication in hardware.
- the hardware accelerator 120 can perform certain floating point operations that are accelerated by dedicated circuitry (“hardware”) on the accelerator.
- floating point operations are, as described above, matrix multiplication.
- the performance of the accelerator 120 is therefore in part bounded by the arithmetic intensity of these floating point operations and the peak memory bandwidth of the accelerator 120 .
- the hardware accelerator 120 can also perform other coefficient-wise operations (COPs)—examples of such operations include vectorized add operations, multiply operations, compare operations, conditional-move operations, and so on.
- COPs coefficient-wise operations
- examples of such operations include vectorized add operations, multiply operations, compare operations, conditional-move operations, and so on.
- these COPs are generally computationally expensive for the accelerator to perform for a variety of reasons, e.g., because they require processing additional instructions in addition to the matrix multiplication instructions that are required to perform multiplication and only a limited number of additional instructions are available before a lack of instruction bandwidth bottlenecks the performance of the accelerator.
- the performance of the accelerator 120 is therefore also bounded by the instruction throughput intensity, which is the ratio of floating point operations to COPs.
- instruction throughput intensity which is the ratio of floating point operations to COPs.
- having COPs per floating point operation can allow the accelerator 120 to achieve better performance on a given computational workload because it reduces the likelihood that instruction bandwidth will serve as a bottleneck.
- the system 100 performs the KNN search in a manner that optimizes the performance of the kNN search by minimizing the number of COPs that are required to be performed as part of the search.
- the system 100 uses the accelerator 120 to perform the search in a manner that accounts for the limited coefficient-wise instruction bandwidth of the hardware accelerator 120 and prevents this limited bandwidth from bottlenecking the efficiency of the search.
- FIG. 2 illustrates an example process 200 for performing a kNN computation.
- a system e.g., the system 100 of FIG. 1 , appropriately programmed, can perform the process 200 .
- the system obtains a set of one or more query vectors (step 202 ).
- the system obtains a set of database vectors (step 204 ).
- Each database vector has a respective index, i.e., a respective identifier that uniquely identifies the database vector within the set.
- the database vectors are partitioned into a plurality of bins based on the indices, i.e., such that each bin is made up of a set of database vectors that have consecutive indices.
- the system selects the total number of bins. For example, the system can select the total number of bins based on a target recall for the kNN search, with larger numbers of bins resulting in a higher recall and smaller number of bins resulting in a lower recall.
- the system receives the total number of bins as input.
- the system performs, on a hardware accelerator and for each query vector in the set, a search for the k most similar database vectors to the query vector according to a similarity measure (step 206 ).
- the similarity measure can be any appropriate similarity measure and can be specified by the request for the kNN search or can be predetermined.
- Examples of similarity measures include inner product similarity, cosine similarity, and Euclidean distance.
- the system computes, by the circuitry of the hardware accelerator and for each query vector, a respective similarity value between the query vector and each database vector according to the similarity measure.
- the system can compute the similarity values at least in part by computing, by circuitry of the hardware accelerator and for each query vector, a respective dot product between the query vector and each database vector.
- the system can compute these dot products using the matrix multiplication circuitry of the accelerator.
- the system can compute the respective dot products using vectorized fused-multiply-add operations performed by the circuitry of the hardware accelerator.
- a fused-multiply-add operation is a floating-point multiply-add operation performed in one step, with a single rounding.
- a fused multiply-add computes the entire expression, i.e., a+(b ⁇ c), to its full precision before rounding the final result down to N significant bits.
- the fused-multiply-add operation is referred to as “vectorized” because the hardware accelerator performs at least a portion of the operation in parallel for each of the plurality of pairs rather than, e.g., performing the operation sequentially by iterating through a loop.
- the accelerator can perform the multiplication operations as an element-wise operation between the two vectors and then accumulate the results, both using the multiplication circuitry of the accelerator, e.g., using a set of MACs of a systolic array.
- the system For each query vector, the system identifies, by the hardware accelerator and for each bin, (i) an index of the most similar database vector within the bin and (ii) the respective similarity value for the most similar database vector within the bin.
- the system identifies L most similar database vectors, with each being the most similar database vector within the corresponding bin.
- the system collects the top-1 similarities for each of the L bins.
- the larger the number of bins the larger the expected recall of the algorithm, i.e., because the likelihood that the second most similar database vector is one of the top k most similar database vectors across all of the bins decreases as the number of vectors per bin decreases.
- Table 1 shows an example of algorithm pseudo-code for performing the kNN search on an accelerator as described above.
- the system iterates through the M query vectors and, for each query vector i, uses the ShiftRight operation to identify the bin Z to which a given database vector j belongs.
- the system uses vectorized conditional moves to determine whether to update a first value a and second value v for the query vector i and for the identified bin/based on a similarity b between the query vector i and the database vector j.
- the described technique requires only three COPs for each floating point dot product, which allows the system to avoid bottlenecks due to the limited coefficient-wise instruction bandwidth of the accelerator and maintain high computational efficiency of the search.
- the system further optimizes the algorithm shown in Table 1 to exploit temporal and spatial locality when making use of the accelerator memory, e.g., of an on-chip cache of the hardware accelerator.
- the system then provides an output of the kNN search (step 208 ).
- the system provides the L most similar database vectors as the output of the kNN search. For example, if L is larger than k, the system can provide an output identifying the L most similar database vectors to the system from which the query vectors were received and the other system can refine the L most similar database vectors to a final set of k database vectors.
- system further refines the L most similar database vectors.
- system can select, by the hardware accelerator, k database vectors from the L most similar database vectors within the plurality of bins.
- the system can sort the most similar database vectors within the plurality of bins based on the respective similarity measures to generate a sorted list of the most similar database vectors. For example, the system can perform a bitonic sort of the most similar database vectors within the plurality of bins to generate the sorted list.
- the system then performs a truncation on the sorted list of the most similar database vectors to identify the k most similar database vectors from the sorted most similar database vectors. That is, the system truncates the sorted list to include only the first k database vectors in the sorted list.
- the system can then provide data identifying the first k database vectors as the output of the kNN computation.
- FIG. 3 illustrates an example process 300 for identifying the most similar database vectors within the plurality of bins.
- a system e.g., the system 100 of FIG. 1 , appropriately programmed, can perform the process 300 .
- the system initializes, for each bin and for each query vector, a first value that identifies the index of the most similar database vector within the bin and a second value identifying the respective similarity measure for the most similar database vector within the bin (step 302 ).
- the system maintains, for each query vector, a respective first value for each bin that identifies the index of the most similar database vector within the bin to the query vector and a respective second value for each bin that represents the most similar database vector identified by the respective first value for the bin.
- the system then repeatedly performs steps 304 through 308 to update the first and second values for the bins. For example, the system can perform steps 304 through 308 until the system has iterated through each database vector for each query vector.
- the system After repeatedly performing steps 304 - 308 , the system returns, for each query vector and for each bin, (i) an index of the most similar database vector within the bin by returning the first value for the query vector for the bin and (ii) the respective similarity value for the most similar database vector within the bin by returning the second value for the query vector for the bin.
- the system operates on a plurality of query vector-database vector pairs.
- the plurality of pairs can be some or all of the pairs corresponding to the current inner iteration of Algorithm 2 that is shown in Table 2 below.
- the system performs a vectorized compare operation to determine, for each of the plurality of query vector-database vector pairs, whether the similarity measure between the pair indicates that the pair is more similar than the most similar database vector identified by the first value for the query vector in the pair and for the bin to which the database vector in the pair belongs (step 304 ).
- the vectorized compare operation compares, for each query vector-database vector pair, the similarity measure between the pair to the similarity between the query vector in the pair and the most similar database vector identified by the first value for the query vector in the pair and for the bin to which the database vector in the pair belongs.
- the compare operation is referred to as “vectorized” because the hardware accelerator performs the compare operation in parallel for each of the plurality of pairs rather than, e.g., performing the compare operation by iterating through a loop.
- the accelerator can perform the compare operation as an element-wise operation between two vectors.
- one vector is a vector of similarities for the query vector-database vector pairs and the other vector is a vector of similarities for the query vector—most similar vector pairs.
- the system then performs one or more first vectorized conditional move operations (step 306 ) to, for each of the plurality of query vector-database vector pairs, update the first value for the query vector in the pair and for the bin to which the database vector in the pair belongs to identify the database vector in the pair only if the similarity measure between the pair indicates that the pair is more similar than the most similar database vector identified by the first value for the query vector and for the bin to which the database vector in the pair belongs.
- the move operation is referred to as “conditional” because the hardware accelerator only updates (or overwrites) a given stored first value for a given pair if the similarity measure between the pair indicates that the pair is more similar than the most similar database vector identified by the given first value. If the similarity measure between the pair does not indicate that the pair is more similar, the accelerator does not modify the stored first value.
- the system also performs one or more second vectorized conditional move operations (step 308 ) to, for each of the plurality of query vector-database vector pairs, update the second value for the query vector and for the bin to which the database vector in the pair belongs to be equal to the similarity measure between the pair only if the similarity measure between the pair indicates that the pair is more similar than the most similar database vector identified by the first value for the query vector and for the bin to which the database vector in the pair belongs.
- the hardware accelerator only updates (or overwrites) a given stored second value for a given pair if the similarity measure between the pair indicates that the pair is more similar than the given second value. If the similarity measure between the pair does not indicate that the pair is more similar, the accelerator does not modify the stored second value.
- the system further optimizes the algorithm shown above in Table 1 to exploit temporal and spatial locality when making use of the accelerator cache.
- the set of query vectors includes a plurality of query vectors that are partitioned into a plurality of query blocks.
- Each query block includes a respective plurality of query vectors and the system performs the search by searching for the query vectors in a respective query block at each of a plurality of outer iterations. That is, each outer iteration corresponds to a different query block.
- the system computes, by the circuitry of the hardware accelerator and for each query vector in the query block for the outer iteration, a respective similarity value between the query vector and each database vector according to the similarity measure. That is, the system can perform the computation of the similarity values using vectorized FMA operations, e.g., using the systolic array, as described above.
- the system For each query vector in the query block for the outer iteration, the system then identifies, by the hardware accelerator and for each bin, (i) an index of the most similar database vector within the bin and (ii) the respective similarity value for the most similar database vector within the bin, e.g., as described above with reference to FIG. 3 .
- the set of database vectors can further be partitioned into a plurality of chunks.
- Each chunk includes a respective plurality of database vectors and each outer iteration includes a respective inner iteration for each of the plurality of chunks.
- the system computes, by the circuitry of the hardware accelerator and for each query vector in the query block for the outer iteration, a respective similarity value between the query vector and each database vector in the chunk corresponding to the inner iteration according to the similarity measure. That is, the system can perform the computation of the similarity values using a vectorized FMA operation, e.g., using the systolic array, as described above.
- the system For each query vector in the query block for the outer iteration and for each database vector in the chunk for the inner iteration, the system then identifies, by the hardware accelerator and for each bin to which at least one of the database vectors in the chunk belongs, (i) an index of the most similar database vector within the bin and (ii) the respective similarity value for the most similar database vector within the bin, e.g., as described above with reference to FIG. 3 .
- the system exploits temporal locality by reusing previously accessed items.
- the system iterates by blocks of queries.
- the block of queries is reused in the inner loops, achieving the temporal locality.
- the system exploits spatial locality by accessing items nearby previously accessed items.
- the block iteration loads a chunk of database vectors to achieve this optimization.
- the same block iteration structure may apply recursively for multiple cache hierarchies till the register level.
- the inner loops (indexed by i, j, and kin line 3 of Table 2) are unrolled or vectorized so that every cycle can produce multiple results via SIMD (Single Instruction Multiple Data) instructions or systolic arrays.
- SIMD Single Instruction Multiple Data
- the operations of the processes 200 and 300 are part of a larger kNN computation and multiple accelerators within a set of accelerators perform the processes 200 and 300 with the same query vectors but on a different set of database vectors.
- the host or another system can determine the output of the larger kNN computation from the outputs generated by the individual accelerators in the set.
- FIG. 4 shows an example 400 of the performance of the described techniques relative to existing techniques.
- FIG. 4 shows plots of the speed-recall trade-off on two data sets: Glove1.2M and Sift1M.
- Glove1.2M and Sift1M.
- Each plot shows the performance of two variants of the described techniques, one deployed on a TPUv3 chip and the other deployed on a TPUv4 chip. Each plot also shows the performance of three high-performing conventional approaches on a GPU V100 and on a GPU A100.
- Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non transitory program carrier for execution by, or to control the operation of, data processing apparatus.
- the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, which is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- the computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them.
- the processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output(s).
- the processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array), an ASIC (application specific integrated circuit), or a GPGPU (General purpose graphics processing unit).
- special purpose logic circuitry e.g., an FPGA (field programmable gate array), an ASIC (application specific integrated circuit), or a GPGPU (General purpose graphics processing unit).
- Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit.
- a central processing unit will receive instructions and data from a read only memory or a random access memory or both.
- the essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks.
- mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks.
- a computer need not have such devices.
- Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks.
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks.
- the processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
Abstract
Methods, systems, and apparatus, including computer programs encoded on computer storage media, for performing a kNN computation using a hardware accelerator. One of the methods includes obtaining a set of one or more query vectors; obtaining a set of database vectors; and performing, on a hardware accelerator and for each query vector in the set, a search for the k most similar database vectors to the query vector, comprising: computing, by circuitry of the hardware accelerator and for each query vector, a respective similarity value between the query vector and each database vector; and for each query vector, identifying, by the hardware accelerator and for each bin, (i) an index of the most similar database vector within the bin and (ii) the respective similarity value for the most similar database vector within the bin.
Description
- This application claims priority to U.S. Provisional Application No. 63/355,542, filed on Jun. 24, 2022. The disclosure of the prior application is considered part of and is incorporated by reference in the disclosure of this application.
- This specification generally relates to performing a k nearest neighbor (kNN) computation on a hardware accelerator.
- A kNN computation is a computation that receives a query vector and a set of database vectors and searches for the k database vectors that are most similar to the query vector according to some similarity measure.
- This specification describes a system implemented as computer programs on one or more computers in one or more locations that performs a k nearest neighbor (kNN) computation.
- The system performs the kNN computation by receiving a set of query vectors and a set of database vectors and, for each query vector, searching for the k database vectors that are most similar to the query vector according to some similarity measure.
- For some similarity measures, e.g., Euclidean distance or other distance measures, the most similar database vectors are those that are closest to the query vector (have the smallest similarity measure with the query vector). For some other similarity measures, e.g., inner product, the most similar database vectors are those that have the largest similarity measure with the query vector.
- K can generally be any positive integer, i.e., any integer greater than or equal to one, but is generally much smaller than the total number of database vectors in the set. For example, if there are a million database vectors, the value of k can be less than two thousand and, in some cases, can be less than one hundred, less than fifty, or less than fifteen.
- More specifically, this specification describes how the kNN computation can be performed efficiently by a hardware accelerator that has circuitry that is configured to perform matrix multiplication in hardware. As a particular example, the hardware accelerator can be a machine learning accelerator like a graphics processing unit (GPU), a tensor processing unit (TPU), or a different type of accelerator that has special-purpose hardware for performing various linear algebra computations.
- The subject matter described in this specification can be implemented in particular embodiments so as to realize one or more of the following advantages.
- This specification describes techniques for performing a kNN computation on a hardware accelerator, e.g., a machine learning accelerator or other accelerator that includes special purpose hardware for performing linear algebra operations, e.g., matrix multiplication.
- In particular, the described algorithm for performing the KNN computation achieves peak performance on the target accelerator, e.g., on a TPU or a GPU, and outperforms state-of-the-art accelerator-based kNN algorithms with a similar level of recall. That is, given a target recall, the described algorithm outperforms, e.g., in terms of computational efficiency, state-of-the-art accelerator-based kNN algorithms that achieve the same target recall. For example, for a given recall, the described techniques can achieve state of the art results in terms of computation time when deployed on a suitable hardware accelerator.
- In particular, as will be described in more detail below, the described techniques can achieve this state-of-the-art performance by minimizing the number of coefficient-wise operations (COPs) that are required to be performed as part of the search.
- The details of one or more embodiments of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
-
FIG. 1 shows an example system for performing a kNN computation. -
FIG. 2 illustrates an example process for performing a kNN computation. -
FIG. 3 illustrates an example process for identifying the most similar database vectors within each bin. -
FIG. 4 shows the performance of the described techniques relative to existing techniques. - Like reference numbers and designations in the various drawings indicate like elements.
-
FIG. 1 shows anexample system 100 for performing a k-nearest neighbor (kNN) search computation. - Performing a kNN search has a wide range of applications in machine learning and information retrieval systems.
- Some examples of systems that make use of kNN search include image search systems, semantic textual retrieval systems, anomaly detection systems, recommendation systems, and, more generally, any of a variety of systems that serve as a component for downstream tasks.
- Thus, accurately performing the kNN search can be important to the performance of a variety of machine learning and information retrieval systems.
- However, given the large number of vectors that need to be searched in many real-world, industrial use cases, the kNN search can be computationally expensive and in some cases can bottleneck the performance computational efficiency of the machine learning or information retrieval system due to excessive latency, excessive memory usage, and so on.
- To alleviate these issues, the
system 100 performs the kNN search in a computationally efficient manner while still maintaining a high degree of accuracy. - To perform the computation, the
system 100 receives a set ofquery vectors 104 and a set ofdatabase vectors 108 and, for eachquery vector 104, searches for thek database vectors 108 that are most similar to thequery vector 104 according to some similarity measure. - The
query vectors 104 and thedatabase vectors 108 generally have the same dimensionality, i.e., each query vector q and each database vector x have the same number of entries D. - For some similarity measures, e.g., Euclidean distance or other distance measures, the most similar database vectors are those that are closest to the query vector (have the smallest similarity measure with the query vector).
- For some other similarity measures, e.g., inner product, the most similar database vectors are those that have the largest similarity measure with the query vector.
- K can generally be any positive integer, i.e., any integer greater than or equal to one, but is generally much smaller than the total number N of database vectors in the set.
- Thus, the
system 100 identifies, as theoutput 112 of the kNN computation, a respective set of k database vectors for eachquery vector 104 and provides theoutput 112 to, e.g., a downstream system from which thequery vectors 104 were received. - In some cases, the
system 100 provides the sets of k database vectors as output. - In some other cases, the
system 100 provides data identifying the k database vectors as output, e.g., by providing the indices of the k database vectors within the set of database vectors. - In yet other cases, the
system 100 can provide anoutput 112 that identifies more than k database vectors for each query vector and the downstream system can further refine the database vectors identified in theoutput 112 to generate the k database vectors for each query vector. - More specifically, the
system 100 performs the kNN computation efficiently using ahardware accelerator 120 that hascircuitry 130 that is configured to perform matrix multiplication in hardware. In other words, thehardware accelerator 120 is a special-purpose computer chip that hascircuitry 130 that performs matrix multiplication in hardware. - For example, the
hardware accelerator 120 can be a machine learning accelerator like a graphics processing unit (GPU), a tensor processing unit (TPU), or a different type of accelerator that has special-purpose hardware for performing various linear algebra computations. - As a particular example, the
hardware accelerator 120 can be a TPU or other accelerator that includes a systolic array circuit for performing multiplication in hardware. For example, the systolic array can be an array of multiply accumulate units (MACs) that performs matrix multiplication in hardware using any of a variety of computation paradigms, e.g., output stationary or input stationary computation. - As a particular example, the
hardware accelerator 120 can be a GPU or other accelerator that includes a tensor core circuit for performing multiplication in hardware. - Generally, the
hardware accelerator 120 can perform certain floating point operations that are accelerated by dedicated circuitry (“hardware”) on the accelerator. One example of these floating point operations is, as described above, matrix multiplication. - The performance of the
accelerator 120 is therefore in part bounded by the arithmetic intensity of these floating point operations and the peak memory bandwidth of theaccelerator 120. - The
hardware accelerator 120 can also perform other coefficient-wise operations (COPs)—examples of such operations include vectorized add operations, multiply operations, compare operations, conditional-move operations, and so on. However, these COPs are generally computationally expensive for the accelerator to perform for a variety of reasons, e.g., because they require processing additional instructions in addition to the matrix multiplication instructions that are required to perform multiplication and only a limited number of additional instructions are available before a lack of instruction bandwidth bottlenecks the performance of the accelerator. - The performance of the
accelerator 120 is therefore also bounded by the instruction throughput intensity, which is the ratio of floating point operations to COPs. In particular, having COPs per floating point operation can allow theaccelerator 120 to achieve better performance on a given computational workload because it reduces the likelihood that instruction bandwidth will serve as a bottleneck. - The
system 100 performs the KNN search in a manner that optimizes the performance of the kNN search by minimizing the number of COPs that are required to be performed as part of the search. - In other words, the
system 100 uses theaccelerator 120 to perform the search in a manner that accounts for the limited coefficient-wise instruction bandwidth of thehardware accelerator 120 and prevents this limited bandwidth from bottlenecking the efficiency of the search. - Performing the search using the
hardware accelerator 120 is described in more detail below with reference toFIGS. 2 and 3 . -
FIG. 2 illustrates anexample process 200 for performing a kNN computation. For example, a system, e.g., thesystem 100 ofFIG. 1 , appropriately programmed, can perform theprocess 200. - The system obtains a set of one or more query vectors (step 202).
- The system obtains a set of database vectors (step 204). Each database vector has a respective index, i.e., a respective identifier that uniquely identifies the database vector within the set.
- Generally, the database vectors are partitioned into a plurality of bins based on the indices, i.e., such that each bin is made up of a set of database vectors that have consecutive indices.
- In some implementations, the system selects the total number of bins. For example, the system can select the total number of bins based on a target recall for the kNN search, with larger numbers of bins resulting in a higher recall and smaller number of bins resulting in a lower recall.
- In some other implementations, the system receives the total number of bins as input.
- The system performs, on a hardware accelerator and for each query vector in the set, a search for the k most similar database vectors to the query vector according to a similarity measure (step 206).
- The similarity measure can be any appropriate similarity measure and can be specified by the request for the kNN search or can be predetermined. Examples of similarity measures include inner product similarity, cosine similarity, and Euclidean distance.
- In particular, as part of the search, the system computes, by the circuitry of the hardware accelerator and for each query vector, a respective similarity value between the query vector and each database vector according to the similarity measure.
- In particular, the system can compute the similarity values at least in part by computing, by circuitry of the hardware accelerator and for each query vector, a respective dot product between the query vector and each database vector. In particular, the system can compute these dot products using the matrix multiplication circuitry of the accelerator.
- As a particular example, the system can compute the respective dot products using vectorized fused-multiply-add operations performed by the circuitry of the hardware accelerator. A fused-multiply-add operation is a floating-point multiply-add operation performed in one step, with a single rounding.
- That is, where an unfused multiply-add that attempts to compute the expression a+(b×c) would compute the product of b and c, round the product to a specified number of significant bits, add the result to a, and round back to the specified number of significant bits, a fused multiply-add computes the entire expression, i.e., a+(b×c), to its full precision before rounding the final result down to N significant bits.
- The fused-multiply-add operation is referred to as “vectorized” because the hardware accelerator performs at least a portion of the operation in parallel for each of the plurality of pairs rather than, e.g., performing the operation sequentially by iterating through a loop. For example, the accelerator can perform the multiplication operations as an element-wise operation between the two vectors and then accumulate the results, both using the multiplication circuitry of the accelerator, e.g., using a set of MACs of a systolic array.
- For each query vector, the system identifies, by the hardware accelerator and for each bin, (i) an index of the most similar database vector within the bin and (ii) the respective similarity value for the most similar database vector within the bin.
- Thus, if there are L bins, the system identifies L most similar database vectors, with each being the most similar database vector within the corresponding bin. Thus, the system collects the top-1 similarities for each of the L bins. Thus, the larger the number of bins, the larger the expected recall of the algorithm, i.e., because the likelihood that the second most similar database vector is one of the top k most similar database vectors across all of the bins decreases as the number of vectors per bin decreases.
- Identifying the most similar database vectors within the bin is described below with reference to Table 1 and
FIG. 3 . -
TABLE 1 Algorithm 1: PartialReduce for MIPS Input: Q ∈ RM × D Batch queries Input: X ∈ RN × D Database Input: 2W Bin size Output: V ∈ RM × L Top-K values Output: A ∈ NM × L Top-K indices 1 for i ← 1 to M do 2 | for j ← 1 to N do 3 | | 4 | | /* Unrolled and does not cost COP */ 5 | | b ← /* COP 1: Vectorized compare */ 6 | | /* COP 2: Vectorized conditional move */ 7 | | /* COP 3: Vectorized conditional move */ 8 | end 9 end - Table 1 shows an example of algorithm pseudo-code for performing the kNN search on an accelerator as described above.
- As shown in Algorithm 1, the system iterates through the M query vectors and, for each query vector i, uses the ShiftRight operation to identify the bin Z to which a given database vector j belongs. The system then uses vectorized conditional moves to determine whether to update a first value a and second value v for the query vector i and for the identified bin/based on a similarity b between the query vector i and the database vector j.
- This is described in more detail below.
- As can be seen from Table 1, the described technique requires only three COPs for each floating point dot product, which allows the system to avoid bottlenecks due to the limited coefficient-wise instruction bandwidth of the accelerator and maintain high computational efficiency of the search.
- In some implementations, the system further optimizes the algorithm shown in Table 1 to exploit temporal and spatial locality when making use of the accelerator memory, e.g., of an on-chip cache of the hardware accelerator.
- This further optimization will be described in more detail below with reference to Table 2.
- The system then provides an output of the kNN search (step 208).
- In some implementations, the system provides the L most similar database vectors as the output of the kNN search. For example, if L is larger than k, the system can provide an output identifying the L most similar database vectors to the system from which the query vectors were received and the other system can refine the L most similar database vectors to a final set of k database vectors.
- In some other implementations, the system further refines the L most similar database vectors. In particular, the system can select, by the hardware accelerator, k database vectors from the L most similar database vectors within the plurality of bins.
- In particular, the system can sort the most similar database vectors within the plurality of bins based on the respective similarity measures to generate a sorted list of the most similar database vectors. For example, the system can perform a bitonic sort of the most similar database vectors within the plurality of bins to generate the sorted list.
- The system then performs a truncation on the sorted list of the most similar database vectors to identify the k most similar database vectors from the sorted most similar database vectors. That is, the system truncates the sorted list to include only the first k database vectors in the sorted list.
- The system can then provide data identifying the first k database vectors as the output of the kNN computation.
-
FIG. 3 illustrates anexample process 300 for identifying the most similar database vectors within the plurality of bins. For example, a system, e.g., thesystem 100 ofFIG. 1 , appropriately programmed, can perform theprocess 300. - The system initializes, for each bin and for each query vector, a first value that identifies the index of the most similar database vector within the bin and a second value identifying the respective similarity measure for the most similar database vector within the bin (step 302). Thus, the system maintains, for each query vector, a respective first value for each bin that identifies the index of the most similar database vector within the bin to the query vector and a respective second value for each bin that represents the most similar database vector identified by the respective first value for the bin.
- The system then repeatedly performs
steps 304 through 308 to update the first and second values for the bins. For example, the system can performsteps 304 through 308 until the system has iterated through each database vector for each query vector. - After repeatedly performing steps 304-308, the system returns, for each query vector and for each bin, (i) an index of the most similar database vector within the bin by returning the first value for the query vector for the bin and (ii) the respective similarity value for the most similar database vector within the bin by returning the second value for the query vector for the bin.
- At each iteration of steps 304-308, the system operates on a plurality of query vector-database vector pairs. For example, the plurality of pairs can be some or all of the pairs corresponding to the current inner iteration of Algorithm 2 that is shown in Table 2 below.
- The system performs a vectorized compare operation to determine, for each of the plurality of query vector-database vector pairs, whether the similarity measure between the pair indicates that the pair is more similar than the most similar database vector identified by the first value for the query vector in the pair and for the bin to which the database vector in the pair belongs (step 304).
- That is, the vectorized compare operation compares, for each query vector-database vector pair, the similarity measure between the pair to the similarity between the query vector in the pair and the most similar database vector identified by the first value for the query vector in the pair and for the bin to which the database vector in the pair belongs.
- The compare operation is referred to as “vectorized” because the hardware accelerator performs the compare operation in parallel for each of the plurality of pairs rather than, e.g., performing the compare operation by iterating through a loop. For example, the accelerator can perform the compare operation as an element-wise operation between two vectors. In this case, one vector is a vector of similarities for the query vector-database vector pairs and the other vector is a vector of similarities for the query vector—most similar vector pairs.
- The system then performs one or more first vectorized conditional move operations (step 306) to, for each of the plurality of query vector-database vector pairs, update the first value for the query vector in the pair and for the bin to which the database vector in the pair belongs to identify the database vector in the pair only if the similarity measure between the pair indicates that the pair is more similar than the most similar database vector identified by the first value for the query vector and for the bin to which the database vector in the pair belongs.
- The move operation is referred to as “conditional” because the hardware accelerator only updates (or overwrites) a given stored first value for a given pair if the similarity measure between the pair indicates that the pair is more similar than the most similar database vector identified by the given first value. If the similarity measure between the pair does not indicate that the pair is more similar, the accelerator does not modify the stored first value.
- The system also performs one or more second vectorized conditional move operations (step 308) to, for each of the plurality of query vector-database vector pairs, update the second value for the query vector and for the bin to which the database vector in the pair belongs to be equal to the similarity measure between the pair only if the similarity measure between the pair indicates that the pair is more similar than the most similar database vector identified by the first value for the query vector and for the bin to which the database vector in the pair belongs.
- As above, the hardware accelerator only updates (or overwrites) a given stored second value for a given pair if the similarity measure between the pair indicates that the pair is more similar than the given second value. If the similarity measure between the pair does not indicate that the pair is more similar, the accelerator does not modify the stored second value.
- As described above, in some implementations, the system further optimizes the algorithm shown above in Table 1 to exploit temporal and spatial locality when making use of the accelerator cache.
- This further optimization will be described is shown in Table 2.
-
TABLE 2 Algorithm 2: Detailed PartialReduce kernel for MIPS Input: Q ∈ RM × D Batch queries Input: X ∈ RN × D Database Input: 2W Bin size Output: V ∈ RM × L Top-K values Output: A ∈ NM × L Top-K indices /* Block iteration over */ 1 for ii ← 1 to M step ib do | /* Block iteration over columns */ 2 | for jj ← 1 to N step jb do | | /* i, j, k and */ 3 | | for | | | /* Starts the inner loop of the systolic arrays */ 4 | | | y 5 | | | for k ← 6 | | | | m ← | | | | /* Vectorized FMA (fused-multiply-add) */ 7 | | | | for j ← jj to jj + jb − 1 do 8 | | | | | 9 | | | | end 10 | | | end | | | /* Ends the inner loop of the systolic arrays */ 11 | | | for j ← jj to jj + jb − 1 do | | | | /* The exact j */ 12 | | | | 13 | | | | b ← */ 14 | | | | */ 15 | | | | */ 16 | | | end 17 | | end 18 | end 19 end - As shown in Table 2, the set of query vectors includes a plurality of query vectors that are partitioned into a plurality of query blocks.
- Each query block includes a respective plurality of query vectors and the system performs the search by searching for the query vectors in a respective query block at each of a plurality of outer iterations. That is, each outer iteration corresponds to a different query block.
- At each outer iteration, the system computes, by the circuitry of the hardware accelerator and for each query vector in the query block for the outer iteration, a respective similarity value between the query vector and each database vector according to the similarity measure. That is, the system can perform the computation of the similarity values using vectorized FMA operations, e.g., using the systolic array, as described above.
- For each query vector in the query block for the outer iteration, the system then identifies, by the hardware accelerator and for each bin, (i) an index of the most similar database vector within the bin and (ii) the respective similarity value for the most similar database vector within the bin, e.g., as described above with reference to
FIG. 3 . - Moreover, the set of database vectors can further be partitioned into a plurality of chunks. Each chunk includes a respective plurality of database vectors and each outer iteration includes a respective inner iteration for each of the plurality of chunks.
- To perform a given inner iteration, the system computes, by the circuitry of the hardware accelerator and for each query vector in the query block for the outer iteration, a respective similarity value between the query vector and each database vector in the chunk corresponding to the inner iteration according to the similarity measure. That is, the system can perform the computation of the similarity values using a vectorized FMA operation, e.g., using the systolic array, as described above.
- For each query vector in the query block for the outer iteration and for each database vector in the chunk for the inner iteration, the system then identifies, by the hardware accelerator and for each bin to which at least one of the database vectors in the chunk belongs, (i) an index of the most similar database vector within the bin and (ii) the respective similarity value for the most similar database vector within the bin, e.g., as described above with reference to
FIG. 3 . - Thus, the system exploits temporal locality by reusing previously accessed items. In particular, the system iterates by blocks of queries. The block of queries is reused in the inner loops, achieving the temporal locality.
- The system exploits spatial locality by accessing items nearby previously accessed items. The block iteration loads a chunk of database vectors to achieve this optimization.
- In some cases, the same block iteration structure may apply recursively for multiple cache hierarchies till the register level.
- As described above, the inner loops (indexed by i, j, and kin line 3 of Table 2) are unrolled or vectorized so that every cycle can produce multiple results via SIMD (Single Instruction Multiple Data) instructions or systolic arrays.
- In some cases, the operations of the
processes processes -
FIG. 4 shows an example 400 of the performance of the described techniques relative to existing techniques. - As shown in
FIG. 4 , given a target level of recall, the described techniques outperform conventional approaches. - In particular,
FIG. 4 shows plots of the speed-recall trade-off on two data sets: Glove1.2M and Sift1M. Thus, up and to the right corresponds to improved performance, i.e., an ideal algorithm would be in the upper right hand corner of each of the two plots and have a recall of 1 and a QPS of 700,000. - Each plot shows the performance of two variants of the described techniques, one deployed on a TPUv3 chip and the other deployed on a TPUv4 chip. Each plot also shows the performance of three high-performing conventional approaches on a GPU V100 and on a GPU A100.
- As can be seen from
FIG. 4 , for both data sets, both variants the described techniques outperform all six of the conventional approaches. - Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non transitory program carrier for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, which is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them.
- The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output(s). The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array), an ASIC (application specific integrated circuit), or a GPGPU (General purpose graphics processing unit).
- Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit. Generally, a central processing unit will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices.
- Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
- Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
- Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.
Claims (20)
1. A method comprising:
obtaining a set of one or more query vectors;
obtaining a set of database vectors, wherein each database vector has a respective index, and wherein the database vectors are partitioned into a plurality of bins based on the indices; and
performing, on a hardware accelerator and for each query vector in the set, a search for the k most similar database vectors to the query vector according to a similarity measure, comprising:
computing, by circuitry of the hardware accelerator and for each query vector, a respective similarity value between the query vector and each database vector according to the similarity measure; and
for each query vector, identifying, by the hardware accelerator and for each bin, (i) an index of the most similar database vector within the bin and (ii) the respective similarity value for the most similar database vector within the bin.
2. The method of claim 1 , wherein the circuitry of the hardware accelerator that is used to compute the respective similarity values comprises a systolic array circuit for performing multiplication in hardware.
3. The method of claim 2 , wherein the hardware accelerator is a tensor processing unit (TPU).
4. The method of claim 1 , wherein the hardware accelerator is a graphics processing unit (GPU).
5. The method of claim 4 , wherein the circuitry of the hardware accelerator that is used to compute the respective similarity values is a tensor core circuit for performing multiplication in hardware.
6. The method of claim 1 , wherein the similarity measure is an inner product, a cosine similarity, or a Euclidean distance.
7. The method of claim 1 , further comprising:
providing data identifying the most similar database vectors within the plurality of bins as an output of the search.
8. The method of claim 1 , further comprising:
selecting, by the hardware accelerator, k database vectors from the most similar database vectors within the plurality of bins.
9. The method of claim 8 , wherein selecting, by the hardware accelerator, k database vectors from the most similar database vectors within the plurality of bins comprises:
sorting the most similar database vectors within the plurality of bins based on the respective similarity measures to generate a sorted list of the most similar database vectors; and
performing a truncation on the sorted list of the most similar database vectors to identify k most similar database vectors from the sorted most similar database vectors.
10. The method of claim 1 , wherein computing, by circuitry of the hardware accelerator and for each query vector, a respective similarity value between the query vector and each database vector according to the similarity measure comprises:
computing, by circuitry of the hardware accelerator and for each query vector, a respective dot product between the query vector and each database vector.
11. The method of claim 10 , wherein computing, by circuitry of the hardware accelerator and for each query vector, a respective dot product between the query vector and each database vector comprises:
computing the respective dot products using vectorized fused-multiply-add operations performed by the circuitry of the hardware accelerator.
12. The method of claim 1 , wherein the set of query vectors includes a plurality of query vectors that are partitioned into a plurality of query blocks that each comprise a respective plurality of query blocks, wherein the search is performed by searching for a respective query block at each of a plurality of outer iterations, and wherein each outer iteration comprises:
computing, by the circuitry of the hardware accelerator and for each query vector in the query block for the outer iteration, a respective similarity value between the query vector and each database vector according to the similarity measure; and
for each query vector in the query block for the outer iteration, identifying, by the hardware accelerator and for each bin, (i) an index of the most similar database vector within the bin and (ii) the respective similarity value for the most similar database vector within the bin.
13. The method of claim 12 , wherein the set of database vectors are partitioned into a plurality of chunks, each chunk comprising a respective plurality of database vectors, and wherein each outer iteration comprises a respective inner iteration for each of the plurality of chunks, and wherein each inner iteration comprises:
computing, by the circuitry of the hardware accelerator and for each query vector in the query block for the outer iteration, a respective similarity value between the query vector and each database vector in the chunk corresponding to the inner iteration according to the similarity measure.
14. The method of claim 1 , wherein, for each query vector, identifying, by the hardware accelerator and for each bin, (i) an index of the most similar database vector within the bin and (ii) the respective similarity value for the most similar database vector within the bin comprises:
for each bin and for each query vector, initializing a first value identifying the index of the most similar database vector within the bin and a second value identifying the respective similarity measure for the most similar database vector within the bin; and
repeatedly performing operations comprising:
performing a vectorized compare operation to determine, for each of a plurality of query vector-database vector pairs, whether the similarity measure between the pair indicates that the pair is more similar than the most similar database vector identified by the first value for the query vector in the pair and for the bin to which the database vector in the pair belongs;
performing one or more first vectorized conditional move operations to, for each of the plurality of query vector-database vector pairs, update the first value for the query vector in the pair and for the bin to which the database vector in the pair belongs to identify the database vector in the pair only if the similarity measure between the pair indicates that the pair is more similar than the most similar database vector identified by the first value for the query vector and for the bin to which the database vector in the pair belongs; and
performing one or more second vectorized conditional move operations to, for each of the plurality of query vector-database vector pairs, update the second value for the query vector and for the bin to which the database vector in the pair belongs to be equal to the similarity measure between the pair only if the similarity measure between the pair indicates that the pair is more similar than the most similar database vector identified by the first value for the query vector and for the bin to which the database vector in the pair belongs.
15. A system comprising one or more computers and one or more storage devices storing instructions that when executed by the one or more computers cause the one or more computers to perform operations comprising:
obtaining a set of one or more query vectors;
obtaining a set of database vectors, wherein each database vector has a respective index, and wherein the database vectors are partitioned into a plurality of bins based on the indices; and
performing, on a hardware accelerator and for each query vector in the set, a search for the k most similar database vectors to the query vector according to a similarity measure, comprising:
computing, by circuitry of the hardware accelerator and for each query vector, a respective similarity value between the query vector and each database vector according to the similarity measure; and
for each query vector, identifying, by the hardware accelerator and for each bin, (i) an index of the most similar database vector within the bin and (ii) the respective similarity value for the most similar database vector within the bin.
16. The system of claim 15 , the operations further comprising:
providing data identifying the most similar database vectors within the plurality of bins as an output of the search.
17. The system of claim 15 , the operations further comprising:
selecting, by the hardware accelerator, k database vectors from the most similar database vectors within the plurality of bins.
18. The system of claim 17 , wherein selecting, by the hardware accelerator, k database vectors from the most similar database vectors within the plurality of bins comprises:
sorting the most similar database vectors within the plurality of bins based on the respective similarity measures to generate a sorted list of the most similar database vectors; and
performing a truncation on the sorted list of the most similar database vectors to identify k most similar database vectors from the sorted most similar database vectors.
19. The system of claim 15 , wherein computing, by circuitry of the hardware accelerator and for each query vector, a respective similarity value between the query vector and each database vector according to the similarity measure comprises:
computing, by circuitry of the hardware accelerator and for each query vector, a respective dot product between the query vector and each database vector.
20. One or more non-transitory computer-readable storage media storing instructions that when executed by one or more computers cause the one or more computers to perform operations comprising:
obtaining a set of one or more query vectors;
obtaining a set of database vectors, wherein each database vector has a respective index, and wherein the database vectors are partitioned into a plurality of bins based on the indices; and
performing, on a hardware accelerator and for each query vector in the set, a search for the k most similar database vectors to the query vector according to a similarity measure, comprising:
computing, by circuitry of the hardware accelerator and for each query vector, a respective similarity value between the query vector and each database vector according to the similarity measure; and
for each query vector, identifying, by the hardware accelerator and for each bin, (i) an index of the most similar database vector within the bin and (ii) the respective similarity value for the most similar database vector within the bin.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US18/341,697 US20230418797A1 (en) | 2022-06-24 | 2023-06-26 | Approximate k nearest neighbors on hardware accelerators |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202263355542P | 2022-06-24 | 2022-06-24 | |
US18/341,697 US20230418797A1 (en) | 2022-06-24 | 2023-06-26 | Approximate k nearest neighbors on hardware accelerators |
Publications (1)
Publication Number | Publication Date |
---|---|
US20230418797A1 true US20230418797A1 (en) | 2023-12-28 |
Family
ID=89322964
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US18/341,697 Pending US20230418797A1 (en) | 2022-06-24 | 2023-06-26 | Approximate k nearest neighbors on hardware accelerators |
Country Status (1)
Country | Link |
---|---|
US (1) | US20230418797A1 (en) |
-
2023
- 2023-06-26 US US18/341,697 patent/US20230418797A1/en active Pending
Similar Documents
Publication | Publication Date | Title |
---|---|---|
Baranchuk et al. | Revisiting the inverted indices for billion-scale approximate nearest neighbors | |
Liu et al. | Discretely coding semantic rank orders for supervised image hashing | |
Garcia et al. | K-nearest neighbor search: Fast GPU-based implementations and application to high-dimensional feature matching | |
US8583896B2 (en) | Massively parallel processing core with plural chains of processing elements and respective smart memory storing select data received from each chain | |
CN107341507B (en) | GPU and cascade hash based rapid image SIFT feature matching method | |
Ji et al. | Min-max hash for jaccard similarity | |
US11392596B2 (en) | Efficient inner product operations | |
KR102305568B1 (en) | Finding k extreme values in constant processing time | |
Kim et al. | Sequential spectral learning to hash with multiple representations | |
Shi et al. | A group testing framework for similarity search in high-dimensional spaces | |
CN105488176A (en) | Data processing method and device | |
Peng et al. | Optimizing fpga-based accelerator design for large-scale molecular similarity search (special session paper) | |
Wu et al. | Efficient inner product approximation in hybrid spaces | |
US20230418797A1 (en) | Approximate k nearest neighbors on hardware accelerators | |
US11645292B2 (en) | Efficient similarity search | |
Mu et al. | Accelerated large scale optimization by concomitant hashing | |
Zhang et al. | Anisotropic additive quantization for fast inner product search | |
EP3115909A1 (en) | Method and apparatus for multimedia content indexing and retrieval based on product quantization | |
Liu et al. | Ternary hashing | |
Pham | Hybrid LSH: faster near neighbors reporting in high-dimensional space | |
Ding et al. | Efficient model-based collaborative filtering with fast adaptive PCA | |
KR20220054220A (en) | A method and system for topk operation | |
Antaris et al. | In-memory stream indexing of massive and fast incoming multimedia content | |
US20230153232A1 (en) | Distributed top k computation | |
Chiu et al. | Effective product quantization-based indexing for nearest neighbor search |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:CHERN, FELIX REN-CHYAN;HECHTMAN, BLAKE ALAN;DAVIS, ANDREW THOMAS;AND OTHERS;SIGNING DATES FROM 20230712 TO 20230717;REEL/FRAME:064285/0275 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |