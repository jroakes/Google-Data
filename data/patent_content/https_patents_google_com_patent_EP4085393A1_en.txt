EP4085393A1 - Boosting and matrix factorization - Google Patents
Boosting and matrix factorizationInfo
- Publication number
- EP4085393A1 EP4085393A1 EP21719466.1A EP21719466A EP4085393A1 EP 4085393 A1 EP4085393 A1 EP 4085393A1 EP 21719466 A EP21719466 A EP 21719466A EP 4085393 A1 EP4085393 A1 EP 4085393A1
- Authority
- EP
- European Patent Office
- Prior art keywords
- matrix
- generating
- feature
- training
- categorical
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F18/00—Pattern recognition
- G06F18/20—Analysing
- G06F18/24—Classification techniques
- G06F18/241—Classification techniques relating to the classification model, e.g. parametric or non-parametric approaches
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
- G06N20/20—Ensemble learning
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F17/00—Digital computing or data processing equipment or methods, specially adapted for specific functions
- G06F17/10—Complex mathematical operations
- G06F17/16—Matrix or vector computation, e.g. matrix-matrix or matrix-vector multiplication, matrix factorization
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F7/00—Methods or arrangements for processing data by operating upon the order or content of the data handled
- G06F7/76—Arrangements for rearranging, permuting or selecting data according to predetermined rules, independently of the content of the data
- G06F7/78—Arrangements for rearranging, permuting or selecting data according to predetermined rules, independently of the content of the data for changing the order of data flow, e.g. matrix transposition or LIFO buffers; Overflow or underflow handling therefor
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
- G06N5/01—Dynamic search techniques; Heuristics; Dynamic trees; Branch-and-bound
Definitions
- Machine learning is a type of artificial intelligence that aims to teach computers how to leam and act without necessarily being explicitly programmed. More specifically, machine learning is an approach to data analysis that involves building and adapting models, which allow computer executable programs to "learn" through experience. Machine learning involves design of algorithms that adapt their models to improve their ability to make predictions. This is done by first training a machine learning model using historical data (training data) for which the outcome (label) is known, which is called supervised learning. The computer may identify rules or relationships during the training period and leam the learning parameters of the machine learning model. Then, using new inputs, the machine learning model can generate a prediction based on the identified rules or relationships.
- one innovative aspect of the subject matter described in this specification can be embodied in methods including the operations of obtaining, a training dataset including a plurality of training samples, wherein each training sample includes feature variables and one or more output variables; generating, using the training dataset, a first matrix that is a sparse representation of the training dataset wherein generating the first matrix includes: generating a categorical representation of the feature variables based on each numerical feature variable among the feature variables; generating an encoded representation of each categorical feature variable among the feature variables by encoding each categorical feature variable; factorizing the matrix representation of the training dataset to generate one or more matrices including a second matrix; generating a third matrix using (i) the second matrix and (ii) a regularization term; generating a fourth matrix based on (i) the one or more matrices and (ii) the third matrix; representing, each feature of the first matrix using a vector that includes a multiple adjustable parameters; and adjusting values of the adjustable parameters using a combination of
- implementations of this aspect include corresponding apparatus, systems, and computer programs, configured to perform the aspects of the methods, encoded on computer storage devices. These and other implementations can each optionally include one or more of the following features.
- Methods can include a loss function that provides a result corresponding to a given result provided by a particular loss function of the form where R is a residue, y t is the output variable, c is a constant and E is the encoded representation.
- Methods can include generating a categorical representation of the feature variables based on each numerical feature variable that includes: selecting a set of knots; representing the numerical feature as either (i) a weighted sum of embedding, or (ii) a weighted average of the embedding; generating the corresponding weights of the embedding using an interpolation technique; and representing each numerical variable in the first matrix using the corresponding weights.
- Methods can include interpolation techniques for generating the corresponding weights of the embedding comprises spline interpolation.
- Methods can include generating a categorical representation of a set of ordinal features included in the training samples, including: performing a Discrete Fourier Transform (DFT) or Discrete Wavelet Transform (DWT) on the set of ordinal features; and assigning categorical representations to the set of ordinal features based, at least in part, on the DFT or DWT transformation matrix.
- DFT Discrete Fourier Transform
- DWT Discrete Wavelet Transform
- Methods can include adjusting values of the adjustable parameters that includes iteratively generating sequential models to predict a residue of the loss function until a residue of the loss function can no longer be reduced, a measure of model quality meets a quality threshold, or a size of the model has reached a maximum model size threshold.
- Methods can include adjusting values of the adjustable parameters further can further include generating a pseudo residue based on the derivative of the loss function.
- Methods can include training to predict a combined residual value of previously generated models in the sequence of models of each subsequently generated model.
- Methods can further include adjusting values of the adjustable parameters that include adjusting the values of the adjustable parameters iteratively until a size of the model reached a model size threshold based, at least in part, on a memory constraint of a device training or invoking the model.
- adjusting values of the adjustable parameters that include adjusting the values of the adjustable parameters iteratively until a size of the model reached a model size threshold based, at least in part, on a memory constraint of a device training or invoking the model.
- a complex machine learning model can leam intricate relationships in the training data but makes it less favorable for devices with low computational power such as mobile phones, but this new architecture makes it feasible to leam or predict those intricate relationships using low computational power devices, making it more efficient than other machine learning models.
- the delay in inferencing from a complex model using other architectures also makes those other models less favorable for real time applications and critical systems in health and emergency, whereas the architecture discussed herein can be used for real time applications and critical systems in health and emergency.
- models generated using the techniques discussed herein can be many orders of magnitude smaller and faster than a typical neural network model.
- the machine learning model described in this specification also has a higher degree of interpretability compared to other existing machine learning models that further makes it suitable for use in areas such as health where model prediction has to make sense to a human operator, thereby providing an improvement over other machine learning models.
- the machine learning model presented in this document can also be used in a broad range of modelling problems ranging from binary and multi-task classification, regression, and ranking making it favorable for a wide variety of modelling problems, thereby making the present machine learning model more flexible than other machine learning models that are limited in the types of modelling problems to which they can be applied.
- FIG. 1 is a block diagram of an example training system of a machine learning model.
- FIG. 2 is a flow diagram of an example process for generating a first matrix.
- FIG. 3 is a flow diagram of an example process of training the model parameters of the machine learning model.
- FIG. 4 is a block diagram of an example computer system that can be used to perform operations described.
- This document discloses methods, systems, apparatus, and computer readable media on one or more computers in one or more locations that are configured to generate and provide a trained machine learning model in response to training a machine learning model on a set of training data.
- a feature is an individual measurable property or characteristic of a phenomenon being observed.
- Categorical Features Features that are divided into groups. Generally these features take a limited number of possible values based on the groups to which they are assigned.
- Numerical Features Features that can be expressed in numbers, rather than natural language description. Sometimes called quantitative features, numerical features are collected in number form. Numerical features differentiates itself with other number form data types with its ability to carry out arithmetic operations with these numbers. [0025] Ordinal Features: These features are a type of categorical data with a set order or scale to it.
- Spline A function made up of piecewise polynomials that each have a specific interval. The points where two of the piecewise polynomials meet is referred to as control points or knots.
- FIG. 1 shows an example training system 100 of a machine learning model 102.
- the training system 100 is configured to generate and provide a trained machine learning model 102.
- the model 102 is configured to receive an input and to process the input in accordance with current values of a set of machine learning model parameters to generate an output based on the input.
- the model 102 can be configured to receive any kind of data input, including but not limited to image, video, sound, and text data, and to generate any kind of score, prediction, classification, or regression output based on the input.
- the output data may be of the same type or modality as the input data, or different.
- the output generated by the model 102 for a given image may be scores for each of a set of object categories, with each score representing an estimated likelihood that the image depicts an object belonging to the category.
- the output generated by the model 102 for a given Internet resource, document, or portion of a document may be a score for each of a set of topics, with each score representing an estimated likelihood that the Internet resource, document, or document portion is about the topic.
- the output generated by the model 102 may be a score that represents an estimated likelihood that the particular digital component will be clicked on.
- the output generated by the model 102 may be a score for each of a set of recommendations, with each score representing an estimated likelihood that the user will respond favorably to being provided the recommendation.
- the output generated by the model 102 may be a score for each sequence of text among a set of sequences of text in another language, with each score representing an estimated likelihood that the sequence of text in the other language is a proper translation of the input text into the other language.
- the output generated by the model 102 may be a score for each piece of text among a set of pieces of text, with each score representing an estimated likelihood that the piece of text is the correct transcript for the utterance.
- the training dataset 104 includes multiple training examples. Each training example includes one or more features and a corresponding target output.
- the target output corresponding to a training example refers to a preferred, or goal, output of the model 102 in response to processing the one or more features of the training examples.
- the training examples specify sequences of “experience tuples” that characterize the interaction of an agent with an environment over multiple time steps.
- Each experience tuple includes: (i) an observation characterizing a state of an environment at a respective time step, (ii) an action performed by the agent at the respective time step, (iii) a subsequent observation characterizing a subsequent state of the environment at a next time step, and (iv) a reward received as a result of the agent performing the action at the time step.
- the system 100 can receive the training dataset 104 in any of a variety of ways.
- the system 100 can receive the training dataset 104 as an upload from a remote user of the system over a data communication network, e.g., using an application programming interface (API) made available by the system 100.
- API application programming interface
- the system 100 can include a data analysis engine 110.
- the data analysis engine 110 can implement techniques and methods for creating or processing the one or more features of the training examples of the training dataset 104 to create and/or select features to increase the predictive power of the learning algorithm.
- training data for a machine learning model must be presented in a format that allows a model to be built. Whether it is structured (numerical/categorical/nominal) data or unstructured (text, audio, images, video), the model generally accepts a tabular format where training examples form the rows and the features form the columns.
- the training dataset 104 can be defined as having N training examples of the form ...
- the training dataset can be represented using a table or a matrix.
- the use of embeddings is natural for categorical features, but the use of embeddings for numerical features requires a conversion of often continuous values of numerical features to discrete points in feature space. In some implementations, such discrete points are referred to as control points or knots.
- the data analysis engine 110 processes the value of each numerical feature among the one or more features of the training dataset 104 into discrete points using cubic spline interpolation. Cubic spline interpolation can construct new points within the boundaries of a set of known points. These new points are function values of an interpolation function (referred to as spline), which itself consists of multiple cubic piecewise polynomials.
- the value of the numerical feature can be represented by an embedding Y (i.e. a vector in an embedding space) that can be determined by a weighted sum of ⁇ Y k , Y k+i , Y k+2 , Y k+3 ⁇ md ⁇ w k ,w k+1 ,w k+2 ,w k+3 ⁇ .
- the embedding Y can take the following form
- the weights ⁇ w k , w k+1 , w k+2 , w k+3 ] can be computed using the following equations where h 00 (t), h 10 (t), h 01 (t), h 11 (t) are hermite basis function representing a cubic hermite spline interpolating between an interval [x k+1 , x k+2 ⁇ that can be determined using the following equations
- Y h 00 (t) * Y k+1 + h 10 (t) * m k+1 + h 01 (t) * Y k+2 + /VuCt) * m k+2 6
- h 00 (t) 2 * t 3 - 3 * t 2 + 1 7
- h 10 (t) t 3 — 2 * t 2 + t 1
- the data analysis engine 110 can use the weights w k , w k+1 , w k+ 2 , w k+ to represent the embedding of the numerical feature as a weighted sum of 4 embeddings for 4 values chosen independently from x t .
- Those 4 values can be x k , x k+ , X f e and x k+3 .
- Those 4 points are examples of control points or knots.
- the data analysis engine 110 can use equations 13 and 14 in addition to the equations 6-12 mentioned above to calculate weights w 0 , w ⁇ and w 2 to represent the numerical feature x t .
- equations 2, 3 and 4 can take the following form respectively
- the data analysis engine 110 can use the equations 18 and 19 in addition to the equations 6-12 mentioned above to calculate weights w n-2 ,w n-1 and w n to represent the numerical feature x t . 19
- equations 2, 3 and 4 can take the following form respectively
- the data analysis engine 110 can further optimize (e.g., improve or otherwise adjust) the number and location of knots. For example, assume that x i , j is the value of the j-th numerical feature of the i-th training example. Further assume that the observed value for the j-th feature ranges from [min ]. If x i , j is evenly distributed within the range max(x i , j ) ], the data analysis engine
- the data analysis engine 110 can choose knots with equal distances with the range. If x i , j is not distributed evenly within the range, the data analysis engine 110 can choose knots based on the density of the value x i , j . For example, the data analysis engine 110 can select knots based on the quantile of the x i , j distribution which allows for an equal probability for any x i , j to fall between adjacent pairs of knots thereby providing sufficient support to lean the embedding.
- the data analysis engine 110 can optimize the selection of knots using Hadamard Transform (HT) which is a generalization of Fourier Transform (FT).
- HT Hadamard Transform
- FT Fourier Transform
- the data analysis engine 110 can also use Haar Wavelet Transform (HWT) instead of HT.
- HWT Haar Wavelet Transform
- FIG. 2 is a flow diagram of an example process 200 for generating a first matrix.
- the first matrix is referred to as A.
- Operations of the process 200 can be implemented for example by the data analysis engine 110.
- Operations of the process 200 can also be implemented as instructions stored on one or more computer readable media which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of the process 200.
- the training dataset 104 is represented using a tabular format that includes rows and columns where each row is a training example and each column is a feature of the training example. Of course, other appropriate formats could be used.
- the first matrix is a sparse matrix generated by encoding the categorical features of the training dataset 104 using encoding techniques such as one-hot encoding.
- the training dataset 104 can include other types of features (for e.g., numerical and ordinal)
- the data analysis engine can process the numerical and ordinal features and convert them to categorical features according to the methods described above.
- the data analysis engine 110 selects features from the training dataset (202). For example, the data analysis engine 110 can iteratively select a feature from among the one or more features of the training dataset 104 for processing. In other implementations, the data analysis engine 110 can simultaneously select multiple features from the one or more features from the training dataset 104 for processing since the processing of each feature is independent of the processing of the other features thereby consuming less computational time.
- the data analysis engine 110 can determine if the selected feature is a categorical feature (204). For example, the data analysis engine 110 can implement methods known in the art to determine if the selected feature from the training dataset 104 is a categorical feature. If a feature is determined to be categorical, the data analysis engine 110 can go to step 208 of the process 200. If the feature is determined to be not categorical, the data analysis engine 110 can use step 206 of the process 200 to convert the feature into categorical feature.
- the data analysis engine 110 can convert the value of non-categorical features into discrete points in feature space (206). For example, the data analysis engine 110 after determining that a particular feature is not categorical (i.e., the particular feature is numerical), can use cubic spline interpolation method (described above) to convert the value of the particular feature into a weighted average based on the knots. For example, the numerical feature x t can be represented using a k-dimensional embedding V).
- the data analysis engine 110 can generate an encoded representation of the features (208).
- the data analysis engine 110 can use methods such as one-hot encoding to generate an encoded representation of the categorical features.
- one-hot encoding converts categorical features into a vector of ones and zeros depending upon the category of the particular feature. For example, if a particular feature that identifies gender takes values Male and Female, the one-hot encoded representation can have two features such that the first feature of the representation will have a value of one (and the second feature will have a value zero) if the particular feature is a Male. Correspondingly, if the particular feature is female, first feature of the representation will have a value of zero (and the second feature will have a value one).
- step 208 of the process 200 all features in the training dataset are categorical since the features that are not categorical, were processed in the step 206 to generate a categorical representation. It should also be noted that even though the step 208 has been described as using one-hot encoding technique to generate an encoded representation of the categorical features, any appropriate encoding technique can be used for the purpose.
- the data analysis engine 110 can use singular value decomposition (SVD) to decompose the first matrix into one or more matrices.
- SVD singular value decomposition
- A is an n x in matrix such that n > m
- U is an x m orthogonal matrix
- ⁇ is a m x m diagonal matrix (also referred to as the second matrix)
- V is a m x m orthogonal matrix
- the data analysis engine 110 can compute a third matrix ⁇ -1 i.e. the inverse of the matrix ⁇ using a regularization term l.
- equation 24 can be used to compute the inverse of the first matrix (also referred to as a fourth matrix) using equation 25
- the system 100 can further include a training engine 108 that can include one or more processors and is configured to, at each iteration, train the model 102 based on the loss function 106.
- the training engine 108 can train the model 102 by adjusting the values of the model parameters 103 from current values of the model parameters 103 in order to decrease a loss value generated by the loss function 106.
- the data analysis engine 110 can map each feature of the training dataset 104 to an embedding representation of a dimension K that is determined based on the unique values and/or levels (also referred to as cardinality of a feature) of the feature. For example, if the training dataset 104 has N training examples and each training example has M features, then the value of the j-th feature of the i-th training example can be represented using an embedding E i , j of dimension K where E i , j ⁇ R K .
- the machine learning model can predict according to the following equation where C can be a constant that can be defined as
- the training engine 108 can train the machine learning model using K iterations by adjusting the values of the trainable parameters c k and the embedding representation. F or example, during a k-th iteration of the training process, the training engine can calculate the trainable parameters c k and the k-th value of each of the
- a residue for a machine learning model is the difference between the model prediction and the target output.
- the residue for a k-th iteration of the training process can be computed using equations 26 and 27.
- the residue can be represented in the following form where y t is the target output for a sample i.
- the target output for each subsequent training iteration can be the residue from the previous iteration(s).
- the target output y i during the k-th is the residual R k- 1,i calculated using equation 28 in the k-l-th training iteration which logically means that each training iteration tries to leam model parameters based on the residual (also referred to as a prediction error) of the previous training iteration.
- the overdetermined system of N equations can be transformed into logarithmic space, for example, by moving c k to the right side of equation 29, and taking the log of both sides of the resulting equation, as represented by equation 30
- equation 31 can be similar to the formulation of a classical linear regression problem without the intercept in the formulation.
- adding an extra column in the first matrix A can be achieved by adding a categorical feature with a single value to each of the training examples of the training dataset 104.
- the training engine 108 can select the value of c k based on the heuristics described below. c k ) >0 the value of c k can be increased to reduce log(max — c k )
- equation 35 can take the form
- the training engine 108 can use gradient descent algorithm which is a first-order iterative optimization algorithm to find the value of c k that minimizes L(c k ).
- the gradient descent algorithm uses the first derivative of the function L(c k ).
- the first order derivative of the function takes the following form log(R k ._ 1; ⁇ - c k ) Rk-i,i — c k
- the training engine 108 can use newton method or stochastic newton method which are second-order iterative optimization algorithms to find the value of c k that minimizes L(c k ).
- the newton method and stochastic newton method uses the second derivative of the function L(c k ).
- the second order derivative of the function takes the following form
- This technique for optimizing the value of ⁇ c k can differ from the use of a neural net for example, because here, each iteration only has a single unknown, ⁇ c k , making this a single variable optimization problem, whereas a neural network optimization problem can require the processing of millions or billions of variables, and having to find local minimums for hundreds or millions of variables. As such, it is easy to see that this technique for optimizing ⁇ 3 ⁇ 4 provides significant resource and training time reductions relative to neural network optimizations.
- the training engine 108 can directly optimize the cost function using stochastic gradient descent (SGD) algorithm.
- SGD stochastic gradient descent
- the cost function of the machine learning model can have the following form
- the training engine 108 can use coordinate descent algorithm to optimize the trainable parameters.
- the coordinate descent algorithm can calculate a new value of C where the new value C’ can be calculated using
- the training engine 108 can calculate the embedding representation of a value for a particular feature using an overdetermined system.
- the solution X is a K dimensional vector and log ( max(X k , e) ) is the new value for the k-th element in the embedding and e is a small positive number.
- Such an overdetermined system can be represented as follows
- the termination criteria of the training process of the machine learning model 102 can be determined based on the residual after the k-th iteration of the training process. For example, if the iterative optimization methods described above are not able to further minimize the magnitude of the residual, the training process can be terminated and current values of the model parameters including the dimension K, the constant C and all the embedding representations for all features can be considered as final values.
- the termination criteria for the training process can be the machine learning prediction accuracy that can be measured using metrics such as precision, recall, FI score or PR AUC.
- the training engine 108 can terminate the training process when the accuracy of the machine learning model 102 with the current model parameters reached a predetermined threshold.
- f'(v m ) ⁇ We may be able to compress the model parameters ⁇ f'(x 0 ), f'(x i), . . . f'(x m ) ⁇ . i.e. reduce the model size without reducing the quality of the cubic spline fitness. If we consider ⁇ f'( x o) > f'( x i) > ... f'( x m ) ⁇ as a one-dimensional continuous signal sampled at m + 1 points, we may convert the one- dimensional signal into frequency domain using either Hadamard Transform (HT) which is a generalization of Fourier Transform (FT), or Haar Wavelet Transform (HWT) which is one possible wavelet transformation.
- HT Hadamard Transform
- FT Fourier Transform
- HWT Haar Wavelet Transform
- the data analysis engine 110 can transform function / into the frequency domain (denoted as F) using Hadamard transformation.
- the transformation matrix for the Hadamard transformation can take the following form where i . j is a bitwise dot product of the binary representations of the numbers i and j. Since transforming f to F is equivalent to projecting vector ⁇ f'(x 0 ),f'(xi), ...f'(x m ) ⁇ , the following relationship holds
- the training engine 108 can train the machine learning model 102 in the frequency domain. For example, equations 6-12 and 44 can be used to conclude that each Y is a linear combination of all F'(x 0 ), F'(x 1 ), ... F'(x m ). The training engine 108 can then construct the first matrix and calculate the values of F'(x 0 ),F'(xi), ... F'(x m ) directly using equations 31-38.
- each element in the learned embedding is a coefficient of (i.e. the weights in linear combination of) frequencies in frequency domains.
- the training engine 108 can set those element values to 0 to reduce the number of model parameters, model capacity, as well as to avoid overfitting. Compression in the frequency domain may be more efficient.
- the application of regularization can shrink the element values in the learned embedding toward 0.
- the training engine 108 can set those element values to 0 to reduce the number of model parameters, model capacity, as well as to avoid overfitting.
- the data analysis engine 110 can use the hadamard transformation method (explained above) if the features in the training dataset 104 includes ordinal features.
- the number of distinct values of the ordinal features can be padded to increase the number of distinct values to 2 ceillng(log2(m)) : where ceiling (x) returns the smallest integer that is not smaller than x.
- machine learning models can be used for a variety of tasks such as regression, classification and ranking.
- the following section describes how the machine learning model 102 described above can be used for such tasks.
- the data analysis engine 110 can convert N training examples of the training dataset 102 into N*L training examples, where N training examples have a target label 1 and N*(L-1) training examples have a label 0.
- weights can be assigned to the training examples.
- Equation 26 can be reformatted into a dot product of two vectors of dimension K+l where the labels with the largest dot product have the highest likelihood of being the label for the training example x i:1 , ... X iM-1.
- the first of the two vectors can be independent of the possible labels and only related to the values of the features for the i-th training example x i,i> ... x i,M- 1 46
- the second of the two vectors can be the embedding of the label and independent of the values of the features for the i-th training example x i,1 ... x i,M-1
- each training example has features x i,1 ... x i,M-1 and labels l i tl , ... x iitr where (t 1; ... t T ⁇ are tasks.
- the data analysis engine 110 can convert multi-task problem into an equivalent single-task problem by defining a dummy categorical feature vector X m with values ⁇ t 1 , ... t T ⁇ .
- the i-th training example can further be expanded to T training examples as follows
- the training engine 108 can then train the function F according to the techniques and methods described above, to learn a K-dimensional embedding t for each task t which is similar to the multiclass classification problem (described above) where each label has an embedding.
- the predicted result of task t can then be computed using
- learning-to-rank problem can be formulated as a set of item-neutral contextual features ⁇ X 1 , ... X M ⁇ and a set of item-specific features ⁇ X 1 , ... Y N ⁇ .
- N 1
- Y 1 is a categorical feature.
- each training example includes (1) value of contextual features ⁇ X 1 , ... X M ⁇ , (2) value of item-specific features for the first item (y 1,1 , ...y 1,h ⁇ > (3) value of item-specific features for the second item (y 2,i , ... y 2,n ⁇ and (4) label L indicating the order between the two items i.e.
- each query includes (1) the value of contextual features ⁇ x lf ... x M ⁇ and (2) Z items, whose item-specific features have the values (y z,i , ... y z,n ⁇ where z e [1, Z],
- the training engine 108 can define a binary operator between two items, whose result is either true or false based on whether the item on the left-hand- side (LHS) of the operator should be ranked higher than the item on the right-hand-side (RHS) of the operator.
- LHS left-hand- side
- RHS right-hand-side
- the data analysis engine 110 can define two item-specific features to encode the LHS Vs RHS, i.e. ⁇ LHS_Y 1 , ... LHS_Y N ⁇ and ⁇ RHS_Y 1 , ... RFIS_Y N ⁇ where Yi,LHS_Yi and RHSJYi have the same data type and their values have the same semantic.
- the feature set in the machine learning model 102 can be of the form ⁇ X 1 , ... X M , LHS_Y 1 , ... LHS_Y N , RHS_Y 1 , ... RHS_Y N ⁇ of size M + 2 * N features.
- the training engine 108 can process four training examples.
- the training examples are as follows
- the first training example can be the original training example
- the second training example can be a negative example of the first training example with an observation that if the two items are swapped the model 102 prediction should be reversed.
- Training examples 3 and 4 are constraints stating that two similar items should rank the same.
- the training engine 108 can then find the permutation of ⁇ z i, ... z x ⁇ . i.e. ⁇ z[, ... z x ' ⁇ that maximizes the overall reward i.e. F(z ⁇ , zj).
- FIG. 3 is a flow chart of an example process 300 for training a machine learning model.
- Operations of the process 300 can be implemented, for example, by the data analysis engine 110 and the training engine 108 of the system 100 of FIG.1 , or one or more data processing apparatus.
- Operations of the process 300 can also be implemented as instructions stored on a computer readable medium, where execution of the instructions can cause one or more data processing apparatus to perform operations of the process 300.
- the system 100 obtains training dataset that includes a plurality of training samples (302).
- the data analysis engine 110 can receive a training dataset 104.
- the training dataset 104 includes multiple training examples. Each training example includes one or more features and a corresponding target output.
- the target output corresponding to a training example refers to a preferred output of the model 102 in response to processing the one or more features of the training examples.
- the training dataset 104 can be defined as having N training examples of the form ⁇ x N, y i ⁇ ... ⁇ x N, y N ⁇ where x t is a feature vector of the i-th training example and y t is the target output. Since the dimension of the feature vector x t is fixed, the training dataset can be represented using a table or a matrix.
- the data analysis engine 110 generates a first matrix which is a sparse representation of the training dataset (304). For example, the data analysis engine 110 can iteratively select a feature from among the one or more features of the training dataset 104 for processing. The data analysis engine determines if the selected feature is a categorical feature. If the feature is determined to be not categorical, the data analysis engine 110 converts the value of the non-categorical features into discrete points in feature space. For example, the data analysis engine 110 after determining that a particular feature is not categorical (i.e., the particular feature is numerical), uses cubic spline interpolation method to convert the particular feature into discrete points using cubic spline interpolation.
- FFTs Fast Fourier Transforms
- wavelet transforms can be used to train the feature embeddings in the frequency domain to enable better model compression, i.e. to reduce the number of model parameters and to prevent overfitting with regularization.
- FFTs Fast Fourier Transforms
- wavelet transforms can be applied to train in the frequency domain, where the embeddings are the coefficients (i.e. weights) of the linear combination of frequencies.
- the data analysis engine 110 can generate an encoded representation of the features using methods such as one-hot encoding to generate an encoded representation of the categorical features.
- one-hot encoding converts categorical features into a vector of ones and zeros depending upon the category of the particular feature. For example, if a particular feature that identifies gender takes values Male and Female, the one-hot encoded representation will have two features such that the first feature of the representation will have a value of one (and the second feature will have a value zero) if the particular feature is a Male. Correspondingly, if the particular feature is female, first feature of the representation will have a value of zero (and the second feature will have a value one). After encoding each feature of the training dataset 102, the result can be represented using a table or a matrix that is referred to as the first matrix.
- the data analysis engine 110 can factorize the matrix representation of the dataset that is referred to as the first matrix (306).
- the data analysis engine 110 after generating a first matrix, uses singular value decomposition (SVD) to decompose the first matrix into one or more matrices.
- SVD singular value decomposition
- the data analysis engine 110 can generate the third matrix using the second matrix and a regularization term (308). For example, the data analysis engine 110 computes a third matrix ⁇ -1 i.e. the inverse of the matrix ⁇ using a regularization term l.
- the data analysis engine 110 can generate a fourth matrix based on one or more matrices and the third matrix (310). For example, equation 24 can be used to compute the inverse of the first matrix (also referred to as a fourth matrix) using equation 25
- the data analysis engine 110 can represent each feature of the training dataset using a vector that includes a predetermined number of adjustable parameters (312). For example, the data analysis engine 110 maps each feature of the training dataset to an embedding representation of a dimension K that is determined based on the unique values and/or levels (also referred to as cardinality of a feature) of the feature. For example, if the training dataset 104 has N training examples and each training example has M features, then the value of the j-th feature of the i-th training example can be represented using an embedding E,., of dimension K where E t j eR K . It should be noted that for a relatively small cardinality of a feature x ⁇ .
- the data analysis engine 110 can split the feature with relatively high cardinality into features with relatively low cardinality.
- a feature x ⁇ can be split into x j1 , x j2 , . . . X jq .
- the feature x can be represented using q distinct embedding E j .
- the training engine 108 can adjust the values of the adjustable model parameters of the machine learning model 102 (314).
- the adjustment can include iteratively training sequential models to predict a residue of the loss function until the loss can no longer be reduced, a measure model quality meets a quality threshold, or a size of the model has reached a maximum model size threshold (e.g., based on a memory constraint of a device training or invoking the model).
- training engine 108 trains the machine learning model using K iterations by adjusting the values of the trainable parameters c k and the embedding representation.
- the residue for a k-th iteration of the training process can be computed using equations 26 and 27.
- the residue can be represented in the following form where yi is the target output for a sample i.
- each subsequent training model can be trained to predict a combined residual value of previously generated models in the sequence of models.
- the target output for each subsequent training iteration is the residue from the previous iteration(s).
- the training process can generate an overdetermined system of N equation that can be transformed into logarithmic space using the following equation log(R k-1,i - c k ) 31 where R k-1,i — c k > 0 for any 1 £ i £ N.
- the training engine 108 can calculate X using iterative methods, with regularization techniques of choice, e.g. LI regularization (aka Lasso regression), or L2 regularization (aka ridge regression).
- the training engine 108 can select the value of c k based on the heuristics described below, or other appropriate heuristics.
- the training engine 108 can further optimize the selection of c k based on the intuition that by selecting an optimal value for c k , the value of ⁇ A * X — B ⁇ 2 cm be minimized. This can be represented using the function L(c k ) where 35
- the training engine 108 can use gradient descent algorithm which is a first-order iterative optimization algorithm to find the value of c k that minimizes L(c k ).
- the training engine 108 can also use newton method, stochastic newton method which are second-order iterative optimization algorithms to find the value of c k that minimizes L(c k ).
- the training engine 108 can also directly optimize the cost function using stochastic gradient descent (SGD) algorithm.
- SGD stochastic gradient descent
- the training engine 108 can also use coordinate descent algorithm to optimize the trainable parameters.
- the error function can be different from Mean Square Error (MSE).
- MSE Mean Square Error
- the training engine 108 may calculate pseudo residue, i.e. the derivative of the loss function of a real intermediate variable representing the inner product of Ai * X, where rips the row of the first matrix corresponding to the i-th training example.
- B t denote the pseudo residue calculated for the i-th training example.
- the training engine 108 in each of the K steps in the iterative training process, can explicitly represent the intercept of the linear regression result
- the training engine 108 can explicitly define a learning rate, e.g, g. and modify the objective function from to the average value of labels in the training dataset.
- FIG. 4 is block diagram of an example computer system 400 that can be used to perform operations described above.
- the system 300 includes a processor 410, a memory 420, a storage device 430, and an input/output device 440. Each of the components 410, 420, 430, and 440 can be interconnected, for example, using a system bus 450.
- the processor 410 is capable of processing instructions for execution within the system 400. In one implementation, the processor 410 is a single-threaded processor. In another implementation, the processor 410 is a multi-threaded processor.
- the processor 410 is capable of processing instructions stored in the memory 420 or on the storage device 430.
- the memory 420 stores information within the system 400.
- the memory 420 is a computer-readable medium. In one implementation, the memory 420 is a volatile memory unit. In another implementation, the memory 420 is a non-volatile memory unit. [00120]
- the storage device 430 is capable of providing mass storage for the system 400. In one implementation, the storage device 430 is a computer-readable medium. In various different implementations, the storage device 430 can include, for example, a hard disk device, an optical disk device, a storage device that is shared over a network by multiple computing devices (e.g., a cloud storage device), or some other large capacity storage device.
- the input/output device 440 provides input/output operations for the system
- the input/output device 440 can include one or more of a network interface devices, e.g., an Ethernet card, a serial communication device, e.g., and RS-232 port, and/or a wireless interface device, e.g., and 802.11 card.
- the input/output device can include driver devices configured to receive input data and send output data to other input/output devices, e.g., keyboard, printer and display devices 370.
- Other implementations, however, can also be used, such as mobile computing devices, mobile communication devices, set-top box television client devices, etc.
- An electronic document (which for brevity will simply be referred to as a document) does not necessarily correspond to a file.
- a document may be stored in a portion of a file that holds other documents, in a single file dedicated to the document in question, or in multiple coordinated files.
- Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
- Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage media (or medium) for execution by, or to control the operation of, data processing apparatus.
- the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- a computer storage medium can be, or be included in, a computer-readable storage device, a computer- readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Moreover, while a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially-generated propagated signal. The computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
- the term “data processing apparatus” encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations, of the foregoing.
- the apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- the apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross- platform runtime environment, a virtual machine, or a combination of one or more of them.
- the apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.
- a computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment.
- a computer program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code).
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors.
- a processor will receive instructions and data from a read-only memory or a random access memory or both.
- the essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data.
- a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- a computer need not have such devices.
- a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few.
- Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.
- processors and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- a keyboard and a pointing device e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user’s client device in response to requests received from the web browser.
- Embodiments of the subject mater described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes amiddleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject mater described in this specification, or any combination of one or more such back-end, middleware, or front-end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network.
- Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
- LAN local area network
- WAN wide area network
- inter-network e.g., the Internet
- peer-to-peer networks e.g., ad hoc peer-to-peer networks.
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device).
- client device e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device.
- Data generated at the client device e.g., a result of the user interaction
Abstract
Methods, systems, and apparatus, including computer programs encoded on a computer storage medium, for presenting a new machine learning model architecture. In some aspects, the methods include obtaining a training dataset with a plurality of training samples that includes feature variables and output variables. A first matrix is generated using the training dataset which is a sparse representation of the training dataset. Generating the first matrix can include generating a categorical representation of numeric features and an encoded representation of the categorical features. The methods further include generating a second, third and a fourth matrix. Each feature of the first matrix is then represented using a vector that includes a multiple adjustable parameters. The machine learning model can learn by adjusting values of the adjustable parameters using a combination of a loss function the fourth matrix, and the first matrix.
Description
BOOSTING AND MATRIX FACTORIZATION
BACKGROUND
[0001] This specification relates to processing data and machine learning models. [0002] Machine learning is a type of artificial intelligence that aims to teach computers how to leam and act without necessarily being explicitly programmed. More specifically, machine learning is an approach to data analysis that involves building and adapting models, which allow computer executable programs to "learn" through experience. Machine learning involves design of algorithms that adapt their models to improve their ability to make predictions. This is done by first training a machine learning model using historical data (training data) for which the outcome (label) is known, which is called supervised learning. The computer may identify rules or relationships during the training period and leam the learning parameters of the machine learning model. Then, using new inputs, the machine learning model can generate a prediction based on the identified rules or relationships.
SUMMARY
[0003] In general, one innovative aspect of the subject matter described in this specification can be embodied in methods including the operations of obtaining, a training dataset including a plurality of training samples, wherein each training sample includes feature variables and one or more output variables; generating, using the training dataset, a first matrix that is a sparse representation of the training dataset wherein generating the first matrix includes: generating a categorical representation of the feature variables based on each numerical feature variable among the feature variables; generating an encoded representation of each categorical feature variable among the feature variables by encoding each categorical feature variable; factorizing the matrix representation of the training dataset to generate one or more matrices including a second matrix; generating a third matrix using (i) the second matrix and (ii) a regularization term; generating a fourth matrix based on (i) the one or more matrices and (ii) the third matrix; representing, each feature of the first matrix using a vector that includes a multiple adjustable parameters; and adjusting values of the adjustable parameters using a combination of (i) a loss function, (ii) the fourth matrix, and (iii) the first matrix.
[0004] Other implementations of this aspect include corresponding apparatus, systems, and computer programs, configured to perform the aspects of the methods, encoded on
computer storage devices. These and other implementations can each optionally include one or more of the following features.
[0005] Methods can include a loss function that provides a result corresponding to a given result provided by a particular loss function of the form
where R is a residue, yt is the output variable, c is a constant and E is the encoded representation.
[0006] Methods can include generating a categorical representation of the feature variables based on each numerical feature variable that includes: selecting a set of knots; representing the numerical feature as either (i) a weighted sum of embedding, or (ii) a weighted average of the embedding; generating the corresponding weights of the embedding using an interpolation technique; and representing each numerical variable in the first matrix using the corresponding weights.
[0007] Methods can include interpolation techniques for generating the corresponding weights of the embedding comprises spline interpolation.
[0008] Methods can include generating a categorical representation of a set of ordinal features included in the training samples, including: performing a Discrete Fourier Transform (DFT) or Discrete Wavelet Transform (DWT) on the set of ordinal features; and assigning categorical representations to the set of ordinal features based, at least in part, on the DFT or DWT transformation matrix.
[0009] Methods can include adjusting values of the adjustable parameters that includes iteratively generating sequential models to predict a residue of the loss function until a residue of the loss function can no longer be reduced, a measure of model quality meets a quality threshold, or a size of the model has reached a maximum model size threshold. [0010] Methods can include adjusting values of the adjustable parameters further can further include generating a pseudo residue based on the derivative of the loss function. [0011] Methods can include training to predict a combined residual value of previously generated models in the sequence of models of each subsequently generated model.
[0012] Methods can further include adjusting values of the adjustable parameters that include adjusting the values of the adjustable parameters iteratively until a size of the model reached a model size threshold based, at least in part, on a memory constraint of a device training or invoking the model.
[0013] Particular embodiments of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages. For example, the techniques discussed throughout this document can generate a trained machine learning model based on a new model architecture that requires less training and computational resources to train and yet provide high accuracy compared to other machine learning models that are both computationally expensive and require longer training periods. In general, a complex machine learning model can leam intricate relationships in the training data but makes it less favorable for devices with low computational power such as mobile phones, but this new architecture makes it feasible to leam or predict those intricate relationships using low computational power devices, making it more efficient than other machine learning models. The delay in inferencing from a complex model using other architectures also makes those other models less favorable for real time applications and critical systems in health and emergency, whereas the architecture discussed herein can be used for real time applications and critical systems in health and emergency. In fact, models generated using the techniques discussed herein can be many orders of magnitude smaller and faster than a typical neural network model.
[0014] The machine learning model described in this specification also has a higher degree of interpretability compared to other existing machine learning models that further makes it suitable for use in areas such as health where model prediction has to make sense to a human operator, thereby providing an improvement over other machine learning models. The machine learning model presented in this document can also be used in a broad range of modelling problems ranging from binary and multi-task classification, regression, and ranking making it favorable for a wide variety of modelling problems, thereby making the present machine learning model more flexible than other machine learning models that are limited in the types of modelling problems to which they can be applied.
[0015] The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
BRIEF DESCRIPTION OF THE DRAWINGS [0016] FIG. 1 is a block diagram of an example training system of a machine learning model.
[0017] FIG. 2 is a flow diagram of an example process for generating a first matrix.
[0018] FIG. 3 is a flow diagram of an example process of training the model parameters of the machine learning model.
[0019] FIG. 4 is a block diagram of an example computer system that can be used to perform operations described.
DETAILED DESCRIPTION
[0020] This document discloses methods, systems, apparatus, and computer readable media on one or more computers in one or more locations that are configured to generate and provide a trained machine learning model in response to training a machine learning model on a set of training data.
[0021] As used in the specification and claims, the following terms have the following meanings, unless the context of use clearly specifies otherwise:
[0022] Features: A feature is an individual measurable property or characteristic of a phenomenon being observed.
[0023] Categorical Features: Features that are divided into groups. Generally these features take a limited number of possible values based on the groups to which they are assigned.
[0024] Numerical Features: Features that can be expressed in numbers, rather than natural language description. Sometimes called quantitative features, numerical features are collected in number form. Numerical features differentiates itself with other number form data types with its ability to carry out arithmetic operations with these numbers. [0025] Ordinal Features: These features are a type of categorical data with a set order or scale to it.
[0026] Spline: A function made up of piecewise polynomials that each have a specific interval. The points where two of the piecewise polynomials meet is referred to as control points or knots.
[0027] FIG. 1 shows an example training system 100 of a machine learning model 102. The training system 100 is configured to generate and provide a trained machine learning model 102. The model 102 is configured to receive an input and to process the input in accordance with current values of a set of machine learning model parameters to generate an output based on the input. In general, the model 102 can be configured to receive any kind of data input, including but not limited to image, video, sound, and text data, and to generate any kind of score, prediction, classification, or regression output based on the input. The output data may be of the same type or modality as the input data, or different.
Some applications of the model are described below; other applications include use in a machine-control system.
[0028] For example, when the model 102 is configured to process training examples that are images or features that have been extracted from images, the output generated by the model 102 for a given image may be scores for each of a set of object categories, with each score representing an estimated likelihood that the image depicts an object belonging to the category.
[0029] As for another example, if the model 102 is configured to process training examples that are Internet resources (e.g., web pages), documents, or portions of documents or features extracted from Internet resources, documents, or portions of documents, the output generated by the model 102 for a given Internet resource, document, or portion of a document may be a score for each of a set of topics, with each score representing an estimated likelihood that the Internet resource, document, or document portion is about the topic.
[0030] As for another example if the model 102 is configured to process training examples that are features of an impression context for a particular digital component (e.g., audio, video, text, or other information, including information in the form of an advertisement), the output generated by the model 102 may be a score that represents an estimated likelihood that the particular digital component will be clicked on.
[0031] As for another example, if the model 102 is configured to process training examples that are features of a personalized recommendation for a user, e.g., features characterizing the context for the recommendation, e.g., features characterizing previous actions taken by the user, the output generated by the model 102 may be a score for each of a set of recommendations, with each score representing an estimated likelihood that the user will respond favorably to being provided the recommendation.
[0032] As for another example, if the model 102 is configured to process training examples that are sequences of text in one language, the output generated by the model 102 may be a score for each sequence of text among a set of sequences of text in another language, with each score representing an estimated likelihood that the sequence of text in the other language is a proper translation of the input text into the other language.
[0033] As for another example, if the model 102 is configured to process training examples that are sequences representing spoken utterances, the output generated by the model 102 may be a score for each piece of text among a set of pieces of text, with each
score representing an estimated likelihood that the piece of text is the correct transcript for the utterance.
[0034] The training dataset 104 includes multiple training examples. Each training example includes one or more features and a corresponding target output. The target output corresponding to a training example refers to a preferred, or goal, output of the model 102 in response to processing the one or more features of the training examples.
[0035] In some implementations, rather than specifying training inputs and corresponding target outputs, the training examples specify sequences of “experience tuples” that characterize the interaction of an agent with an environment over multiple time steps. Each experience tuple includes: (i) an observation characterizing a state of an environment at a respective time step, (ii) an action performed by the agent at the respective time step, (iii) a subsequent observation characterizing a subsequent state of the environment at a next time step, and (iv) a reward received as a result of the agent performing the action at the time step.
[0036] The system 100 can receive the training dataset 104 in any of a variety of ways. For example, the system 100 can receive the training dataset 104 as an upload from a remote user of the system over a data communication network, e.g., using an application programming interface (API) made available by the system 100.
[0037] The system 100 can include a data analysis engine 110. In some implementations, the data analysis engine 110 can implement techniques and methods for creating or processing the one or more features of the training examples of the training dataset 104 to create and/or select features to increase the predictive power of the learning algorithm. In general, training data for a machine learning model must be presented in a format that allows a model to be built. Whether it is structured (numerical/categorical/nominal) data or unstructured (text, audio, images, video), the model generally accepts a tabular format where training examples form the rows and the features form the columns. However, other formats are possible. For the purpose of explanation, the training dataset 104 can be defined as having N training examples of the form ... {xw,yw} where xt is a feature vector of the i-th training example and yt is the target output. Since the dimension of the feature vector xt is fixed, the training dataset can be represented using a table or a matrix.
[0038] The use of embeddings is natural for categorical features, but the use of embeddings for numerical features requires a conversion of often continuous values of numerical features to discrete points in feature space. In some implementations, such
discrete points are referred to as control points or knots. In some implementations, the data analysis engine 110 processes the value of each numerical feature among the one or more features of the training dataset 104 into discrete points using cubic spline interpolation. Cubic spline interpolation can construct new points within the boundaries of a set of known points. These new points are function values of an interpolation function (referred to as spline), which itself consists of multiple cubic piecewise polynomials.
[0039] For the purpose of explanation, consider a training dataset 104 that includes n training examples of one numerical feature x and a target output y. In some implementations, the data analysis engine 110 can quantile legitimate feature value x using any number of knots (for e.g., n+1 knots) such that {(xi , Yi): i = 1, ... n] where Yt is a K- dimensional embedding representation for xi and x0 < x1 < ... < xn.
[0040] In some implementations, for a value of a numerical feature xk+1 + t where 0 < t < X(k+2) — xk+ 1, the value of the numerical feature can be represented by an embedding Y (i.e. a vector in an embedding space) that can be determined by a weighted sum of {Yk, Yk+i, Yk+2, Yk+3} md {wk,wk+1,wk+2,wk+3}. In some implementations, the embedding Y can take the following form
[0041] In some implementations, the weights {wk, wk+1, wk+2, wk+3] can be computed using the following equations
where h00 (t), h10(t), h01(t), h11(t) are hermite basis function representing a cubic hermite spline interpolating between an interval [xk+1, xk+2\ that can be determined using the following equations
Y = h00(t) * Yk+1 + h10(t) * mk+1 + h01(t) * Yk+2 + /VuCt) * mk+2 6 h00(t) = 2 * t3 - 3 * t2 + 1 7 h10(t) = t3 — 2 * t2 + t 1
12
[0042] In some implementations, when the value of a numerical feature xt is within the interval [ xk+1, xk+2] the data analysis engine 110 can use the weights wk, wk+1, wk+ 2, wk+ to represent the embedding of the numerical feature as a weighted sum of 4 embeddings for 4 values chosen independently from xt. Those 4 values can be xk, xk+ , Xfe and xk+3. Those 4 points are examples of control points or knots.
[0043] In some implementations, when the value of a numerical feature xt is within the interval [x0,x0] the data analysis engine 110 can use equations 13 and 14 in addition to the equations 6-12 mentioned above to calculate weights w0, w± and w2 to represent the numerical feature xt.
14
When using equations 13 and 14, the equations 2, 3 and 4 can take the following form respectively
[0044] In some implementations, if the value of a numerical feature xi is within the interval [xn_ v xn], the data analysis engine 110 can use the equations 18 and 19 in addition to the equations 6-12 mentioned above to calculate weights wn-2,wn-1 and wn to represent the numerical feature xt . 19
When using equations 18 and 19, the equations 2, 3 and 4 can take the following form respectively
[0045] In some implementations, the data analysis engine 110 can further optimize (e.g., improve or otherwise adjust) the number and location of knots. For example, assume that xi, j is the value of the j-th numerical feature of the i-th training example. Further assume that the observed value for the j-th feature ranges from [min
]. If xi, j is evenly distributed within the range
max(xi, j) ], the data analysis engine
110 can choose knots with equal distances with the range. If xi, j is not distributed evenly within the range, the data analysis engine 110 can choose knots based on the density of the value xi, j. For example, the data analysis engine 110 can select knots based on the quantile of the xi, j distribution which allows for an equal probability for any xi, j to fall between adjacent pairs of knots thereby providing sufficient support to lean the embedding.
[0046] In some implementations, the data analysis engine 110 can optimize the selection of knots using Hadamard Transform (HT) which is a generalization of Fourier Transform (FT). In other implementations, the data analysis engine 110 can also use Haar Wavelet Transform (HWT) instead of HT. However, explaining the appropriate methods and techniques of how HT and HWT can be used is informed by an understanding of the working of the machine learning model 102. For the purpose of explanation, the following section of the document will present the methods and techniques of training the machine learning model 102.
[0047] FIG. 2 is a flow diagram of an example process 200 for generating a first matrix. To support the formulation of the training process, the first matrix is referred to as A. Operations of the process 200 can be implemented for example by the data analysis engine 110. Operations of the process 200 can also be implemented as instructions stored on one
or more computer readable media which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of the process 200. The training dataset 104 is represented using a tabular format that includes rows and columns where each row is a training example and each column is a feature of the training example. Of course, other appropriate formats could be used.
[0048] In some implementations, the first matrix is a sparse matrix generated by encoding the categorical features of the training dataset 104 using encoding techniques such as one-hot encoding. However, since the training dataset 104 can include other types of features (for e.g., numerical and ordinal), the data analysis engine can process the numerical and ordinal features and convert them to categorical features according to the methods described above.
[0049] The data analysis engine 110 selects features from the training dataset (202). For example, the data analysis engine 110 can iteratively select a feature from among the one or more features of the training dataset 104 for processing. In other implementations, the data analysis engine 110 can simultaneously select multiple features from the one or more features from the training dataset 104 for processing since the processing of each feature is independent of the processing of the other features thereby consuming less computational time.
[0050] The data analysis engine 110 can determine if the selected feature is a categorical feature (204). For example, the data analysis engine 110 can implement methods known in the art to determine if the selected feature from the training dataset 104 is a categorical feature. If a feature is determined to be categorical, the data analysis engine 110 can go to step 208 of the process 200. If the feature is determined to be not categorical, the data analysis engine 110 can use step 206 of the process 200 to convert the feature into categorical feature.
[0051] The data analysis engine 110 can convert the value of non-categorical features into discrete points in feature space (206). For example, the data analysis engine 110 after determining that a particular feature is not categorical (i.e., the particular feature is numerical), can use cubic spline interpolation method (described above) to convert the value of the particular feature into a weighted average based on the knots. For example, the numerical feature xt can be represented using a k-dimensional embedding V).
[0052] The data analysis engine 110 can generate an encoded representation of the features (208). For example, the data analysis engine 110 can use methods such as one-hot
encoding to generate an encoded representation of the categorical features. In general, one- hot encoding converts categorical features into a vector of ones and zeros depending upon the category of the particular feature. For example, if a particular feature that identifies gender takes values Male and Female, the one-hot encoded representation can have two features such that the first feature of the representation will have a value of one (and the second feature will have a value zero) if the particular feature is a Male. Correspondingly, if the particular feature is female, first feature of the representation will have a value of zero (and the second feature will have a value one).
[0053] Note that prior to the step 208 of the process 200, all features in the training dataset are categorical since the features that are not categorical, were processed in the step 206 to generate a categorical representation. It should also be noted that even though the step 208 has been described as using one-hot encoding technique to generate an encoded representation of the categorical features, any appropriate encoding technique can be used for the purpose.
[0054] In some implementations, after generating a first matrix, the data analysis engine 110 can use singular value decomposition (SVD) to decompose the first matrix into one or more matrices. The SVD method can be represented using the following equation
A = U * Σ * VT 23
Where A is an n x in matrix such that n > m, U is an x m orthogonal matrix, Σ is a m x m diagonal matrix (also referred to as the second matrix) and V is a m x m orthogonal matrix.
[0055] In some implementations, the data analysis engine 110 can compute a third matrix Σ-1 i.e. the inverse of the matrix Σ using a regularization term l. Σ-1 can be calculated using the following equation
where Σ = diag(σ1, ... σr ) and σ1, ... σr are singular values.
[0056] In some implementations, equation 24 can be used to compute the inverse of the first matrix (also referred to as a fourth matrix) using equation 25
[0057] In some implementations, the system 100 can further include a training engine 108 that can include one or more processors and is configured to, at each iteration, train the model 102 based on the loss function 106. In some implementations, the training engine
108 can train the model 102 by adjusting the values of the model parameters 103 from current values of the model parameters 103 in order to decrease a loss value generated by the loss function 106.
[0058] In some implementations, the data analysis engine 110 can map each feature of the training dataset 104 to an embedding representation of a dimension K that is determined based on the unique values and/or levels (also referred to as cardinality of a feature) of the feature. For example, if the training dataset 104 has N training examples and each training example has M features, then the value of the j-th feature of the i-th training example can be represented using an embedding Ei, j of dimension K where Ei, j∈RK. It should be noted that for each distinct value of a categorical feature xj, there is a distinct embedding Ej resulting in | Xj | distinct embedding for the feature j where | Xj | is the cardinality of the categorical feature j.
[0059] In some implementations, during training the machine learning model 102, the machine learning model can predict according to the following equation
where C can be a constant that can be defined as
27
[0060] The training engine 108 can train the machine learning model using K iterations by adjusting the values of the trainable parameters ck and the embedding representation. F or example, during a k-th iteration of the training process, the training engine can calculate the trainable parameters ck and the k-th value of each of the | xj | embedding representation for all features.
[0061] In general, a residue for a machine learning model is the difference between the model prediction and the target output. According to the machine learning model 102, the residue for a k-th iteration of the training process can be computed using equations 26 and 27. The residue can be represented in the following form where yt is the target output for a sample i.
28
[0062] In some implementations, the target output for each subsequent training iteration can be the residue from the previous iteration(s). For example, the target output yi during the k-th is the residual
Rk- 1,i calculated using equation 28 in the k-l-th training iteration which logically means that each training iteration tries to leam model parameters based on the residual (also referred to as a prediction error) of the previous training iteration. This training process can generate an overdetermined system of N equation that can be represented as 29
where i = 1, 2, ... N.
[0063] In some implementations, the overdetermined system of N equations can be transformed into logarithmic space, for example, by moving ck to the right side of equation 29, and taking the log of both sides of the resulting equation, as represented by equation 30
[0064] It should be noted that,
Eij k = A * X where X is the k-th value of each of the embedding representation for all features concatenated together corresponding to the columns of the first matrix. Using equation 30, the 31 overdetermined system of N equations can further represented as
A * X = B
[0065] It should be noted that equation 31 can be similar to the formulation of a classical linear regression problem without the intercept in the formulation. In some implementations, equation 31 can be modified into [A 1] * [X b] 1 = B by adding an extra column in the first matrix A. In some implementations, adding an extra column in the first matrix A can be achieved by adding a categorical feature with a single value to each of the training examples of the training dataset 104.
[0066] In some implementations, the training engine 108 can calculate X in equation 31 of the overdetermined system. Since A * X = B and A = U * Σ * VT the following equation can be derived
U * Σ* VT * X = B
which leads to
V * Σ-1 *UT*U*Σ*VT*X = V* Σ-1 * UT * B 33 Since matrices U * UT = I, V *VT = I and å * åT = /, equation 33 can be used to derive X as follows
X = V* Σ~1*UT *B = A-1 *B 34 where A~x is computed using equation 25 and Bt
— ck) .
[0067] In some implementations, the training engine 108 can select the value of ck based on the heuristics described below.
ck) >0 the value of ck can be increased to reduce log(max
— ck)
< ck) )2)·
The value of max ((log ( Rk-1}i — ck) )2) can reduced to minimum when
[0068] In some implementations, the training engine 108 can further optimize the selection of ck based on the intuition that by selecting an optimal value for ck, the value of \A* X — B 12 can be minimized. This can be represented using the function L(ck) where L(ck)=BT *(I-A*(AT *A)~1*AT)*B 35
By calculating C = I — A * (A1 * A)-1 * A1, equation 35 can take the form
L(ck) = BT * C * B = ΣiΣjCi}j * log (Rk-U - ck ) * log(Rk-1}j - ck ) 36
[0069] In some implementations, the training engine 108 can use gradient descent algorithm which is a first-order iterative optimization algorithm to find the value of ck that minimizes L(ck). The gradient descent algorithm uses the first derivative of the function L(ck). The first order derivative of the function takes the following form log(Rk._1;· - ck )
Rk-i,i — ck
[0070] In some implementations, the training engine 108 can use newton
method or stochastic newton method which are second-order iterative optimization algorithms to find the value of ck that minimizes L(ck). The newton method and stochastic newton method uses the second derivative of the function L(ck). The second order derivative of the function takes the following form
[0071] This technique for optimizing the value of <ck can differ from the use of a neural net for example, because here, each iteration only has a single unknown, <ck, making this a single variable optimization problem, whereas a neural network optimization problem can require the processing of millions or billions of variables, and having to find local minimums for hundreds or millions of variables. As such, it is easy to see that this technique for optimizing <¾ provides significant resource and training time reductions relative to neural network optimizations.
[0072] In some implementations, the training engine 108 can directly optimize the cost function using stochastic gradient descent (SGD) algorithm. The cost function of the machine learning model can have the following form
[0073] In some implementations, the training engine 108 can use coordinate descent algorithm to optimize the trainable parameters. In such an implementation, the coordinate descent algorithm can calculate a new value of C where the new value C’ can be calculated using
[0074] In some implementations, the training engine 108 can calculate the embedding representation of a value for a particular feature using an overdetermined system. For example, an overdetermined system A * X = B, can be solved for X using QR decomposition. In such a case, the solution X is a K dimensional vector and log ( max(Xk , e) ) is the new value for the k-th element in the embedding and e is a small positive number. Such an overdetermined system can be represented as follows
Bpi,k Xi C
where xi q = v and pu ... = (0, 1, 2, ... } 41
[0075] In some implementations, the termination criteria of the training process of the machine learning model 102 can be determined based on the residual after the k-th iteration of the training process. For example, if the iterative optimization methods described above are not able to further minimize the magnitude of the residual, the training process can be terminated and current values of the model parameters including the dimension K, the constant C and all the embedding representations for all features can be considered as final values.
[0076] In some implementations, the termination criteria for the training process can be the machine learning prediction accuracy that can be measured using metrics such as precision, recall, FI score or PR AUC. For example, the training engine 108 can terminate the training process when the accuracy of the machine learning model 102 with the current model parameters reached a predetermined threshold.
[0077] Coming back to the selection of knots using HT and HWT. For each one of the K dimensions, the data analysis engine 110 and the training engine 108 leams a function f' that maps a feature value xi,j that falls within the range
mar(xj i) ] into a floating point number. Let’s assume that / represents the actual unknown smooth function to be learned. For equally spaced knots x0 < xt < ... < xn where x0 = min(xi j ) and xn = max(xi j ), the methods described above learns cubic spline f' that is sufficiently close to /. To evaluate the closeness, we evaluate both / and f' at any x{ where x0 < Xi < xn where |/(xi) — f'(xi) \ < e for a well-trained model. To represent the cubic spline with m + 1 knots, the model needs m + 1 parameters to be learned, i.e. {f'(xo)>f'(xi)> ... f'(xm)}· If the value of m chosen is significantly larger than necessary, there may be many redundancies in the model parameters {f'(x0), f'(xi), ... f'(vm)}. We may be able to compress the model parameters {f'(x0), f'(x i), . . . f'(xm)}. i.e. reduce the model size without reducing the quality of the cubic spline fitness. If we consider {f'(xo)>f'(xi)> ... f'(x m)} as a one-dimensional continuous signal sampled at m + 1 points, we may convert the one- dimensional signal into frequency domain using either Hadamard Transform (HT) which is a generalization of Fourier Transform (FT), or Haar Wavelet Transform (HWT) which is one possible wavelet transformation. Continuous one- dimensional signals can often be compressed better in the frequency domain.
[0078] In some implementations, the data analysis engine 110 can transform function / into the frequency domain (denoted as F) using Hadamard transformation. The transformation matrix for the Hadamard transformation can take the following form
where i . j is a bitwise dot product of the binary representations of the numbers i and j. Since transforming f to F is equivalent to projecting vector {f'(x0),f'(xi), ...f'(xm)}, the following relationship holds
Hn * {f'(x0),f'Oi), ...f(xm)F = F'(x0), F'(x1), ... F'(xm) } 4; where m = 2n.
[0079] In some implementations, the training engine 108 can train the machine learning model 102 in the frequency domain. For example, equations 6-12 and 44 can be used to conclude that each Y is a linear combination of all F'(x0), F'(x1), ... F'(xm). The training engine 108 can then construct the first matrix and calculate the values of F'(x0),F'(xi), ... F'(xm) directly using equations 31-38.
{f'(x0),f'(x1), -f'(xm)}T = Hΰ1 * {F'(x0),F'(x1), ... F'(xm)}T 44
When training the machine learning model 102 in the frequency domain, each element in the learned embedding is a coefficient of (i.e. the weights in linear combination of) frequencies in frequency domains. For elements whose values are really small, the training engine 108 can set those element values to 0 to reduce the number of model parameters, model capacity, as well as to avoid overfitting. Compression in the frequency domain may be more efficient.
[0080] In some implementations, the application of regularization, e.g. equation 24, can shrink the element values in the learned embedding toward 0. For elements whose values are really small, the training engine 108 can set those element values to 0 to reduce the number of model parameters, model capacity, as well as to avoid overfitting.
[0081] In some implementations, the data analysis engine 110 can use the hadamard transformation method (explained above) if the features in the training dataset 104 includes ordinal features. In such an implementation, the number of distinct values of the ordinal features can be padded to increase the number of distinct values to 2ceillng(log2(m)) : where ceiling (x) returns the smallest integer that is not smaller than x.
[0082] In general, machine learning models can be used for a variety of tasks such as regression, classification and ranking. The following section describes how the machine learning model 102 described above can be used for such tasks.
Multiclass Classification
[0083] Assume that there is a training dataset 102 of N training examples of the form (xj, k), ... {xN, lN} where xt is a feature vector of the i-th training example and Zj is the corresponding target label where Zj is an instance of all possible labels L i.e. Zj e L. Further assuming that the number of features for each training example is M-l i.e. xt ... XiM-1. [0084] The multiclass classification problem is to find a classifier F to predict the class label for a training example, i.e.
= lt . The multiclass classification problem can be reformulated into a regression problem for each class i.e. to find a classifier F’ such that F'(xj 1( ... xt M) = 1 if xi M = lt and 0 otherwise for all xi M∈L.
[0085] During the training process, the data analysis engine 110 can convert N training examples of the training dataset 102 into N*L training examples, where N training examples have a target label 1 and N*(L-1) training examples have a label 0. In case the classification problem suffers from unbalanced datasets, weights can be assigned to the training examples. For example, ahyperparameter d > 0 can be defined and the generated training examples and labels can be modified as follows. For all xi MeL,
where the weight for the training examples with 1 as the label is d * (L — 1). It should be noted that selecting 5 = 1 will result in a perfectly balanced binary classification problem. It should also be noted that increasing the value of d reduces intra-class variance in the prediction result of F’.
[0086] The optimal classifier F' can then be calculated using equation 26 and the corresponding solution described in the document. It should be noted that each label ll ∈ L will have a K-dimensional embedding during training. To predict the most likely labels, equation 26 can be reformatted into a dot product of two vectors of dimension K+l where the labels with the largest dot product have the highest likelihood of being the label for the training example xi:1, ... XiM-1.
[0087] The first of the two vectors (presented below) can be independent of the possible labels and only related to the values of the features for the i-th training example xi,i> ... xi,M- 1 46
The second of the two vectors (presented below) can be the embedding of the label and independent of the values of the features for the i-th training example xi,1 ... xi,M-1
(1, q1, ..., qK} where qK = eE^.k 47
Multi-Task Classification / Regression
[0088] Assume that there is a training dataset 102 of N training examples where each training example has features xi,1 ... xi,M-1 and labels li tl, ... xiitr where (t1; ... tT} are tasks.
[0089] During the training process, the data analysis engine 110 can convert multi-task problem into an equivalent single-task problem by defining a dummy categorical feature vector Xm with values {t1, ... tT}. The i-th training example can further be expanded to T training examples as follows
[0090] The training engine 108 can then train the function F according to the techniques and methods described above, to learn a K-dimensional embeddingt for each task t which is similar to the multiclass classification problem (described above) where each label has an embedding.
[0091] Similar to the multiclass classification problem, the training engine 108 can calculate the vector (p1; ... pK} where pk = is independent of the possible tasks
and is only related to the values of the features of the i-th training example xi,1 ... xi,M-1 The predicted result of task t can then be computed using
C + (p1; ... pk] O embeddingt 49
Ranking
[0092] In general, learning-to-rank problem can be formulated as a set of item-neutral contextual features { X1, ... XM} and a set of item-specific features { X1, ... YN}. Commonly N=1 and Y1 is a categorical feature. During training, using pairwise approach, each training example includes (1) value of contextual features { X1, ... XM}, (2) value of item-specific features for the first item (y1,1, ...y1,h}> (3) value of item-specific features for the second item (y2,i, ... y2,n} and (4) label L indicating the order between the two items i.e. L= -1 if the first item should be ranked lower than the second item and L= 1 otherwise. While
querying, each query includes (1) the value of contextual features {xlf ... xM} and (2) Z items, whose item-specific features have the values (yz,i, ... yz,n} where z e [1, Z],
[0093] During training, the training engine 108 can define a binary operator between two items, whose result is either true or false based on whether the item on the left-hand- side (LHS) of the operator should be ranked higher than the item on the right-hand-side (RHS) of the operator.
[0094] For each item-specific feature in {Y1 , ... YN}. the data analysis engine 110 can define two item-specific features to encode the LHS Vs RHS, i.e. {LHS_Y1, ... LHS_YN } and {RHS_Y1, ... RFIS_YN } where Yi,LHS_Yi and RHSJYi have the same data type and their values have the same semantic. The feature set in the machine learning model 102 can be of the form {X1, ... XM, LHS_Y1, ... LHS_YN, RHS_Y1, ... RHS_YN } of size M + 2 * N features.
[0095] For each training example
[ylx, ...ylin], {y2il, ...y2,n},k[, the training engine 108 can process four training examples. The training examples are as follows
50
It should be noted that the first training example can be the original training example, the second training example can be a negative example of the first training example with an observation that if the two items are swapped the model 102 prediction should be reversed. Training examples 3 and 4 are constraints stating that two similar items should rank the same.
[0096] Assume that the value of contextual features in the query are {xll ... xm}, and the query needs to rank x items, i.e. {zv ... zx). whose item-specific features have the values [yZi, 1, ...yZi, n] where Zi∈{zj, ... zx}. Given two arbitrary items Zi∈{zj, ... zx} , the training engine 108 calculates function F+ and F~ as stated below
[0097] The training engine 108 can then define cap (x, minValue, maxValue) = min(max(x, minValue) ,maxValue)
Which can results in
the reward to rank zt over z;.
[0098] The training engine 108 can then find the permutation of {zi, ... zx}. i.e. {z[, ... zx'} that maximizes the overall reward i.e.
F(z·, zj).
[0099] FIG. 3 is a flow chart of an example process 300 for training a machine learning model. Operations of the process 300 can be implemented, for example, by the data analysis engine 110 and the training engine 108 of the system 100 of FIG.1 , or one or more data processing apparatus. Operations of the process 300 can also be implemented as instructions stored on a computer readable medium, where execution of the instructions can cause one or more data processing apparatus to perform operations of the process 300. [00100] The system 100 obtains training dataset that includes a plurality of training samples (302). F or example, the data analysis engine 110 can receive a training dataset 104. The training dataset 104 includes multiple training examples. Each training example includes one or more features and a corresponding target output. The target output corresponding to a training example refers to a preferred output of the model 102 in response to processing the one or more features of the training examples. For example, the training dataset 104 can be defined as having N training examples of the form {xN, yi} ... {xN, yN} where xt is a feature vector of the i-th training example and yt is the target output. Since the dimension of the feature vector xt is fixed, the training dataset can be represented using a table or a matrix.
[00101] The data analysis engine 110 generates a first matrix which is a sparse representation of the training dataset (304). For example, the data analysis engine 110 can iteratively select a feature from among the one or more features of the training dataset 104 for processing. The data analysis engine determines if the selected feature is a categorical feature. If the feature is determined to be not categorical, the data analysis engine 110 converts the value of the non-categorical features into discrete points in feature space. For example, the data analysis engine 110 after determining that a particular feature is not categorical (i.e., the particular feature is numerical), uses cubic spline interpolation method to convert the particular feature into discrete points using cubic spline interpolation. In some situations, Fast Fourier Transforms (FFTs) and/or wavelet transforms can be used to train the feature embeddings in the frequency domain to enable better model compression, i.e. to reduce the number of model parameters and to prevent overfitting with regularization. For example, a FFT (and/or wavelet) can be applied to train in the frequency
domain, where the embeddings are the coefficients (i.e. weights) of the linear combination of frequencies.
[00102] The data analysis engine 110 can generate an encoded representation of the features using methods such as one-hot encoding to generate an encoded representation of the categorical features. In general, one-hot encoding converts categorical features into a vector of ones and zeros depending upon the category of the particular feature. For example, if a particular feature that identifies gender takes values Male and Female, the one-hot encoded representation will have two features such that the first feature of the representation will have a value of one (and the second feature will have a value zero) if the particular feature is a Male. Correspondingly, if the particular feature is female, first feature of the representation will have a value of zero (and the second feature will have a value one). After encoding each feature of the training dataset 102, the result can be represented using a table or a matrix that is referred to as the first matrix.
[00103] The data analysis engine 110 can factorize the matrix representation of the dataset that is referred to as the first matrix (306). For example, the data analysis engine 110 after generating a first matrix, uses singular value decomposition (SVD) to decompose the first matrix into one or more matrices. The SVD method can be represented using the following equation A = U * Σ * V1 where A is an n x in matrix such that n > m, U is a n x m orthogonal matrix, Σ is a m xm diagonal matrix (also referred to as the second matrix) and V is am x m orthogonal matrix.
[00104] The data analysis engine 110 can generate the third matrix using the second matrix and a regularization term (308). For example, the data analysis engine 110 computes a third matrix Σ-1 i.e. the inverse of the matrix Σ using a regularization term l. Σ-1 can be calculated using the following equation
24 where Σ = diag(σ1, ... σr ) and σ1, ... σr are singular values.
[00105] The data analysis engine 110 can generate a fourth matrix based on one or more matrices and the third matrix (310). For example, equation 24 can be used to compute the inverse of the first matrix (also referred to as a fourth matrix) using equation 25
25
[00106] The data analysis engine 110 can represent each feature of the training dataset using a vector that includes a predetermined number of adjustable parameters (312). For example, the data analysis engine 110 maps each feature of the training dataset to an embedding representation of a dimension K that is determined based on the unique values and/or levels (also referred to as cardinality of a feature) of the feature. For example, if the training dataset 104 has N training examples and each training example has M features, then the value of the j-th feature of the i-th training example can be represented using an embedding E,., of dimension K where Et j eRK . It should be noted that for a relatively small cardinality of a feature x}. for each distinct value of a feature x,. there is a distinct embedding Ej resulting in | xj \ distinct embedding for the feature j where | xj | is the cardinality of the categorical feature j. For features with relatively higher cardinality, the data analysis engine 110 can split the feature with relatively high cardinality into features with relatively low cardinality. For example a feature x} can be split into xj1, xj2, . . . Xjq. In such a scenario, the feature x can be represented using q distinct embedding Ej.
[00107] The training engine 108 can adjust the values of the adjustable model parameters of the machine learning model 102 (314). In some implementations, the adjustment can include iteratively training sequential models to predict a residue of the loss function until the loss can no longer be reduced, a measure model quality meets a quality threshold, or a size of the model has reached a maximum model size threshold (e.g., based on a memory constraint of a device training or invoking the model). For example, training engine 108 trains the machine learning model using K iterations by adjusting the values of the trainable parameters ck and the embedding representation. According to the machine learning model 102, the residue for a k-th iteration of the training process can be computed using equations 26 and 27. The residue can be represented in the following form
where yi is the target output for a sample i.
[00108] In some implementations, each subsequent training model can be trained to predict a combined residual value of previously generated models in the sequence of models. In other words, the target output for each subsequent training iteration is the residue from the previous iteration(s). The training process can generate an overdetermined system of N equation that can be transformed into logarithmic space using the following equation
log(Rk-1,i - ck) 31
where Rk-1,i — ck > 0 for any 1 £ i £ N.
[00109] The overdetermined system of N equations can further represented as
A * X = B
[00110] The training engine 108 can calculate X in A * X = B of the overdetermined system using the following equation
X = V * Σ~1 * UT * B = A~1 * B 34 where A~x is computed using equation 25 and B t =log log (Rk-1,i — ck) .
[00111] In some implementations, instead of equation 34, the training engine 108 can calculate X using iterative methods, with regularization techniques of choice, e.g. LI regularization (aka Lasso regression), or L2 regularization (aka ridge regression). The training engine 108 can select the value of ck based on the heuristics described below, or other appropriate heuristics. The training engine 108 can further optimize the selection of ck based on the intuition that by selecting an optimal value for ck, the value of \A * X — B\2cm be minimized. This can be represented using the function L(ck) where 35
L{ck) = BT * 0 - A * (AT * A)-1 * AT) * B By calculating C = I — A * (A1 * A)^1 * A1’ . equation 35 can take the form
L(ck ) = BT * C * B = ΣiΣjCi}j * log {Rk-1}i - ck ) * log(Rk-1}j - ck ) 36
[00112] In some implementations, the training engine 108 can use gradient descent algorithm which is a first-order iterative optimization algorithm to find the value of ck that minimizes L(ck). The training engine 108 can also use newton method, stochastic newton method which are second-order iterative optimization algorithms to find the value of ck that minimizes L(ck). The training engine 108 can also directly optimize the cost function using stochastic gradient descent (SGD) algorithm. The training engine 108 can also use coordinate descent algorithm to optimize the trainable parameters.
[00113] The training engine 108 can calculate the embedding representation of a value for a particular feature using an overdetermined system. For example, an overdetermined system A * X = B, can be solved for X using QR decomposition.
[00114] In some implementations, the error function can be different from Mean Square Error (MSE). In these implementations, instead of using the residue as the training
label in each one of the K steps, the training engine 108 may calculate pseudo residue, i.e. the derivative of the loss function of a real intermediate variable representing the inner product of Ai * X, where rips the row of the first matrix corresponding to the i-th training example. Let Bt denote the pseudo residue calculated for the i-th training example. The training engine 108 may solve the overdetermined system A * X = B using any linear regression approaches described in previous sections.
[00115] In some implementations, in each of the K steps in the iterative training process, the training engine 108 can explicitly represent the intercept of the linear regression result
[00116] In some implementations, the training engine 108 can explicitly define a learning rate, e.g, g. and modify the objective function from
to
the average value of labels in the training dataset. In some implementations that support both intercept and learning rate, the objective function can be average(y ) + g x Σk=1(ck +
[00117] By introducing a fictitious single-valued categorical feature with one legitimate value, the above equation canbe equivalent to C +
where C = average(y) + g x Σk=1 ck, and the k-th dimension in the embedding for the fictitious single- valued categorical feature is log(y ) + inter ceptk.
[00118] FIG. 4 is block diagram of an example computer system 400 that can be used to perform operations described above. The system 300 includes a processor 410, a memory 420, a storage device 430, and an input/output device 440. Each of the components 410, 420, 430, and 440 can be interconnected, for example, using a system bus 450. The processor 410 is capable of processing instructions for execution within the system 400. In one implementation, the processor 410 is a single-threaded processor. In another implementation, the processor 410 is a multi-threaded processor. The processor 410 is capable of processing instructions stored in the memory 420 or on the storage device 430. [00119] The memory 420 stores information within the system 400. In one implementation, the memory 420 is a computer-readable medium. In one implementation, the memory 420 is a volatile memory unit. In another implementation, the memory 420 is a non-volatile memory unit.
[00120] The storage device 430 is capable of providing mass storage for the system 400. In one implementation, the storage device 430 is a computer-readable medium. In various different implementations, the storage device 430 can include, for example, a hard disk device, an optical disk device, a storage device that is shared over a network by multiple computing devices (e.g., a cloud storage device), or some other large capacity storage device.
[00121] The input/output device 440 provides input/output operations for the system
400. In one implementation, the input/output device 440 can include one or more of a network interface devices, e.g., an Ethernet card, a serial communication device, e.g., and RS-232 port, and/or a wireless interface device, e.g., and 802.11 card. In another implementation, the input/output device can include driver devices configured to receive input data and send output data to other input/output devices, e.g., keyboard, printer and display devices 370. Other implementations, however, can also be used, such as mobile computing devices, mobile communication devices, set-top box television client devices, etc.
[00122] Although an example processing system has been described in FIG. 4, implementations of the subject matter and the functional operations described in this specification can be implemented in other types of digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. [00123] An electronic document (which for brevity will simply be referred to as a document) does not necessarily correspond to a file. A document may be stored in a portion of a file that holds other documents, in a single file dedicated to the document in question, or in multiple coordinated files.
[00124] Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage media (or medium) for execution by, or to control the operation of, data processing apparatus. Alternatively, or in addition, the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal that is generated to encode information for transmission
to suitable receiver apparatus for execution by a data processing apparatus. A computer storage medium can be, or be included in, a computer-readable storage device, a computer- readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Moreover, while a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially-generated propagated signal. The computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
[00125] The operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
[00126] The term “data processing apparatus” encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations, of the foregoing. The apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross- platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.
[00127] A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code). A computer program can be deployed to be executed on one computer
or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
[00128] The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
[00129] Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few. Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry. [00130] To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to
and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user’s client device in response to requests received from the web browser.
[00131] Embodiments of the subject mater described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes amiddleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject mater described in this specification, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
[00132] The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) can be received from the client device at the server.
[00133] While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any inventions or of what may be claimed, but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
[00134] Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
[00135] Thus, particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.
Claims
1. A computer-implemented method comprising: obtaining, a training dataset comprising a plurality of training samples, wherein each training sample includes feature variables and one or more output variables; generating, using the training dataset, a first matrix that is a sparse representation of the training dataset wherein generating the first matrix comprises: generating a categorical representation of the feature variables based on each numerical feature variable among the feature variables; generating an encoded representation of each categorical feature variable among the feature variables by encoding each categorical feature variable; factorizing the matrix representation of the training dataset to generate one or more matrices including a second matrix; generating a third matrix using (i) the second matrix and (ii) a regularization term; generating a fourth matrix based on (i) one or more matrices and (ii) the third matrix; representing, each feature of the first matrix using a vector that includes a multiple adjustable parameters; and adjusting values of the adjustable parameters using a combination of (i) a loss function, (ii) the fourth matrix, and (iii) the first matrix.
2. The computer-implemented method of claim 1, wherein the loss function is a loss function that provides a result corresponding to a given result provided by a particular loss function of the form
where R is a residue, yt is the output variable, c is a constant and E is the encoded representation.
3. The computer-implemented method of claim 1, wherein generating a categorical representation of the feature variables based on each numerical feature variable comprises: selecting a set of knots; representing the numerical feature as either (i) a weighted sum of embedding, or (ii) a weighted average of the embedding; generating the corresponding weights of the embedding using an interpolation technique; and representing each numerical variable in the first matrix using the corresponding weights.
4. The computer-implemented method of claim 3, wherein the interpolation techniques for generating the corresponding weights of the embedding comprises spline interpolation.
5. The computer-implemented method of claim 1, further comprising: generating a categorical representation of a set of ordinal features included in the training samples, including: performing a Discrete Fourier Transform (DFT) or Discrete Wavelet Transform (DWT) on the set of ordinal features; and assigning categorical representations to the set of ordinal features based, at least in part, on the DFT or DWT transformation matrix.
6. The computer-implemented method of claim 1, wherein adjusting values of the adjustable parameters comprises iteratively generating sequential models to predict a residue of the loss function until a residue of the loss function can no longer be reduced, a measure of model quality meets a quality threshold, or a size of the model has reached a maximum model size threshold.
7. The computer-implemented method of claim 6, wherein adjusting values of the adjustable parameters further comprises generating a pseudo residue based on the derivative of the loss function.
8. The computer-implemented method of claim 5, wherein each subsequently generated model is trained to predict a combined residual value of previously generated models in the sequence of models.
9. The computer-implemented method of claim 1, wherein adjusting values of the adjustable parameters comprises adjusting the values of the adjustable parameters iteratively until a size of the model reached a model size threshold based, at least in part, on a memory constraint of a device training or invoking the model.
10. A system, comprising: obtaining, a training dataset comprising a plurality of training samples, wherein each training sample includes feature variables and one or more output variables; generating, using the training dataset, a first matrix that is a sparse representation of the training dataset wherein generating the first matrix comprises: generating a categorical representation of the feature variables based on each numerical feature variable among the feature variables; generating an encoded representation of each categorical feature variable among the feature variables by encoding each categorical feature variable; factorizing the matrix representation of the training dataset to generate one or more matrices including a second matrix; generating a third matrix using (i) the second matrix and (ii) a regularization term; generating a fourth matrix based on (i) one or more matrices and (ii) the third matrix; representing, each feature of the first matrix using a vector that includes a multiple adjustable parameters; and adjusting values of the adjustable parameters using a combination of (i) a loss function, (ii) the fourth matrix, and (iii) the first matrix.
11. The system of claim 10, wherein the loss function is a loss function that provides a result corresponding to a given result provided by a particular loss function of the form
where R is a residue, yt is the output variable, c is a constant and E is the encoded representation.
12. The system of claim 10, wherein generating a categorical representation of the feature variables based on each numerical feature variable comprises: selecting a set of knots; representing the numerical feature as either (i) a weighted sum of embedding, or (ii) a weighted average of the embedding; generating the corresponding weights of the embedding using an interpolation technique; and representing each numerical variable in the first matrix using the corresponding weights.
13. The system of claim 12, wherein the interpolation techniques for generating the corresponding weights of the embedding comprises spline interpolation.
14. The system of claim 10, further comprising: generating a categorical representation of a set of ordinal features included in the training samples, including: performing a Discrete Fourier Transform (DFT) or Discrete Wavelet Transform (DWT) on the set of ordinal features; and assigning categorical representations to the set of ordinal features based, at least in part, on the DFT or DWT transformation matrix.
15. The system of claim 10, wherein adjusting values of the adjustable parameters comprises iteratively generating sequential models to predict a residue of the loss function until a residue of the loss function can no longer be reduced, a measure of model quality meets a quality threshold, or a size of the model has reached a maximum model size threshold.
16. The system of claim 15, wherein adjusting values of the adjustable parameters further comprises generating a pseudo residue based on the derivative of the loss function.
17. The system of claim 14, wherein each subsequently generated model is trained to predict a combined residual value of previously generated models in the sequence of models.
18. The system of claim 10, wherein adjusting values of the adjustable parameters comprises adjusting the values of the adjustable parameters iteratively until a size of the model reached a model size threshold based, at least in part, on a memory constraint of a device training or invoking the model.
19. A non-transitory computer readable medium storing instructions that, when executed by one or more data processing apparatus, cause the one or more data processing apparatus to perform operations comprising: obtaining, a training dataset comprising a plurality of training samples, wherein each training sample includes feature variables and one or more output variables; generating, using the training dataset, a first matrix that is a sparse representation of the training dataset wherein generating the first matrix comprises: generating a categorical representation of the feature variables based on each numerical feature variable among the feature variables; generating an encoded representation of each categorical feature variable among the feature variables by encoding each categorical feature variable; factorizing the matrix representation of the training dataset to generate one or more matrices including a second matrix; generating a third matrix using (i) the second matrix and (ii) a regularization term; generating a fourth matrix based on (i) one or more matrices and (ii) the third matrix; representing, each feature of the first matrix using a vector that includes a multiple adjustable parameters; and adjusting values of the adjustable parameters using a combination of (i) a loss function, (ii) the fourth matrix, and (iii) the first matrix.
20. The non-transitory computer readable medium of claim 19, wherein the loss function is a loss function that provides a result corresponding to a given result provided by a particular loss function of the form
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2021/024274 WO2022203678A1 (en) | 2021-03-26 | 2021-03-26 | Boosting and matrix factorization |
Publications (1)
Publication Number | Publication Date |
---|---|
EP4085393A1 true EP4085393A1 (en) | 2022-11-09 |
Family
ID=75540046
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
EP21719466.1A Pending EP4085393A1 (en) | 2021-03-26 | 2021-03-26 | Boosting and matrix factorization |
Country Status (6)
Country | Link |
---|---|
US (1) | US20230050538A1 (en) |
EP (1) | EP4085393A1 (en) |
JP (1) | JP7376717B2 (en) |
KR (1) | KR20220134515A (en) |
CN (1) | CN115413345A (en) |
WO (1) | WO2022203678A1 (en) |
Family Cites Families (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JP7157154B2 (en) | 2017-11-30 | 2022-10-19 | グーグル エルエルシー | Neural Architecture Search Using Performance Prediction Neural Networks |
US10248664B1 (en) | 2018-07-02 | 2019-04-02 | Inception Institute Of Artificial Intelligence | Zero-shot sketch-based image retrieval techniques using neural networks for sketch-image recognition and retrieval |
-
2021
- 2021-03-26 EP EP21719466.1A patent/EP4085393A1/en active Pending
- 2021-03-26 CN CN202180006754.6A patent/CN115413345A/en active Pending
- 2021-03-26 KR KR1020227017118A patent/KR20220134515A/en unknown
- 2021-03-26 WO PCT/US2021/024274 patent/WO2022203678A1/en unknown
- 2021-03-26 US US17/773,650 patent/US20230050538A1/en active Pending
- 2021-03-26 JP JP2022530961A patent/JP7376717B2/en active Active
Also Published As
Publication number | Publication date |
---|---|
KR20220134515A (en) | 2022-10-05 |
CN115413345A (en) | 2022-11-29 |
WO2022203678A1 (en) | 2022-09-29 |
JP7376717B2 (en) | 2023-11-08 |
US20230050538A1 (en) | 2023-02-16 |
JP2023522287A (en) | 2023-05-30 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11087201B2 (en) | Neural architecture search using a performance prediction neural network | |
US10248664B1 (en) | Zero-shot sketch-based image retrieval techniques using neural networks for sketch-image recognition and retrieval | |
EP3711000B1 (en) | Regularized neural network architecture search | |
US10515313B2 (en) | Predictive model evaluation and training based on utility | |
US10133729B2 (en) | Semantically-relevant discovery of solutions | |
US20190278600A1 (en) | Tiled compressed sparse matrix format | |
CN110503192A (en) | The effective neural framework of resource | |
CN102782678A (en) | Joint embedding for item association | |
US20230021555A1 (en) | Model training based on parameterized quantum circuit | |
CN114611460A (en) | Data processing method, device, equipment and storage medium | |
US11599749B1 (en) | Method of and system for explainable knowledge-based visual question answering | |
Dai et al. | Hybrid deep model for human behavior understanding on industrial internet of video things | |
Kuri-Morales | Closed determination of the number of neurons in the hidden layer of a multi-layered perceptron network | |
CN116976505A (en) | Click rate prediction method of decoupling attention network based on information sharing | |
US20210166131A1 (en) | Training spectral inference neural networks using bilevel optimization | |
Zhu et al. | When contrastive learning meets active learning: A novel graph active learning paradigm with self-supervision | |
US20230196128A1 (en) | Information processing method, apparatus, electronic device, storage medium and program product | |
US20230050538A1 (en) | Boosting and matrix factorization | |
US11386335B2 (en) | Systems and methods providing evolutionary generation of embeddings for predicting links in knowledge graphs | |
CN114861671A (en) | Model training method and device, computer equipment and storage medium | |
Liu | POI recommendation model using multi-head attention in location-based social network big data | |
US20230334320A1 (en) | Latency-Aware Neural Network Pruning and Applications Thereof | |
US20240127045A1 (en) | Optimizing algorithms for hardware devices | |
US20230107247A1 (en) | Neural networks with transformed activation function layers | |
US20210326712A1 (en) | Obtaining Custom Artificial Neural Network Architectures |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: UNKNOWN |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: THE INTERNATIONAL PUBLICATION HAS BEEN MADE |
|
PUAI | Public reference made under article 153(3) epc to a published international application that has entered the european phase |
Free format text: ORIGINAL CODE: 0009012 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: REQUEST FOR EXAMINATION WAS MADE |
|
17P | Request for examination filed |
Effective date: 20220527 |
|
AK | Designated contracting states |
Kind code of ref document: A1Designated state(s): AL AT BE BG CH CY CZ DE DK EE ES FI FR GB GR HR HU IE IS IT LI LT LU LV MC MK MT NL NO PL PT RO RS SE SI SK SM TR |