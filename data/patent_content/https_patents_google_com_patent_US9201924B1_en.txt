US9201924B1 - Processing partially supported queries - Google Patents
Processing partially supported queries Download PDFInfo
- Publication number
- US9201924B1 US9201924B1 US14/088,300 US201314088300A US9201924B1 US 9201924 B1 US9201924 B1 US 9201924B1 US 201314088300 A US201314088300 A US 201314088300A US 9201924 B1 US9201924 B1 US 9201924B1
- Authority
- US
- United States
- Prior art keywords
- query
- processing
- processing steps
- supported
- unsupported
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2453—Query optimisation
- G06F16/24534—Query rewriting; Transformation
- G06F16/24542—Plan optimisation
-
- G06F17/30463—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2455—Query execution
-
- G06F17/30864—
Definitions
- Server systems frequently receive resource-intensive queries from requestors (e.g., clients and/or applications). To respond to such queries, server systems need to access and search through large data sets. Generating results and responses to complex queries using large data sets can be a time-consuming and resource-intensive process for the server systems. Processing resource-intensive queries at server systems can have detrimental effects on the entire server system. For example, when certain requestors transmit resource-intensive queries to a server system, the resource-intensive queries can monopolize resources (e.g., memory, processing power and functionality, server time etc.) of the server system, which will result in degrading the performance of the server system when responding to queries from other requestors.
- resources e.g., memory, processing power and functionality, server time etc.
- server systems it would be advantageous for server systems to have the capability to address resource-intensive queries without degrading the performance of the server system.
- One way to achieve this is to use customized indexes of database entries that are adapted for efficiently executing particular types of queries. In this scenario, the efficiency of processing a query is substantially increased if the customized indexes can be used to process the query.
- specific indexes that are required for the execution of specific queries are absent at the server system, then those specific queries are not fully supported at the server system at that instant in time and thus are frequently very expensive to perform.
- One possibility for handling an incoming query that is not fully supported is to return an exception (e.g., returning no results or an error message or returning all entities) to the requestors. However, returning an exception to queries that are not fully supported either prevents the requestor from getting results for the query or forces the requestor to perform all of the processing of the query, even if the server system could have performed a part of the query very efficiently using the customized indexes.
- the server system would be advantageous to enable the server system to partially perform a query that is only partially supported and provide the requestor with information enabling processing of the partially supported query to be completed at the requestor.
- the server system does not support processing a complete query (for example, owing to the inadequacy of query-processing capabilities such as the necessary index(es))
- the server system processes only the supported query-processing steps and returns intermediate results (generated based only on the execution of the supported query-processing steps) to the requestor.
- the server system In order to enable the requestor to process the unprocessed (e.g., unsupported) query-processing step(s) using the intermediate results provided to the requestor by the server system, the server system also returns a representation of the unprocessed (e.g., unsupported) query-processing step(s) to the requestor.
- a representation of the unprocessed (e.g., unsupported) query-processing step(s) to the requestor.
- Such an approach would enable the requestor to take advantage of the server system to efficiently process the portions of partially supported queries that are supported by the server system and let the requestor make decisions as to the resources that are to be used to process the unsupported portions of the partially supported queries (e.g., determining whether the cost of getting the results to a particular query is worth the benefit of completing processing the particular query), while preventing the server system from being overwhelmed by performing resource-intensive portions of the partially supported queries.
- a method is performed at a server system having one or more processors and memory storing one or more programs for execution by the one or more processors so as to perform the method.
- the method includes receiving a first query from a requestor and obtaining a first query-processing plan including a first plurality of query-processing steps for processing the query.
- the respective server system has a set of supported query-processing steps. Supported query-processing steps comprise query-processing steps in the set of supported query-processing steps, and unsupported query-processing steps comprise query-processing steps not in the set of supported query-processing steps.
- the method further includes, in accordance with a determination that the first plurality of query-processing steps includes one or more of the supported query-processing steps and one or more unsupported query-processing steps including a respective unsupported query-processing step: performing the one or more supported query-processing steps to produce intermediate results and generating a first response to the first query that includes the intermediate results and a representation of the respective unsupported query-processing step.
- the method further includes transmitting the first response to the requestor.
- a method is performed at a client system having one or more processors and memory storing one or more programs for execution by the one or more processors so as to perform the method.
- the method includes transmitting a query to a datastore server and receiving a response to the query that includes intermediate results and a representation of one or more unperformed query-processing steps including a respective unperformed query-processing step generated by the datastore server based on the query.
- the method further includes, after receiving the response, performing the respective unperformed query-processing step on the intermediate results to produce final results for the query.
- a computer system (e.g., a client system or server system) includes one or more processors, memory, and one or more programs; the one or more programs are stored in the memory and configured to be executed by the one or more processors and the one or more programs include instructions for performing the operations of the method described above.
- a non-transitory computer readable storage medium has stored therein instructions which when executed by one or more processors, cause a computer system (e.g., a client system or server system) to perform the operations of the methods described above.
- FIG. 1 is a block diagram illustrating a distributed client-server system, in accordance with some embodiments.
- FIG. 2 is a block diagram illustrating a client system, in accordance with some embodiments.
- FIG. 3 is a block diagram illustrating an application server system, in accordance with some embodiments.
- FIG. 4 is a block diagram illustrating a datastore server system, in accordance with some embodiments.
- FIG. 5A is a block diagram illustrating an entity database storing information about entities having properties, unique identifiers (keys) and content, in accordance with some embodiments.
- FIG. 5B is a block diagram illustrating execution of a query using a set of indexes for different properties for a plurality of entities having multiple properties and unique identifiers (keys), in accordance with some embodiments.
- FIG. 5C is a block diagram illustrating execution of a query using a set of indexes for different properties for a plurality of entities having multiple properties and unique identifiers (keys), where the indexes are sorted in accordance with values of one of the properties, in accordance with some embodiments.
- FIGS. 6A-6B include a flow chart illustrating a method for processing queries, in accordance with some embodiments.
- FIGS. 7A-7D include a flow chart illustrating a method for receiving and processing queries at a datastore server system and returning responses, in accordance with some embodiments.
- FIG. 8 includes a flow chart illustrating a method for transmitting queries from a client or application server system and receiving responses, in accordance with some embodiments.
- first, second, etc. are used herein to describe various elements, these elements should not be limited by these terms. These terms are only used to distinguish one element from another. For example, a first element could be termed a second element, and, similarly, a second element could be termed a first element, without changing the meaning of the description, so long as all occurrences of the “first element” are renamed consistently and all occurrences of the second element are renamed consistently. The first element and the second element are both elements, but they are not the same element.
- the term “if” can, optionally, be construed to mean “when” or “upon” or “in response to determining” or “in accordance with a determination” or “in response to detecting,” that a stated condition precedent is true, depending on the context.
- the phrase “if it is determined [that a stated condition precedent is true]” or “if [a stated condition precedent is true]” or “when [a stated condition precedent is true]” should be construed to mean “upon determining” or “in response to determining” or “in accordance with a determination” or “upon detecting” or “in response to detecting” that the stated condition precedent is true, depending on the context.
- the embodiments described below include client and server systems, which typically inter-operate in a distributed client-server system and corresponding methods of responding to queries based on supported query-processing capabilities.
- the term “requestor” is used to refer to an application being executed by a computer system (such as Client 102 or App Server 104 ) distinct from a server system (such as Datastore Server 106 ) in the distributed client-server system that processes queries.
- the requestor is an application that sends requests to Datastore Server 106 .
- FIG. 1 includes a block diagram illustrating an example of a distributed client-server system 100 for performing queries.
- System 100 includes one or more Client System(s) 102 (also referred to herein as “Client 102 ”), an Application Server System 104 (also referred to herein as “App Server 104 ”), a Datastore Server System 106 (also referred to herein as “Datastore Server 106 ”) and a Communication Network 120 for connecting Clients 102 and/or Application Server System 104 to Datastore Server System 106 .
- Communication Network 120 optionally includes the Internet, one or more local area networks (LANs), one or more wide area networks (WANs), other types of networks, or a combination of such networks.
- LANs local area networks
- WANs wide area networks
- Client 102 optionally includes Browser 110 and/or Client Application 112 .
- Browser 110 can be a general purpose Internet browser (sometimes called a Web browser) having a browser window used for displaying an application interface.
- a web application for submitting a data request is optionally implemented using hypertext markup language (HTML) or extensible markup language (XML) elements that are rendered by Browser 110 .
- a data request is, optionally, submitted via a standalone Client Application 112 .
- Client 102 relays the request to App Server 104 or Datastore Server 106 via Communication Network 120 .
- App Server 104 provides a corresponding request to Datastore Server 106 .
- Datastore Server 106 identifies a plurality of matching entities and transfers results including representations of the matching entities and, optionally, a set of display information back to Client 102 or App Server 104 .
- Client Application 112 and/or Browser 110 uses the results and display information to render a set of results at Client 102 .
- unprocessed query-processing steps and intermediate result(s) corresponding to the request are transmitted by Datastore Server 106 to Client 102 or App Server 104 .
- Client 102 or App Server 104 e.g., a query planner
- App Server 104 includes Application 130 , Query Planner 132 , Unprocessed Query-Processing Steps 134 , and Intermediate Result(s) 136 .
- Application 130 is a backend application for receiving and responding to requests from an application (e.g., Client Application 112 ) at Client 102 .
- Application 130 transmits data requests to Datastore Server 106 (e.g., to request data for use in responding to a request from an application at Client 102 ).
- App Server 104 includes Query Planner 132 that plans the execution of the request and provides a query plan to Datastore Server 106 along with the request.
- Unprocessed Query-Processing Steps 134 and Intermediate Result(s) 136 are, in some situations, transmitted by Datastore Server 106 to the App Server 104 in response to the request. It should be understood that in some embodiments, requests from Client 102 are transmitted to Datastore Server 106 without an intermediary backend application, while in other embodiments requests from Client 102 are transmitted to Application 130 on App Server 104 and Application 130 communicates with Datastore Server 106 . Additionally, in some implementations it is advantageous to handle some client requests without an intermediary backend application at App Server 104 , while other client requests are handled by an intermediary backend application (e.g., Application 130 ).
- an intermediary backend application e.g., Application 130
- Datastore Server System 106 includes Frontend Server 122 , Request Processor 124 , Query Engine 126 , Response Generator 128 , Index Generator 130 , Intermediate Result(s) 138 , Entity Database 140 , one or more Indexes 142 , and Supported Query-Processing Steps 148 .
- Index Generator 130 processes information about the entities that is stored in Entity Database 140 to produce Indexes 142 for use by Query Engine 126 when performing a search query.
- Index Generator 130 retrieves information about entities from a remote source such as a remote database or web crawler that systematically retrieves information from a plurality of remote sources (e.g., websites).
- Index Generator 130 Prior to receiving the search query at Datastore Server 106 . Performing these processes prior to receiving the search query increases the speed with which search results can be retrieved, thereby reducing latency of the search operation and returning results to users more quickly. In addition, Index Generator 130 typically continues to update Indexes 142 in between queries.
- Frontend Server 122 relays requests from Clients 102 to Request Processor 124 , which optionally plans a query by selecting an order to apply filters and sort orders specified in the query and transmits the planned query to Query Engine 126 .
- the Request Processor 124 plans the query so as to improve the performance characteristics of the query (e.g., by determining an order to apply filters that reduces the time to perform the query and/or reduces the maximum or total processor usage).
- Request Processor 124 determines an optimum query-processing plan from candidate query-processing plans and identifies constituent query-processing steps within the query to be executed.
- Request Processor 124 also identifies unsupported query-processing steps.
- Query Engine 126 identifies, in Indexes 142 , indexes and index portions adapted for responding to the query and performs the query on the identified indexes and/or index portions to identify search results.
- Supported Query-Processing Steps 148 are a set of query-processing steps that can be executed by Datastore Server 106 based on the current set of Indexes 142 present at Datastore Server 104 or based on the current set of query-processing capabilities of Datastore Server 106 .
- Intermediate Result(s) 138 are generated by Query Engine 126 by performing one or more Supported Query-Processing Steps 148 on one or more Indexes 142 , in response to the query received from Client 102 or App Server 104 .
- the matching entities are identified one at a time or in small batches in a predefined order (e.g., an order defined by the query or a system defined order).
- Query Engine 126 can easily retrieve the twenty most relevant/recent results and then stop searching the identified indexes or index portions.
- Query Engine 126 retrieves information about the matching entities from Entity Database 140 and passes the information to Response Generator 128 .
- Response Generator 128 generates a response including at least a portion of the information about the matching entities.
- Response Generator 128 also, optionally, determines display information for the results.
- the results and, optionally, display information passed to Frontend Server 122 which in turn passes the results to App Server 104 or to Client 102 via Communication Network 120 for display at Client 102 (e.g., via Browser 110 or Client Application 112 ).
- FIG. 2 is a block diagram illustrating a Client System 102 in accordance with some embodiments.
- Client 102 typically includes one or more processing units CPU(s) 202 , one or more network or other Communication Interfaces 204 , Memory 206 a User Interface 205 comprising a display device and a keyboard, mouse, touchpad, touchscreen or other input device, and one or more Communication Buses 208 for interconnecting these components.
- Communication Buses 208 optionally include circuitry (sometimes called a chipset) that interconnects and controls communications between system components.
- Memory 206 typically includes high-speed random access memory, such as DRAM, SRAM, DDR RAM or other random access solid state memory devices; and optionally includes non-volatile memory, such as one or more magnetic disk storage devices, optical disk storage devices, flash memory devices, or other non-volatile solid state storage devices. Memory 206 optionally includes one or more storage devices remotely located from the CPU(s) 202 . Memory 206 , or alternatively the non-volatile memory device(s) within Memory 206 , comprises a non-transitory computer readable storage medium. In some embodiments, Memory 206 or alternatively the non-transitory computer readable storage medium stores the following programs, modules and data structures, or a subset thereof:
- Each of the above identified elements are, optionally, stored in one or more of the previously mentioned memory devices, and corresponds to a set of instructions for performing a function described above.
- the above identified modules or programs i.e., sets of instructions
- Memory 206 optionally stores a subset of the modules and data structures identified above.
- Memory 206 optionally stores additional modules and data structures not described above.
- FIG. 3 is a block diagram illustrating an Application Server System 104 (also referred to herein as “App Server 104 ”) in accordance with some embodiments.
- App Server 104 typically includes one or more processing units CPU(s) 302 , one or more network or other Network Interfaces 304 , Memory 306 , and one or more Communication Buses 308 for interconnecting these components.
- Communication Buses 308 optionally include circuitry (sometimes called a chipset) that interconnects and controls communications between system components.
- Memory 306 includes high-speed random access memory, such as DRAM, SRAM, DDR RAM or other random access solid state memory devices; and optionally includes non-volatile memory, such as one or more magnetic disk storage devices, optical disk storage devices, flash memory devices, or other non-volatile solid state storage devices. Memory 306 optionally includes one or more storage devices remotely located from the CPU(s) 302 . Memory 306 , or alternatively the non-volatile memory device(s) within Memory 306 , comprises a non-transitory computer readable storage medium. In some embodiments, Memory 306 or alternatively the non-transitory computer readable storage medium stores the following programs, modules and data structures, or a subset thereof:
- Memory 306 optionally stores a subset of the modules and data structures identified above. Furthermore, Memory 306 optionally stores additional modules and data structures not described above.
- FIG. 3 shows an “Application Server System” 104
- FIG. 3 is intended more as functional description of the various features which are, optionally, present in a set of servers than as a structural schematic of the embodiments described herein.
- items shown separately could be combined and some items could be separated.
- some items shown separately in FIG. 3 could be implemented on single servers and single items could be implemented by one or more servers.
- the actual number of servers used to implement an Application Server System 104 and how features are allocated among them will vary from one implementation to another, and optionally depends in part on the amount of data traffic that the system must handle during peak usage periods as well as during average usage periods.
- FIG. 4 is a block diagram illustrating a Datastore Server System 106 (also referred to herein as “Datastore Server 106 ”) in accordance with some embodiments.
- Datastore Server 106 typically includes one or more processing units CPU(s) 402 , one or more network or other Communications Interfaces 408 , Memory 406 , and one or more Communication Buses 408 for interconnecting these components.
- Communication Buses 408 optionally include circuitry (sometimes called a chipset) that interconnects and controls communications between system components.
- Memory 406 includes high-speed random access memory, such as DRAM, SRAM, DDR RAM or other random access solid state memory devices; and optionally includes non-volatile memory, such as one or more magnetic disk storage devices, optical disk storage devices, flash memory devices, or other non-volatile solid state storage devices. Memory 406 optionally includes one or more storage devices remotely located from the CPU(s) 402 . Memory 406 , or alternatively the non-volatile memory device(s) within Memory 406 , comprises a non-transitory computer readable storage medium. In some embodiments, Memory 406 or alternatively the non-transitory computer readable storage medium stores the following programs, modules and data structures, or a subset thereof:
- Each of the above identified elements are, optionally, stored in one or more of the previously mentioned memory devices, and corresponds to a set of instructions for performing a function described above.
- the above identified modules or programs i.e., sets of instructions
- Memory 406 optionally stores a subset of the modules and data structures identified above.
- Memory 406 optionally stores additional modules and data structures not described above.
- FIG. 4 shows a “Datastore Server System” 106
- FIG. 4 is intended more as functional description of the various features which are, optionally, present in a set of servers than as a structural schematic of the embodiments described herein.
- items shown separately could be combined and some items could be separated.
- some items shown separately in FIG. 4 could be implemented on single servers and single items could be implemented by one or more servers.
- the actual number of servers used to implement a Datastore Server System 106 and how features are allocated among them will vary from one implementation to another, and optionally depends in part on the amount of data traffic that the system must handle during peak usage periods as well as during average usage periods.
- FIG. 5A illustrates an entity database storing information about entities (data objects) having keys 402 (unique identifiers), properties 404 and content 406 of the entities according to some embodiments.
- An entity has one or more properties, each property having one or more possible values of different types, including one or more of: integers, floating point values, strings, dates, and binary data.
- a property can have one or more values. For example, the property “tag” for a particular entity could have a value for each tag associated with the particular entity (e.g., “vacation” “mom” “California,” etc. could all be values for the property “tag”).
- a property with multiple values can have values of mixed types (e.g., for a particular entity a property could have one value that is an integer and another value that is a string).
- a search query including a filter tests whether any of the values meets the filter.
- the values of these properties can be used either as predefined sort parameters or to determine whether respective entities meet filter criteria.
- Each entity also has a key that uniquely identifies the entity, also called a “unique identifier” for the entity.
- a key is simply an Entity ID that is associated with the entity (e.g., assigned by Datastore Server 106 ).
- the key includes a kind and the Entity ID. The kind categorizes the entity so that it can more easily be identified and retrieved.
- An entity can be requested by Client 102 , and/or by App Server 104 either by submitting a request for an entity associated with a particular key, or by requesting performance of a search query that matches the entity's properties.
- a search query that matches the entities properties will typically first produce the key for the matching entity and then retrieve the entity or information representative of the entity from Entity Database 140 .
- Entity Database 140 does not require that all entities of a given kind have the same properties.
- FIG. 5B illustrates examples of Indexes 142 for different properties for a plurality of entities having multiple properties and unique identifiers (keys).
- the indexes (Index A 142 -A, Index B 142 -B and Index-C 142 -C) illustrated in FIG. 5B are for responding to queries that do not have custom (user specified or system specified) sort order.
- each index has a plurality index entries (rows) sorted in accordance with values of a property and a key (columns).
- index entries for the entity there will be at least two index entries for the entity (e.g., two index entries in the same index with the same key but different filter values), one sorted in accordance with the first value of the property and another sorted in accordance with the second value of the property.
- Each of the example indexes in FIG. 5B is adapted for responding to queries including a filter for the respective property included in the index (e.g., A, B, or C for Index A 142 -A, Index B 142 -B or Index C 142 -C, respectively).
- the indexes include portions that are indicated by the values of the property.
- a default sort order e.g., the index entries within a portion are sorted by key, which is not typically a user selected sort order, as the values of the keys are not usually known by the user and frequently do not correspond to any property that is relevant to the user.
- indexes are selected to execute the query based on the properties that are included in the index.
- Datastore Server 106 provides services for a plurality of different applications, and each application has its own set of indexes for performing queries.
- each application defines its indexes in a configuration file.
- indexes for some types of commonly received queries are optionally provided automatically by Datastore Server 106 .
- Datastore Server 106 can automatically add suggestions for new indexes to create to the configuration file when it encounters a query that cannot be performed because indexes adapted for performing the query have not been created.
- a developer of the application can manually specify indexes to be created in anticipation of queries that are likely to be executed by the application.
- Datastore Server 106 updates the indexes (e.g., by updating the values for properties for the entities when the entities are modified).
- the query is passed to Datastore Server 106 , which generates results using indexes corresponding to the query.
- a default sort order can be used. For example, in FIG. 5B , all of the index portions are sorted by primary key in ascending order.
- a custom sort order e.g., sorting by values of one or more of the properties, such as date or relevance
- the indexes must include indexes with index portions sorted in the custom sort order.
- the query-processing capabilities of Datastore Server 106 at any given point in time are enabled by or depend on the indexes present at Datastore Server 106 at that point in time. Consequently, if specific indexes—such as indexes with index portions sorted in the custom sort order—that are required for the execution of specific queries or query-processing steps—such as queries that include custom sort orders—are absent at Datastore Server 106 , then those specific queries or query-processing steps are determined to be unsupported queries or query-processing steps at Datastore Server 106 at that point in time.
- the indexes shown in FIG. 5B do not support sorting results by values of C. Thus, in the example illustrated in FIG. 5B , for any query that includes a query-processing step of sorting by C would be partially supported, with “sort by C” as an unsupported query-processing step (provided that at least one of the other query-processing steps were supported).
- FIG. 5C illustrates example Indexes 142 for different properties for a plurality of entities having multiple properties and unique identifiers (keys), where the indexes are sorted in a custom sort order (e.g., sorted by values of C).
- the indexes (Index AC 142 -AC, Index BC 142 -BC) illustrated in FIG. 4C are for responding to queries that have a custom sort order (e.g., sorted alphabetically by values of property C).
- This custom sort order is merely an example and it should be understood that a set of indexes can be generated that is adapted for responding to search queries that have any custom sort order on values of any property or any combination of values of different properties (e.g., date descending and relevance descending).
- each index has index entries (rows) sorted in accordance with values of two properties and a key (columns).
- there will be at least two index entries for the entity e.g., two index entries in the same index with the same identifier but different filter values, one sorted in accordance with the first value of the property and another sorted in accordance with the second value of the property.
- Each of the example indexes in FIG. 5C is adapted for responding to queries including a filter for the respective property included in the index (e.g., A or B for Index AC 142 -AC or Index BC 142 -BC, respectively).
- Index 142 -AC includes portions that are indicated by the values of A and are sorted in a sort order in accordance with values of property C and key (e.g., Index AC 142 -AC is sorted in accordance with a postfix of the form (C, key)).
- Index 142 -BC includes portions that are indicated by the values of B and are sorted in a sort order in accordance with values of property C and key (e.g., Index BC 142 -BC is sorted in accordance with a postfix of the form (C, key)).
- Index 142 -CA includes portions that are indicated by the values of C and are sorted in a sort order in accordance with values of property A and key (e.g., Index CA 142 -CA is sorted in accordance with a postfix of the form (A, key)). For example, similar to Index A 142 -A in FIG.
- Index A 142 -A where the index portions were sorted only by key
- Index AC 142 -C the index portions are sorted by values of property C and key, or a “postfix” in the form (C, key).
- Index C 142 -C where the index portions were sorted only by key
- Index BC 142 -C the index portions are sorted by values of property A and key, or a “postfix” in the form (A, key).
- the sort order of several of the index portions in FIG. 5C is different from the sort order of the index portions in FIG. 5B .
- index AC 142 -AC and Index BC 142 -BC are used to respond to the query.
- Index AC 142 -AC and Index BC 142 -BC are used to respond to the query.
- an index adapted for responding to the query will include a column for each property used in a filter or sort order.
- the rows are sorted by the following aspects, in order: property values used in equality filters property values used in inequality filters property values used in sort orders. Additionally, it should be understood that a given index could be adapted for responding to multiple different queries.
- this index generation scheme will entail the creation of a large number of indexes so that there is an index adapted for performing each of the likely queries that can be requested by a client
- the sorting of the indexes puts all index entries matching every possible query that uses an index in consecutive rows in the index. Consequently, once a first index entry is found that matches all of the filters of a query, all of the index entries in the index that match the query will be ordered consecutively in the index in the sort order of the index.
- Datastore Server 106 can quickly identify subsequent matching index entries without searching through the whole index (e.g., by sequentially stepping through index entries row by row).
- Datastore Server 106 has confirmation that the index does not contain any other matching index entries.
- a second identifier in an index portion or set of index portions is “sequentially adjacent” to a first identifier (e.g., a previously retrieved identifier), even when the first identifier is not present in the index portion or set of index portions, when the second identifier is the next higher identifier, for ascending order, or the next lower identifier, for descending order, in the index portion or set of index portions that matches the filter(s) of the second operand (e.g., in the sequence 1, 4, 6, 9, 13, the value “9” is sequentially adjacent to “7” in the ascending direction and the value “6” is sequentially adjacent to “7” in the descending direction).
- a first identifier e.g., a previously retrieved identifier
- the first example which generates intermediate results and an unsupported query-processing step, describes executing the example query using the index portions (Index A 142 -A and Index B 142 -B) previously described with reference to FIG. 5B .
- the second example which generates a final result, describes executing the example query using the index portions (Index AC 142 -AC and Index BC 142 -BC) previously described with reference to FIG. 5C .
- Query-processing steps are determined to be “supported” versus “unsupported” by the datastore server system in the context of existing indexes present at the datastore server.
- Existing indexes enable the datastore server to support a set of query-processing capabilities that would not be readily present without the indexes.
- a custom sort order e.g., sorting by values of one or more of the properties, such as date or relevance
- Datastore Server 106 must have indexes with index portions sorted in the custom sort order.
- the query-processing capabilities of Datastore Server 106 at any given point in time are enabled by or depend on the indexes present at Datastore Server 106 at that point in time.
- query-processing steps are determined to be “supported” versus “unsupported” by Datastore Server 106 in the context of a specific query-processing plan.
- query-processing steps that are supported according to one query-processing plan are, in some situations, not supported according to another query-processing plan.
- the query-processing step ‘Sort by C’ is supported in itself based on Index C 142 -C.
- Index C 142 -C is supported in itself based on Index C 142 -C.
- the query-processing capabilities (including the set of “supported” query-processing steps) of Datastore Server 106 are enabled by or depend on the indexes present at Datastore Server 106 .
- query-processing steps are determined to be “supported” based whether indexes are readily available at Datastore Server 106 to enable resource-efficient or optimized processing of the query-processing steps.
- One measure of resource-efficiency in query-processing is that when a query can be performed by a single pass through sorted index portions, the time for query-processing scales with the number of results retrieved whereas in many conventional query processing techniques, the time for query-processing scales with the number of entries or entities searched.
- “supported” query-processing steps can also be referred to as “optimized” query-processing steps or “enhanced-efficiency” query-processing steps, or “resource-efficient” query-processing steps.
- “unsupported” query-processing steps can also be referred to as “non-optimized” or “non-enhanced-efficiency” or “resource-intensive” query-processing steps.
- a query-processing plan for processing Query 550 is generated that includes two steps: Supported Step 551 - a ((A AND B) sorted by Key) which can be executed using Index A 142 -A and Index B 142 -B (or portions thereof) as explained below and Unsupported Step 552 (Sort by C).
- Supported Step 551 - a ((A AND B) sorted by Key) is performed on Index A 142 -A and Index B 142 -B.
- an unsupported or unperformed query-processing step (in this example, Unsupported Step 552 (Sort by C)) has unconstrained resource requirements—i.e., the unperformed or unsupported query-processing step would require an unknown amount of processing power that cannot be calculated by Datastore Server 106 a-priori. For instance, in the example shown in FIG.
- Datastore Server 106 would not be able to calculate a-priori the amount of power required to execute Unsupported Step 552 (Sort by C) using the existing Indexes 142 .
- the results include only three entries, but in reality, the intermediate results could include significantly larger data sets.
- Datastore Server 106 will not perform query-processing steps that might cause Datastore Server 106 to be overwhelmed or overloaded (or place an excessive demand on its resources, such as processing power, time, memory etc.) or that will degrade the ability of Datastore Server 106 to enforce isolation across requests (e.g., reducing the impact of any one request on other requests by Datastore Server 106 by preventing the request from monopolizing the resources of Datastore Server 106 ).
- Datastore Server 106 After generating Intermediate Result 554 , Datastore Server 106 generates Response 553 - a including Intermediate Result 554 (e.g., including Keys 1, 4, and 5) and the Unsupported Step 552 (e.g., Sort by C). Datastore Server 106 transmits Response 553 - a to the requestor. The requestor, in turn, performs Unsupported Step 552 on Intermediate Result 554 to generate a final result. While sending the requestor incompletely processed results along with information indicating that how to complete the processing causes the requestor to utilize additional resources to finish executing the query, this approach has several advantages for the requestor. As a preliminary matter, producing intermediate results is more helpful to the requestor than producing no results, which would be an alternative way to enforce fairness when executing queries.
- the enforcement of fairness by Datastore Server 106 by refusing to execute unsupported query-processing steps means that other requestors will not be monopolizing Datastore Server 106 , so that Datastore Server 106 is available to respond to the requestor. Furthermore, in situations where the requestor has a processing budget at Datastore Server 106 (e.g., either a predefined limit of available compute cycles or processing time or price based on compute cycles or processing time used), passing computationally-intensive query-processing steps back to the requestor prevents the requestor from inadvertently exceeding the budget.
- a processing budget at Datastore Server 106 e.g., either a predefined limit of available compute cycles or processing time or price based on compute cycles or processing time used
- Datastore Server 106 has Indexes 142 sorted by two properties and then by Key (e.g., Indexes AC 142 -AC is sorted by A, C, and by Key; Index 142 -BC is sorted by B, C, and by Key; and Index CA is sorted by C, A, and by Key).
- the Indexes 142 described in the example of FIG. 5C could be created, for example, by Datastore Server 106 to support additional query processing steps that were not supported by Datastore Server 106 prior to the creation of the additional set of Indexes 142 described in FIG. 5C .
- Datastore Server 106 could undertake the task (or be instructed to undertake the task) of generating the indexes shown in FIG. 5C , which enable filtering and sorting by C to be supported query-processing steps in the same query-processing plan.
- Query 550 is determined to include Supported Step 551 - b ((A AND B) sorted by C) which can be executed using Index AC 142 -AC and Index BC 142 -BC (or portions thereof) as explained below.
- Supported Step 551 - b ((A AND B) sorted by C) which can be executed using Index AC 142 -AC and Index BC 142 -BC (or portions thereof) as explained below.
- Supported Step 551 ((A AND B) sorted by Key) is performed on Index AC 142 -AC and Index BC 142 -BC.
- Index BC 142 -BC is sorted in accordance with a postfix of the form (C, key).
- Datastore Server 106 does not have to consider the index entry in Index AC 142 -AC with postfix (bar, 6), because that index entry is less than the current minimum postfix (foo1, 5). In principle, any number of index entries could be skipped in an analogous manner.
- Final Result 556 includes Keys 4, 5, and 1. These entities are obtained in order, sorted by C. Consequently, Final Result 556 corresponds to the final result to Query 550 .
- the keys for matching entities are retrieved from Indexes ordered by Key, ascending (e.g., 1, 4, 5) while in the Example illustrated in FIG.
- Datastore Server 106 does have the capabilities (or Indexes) to support Query 550 , including Supported Step 551 - b ((A AND B) Sorted by C).
- Sorting by C is a supported query-processing step in FIG. 5C
- sorting by C is not a supported query-processing step in FIG. 5B .
- Datastore Server 106 After generating Final result 566 , Datastore Server 106 generates Response 553 - b including Final Result 556 (e.g., including Keys 4, 5, and 1) Datastore Server 106 transmits Response 553 - b to the requestor.
- FIGS. 5A-5C have been described with reference to examples that have been simplified to better highlight particularly relevant aspects of the described query execution techniques, in reality, queries are more complex (queries can be expressed using a virtually unlimited number of combinations of multiple filter parameters and sort orders). Also, in many common use cases, indexes will generally be much larger and contain a significantly large number of index entries, as the advantages provided by the query execution techniques described above are most substantial when executing queries against large databases.
- FIGS. 6A-6B include a flowchart representing a method 600 for receiving and processing queries from a requestor (e.g., Client 102 , App Server 104 ), at Datastore Server 106 and returning responses to the queries, according to certain embodiments.
- Method 600 is, optionally, governed by instructions that are stored in a non-transitory computer readable storage medium and that are executed by one or more processors of one or more computer systems (e.g., Client 102 , App Server 104 or Datastore Server 106 ).
- Each of the operations shown in FIGS. 6A-6B typically corresponds to instructions stored in a computer memory or non-transitory computer readable storage medium (e.g., memory 206 of Client 102 in FIG.
- the computer readable storage medium optionally includes a magnetic or optical disk storage device, solid state storage devices such as Flash memory, or other non-volatile memory device or devices.
- the computer readable instructions stored on the computer readable storage medium optionally includes one or more of: source code, assembly language code, object code, or other instruction format that is interpreted or executed by one or more processors. In various embodiments, some operations in method 600 are, optionally, combined and/or the order of some operations are, optionally, changed from the order shown in FIGS. 6A-6B .
- Datastore Server 106 receives ( 604 ) the first query.
- Datastore Server 106 obtains ( 606 ) a first query-processing plan, for example from Request Processor 124 (e.g., Query Planner 446 ), including a first plurality of query-processing steps for processing the query.
- Datastore Server 106 makes a determination as to whether the first plurality of query-processing steps includes one or more supported query-processing steps.
- Datastore Server 106 upon determining that the first plurality of query-processing steps does not ( 608 ) include one or more supported query-processing steps, Datastore Server 106 transmits all entities in the database to the requestor or, alternatively, Datastore Server 106 transmits an error message to the requestor.
- the requestor receives ( 610 ) all entities in the database or alternatively, receives the error message.
- one of these options is selected as a default which can be overridden if Datastore Server 106 determines that the other option (e.g., returning an error message) is more appropriate given the known capabilities of the requestor (e.g., that the requestor has a limited amount of memory that is smaller than the size of the data set including all entities in the database, or that the requestor has a slow network connection).
- Datastore Server 106 upon determining that the first plurality of query-processing steps does ( 612 ) include one or more supported query-processing steps, Datastore Server 106 makes a determination as to whether the first plurality of query-processing steps includes one or more unsupported query-processing steps. If the first plurality of query-processing steps does not ( 614 ) include one or more unsupported query-processing steps (e.g., if Datastore Server 106 has indexes that enable the entire query to be executed efficiently at Datastore Server 106 ), Datastore Server 106 generates a final response and transmits the final response to the requestor. The requestor receives ( 616 ) the final response.
- the first plurality of query-processing steps does ( 618 ) include one or more unsupported query-processing steps (e.g., query-processing steps that cannot be efficiently executed at Datastore Server 106 using existing indexes)
- Datastore Server 106 generates ( 620 ) a first response including intermediate results and a representation of the respective unsupported query-processing step.
- Query 550 includes Supported Step 551 - a ((A AND B) sorted by Key) and Unsupported Step 552 (Sort by C).
- Datastore Server 106 generates Response 553 - a including Intermediate Result 554 (e.g., Keys 1 , 4 , and 5 ) and a representation of the unsupported query-processing step (in the example shown in FIG. 5B , Unsupported Step 552 (Sort by C)).
- Intermediate Result 554 e.g., Keys 1 , 4 , and 5
- Unsupported Step 552 (Sort by C)
- Datastore Server 106 transmits ( 622 ) the first response to the requestor.
- the requestor receives ( 624 ) the first response including intermediate results and a representation of one or more unperformed query-processing steps (e.g., the respective unperformed query-processing step).
- the requestor performs ( 626 ) the respective unperformed query-processing step on the intermediate results to produce final results for the query.
- Datastore Server 106 transmits Response 553 - a to the requestor, which receives Response 553 - a including Intermediate Result 554 and Unsupported Step 552 (Sort by C).
- the requestor can then perform the unperformed query-processing step (in example in FIG. 5B , Unsupported Step 552 (Sort by C) to produce final results.
- Unsupported Step 552 (Sort by C)
- the requestor would sort Intermediate Result 554 (in this example, Entities for Keys 1, 4, and 5) by C to produce a final result (Entities for Keys 4, 5, and 1).
- Datastore Server 106 generates ( 628 ) an additional index, wherein the additional index enables additional query-processing capabilities including the capability to support the respective unsupported query-processing step.
- Datastore Server 106 adds ( 630 ) the respective unsupported query-processing step to the set of supported query processing steps. In the example shown in FIG.
- the additional Indexes 142 Indexes 142 -AC and 142 -BC
- the additional Indexes enable additional query-processing capabilities including the capability to support the previously unsupported query-processing step (e.g., Unsupported Step 552 (Sort by C), shown in the example of FIG. 5B ).
- the requestor transmits ( 632 ) a second query to Datastore Server 106 .
- Datastore Server 106 receives ( 634 ) the second query.
- the second query includes ( 638 ) a query expression that is the same or logically equivalent to a query expression of the first query.
- the second query and the first query are considered logically equivalent if they have the same logical content (e.g., if two operations performed on the same operands produce the same result, then the two operations are considered logically equivalent) or can be logically derived from one another.
- Some examples of logical equivalence are double negations (e.g., A ⁇ NOT(NOT(A))), commutativity of ‘and’ (e.g., A and B ⁇ B and A) commutativity of ‘or’ (e.g., A or B ⁇ B or A), associativity of ‘and’ (e.g., A and (B and C) ⁇ (A and B) and C), associativity of ‘or’ (e.g., A or (B or C) ⁇ (A or B) or C), De Morgan's laws (e.g., NOT(A or B) ⁇ NOT(A) and NOT(B); NOT(A and B) ⁇ NOT(A) or NOT(B), contrapositivity (e.g., if A then B ⁇ if NOT(B) then NOT(A)), etc.
- double negations e.g., A ⁇ NOT(NOT(A))
- commutativity of ‘and’ e.g., A
- Datastore Server 106 receives essentially the same query at two different times, the results will, in some situations, differ from each other if new capabilities have been added to Datastore Server 106 (e.g., by generating new indexes that enable the new capabilities), as described in greater detail below.
- Datastore Server 106 obtains ( 640 ) a second query-processing plan different from the first query-processing plan.
- the difference between the first and second query-processing plans might be that a query-processing step that was “unsupported” in the first query-processing plan is now “supported” in the second query-processing plan.
- the second query-processing plan includes ( 642 ) at least the new supported query-processing step that was not included as a supported query-processing step in the first query-processing plan.
- Datastore Server 106 generates the additional Indexes 142 (Indexes 142 -AC and 142 -BC) shown in the example in FIG.
- the additional Indexes enable additional query-processing capabilities including the addition of the previously unsupported query-processing step (e.g., Unsupported Step 552 (Sort by C), shown in the example of FIG. 5B ) to the second query-processing plan.
- Datastore Server 106 makes a determination as to whether the second query-processing plan includes any unsupported query-processing steps. If the second query-processing plan does not ( 644 ) include any unsupported query-processing steps, Datastore Server 106 returns a final response. The requestor receives ( 646 ) the final response. In the example shown in FIG. 5C , since the query-processing plan includes only Supported Step 551 - b and no unsupported query-processing step, Datastore Server 106 generates Response 553 - b including Final Result 556 . This result (Final Result 556 ) is different from the Intermediate Result 554 generated in the scenario demonstrated in FIG.
- Datastore Server 106 transmits ( 654 ) the second response.
- the requestor receives ( 656 ) the second response.
- the second intermediate result will be different from the first intermediate result, even if the data at Datastore Server 106 has not changed, due to the fact that a new query processing capability was used to generate the second intermediate result that was not available when generating the first intermediate result.
- entities, indexes, index entries, queries, query-processing steps (supported and unsupported), responses, and results described above with reference to method 600 optionally have one or more of the characteristics of the various entities, indexes, index entries, queries, query-processing steps (supported and unsupported), responses, and results described herein with reference to methods 700 and 800 .
- these details are not repeated here.
- FIGS. 7A-7D include a flowchart representing a method 700 for receiving and processing queries at a datastore server system and returning responses, according to certain embodiments.
- Method 700 is, optionally, governed by instructions that are stored in a non-transitory computer readable storage medium and that are executed by one or more processors of one or more servers (e.g., Datastore Server 106 , FIG. 4 ).
- Each of the operations shown in FIGS. 7A-7D typically corresponds to instructions stored in a computer memory or non-transitory computer readable storage medium (e.g., memory 406 of Datastore Server 106 in FIG. 4 ).
- the computer readable storage medium optionally includes a magnetic or optical disk storage device, solid state storage devices such as Flash memory, or other non-volatile memory device or devices.
- the computer readable instructions stored on the computer readable storage medium optionally includes one or more of: source code, assembly language code, object code, or other instruction format that is interpreted or executed by one or more processors.
- some operations in method 700 are, optionally, combined and/or the order of some operations are, optionally, changed from the order shown in FIGS. 7A-7D .
- the respective server system (e.g., Datastore Server 106 ) has ( 702 ) a set of supported query-processing steps.
- Supported query-processing steps comprise ( 704 ) query-processing steps in the set of supported query-processing steps.
- Unsupported query-processing steps comprise ( 706 ) query-processing steps not in the set of supported query-processing steps.
- the determination as to whether a respective query-processing step is supported/unsupported is conditioned upon one or more query processing steps that precede the respective query-processing step in the query-processing plan. For example, under one set of circumstances sorting by A then B or sorting by B then C is supported, but sorting by A then B then C is not supported. In this example, sorting by C is supported if a prior step in the plan includes sorting by A or sorting by B, but sorting by C is not supported if prior steps in the plan include sorting by A then B.
- sorting of results is performed as an integral part of retrieving results, and thus different sorting steps are not performed sequentially, rather the respective server system is either capable (e.g., has indexes that support) retrieving results sorted in a sort order, or it is not capable of doing so.
- a requested sort order e.g., sort by A then B then C
- a portion of the requested sort order e.g., sort by A then B
- the rest of the sorting e.g., sorting by C
- the respective server system has ( 708 ) a set of (preferred/resource-efficient) query-processing capabilities that are enabled by currently existing indexes of data accessible to the respective server system.
- the respective server system uses a set of sorted indexes to retrieve sorted results efficiently. However, when a particular index that is needed to process a respective portion of a query efficiently is not present, then the query-processing capabilities of the respective server system do not include a capability to process the respective portion of the query efficiently.
- the time to execute the query scales with the number of results retrieved rather than with the number of entries or entities searched (as would be the case absent the requisite index(es) at the respective server system), thereby making query-execution “efficient.”
- the set of supported query-processing steps is determined ( 710 ) in accordance with the currently existing indexes.
- the additional Indexes (Indexes 142 -AC, 142 -BC, and 142 -CA) as shown in the example in FIG. 5C
- the additional Indexes (Indexes 142 -AC, 142 -BC, and 142 -CA) enable additional query-processing capabilities including the capability to support the previously unsupported query-processing step (e.g., Unsupported Step 552 (Sort by C), shown in the example of FIG. 5B ).
- the respective server system receives ( 712 ) a first query from a requestor (e.g., Client 102 or App Server 104 ).
- Datastore Server 106 receives Query 550 from a requestor (e.g., Client 102 or App Server 104 ).
- the respective server system obtains ( 714 ) a first query-processing plan including a first plurality of query-processing steps for processing the query.
- the process of obtaining a respective query-processing plan includes generating, identifying or selecting the respective query-processing plan.
- a query-processing plan includes a set of steps (supported and unsupported) and an order in which the steps are to be executed (optionally, the supported steps all occur earlier in the order than the unsupported steps).
- the supported steps are performed as part of an integrated operation that scans a set of one or more indexes for identifiers of matching entities, as described in greater detail above with reference to FIGS. 5B-5C .
- information about what steps are supported and unsupported is not provided to potential requestors prior to receiving queries from the requestors, and thus the requestor from which the first query is received does not know a current set of supported/unsupported query processing steps prior to sending the first query to the respective server.
- obtaining the query-processing plan includes ( 716 ) generating a plurality of candidate query-processing plans and selecting a respective query-processing plan from the plurality of query-processing plans in accordance with predefined planning criteria.
- query-processing steps are determined to be supported or unsupported in the context of a query-processing plan.
- a query-processing step that is supported in one query-processing plan could be unsupported in another query-processing plan. For example, if results are filtered by X, Y and Z, then the results can only be sorted by A. However, if results are only filtered by X, then results can be sorted by A, B and C.
- the predefined planning criteria include ( 718 ) a number of sort orders that will be applied (e.g., preferentially selecting query-processing plans that include applying all of the sort orders specified in the search query).
- query plans that include more sort orders are preferred over query plans that include fewer sort orders. For example, if a query requires filtering by X, Y and Z, and sorting by A, B and C. Then query plans that include sorting steps (sorting by A, B, and C) are preferred over query plans that include all of the filtering steps but include fewer sorting steps (e.g., because sorting large sets of data can be a very resource-intensive operation).
- query plans that include more filters are preferred over query plans that include fewer filters. For example, if a query requires filtering by X, Y and Z, and sorting by A, B and C. Then query plans that include filtering steps (sorting by X, Y, and Z) are preferred over query plans that include all of the sorting steps but include fewer filtering steps (e.g., because applying more filters can substantially reduce the result set, thereby making it more efficient to sort the intermediate results produced by performing the filtering steps).
- the predefined planning criteria include ( 720 ) a restrictiveness of filters that are to be applied (e.g., so as to reduce the size of the intermediate results).
- the respective server system preferentially selects query-processing plans that include applying a most restrictive filter to reduce the number of results returned if all orders specified in the search query cannot be applied.
- the predefined planning criteria include ( 722 ) a preference for operations (e.g., filter operations and/or sort operations) to be performed indicated by the requestor (preferentially applying query-processing plans that include performing processing operations that the requestor indicated were important, for example, in accordance with an order in which filters or sort orders are listed in the query).
- operations e.g., filter operations and/or sort operations
- Datastore Server 106 would select a query-processing plan where ‘Sort by Age’ is a supported query-processing step using existing Indexes sorted by ‘Age.’ Additionally, if Datastore Server 106 does not have Indexes sorted by age, Datastore Server 106 optionally generates Indexes sorted by ‘Age’ so that the query-processing step can be included as a supported query-processing step in future query-processing plans.
- Obtaining the query-processing plan includes ( 724 ) selecting the first plurality of supported query-processing steps for inclusion in the query-processing plan and the first plurality of query-processing steps are selected by a query planner in accordance with a set of (preferred/resource-efficient) query-processing capabilities of the respective server system.
- the respective server system makes a determination as to whether the first plurality of query-processing steps includes one or more of the supported query-processing steps. In some embodiments, if the first plurality of query-processing steps does not ( 726 ) include one or more of the supported query-processing steps, the respective server system returns ( 728 ) all entities in the database to the requestor or transmits an error message to the requestor. As described above with reference to FIGS. 6A-6B , returning all entities in the database to the requestor would give the requestor an opportunity or option to execute the query on the returned entities, but might also risk overwhelming the requestor with an excessive amount of data that the requestor is potentially incapable of handling.
- the respective server system makes a determination as to whether the first plurality of query-processing steps includes one or more unsupported query-processing steps including a respective unsupported query-processing step.
- the respective server system if the first plurality of query-processing steps does not ( 732 ) include one or more of the unsupported query-processing steps, the respective server system generates ( 734 ) a final response.
- the respective server system transmits ( 736 ) the final response to the requestor. For example, in FIG. 5C , in the absence of an unsupported query-processing step, the respective server system generates Response 553 - b , including Final Result 556 (e.g., Index Entities for Keys 4, 5, and 1).
- the respective server system performs ( 740 ) the one or more supported query-processing steps to produce intermediate results.
- the respective server system generates ( 742 ) a first response to the first query that includes the intermediate results and a representation of the respective unsupported query-processing step. While the following discussion is with respect to a single unsupported query-processing step, in some circumstances, the first query-processing plan includes a plurality of respective unsupported query-processing steps, which are handled in an analogous manner to the respective unsupported query-processing step described below (e.g., the first response includes a representation of the plurality of unsupported query-processing steps).
- the representation of the respective unsupported query-processing step includes an indication of any sort orders, filters and/or other query processing steps that have not yet been applied to the intermediate results.
- Query 550 includes Supported Step 551 - a ((A AND B) sorted by Key) and Unsupported Step 552 (Sort by C). Consequently, the respective server system generates Response 553 - a including Intermediate Result 554 and a representation of the unsupported query-processing step (in the example shown in FIG. 5B , Unsupported Step 552 ).
- the representation of the respective unsupported query-processing step enables ( 744 ) the requestor to perform the respective unsupported query-processing step on the intermediate results.
- the respective server system e.g., Datastore Server 106 transmits Response 553 - a to the requestor (e.g., Client 102 or App Server 104 ), which receives Response 553 - a including Intermediate Result 554 and Unsupported Step 552 (Sort by C).
- the requestor e.g., Client 102 or App Server 104
- Receives Response 553 - a including Intermediate Result 554 and Unsupported Step 552 (Sort by C).
- Obtaining Intermediate Result 554 and Unsupported Step 552 would enable the requestor to then perform the unperformed query-processing step (in example in FIG. 5B , Unsupported Step 552 ) in order to produce final results.
- Unsupported Step 552 In the example shown in FIG.
- Intermediate Result 554 and Unsupported Step 552 would enable the requestor to sort Intermediate Result 554 by C to produce a final result (Entities for Keys 4, 5, and 1).
- the respective server system transmits ( 746 ) the first response to the requestor (e.g., Client 102 or App Server 104 ).
- the respective server system makes a determination as to whether the first query-processing plan for the first query includes the respective unsupported query-processing step. Upon determining that the first query-processing plan for the first query includes ( 752 ) the respective unsupported query-processing step, the respective server system generates ( 754 ) an additional index. The respective server system could generate an additional index(es) to support one or more respective unsupported query-processing steps, for example, if the respective server system receives multiple queries that include the one or more respective unsupported query-processing steps.
- the additional index enables ( 756 ) additional query-processing capabilities including the capability to support the respective unsupported query-processing step.
- the respective server system adds ( 758 ) the respective unsupported query-processing step to the set of supported query-processing steps. In the example shown in FIG.
- the respective server system generates the additional Indexes 142 (e.g., Indexes 142 -AC and 142 -BC shown in the example in FIG.
- the additional Indexes (e.g., Indexes 142 -AC and 142 -BC) enable additional query-processing capabilities including the capability to support the previously unsupported query-processing step (e.g., Unsupported Step 552 (Sort by C), shown in the example of FIG. 5B ).
- the respective server system after generating the first response, in sequence, adds ( 760 ) a new supported query-processing step to the set of supported query-processing steps (e.g., by adding a new index that supports efficient processing of a previously unsupported query processing step (see steps 754 - 758 )); receives ( 762 ) a second query that includes a query expression that is the same or logically equivalent to a query expression of the first query; and obtains ( 766 ) a second query-processing plan different from the first query-processing plan.
- the second query processing plan includes ( 768 ) at least the new supported query-processing step that was not included as a supported query-processing step in the first query-processing plan.
- the second query-processing plan also includes one or more unsupported query-processing steps.
- the query e.g., Query 550
- the query-processing plan would include at least the unsupported query-processing step ‘Sort by D.’
- the second query-processing plan does not include any unsupported query-processing steps (e.g., because the newly supported query-processing step provides the respective server system with the capability to efficiently perform the steps in the second query-processing plan.
- the new supported query-processing step in the second query-processing plan corresponds to ( 770 ) the respective unsupported query-processing step in the first query-processing plan.
- the query-processing step ‘Sort by C’ namely, Unsupported Step 552
- the additional Indexes 142 enable additional query-processing capabilities including the addition of the previously unsupported query-processing step (e.g., Unsupported Step 552 (Sort by C), shown in the example of FIG. 5B ) to the second query-processing plan (e.g., the query-processing plan of FIG. 5C ).
- the respective server system makes a determination as to whether the second query-processing plan does not include any unsupported query-processing steps. Upon determining that the second query-processing plan does not ( 772 ) include any unsupported query-processing steps, the respective server system performs ( 774 ) the second query-processing plan to generate final results and generates ( 776 ) a second response to the second query that includes the final results. After generating the final results, Datastore Server transmits ( 777 ) the second response (e.g., including the final results) to a requestor from which the second query was received. In the example shown in FIG.
- the respective server system since the query-processing plan includes only Supported Step 551 - b and no unsupported query-processing step, the respective server system generates Response 553 - b including Final Result 556 .
- the respective server system upon determining that the second query-processing plan does ( 778 ) include any unsupported query-processing steps, the respective server system performs ( 780 ) the supported query-processing steps from the second query-processing plan to produce a second intermediate result (e.g., different from the first intermediate result).
- the respective server system generates ( 782 ) a second response to the second query that includes the second intermediate result and a representation of the one or more unsupported query-processing steps (e.g., ‘Sort by D’) for the second query-processing plan.
- the respective server system transmits ( 777 ) the second response (e.g. including the second intermediate result and a representation of the one or more unsupported query-processing steps) to a requestor from which the second query was received.
- the same requestor transmits both the first query and the second query to the respective server system.
- different requestors transmit the first and second queries to the respective server system (e.g., a first requestor transmits the first query and a second requestor transmits the second query).
- FIGS. 7A-7D have been described are merely examples and are not intended to indicate that the described order is the only order in which the operations could be performed.
- One of ordinary skill in the art would recognize various ways to reorder the operations described herein. Additionally, it should be noted that details of other processes described herein with respect to methods 600 and 800 (described herein with reference to FIG. 6A-6B or 8 respectively) are also applicable in an analogous manner to method 700 described above with respect to FIGS. 7A-7D .
- entities, indexes, index entries, queries, query-processing steps (supported and unsupported), responses, and results described above with reference to method 700 optionally have one or more of the characteristics of the various entities, indexes, index entries, queries, query-processing steps (supported and unsupported), responses, and results described herein with reference to methods 600 and 800 .
- these details are not repeated here.
- FIG. 8 includes a flowchart representing a method 800 transmitting queries from a client or application server system and receiving responses, according to certain embodiments.
- Method 800 is, optionally, governed by instructions that are stored in a non-transitory computer readable storage medium and that are executed by one or more processors of one or more servers (e.g., App Server 104 , FIG. 3 ).
- Each of the operations shown in FIG. 8 typically corresponds to instructions stored in a computer memory or non-transitory computer readable storage medium (e.g., memory 306 of App Server 104 in FIG. 3 ).
- the computer readable storage medium optionally includes a magnetic or optical disk storage device, solid state storage devices such as Flash memory, or other non-volatile memory device or devices.
- the computer readable instructions stored on the computer readable storage medium optionally includes one or more of: source code, assembly language code, object code, or other instruction format that is interpreted or executed by one or more processors.
- some operations in method 800 are, optionally, combined and/or the order of some operations are, optionally, changed from the order shown in FIG. 8 .
- a requestor (e.g., Client 102 or App Server 104 ) transmits ( 802 ) a query to a datastore server (e.g., Datastore Server 106 ).
- a datastore server e.g., Datastore Server 106
- Client 102 communicates requests directly to Datastore Server 106 .
- Client 102 communicates with a backend application at App Server 104 and App Server 104 acts as an intermediary and sends requests to Datastore Server 106 on behalf of Client 102 .
- the requestor receives ( 804 ) a response to the query that includes intermediate results and a representation of one or more unperformed query-processing steps including a respective unperformed query-processing step generated by Datastore Server 106 based on the query (e.g., based on analysis of the query by Datastore Server 106 ). For example, as shown in FIG. 5B , the requestor receives Response 553 - a to Query 550 , which includes Intermediate Result 554 (Keys 1, 4, and 5) and Unsupported Step 552 (Sort by C).
- Datastore Server 106 is configured ( 806 ) to perform one or more processing steps for processing the query more efficiently than the requestor. For example, as shown in the entity-index configuration of FIG. 5A-5C , Datastore Server 106 can perform searches across large datasets efficiently due to the presence of Indexes 142 to support complex searches across large quantities of data entities.
- the requestor is configured ( 808 ) to perform the respective unperformed query-processing step at least as efficiently as Datastore Server 106 . For example, a sorting step (e.g., Unsupported Step 552 (Sort by C), in the example shown in FIG.
- Datastore Server 106 is configured ( 810 ) to perform one or more processing steps for processing the query that have constrained resource requirements, as described in greater detail above with reference to method 700 (e.g., steps 714 - 740 ) and the respective unperformed query-processing step has unconstrained resource requirements.
- the one or more processing steps would require a known amount of processing power that can be calculated a-priori (e.g., in the examples shown in FIG. 5B , the cost of performing Supported Step 551 - a using Index A 142 -A and Index B 142 -B would scale with the number of results retrieved rather that the number of data items, or index entries, searched).
- the unperformed query-processing step when the unperformed query-processing step has unconstrained resource requirements, the unperformed query-processing step will use an unknown amount of processing power that cannot be calculated a-priori. For instance, in the example shown in FIG. 5B , Datastore Server 106 would not be able to calculate a-priori the amount of power required to execute Unsupported Step 552 (Sort by C) using the existing Indexes 142 .
- Datastore Server 106 will not perform query-processing steps that might cause Datastore Server 106 to be overwhelmed or overloaded (or place an excessive demand on its resources, such as processing power, time, memory etc.) or that will degrade the ability of Datastore Server 106 to enforce isolation across requests (e.g., reducing the impact of any one request on other requests by Datastore Server 106 by preventing the request from monopolizing the resources of Datastore Server 106 ).
- the query includes ( 812 ) a plurality of prioritized operations including a set of one or more high priority operations and a set of one or more low priority operations.
- the intermediate results include results generated by performing query-processing steps corresponding to the set of one or more high priority operations.
- the respective unperformed query-processing step corresponds to one of the low priority operations.
- the requestor can prioritize operations included in the query to influence the decision by Datastore Server 106 as to which operations to include in the query processing plan as supported query-processing steps if the query is not fully supported.
- Datastore Server 106 will, in many situations, select a low priority (or the lowest priority) operation as one of the unsupported query-processing steps.
- the respective unperformed query-processing step is not supported ( 814 ) by Datastore Server 106 (e.g., the unperformed query-processing step described herein is one of the unsupported query-processing steps described above with reference to method 700 ).
- the requestor Prior to transmitting the query to Datastore Server 106 , the requestor does not have information indicating whether or not the respective unperformed query-processing step is supported by Datastore Server 106 .
- the query-processing capabilities of Datastore Server 106 are not constant, but rather in flux due to the frequent addition of indexes at Datastore Server 106 that enable previously unsupported query-processing capabilities.
- the requestor would not have information indicating whether or not a certain query-processing step is supported by Datastore Server 106 based on the current query-processing capabilities of Datastore Server 106 .
- the requestor After receiving the response, the requestor performs ( 816 ) the respective unperformed query-processing step on the intermediate results to produce final results for the query.
- the respective unperformed query-processing step is a query-processing step that is not in a set of supported query processing steps that are supported by Datastore Server 106 .
- This alternative provides no information other than that the query is not supported and thus leaves the requestor to determine how the query should be changed to get some results.
- Datastore Server 106 when Datastore Server 106 is unable to perform any portion of a query transmitted by a requestor, Datastore Server 106 returns all entities to the requestor to allow the requestor to perform the entire query. This alternative provides an overload of information to the requestor and does not leverage the specialized capabilities of Datastore Server 106 to perform some portions of the query efficiently.
- the method described herein (performing part of the query at Datastore Server 106 and returning intermediate results along with a representation of the unperformed query-processing step) enables the requestor to arrive at a final response (by executing only the unperformed query-processing step(s) on the intermediate results), without having to perform the entire query, thereby providing substantial gains in efficiency for the requestor.
- the entities, indexes, index entries, queries, query-processing steps (supported and unsupported), responses, and results described above with reference to method 800 optionally have one or more of the characteristics of the various entities, indexes, index entries, queries, query-processing steps (supported and unsupported), responses, and results described herein with reference to methods 600 and 700 .
- these details are not repeated here.
Abstract
Description
-
- an
Operating System 210 that includes procedures for handling various basic system services and for performing hardware dependent tasks; - a Network Communication Module (or instructions) 212 that is used for connecting
Client System 102 to other computers (e.g.,Application Server System 104,Datastore Server System 106 or Other Message Server Systems 108) via one or more Network Interfaces 204 (wired or wireless) and one or more Communication Networks 120 (FIG. 1 ), such as the Internet, other wide area networks, local area networks, metropolitan area networks, and so on; - a
Web Browser 110 for loading web pages such as aWeb Page 214, which optionally includes code for executing a Client Application 112-a as an embedded application inWeb Page 214, where Client Application 112-a sends requests toApp Server 104 orDatastore Server 106 and displays data received fromApp Server 104 orDatastore Server 106, in some implementations Client Application 112-a transmits requests to execute partially supported queries and is the “requestor” described below and in other implementations, Client Application 112-b transmits requests to an intermediary backend application (e.g., Application 130) atApp Server 104 which transmits corresponding request(s) toDatastore Server 106; - a dedicated Client Application 112-b (e.g., a stand-alone email client) for sending requests to
App Server 104 orDatastore Server 106 and displaying data received fromApp Server 104 orDatastore Server 106, in some implementations Client Application 112-b transmits requests to execute partially supported queries and is the “requestor” described below and in other implementations, Client Application 112-b transmits requests to an intermediary backend application (e.g., Application 130) atApp Server 104 which transmits corresponding request(s) toDatastore Server 106; - optionally,
Query Planner 215 for planning the execution of a query at Datastore Server 106 (e.g., generating a set of query-processing steps for executing the query), this query plan includes, in some situations, relative priorities for the query-processing steps (e.g., indicating that some query-processing steps have a higher priority than other query-processing steps). In some implementations, prior to transmitting the query,Client 102 does not have any information indicating whether or not a respective unperformed query-processing step (e.g., a query processing step included in Unprocessed Query-Processing Steps 218) is supported byDatastore Server 106 and thus generates queries forDatastore Server 106 without regard to whether or not the query-processing steps that will be used to perform the query are supported byDatastore Server 106; and - optionally,
Data 216 such as cached data (e.g., recently accessed results, recent queries, etc.) such as results (including Intermediate Result(s) 220) from one or more prior queries and Unprocessed Query-Processing Steps 218 returned fromDatastore Server 106. Client 102 (e.g., using Query Planner 215) optionally performs Unprocessed Query-Processing Steps 218 on Intermediate Result(s) 220 to produce a final result. Unprocessed Query-Processing Steps 218 are query-processing steps not supported byDatastore Server 106, which optionally correspond to operations thatClient 102 indicated were low priority operations. Intermediate Result(s) 220 include results generated byDatastore Server 106 by performing a set of one or more supported query-processing steps, which optionally correspond to operations thatClient 102 indicated were high priority operations.
- an
-
- an
Operating System 310 that includes procedures for handling various basic system services and for performing hardware dependent tasks; - a Network Communication Module (or instructions) 312 that is used for connecting
App Server 104 to other computers (e.g.,Client 102 and Datastore Server 106) via one or more Network Interfaces 304 (wired or wireless) and one or more Communication Networks 102 (FIG. 1 ), such as the Internet, other wide area networks, local area networks, metropolitan area networks, and so on; - a
Frontend Server 122 for coordinating communication betweenApp Server 104,Clients 102,Datastore Server 106 and any other computer systems with whichApp Server 104 communicates; -
Application 130 for communicating withDatastore Server 106 and serving as an intermediary backend application for a client application atClient 102, in someimplementations Application 130 transmits requests to execute partially supported queries and is the “requestor” described below; -
Query Planner 132 for planning the execution of a query at Datastore Server 106 (e.g., generating a set of query-processing steps for executing the query), this query plan includes, in some situations, relative priorities for the query-processing steps (e.g., indicating that some query-processing steps have a higher priority than other query-processing steps). In some implementations, prior to transmitting the query,App Server 104 does not have any information indicating whether or not a respective unperformed query-processing step (e.g., a query processing step included in Unprocessed Query-Processing Steps 134) is supported byDatastore Server 106 and thus generates queries forDatastore Server 106 without regard to whether or not the query-processing steps that will be used to perform the query are supported byDatastore Server 106; and -
Data 316 such as cached data (e.g., recently accessed results, recent queries, etc.), such as results (including Intermediate Result(s) 136) from one or more prior queries and Unprocessed Query-Processing Steps 134 returned fromDatastore Server 106. App Server 104 (e.g., using Query Planner 132) optionally performs Unprocessed Query-Processing Steps 136 on Intermediate Result(s) 136 to produce a final result. Unprocessed Query-Processing Steps 134 are query-processing steps not supported byDatastore Server 106, which optionally correspond to operations thatApp Server 104 indicated were low priority operations. Intermediate Result(s) 136 include results generated byDatastore Server 106 by performing a set of one or more supported query-processing steps, which optionally correspond to operations thatApp Server 104 indicated were high priority operations.
- an
-
- an
Operating System 410 that includes procedures for handling various basic system services and for performing hardware dependent tasks; - a Network Communication Module (or instructions) 412 that is used for connecting
Datastore Server 106 to other computers (e.g.,Client 102, App Server 104) via one or more Network Interfaces 404 (wired or wireless) and one or more Communication Networks 102 (FIG. 1 ), such as the Internet, other wide area networks, local area networks, metropolitan area networks, and so on; - a
Frontend Server 122 for coordinating communication betweenDatastore Server 106,Clients 102,App Server 104 and any other computer systems with whichDatastore Server 106 communicates; - a
Request Processor 124, optionally includingQuery Planner 446, for generating a query plan for processing a query received fromClient 102 orApp Server 104 into a query to be executed byQuery Engine 126; for multi-step queries, the converting optionally includes revising the order and/or composition of the steps so as to improve the speed and/or efficiency of performing the query (e.g., by reducing the number of required index scans and/or performing steps that are likely to eliminate a large number of non-matching entities earlier in the process); - a
Query Engine 126 for performing the query by identifying index portions and searching the index portions using the query;- an
Index Portion Identifier 424 for identifying index portions that are adapted for responding to a query (e.g., index portions that match all of the filters of a query and are sorted in same sort order, such as a sort order specified by the query); - one or more Filter (Index)
Scanners 426 for scanning through an index or index portion to retrieve an identifier of one or more next matching results (e.g., matching index entries that are sequentially adjacent to the last matching index entry in the sort order) in the index or index portion; - one or more Logical-
Relationship Scanners 428 for retrieving identifiers of matching entities from the index portions identified byIndex Portion Identifier 424 in accordance with the received query, the Logical-Relationship Scanners 428 typically include one or more of an AND_Scanner 440 (described in greater detail below with reference toFIGS. 5A-5B ), aNOT_Scanner 442 and an OR_Scanner;
- an
- a
Response Generator 128 for organizing information concerning matching entities identified byQuery Engine 126 and generating display information to be transmitted toClient 102 orApp Server 104, where the display information specifies formatting of the search results atClient 102; - an
Index Generator 130 for generating indexes for use in executing search queries, in someimplementations Index Generator 130 generates a large number of indexes (e.g., at least one index for each property that can be used to sort and/or filter search results), or a large index with a large number of different portions, so that for each possible combination of filters and sort orders in a search query, there exists an index including an index portion where the index entries matching the combination of filters are arranged in a contiguous block of index entries sorted in the sort order; - optionally, an
Entity Database 140 storing entities or information about entities; - one or
more Indexes 142 which store information about entities and properties of the entities, typically theIndexes 142 are each sorted in accordance with values of the properties for the entities, as described in greater detail below with reference toFIGS. 5A-5C ; - optionally, a
User Database 450 storing information about users and user query preferences, in some embodiments when the entities are user specific (e.g., a collection of a user's photos, emails or other documents), the user database identifies which entities and indexes the user has authority to access, theUser Database 450, optionally, stores other user account information; - Supported Query-
Processing Steps 148 corresponding to a set of query-processing steps that can be executed byDatastore Server 106 based on the current set ofIndexes 142 present atDatastore Server 106 or based on the current set of query-processing capabilities ofDatastore Server 106. In some circumstances whether or not a particular query-processing step is supported in a query plan depends on which other query-processing steps are already being performed as part of the query plan (e.g., a query plan can include “filtering by A, filtering by B and sorting by C,” or “filtering by A and sorting by B,” but not “filtering by A, sorting by B and sorting by C” and thus “sorting by C” is a supported query-processing step when the query plan already includes “filtering by A and filtering by B” but is an unsupported query-processing step when the query plan already includes “filtering by A and sorting by B”); - Intermediate Result(s) 138 generated by
Query Engine 126 by performing one or more Supported Query-Processing Steps 148 using one ormore Indexes 142, based on the query received fromClient 102 orApp Server 104; and - optionally, Query-Processing Plan(s) 454 (e.g., generated by
Query Planner 446 or a query planner atClient 102 or App Server 104) including at least a subset of Supported Query-Processing Steps 148 and optionally one or more unsupported query-processing steps to be performed atApp Server 104 orClient 102. Optionally, a candidate Query-Processing Plan is selected from a plurality of Query-Processing Plans 454 for the execution of a query received fromClient 102 orApp Server 104 based on predefined criteria such as preferences of a requestor and/or estimated efficiency of alternative query-processing plans.
- an
Claims (21)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/088,300 US9201924B1 (en) | 2012-11-26 | 2013-11-22 | Processing partially supported queries |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201261729999P | 2012-11-26 | 2012-11-26 | |
US14/088,300 US9201924B1 (en) | 2012-11-26 | 2013-11-22 | Processing partially supported queries |
Publications (1)
Publication Number | Publication Date |
---|---|
US9201924B1 true US9201924B1 (en) | 2015-12-01 |
Family
ID=54609242
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/088,300 Active 2034-05-31 US9201924B1 (en) | 2012-11-26 | 2013-11-22 | Processing partially supported queries |
Country Status (1)
Country | Link |
---|---|
US (1) | US9201924B1 (en) |
Cited By (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9600501B1 (en) * | 2012-11-26 | 2017-03-21 | Google Inc. | Transmitting and receiving data between databases with different database processing capabilities |
US20180107713A1 (en) * | 2016-10-13 | 2018-04-19 | International Business Machines Corporation | Adaptive query row selection |
US10180946B2 (en) | 2016-08-11 | 2019-01-15 | International Business Machines Corporation | Consistent execution of partial queries in hybrid DBMS |
US20200006904A1 (en) * | 2015-03-09 | 2020-01-02 | ZPE Systems, Inc. | Infrastructure management device |
US10657317B2 (en) * | 2018-02-27 | 2020-05-19 | Elasticsearch B.V. | Data visualization using client-server independent expressions |
US10997196B2 (en) | 2018-10-30 | 2021-05-04 | Elasticsearch B.V. | Systems and methods for reducing data storage overhead |
CN112788537A (en) * | 2019-11-07 | 2021-05-11 | 维沃移动通信有限公司 | Location query method, core network function and location service requester |
US11269906B2 (en) * | 2016-06-22 | 2022-03-08 | Palantir Technologies Inc. | Visual analysis of data using sequenced dataset reduction |
US11586695B2 (en) * | 2018-02-27 | 2023-02-21 | Elasticsearch B.V. | Iterating between a graphical user interface and plain-text code for data visualization |
US20230169212A1 (en) * | 2020-07-31 | 2023-06-01 | Snowflake Inc. | Data clean room |
Citations (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20070011154A1 (en) * | 2005-04-11 | 2007-01-11 | Textdigger, Inc. | System and method for searching for a query |
US20070073853A1 (en) * | 2005-09-13 | 2007-03-29 | Cognos Incorporated | Query framework system and method |
US20080109461A1 (en) * | 1999-09-28 | 2008-05-08 | University Of Tennessee Research Foundation | Parallel data processing architecture |
US20080177720A1 (en) * | 2007-01-19 | 2008-07-24 | Vladimir Mordvinov | System and method for query planning for execution using conditional operators |
US20120221711A1 (en) * | 2011-02-28 | 2012-08-30 | International Business Machines Corporation | Regular expression searches utilizing general purpose processors on a network interconnect |
US20130018729A1 (en) * | 2011-07-13 | 2013-01-17 | Alibaba Group Holding Limited | System and method for advertisement placement |
-
2013
- 2013-11-22 US US14/088,300 patent/US9201924B1/en active Active
Patent Citations (6)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20080109461A1 (en) * | 1999-09-28 | 2008-05-08 | University Of Tennessee Research Foundation | Parallel data processing architecture |
US20070011154A1 (en) * | 2005-04-11 | 2007-01-11 | Textdigger, Inc. | System and method for searching for a query |
US20070073853A1 (en) * | 2005-09-13 | 2007-03-29 | Cognos Incorporated | Query framework system and method |
US20080177720A1 (en) * | 2007-01-19 | 2008-07-24 | Vladimir Mordvinov | System and method for query planning for execution using conditional operators |
US20120221711A1 (en) * | 2011-02-28 | 2012-08-30 | International Business Machines Corporation | Regular expression searches utilizing general purpose processors on a network interconnect |
US20130018729A1 (en) * | 2011-07-13 | 2013-01-17 | Alibaba Group Holding Limited | System and method for advertisement placement |
Cited By (15)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9600501B1 (en) * | 2012-11-26 | 2017-03-21 | Google Inc. | Transmitting and receiving data between databases with different database processing capabilities |
US11849557B2 (en) * | 2015-03-09 | 2023-12-19 | ZPE Systems, Inc. | Infrastructure management device |
US20200006904A1 (en) * | 2015-03-09 | 2020-01-02 | ZPE Systems, Inc. | Infrastructure management device |
US11269906B2 (en) * | 2016-06-22 | 2022-03-08 | Palantir Technologies Inc. | Visual analysis of data using sequenced dataset reduction |
US11782941B2 (en) * | 2016-06-22 | 2023-10-10 | Palantir Technologies Inc. | Visual analysis of data using sequenced dataset reduction |
US20220147521A1 (en) * | 2016-06-22 | 2022-05-12 | Palantir Technologies Inc. | Visual analysis of data using sequenced dataset reduction |
US10262002B2 (en) | 2016-08-11 | 2019-04-16 | International Business Machines Corporation | Consistent execution of partial queries in hybrid DBMS |
US10180946B2 (en) | 2016-08-11 | 2019-01-15 | International Business Machines Corporation | Consistent execution of partial queries in hybrid DBMS |
US20180107713A1 (en) * | 2016-10-13 | 2018-04-19 | International Business Machines Corporation | Adaptive query row selection |
US10657317B2 (en) * | 2018-02-27 | 2020-05-19 | Elasticsearch B.V. | Data visualization using client-server independent expressions |
US11586695B2 (en) * | 2018-02-27 | 2023-02-21 | Elasticsearch B.V. | Iterating between a graphical user interface and plain-text code for data visualization |
US10997196B2 (en) | 2018-10-30 | 2021-05-04 | Elasticsearch B.V. | Systems and methods for reducing data storage overhead |
CN112788537A (en) * | 2019-11-07 | 2021-05-11 | 维沃移动通信有限公司 | Location query method, core network function and location service requester |
US20230169212A1 (en) * | 2020-07-31 | 2023-06-01 | Snowflake Inc. | Data clean room |
US11809600B2 (en) * | 2020-07-31 | 2023-11-07 | Snowflake Inc. | Data clean room |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9201924B1 (en) | Processing partially supported queries | |
US9342553B1 (en) | Identifying distinct combinations of values for entities based on information in an index | |
US9195698B2 (en) | Selectively retrieving search results in accordance with different logical relationships | |
US9600501B1 (en) | Transmitting and receiving data between databases with different database processing capabilities | |
US9948531B2 (en) | Predictive prefetching to reduce document generation times | |
US8412717B2 (en) | Changing ranking algorithms based on customer settings | |
JP5698222B2 (en) | Search method, apparatus and system | |
US9390142B2 (en) | Guided predictive analysis with the use of templates | |
US9148329B1 (en) | Resource constraints for request processing | |
US20080140637A1 (en) | Environment taxonomy | |
US8553259B2 (en) | Intelligent print options for search engine results | |
WO2013183115A1 (en) | Log management system and program | |
US9870394B2 (en) | Query routing method, query routing server performing the same and storage medium storing the same | |
US20190243914A1 (en) | Parallel query processing in a distributed analytics architecture | |
EP2674880A1 (en) | Creating optimal comparison criterion within associative memories | |
CN107025261B (en) | Topic network corpus | |
US9390131B1 (en) | Executing queries subject to different consistency requirements | |
US11762687B2 (en) | Processing of messages and documents carrying business transactions | |
CN110674387B (en) | Method, apparatus and computer storage medium for data search | |
CN112860736A (en) | Big data query optimization method and device and readable storage medium | |
US7523120B2 (en) | Recording medium in which document management program is stored, document management method, and document management apparatus | |
KR101054815B1 (en) | Search service provision system of multimedia data with multi-precision and its provision method | |
CN115455010B (en) | Data processing method based on milvus database, electronic equipment and storage medium | |
Chandrasekaran et al. | Efficient Web Service Discovery and Selection Model | |
JP4220483B2 (en) | Information collection system, information collection method and program |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:FULLER, ALFRED R.K.;REEL/FRAME:036312/0807Effective date: 20131121 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044334/0466Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 8TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1552); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 8 |