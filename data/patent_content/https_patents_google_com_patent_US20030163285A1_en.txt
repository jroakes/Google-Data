US20030163285A1 - XPath evaluation method, XML document processing system and program using the same - Google Patents
XPath evaluation method, XML document processing system and program using the same Download PDFInfo
- Publication number
- US20030163285A1 US20030163285A1 US10/375,970 US37597003A US2003163285A1 US 20030163285 A1 US20030163285 A1 US 20030163285A1 US 37597003 A US37597003 A US 37597003A US 2003163285 A1 US2003163285 A1 US 2003163285A1
- Authority
- US
- United States
- Prior art keywords
- xpath
- data structure
- expressions
- evaluation
- expression
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
- 238000011156 evaluation Methods 0.000 title claims abstract description 282
- 238000012545 processing Methods 0.000 title claims description 143
- 230000014509 gene expression Effects 0.000 claims abstract description 619
- 238000000034 method Methods 0.000 claims description 68
- 238000002910 structure generation Methods 0.000 claims description 47
- 230000008569 process Effects 0.000 claims description 33
- 230000006870 function Effects 0.000 claims description 30
- 238000000354 decomposition reaction Methods 0.000 claims description 9
- 238000013459 approach Methods 0.000 description 44
- 238000010586 diagram Methods 0.000 description 42
- 238000004364 calculation method Methods 0.000 description 11
- 230000008901 benefit Effects 0.000 description 6
- 230000010365 information processing Effects 0.000 description 6
- 235000013305 food Nutrition 0.000 description 5
- 230000008859 change Effects 0.000 description 4
- 238000010276 construction Methods 0.000 description 4
- 235000015220 hamburgers Nutrition 0.000 description 4
- 238000000926 separation method Methods 0.000 description 4
- 238000012163 sequencing technique Methods 0.000 description 4
- 238000012360 testing method Methods 0.000 description 4
- 239000012634 fragment Substances 0.000 description 3
- 230000003287 optical effect Effects 0.000 description 3
- 239000004065 semiconductor Substances 0.000 description 3
- 230000001419 dependent effect Effects 0.000 description 2
- 230000000694 effects Effects 0.000 description 2
- 238000001914 filtration Methods 0.000 description 2
- 230000010354 integration Effects 0.000 description 2
- 238000005457 optimization Methods 0.000 description 2
- 230000006798 recombination Effects 0.000 description 2
- 238000005215 recombination Methods 0.000 description 2
- 238000004904 shortening Methods 0.000 description 2
- PCTMTFRHKVHKIS-BMFZQQSSSA-N (1s,3r,4e,6e,8e,10e,12e,14e,16e,18s,19r,20r,21s,25r,27r,30r,31r,33s,35r,37s,38r)-3-[(2r,3s,4s,5s,6r)-4-amino-3,5-dihydroxy-6-methyloxan-2-yl]oxy-19,25,27,30,31,33,35,37-octahydroxy-18,20,21-trimethyl-23-oxo-22,39-dioxabicyclo[33.3.1]nonatriaconta-4,6,8,10 Chemical compound C1C=C2C[C@@H](OS(O)(=O)=O)CC[C@]2(C)[C@@H]2[C@@H]1[C@@H]1CC[C@H]([C@H](C)CCCC(C)C)[C@@]1(C)CC2.O[C@H]1[C@@H](N)[C@H](O)[C@@H](C)O[C@H]1O[C@H]1/C=C/C=C/C=C/C=C/C=C/C=C/C=C/[C@H](C)[C@@H](O)[C@@H](C)[C@H](C)OC(=O)C[C@H](O)C[C@H](O)CC[C@@H](O)[C@H](O)C[C@H](O)C[C@](O)(C[C@H](O)[C@H]2C(O)=O)O[C@H]2C1 PCTMTFRHKVHKIS-BMFZQQSSSA-N 0.000 description 1
- 230000005540 biological transmission Effects 0.000 description 1
- 238000013467 fragmentation Methods 0.000 description 1
- 238000006062 fragmentation reaction Methods 0.000 description 1
- 230000001788 irregular Effects 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 230000013011 mating Effects 0.000 description 1
- 230000002093 peripheral effect Effects 0.000 description 1
- 238000004064 recycling Methods 0.000 description 1
- 230000001172 regenerating effect Effects 0.000 description 1
- 230000004044 response Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/80—Information retrieval; Database structures therefor; File system structures therefor of semi-structured data, e.g. markup language structured data such as SGML, XML or HTML
- G06F16/81—Indexing, e.g. XML tags; Data structures therefor; Storage structures
Definitions
- the present invention relates to a technique for efficiently evaluating XPath expressions to specify a certain part of XLM or HTML documents using XPaths (XML Path Language).
- W3C World Wide Web Consortium
- XPath a recommendation for a path language to specify a certain part of an XML document.
- XPaths are used as a component of XPointer, XSLT, XQuery, etc., and also used to access a DOM (Document Object Model) tree for an XML document in a predetermined application program.
- DOM Document Object Model
- a complex XSLT style sheet includes a number of XPath expressions, which need to be evaluated with respect to an XML document to be an objective of processing.
- a predetermined web page can be reused in various ways and a new application can be developed by adding an annotation to a web page to be used for such purpose as exchanging data on Internet.
- An XPath is also used for associating an annotation with an element of a web page, because an HTML document used for writing a web page can specify a certain part by using an XPath expression in the same way as an XML document does.
- An efficient way to add an annotation to a web page is applying a particular annotation to a plurality of web pages for recycling. In this case, it requires to evaluate whether a plurality of XPath expressions in a predetermined annotation correctly specify a predetermined element in a targeted web page or not in order to determine whether the predetermined annotation is applicable to the predetermined web page or not.
- a feature of specifying a certain part of an XML document with an XPath is considered to be a condition for checking whether an XML document to be an objective for processing has a certain part specified by an XPath or not.
- WebLogic Collaborate http://www.bea.com/index.html
- a server system from U.S. BEA uses XPaths to write a condition for routing and filtering of a message expressed in XML.
- a plurality of XPath expressions should be evaluated for each time a XML document arrives.
- the expressions are limited with a variation of structures or element values of an objective data file and the like.
- the plurality of XPath expressions include similar expressions. Therefore, by retrieving and evaluating a common part from similar XPath expressions and sharing an evaluation result for the common part among the similar XPath expressions, an evaluation of XPaths can be performed quicker than in a way of evaluating a plurality of XPath expressions respectively.
- Dependency among XPath expressions in this context refers to; when a web page specified by a predetermined XPath expression includes two table contents (table [1], table [2]), for example, a relation where table [2] does not exist if table [1] does not exist, i.e., a relation where an evaluation of one or a part of a plurality of XPaths tells evaluation results for remaining XPaths.
- the present invention is intended to provide a method for obtaining an evaluation result in an efficient manner for a plurality of XPath expressions by taking advantage of the above-mentioned similarity or dependency among XPath expressions in evaluating a plurality of XPath expressions with respect to a data file such as an XML or HTML document.
- the present invention to accomplish the above-mentioned object is implemented as a following XPath evaluation method for evaluating a plurality of XPaths with respect to a predetermined data file by a computer.
- this XPath evaluation method is characterized by including the steps of generating a data structure that has a common part of a plurality of XPath expressions to be evaluated as a common node in a tree structure, evaluating the generated data structure in node-by-node basis with respect to a data file to be an objective of processing, and obtaining an evaluation result for each XPath expression by combining the evaluation results for each of the nodes.
- the above-mentioned step of generating a data structure specifically includes the steps of decomposing individual XPath expressions into steps, and associating a node with each step obtained from the decomposition and generating a data structure, in which a step common to a plurality of XPath expressions is associated with a single node.
- the step of generating a data structure can use a special data structure when a plurality of steps of XPath expressions are written in a common particular form, more specifically, when a predicate in the form of ‘[(expression)(comparison operator)(constant)]’ exists.
- a hash table for searching for remaining steps in an XPath can be generated by using an evaluation result for a predicate expression in a step as a key to evaluate the remaining steps in the XPath obtained from a search by means of the generated hash table.
- a binary search tree for searching for remaining steps in an XPath can be generated by using an evaluation result for a predicate expression in a step as a key to evaluate the remaining steps in the XPath obtained from a search by means of the generated binary search tree.
- the step of generating a data structure includes the steps of decomposing an operation expression or function into subexpressions when a plurality of XPath expressions include an operation expression or function, and generating a non-repeating directed graph by combining common subexpressions of the subexpressions obtained from decomposition.
- the step of evaluating an XPath expression includes the step of evaluating each XPath expression by using the generated non-repeating directed graph and sharing an evaluation result among a plurality of XPath expressions for a subexpression common to a plurality of XPath expressions.
- a data structure that has a common part as a common node in a tree structure can be generated as mentioned above, and the data structure can be used to perform an evaluation.
- Another XPath evaluation method is characterized by including the steps of extracting a common part from a plurality of XPath expressions to be evaluated, and obtaining an evaluation result for each XPath expression, with respect to a data file to be an objective of processing, by evaluating the common part and the other parts in the XPath expression separately and combining the evaluation results, wherein the step of obtaining an evaluation of an XPath expression includes a step of using an evaluation result obtained at an evaluation of another XPath as an evaluation result for a common part of a predetermined XPath expression if such an evaluation result exists, with respect to the common part when evaluating the predetermined XPath expression.
- Yet another XPath evaluation method is characterized by including a step of reading out an XPath set including a plurality of XPath expressions to be evaluated from a memory and generating a data structure with a redundant element in the XPath expressions included in the XPath set omitted, and a step of inputting a data file to be an objective of processing, evaluating the XPath set by using the data structure with respect to the data file, and storing the obtained evaluation result into a memory, in an XPath evaluation method for evaluating a plurality of XPaths with respect to a predetermined data file by a computer.
- an XPath expression commonly included in a plurality of XPath sets and an XPath expression unique to a predetermined XPath set are separated, and XPath expressions to be evaluated at an evaluation of the XPath sets are narrowed down.
- a connected XPath expression included in the XPath set is simplified by removing an XPath expression that can dispense with an evaluation from objectives of evaluation on the basis of dependency among respective XPaths constituting the connected XPath expression.
- an XPath expression that can dispense with an evaluation is removed from objectives of evaluation on the basis of dependency among a plurality of XPath expressions. And further, a part common to a plurality of XPath expressions and a part unique to each XPath expression are separated to make each part an objective of evaluation as an individual XPath expression.
- an XPath expression unique to each XPath set is initially evaluated, and if each of the unique XPath expressions matches a data file to be an objective of processing, XPath expressions common to the remaining XPath sets within the XPath sets are evaluated.
- the present invention to accomplish the above-mentioned object is also implemented as a document processing system configured in the following way.
- the document processing system is characterized by including an XPath storing part which stores a plurality of XPath expressions, a data structure-generation part for generating a data structure with redundant elements of a plurality of XPath expressions stored in the XPath-storing part being omitted, and an evaluation execution part for evaluating the plurality of XPath expressions with respect to a data file to be evaluated by using the data structure generated at the data structure-generation part.
- the document processing system can be configured to include a data structure-storing part for storing and retaining a data structure generated at the data structure-generation part.
- the evaluation execution part can evaluate an XPath expression with respect to a plurality of data files by repeatedly using a data structure stored in the data structure-storing part.
- the data structure-generation part includes a step decomposing means for decomposing individual XPath expressions into steps and a tree generation means for generating a data structure, in which a step common to a plurality of XPath expressions is associated with a node by associating a node with each step obtained from the decomposition.
- the data structure generation part If an XPath expression stored in the XPath storing part is changed, the data structure generation part generates a new node for a part which does not have a node corresponding to the data structure in newly added XPath expressions and adds the new node to an existing data structure. On the other hand, a data structure is updated by removing only a node corresponding to a part unique to the XPath expression from nodes corresponding to a part of deleted XPath expressions.
- the data structure generation part removes an XPath expression which overlaps other XPath expressions or an XPath expression whose evaluation result depends on other XPath expressions from objectives of evaluation.
- the evaluation execution part evaluates a part corresponding to each node in the data structure, obtains a general evaluation result for individual XPath expressions by combining the partial evaluation results, and shares an evaluation result for a part corresponding to a node common to a plurality of XPath expressions in evaluating a plurality of XPath expressions.
- the present invention to accomplish the above-mentioned object is also embodied as a program causing a computer to execute processing corresponding to each step of the above-mentioned XPath evaluation method, or controlling a computer to execute each function as the above-mentioned document processing system.
- the program can be provided by storing and distributing on a magnetic disk, an optical disk, a semiconductor memory or other storage medium, or by delivering over a network.
- FIG. 1 is a diagram schematically illustrating an exemplary configuration of hardware in a computer system which is preferable for implementing an XML document processing system according to the first embodiment
- FIG. 2 is a diagram illustrating a function of an XML document processing system according to the first embodiment
- FIG. 3 is a diagram illustrating a data structure generated at a data structure generation part of the first embodiment
- FIG. 4 is a diagram illustrating an exemplary XML document to be an objective of processing of the first embodiment
- FIG. 5 is a flow chart illustrating a processing procedure by an evaluation execution part in evaluating a plurality of XPath expressions in width priority
- FIG. 6 is a diagram illustrating a non-repeating directed graph representing XPath expressions P 7 , P 8 and P 9 to be evaluated in the first embodiment
- FIG. 7 is a flow chart illustrating a flow of evaluation processing using a hash table in the first embodiment
- FIG. 8 is a flow chart illustrating a method for generating a data structure with a data structure generation part of the first embodiment
- FIG. 9 is a diagram illustrating a data structure with an XPath expression P 4 being added to the data structure of FIG. 3;
- FIG. 10 is a flow chart illustrating processing of a data structure generation part at removal of a predetermined XPath expression from a data structure
- FIG. 11 is a diagram illustrating a data structure with an XPath expression P 3 being removed from a data structure shown in FIG. 9;
- FIG. 12 is a diagram illustrating a data structure representing XPath expressions P 11 , P 12 , P 13 , and P 14 ;
- FIG. 13 is a diagram showing an XML document to be an objective of processing
- FIG. 14 is a diagram illustrating an execution time taken for evaluating an XPath expression according to the embodiment
- FIG. 15 is a block diagram illustrating a function of a web page processing system according to the second embodiment
- FIG. 16 is a table listing XPath sets and XPath expressions included therein;
- FIG. 17 is a diagram listing XPath expressions shown in FIG. 16 with redundancy got rid of and identifying information (XPath ID) assigned;
- FIG. 18 is a diagram illustrating XPath expressions shown in FIG. 17 with extracted of XPath expressions common to a plurality of XPath sets in a graph structure;
- FIG. 19 is a diagram illustrating dependency among the XPath expressions after broken a connected XPath expression in a tree structure
- FIG. 20 is a diagram illustrating a connected XPath expression simplified on the basis of dependency among XPath expressions shown in FIG. 19;
- FIG. 21 is a diagram of XPath expressions omitted on the basis of dependency among XPath expressions shown in FIG. 20;
- FIG. 22 is a diagram illustrating the case that recombination is executed for what can be recombined with respect to an XPath expression in the dependency tree of XPath expressions shown in FIG. 21;
- FIG. 23 is a diagram illustrating each node (an XPath expression) in the dependency tree shown in FIG. 22 added with priorities (the number in a circle);
- FIG. 24 is a table listing XPath expressions on the basis of the priorities shown in FIG. 23;
- FIG. 25 is a table showing a list of XPath expressions obtained through the separation processing after simplification and omitting on the basis of dependency;
- FIG. 26 is a diagram illustrating a dependency tree including PX 1 , PX 2 , and PX 3 shown in FIG. 25;
- FIG. 27 is a diagram illustrating each node of the dependency tree shown in FIG. 26 (XPath expression) added with priorities according to the above rule;
- FIG. 28 is a table listing XPath expressions according to the priorities shown in FIG. 27.
- FIG. 29 is a diagram illustrating a structure of an XPath expression which can be optimized according to the second embodiment.
- the embodiments is intended for data files with a predetermined part can be specified by an XPath, such as an XML document or an HTML document, which is used for writing a web page. Accordingly, descriptions intended for XML documents can be applied to HTML documents and vise versa.
- FIG. 1 is a diagram illustrating an exemplary configuration of hardware in a computer system which is preferable for implementing an XML document processing system according to the first embodiment.
- a computer system shown in FIG. 1 includes a CPU (Central Processing Unit) 101 of a computing means, a main memory 103 connected to a CPU 101 via a M/B (mother board) chipset 102 and a CPU bus, a video card 104 connected to a CPU 101 also via a M/B chipset 102 and AGP (Accelerated Graphics Port), a display device 110 for displaying graphic data generated with a video card 104 , a harddisk 105 and a network interface 106 connected to a M/B chipset 102 via a PCI (Peripheral Component Interconnect) bus, and a floppy disk drive 108 and a keyboard/mouse 109 connected from the PCI bus to a M/B chipset 102 via a slower bus such as a bridge circuit 107 and an ISA (Industry Standard Architecture) bus.
- a display device 110 a liquid crystal display (LCD) or CRT display, for example, can be used.
- LCD liquid crystal display
- FIG. 1 is a merely example of a hardware configuration of a computer system for implementing the embodiment, and other different configurations can be adopted where the embodiment can be applied.
- a configuration for processing image data at a CPU 101 with mounting only a video memory is possible instead of providing a video card 104 , a sound feature can be provided to input and output with sound, or a drive for a CD-ROM (Compact Disk Read Only Memory) or a DVD-ROM (Digital Versatile Disk Read Only Memory) can be provided via an interface such as ATA (AT Attachment).
- a configuration for processing image data at a CPU 101 with mounting only a video memory is possible instead of providing a video card 104 , a sound feature can be provided to input and output with sound, or a drive for a CD-ROM (Compact Disk Read Only Memory) or a DVD-ROM (Digital Versatile Disk Read Only Memory) can be provided via an interface such as ATA (AT Attachment).
- ATA AT Attachment
- FIG. 2 is a block diagram illustrating a feature of an XML document processing system according to the first embodiment.
- the embodiment includes an XPath storing part 10 that stores a plurality of XPaths specifying a particular part of an XML document to be an objective of processing, a data structure generation part 20 for generating a data structure to evaluate efficiently according to the embodiment from an XPath expression stored in the XPath storing part 10 , a data structure storing part 30 for storing a data structure generated at the data structure generation part 20 , and an evaluation execution part 40 for evaluating an XPath expression for an XML document to be an objective of processing by using a data structure stored in the data structure storing part 30 , as well as an XML document storing part 50 for storing an XML document to be an objective of processing and an XML document processing unit 60 for executing predetermined information processing with respect to an XML document, which has been subjected to an evaluation by an evaluation execution part 40 .
- a data structure generation part 20 , an evaluation execution part 40 and an XML document processing unit 60 are virtual software blocks embodied at a CPU 101 controlled by a program shown in FIG. 1.
- a Program controlling a CPU 101 to implement each of these functions is provided and read in a main memory 103 by stored and distributed on a magnetic disk, an optical disk, a semiconductor memory or other storage media, or by delivered over a network.
- An XPath storing part 10 , a data structure storing part 30 and an XML document storing part 50 are embodied at a main memory 103 .
- Data and programs held at a main memory 103 can be saved on a storage device such as a harddisk 105 as required.
- an XPath storing part 10 stores a previously provided plurality of XPath expressions to be evaluated with respect to an XML document.
- a data structure-storing part 30 stores a data structure generated at a data structure generation part 20 to be used at an evaluation execution part 40 .
- An XML document storing part 50 stores an XML document input through a network interface 106 or an input device such as a keyboard/mouse 109 shown in FIG. 1 or a drive for reading out the concerned XML document from a storage medium that stores the XML document to be an objective of processing.
- a data structure generation part 20 generates a data structure to be used for an evaluation with an evaluation execution part 40 from an XPath expression stored in an XPath storing part 10 . If an XPath stored in an XPath storing part 10 is changed (added or deleted), a data structure is updated according to this change. With using such a data structure, an evaluation can be executed more efficiently than in the case that a plurality of XPath expressions stored in an XPath storing part 10 are evaluated independently with respect to an XML document. Detail for this data structure, evaluation methods using this data structure and generation methods of this data structure will be described below.
- An evaluation execution part 40 executes an evaluation (matching) of an XPath expression by using a data structure generated at a data structure generation part 20 with respect to an XML document stored at an XML document storing part 50 . Thereby, it is efficiently evaluated whether the concerned input document has a certain part specified with an XPath expression stored in an XPath storing part 10 or not.
- An evaluation result with an evaluation execution part 40 is stored in a predetermined area of a main memory 103 .
- An XML document processing unit 60 reads out an evaluation result with an evaluation execution part 40 from a predetermined area of a main memory 103 , and if an XML document stored in an XML document storing part 50 is determined to have a certain part specified with an XPath expression stored at an XPath storing part 10 on the basis of the evaluation result, the XML document processing unit 60 reads out the XML document as an objective of processing from an XML document storing part 50 and executes predetermined information processing, i.e., information processing previously provided as an application.
- evaluation processing is speeded up by generating a data structure for sharing a common part of a plurality of XPath expressions and evaluating with respect to an XML document by using the data structure.
- Approach 1 sharing an evaluation of a step among a plurality of location paths
- Approach 2 sharing an evaluation of a subexpression or an argument among a plurality of operation expressions or functions
- Approach 3 speeding up a predicate of a location path.
- the data structure generation part 20 decomposes the above-mentioned XPath expressions into steps to generate this data structure.
- a step consists of an axis, a set of node test and a predicate, they are also decomposed.
- an XPath expression P 1 is decomposed to the following P 1 ′, P 2 to P 2 ′, and P 3 to P 3 ′, respectively.
- a data structure generation part 20 functions as a step decomposing means for decomposing an XPath into steps and a tree generation means for generating a tree structure (data structure) with a node corresponding to each step in this processing.
- FIG. 3 is a diagram showing a data structure (tree structure) generated at a data structure generation part 20 .
- an evaluation execution part 40 evaluates XPath expressions P 1 , P 2 and P 3 with respect to an XML document by using a tree data structure generated in the above-mentioned manner.
- a leading step of an XPath expression P 1 ‘profile’ is initially evaluated with respect to an XML document D 1 shown in FIG. 4.
- the evaluation result is a node set with following four elements.
- N 1
- an XPath expression P 2 is evaluated.
- an evaluation result for a leading step ‘profile’ for an XPath expression P 2 has been obtained as a node set N 1 . Therefore, processing for this evaluation is not actually performed and the evaluation result that has already been obtained is used.
- ‘interests’ is applied to each element of a node set N 1 , respective results are as follows:
- an XPath expression P 3 is evaluated.
- an evaluation value for the part of ‘/profile/demographics/age’ in an XPath P 3 location path with respect to an XML document D 1 has been obtained as a node set N 3 . Therefore, processing for an evaluation of this part is not actually performed and the evaluation result that has been obtained is used.
- an amount of calculation time for a plurality of XPath expressions can be shortened by using a data structure shown in FIG. 3, performing an actual calculation for only once for a step common to a plurality of XPath expressions, and sharing the evaluation result.
- a storage area of a memory required in an evaluation can be reduced by evaluating either in the order of depth priorities or width priorities induced from a data structure in FIG. 3. For example, if an evaluation is done in depth priorities, a storage area required for holding a predetermined node can be freed when evaluations for all partial trees with respect to the concerned node has finished. In contrast, if an evaluation is done in width priorities, a storage area required for holding an evaluation result for upper nodes can be freed after the concerned evaluation result has been used for lower nodes.
- FIG. 5 is a flow chart illustrating a processing procedure with an evaluation execution part 40 in evaluating a plurality of XPath expressions in width priorities.
- an evaluation execution part 40 initially assigns a set including the entire XML document as a single element to the current node set (step 501 ). Then, leading steps of all location paths are included as elements of a set of steps (step 502 ). Then, the next processing is executed for all elements of the set of steps. In other words, steps are respectively evaluated for each element of the current node set (step 504 ). Next, all of the evaluation results are combined to be assigned to the current node set (step 505 ).
- a evaluation execution part 40 functions as a partial evaluation means for evaluating for each step corresponding to a node of a data structure and as an evaluation results combination means for obtaining an evaluation result for the entire XPath expression by combining evaluation results for respective steps in evaluating each XPath expression.
- a basic property of an XPath for this approach is that the same result as one obtained from an evaluation of the entire path can be obtained by evaluating representations of a location path to the halfway to obtain a node set; then evaluating the remaining representations of the path by using each element of the obtained node set as a context node; and finally combining the results.
- a common part is extracted from a location path of each XPath expression, the common part and the other parts are evaluated separately, and the evaluation results are combined. If an evaluation result for the part that can share the evaluation result (a common part of a location path) has been in this process, that existing evaluation result is used by omitting evaluation results for the part. Therefore, when a path can be decomposed to meet this property, this approach is applicable.
- a location path expression is a main expression in an XPath
- operation expressions such as an arithmetical operation, a comparison operation, a logical operation and functions are used for describing a condition of a path predicate or for generating data to be used by other programs. Therefore, an approach below for speeding up expressions other than a location path is used.
- a data structure generation part 20 initially decomposes the XPath expressions P 7 , P 8 and P 9 into subexpressions consisting of location paths.
- an XPath expression P 7 is decomposed into P 71 -P 74 , P 8 into P 81 -P 84 , P 9 into P 91 and P 92 , respectively.
- P 71 and P 91 , P 72 and P 82 , P 73 and P 83 , P 84 and P 92 are the same expressions. Therefore, XPath expressions P 7 , P 8 , P 9 can be represented in a non-repeating directed graph (DAG).
- DAG non-repeating directed graph
- FIG. 6 is a diagram illustrating a non-repeating directed graph representing XPath expressions P 7 , P 8 and P 9 .
- An evaluation execution part 40 evaluates XPath expressions P 7 , P 8 and P 9 by using a data structure obtained in the above manner. At first, a location path part is evaluated by using Approach 1. Next, each XPath expression is evaluated with a non-repeating directed graph shown in FIG. 6. At this point, a subexpression common to XPath expressions is evaluated for once for all and its evaluation result is reused for the common part, for the XPath expressions with a common subexpression.
- a hash table for searching for a remaining location path is created by using an evaluation result of a predicate expression in a step as a key.
- a data structure generation part 20 generates the following hash tables for the above-XPath expressions P 41 , P 42 , P 43 and P 44 .
- a searched set is ⁇ srartDate/year, hobbyName ⁇ when a key is ‘SPORT’
- a searched set is ⁇ composer ⁇ when a key is ‘MUSIC’
- a searched set is ⁇ software ⁇ when a key is ‘COMPUTER’
- a step evaluation can be shared according to Approach 1; so that a data structure for this part is generated (This part has no branch in a tree structure because all of the XPath expressions P 41 , P 42 , P 43 and P 44 are same.).
- the generated hash table is stored in a data structure storing part 30 along with a data structure in a tree structure generated at Approach 1.
- An evaluation execution part 40 initially evaluates a step /CPEXMLv 1 /person/partyActivities/hobby according to the above-mentioned Approach 1 to obtain a node set. Then the evaluation execution part 40 executes processing with the above-mentioned hash table for each node of a node set.
- FIG. 7 is a flow chart illustrating a flow of evaluation processing using a hash table.
- a left side expression of a predicate (‘typeName’ in this case) is evaluated first (step 701 ).
- a hash table is searched for by using a left side expression value as a key, and if the searched result is obtained, evaluate the obtained location path with respect to the concerned node and return the evaluation result (steps 703 , 704 ). In contrast, if the searched result is not obtained, return an empty node set (steps 703 , 705 ).
- a predicate does not need to be evaluated as many times as the number of XPaths with respect to a single node, so that same result as the result obtained from evaluations for all predicates with respect to a single node can be obtained from a single table search. For example, if typeName is ‘MUSIC’, a single table search determines that a predicate of an XPath expression P 42 is true and predicates of P 41 , P 42 and P 43 are false.
- a hash table is configured so that a set of remaining location paths to be searched with a key of Kj will be U i ⁇ j Pi.
- a hash table returning the following search results is configured.
- a data structure generation part 20 creates a binary search tree for searching by using a constant in a predicate of a step as a key. For example, when two XPath expressions P 5 and P 6 exist,
- a generated binary tree is stored in a data structure storing part 30 along with a data structure in a tree structure generated at Approach 1.
- An evaluation execution part 40 evaluates steps up to /CPEXMLv 1 /person/personDemorgraphics/birthDate according t o the above-mentioned Approach 1. Then, a left-side expression of a predicate (‘year’ in this case) is evaluated and the evaluated value is used as a key to search a binary search tree. As a result of this search, if the key is a value larger than 1990, both ‘gender’ and ‘birthplace’ are returned. If the key is a value same or less than 1990 and larger than 1976, ‘birthplace’ is returned. If no condition is met, an empty set is returned.
- a method for a data structure generation part 20 to generate a data structure (see FIG. 3) to be used in an evaluation execution part 40 from an XPath expression stored in an XPath storing part 10 will now be described.
- the embodiment presents a generation method that can efficiently reflect a change into a data structure, when an XPath stored in an XPath storing part 10 is changed (added or deleted). This method will be described below.
- FIG. 8 is a flow chart illustrating a method for generating a data structure with a data structure generation part 20 .
- a desired data structure is obtained by adding an XPath expression in succession. Therefore, for the first time to generate a data structure, a predetermined XPath expression is selected from a set of XPaths stored in an XPath storing part 10 , to which another XPath expression is added subsequently. In the case that a new XPath expression is added due to a change occurred to a set of XPaths, a step of a newly added XPath expression is added to an already generated data structure stored in a data structure storing part 30 .
- steps corresponding to si, . . . , sk are added to a data structure (step 808 ) and the XPath expression P is registered to a corresponding step of the data structure, then processing ends (step 809 ).
- step 806 if a new value of ‘i’ reaches the number of step ‘k’ in an XPath expression P, the XPath expression P is also registered to the corresponding step of the corresponding data structure, then processing ends (step 809 ).
- An XPath expression P 4 is initially decomposed into steps as follows at step 801 .
- a location path is represented in abbreviation, the path should be converted into a form that is not represented in abbreviation before decomposition. For example, a separator ‘//’ between steps should be previously converted into ‘decendant-or-self::node( )’ and ‘.’ into ‘self::node( )’.
- the process proceeds to step 807 , where ‘ ⁇ demographics, interests ⁇ ’, which is the next level step of ‘profile’, is substituted for S in a data structure because step s 1 is included in a set of steps S and remaining steps also exists (steps 803 - 806 ).
- step 808 steps corresponding to s 2 , s 3 and s 4 are added to a data structure.
- an XPath expression P 4 is registered into a data structure at step 809 .
- FIG. 9 is a diagram illustrating a data structure with an XPath expression P 4 being added to the data structure of FIG. 3.
- a data structure for speeding up step evaluation with the above-mentioned Approach 1 has been generated (updated).
- a generation (update) of a data structure to speed up an evaluation of an operation expression with Approach 2 will now be described.
- a location path is extracted from a newly added operation expression, and only the location path that has not been registered in an existing data structure is added to a data structure.
- a location path is added according to the procedure shown in a flow chart in FIG. 8.
- Subexpressions other than a location path are searched to find out whether they have been appeared as a common subexpression. If they have been appeared as a common subexpression, a data structure for evaluating the common subexpression will be reused. If they have not been appeared as a common subexpression, a data structure for evaluating the subexpression will be newly created and added to an existing data structure.
- FIG. 10 is a flow chart illustrating processing of a data structure generation part 20 at removal of a predetermined XPath expression from a data structure.
- step 1003 the number of XPath expressions registered at a step ‘s’ is checked whether it is 0 or not. If it is not 0, the process ends (step 1003 ).
- the number of XPath expressions registered at a step ‘s’ becomes 0.
- the process proceeds to step 1004 .
- a step ‘s’ is removed from an upper step ‘demographics’ of the step ‘s’ at step 1005 . In this case, as it is determined that the number of lower steps of ‘demographics’ is not 0 at step 1006 , the process ends here.
- FIG. 11 is a diagram for illustrating a data structure with an XPath expression P 3 being removed from a data structure shown in FIG. 9.
- a location path is extracted from an operation expression to be removed; a location path that is solely used by the operation expression is searched for; and the location path is removed from a data structure.
- a check of whether a predetermined location path is solely used by an operation expression to be removed or not can be executed in an approach such as controlling the number of reference for a location path.
- a data structure generation part 20 generates a data structure with respect to the above four XPath expressions P 11 , P 12 , P 13 and P 14 in the procedure shown in FIG. 8.
- XPath expressions P 11 , P 12 , P 13 and P 14 will be described below as they are added to an empty tree structure (initial condition) in succession.
- step ‘profile’ is not registered at a data structure, the step is added and registered (steps 804 , 808 , 809 ).
- step ‘interests’ is not registered at a data structure, the step is added and registered (steps 804 , 808 , 809 ).
- step ‘profile’ and ‘interests’ have been registered at a data structure and a data structure for ‘sport/@type’ has also added to a corresponding hash table, addition to a data structure is not executed, executing only the registration of an XPath expression P 12 (step 809 ).
- FIG. 12 is a diagram showing a generated data structure.
- a generated data structure is stored and saved in a data structure-storing part 30 .
- An evaluation execution part 40 reads out this XML document from an XML document storing part 50 , and evaluates XPath expressions P 11 , P 12 , P 13 and P 14 by using a data structure stored in a data structure storing part 30 .
- a hash table is searched by using ‘Baseball’ as a key, and a step ‘book’ and a function ‘count’ are obtained. ‘book’ is evaluated with respect to two elements of node set N 2 , then ⁇ ⁇ and ⁇ History ⁇ are obtained. These two are combined, and
- a step ‘demographics’ is applied to each element of a node set N 1 and the results are combined to be ‘ ⁇ age>19 ⁇ /age> ⁇ ’.
- a step ‘age’ is further applied to this element, and
- the entire execution time is shortened by fragmenting an XPath expression into steps as stated above, and then by changing execution sequence or by reducing the number of execution with respect to execution of XPath fragments obtained from the fragmentation.
- a fragment of an XPath expression is also an XPath expression; a package ‘org.apache.xpath’ of an XPath processor included in an XSLT processor Xalan-Java® 2 provided in Apache XML Project (hereinafter merely referred to as Xalan) is used to execute this fragment.
- a function of Xalan is used as it is for executing a step of a location path or for evaluating an arithmetic expression. Therefore, how much the present invention streamlines an evaluation of an XPath is directly known from the difference between an execution only with Xalan and an execution with Xalan in an XML document processing system according to the present invention.
- XPath expressions are provided for an XML document defined by CPExchange (IDEAlliance, CPExchange Specification Version 1.0, 2000. (http://www.cpexchange.org/)).
- An appropriate XPath expression for a given XML document is selected from the XPath expressions.
- XPath expressions are generated in the following pattern with different XYZ, and registered to a system.
- FIG. 14 is a diagram illustrating an execution time taken for evaluating an XPath expression according to the embodiment.
- two kinds of execution time measured respectively in (1) a system for evaluating an XPath expression solely with an Xalan, and (2) a system for evaluating with the combination of approaches according to the present invention and an Xalan are shown.
- an execution time lineally increases with regard to the increase in the number of XPath expressions.
- an execution time shows little increase with regard to the increase in the number of XPath expressions. Accordingly, the difference between two cases becomes larger as the number of XPath expressions increases.
- processing of evaluation is speeded up by evaluating an XML document with a data structure, which shares a common part of a plurality of XPath expressions to be evaluated, and sharing the result.
- processing of evaluation is speeded up by analyzing dependency among a plurality of XPath expressions to be evaluated, evaluating with a data structure with a redundant part of a plurality of XPath expressions omitted on the basis of the obtained dependency to simplify the processing of evaluation.
- the embodiment will be described by exemplifying the case in which whether an XPath expression within an annotation correctly specifies a predetermined element of an objective web page or not is evaluated in order to add an annotation to a web page.
- a web page processing system is embodied in a computer system with a hardware configuration shown in FIG. 1, for example, as in the case of the first embodiment.
- FIG. 15 is a block diagram illustrating a function of a web page processing system according to the second embodiment.
- the embodiment includes an XPath storing part 1510 that stores a plurality of XPath expressions specifying a certain part of a web page to be an objective of processing (HTML document), a data structure generation part 1520 that generates a data structure for performing an efficient evaluation according to the embodiment from the XPath expressions stored in an XPath storing part 1510 , a data structure storing part 1530 that stores a data structure generated at a data structure generation part 1520 and an evaluation execution part 1540 that evaluates an XPath expression with respect to a web page to be an objective of processing by using a data structure stored in a data structure storing part 1530 , as well as a document storing part 1550 that stores a web page to be an objective of processing and a document processing unit 1560 that performs a predetermined information processing with respect to a web page, which has been subjected to an evaluation with an evaluation execution part 1540 .
- HTML document HTML document
- a data structure generation part 1520
- a data structure generation part 1520 , an evaluation execution part 1540 and a document processing unit 1560 are virtual software blocks embodied in a CPU 101 controlled by a program shown in FIG. 1.
- a Program controlling a CPU 101 to implement each of these functions is provided and read in a main memory 103 by stored and distributed on a magnetic disk or an optical disk, a semiconductor memory or other storage media, or by delivered over a network.
- An XPath storing part 1510 , a data structure storing part 1530 and a document storing part 1550 are implemented at a main memory 103 . Data and program held in a main memory 103 can be saved on a storage device such as a harddisk 105 as required.
- an XPath storing part 1510 stores a plurality of previously prepared XPath expressions to be evaluated with respect to a web page.
- a data structure storing part 1530 stores a data structure that is generated at a data structure generation part 1520 to be used in an evaluation execution part 1540 .
- a document storing part 1550 stores a web page that input through a network interface 106 or an input device such as a keyboard/mouse 109 shown in FIG. 1 or a drive for reading out the concerned web page from a storage medium that stores the web page to be an objective of processing.
- a data structure generation part 1520 generates a data structure to be used for an evaluation by an evaluation execution part 1540 from XPath expressions stored in an XPath storing part 1510 .
- an evaluation can be executed more efficiently than in the case that a plurality of XPath expressions stored in an XPath storing part 1510 are separately evaluated with respect to a web page. Detail of this data structure and a method for evaluating by means of this data structure and a method for generating this data structure will be described below.
- An evaluation execution part 1540 is an XPath engine and executes an evaluation (matching) of an XPath expression by using a data structure generated at a data structure generation part 1520 with respect to a web page stored in a document storing part 1550 . Thereby, it is efficiently evaluated whether the concerned input document has a certain part specified by an XPath expression stored in an XPath storing part 1510 or not. Evaluation results from an evaluation execution part 1540 are stored in a predetermined area in a main memory 103 .
- a document-processing unit 1560 reads out an evaluation result of an evaluation execution part 1540 from a predetermined area of a main memory 103 . If a web page stored at a document storing part 1550 has a certain part specified by an XPath expression stored in an XPath storing part 1510 on the basis of the evaluation result, the document processing unit 1560 reads out the web page as an objective of processing from the document storing part 1550 and executes an intended predetermined information processing, i.e., processing of adding an annotation to a web page.
- the embodiment particularly intends to the streamlining of an evaluation processing in the case of determining an XPath set that matches a web page among a plurality of XPath sets, as in the case of searching an annotation applicable for a predetermined web page among a plurality of annotations.
- the embodiment speeds up processing of evaluation in the above-mentioned case by generating a data structure for simplifying an evaluation of an XPath expression on the basis of dependency among a plurality of XPath expressions and by evaluating a web page by means of this data structure.
- different algorithms are applied on the basis of a type of an evaluation execution part 1540 (TYPE 1 and TYPE 2 shown below).
- TYPE 1 Call overhead for an XPath evaluation function is large. Smaller number of evaluations of an XPath expression can improves an entire performance of a system (processing efficiency).
- TYPE 2 Call overhead for an XPath evaluation function is small. An entire performance of a system (processing efficiency) does not significantly deteriorate even through an evaluation of an XPath expression after it has been separated.
- a data structure generation part 1520 does not separate an XPath expression within a data structure to be generated. Specifically, processing such as:
- An XPath expression included commonly in a plurality of XPath sets is not involved in determination of an XPath set which matches a web page. The reason for this is that an evaluation result for such an XPath expression is common to (is not differentiated for) each XPath set. Therefore, an evaluation of an XPath that is not included in a plurality of XPath sets (specific XPath) is executed before others.
- FIG. 16 is a table listing XPath sets and XPath expressions included therein.
- a plurality of XPath expressions are included in each of four kinds of XPath sets (A, B, C, D).
- XPath expressions shown in FIG. 16 include much redundancy.
- an XPath expression at No. 5 is identical to an XPath expression at No. 14 (XPath set B).
- FIG. 17 is a diagram listing XPath expressions shown in FIG. 16 with redundancy got rid of and identifying information (XPath ID) assigned. In an example shown in FIG. 17, 31 XPath expressions shown in FIG. 16 are reduced to 18.
- FIG. 18 is a diagram illustrating reduced XPath expressions shown in FIG. 17 with further analyzed and extracted of XPath expressions common to a plurality of XPath sets in a graph structure.
- an XPath expression X 7 is commonly included in XPath sets C and D and an XPath expression X 1 , X 2 , X 3 and X 18 are commonly included in all XPath sets.
- each XPath expression unique to each XPath set is described with a node, which represents XPath expressions commonly included in the plurality of XPath sets, branched into respective XPath sets. Therefore, in the example of FIG. 18, objectives of evaluation will be narrowed down to 13 types of XPath expressions (X 4 -X 6 , X 8 -X 17 ) added to a node, which represents each XPath set.
- a connected XPath expression is an expression which connects a plurality of XPath expressions with an OR sign (
- a connected XPath expression specifying one of two table contents (table [ 1 ], table[ 2 ]) placed at a predetermined location (body [ 1 ]) in a predetermined web page (html [ 1 ])
- an XPath 2 is defined to depend on an XPath 1 .
- a connected XPath is simplified by taking advantage of this feature.
- an XPath 1 and an XPath 2 are in sibling relation, so,
- an XPath 1 is a descendant of an XPath 2 , so,
- this expression can be broken into following two XPath expressions:
- FIG. 19 is a diagram illustrating dependency among the obtained broken XPath expressions in a tree structure.
- XPath expressions X 6 - 5 and X 7 are identical.
- a plurality of XPath expressions originally included in a single connected XPath expression (X 1 ) like X 11 - 3 , X 11 - 2 , and X 11 - 1 may have dependency each other.
- lower XPath expressions, X 11 - 2 and X 11 - 3 do not need to be evaluated from the reasons described below.
- a connected XPath expression is simplified by deleting an XPath expression dependent to other XPath expressions as described above.
- FIG. 20 is a diagram illustrating a connected XPath expression simplified on the basis of dependency among XPath expressions shown in FIG. 19.
- a condition for a predetermined XPath set to hold is “holding of all XPath expressions included in” the XPath set. If either of the above-mentioned an XPath 1 and an XPath 2 does not hold, the entire XPath set will not hold. In other words, the following relation will be established.
- FIG. 21 is a diagram of XPath expressions omitted on the basis of dependency among XPath expressions shown in FIG. 20.
- FIG. 21 (A) is a diagram with XPath expressions to be omitted (X 2 , X 7 , X 9 ) being marked up
- FIG. 21 (B) is a diagram with XPath expressions marked up in FIG. 21(A) being deleted from the dependency tree.
- Codes attached to XPath expressions in the diagram such as ‘A’, ‘B’, ‘ABCD’, indicate the XPath sets which include those XPath expressions.
- FIG. 21 (A) is a diagram with XPath expressions to be omitted (X 2 , X 7 , X 9 ) being marked up
- FIG. 21 (B) is a diagram with XPath expressions marked up in FIG. 21(A) being deleted from the dependency tree.
- a data structure generation part 1520 recombines a connected XPath expression broken at the analysis of dependency among XPath expressions at processing of ‘2’, in order to reduce the number of XPath expressions to be evaluated.
- FIG. 22 is a diagram illustrating the case that recombination is executed for what can be recombined with respect to an XPath expression in the dependency tree of XPath expressions shown in FIG. 21.
- X 5 - 2 is a child node of X 18 .
- X 5 -* is recombined to be a node in the same level as X 1 , X 3 , X 4 and X 18 as a rout node.
- XPath expressions that intended to ‘an element which does not likely to exist’ are preferably processed before. Then, the order of XPath expressions to be evaluated (priorities) is decided with the following criteria.
- an evaluation of /table[ 1 ] is executed after an evaluation of /table[ 1 ]/tr[ 1 ]/td[ 1 ] that includes more part toward the end (rule ( 1 )).
- an evaluation of /table[ 2 ] is executed before, because /table[ 2 ] appears ‘after’ /table[ 1 ] when the DOM tree is visited around, i.e., /table[ 2 ] specifies an element, which appears after one specified with /table[ 1 ] in the order of tags for HTML (rule ( 2 )). This is because a probability of appearance for an XPath expression (/table[ 2 ]) placed after in the DOM tree is lower than that for an XPath expression (/table [ 1 ]) placed before in the DOM tree.
- FIG. 23 is a diagram illustrating each node (an XPath expression) in the dependency tree shown in FIG. 22 added with priorities (the number in a circle) according to the above-mentioned rules.
- FIG. 24 is a table listing XPath expressions on the basis of the priorities shown in FIG. 23.
- other XPath expressions, on which each XPath expression depends dependent XPath
- dependency levels tree lengths for each XPath expression are also described.
- ‘Dependency level’ used here refers to a depth of a tree when a rule node is 0.
- ‘Tree length’ refers to a length of a tree for the XPath expression itself.
- a tree length for a connected XPath expression represents the length of an XPath expression whose tree length is the longest of all the XPath expressions constituting the XPath expression.
- XPath expressions X 10 and X 11 are both at dependency level three, the deepest dependency level. In other words, if the expressions hold, they influence more XPath expressions than the other expressions do. Between X 10 and X 11 , X 10 has a longer tree length. For this reason, priority of X 10 is 1 and priority of X 11 is 2. Between XPath expressions X 12 and X 13 , which are equal both in dependency level and tree length, X 13 is higher in priority because X 13 , which specifies /td[ 2 ]/table[ 1 ], is placed after than X 12 on a DOM tree for a web page to be evaluated.
- An XPath set which has been organized on the basis of dependency among XPath expressions in the above-mentioned manner, is converted into a data structure that can be referenced in matching processing with a web page (for example, a non-repeating directed graph structure) and save it in a predetermined storage device (for example, a main memory 103 shown in FIG. 1).
- a web page for example, a non-repeating directed graph structure
- an evaluation execution part 1540 evaluates with respect to a web page stored in a document storing part 1550 using the data structure.
- the evaluation execution part 1540 is in a type of improving the entire performance of a system for smaller number of evaluation of XPath expressions (TYPE 1) according to the above description, an evaluation is executed from the XPath expression at top priority in descending order according to the following procedure.
- evaluation processing for an XPath set according to the embodiment is used as processing to decide an annotation to be added to a web page from a plurality of annotations, an annotation with an XPath set, all of whose XPath expressions are determined to match according to the above procedure, will be decided as an annotation that can be added to the web page.
- a data structure generation part 1520 separates an XPath expression in a data structure to be generated and simplifies each XPath expression. Specifically, processing such as:
- a data structure generation part 1520 speeds up processing by fragmenting a plurality of XPath expressions into a common part and a unique part, and evaluating each of them.
- FIG. 25 is a table showing a list of XPath expressions obtained through the separation processing after simplification and omitting on the basis of dependency.
- XPath expressions PX 1 , PX 2 , and PX 3 in the list are XPath subexpressions added according to the separation processing. It is evident that separation processing of these three XPath expressions has made each XPath expression significantly simple compared to XPath expressions listed in FIG. 17.
- FIG. 26 shows a dependency tree including PX 1 , PX 2 , and PX 3 .
- XPath expressions that intended to ‘an element which does not likely to exist’ are preferably processed before. Then, the order of XPath expressions to be evaluated (priority) is decided with the following criteria.
- Processing to decide priority is same as in the above-mentioned case, in which a type of an evaluation execution part 1540 is TYPE 1, though priority including XPath expressions PX 1 , PX 2 , and PX 3 newly added at processing at ‘3.’ are decided.
- FIG. 27 is a diagram illustrating each node of the dependency tree shown in FIG. 26 (XPath expression) added with priorities according to the above rule.
- FIG. 28 is a table listing XPath expressions according to the priorities shown in FIG. 27. As a common part of a plurality of XPath expressions is separated and becomes individual XPath expressions by means of the above-mentioned processing of ‘4.’, a tree length of an XPath expression itself is not involved in the decision on priorities.
- XPath sets which have been organized on the basis of dependency among XPath expressions in the above-mentioned manner, are converted into a data structure that can be referenced in matching processing with a web page (for example, a non-repeating directed graph structure) and saved in a predetermined storage device (for example, a main memory 103 shown in FIG. 1).
- This processing is same as that in the case, in which a type of an evaluation execution part 1540 is TYPE 1.
- an evaluation execution part 1540 evaluates with respect to a web page stored in a document storing part 1550 using the data structure.
- the evaluation execution part 1540 is in a type, in which an entire performance of a system does not significantly deteriorate even when a frequency of evaluation for XPath expression is high (TYPE 2). Therefore, an evaluation is executed in the following manner from the XPath expression at top priority in descending order.
- evaluation processing for an XPath set according to the embodiment is used for processing to decide an annotation to be added to a web page from a plurality of annotations, an annotation with an XPath set, all of whose XPath expressions are determined to match according to the above procedure, is decided as an annotation that can be added to the web page.
- the above-mentioned embodiment is not generate a data structure to efficiently evaluate (optimize) with respect to all functions of XPath expressions, only optimizing a part of the functions that are in frequent use.
- FIG. 29 is a diagram illustrating a structure of an XPath expression which can be optimized according to the embodiment.
- Axis is for child only, and other axes should not be used.
- designation of abbreviation for ‘descendant-or-self::node( )’, ‘//’ should not be used.
- the embodiment take advantage of a property that a structure shown above (structure which can be separated into part 1 and part 2 ) belongs to many XPath expressions that specify a node of a tree in a long and irregular form like HTML documents describing a web page.
- applicability A can be calculated in the following manner.
- P the number of steps taken to reach an existing node, when the parent sequence of the XPath expression in concern is followed. At least a ‘body’ node is common even if the worst case, this parameter is guaranteed to have a value.
- S the distance of sibling sequence of the XPath expressions in concern. The distance is defined to 1 when (parent node)/tr[ 4 ] does not exist and (parent node)/tr[ 3 ] exists, while the distance is defined to 2 when (parent node)/tr[ 2 ] exists.
- a sibling node does not exist, calculate a sibling node within a child node in node toward an existing parent node to be an objective of P.
- a node to be an objective is originally a first node (/tag[ 1 ])
- a default value is assigned to the value.
- L a length of a tree, to which the XPath expression in concern specifies.
- Applicability for each XPath expression is calculated with such calculations as stated above, and the total of finally obtained applicability for each XPath expression is made to be an applicability of an XPath set.
- AXPath set ⁇ AXPath
- a processing speed with respect to an XML document is improved by efficiently searching an evaluation result of a number of XPath expressions.
- a processing speed can be improved by incorporating the embodiments into an XSLT processor.
- An XML document processing system improves efficiency by taking advantage of a fact that, where a plurality of XPath expressions exist, they include redundant part such as something similar or overlapping, or what does not need an evaluation depending on the evaluation results of other XPath expressions due to the dependency. Therefore, if no such redundancy exists, efficiency will not improve.
- a calculation of a location path is executed in the same way as conventional procedures by using an Xalan and the like as it is, because the calculation is executed by recursively searching for node set one after another.
- One comparison operator is executed in a table search with entry number one. The both ways can be executed in a negligible time, which is quicker than the case of reconfiguring a node set.
- a predicate is not a predetermined pattern, it is not an objective of optimization.
- a test for such a case may be done by calculating in the same way as conventional procedures by using an Xalan and the like as it is.
- the present invention has an effect of improving execution efficiency in evaluating a plurality of XPath expressions with respect to an XML document. This effect will be remarkable as redundant part increases among the plurality of XPath expressions.
Abstract
Description
- 1. Field of the Invention
- The present invention relates to a technique for efficiently evaluating XPath expressions to specify a certain part of XLM or HTML documents using XPaths (XML Path Language).
- 2. Related Art
- W3C (World Wide Web Consortium) released ‘XPath’ as a recommendation for a path language to specify a certain part of an XML document. XPaths are used as a component of XPointer, XSLT, XQuery, etc., and also used to access a DOM (Document Object Model) tree for an XML document in a predetermined application program.
- Evaluating a plurality of XPaths with respect to a single XML document is commonplace in actual information processing with an XML document. In an XSLT style sheet, for example, an XPath expression is specified as a pattern for each template rule. Therefore, a complex XSLT style sheet includes a number of XPath expressions, which need to be evaluated with respect to an XML document to be an objective of processing.
- In addition, it is broadly known that a predetermined web page can be reused in various ways and a new application can be developed by adding an annotation to a web page to be used for such purpose as exchanging data on Internet. An XPath is also used for associating an annotation with an element of a web page, because an HTML document used for writing a web page can specify a certain part by using an XPath expression in the same way as an XML document does. An efficient way to add an annotation to a web page is applying a particular annotation to a plurality of web pages for recycling. In this case, it requires to evaluate whether a plurality of XPath expressions in a predetermined annotation correctly specify a predetermined element in a targeted web page or not in order to determine whether the predetermined annotation is applicable to the predetermined web page or not.
- A feature of specifying a certain part of an XML document with an XPath is considered to be a condition for checking whether an XML document to be an objective for processing has a certain part specified by an XPath or not. For example, WebLogic Collaborate (http://www.bea.com/index.html), a server system from U.S. BEA uses XPaths to write a condition for routing and filtering of a message expressed in XML. For such a purpose, a plurality of XPath expressions should be evaluated for each time a XML document arrives.
- When a plurality of XPath expressions need to be evaluated for each XML document like in the above-mentioned case, an efficient way of evaluating XPath expressions is required. A conventional kind of such technique is performed by writing a condition of subscription for each user with respect to a document written in XML with XPaths, checking the XML document with respect to matching with XPath expressions for each time the document arrives, and then delivering a document that passed the check to a user with a condition of subscription for XPaths (for example, see non-patent-related document 1). This method for evaluating an XPath expression improves an execution time per XPath by evaluating for each step of a location path via searching a table.
- Altinel M., Franklin, M., “Efficient Filtering of XML Documents for Selective Dissemination of Information”, International Conference on Very Large Data Bases, 2000.
- As mentioned above, when a plurality of XPath expressions are evaluated for a single data file (document) in processing with respect to XML or HTML documents, an efficient way to evaluate XPath expressions is needed.
- However, although methods for improving an execution time of an evaluation per XPath as the method disclosed in the above-mentioned document have been known, an execution time required for the entire evaluation linearly increases in proportion to the growth of the number of XPath expressions, which limits shortening of the entire execution time.
- This is caused by the fact that conventional evaluation methods for an XPath handle respective XPath expressions independently of each other in evaluating a plurality of XPath expressions.
- For a plurality of XPath expressions assumed to be evaluated for a single data file, the expressions are limited with a variation of structures or element values of an objective data file and the like. As a result, the plurality of XPath expressions include similar expressions. Therefore, by retrieving and evaluating a common part from similar XPath expressions and sharing an evaluation result for the common part among the similar XPath expressions, an evaluation of XPaths can be performed quicker than in a way of evaluating a plurality of XPath expressions respectively.
- Where a plurality of XPath expressions to be evaluated depend on each other, processing required for an evaluation of XPath expressions can be simplified by taking advantage of the dependency. Dependency among XPath expressions in this context refers to; when a web page specified by a predetermined XPath expression includes two table contents (table [1], table [2]), for example, a relation where table [2] does not exist if table [1] does not exist, i.e., a relation where an evaluation of one or a part of a plurality of XPaths tells evaluation results for remaining XPaths.
- Therefore, the present invention is intended to provide a method for obtaining an evaluation result in an efficient manner for a plurality of XPath expressions by taking advantage of the above-mentioned similarity or dependency among XPath expressions in evaluating a plurality of XPath expressions with respect to a data file such as an XML or HTML document.
- The present invention to accomplish the above-mentioned object is implemented as a following XPath evaluation method for evaluating a plurality of XPaths with respect to a predetermined data file by a computer. In other words, this XPath evaluation method is characterized by including the steps of generating a data structure that has a common part of a plurality of XPath expressions to be evaluated as a common node in a tree structure, evaluating the generated data structure in node-by-node basis with respect to a data file to be an objective of processing, and obtaining an evaluation result for each XPath expression by combining the evaluation results for each of the nodes.
- The above-mentioned step of generating a data structure specifically includes the steps of decomposing individual XPath expressions into steps, and associating a node with each step obtained from the decomposition and generating a data structure, in which a step common to a plurality of XPath expressions is associated with a single node.
- More preferably, the step of generating a data structure can use a special data structure when a plurality of steps of XPath expressions are written in a common particular form, more specifically, when a predicate in the form of ‘[(expression)(comparison operator)(constant)]’ exists. For example, when a comparison operator is ‘=’ or ‘!=’, a hash table for searching for remaining steps in an XPath can be generated by using an evaluation result for a predicate expression in a step as a key to evaluate the remaining steps in the XPath obtained from a search by means of the generated hash table. Or, when a comparison operator is ‘>’, ‘>=’, ‘<’ or ‘<=’, a binary search tree for searching for remaining steps in an XPath can be generated by using an evaluation result for a predicate expression in a step as a key to evaluate the remaining steps in the XPath obtained from a search by means of the generated binary search tree.
- Moreover, the step of generating a data structure includes the steps of decomposing an operation expression or function into subexpressions when a plurality of XPath expressions include an operation expression or function, and generating a non-repeating directed graph by combining common subexpressions of the subexpressions obtained from decomposition. And the step of evaluating an XPath expression includes the step of evaluating each XPath expression by using the generated non-repeating directed graph and sharing an evaluation result among a plurality of XPath expressions for a subexpression common to a plurality of XPath expressions.
- Then, for individual subexpressions, a data structure that has a common part as a common node in a tree structure can be generated as mentioned above, and the data structure can be used to perform an evaluation.
- Another XPath evaluation method according to the present invention is characterized by including the steps of extracting a common part from a plurality of XPath expressions to be evaluated, and obtaining an evaluation result for each XPath expression, with respect to a data file to be an objective of processing, by evaluating the common part and the other parts in the XPath expression separately and combining the evaluation results, wherein the step of obtaining an evaluation of an XPath expression includes a step of using an evaluation result obtained at an evaluation of another XPath as an evaluation result for a common part of a predetermined XPath expression if such an evaluation result exists, with respect to the common part when evaluating the predetermined XPath expression.
- Yet another XPath evaluation method according to the present invention is characterized by including a step of reading out an XPath set including a plurality of XPath expressions to be evaluated from a memory and generating a data structure with a redundant element in the XPath expressions included in the XPath set omitted, and a step of inputting a data file to be an objective of processing, evaluating the XPath set by using the data structure with respect to the data file, and storing the obtained evaluation result into a memory, in an XPath evaluation method for evaluating a plurality of XPaths with respect to a predetermined data file by a computer.
- More specifically, in the step of generating a data structure, an XPath expression commonly included in a plurality of XPath sets and an XPath expression unique to a predetermined XPath set are separated, and XPath expressions to be evaluated at an evaluation of the XPath sets are narrowed down. Further, a connected XPath expression included in the XPath set is simplified by removing an XPath expression that can dispense with an evaluation from objectives of evaluation on the basis of dependency among respective XPaths constituting the connected XPath expression. Yet further, an XPath expression that can dispense with an evaluation is removed from objectives of evaluation on the basis of dependency among a plurality of XPath expressions. And further, a part common to a plurality of XPath expressions and a part unique to each XPath expression are separated to make each part an objective of evaluation as an individual XPath expression.
- Additionally, for an evaluation of an XPath set, an XPath expression unique to each XPath set is initially evaluated, and if each of the unique XPath expressions matches a data file to be an objective of processing, XPath expressions common to the remaining XPath sets within the XPath sets are evaluated.
- The present invention to accomplish the above-mentioned object is also implemented as a document processing system configured in the following way. The document processing system is characterized by including an XPath storing part which stores a plurality of XPath expressions, a data structure-generation part for generating a data structure with redundant elements of a plurality of XPath expressions stored in the XPath-storing part being omitted, and an evaluation execution part for evaluating the plurality of XPath expressions with respect to a data file to be evaluated by using the data structure generated at the data structure-generation part.
- Further, the document processing system can be configured to include a data structure-storing part for storing and retaining a data structure generated at the data structure-generation part. In this case, the evaluation execution part can evaluate an XPath expression with respect to a plurality of data files by repeatedly using a data structure stored in the data structure-storing part.
- Specifically, the data structure-generation part includes a step decomposing means for decomposing individual XPath expressions into steps and a tree generation means for generating a data structure, in which a step common to a plurality of XPath expressions is associated with a node by associating a node with each step obtained from the decomposition.
- If an XPath expression stored in the XPath storing part is changed, the data structure generation part generates a new node for a part which does not have a node corresponding to the data structure in newly added XPath expressions and adds the new node to an existing data structure. On the other hand, a data structure is updated by removing only a node corresponding to a part unique to the XPath expression from nodes corresponding to a part of deleted XPath expressions.
- Further, the data structure generation part removes an XPath expression which overlaps other XPath expressions or an XPath expression whose evaluation result depends on other XPath expressions from objectives of evaluation.
- Yet further, the evaluation execution part evaluates a part corresponding to each node in the data structure, obtains a general evaluation result for individual XPath expressions by combining the partial evaluation results, and shares an evaluation result for a part corresponding to a node common to a plurality of XPath expressions in evaluating a plurality of XPath expressions.
- The present invention to accomplish the above-mentioned object is also embodied as a program causing a computer to execute processing corresponding to each step of the above-mentioned XPath evaluation method, or controlling a computer to execute each function as the above-mentioned document processing system. The program can be provided by storing and distributing on a magnetic disk, an optical disk, a semiconductor memory or other storage medium, or by delivering over a network.
- FIG. 1 is a diagram schematically illustrating an exemplary configuration of hardware in a computer system which is preferable for implementing an XML document processing system according to the first embodiment;
- FIG. 2 is a diagram illustrating a function of an XML document processing system according to the first embodiment;
- FIG. 3 is a diagram illustrating a data structure generated at a data structure generation part of the first embodiment;
- FIG. 4 is a diagram illustrating an exemplary XML document to be an objective of processing of the first embodiment;
- FIG. 5 is a flow chart illustrating a processing procedure by an evaluation execution part in evaluating a plurality of XPath expressions in width priority;
- FIG. 6 is a diagram illustrating a non-repeating directed graph representing XPath expressions P7, P8 and P9 to be evaluated in the first embodiment;
- FIG. 7 is a flow chart illustrating a flow of evaluation processing using a hash table in the first embodiment;
- FIG. 8 is a flow chart illustrating a method for generating a data structure with a data structure generation part of the first embodiment;
- FIG. 9 is a diagram illustrating a data structure with an XPath expression P4 being added to the data structure of FIG. 3;
- FIG. 10 is a flow chart illustrating processing of a data structure generation part at removal of a predetermined XPath expression from a data structure;
- FIG. 11 is a diagram illustrating a data structure with an XPath expression P3 being removed from a data structure shown in FIG. 9;
- FIG. 12 is a diagram illustrating a data structure representing XPath expressions P11, P12, P13, and P14;
- FIG. 13 is a diagram showing an XML document to be an objective of processing;
- FIG. 14 is a diagram illustrating an execution time taken for evaluating an XPath expression according to the embodiment;
- FIG. 15 is a block diagram illustrating a function of a web page processing system according to the second embodiment;
- FIG. 16 is a table listing XPath sets and XPath expressions included therein;
- FIG. 17 is a diagram listing XPath expressions shown in FIG. 16 with redundancy got rid of and identifying information (XPath ID) assigned;
- FIG. 18 is a diagram illustrating XPath expressions shown in FIG. 17 with extracted of XPath expressions common to a plurality of XPath sets in a graph structure;
- FIG. 19 is a diagram illustrating dependency among the XPath expressions after broken a connected XPath expression in a tree structure;
- FIG. 20 is a diagram illustrating a connected XPath expression simplified on the basis of dependency among XPath expressions shown in FIG. 19;
- FIG. 21 is a diagram of XPath expressions omitted on the basis of dependency among XPath expressions shown in FIG. 20;
- FIG. 22 is a diagram illustrating the case that recombination is executed for what can be recombined with respect to an XPath expression in the dependency tree of XPath expressions shown in FIG. 21;
- FIG. 23 is a diagram illustrating each node (an XPath expression) in the dependency tree shown in FIG. 22 added with priorities (the number in a circle);
- FIG. 24 is a table listing XPath expressions on the basis of the priorities shown in FIG. 23;
- FIG. 25 is a table showing a list of XPath expressions obtained through the separation processing after simplification and omitting on the basis of dependency;
- FIG. 26 is a diagram illustrating a dependency tree including PX1, PX2, and PX3 shown in FIG. 25;
- FIG. 27 is a diagram illustrating each node of the dependency tree shown in FIG. 26 (XPath expression) added with priorities according to the above rule;
- FIG. 28 is a table listing XPath expressions according to the priorities shown in FIG. 27; and
- FIG. 29 is a diagram illustrating a structure of an XPath expression which can be optimized according to the second embodiment.
- The present invention will now be specifically described on the basis of embodiments shown in accompanying drawings.
- The embodiments is intended for data files with a predetermined part can be specified by an XPath, such as an XML document or an HTML document, which is used for writing a web page. Accordingly, descriptions intended for XML documents can be applied to HTML documents and vise versa.
- First Embodiment
- FIG. 1 is a diagram illustrating an exemplary configuration of hardware in a computer system which is preferable for implementing an XML document processing system according to the first embodiment.
- A computer system shown in FIG. 1 includes a CPU (Central Processing Unit)101 of a computing means, a
main memory 103 connected to aCPU 101 via a M/B (mother board)chipset 102 and a CPU bus, avideo card 104 connected to aCPU 101 also via a M/B chipset 102 and AGP (Accelerated Graphics Port), adisplay device 110 for displaying graphic data generated with avideo card 104, aharddisk 105 and anetwork interface 106 connected to a M/B chipset 102 via a PCI (Peripheral Component Interconnect) bus, and afloppy disk drive 108 and a keyboard/mouse 109 connected from the PCI bus to a M/B chipset 102 via a slower bus such as abridge circuit 107 and an ISA (Industry Standard Architecture) bus. For adisplay device 110, a liquid crystal display (LCD) or CRT display, for example, can be used. - FIG. 1 is a merely example of a hardware configuration of a computer system for implementing the embodiment, and other different configurations can be adopted where the embodiment can be applied. For example, a configuration for processing image data at a
CPU 101 with mounting only a video memory is possible instead of providing avideo card 104, a sound feature can be provided to input and output with sound, or a drive for a CD-ROM (Compact Disk Read Only Memory) or a DVD-ROM (Digital Versatile Disk Read Only Memory) can be provided via an interface such as ATA (AT Attachment). - FIG. 2 is a block diagram illustrating a feature of an XML document processing system according to the first embodiment.
- Referring to FIG. 2, the embodiment includes an
XPath storing part 10 that stores a plurality of XPaths specifying a particular part of an XML document to be an objective of processing, a datastructure generation part 20 for generating a data structure to evaluate efficiently according to the embodiment from an XPath expression stored in theXPath storing part 10, a datastructure storing part 30 for storing a data structure generated at the datastructure generation part 20, and anevaluation execution part 40 for evaluating an XPath expression for an XML document to be an objective of processing by using a data structure stored in the datastructure storing part 30, as well as an XMLdocument storing part 50 for storing an XML document to be an objective of processing and an XMLdocument processing unit 60 for executing predetermined information processing with respect to an XML document, which has been subjected to an evaluation by anevaluation execution part 40. - In the system configuration illustrated in FIG. 2, a data
structure generation part 20, anevaluation execution part 40 and an XMLdocument processing unit 60 are virtual software blocks embodied at aCPU 101 controlled by a program shown in FIG. 1. A Program controlling aCPU 101 to implement each of these functions is provided and read in amain memory 103 by stored and distributed on a magnetic disk, an optical disk, a semiconductor memory or other storage media, or by delivered over a network. AnXPath storing part 10, a datastructure storing part 30 and an XMLdocument storing part 50 are embodied at amain memory 103. Data and programs held at amain memory 103 can be saved on a storage device such as aharddisk 105 as required. - In a system configuration shown in FIG. 2, an
XPath storing part 10 stores a previously provided plurality of XPath expressions to be evaluated with respect to an XML document. A data structure-storingpart 30 stores a data structure generated at a datastructure generation part 20 to be used at anevaluation execution part 40. An XMLdocument storing part 50 stores an XML document input through anetwork interface 106 or an input device such as a keyboard/mouse 109 shown in FIG. 1 or a drive for reading out the concerned XML document from a storage medium that stores the XML document to be an objective of processing. - A data
structure generation part 20 generates a data structure to be used for an evaluation with anevaluation execution part 40 from an XPath expression stored in anXPath storing part 10. If an XPath stored in anXPath storing part 10 is changed (added or deleted), a data structure is updated according to this change. With using such a data structure, an evaluation can be executed more efficiently than in the case that a plurality of XPath expressions stored in anXPath storing part 10 are evaluated independently with respect to an XML document. Detail for this data structure, evaluation methods using this data structure and generation methods of this data structure will be described below. - An
evaluation execution part 40 executes an evaluation (matching) of an XPath expression by using a data structure generated at a datastructure generation part 20 with respect to an XML document stored at an XMLdocument storing part 50. Thereby, it is efficiently evaluated whether the concerned input document has a certain part specified with an XPath expression stored in anXPath storing part 10 or not. An evaluation result with anevaluation execution part 40 is stored in a predetermined area of amain memory 103. - An XML
document processing unit 60 reads out an evaluation result with anevaluation execution part 40 from a predetermined area of amain memory 103, and if an XML document stored in an XMLdocument storing part 50 is determined to have a certain part specified with an XPath expression stored at anXPath storing part 10 on the basis of the evaluation result, the XMLdocument processing unit 60 reads out the XML document as an objective of processing from an XMLdocument storing part 50 and executes predetermined information processing, i.e., information processing previously provided as an application. - A method for streamlining an evaluation of an XPath expression in the embodiment will now be described in detail.
- In the embodiment, evaluation processing is speeded up by generating a data structure for sharing a common part of a plurality of XPath expressions and evaluating with respect to an XML document by using the data structure. In the embodiment, the following three approaches are presented to implement this:
Approach 1—sharing an evaluation of a step among a plurality of location paths;Approach 2—sharing an evaluation of a subexpression or an argument among a plurality of operation expressions or functions;Approach 3—speeding up a predicate of a location path. - Each approach will be described below.
-
Approach 1. sharing an evaluation of a step among a plurality of location paths - A case that following three XPath expressions P1, P2 and P3 are stored in an
XPath storing part 10 and the XPath expressions are evaluated with respect to an XML document will be described as an example. - P1 :/profile/demographics/age[text( )<20]
- P2 :/profile/interests/sport[text( )=‘Soccer’]
- P3 :/profile/demographics/age[text( )>=40 and text( )<50]
- Initially, a data structure that combined the above-mentioned XPath expressions P1, P2 and P3 is generated with a data
structure generation part 20. - The data
structure generation part 20 decomposes the above-mentioned XPath expressions into steps to generate this data structure. When a step consists of an axis, a set of node test and a predicate, they are also decomposed. In other word, an XPath expression P1 is decomposed to the following P1′, P2 to P2′, and P3 to P3′, respectively. - P1′ :profile+demographics+age+[text( )<20]
- P2′ :profile+interests+sport+[text( )=‘Soccer’]
- P3′ :profile+demographics+age+[text( )>=40 and text( )<50]
- Comparing P1′, P2′ and P3′, these three XPaths have ‘profile’ as a common step. P1′ and P3′ have subsequent step ‘demographics’ in common. Therefore, by combining a common step, these XPath expressions can be represented in a tree structure.
- In other words, a data
structure generation part 20 functions as a step decomposing means for decomposing an XPath into steps and a tree generation means for generating a tree structure (data structure) with a node corresponding to each step in this processing. - FIG. 3 is a diagram showing a data structure (tree structure) generated at a data
structure generation part 20. - Next, an
evaluation execution part 40 evaluates XPath expressions P1, P2 and P3 with respect to an XML document by using a tree data structure generated in the above-mentioned manner. - An example to evaluate XPath expressions P1, P2 and P3 with respect to an XML document shown in FIG. 4 will be discussed here.
- (1) Evaluation of an XPath expression P1
- A leading step of an XPath expression P1 ‘profile’ is initially evaluated with respect to an XML document D1 shown in FIG. 4. The evaluation result is a node set with following four elements.
- N1:
- {<name>Alan</name>,
- <demographics><age>35</age></demographics>,
- <location><city>Osaka</city></location>,
- <interests><sport>Soccer</sport><music>Classical</music><book>
- History</book></interests>}
- When the next step of an XPath expression P1 is applied for each of four elements in a node set N1, the result is as follows:
- { }, {<age>35</age>}, { }, { }
- Combining these four node sets to create a node set for this step, the result will be as follows:
- N2:
- {<age>35</age>}
- When ‘age’ is applied to an element of this node set N2, the result comes out as follows:
- N3:
- {35}
- When ‘[text( )<20]’ is further applied to the node set N3, the result comes out an empty node set, which is obtained as an evaluation result for an XPath expression P1.
- (2) Evaluation of an XPath expression P2
- Next, an XPath expression P2 is evaluated. In this case, an evaluation result for a leading step ‘profile’ for an XPath expression P2 has been obtained as a node set N1. Therefore, processing for this evaluation is not actually performed and the evaluation result that has already been obtained is used. When ‘interests’ is applied to each element of a node set N1, respective results are as follows:
- { }, { }, { }, {<sport>Soccer</sport>, <music>Classical</music>, <book>History</book>}
- Combining these four node sets to create a node set for this step results in as follows:
- N4:
- {<sport>Soccer</sport>,<music>Classical</music>,<book>History</boo k>}
- When ‘sport’, which is a remaining representation of XPath expression P2 is applied to three elements of a node set N4, and then ‘[text( )=‘Soccer’]’ to the result, it comes out as follows:
- {Soccer}, { }, { }
- Combining them results in
- {Soccer}
- , which is obtained as an evaluation result for an XPath expression P2.
- (3) Evaluation of an XPath expression P3
- Finally, an XPath expression P3 is evaluated. Here, an evaluation value for the part of ‘/profile/demographics/age’ in an XPath P3 location path with respect to an XML document D1 has been obtained as a node set N3. Therefore, processing for an evaluation of this part is not actually performed and the evaluation result that has been obtained is used. When the last predicate ‘[text( )>=40 and text( )<50]’ of an XPath P3 is applied to each element of the node set N3, the result is an empty node set, which is obtained as an evaluation result for an XPath expression P3.
- According to the above-mentioned manner, an amount of calculation time for a plurality of XPath expressions can be shortened by using a data structure shown in FIG. 3, performing an actual calculation for only once for a step common to a plurality of XPath expressions, and sharing the evaluation result.
- Although in the above-mentioned example, an XPath expression is described to be evaluated in any order, a storage area of a memory required in an evaluation can be reduced by evaluating either in the order of depth priorities or width priorities induced from a data structure in FIG. 3. For example, if an evaluation is done in depth priorities, a storage area required for holding a predetermined node can be freed when evaluations for all partial trees with respect to the concerned node has finished. In contrast, if an evaluation is done in width priorities, a storage area required for holding an evaluation result for upper nodes can be freed after the concerned evaluation result has been used for lower nodes.
- FIG. 5 is a flow chart illustrating a processing procedure with an
evaluation execution part 40 in evaluating a plurality of XPath expressions in width priorities. - Referring to FIG. 5, an
evaluation execution part 40 initially assigns a set including the entire XML document as a single element to the current node set (step 501). Then, leading steps of all location paths are included as elements of a set of steps (step 502). Then, the next processing is executed for all elements of the set of steps. In other words, steps are respectively evaluated for each element of the current node set (step 504). Next, all of the evaluation results are combined to be assigned to the current node set (step 505). - After processing of steps504 and 505 has been executed for all elements of a set of steps, next set of steps is sought with respect to all elements in a set of steps. Then, the evaluation results are combined to be replaced with the current set of steps (steps 503, 506).
- If any element is left in the set of steps, processing of steps from503 to 506 is repeated. The processing finishes when the set of steps is cleared of elements.
- In other words, in the above-mentioned processing, a
evaluation execution part 40 functions as a partial evaluation means for evaluating for each step corresponding to a node of a data structure and as an evaluation results combination means for obtaining an evaluation result for the entire XPath expression by combining evaluation results for respective steps in evaluating each XPath expression. When evaluating a step common to other XPath expressions, if any evaluation result from an evaluation of other XPath expressions for the step exists, evaluation processing for the step is omitted by using this evaluation result as an evaluation result for the step of the concerned XPath expression. - A basic property of an XPath for this approach is that the same result as one obtained from an evaluation of the entire path can be obtained by evaluating representations of a location path to the halfway to obtain a node set; then evaluating the remaining representations of the path by using each element of the obtained node set as a context node; and finally combining the results. In other words, in the above-mentioned procedure, a common part is extracted from a location path of each XPath expression, the common part and the other parts are evaluated separately, and the evaluation results are combined. If an evaluation result for the part that can share the evaluation result (a common part of a location path) has been in this process, that existing evaluation result is used by omitting evaluation results for the part. Therefore, when a path can be decomposed to meet this property, this approach is applicable.
- In the above description, the case in which ‘child’ as a default is selected by omitting an axis is exemplified. However, even the case in which an axis explicitly writes in such way as ‘descendant::age’ other than ‘child’ can be dealt with
Approach 1. The case in which ‘//’ is used as a separator between steps instead of ‘/’ can also be dealt with. ‘.’, ‘..’, ‘*’, ‘comment( )’, etc. can be described in addition to an element name as a node test. For example, such an XPath expression described in the following way can be dealt withApproach 1. - /*//interest/../demographics/descendant::age[text( )<20]
-
Approach 2. sharing an evaluation of a subexpression or an argument among a plurality of operation expressions or functions - For the above-mentioned
Approach 1, an approach for speeding up an evaluation of a location path is described. Although a location path expression is a main expression in an XPath, operation expressions such as an arithmetical operation, a comparison operation, a logical operation and functions are used for describing a condition of a path predicate or for generating data to be used by other programs. Therefore, an approach below for speeding up expressions other than a location path is used. - A case of following three XPath expressions P1, P2 and P3 being stored in an
XPath storing part 10 and the XPath expressions being evaluated with respect to an XML document will be described as an example. - P7:
- (/CPEXMLv1/person/partyActivities/food[favoriteFood=‘Hamburger’] or
- (not(/CPEXMLv1/person/partyActivities/hobby[typeName=‘SPORT’])and
- /CPEXMLv1/person/personDemographics/birthDate[year<1960])) and
- /CPEXMLv1/person/partyActivities/hobby/startDate[year=1986]
- P8:
- (/CPEXMLv1/person/partyDemographics[gender=‘MALE’] or
- (not(/CPEXMLv1/person/partyActivities/hobby[typeName=‘SPORT’]) and
- /CPEXMLv1/person/personDemographics/birthDate[year<1960])) and
- /CPEXMLv1/person/partyActivities/hobby/startDate[year>1990]
- P9:
- /CPEXMLv1/person/partyActivities/food[favoriteFood=‘Hamburger’] and
- /CPEXMLv1/person/partyActivities/hobby/startDate[year>1990]
- A data
structure generation part 20 initially decomposes the XPath expressions P7, P8 and P9 into subexpressions consisting of location paths. In other words, an XPath expression P7 is decomposed into P71-P74, P8 into P81-P84, P9 into P91 and P92, respectively. - P71 :/CPEXMLv1/person/partyActivities/food[favoriteFood=‘Hamburger’]
- P72 :/CPEXMLv1/person/partyActivities/hobby[typeName=‘SPORT’]
- P73 :/CPEXMLv1/person/parsonDemographics/birthDate[year=1960]
- P74 :/CPEXMLv1/person/partyActivities/hobby/startDate[year=1986]
- P81 :/CPEXMLv1/person/partyDemographics[gender=‘MALE’]
- P82 :/CPEXMLv1/person/partyActivities/hobby[typeName=‘SPORT’]
- P83 :/CPEXMLv1/person/personDemographics/birthDate[year<1960]
- P84 :/CPEXMLv1/person/partyActivities/hobby/startDate[year>1990]
- P91 :/CPEXMLv1/person/partyActivities/food[favoriteFood=‘Hamburger’]
- P92 :/CPEXMLv1/person/partyActivities/hobby/startDate[year>1990]
- Within the above subexpressions, P71 and P91, P72 and P82, P73 and P83, P84 and P92 are the same expressions. Therefore, XPath expressions P7, P8, P9 can be represented in a non-repeating directed graph (DAG).
- FIG. 6 is a diagram illustrating a non-repeating directed graph representing XPath expressions P7, P8 and P9.
- For six location paths shown at the left side of FIG. 6, an approach of sharing an evaluation of a step by the above-mentioned
Approach 1 can be used. Therefore, this part is converted into a data structure of a tree structure described in FIG. 3. The generated data structure of a non-repeating directed graph is stored in a data structure-storingpart 30 along with a data structure in a tree structure generated atApproach 1. - An
evaluation execution part 40 evaluates XPath expressions P7, P8 and P9 by using a data structure obtained in the above manner. At first, a location path part is evaluated by usingApproach 1. Next, each XPath expression is evaluated with a non-repeating directed graph shown in FIG. 6. At this point, a subexpression common to XPath expressions is evaluated for once for all and its evaluation result is reused for the common part, for the XPath expressions with a common subexpression. - Although a logical operation, in which an argument is a node set and the evaluated value is a true value, is exemplified in the above case, operation expressions in other data type such as an arithmetical operation can be optimized similarly.
-
Approach 3. speeding up a predicate of a location path - In the above-mentioned
Approach 1, steps with different predicates are described to be processed as separate steps. However, utilizing similarity among similar predicates can speed up the execution of predicates. - For example, such predicates as in the form of ‘[(expression) (comparison operator) (constant)]’, such as ‘[age<20]’ are speeded up. If it is not explicitly represented in this way, this approach can be applied to the predicate that can be converted into this form by replacement or partial calculation. For example, this approach can be applied to the specification ‘[2]’ with a location of a node, which can be replaced into ‘[position( )=2]’.
- The cases of: (1) a comparison operator is ‘=’; (2) a comparison operator is ‘!=’; and (3) a comparison operator is ‘>’ will now be specifically described.
- (1) speeding up when a comparison operator is ‘=’
- A hash table for searching for a remaining location path is created by using an evaluation result of a predicate expression in a step as a key. For example, an XPath expression which takes different values for ‘XYZ’ part of /CPEXMLv1/person/partyActivities/hobby[typeName=‘XYZ’]/ . . . , such as the following XPath expressions P41, P42, P43, P44, is considered.
- P41:
- /CPEXMLv1/person/partyActivities/hobby[typeName=‘SPORT’]/startDate/year
- P42:
- /CPEXMLv1/person/partyActivities/hobby[typeName=‘MUSIC’]/composer
- P43:
- /CPEXMLv1/person/partyActivities/hobby[typeName=‘SPORT’]/hobbyName
- P44:
- /CPEXMLv1/person/partyActivities/hobby[typeName=‘COMPUTER]/software
- A data
structure generation part 20 generates the following hash tables for the above-XPath expressions P41, P42, P43 and P44. - A searched set is {srartDate/year, hobbyName} when a key is ‘SPORT’
- A searched set is {composer} when a key is ‘MUSIC’
- A searched set is {software} when a key is ‘COMPUTER’
- For the part up to /CPEXMLv1/person/partyActivities/hobby, a step evaluation can be shared according to
Approach 1; so that a data structure for this part is generated (This part has no branch in a tree structure because all of the XPath expressions P41, P42, P43 and P44 are same.). The generated hash table is stored in a datastructure storing part 30 along with a data structure in a tree structure generated atApproach 1. - An
evaluation execution part 40 initially evaluates a step /CPEXMLv1/person/partyActivities/hobby according to the above-mentionedApproach 1 to obtain a node set. Then theevaluation execution part 40 executes processing with the above-mentioned hash table for each node of a node set. - FIG. 7 is a flow chart illustrating a flow of evaluation processing using a hash table.
- Referring to FIG. 7, a left side expression of a predicate (‘typeName’ in this case) is evaluated first (step701). Next, a hash table is searched for by using a left side expression value as a key, and if the searched result is obtained, evaluate the obtained location path with respect to the concerned node and return the evaluation result (steps 703, 704). In contrast, if the searched result is not obtained, return an empty node set (steps 703, 705).
- By using the above-mentioned
Approach 3, a predicate does not need to be evaluated as many times as the number of XPaths with respect to a single node, so that same result as the result obtained from evaluations for all predicates with respect to a single node can be obtained from a single table search. For example, if typeName is ‘MUSIC’, a single table search determines that a predicate of an XPath expression P42 is true and predicates of P41, P42 and P43 are false. - Given that the number of XPath expressions is ‘n’ and the number of nodes included in a node set is ‘m’, it takes a time period of O (n×m) to check a predicate for evaluating all XPaths with respect to all nodes without using Approach 3 (O (n×m) means that a calculation can be executed within a time period of n×m multiplied by a constant). In contrast, if
Approach 3 is used, a hash table search, which can be executed virtually within a constant time period, is executed for ‘m’ times. Therefore, when ‘n’ is too large,Approach 3 can speed up evaluation processing significantly. - (2) speeding up when a comparison operator is ‘!=’
- If a set of remaining location paths which is searched with a key of Ki, is Pi, when the above-mentioned comparison operation is ‘=’ if a comparison operation is ‘!=’, a hash table is configured so that a set of remaining location paths to be searched with a key of Kj will be Ui≠jPi. For XPath expressions P41, P42, P43 and P44, a hash table returning the following search results is configured.
- When a key is ‘SPORT’, {composer, software}
- When a key is ‘MUSIC’, {startDate/year, hobbyName, software}
- When a key is ‘COMPUTER’, {startDate/year, composer, hobbyName}
- Because the entire processing is same as that of the case (1) where a comparison operator is ‘=’, except for using the above-mentioned hash table, the description thereof is omitted.
- (3) speeding up when a comparison operator is ‘>’
- If a comparison operator is ‘>’, a data
structure generation part 20 creates a binary search tree for searching by using a constant in a predicate of a step as a key. For example, when two XPath expressions P5 and P6 exist, - P5 :/CPEXMLv1/person/personDemographics/birthDate[year>1990]/gender
- P6 :/CPEXMLv1/person/personDemographics/birthDate[year>1976]/birthplace
- a binary search tree for executing the following calculation is configured.
- if (Key>1990) then
- {gender, birthplace}
- else
- if (key>1976) then
- {birthplace}
- else
- { }
- endif
- endif
- A generated binary tree is stored in a data
structure storing part 30 along with a data structure in a tree structure generated atApproach 1. - An
evaluation execution part 40 evaluates steps up to /CPEXMLv1/person/personDemorgraphics/birthDate according t o the above-mentionedApproach 1. Then, a left-side expression of a predicate (‘year’ in this case) is evaluated and the evaluated value is used as a key to search a binary search tree. As a result of this search, if the key is a value larger than 1990, both ‘gender’ and ‘birthplace’ are returned. If the key is a value same or less than 1990 and larger than 1976, ‘birthplace’ is returned. If no condition is met, an empty set is returned. - Given that the number of XPath expressions is ‘n’ and the number of nodes included in a node set is ‘m’, it takes a time period of O (n×m) to check a predicate for evaluating all XPaths with respect to all nodes without using
Approach 3. In contrast, ifApproach 3 is used, a binary search, which takes a time period of O (log n), is executed for ‘m’ times. Accordingly, if ‘n’ is too large,Approach 3 can significantly speed up the evaluation processing. - Although the case with a comparison operator being ‘>’ is described hereinabove, of course the case with a comparison operator is ‘>=’, ‘<’ or ‘<=’ can be dealt in the same way.
- A method for a data
structure generation part 20 to generate a data structure (see FIG. 3) to be used in anevaluation execution part 40 from an XPath expression stored in anXPath storing part 10 will now be described. - For generating a data structure to be used in the embodiment, principally a general various methods for generating a tree structure can be used, leaving methods for generating unlimited in particular. However, the embodiment presents a generation method that can efficiently reflect a change into a data structure, when an XPath stored in an
XPath storing part 10 is changed (added or deleted). This method will be described below. - For shortening a time period required for evaluating an XPath expression with respect to an XML document, it may be a way to save a generated data structure in a data
structure storing part 30 to be reused in processing among a plurality of XML documents, instead of generating a data structure as mentioned above for each time the processing is performed. - In addition, if a set of XPaths stored in an
XPath storing part 10 is changed, a data structure for a desired set of XPaths can be efficiently obtained by reflecting each of the added XPath expressions and the deleted XPath expressions to a saved data structure instead of regenerating a data structure from the beginning. - In other words, if an XPath expression is newly added, a new node is generated for a step in the XPath expression, which does not have a node corresponding to an existing data structure, and the new node is added to the data structure. In contrast, if a predetermined XPath expression is deleted, only a node corresponding to a part unique to the XPath expression is removed from nodes corresponding to steps of the XPath expressions. In this manner, a data structure is efficiently updated.
- FIG. 8 is a flow chart illustrating a method for generating a data structure with a data
structure generation part 20. - In the embodiment, a desired data structure is obtained by adding an XPath expression in succession. Therefore, for the first time to generate a data structure, a predetermined XPath expression is selected from a set of XPaths stored in an
XPath storing part 10, to which another XPath expression is added subsequently. In the case that a new XPath expression is added due to a change occurred to a set of XPaths, a step of a newly added XPath expression is added to an already generated data structure stored in a datastructure storing part 30. - Referring to FIG. 8, a data
structure generation part 20 initially decomposes an XPath expression P, which is to be added, into step s1, s2, . . . , sk (step 801). Then, parameter ‘i’ and parameter ‘S’ are initialized, i.e. make them i=1, and S=‘a set of steps at top level’ (step 802), and then step ‘si’ is searched from a set of steps S (step 803). - If step ‘si’ is included in a set of steps S, then ‘i+1’ is a new value of a parameter ‘i’(steps804, 805), and whether the new ‘i’ is less than the number of steps ‘k’ in an XPath expression P or not is checked (step 806). If a value of ‘i’ is less than ‘k’, a parameter S is S=‘a set of steps at the next level of step ‘si’ in a data structure’, and processing is repeated from step 803 (step 807).
- On the other hand, if it is determined that a step ‘si’ is not included in a set of steps S at step804, steps corresponding to si, . . . , sk are added to a data structure (step 808) and the XPath expression P is registered to a corresponding step of the data structure, then processing ends (step 809).
- At step806, if a new value of ‘i’ reaches the number of step ‘k’ in an XPath expression P, the XPath expression P is also registered to the corresponding step of the corresponding data structure, then processing ends (step 809).
- Processing will be specifically described by exemplifying a case of adding the next XPath expression P4 to the data structure shown in FIG. 3.
- P4:/profile/location/city[text( )=‘Tokyo’]
- An XPath expression P4 is initially decomposed into steps as follows at step 801.
- s1=profile
- s2=location
- s3=city
- s4=[test( )=‘Tokyo’]
- If a location path is represented in abbreviation, the path should be converted into a form that is not represented in abbreviation before decomposition. For example, a separator ‘//’ between steps should be previously converted into ‘decendant-or-self::node( )’ and ‘.’ into ‘self::node( )’.
- Initialization to i=1, S={profile} is executed at step802. The process proceeds to step 807, where ‘{demographics, interests}’, which is the next level step of ‘profile’, is substituted for S in a data structure because step s1 is included in a set of steps S and remaining steps also exists (steps 803-806).
- Then, as it is determined that a value of step s2 ‘location’ is not included in a set of steps S at step 804, the process proceeds to step 808, where steps corresponding to s2, s3 and s4 are added to a data structure. Then, an XPath expression P4 is registered into a data structure at step 809.
- FIG. 9 is a diagram illustrating a data structure with an XPath expression P4 being added to the data structure of FIG. 3.
- A data structure for speeding up step evaluation with the above-mentioned
Approach 1 has been generated (updated). A generation (update) of a data structure to speed up an evaluation of an operation expression withApproach 2 will now be described. - At first, a location path is extracted from a newly added operation expression, and only the location path that has not been registered in an existing data structure is added to a data structure. A location path is added according to the procedure shown in a flow chart in FIG. 8.
- Subexpressions other than a location path are searched to find out whether they have been appeared as a common subexpression. If they have been appeared as a common subexpression, a data structure for evaluating the common subexpression will be reused. If they have not been appeared as a common subexpression, a data structure for evaluating the subexpression will be newly created and added to an existing data structure.
- Generation (update) of a data structure for speeding up an evaluation of a predicate with
Approach 3 will now be described. - If predicate of step ‘si’ is any one of [<expression>=<constant>], [<expression>=<constant>], [<expression><<constant>], [<expression><=<constant>], [<expression>><constant>], [<expression>>=<constant>], it is initially checked whether a hash table corresponding to an expression (or a binary tree) exists or not in step808 shown in FIG. 8. If the corresponding hash table (or a binary tree) does not exist, they are created. In other words, a search item with a constant as a key is added to an existing hash table (or a binary tree). Then, remaining step sequence (si+1, . . . , sk) is made in a tree structure and added to an existing data structure. Addition to the data structure is executed according to the procedure shown in a flow chart of FIG. 8.
- FIG. 10 is a flow chart illustrating processing of a data
structure generation part 20 at removal of a predetermined XPath expression from a data structure. - Referring to FIG. 10, a data
structure generation part 20 initially make a parameter ‘s’ as s=‘a step whose XPath expression P is registered on a data structure’ (step 1001), and removes an XPath expression P from step ‘s’(step 1002). - Next, the number of XPath expressions registered at a step ‘s’ is checked whether it is 0 or not. If it is not 0, the process ends (step1003).
- In contrast, if the number of XPaths registered at a step ‘s’ is 0, a parameter ‘sp’ is made to be sp=‘step upper than step ‘s’ by one within a data structure’ (step1004) and a step ‘s’ is removed from a step ‘sp’ (step 1005). Then, the number of steps lower than a step ‘sp’ by one is checked whether it is 0 or not. If it is not 0, the process ends (step 1006).
- In contrast, if the number of steps lower than a step ‘sp’ by one is 0, the process returns to step1004 as make it s=sp (step 1007), and process is repeated for a new step ‘s’.
- Processing will be specifically described by exemplifying the case that an XPath expression P3 is removed from a data structure shown in FIG. 9.
- A step on a data structure ‘[text( )>=40 and text<50]’ is assigned to a parameter ‘s’ at step1001. When an XPath expression P3 is removed from it, the number of XPath expressions registered at a step ‘s’ becomes 0. Then the process proceeds to step 1004. Then a step ‘s’ is removed from an upper step ‘demographics’ of the step ‘s’ at
step 1005. In this case, as it is determined that the number of lower steps of ‘demographics’ is not 0 at step 1006, the process ends here. - FIG. 11 is a diagram for illustrating a data structure with an XPath expression P3 being removed from a data structure shown in FIG. 9.
- A data structure for speeding up an evaluation of steps with the above-mentioned
Approach 1 has been updated. Updating a data structure for speeding up an evaluation of an operation expression withApproach 2 will now be described. - A location path is extracted from an operation expression to be removed; a location path that is solely used by the operation expression is searched for; and the location path is removed from a data structure. A check of whether a predetermined location path is solely used by an operation expression to be removed or not can be executed in an approach such as controlling the number of reference for a location path.
- Additionally, for subexpressions other than location paths, a subexpression that is solely used by the operation expression is sought and removed from a data structure.
- Updating a data structure for speeding up an evaluation of a predicate with
Approach 3 will now be described. - At first, an item corresponding to a constant of a predicate is removed from a hash table (binary tree). Then, a location path searched from the item is deleted from a data structure. A location path is deleted according to the procedure shown in a flow chart of FIG. 10.
- Operation of the embodiment will now be described with XPath expressions and XML documents as a specific example.
- Assuming that the following four XPath expressions are stored in an
XPath storing part 10. - P11 :/profile/interests[sport/@type=‘Soccer’]/music
- P12 :/profile/interests[sport/@type=‘Baseball’]/book
- P13 :/profile/demographics/age
- P14 :count(/profile/interests[sport/@type=‘Soccer’]>1
- A data
structure generation part 20 generates a data structure with respect to the above four XPath expressions P11, P12, P13 and P14 in the procedure shown in FIG. 8. XPath expressions P11, P12, P13 and P14 will be described below as they are added to an empty tree structure (initial condition) in succession. - Addition of P11:
- (1) Decompose a location path into three steps of ‘profile’, ‘interests[sport/@type=‘Soccer’]’, and ‘music’ (step801).
- (2) As step ‘profile’ is not registered at a data structure, the step is added and registered (steps804, 808, 809).
- (3) Decompose a step ‘interests[sport/@type=‘Soccer’]’ into ‘interests’ and ‘[sport/@type=‘Soccer’]’.
- (4) As step ‘interests’ is not registered at a data structure, the step is added and registered (steps804, 808, 809).
- (5) As a hash table for a predicate does not exist, a hash table is generated.
- (6) Create a data structure representing a location path ‘sport/@type’, a left side expression of a predicate to add to the hash table.
- (7) Add an entry, in which a key is ‘Soccer’ and a value is a remaining step ‘music’, to the hash table.
- Addition of P12:
- (1) Decompose a location path into three steps of ‘profile’, ‘interests[sport/@type=‘Baseball’]’, and ‘book’ (step801).
- (2) As step ‘profile’ and ‘interests’ have been registered at a data structure and a data structure for ‘sport/@type’ has also added to a corresponding hash table, addition to a data structure is not executed, executing only the registration of an XPath expression P12 (step 809).
- (3) Add an entry, in which a key is ‘Baseball’ and a value is a remaining step ‘book’, to the hash entry.
- Addition of P13:
- (1) Decompose a location path into three steps of ‘profile’, ‘demographics’, and ‘age’ (step801).
- (2) As a step ‘profile’ is registered but ‘demographics’ and ‘age’ are not registered, add ‘demographics’ and ‘age’ as steps at a data structure, and register an XPath expression P13 (steps 804, 808, 809).
- Addition of P14
- (1) Decompose an expression into subexpressions and extract a location path ‘/profile/interests[sport/@type=‘Baseball’]’.
- (2) As the location path ‘/profile/interests[sport/@type=‘Baseball’]’ has been registered, generate a data structure to pass the result to a function ‘count’ and also pass the result of a function ‘count’ to a comparison operator.
- The data structure representing four XPath expressions P11, P12, P13 and P14 have been generated.
- FIG. 12 is a diagram showing a generated data structure.
- A generated data structure is stored and saved in a data structure-storing
part 30. - Here, it is assumed that an XML document shown in FIG. 13 has been input and stored in an XML document-storing
part 50. Anevaluation execution part 40 reads out this XML document from an XMLdocument storing part 50, and evaluates XPath expressions P11, P12, P13 and P14 by using a data structure stored in a datastructure storing part 30. - Initially, the first step “profile” is executed and a node set N1 consisting of two elements is obtained.
- N1:
{ <demographices> <age>19</age> </demographics>, <interests> <sport type@=′Baseball′/> <book>History<book/> </interests> } - Next, a step “interests” is applied to each element of a node set N1 and the following two node sets are obtained.
- { }
- {<sport type@=‘Baseball’/>, <book>History<book/>}
- Then, these two node sets are combined and a node set N2, which is the result of ‘interest’ is obtained.
- N2:
- {<sport type@=‘Baseball’/>, <book>History<book/>}
- The left side expression ‘sport/@type’ is evaluated with respect to two elements of node set N2, then { } and {‘Baseball’} are obtained, respectively.
- Next, a hash table is searched by using ‘Baseball’ as a key, and a step ‘book’ and a function ‘count’ are obtained. ‘book’ is evaluated with respect to two elements of node set N2, then { } and {History} are obtained. These two are combined, and
- an evaluated value for an XPath expression P2:{History}
- is obtained.
- Then, a function ‘count’ is evaluated by using {<sport type@=‘Baseball’/> as an argument, the value comes out 1. As a comparison operation with this
value 1 are evaluated, it will be ‘false’. Then, - an evaluated value for an XPath expression P4:false
- is obtained.
- Next, a step ‘demographics’ is applied to each element of a node set N1 and the results are combined to be ‘{<age>19</age>}’. A step ‘age’ is further applied to this element, and
- an evaluated value for an XPath expression P3: {19}
- is obtained.
- As a node to reach an XPath expression P1 even after visited a data structure does not exist,
- an evaluated value for an XPath expression P1: empty node set
- is obtained.
- The embodiment of processing an evaluation of an XPath expression with an XML document processing system according to the embodiment will now be described.
- In the embodiment, the entire execution time is shortened by fragmenting an XPath expression into steps as stated above, and then by changing execution sequence or by reducing the number of execution with respect to execution of XPath fragments obtained from the fragmentation.
- A fragment of an XPath expression is also an XPath expression; a package ‘org.apache.xpath’ of an XPath processor included in an XSLT processor Xalan-
Java® 2 provided in Apache XML Project (hereinafter merely referred to as Xalan) is used to execute this fragment. For example, a function of Xalan is used as it is for executing a step of a location path or for evaluating an arithmetic expression. Therefore, how much the present invention streamlines an evaluation of an XPath is directly known from the difference between an execution only with Xalan and an execution with Xalan in an XML document processing system according to the present invention. - In the embodiment, many XPath expressions are provided for an XML document defined by CPExchange (IDEAlliance, CPExchange Specification Version 1.0, 2000. (http://www.cpexchange.org/)). An appropriate XPath expression for a given XML document is selected from the XPath expressions. XPath expressions are generated in the following pattern with different XYZ, and registered to a system.
- /CPEXMLV1/person/partyActivities/hobby[typeName=‘XYZ’]
- /CPEXMLV1/person/partyActivities/hobby[hobbyName=‘XYZ’]
- /CPEXMLV1/person/partyActivities/food[favoriteFood=‘XYZ’]
- /CPEXMLV1/person/personDemographics/gender[@enumtype=‘XYZ’]
- /CPEXMLV1/personName[firstName=‘XYZ’]
- /CPEXMLV1/person/partyActivities/hobby/startDate[year!=‘XYZ’]
- /CPEXMLV1/person/personDemographics/birthDate[year=‘XYZ’]
- /CPEXMLV1/person/partyActivities/newspaper/startDate[year=‘XYZ’]
- /CPEXMLV1/person/partyActivities/hobby/startDate[year=‘XYZ’]
- /CPEXMLV1/person/partyActivities/magazine/startDate[year=‘XYZ’]
- As an operating environment for a system, 800 MHz of a mobile Pentium® III from U.S. Intel is used for a
CPU 101, 128 MB of a RAM (Random Access Memory) for amain memory 103, andWindows® 2000 from U.S. Microsoft for an operating system. - FIG. 14 is a diagram illustrating an execution time taken for evaluating an XPath expression according to the embodiment. In FIG. 14, two kinds of execution time measured respectively in (1) a system for evaluating an XPath expression solely with an Xalan, and (2) a system for evaluating with the combination of approaches according to the present invention and an Xalan are shown.
- Referring to FIG. 14, in a system solely using an Xalan, an execution time lineally increases with regard to the increase in the number of XPath expressions. In contrast, in a system using an Xalan in the embodiment, an execution time shows little increase with regard to the increase in the number of XPath expressions. Accordingly, the difference between two cases becomes larger as the number of XPath expressions increases.
- Second Embodiment
- In the above-mentioned first-embodiment, processing of evaluation is speeded up by evaluating an XML document with a data structure, which shares a common part of a plurality of XPath expressions to be evaluated, and sharing the result. In contrast, in the second embodiment, processing of evaluation is speeded up by analyzing dependency among a plurality of XPath expressions to be evaluated, evaluating with a data structure with a redundant part of a plurality of XPath expressions omitted on the basis of the obtained dependency to simplify the processing of evaluation. The embodiment will be described by exemplifying the case in which whether an XPath expression within an annotation correctly specifies a predetermined element of an objective web page or not is evaluated in order to add an annotation to a web page.
- A web page processing system according to the second embodiment is embodied in a computer system with a hardware configuration shown in FIG. 1, for example, as in the case of the first embodiment.
- FIG. 15 is a block diagram illustrating a function of a web page processing system according to the second embodiment.
- Referring to FIG. 15, the embodiment includes an
XPath storing part 1510 that stores a plurality of XPath expressions specifying a certain part of a web page to be an objective of processing (HTML document), a datastructure generation part 1520 that generates a data structure for performing an efficient evaluation according to the embodiment from the XPath expressions stored in anXPath storing part 1510, a datastructure storing part 1530 that stores a data structure generated at a datastructure generation part 1520 and anevaluation execution part 1540 that evaluates an XPath expression with respect to a web page to be an objective of processing by using a data structure stored in a datastructure storing part 1530, as well as adocument storing part 1550 that stores a web page to be an objective of processing and adocument processing unit 1560 that performs a predetermined information processing with respect to a web page, which has been subjected to an evaluation with anevaluation execution part 1540. - In a system configuration shown in FIG. 15, a data
structure generation part 1520, anevaluation execution part 1540 and adocument processing unit 1560 are virtual software blocks embodied in aCPU 101 controlled by a program shown in FIG. 1. A Program controlling aCPU 101 to implement each of these functions is provided and read in amain memory 103 by stored and distributed on a magnetic disk or an optical disk, a semiconductor memory or other storage media, or by delivered over a network. AnXPath storing part 1510, a datastructure storing part 1530 and adocument storing part 1550 are implemented at amain memory 103. Data and program held in amain memory 103 can be saved on a storage device such as aharddisk 105 as required. - In a system configuration shown in FIG. 15, an
XPath storing part 1510 stores a plurality of previously prepared XPath expressions to be evaluated with respect to a web page. A datastructure storing part 1530 stores a data structure that is generated at a datastructure generation part 1520 to be used in anevaluation execution part 1540. Adocument storing part 1550 stores a web page that input through anetwork interface 106 or an input device such as a keyboard/mouse 109 shown in FIG. 1 or a drive for reading out the concerned web page from a storage medium that stores the web page to be an objective of processing. - A data
structure generation part 1520 generates a data structure to be used for an evaluation by anevaluation execution part 1540 from XPath expressions stored in anXPath storing part 1510. By using this data structure, an evaluation can be executed more efficiently than in the case that a plurality of XPath expressions stored in anXPath storing part 1510 are separately evaluated with respect to a web page. Detail of this data structure and a method for evaluating by means of this data structure and a method for generating this data structure will be described below. - An
evaluation execution part 1540 is an XPath engine and executes an evaluation (matching) of an XPath expression by using a data structure generated at a datastructure generation part 1520 with respect to a web page stored in adocument storing part 1550. Thereby, it is efficiently evaluated whether the concerned input document has a certain part specified by an XPath expression stored in anXPath storing part 1510 or not. Evaluation results from anevaluation execution part 1540 are stored in a predetermined area in amain memory 103. - A document-
processing unit 1560 reads out an evaluation result of anevaluation execution part 1540 from a predetermined area of amain memory 103. If a web page stored at adocument storing part 1550 has a certain part specified by an XPath expression stored in anXPath storing part 1510 on the basis of the evaluation result, thedocument processing unit 1560 reads out the web page as an objective of processing from thedocument storing part 1550 and executes an intended predetermined information processing, i.e., processing of adding an annotation to a web page. - A method for streamlining an evaluation of an XPath expression according to the embodiment will now be described.
- In an operation of adding an annotation to a web page, it is necessary to evaluate whether a plurality of XPath expressions in the concerned annotation correctly specifies a predetermined element of an objective web page or not to determine whether a predetermined annotation is applicable to a predetermined web page or not. In other words, this could be expressed as a problem of evaluating whether a set of a plurality of XPath expressions (hereinafter referred to an XPath set) matches the concerned web page or not. Mating of an XPath set with a web page means all of the XPath expressions included in the XPath set match the structure of the concerned web page. The embodiment, particularly intends to the streamlining of an evaluation processing in the case of determining an XPath set that matches a web page among a plurality of XPath sets, as in the case of searching an annotation applicable for a predetermined web page among a plurality of annotations.
- The embodiment speeds up processing of evaluation in the above-mentioned case by generating a data structure for simplifying an evaluation of an XPath expression on the basis of dependency among a plurality of XPath expressions and by evaluating a web page by means of this data structure. In the embodiment, different algorithms are applied on the basis of a type of an evaluation execution part1540 (
TYPE 1 andTYPE 2 shown below). - TYPE 1: Call overhead for an XPath evaluation function is large. Smaller number of evaluations of an XPath expression can improves an entire performance of a system (processing efficiency). TYPE 2: Call overhead for an XPath evaluation function is small. An entire performance of a system (processing efficiency) does not significantly deteriorate even through an evaluation of an XPath expression after it has been separated.
- The case in which a type of an
evaluation execution part 1540 is inTYPE 1 will now be described. - In this case, as smaller number of an evaluation of an XPath improves performance of a system, a data
structure generation part 1520 does not separate an XPath expression within a data structure to be generated. Specifically, processing such as: - 1. narrowing down of XPath expressions on the basis of similarity among XPath expressions;
- 2. simplifying of a connected XPath expression on the basis of dependency among XPath expressions;
- 3. omitting of XPath expressions on the basis of dependency among XPath expressions;
- 4. integration of XPath expressions;
- 5. priority sequencing of evaluation processing on the basis of the length of a tree and locations on a DOM tree for an XPath; and
- 6. construction of a data structure for determination of execution timeare executed.
- Each processing will be described below. Terms “an XPath expression holds” or “an XPath will be true” used hereinafter mean “an element corresponding to an XPath expression exists in a web page to be evaluated”.
- 1. Narrowing down of XPath expressions on the basis of similarity among XPath expressions
- An XPath expression included commonly in a plurality of XPath sets is not involved in determination of an XPath set which matches a web page. The reason for this is that an evaluation result for such an XPath expression is common to (is not differentiated for) each XPath set. Therefore, an evaluation of an XPath that is not included in a plurality of XPath sets (specific XPath) is executed before others.
- FIG. 16 is a table listing XPath sets and XPath expressions included therein. In an example shown in FIG. 16, a plurality of XPath expressions are included in each of four kinds of XPath sets (A, B, C, D). XPath expressions shown in FIG. 16 include much redundancy. For example, an XPath expression at No.5 (XPath set A) is identical to an XPath expression at No. 14 (XPath set B).
- FIG. 17 is a diagram listing XPath expressions shown in FIG. 16 with redundancy got rid of and identifying information (XPath ID) assigned. In an example shown in FIG. 17, 31 XPath expressions shown in FIG. 16 are reduced to 18.
- FIG. 18 is a diagram illustrating reduced XPath expressions shown in FIG. 17 with further analyzed and extracted of XPath expressions common to a plurality of XPath sets in a graph structure.
- Referring to17, an XPath expression X7 is commonly included in XPath sets C and D and an XPath expression X1, X2, X3 and X18 are commonly included in all XPath sets. In the example of FIG. 18, each XPath expression unique to each XPath set is described with a node, which represents XPath expressions commonly included in the plurality of XPath sets, branched into respective XPath sets. Therefore, in the example of FIG. 18, objectives of evaluation will be narrowed down to 13 types of XPath expressions (X4-X6, X8-X17) added to a node, which represents each XPath set.
- 2. Simplifying of a connected XPath expression on the basis of dependency among XPath expressions
- A connected XPath expression is an expression which connects a plurality of XPath expressions with an OR sign (|) For example, a connected XPath expression specifying one of two table contents (table [1], table[2]) placed at a predetermined location (body [1]) in a predetermined web page (html [1])
- /html[1]/body[1]/table[1]/html[1]/body[1]/table[2]
- is considered. It is indicated that the XPath expression holds if either /html[1]/body[1]/table[1] or /html[1]/body[1]/table[2] exists in a predetermined web page. It is evident that if table[1] does not exist, table[2] does not exist from a description rule for an XPath expression. Therefore, for this connected XPath expression, it is enough to evaluate only the first half part, /html[1]/body[1]/table[1].
- In such a case that a predetermined XPath expression (XPath1) holds, and another XPath expression (XPath2) also holds, an
XPath 2 is defined to depend on anXPath 1. A connected XPath is simplified by taking advantage of this feature. - Dependency between XPath expressions is broadly divided into the following two kinds:
- Identical tag sibling relation
- If
-
XPath 1/html[1]/body[1]/table[2] -
XPath 2/html[1]/body[1]/table[1], - an
XPath 1 and anXPath 2 are in sibling relation, so, - if an
XPath 1 holds, anXPath 2 also holds, and - if an
XPath 2 does not hold, anXPath 1 does not hold either. - Therefore, “an
XPath 1 depends on anXPath 2.” - Parent node relation
- If
-
XPath 1/html[1]/body[1]/table[1]/tr[1]/td[1] -
XPath 2/html[1]/body[1]/table[1], - an
XPath 1 is a descendant of anXPath 2, so, - if an
XPath 1 holds, anXPath 2 holds, and - if an
XPath 2 does not hold, anXPath 1 does not hold either. - Therefore, “an
XPath 1 depends on anXPath 2.” - Simplification of a connected XPath expression is executed according to the following procedure.
- At first, break a connected XPath expression and newly assign to an XPath ID. For example, as an XPath expression X1 shown in FIG. 7 is
- /html[1]/body[1]/table[1]/tbody[1]/tr[1]/html[1]/body[1]/table[1]/tbody[1]/tr[2],
- this expression can be broken into following two XPath expressions:
- X1-1 :/html[1/body[1]/table[1]/tbody[1]/tr[1]
- X1-2 :/html[1]/body[1]/table[1]/tbody[1]/tr[2]
- In a same manner, 13 kinds of XPath expressions, which were made objectives of evaluation in FIG. 18, are analyzed and broken. Then, dependency among the respective broken XPath expressions is examined.
- FIG. 19 is a diagram illustrating dependency among the obtained broken XPath expressions in a tree structure. XPath expressions X6-5 and X7, each described in a circle in FIG. 19, are identical.
- Referring to FIG. 19, a plurality of XPath expressions originally included in a single connected XPath expression (X1) like X11-3, X11-2, and X11-1 may have dependency each other. In this case, lower XPath expressions, X11-2 and X11-3 do not need to be evaluated from the reasons described below.
- In other words, if X11-1 holds, the original connected XPath expression X1 holds, too. This is because of a feature that if at least one of XPath expressions in connected relation holds, a connected XPath expression including the expression also holds.
- In contrast, due to dependency, if X11-1 does not hold, X11-2 nor X11-3 holds. Therefore, X11-2 and X11-3 do not influence the evaluation result of XPath expression X1.
- A connected XPath expression is simplified by deleting an XPath expression dependent to other XPath expressions as described above.
- FIG. 20 is a diagram illustrating a connected XPath expression simplified on the basis of dependency among XPath expressions shown in FIG. 19.
- 3. Omitting of XPath expressions on the basis of dependency among XPath expressions
- In a plurality of XPath expressions, due to a restriction caused by a variation of structures or elements of a web page, if a evaluated result is obtained for one XPath expression, evaluation results for other XPath expressions may be evident. For example, the case, in which two XPath expressions specifying two table contents (table[1], table[2]) placed in a predetermined location (body[1]) in a predetermined web page (html[1])
- XPath1 /html[1]/body[1]/table[2]
- XPath2 /html[1]/body[1]/table[1]
- are in an XPath set is considered. In this case, if an
XPath 1 specifying table[2] exists, anXPath 2 specifying table[1] always exists too. Therefore, anXPath 2 does not need to be evaluated. An XPath expression to be evaluated is deleted by taking advantage of this feature. - Dependency among these XPaths will be described further in detail. A condition for a predetermined XPath set to hold is “holding of all XPath expressions included in” the XPath set. If either of the above-mentioned an
XPath 1 and anXPath 2 does not hold, the entire XPath set will not hold. In other words, the following relation will be established. - If an
XPath 1 holds, anXPath 2 holds, too. - If an
XPath 1 does not hold, the entire XPath set does not hold either. - Due to the above-mentioned reason, it can be ignored whether an
XPath 2 holds or not. In other words, “if all XPath sets that includes a predetermined XPath expression (anXPath 2 in the above case) appears at the end of a dependency tree (such a tree structure shown in FIGS. 19, 20), the XPath expression (anXPath 2 in the above case) can be omitted because the expression does not influence whether the set holds or not. - FIG. 21 is a diagram of XPath expressions omitted on the basis of dependency among XPath expressions shown in FIG. 20. FIG. 21 (A) is a diagram with XPath expressions to be omitted (X2, X7, X9) being marked up, while FIG. 21 (B) is a diagram with XPath expressions marked up in FIG. 21(A) being deleted from the dependency tree. Codes attached to XPath expressions in the diagram such as ‘A’, ‘B’, ‘ABCD’, indicate the XPath sets which include those XPath expressions. In FIG. 21, subscripts to X11 and X1 (‘1’ in X1-1, X11-1) are omitted. This is because these XPath expressions are converted from connected XPath expressions to single XPath expressions through processing of ‘2’.
- 4. Integration of XPath expressions
- To use an
evaluation execution part 1540 ofTYPE 1 with a large call overhead of an XPath evaluation function, a datastructure generation part 1520 recombines a connected XPath expression broken at the analysis of dependency among XPath expressions at processing of ‘2’, in order to reduce the number of XPath expressions to be evaluated. - FIG. 22 is a diagram illustrating the case that recombination is executed for what can be recombined with respect to an XPath expression in the dependency tree of XPath expressions shown in FIG. 21.
- Combination processing is executed according to the following rule.
- (1) The location of a combined XPath expression should be immediately below the parent node that is shard with all of the belonging XPath expressions.
- (2) If no parent node exists, a combined XPath expression itself should be a rout node.
- In the examples shown in FIGS. 21 and 22, as XPath expressions like X5-*, for example, three expressions of X5-4, X5-1, and X-2 exist (see FIG. 21(B)). When the XPath expressions are followed toward a rout respectively, they meet at X4. Then, all XPath expressions represented in X5-* are arranged in a single node immediately below X4 (see FIG. 22(A)), being recombined to make an XPath expression X5 (see FIG. 22 (B)). X6 and X17 are recombined in the same manner.
- It is assumed that X5-2 is a child node of X18. In this case, as any sharing parent node does not exist, X5-* is recombined to be a node in the same level as X1, X3, X4 and X18 as a rout node.
- 5. Priority sequencing of evaluation processing on the basis of the length of a tree and locations on a DOM tree for an XPath
- In order to decide and weed out a XPath set that does not match a web page to be evaluated in an efficient manner, XPath expressions that intended to ‘an element which does not likely to exist’ are preferably processed before. Then, the order of XPath expressions to be evaluated (priorities) is decided with the following criteria.
- (1) An XPath expression with long tree for an XPath expression
- (2) An XPath expression located after on a DOM tree for a web page to be evaluated
- (3) XPath expressions influence more XPath expressions when they hold are preferred on the basis of dependency among XPath expressions
- For example, an evaluation of /table[1] is executed after an evaluation of /table[1]/tr[1]/td[1] that includes more part toward the end (rule (1)). Between /table[1] and /table[2], an evaluation of /table[2] is executed before, because /table[2] appears ‘after’ /table[1] when the DOM tree is visited around, i.e., /table[2] specifies an element, which appears after one specified with /table[1] in the order of tags for HTML (rule (2)). This is because a probability of appearance for an XPath expression (/table[2]) placed after in the DOM tree is lower than that for an XPath expression (/table [1]) placed before in the DOM tree.
- FIG. 23 is a diagram illustrating each node (an XPath expression) in the dependency tree shown in FIG. 22 added with priorities (the number in a circle) according to the above-mentioned rules. FIG. 24 is a table listing XPath expressions on the basis of the priorities shown in FIG. 23. In FIG. 24, other XPath expressions, on which each XPath expression depends (dependent XPath), dependency levels, tree lengths for each XPath expression are also described. ‘Dependency level’ used here refers to a depth of a tree when a rule node is 0. ‘Tree length’ refers to a length of a tree for the XPath expression itself. A tree length for a connected XPath expression represents the length of an XPath expression whose tree length is the longest of all the XPath expressions constituting the XPath expression.
- In FIG. 23, XPath expressions X10 and X11 are both at dependency level three, the deepest dependency level. In other words, if the expressions hold, they influence more XPath expressions than the other expressions do. Between X10 and X11, X10 has a longer tree length. For this reason, priority of X10 is 1 and priority of X11 is 2. Between XPath expressions X12 and X13, which are equal both in dependency level and tree length, X13 is higher in priority because X13, which specifies /td[2]/table[1], is placed after than X12 on a DOM tree for a web page to be evaluated.
- 6. Construction of a data structure for determination of execution time
- An XPath set, which has been organized on the basis of dependency among XPath expressions in the above-mentioned manner, is converted into a data structure that can be referenced in matching processing with a web page (for example, a non-repeating directed graph structure) and save it in a predetermined storage device (for example, a
main memory 103 shown in FIG. 1). - After a data structure for efficiently executing an evaluation of an XPath set is generated in the above-mentioned manner, an
evaluation execution part 1540 evaluates with respect to a web page stored in adocument storing part 1550 using the data structure. - As the
evaluation execution part 1540 is in a type of improving the entire performance of a system for smaller number of evaluation of XPath expressions (TYPE 1) according to the above description, an evaluation is executed from the XPath expression at top priority in descending order according to the following procedure. - 1. Select the XPath expression at top priority among XPath expressions to be processed, and evaluate with respect to a web page.
- 2. If an XPath expression to be evaluated matches, remove other XPath expressions, which depend on the XPath expression, (XPath expressions in lower priorities) from an evaluation, because they are guaranteed to match.
- In contrast, if an XPath expression to be evaluated does not match, all XPath expressions included in an XPath set, which includes the XPath expression, will be removed from objective of evaluation, because the XPath set does not match the web page.
- 3. When processing for all XPath expressions unique to each XPath-set (specific XPath) has finished, the XPath set all of whose XPath expressions match may perfectly match the web page. Then, it is examined whether such an XPath set exists or not.
- 4. If such an XPath set exists, XPath expressions, which the XPath set shares with other XPath sets, are evaluated with respect to the XPath set.
- In contrast, if such an XPath set does not exist, an XPath set that perfectly matches the web page does not exist either. Then, the processing ends here without evaluating XPath expressions, which the XPath set shares with other XPath sets.
- If evaluation processing for an XPath set according to the embodiment is used as processing to decide an annotation to be added to a web page from a plurality of annotations, an annotation with an XPath set, all of whose XPath expressions are determined to match according to the above procedure, will be decided as an annotation that can be added to the web page.
- The case, in which a type of an
evaluation execution part 1540 isTYPE 2 will now be described. - In this case, the entire performance of a system does not significantly deteriorate even when an XPath expression is separated and evaluated. Therefore, a data
structure generation part 1520 separates an XPath expression in a data structure to be generated and simplifies each XPath expression. Specifically, processing such as: - 1. narrowing down of XPath expressions on the basis of similarity among XPath expressions;
- 2. simplification of a connected XPath expression on the basis of dependency among XPath expressions;
- 3. omitting of an XPath expression on the basis of dependency among XPath expressions;
- 4. separating an XPath expression;
- 5. priority sequencing of evaluation processing on the basis of a tree length and locations on a DOM tree for an XPath; and
- 6. construction of a data structure for determination of execution time are executed.
- Processing from 1 to 3 among the above processing is same as in the case, in which the type of an
evaluation execution part 1540 isTYPE 1. Therefore, the description for the processing is omitted. - 4. Separating an XPath expression
- If an
evaluation execution part 1540 ofTYPE 2 with smaller call overhead for an XPath evaluation function is used, a datastructure generation part 1520 speeds up processing by fragmenting a plurality of XPath expressions into a common part and a unique part, and evaluating each of them. - For example, the following two XPath expressions (XPath1, XPath2) share a part (node) of /html[1]/body[1]/table[1]/tr[1]/td[1].
-
XPath 1 /html[1]/body[1]/table[1]/tr[1]/td[1]/font[1] -
XPath 2 /html[1]/body[1]/table[1]/tr[1]/td[1]/b[1] - Therefore, speedy processing can be implemented by evaluating the common node, and evaluating only font[1] and b[1] for relative path from the node. Here, relation between /html[1]/body[1]/table[1]/tr[1]/td[1] and /html[1]/body[1]/table[1]/tr[1]/td[1]/font[1] is called ‘inclusive relation’ and represented as ‘/html[1]/body[1]/table[1]/tr[1]/td[1]/font[1] includes /html[1]/body[1]/table[1]/tr[1]/td[1]’. On the basis of this inclusion relation, an XPath expression is separated into a common part and a unique part to make each part an XPath subexpression.
- FIG. 25 is a table showing a list of XPath expressions obtained through the separation processing after simplification and omitting on the basis of dependency. XPath expressions PX1, PX2, and PX3 in the list are XPath subexpressions added according to the separation processing. It is evident that separation processing of these three XPath expressions has made each XPath expression significantly simple compared to XPath expressions listed in FIG. 17. FIG. 26 shows a dependency tree including PX1, PX2, and PX3.
- 5. Priority sequencing of evaluation processing on the basis of a tree length and locations on a DOM tree for an XPath
- In order to decide and weed out a XPath set that does not match a web page to be evaluated in an efficient manner, XPath expressions that intended to ‘an element which does not likely to exist’ are preferably processed before. Then, the order of XPath expressions to be evaluated (priority) is decided with the following criteria.
- Processing to decide priority is same as in the above-mentioned case, in which a type of an
evaluation execution part 1540 isTYPE 1, though priority including XPath expressions PX1, PX2, and PX3 newly added at processing at ‘3.’ are decided. - FIG. 27 is a diagram illustrating each node of the dependency tree shown in FIG. 26 (XPath expression) added with priorities according to the above rule. FIG. 28 is a table listing XPath expressions according to the priorities shown in FIG. 27. As a common part of a plurality of XPath expressions is separated and becomes individual XPath expressions by means of the above-mentioned processing of ‘4.’, a tree length of an XPath expression itself is not involved in the decision on priorities.
- 6. Construction of a data structure for determination of execution time
- XPath sets, which have been organized on the basis of dependency among XPath expressions in the above-mentioned manner, are converted into a data structure that can be referenced in matching processing with a web page (for example, a non-repeating directed graph structure) and saved in a predetermined storage device (for example, a
main memory 103 shown in FIG. 1). This processing is same as that in the case, in which a type of anevaluation execution part 1540 isTYPE 1. - After a data structure to efficiently execute an evaluation of an XPath set is generated in the above-mentioned manner, an
evaluation execution part 1540 evaluates with respect to a web page stored in adocument storing part 1550 using the data structure. - As the
evaluation execution part 1540 is in a type, in which an entire performance of a system does not significantly deteriorate even when a frequency of evaluation for XPath expression is high (TYPE 2). Therefore, an evaluation is executed in the following manner from the XPath expression at top priority in descending order. - 1. Select the XPath expression at top priority among XPath expressions to be processed, and evaluate with respect to a web page. At this time, XPath expressions included in the XPath expression to be evaluated are also evaluated. If included XPath expressions have been evaluated (if they are evaluated along with the evaluation of XPath expressions in higher priorities), those evaluation results are reused.
- 2. If an XPath expression evaluated at ‘1.’ matches, other XPath expressions, which depend on the XPath expression, (XPath expressions in lower priorities) will be removed from the evaluation, because they are guaranteed to match.
- In contrast, if the XPath expression to be evaluated does not match, all XPath expressions included in an XPath set, which includes the XPath expression, will be removed from objectives of evaluation, because the XPath set does not match the web page. If XPath expressions included in the XPath expression to be evaluated do not match, all the other XPath expressions including the XPath expression are primarily removed from objectives of processing. A connected XPath expression, however, is not removed from objectives of evaluation, because it cannot be determined whether the connected XPath expression matches or not until all XPath expressions constituting the connected XPath expression are evaluated.
- 3. When processing for all of the XPath expressions unique to each XPath-set (specific XPath) has finished, the XPath set all of whose XPath expressions match may perfectly match the web page. Therefore, it is examined whether such an XPath set exists or not. 4. If such an XPath set exists, XPath expressions, which the XPath set shares with other XPath sets, are evaluated with respect to the XPath set.
- In contrast, if such an XPath set does not exist, an XPath set that perfectly matches the web page does not exist either. Therefore, the processing ends here without evaluating XPath expressions, which the XPath set shares with other XPath sets.
- If evaluation processing for an XPath set according to the embodiment is used for processing to decide an annotation to be added to a web page from a plurality of annotations, an annotation with an XPath set, all of whose XPath expressions are determined to match according to the above procedure, is decided as an annotation that can be added to the web page.
- The above-mentioned embodiment is not generate a data structure to efficiently evaluate (optimize) with respect to all functions of XPath expressions, only optimizing a part of the functions that are in frequent use.
- FIG. 29 is a diagram illustrating a structure of an XPath expression which can be optimized according to the embodiment.
- In the XPath expression shown in FIG. 29, ‘Ex’ refers to the x'th element. ‘Cx’ refers to a value indicating a position within the x'th sibling, if it is represented in a ‘predicate’, it is equal to [position( )=Cx]. In other words, an XPath expression can be separated into two parts. If the first half of the expression (
part 1 in FIG. 29) meets the following conditions, optimization according to the embodiment can be executed. - It shifts the tree up to n'th step toward its descendant, one by one.
- Axis is for child only, and other axes should not be used. In addition, designation of abbreviation for ‘descendant-or-self::node( )’, ‘//’ should not be used.
- For ‘predicate’, [position( )=number] ([number] for abbreviation) can only be used.
- No abbreviation for ‘predicate’ (/tag/).
- For the latter half (
part 2 in FIG. 29), any XPath expression may be appeared, though the part is not optimized. - In other words, the embodiment take advantage of a property that a structure shown above (structure which can be separated into
part 1 and part 2) belongs to many XPath expressions that specify a node of a tree in a long and irregular form like HTML documents describing a web page. - In the embodiment, as a condition for an XPath set to hold it has been described that all XPath expressions within an XPath set should hold. However, in stead of requiring for such exact matching, there is another requirement for selecting ‘just one that most matches’. For example, if an annotation to be added to a predetermined web page is selected in a system of adding an annotation to a web page, a situation where it cannot be transcoded may be avoided by calculating applicability of an XPath expression with a certain criteria, and selecting what is most appropriate. For this use, the embodiment can be enhanced to introduce an algorithm, which allows ambiguity in determining whether an XPath set holds or not.
- Specific procedure for this algorithm will now be described.
- 1. At the execution time of matching by an
evaluation execution part 1540, if a predetermined XPath expression does not match, a flag (UNMATCH flag) to indicate that it did not match with respect to the XPath expression is set. - 2. For an XPath expression that was not evaluated because the XPath expression was included in the same XPath set with an XPath that does not match, a flag (UNEVALUATED flag) to indicate that no evaluation was executed for the XPath expression is set.
- 3. Evaluate all XPath expressions which is set an UNEVALUATED flag, when it is evaluated for all XPath sets do not match. (However, XPath expressions, for which evaluation results have been known from their dependency or inclusion relations, should be excluded.) For XPath expressions that do not match, an UNMATCH flag is set.
- When an algorithm that allows ambiguity in determining whether an XPath set holds or not, without regard to an approach for evaluating applicability, processing up to this point is common. However, processing after this point is executed in different ways depending on evaluation approaches of applicability. An algorithm which selects ‘an XPath set including the fewest number of XPath expressions which is the most unmatched,’ and also ‘with the greatest applicability for XPath expressions to be defined with distance on a DOM tree’ will be exemplified here.
- 4. Select an XPath set with the fewest number of XPath expressions with an UNMATCH flag.
- 5. If a plurality of XPath sets, in which the number of XPath expressions with UNMATCH flags are same, exists, calculate applicability for all of XPath expressions included in each XPath set. For example, applicability A can be calculated in the following manner.
- AXPath=k1*P+k2*S−k3*L
- Each parameter will be as follows:
- k1, k2, k3: constant coefficient
- P: the number of steps taken to reach an existing node, when the parent sequence of the XPath expression in concern is followed. At least a ‘body’ node is common even if the worst case, this parameter is guaranteed to have a value.
- S: the distance of sibling sequence of the XPath expressions in concern. The distance is defined to 1 when (parent node)/tr[4] does not exist and (parent node)/tr[3] exists, while the distance is defined to 2 when (parent node)/tr[2] exists. When a sibling node does not exist, calculate a sibling node within a child node in node toward an existing parent node to be an objective of P. When a node to be an objective is originally a first node (/tag[1]), a default value is assigned to the value.
- L: a length of a tree, to which the XPath expression in concern specifies. When the distance is long, it is considered to be disadvantageous with a value such as P, so the distance is balanced out with negative coefficient.
- Applicability for each XPath expression is calculated with such calculations as stated above, and the total of finally obtained applicability for each XPath expression is made to be an applicability of an XPath set.
- AXPath set=ΣAXPath
- With selecting an XPath set with the finally obtained value ‘A’ being the least value, the most applicable XPath set can be selected.
- However, if such an enhancement is done, although the amount of calculation does not change in case that an XPath set holds, the amount of calculation may significantly increases in the case that no XPath set to hold exists. For this reason, the entire performance deteriorates in response to the percentage of input where holding XPath set does not exist. To avoid such a situation, it would be necessary to simplify an algorithm for calculating applicability and to maintain ‘ambiguity’ to make a rapid calculation possible.
- As shown above, in the first and the second embodiment (hereinafter referred to as the embodiments), a processing speed with respect to an XML document is improved by efficiently searching an evaluation result of a number of XPath expressions. For example, when a number of XPath expressions are included in a style sheet, a processing speed can be improved by incorporating the embodiments into an XSLT processor.
- With using an XPath to check whether an XML document has a certain part or not, news transmissions in a specified condition for each user or matching of contents with a user under a condition specified for each contents can be implemented by using an XML as a base. In this case, a large scale services could have not been implemented due to the increase in processing time in accordance with the increase in the number of XPath expressions. With the embodiments, such services can be implemented because the increase in processing time can be reduced.
- Furthermore, in a system that transcodes a web page (HTML document) over a network on the basis of a predetermined annotation, by using the embodiment at searching an applicable annotation to a web page to be transcoded (an annotation with an XPath set correctly specifying an element of the web page) among a number of annotation patterns previously provided, time required for evaluating an XPath set is shortened so that processing of searching for an annotation can be executed quickly.
- An XML document processing system according to the embodiment improves efficiency by taking advantage of a fact that, where a plurality of XPath expressions exist, they include redundant part such as something similar or overlapping, or what does not need an evaluation depending on the evaluation results of other XPath expressions due to the dependency. Therefore, if no such redundancy exists, efficiency will not improve.
- In such a case, however, a calculation of a location path is executed in the same way as conventional procedures by using an Xalan and the like as it is, because the calculation is executed by recursively searching for node set one after another. One comparison operator is executed in a table search with entry number one. The both ways can be executed in a negligible time, which is quicker than the case of reconfiguring a node set. Moreover, if a predicate is not a predetermined pattern, it is not an objective of optimization. A test for such a case may be done by calculating in the same way as conventional procedures by using an Xalan and the like as it is.
- Therefore, an evaluation of an XPath expression can be executed in efficiency virtually equal to the conventional ways even for a set of XPath expressions which has no redundant part and cannot be optimized. And, as the number of what can be optimized (XPath expressions similar to each other) increases, execution efficiency of processing will increase.
- As described above, the present invention has an effect of improving execution efficiency in evaluating a plurality of XPath expressions with respect to an XML document. This effect will be remarkable as redundant part increases among the plurality of XPath expressions.
Claims (34)
Applications Claiming Priority (4)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
JP2002053265 | 2002-02-28 | ||
JP2002-053265 | 2002-02-28 | ||
JP2002-267625 | 2002-09-13 | ||
JP2002267625A JP4039484B2 (en) | 2002-02-28 | 2002-09-13 | XPath evaluation method, XML document processing system and program using the same |
Publications (2)
Publication Number | Publication Date |
---|---|
US20030163285A1 true US20030163285A1 (en) | 2003-08-28 |
US7315981B2 US7315981B2 (en) | 2008-01-01 |
Family
ID=27759713
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/375,970 Expired - Fee Related US7315981B2 (en) | 2002-02-28 | 2003-02-28 | XPath evaluation method, XML document processing system and program using the same |
Country Status (2)
Country | Link |
---|---|
US (1) | US7315981B2 (en) |
JP (1) | JP4039484B2 (en) |
Cited By (71)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20040205577A1 (en) * | 2002-04-23 | 2004-10-14 | International Business Machines Corporation | Selectable methods for generating robust Xpath expressions |
US20050044486A1 (en) * | 2000-06-21 | 2005-02-24 | Microsoft Corporation | User interface for integrated spreadsheets and word processing tables |
US20050091587A1 (en) * | 2003-10-22 | 2005-04-28 | Conformative Systems, Inc. | Expression grouping and evaluation |
US20050091251A1 (en) * | 2003-10-22 | 2005-04-28 | Conformative Systems, Inc. | Applications of an appliance in a data center |
US20050091589A1 (en) * | 2003-10-22 | 2005-04-28 | Conformative Systems, Inc. | Hardware/software partition for high performance structured data transformation |
US20060005122A1 (en) * | 2004-07-02 | 2006-01-05 | Lemoine Eric T | System and method of XML query processing |
US20060085739A1 (en) * | 2004-10-14 | 2006-04-20 | Shingo Iwasaki | Document processing apparatus and control method thereof |
US20060095252A1 (en) * | 2003-04-30 | 2006-05-04 | International Business Machines Corporation | Content creation, graphical user interface system and display |
US20060098673A1 (en) * | 2004-11-09 | 2006-05-11 | Alcatel | Input queue packet switch architecture and queue service discipline |
US20060106758A1 (en) * | 2004-11-16 | 2006-05-18 | Chen Yao-Ching S | Streaming XPath algorithm for XPath value index key generation |
WO2006054959A1 (en) * | 2003-10-22 | 2006-05-26 | Conformative Systems, Inc. | Device for structured data transformation |
US20060253430A1 (en) * | 2005-05-09 | 2006-11-09 | International Business Machines Corporation | Method and apparatus for approximate projection of XML documents |
US20070089115A1 (en) * | 2005-10-05 | 2007-04-19 | Stern Aaron A | High performance navigator for parsing inputs of a message |
US20070130504A1 (en) * | 2005-12-06 | 2007-06-07 | International Business Machines Corporation | Reusable XPath validation expressions |
US20070174242A1 (en) * | 2006-01-20 | 2007-07-26 | Vanja Josifovski | Query evaluation using ancestor information |
US20070174241A1 (en) * | 2006-01-20 | 2007-07-26 | Beyer Kevin S | Match graphs for query evaluation |
US20070198479A1 (en) * | 2006-02-16 | 2007-08-23 | International Business Machines Corporation | Streaming XPath algorithm for XPath expressions with predicates |
US20080044021A1 (en) * | 2006-06-28 | 2008-02-21 | Fuji Xerox Co., Ltd. | Image forming apparatus, image forming method and, computer readable medium and computer signal |
US20080092034A1 (en) * | 2006-10-11 | 2008-04-17 | International Business Machines Corporation | Identifying and annotating shared hierarchical markup document trees |
US20080091649A1 (en) * | 2006-10-11 | 2008-04-17 | International Business Machines Corporation | Processing queries on hierarchical markup data using shared hierarchical markup trees |
US20080091651A1 (en) * | 2006-10-13 | 2008-04-17 | International Business Machines Corporation | Extensible markup language (XML) path (XPATH) debugging framework |
US20080154893A1 (en) * | 2006-12-20 | 2008-06-26 | Edison Lao Ting | Apparatus and method for skipping xml index scans with common ancestors of a previously failed predicate |
US20080165281A1 (en) * | 2007-01-05 | 2008-07-10 | Microsoft Corporation | Optimizing Execution of HD-DVD Timing Markup |
US20080244380A1 (en) * | 2007-03-27 | 2008-10-02 | Canon Kabushiki Kaisha | Method and device for evaluating an expression on elements of a structured document |
US20080263008A1 (en) * | 2007-04-23 | 2008-10-23 | International Business Machines Corporation | Apparatus and method for optimizing descendant path evaluation in xpath/xquery |
US20080320031A1 (en) * | 2007-06-19 | 2008-12-25 | C/O Canon Kabushiki Kaisha | Method and device for analyzing an expression to evaluate |
FR2917865A1 (en) * | 2007-06-19 | 2008-12-26 | Canon Kk | XML path language expression analyzing method for streaming environment, involves classifying sub-expressions of expression into subset comprising calculation sub-expressions, and linking navigation sub-expression to sub-expression |
US7480856B2 (en) * | 2002-05-02 | 2009-01-20 | Intel Corporation | System and method for transformation of XML documents using stylesheets |
US7516399B2 (en) * | 2004-09-30 | 2009-04-07 | Microsoft Corporation | Structured-document path-language expression methods and systems |
US20090187562A1 (en) * | 2008-01-22 | 2009-07-23 | Fujitsu Limited | Search method |
WO2009118664A1 (en) * | 2008-03-27 | 2009-10-01 | Canon Kabushiki Kaisha | Optimized methods and devices for the analysis, processing and evaluation of expressions of the xpath type on data of the binary xml type |
US20090259641A1 (en) * | 2008-04-10 | 2009-10-15 | International Business Machines Corporation | Optimization of extensible markup language path language (xpath) expressions in a database management system configured to accept extensible markup language (xml) queries |
US20090307186A1 (en) * | 2008-06-06 | 2009-12-10 | Hitachi, Ltd. | Method and Apparatus for Database Management and Program |
US7676843B1 (en) | 2004-05-27 | 2010-03-09 | Microsoft Corporation | Executing applications at appropriate trust levels |
US7689929B2 (en) | 2000-06-21 | 2010-03-30 | Microsoft Corporation | Methods and systems of providing information to computer users |
US7692636B2 (en) | 2004-09-30 | 2010-04-06 | Microsoft Corporation | Systems and methods for handwriting to a screen |
US7703006B2 (en) | 2005-06-02 | 2010-04-20 | Lsi Corporation | System and method of accelerating document processing |
US7712048B2 (en) | 2000-06-21 | 2010-05-04 | Microsoft Corporation | Task-sensitive methods and systems for displaying command sets |
US7712022B2 (en) | 2004-11-15 | 2010-05-04 | Microsoft Corporation | Mutually exclusive options in electronic forms |
US7716210B2 (en) | 2006-12-20 | 2010-05-11 | International Business Machines Corporation | Method and apparatus for XML query evaluation using early-outs and multiple passes |
US7721190B2 (en) | 2004-11-16 | 2010-05-18 | Microsoft Corporation | Methods and systems for server side form processing |
US7725834B2 (en) | 2005-03-04 | 2010-05-25 | Microsoft Corporation | Designer-created aspect for an electronic form template |
US7743063B2 (en) | 2000-06-21 | 2010-06-22 | Microsoft Corporation | Methods and systems for delivering software via a network |
US7818677B2 (en) | 2000-06-21 | 2010-10-19 | Microsoft Corporation | Single window navigation methods and systems |
US20100332451A1 (en) * | 2006-03-31 | 2010-12-30 | Vosshall Peter S | System and method for providing high availability data |
US7865477B2 (en) | 2003-03-28 | 2011-01-04 | Microsoft Corporation | System and method for real-time validation of structured data files |
US7882089B1 (en) * | 2005-07-13 | 2011-02-01 | Adobe Systems Incorporated | Caching database information |
US7899817B2 (en) | 2005-10-05 | 2011-03-01 | Microsoft Corporation | Safe mode for inverse query evaluations |
US7900134B2 (en) | 2000-06-21 | 2011-03-01 | Microsoft Corporation | Authoring arbitrary XML documents using DHTML and XSLT |
US7904801B2 (en) | 2004-12-15 | 2011-03-08 | Microsoft Corporation | Recursive sections in electronic forms |
US7913159B2 (en) | 2003-03-28 | 2011-03-22 | Microsoft Corporation | System and method for real-time validation of structured data files |
US20110078186A1 (en) * | 2009-09-29 | 2011-03-31 | International Business Machines Corporation | Xpath evaluation in an xml repository |
US7925621B2 (en) | 2003-03-24 | 2011-04-12 | Microsoft Corporation | Installing a solution |
US20110087698A1 (en) * | 2008-06-18 | 2011-04-14 | Keiichi Iguchi | Search expression creating system, search expression creating method, search expression creating program, and recording medium |
US7937651B2 (en) | 2005-01-14 | 2011-05-03 | Microsoft Corporation | Structural editing operations for network forms |
US7971139B2 (en) | 2003-08-06 | 2011-06-28 | Microsoft Corporation | Correlation, association, or correspondence of electronic forms |
US7979856B2 (en) | 2000-06-21 | 2011-07-12 | Microsoft Corporation | Network-based software extensions |
US20110184920A1 (en) * | 2006-03-31 | 2011-07-28 | Vosshall Peter S | System and method for providing high availability data |
US8001459B2 (en) | 2005-12-05 | 2011-08-16 | Microsoft Corporation | Enabling electronic documents for limited-capability computing devices |
US8010515B2 (en) | 2005-04-15 | 2011-08-30 | Microsoft Corporation | Query to an electronic form |
US8078960B2 (en) | 2003-06-30 | 2011-12-13 | Microsoft Corporation | Rendering an HTML electronic form by applying XSLT to XML using a solution |
US8117552B2 (en) | 2003-03-24 | 2012-02-14 | Microsoft Corporation | Incrementally designing electronic forms and hierarchical schemas |
US20120101721A1 (en) * | 2010-10-21 | 2012-04-26 | Telenav, Inc. | Navigation system with xpath repetition based field alignment mechanism and method of operation thereof |
US8200975B2 (en) | 2005-06-29 | 2012-06-12 | Microsoft Corporation | Digital signatures for network forms |
US8336021B2 (en) * | 2008-12-15 | 2012-12-18 | Microsoft Corporation | Managing set membership |
US20130103693A1 (en) * | 2010-05-14 | 2013-04-25 | Nec Corporation | Information search device, information search method, computer program, and data structure |
US20130132817A1 (en) * | 2010-08-03 | 2013-05-23 | Adobe Systems Incorporated | Portable page template |
US8819072B1 (en) | 2004-02-02 | 2014-08-26 | Microsoft Corporation | Promoting data from structured data files |
US20140258265A1 (en) * | 2013-03-11 | 2014-09-11 | International Business Machines Corporation | Persisting and retrieving arbitrary slices of nested structures using a column-oriented data store |
US8892993B2 (en) | 2003-08-01 | 2014-11-18 | Microsoft Corporation | Translation file |
US8918729B2 (en) | 2003-03-24 | 2014-12-23 | Microsoft Corporation | Designing electronic forms |
Families Citing this family (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JP3880504B2 (en) * | 2002-10-28 | 2007-02-14 | インターナショナル・ビジネス・マシーンズ・コーポレーション | Structured / hierarchical content processing apparatus, structured / hierarchical content processing method, and program |
US7496837B1 (en) * | 2004-04-29 | 2009-02-24 | Microsoft Corporation | Structural editing with schema awareness |
JP4523561B2 (en) * | 2006-03-17 | 2010-08-11 | 日本電信電話株式会社 | XPath processing equipment |
US7681135B2 (en) * | 2006-08-10 | 2010-03-16 | Kabushiki Kaisha Toshiba | System and method for generating a composite source user interface |
US7979793B2 (en) | 2007-09-28 | 2011-07-12 | Microsoft Corporation | Graphical creation of a document conversion template |
JP5333230B2 (en) * | 2007-10-31 | 2013-11-06 | 日本電気株式会社 | Candidate path table construction device, candidate path table construction method, candidate path table construction program |
FR2925721B1 (en) * | 2007-12-21 | 2016-07-01 | Canon Kk | METHOD AND DEVICE FOR COMPILING AND EVALUATING A PLURALITY OF EXPRESSIONS TO BE EVALUATED ON A STRUCTURED DOCUMENT |
FR2933793B1 (en) * | 2008-07-11 | 2013-07-05 | Canon Kk | METHODS OF ENCODING AND DECODING, BY REFERENCING, VALUES IN A STRUCTURED DOCUMENT, AND ASSOCIATED SYSTEMS. |
US9298761B2 (en) * | 2009-04-30 | 2016-03-29 | Hewlett Packard Enterprise Development Lp | Adaptive merging in database indexes |
US11175914B2 (en) * | 2019-06-28 | 2021-11-16 | Aras Corporation | Calculation engine for performing calculations based on dependencies in a self-describing data system |
Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20040010752A1 (en) * | 2002-07-09 | 2004-01-15 | Lucent Technologies Inc. | System and method for filtering XML documents with XPath expressions |
US20040010754A1 (en) * | 2002-05-02 | 2004-01-15 | Jones Kevin J. | System and method for transformation of XML documents using stylesheets |
US20040060007A1 (en) * | 2002-06-19 | 2004-03-25 | Georg Gottlob | Efficient processing of XPath queries |
US7096224B2 (en) * | 2001-09-28 | 2006-08-22 | Oracle International Corporation | Mechanism for mapping XML schemas to object-relational database systems |
-
2002
- 2002-09-13 JP JP2002267625A patent/JP4039484B2/en not_active Expired - Fee Related
-
2003
- 2003-02-28 US US10/375,970 patent/US7315981B2/en not_active Expired - Fee Related
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7096224B2 (en) * | 2001-09-28 | 2006-08-22 | Oracle International Corporation | Mechanism for mapping XML schemas to object-relational database systems |
US20040010754A1 (en) * | 2002-05-02 | 2004-01-15 | Jones Kevin J. | System and method for transformation of XML documents using stylesheets |
US20040060007A1 (en) * | 2002-06-19 | 2004-03-25 | Georg Gottlob | Efficient processing of XPath queries |
US20040010752A1 (en) * | 2002-07-09 | 2004-01-15 | Lucent Technologies Inc. | System and method for filtering XML documents with XPath expressions |
Cited By (131)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7779027B2 (en) | 2000-06-21 | 2010-08-17 | Microsoft Corporation | Methods, systems, architectures and data structures for delivering software via a network |
US20050044486A1 (en) * | 2000-06-21 | 2005-02-24 | Microsoft Corporation | User interface for integrated spreadsheets and word processing tables |
US7743063B2 (en) | 2000-06-21 | 2010-06-22 | Microsoft Corporation | Methods and systems for delivering software via a network |
US7712048B2 (en) | 2000-06-21 | 2010-05-04 | Microsoft Corporation | Task-sensitive methods and systems for displaying command sets |
US7689929B2 (en) | 2000-06-21 | 2010-03-30 | Microsoft Corporation | Methods and systems of providing information to computer users |
US7673227B2 (en) | 2000-06-21 | 2010-03-02 | Microsoft Corporation | User interface for integrated spreadsheets and word processing tables |
US9507610B2 (en) | 2000-06-21 | 2016-11-29 | Microsoft Technology Licensing, Llc | Task-sensitive methods and systems for displaying command sets |
US7818677B2 (en) | 2000-06-21 | 2010-10-19 | Microsoft Corporation | Single window navigation methods and systems |
US8074217B2 (en) | 2000-06-21 | 2011-12-06 | Microsoft Corporation | Methods and systems for delivering software |
US7979856B2 (en) | 2000-06-21 | 2011-07-12 | Microsoft Corporation | Network-based software extensions |
US7900134B2 (en) | 2000-06-21 | 2011-03-01 | Microsoft Corporation | Authoring arbitrary XML documents using DHTML and XSLT |
US7213200B2 (en) * | 2002-04-23 | 2007-05-01 | International Business Machines Corporation | Selectable methods for generating robust XPath expressions |
US20040205577A1 (en) * | 2002-04-23 | 2004-10-14 | International Business Machines Corporation | Selectable methods for generating robust Xpath expressions |
US7480856B2 (en) * | 2002-05-02 | 2009-01-20 | Intel Corporation | System and method for transformation of XML documents using stylesheets |
US7925621B2 (en) | 2003-03-24 | 2011-04-12 | Microsoft Corporation | Installing a solution |
US8918729B2 (en) | 2003-03-24 | 2014-12-23 | Microsoft Corporation | Designing electronic forms |
US8117552B2 (en) | 2003-03-24 | 2012-02-14 | Microsoft Corporation | Incrementally designing electronic forms and hierarchical schemas |
US7913159B2 (en) | 2003-03-28 | 2011-03-22 | Microsoft Corporation | System and method for real-time validation of structured data files |
US9229917B2 (en) | 2003-03-28 | 2016-01-05 | Microsoft Technology Licensing, Llc | Electronic form user interfaces |
US7865477B2 (en) | 2003-03-28 | 2011-01-04 | Microsoft Corporation | System and method for real-time validation of structured data files |
US8244541B2 (en) * | 2003-04-30 | 2012-08-14 | Nuance Communications, Inc. | Content creation system, content creation method, computer executable program for executing the same content creation method, computer readable storage medium having stored the same program, graphical user interface system and display control method |
US7877260B2 (en) * | 2003-04-30 | 2011-01-25 | Nuance Communications, Inc. | Content creation, graphical user interface system and display |
US20060095252A1 (en) * | 2003-04-30 | 2006-05-04 | International Business Machines Corporation | Content creation, graphical user interface system and display |
US20080276163A1 (en) * | 2003-04-30 | 2008-11-06 | Hironobu Takagi | Content creation system, content creation method, computer executable program for executing the same content creation method, computer readable storage medium having stored the same program, graphical user interface system and display control method |
US8078960B2 (en) | 2003-06-30 | 2011-12-13 | Microsoft Corporation | Rendering an HTML electronic form by applying XSLT to XML using a solution |
US9239821B2 (en) | 2003-08-01 | 2016-01-19 | Microsoft Technology Licensing, Llc | Translation file |
US8892993B2 (en) | 2003-08-01 | 2014-11-18 | Microsoft Corporation | Translation file |
US9268760B2 (en) | 2003-08-06 | 2016-02-23 | Microsoft Technology Licensing, Llc | Correlation, association, or correspondence of electronic forms |
US8429522B2 (en) | 2003-08-06 | 2013-04-23 | Microsoft Corporation | Correlation, association, or correspondence of electronic forms |
US7971139B2 (en) | 2003-08-06 | 2011-06-28 | Microsoft Corporation | Correlation, association, or correspondence of electronic forms |
JP2007510204A (en) * | 2003-10-22 | 2007-04-19 | インテル コーポレイション | Hardware / software partition for high performance structured data conversion |
US7437666B2 (en) | 2003-10-22 | 2008-10-14 | Intel Corporation | Expression grouping and evaluation |
US7409400B2 (en) | 2003-10-22 | 2008-08-05 | Intel Corporation | Applications of an appliance in a data center |
WO2006054959A1 (en) * | 2003-10-22 | 2006-05-26 | Conformative Systems, Inc. | Device for structured data transformation |
JP4829794B2 (en) * | 2003-10-22 | 2011-12-07 | インテル コーポレイション | Expression grouping and evaluation |
US20050091587A1 (en) * | 2003-10-22 | 2005-04-28 | Conformative Systems, Inc. | Expression grouping and evaluation |
US7458022B2 (en) | 2003-10-22 | 2008-11-25 | Intel Corporation | Hardware/software partition for high performance structured data transformation |
US20050091251A1 (en) * | 2003-10-22 | 2005-04-28 | Conformative Systems, Inc. | Applications of an appliance in a data center |
US7328403B2 (en) | 2003-10-22 | 2008-02-05 | Intel Corporation | Device for structured data transformation |
JP2007528052A (en) * | 2003-10-22 | 2007-10-04 | コンフォーマティブ システムズ， インコーポレイテッド | Expression grouping and evaluation |
KR101110988B1 (en) * | 2003-10-22 | 2012-03-08 | 인텔 코오퍼레이션 | Device for structured data transformation |
US20050091589A1 (en) * | 2003-10-22 | 2005-04-28 | Conformative Systems, Inc. | Hardware/software partition for high performance structured data transformation |
WO2005041072A1 (en) * | 2003-10-22 | 2005-05-06 | Conformative Systems, Inc. | Expression grouping and evaluation |
WO2005043412A1 (en) * | 2003-10-22 | 2005-05-12 | Conformative Systems, Inc. | Hardware/software partition for high performance structured data transformation |
KR101129083B1 (en) * | 2003-10-22 | 2012-03-26 | 인텔 코오퍼레이션 | Expression grouping and evaluation |
KR101204128B1 (en) * | 2003-10-22 | 2012-11-22 | 인텔 코오퍼레이션 | Hardware/software partition for high performance structured data transformation |
US8819072B1 (en) | 2004-02-02 | 2014-08-26 | Microsoft Corporation | Promoting data from structured data files |
US7676843B1 (en) | 2004-05-27 | 2010-03-09 | Microsoft Corporation | Executing applications at appropriate trust levels |
US7774620B1 (en) | 2004-05-27 | 2010-08-10 | Microsoft Corporation | Executing applications at appropriate trust levels |
US20060005122A1 (en) * | 2004-07-02 | 2006-01-05 | Lemoine Eric T | System and method of XML query processing |
US20090177960A1 (en) * | 2004-07-02 | 2009-07-09 | Tarari. Inc. | System and method of xml query processing |
US7512592B2 (en) | 2004-07-02 | 2009-03-31 | Tarari, Inc. | System and method of XML query processing |
US7516399B2 (en) * | 2004-09-30 | 2009-04-07 | Microsoft Corporation | Structured-document path-language expression methods and systems |
US7692636B2 (en) | 2004-09-30 | 2010-04-06 | Microsoft Corporation | Systems and methods for handwriting to a screen |
US7661063B2 (en) * | 2004-10-14 | 2010-02-09 | Canon Kabushiki Kaisha | Document processing apparatus and control method thereof |
US20060085739A1 (en) * | 2004-10-14 | 2006-04-20 | Shingo Iwasaki | Document processing apparatus and control method thereof |
US20060098673A1 (en) * | 2004-11-09 | 2006-05-11 | Alcatel | Input queue packet switch architecture and queue service discipline |
US7712022B2 (en) | 2004-11-15 | 2010-05-04 | Microsoft Corporation | Mutually exclusive options in electronic forms |
US20060106758A1 (en) * | 2004-11-16 | 2006-05-18 | Chen Yao-Ching S | Streaming XPath algorithm for XPath value index key generation |
US7346609B2 (en) * | 2004-11-16 | 2008-03-18 | International Business Machines Corporation | Streaming XPath algorithm for XPath value index key generation |
US7721190B2 (en) | 2004-11-16 | 2010-05-18 | Microsoft Corporation | Methods and systems for server side form processing |
US7904801B2 (en) | 2004-12-15 | 2011-03-08 | Microsoft Corporation | Recursive sections in electronic forms |
US7937651B2 (en) | 2005-01-14 | 2011-05-03 | Microsoft Corporation | Structural editing operations for network forms |
US7725834B2 (en) | 2005-03-04 | 2010-05-25 | Microsoft Corporation | Designer-created aspect for an electronic form template |
US8010515B2 (en) | 2005-04-15 | 2011-08-30 | Microsoft Corporation | Query to an electronic form |
US7499931B2 (en) * | 2005-05-09 | 2009-03-03 | International Business Machines Corporation | Method and apparatus for approximate projection of XML documents |
US20060253430A1 (en) * | 2005-05-09 | 2006-11-09 | International Business Machines Corporation | Method and apparatus for approximate projection of XML documents |
US7703006B2 (en) | 2005-06-02 | 2010-04-20 | Lsi Corporation | System and method of accelerating document processing |
US8200975B2 (en) | 2005-06-29 | 2012-06-12 | Microsoft Corporation | Digital signatures for network forms |
US7882089B1 (en) * | 2005-07-13 | 2011-02-01 | Adobe Systems Incorporated | Caching database information |
US7548926B2 (en) | 2005-10-05 | 2009-06-16 | Microsoft Corporation | High performance navigator for parsing inputs of a message |
US20070089115A1 (en) * | 2005-10-05 | 2007-04-19 | Stern Aaron A | High performance navigator for parsing inputs of a message |
US7899817B2 (en) | 2005-10-05 | 2011-03-01 | Microsoft Corporation | Safe mode for inverse query evaluations |
US9210234B2 (en) | 2005-12-05 | 2015-12-08 | Microsoft Technology Licensing, Llc | Enabling electronic documents for limited-capability computing devices |
US8001459B2 (en) | 2005-12-05 | 2011-08-16 | Microsoft Corporation | Enabling electronic documents for limited-capability computing devices |
US20070130504A1 (en) * | 2005-12-06 | 2007-06-07 | International Business Machines Corporation | Reusable XPath validation expressions |
US7761786B2 (en) * | 2005-12-06 | 2010-07-20 | International Business Machines Corporation | Reusable XPath validation expressions |
US7979423B2 (en) * | 2006-01-20 | 2011-07-12 | International Business Machines Corporation | Query evaluation using ancestor information |
US20070174242A1 (en) * | 2006-01-20 | 2007-07-26 | Vanja Josifovski | Query evaluation using ancestor information |
US8688721B2 (en) | 2006-01-20 | 2014-04-01 | International Business Machines Corporation | Query evaluation using ancestor information |
US9659001B2 (en) | 2006-01-20 | 2017-05-23 | International Business Machines Corporation | Query evaluation using ancestor information |
US20090287700A1 (en) * | 2006-01-20 | 2009-11-19 | International Business Machines Corporation | Query evaluation using ancestor information |
US20110225144A1 (en) * | 2006-01-20 | 2011-09-15 | International Business Machines Corporation | Query evaluation using ancestor information |
US20070174241A1 (en) * | 2006-01-20 | 2007-07-26 | Beyer Kevin S | Match graphs for query evaluation |
US7596548B2 (en) | 2006-01-20 | 2009-09-29 | International Business Machines Corporation | Query evaluation using ancestor information |
US9087139B2 (en) | 2006-01-20 | 2015-07-21 | International Business Machines Corporation | Query evaluation using ancestor information |
US20080222176A1 (en) * | 2006-02-16 | 2008-09-11 | International Business Machines Corporation | Streaming xpath algorithm for xpath expressions with predicates |
US20070198479A1 (en) * | 2006-02-16 | 2007-08-23 | International Business Machines Corporation | Streaming XPath algorithm for XPath expressions with predicates |
US20100332451A1 (en) * | 2006-03-31 | 2010-12-30 | Vosshall Peter S | System and method for providing high availability data |
US11288002B2 (en) | 2006-03-31 | 2022-03-29 | Amazon Technologies, Inc. | System and method for providing high availability data |
US20110184920A1 (en) * | 2006-03-31 | 2011-07-28 | Vosshall Peter S | System and method for providing high availability data |
US8706688B2 (en) | 2006-03-31 | 2014-04-22 | Amazon Technologies, Inc. | System and method for providing high availability data |
US9223841B2 (en) * | 2006-03-31 | 2015-12-29 | Amazon Technologies, Inc. | System and method for providing high availability data |
US20080044021A1 (en) * | 2006-06-28 | 2008-02-21 | Fuji Xerox Co., Ltd. | Image forming apparatus, image forming method and, computer readable medium and computer signal |
US8108765B2 (en) * | 2006-10-11 | 2012-01-31 | International Business Machines Corporation | Identifying and annotating shared hierarchical markup document trees |
US20080092034A1 (en) * | 2006-10-11 | 2008-04-17 | International Business Machines Corporation | Identifying and annotating shared hierarchical markup document trees |
US20080091649A1 (en) * | 2006-10-11 | 2008-04-17 | International Business Machines Corporation | Processing queries on hierarchical markup data using shared hierarchical markup trees |
US8635242B2 (en) * | 2006-10-11 | 2014-01-21 | International Business Machines Corporation | Processing queries on hierarchical markup data using shared hierarchical markup trees |
US20080091651A1 (en) * | 2006-10-13 | 2008-04-17 | International Business Machines Corporation | Extensible markup language (XML) path (XPATH) debugging framework |
US8321845B2 (en) * | 2006-10-13 | 2012-11-27 | International Business Machines Corporation | Extensible markup language (XML) path (XPATH) debugging framework |
US10394685B2 (en) * | 2006-10-13 | 2019-08-27 | International Business Machines Corporation | Extensible markup language (XML) path (XPATH) debugging framework |
US20130014003A1 (en) * | 2006-10-13 | 2013-01-10 | International Business Machines Corporation | Extensible markup language (xml) path (xpath) debugging framework |
US7716210B2 (en) | 2006-12-20 | 2010-05-11 | International Business Machines Corporation | Method and apparatus for XML query evaluation using early-outs and multiple passes |
US20080154893A1 (en) * | 2006-12-20 | 2008-06-26 | Edison Lao Ting | Apparatus and method for skipping xml index scans with common ancestors of a previously failed predicate |
US7552119B2 (en) | 2006-12-20 | 2009-06-23 | International Business Machines Corporation | Apparatus and method for skipping XML index scans with common ancestors of a previously failed predicate |
US20080165281A1 (en) * | 2007-01-05 | 2008-07-10 | Microsoft Corporation | Optimizing Execution of HD-DVD Timing Markup |
EP2100303A4 (en) * | 2007-01-05 | 2013-01-23 | Microsoft Corp | Optimizing execution of hd-dvd timing markup |
EP2100303A1 (en) * | 2007-01-05 | 2009-09-16 | Microsoft Corporation | Optimizing execution of hd-dvd timing markup |
US20080244380A1 (en) * | 2007-03-27 | 2008-10-02 | Canon Kabushiki Kaisha | Method and device for evaluating an expression on elements of a structured document |
US8117182B2 (en) * | 2007-04-23 | 2012-02-14 | International Business Machines Corporation | Apparatus and method for optimizing descendant path evaluation in xpath/xquery |
US20080263008A1 (en) * | 2007-04-23 | 2008-10-23 | International Business Machines Corporation | Apparatus and method for optimizing descendant path evaluation in xpath/xquery |
US20080320031A1 (en) * | 2007-06-19 | 2008-12-25 | C/O Canon Kabushiki Kaisha | Method and device for analyzing an expression to evaluate |
FR2917865A1 (en) * | 2007-06-19 | 2008-12-26 | Canon Kk | XML path language expression analyzing method for streaming environment, involves classifying sub-expressions of expression into subset comprising calculation sub-expressions, and linking navigation sub-expression to sub-expression |
US20090187562A1 (en) * | 2008-01-22 | 2009-07-23 | Fujitsu Limited | Search method |
WO2009118664A1 (en) * | 2008-03-27 | 2009-10-01 | Canon Kabushiki Kaisha | Optimized methods and devices for the analysis, processing and evaluation of expressions of the xpath type on data of the binary xml type |
US8850309B2 (en) | 2008-03-27 | 2014-09-30 | Canon Kabushiki Kaisha | Optimized methods and devices for the analysis, processing and evaluation of expressions of the XPath type on data of the binary XML type |
US20090259641A1 (en) * | 2008-04-10 | 2009-10-15 | International Business Machines Corporation | Optimization of extensible markup language path language (xpath) expressions in a database management system configured to accept extensible markup language (xml) queries |
US7865502B2 (en) | 2008-04-10 | 2011-01-04 | International Business Machines Corporation | Optimization of extensible markup language path language (XPATH) expressions in a database management system configured to accept extensible markup language (XML) queries |
US20090307186A1 (en) * | 2008-06-06 | 2009-12-10 | Hitachi, Ltd. | Method and Apparatus for Database Management and Program |
US20110087698A1 (en) * | 2008-06-18 | 2011-04-14 | Keiichi Iguchi | Search expression creating system, search expression creating method, search expression creating program, and recording medium |
US8336021B2 (en) * | 2008-12-15 | 2012-12-18 | Microsoft Corporation | Managing set membership |
US9135367B2 (en) * | 2009-09-29 | 2015-09-15 | International Business Machines Corporation | XPath evaluation in an XML repository |
US9529934B2 (en) | 2009-09-29 | 2016-12-27 | International Business Machines Corporation | XPath evaluation in an XML repository |
US20110078186A1 (en) * | 2009-09-29 | 2011-03-31 | International Business Machines Corporation | Xpath evaluation in an xml repository |
US9141727B2 (en) * | 2010-05-14 | 2015-09-22 | Nec Corporation | Information search device, information search method, computer program, and data structure |
US20130103693A1 (en) * | 2010-05-14 | 2013-04-25 | Nec Corporation | Information search device, information search method, computer program, and data structure |
US9658997B2 (en) * | 2010-08-03 | 2017-05-23 | Adobe Systems Incorporated | Portable page template |
US20130132817A1 (en) * | 2010-08-03 | 2013-05-23 | Adobe Systems Incorporated | Portable page template |
US20120101721A1 (en) * | 2010-10-21 | 2012-04-26 | Telenav, Inc. | Navigation system with xpath repetition based field alignment mechanism and method of operation thereof |
US9195711B2 (en) * | 2013-03-11 | 2015-11-24 | International Business Machines Corporation | Persisting and retrieving arbitrary slices of nested structures using a column-oriented data store |
US20140258265A1 (en) * | 2013-03-11 | 2014-09-11 | International Business Machines Corporation | Persisting and retrieving arbitrary slices of nested structures using a column-oriented data store |
Also Published As
Publication number | Publication date |
---|---|
JP4039484B2 (en) | 2008-01-30 |
US7315981B2 (en) | 2008-01-01 |
JP2003323332A (en) | 2003-11-14 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US7315981B2 (en) | XPath evaluation method, XML document processing system and program using the same | |
JP5746286B2 (en) | High-performance data metatagging and data indexing method and system using a coprocessor | |
JP3982623B2 (en) | Information processing apparatus, database search system, and program | |
US8892599B2 (en) | Apparatus and method for securing preliminary information about database fragments for utilization in mapreduce processing | |
US8751484B2 (en) | Systems and methods of identifying chunks within multiple documents | |
US20170147566A1 (en) | Converting data into natural language form | |
US9069855B2 (en) | Modifying a hierarchical data structure according to a pseudo-rendering of a structured document by annotating and merging nodes | |
US8326819B2 (en) | Method and system for high performance data metatagging and data indexing using coprocessors | |
US7444325B2 (en) | Method and system for information extraction | |
US8856183B2 (en) | Database access using partitioned data areas | |
JP3835193B2 (en) | Digital content creation system and digital content creation program | |
US8001140B2 (en) | Systems and methods of refining a search query based on user-specified search keywords | |
US20110191325A1 (en) | Systems and Methods of Displaying and Re-Using Document Chunks in a Document Development Application | |
US20110119262A1 (en) | Method and System for Grouping Chunks Extracted from A Document, Highlighting the Location of A Document Chunk Within A Document, and Ranking Hyperlinks Within A Document | |
US20070150473A1 (en) | Search By Document Type And Relevance | |
JP2002259429A (en) | Computer-based matching text search system and method | |
US9129036B2 (en) | Systems and methods of identifying chunks within inter-related documents | |
US8126880B2 (en) | Systems and methods of adaptively screening matching chunks within documents | |
US8549009B2 (en) | XML data processing system, data processing method and XML data processing control program used for the system | |
US6772395B1 (en) | Self-modifying data flow execution architecture | |
US11507639B1 (en) | Methods for identifying recurring web site accessibility issues and devices thereof | |
JP3937741B2 (en) | Document standardization | |
JPH11259524A (en) | Information retrieval system, information processing method in information retrieval system and record medium | |
Sakr | Algebra‐based XQuery cardinality estimation | |
WO2021229773A1 (en) | Inquiry subject aggregation device, inquiry subject aggregation method, and program |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:NAKAMURA, HIROAKI;TAKAGI, HIRONOBU;YURIYAMA, MADOKA;REEL/FRAME:013833/0163Effective date: 20030121 |
|
REMI | Maintenance fee reminder mailed | ||
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026894/0001Effective date: 20110817 |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
SULP | Surcharge for late payment | ||
REMI | Maintenance fee reminder mailed | ||
LAPS | Lapse for failure to pay maintenance fees | ||
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20160101 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044142/0357Effective date: 20170929 |