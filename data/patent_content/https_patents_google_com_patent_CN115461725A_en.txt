CN115461725A - Rendering debugger - Google Patents
Rendering debugger Download PDFInfo
- Publication number
- CN115461725A CN115461725A CN202080100213.5A CN202080100213A CN115461725A CN 115461725 A CN115461725 A CN 115461725A CN 202080100213 A CN202080100213 A CN 202080100213A CN 115461725 A CN115461725 A CN 115461725A
- Authority
- CN
- China
- Prior art keywords
- digital component
- content
- application
- requirements
- request
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/3668—Software testing
- G06F11/3672—Test management
- G06F11/3688—Test management for test execution, e.g. scheduling of test suites
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/32—Monitoring with visual or acoustical indication of the functioning of the machine
- G06F11/321—Display for diagnostics, e.g. diagnostic result display, self-test user interface
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/3664—Environments for testing or debugging software
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/3668—Software testing
- G06F11/3672—Test management
- G06F11/3692—Test management for test results analysis
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/3668—Software testing
- G06F11/3696—Methods or tools to render software testable
Abstract
Methods, systems, and apparatus, including computer programs encoded on a computer storage medium, for debugging applications are provided. In some aspects, a method comprises: a rendering of a digital component by an application executing on a device is detected. A first signal indicative of visible attributes of content assets of the test digital component and a second signal indicative of hierarchical associations between the content assets as rendered are obtained. A verification process is invoked that compares the first signal and the second signal to the set of requirements. Determining that one or more requirements are not satisfied by the first signal or the second signal. Responsive to determining that the one or more requirements are not met, a non-conforming overlay is provided within the application indicating that the digital component fails to conform to the one or more requirements.
Description
Background
This specification relates to data processing and debugging applications.
The internet facilitates the exchange of information between users worldwide. This exchange of information enables distribution of content to various users. In some cases, content from multiple different providers may be integrated into a single electronic document to create a composite document. For example, the portion of content included in the electronic document may be selected (or specified) by the issuer of the electronic document. The digital components (e.g., different portions of the content) may be provided by a third party (e.g., an entity that is not the issuer of the electronic document) and integrated into the electronic document along with the content portions selected by the issuer.
Disclosure of Invention
In general, one innovative aspect of the subject matter described in this specification can be embodied in systems that include: detecting, by a device, a rendering of a digital component by an application executing on the device; obtaining, from an application, a set of signals specifying rendering attributes of digital components, the set of signals including at least a first signal indicative of visible attributes of content assets included in a test digital component and a second signal indicative of hierarchical associations between rendered content assets; invoking, by the device, a validation process that compares the first signal and the second signal to a set of requirements that specify that the digital component conforms to the attribute of the digital component has been correctly rendered; determining that one or more requirements are not satisfied by the first signal or the second signal; and responsive to determining that the one or more requirements are not met, providing, by the device, a non-conforming overlay that provides an alert within the application indicating that the digital component failed to meet the one or more requirements. Other embodiments of this aspect include corresponding methods, apparatus, and computer programs, encoded on computer storage devices, configured to perform the actions of the methods. These and other embodiments may each optionally include one or more of the following features.
The method can comprise the following steps: receiving, by a server, a registration message identifying a device as a test device for an application; receiving, from a device, a request to provide content to an application; based on the device being identified as a test device, selecting, by the server, a test object that includes content assets needed to render the digital component; and based on the device being identified as a test device, providing, by the server, the test object to the device in response to the request for content.
The method can comprise the following steps: receiving, by a server, a request to provide content to an application; determining, by the server, that the request for content includes an identifier corresponding to the testing environment; in response to determining that the request for content includes an identifier corresponding to the testing environment, selecting, by the server, a test object that includes content assets required to render the digital component; and providing, by the server, the test object to the device in response to the request for the content.
Invoking, by the device, a verification process that compares the first signal and the second signal to the set of requirements may include: the request is to perform an authentication process by a script instantiated at the time the application is launched.
The method can comprise the following steps: detecting interaction with the overlay; and in response to detecting interaction with the overlay, providing additional detail regarding how the digital component failed to meet the one or more requirements.
The method can comprise the following steps: obtaining, by a device, a document from a specified location; and populating the document with information indicating that the digital component fails to meet the one or more requirements.
Obtaining a set of signals specifying rendering attributes for the digital component may include: obtaining a set of signals indicative of a set of content assets included in a digital component; and determining that the one or more requirements are not satisfied comprises: determine that the desired assets are not included or are not properly registered with the software development kit, (ii) determine that a particular view including the content assets is less than a specified size, or (iii) determine that one or more of the content assets are located outside the boundaries of the particular view.
Particular embodiments of the subject matter described in this specification can be implemented to realize one or more of the following advantages. For example, the techniques discussed in this document enable identification of errors in the rendering code of an application before the application is published to a user, thereby reducing wasted system resources. More specifically, for applications responsible for properly building and presenting digital components from a collection of content assets provided by a third party, conventional systems fail to enable application developers to ensure that the rendering code of the application has been properly implemented prior to publishing the application to a user. Thus, application developers have historically learned errors in their rendering code only after the rendering code wrongly renders (or fails to render) the digital component to the user. This creates a situation where application developers must track errors, correct the rendered code, and then provide updated versions of the application for download by the user. However, due to the user's control over the application updates, the application developer cannot ensure that the user will update to a new version of the application, so that rendering errors may continue. As discussed in more detail below, one such rendering error is an error that can cause a portion of the content to obscure other content that the user should see. In this case, rendering errors may result in inefficient and less effective application, as only the portion of the content that the user would otherwise be able to visually perceive can be perceived. These rendering errors also result in inefficiencies associated with the use of computing resources (e.g., memory, processing power, network bandwidth, etc.). For example, when memory, processing resources, and network bandwidth are used to select content assets and transmit them to applications that will ultimately obscure, omit, or otherwise distort the digital components of the content assets in a manner that prevents users from being able to perceive information provided by one or more content assets, these computing resources are not available to distribute the content assets to other applications that are able to render the content assets appropriately in the digital components. As the number of users of an application increases, the amount of wasted resources also increases. The aggregate impact (e.g., wasted system resources) caused by these inefficiencies increases rapidly because the number of application users can reach millions of users quickly. As discussed in detail below, the techniques presented in this document reduce the inefficiencies discussed and improve the allocation and use of computing resources by ensuring that the rendering code of the application operates properly before distribution to users.
The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
Drawings
FIG. 1 is a block diagram of an example environment in which content is distributed.
FIG. 2A is a block diagram illustrating the generation of test rendering code that conforms to a digital component.
FIG. 2B is a block diagram illustrating the generation of test rendering code that does not conform to digital components.
FIG. 3 is a flow diagram of an example process for testing rendering code.
FIG. 4 is a flow diagram of an example process for providing test objects to an application executing on a client device.
FIG. 5 is a block diagram of an example computing system.
Like reference numbers and designations in the various drawings indicate like elements.
Detailed Description
This document discloses methods, systems, and devices that may be used to facilitate application (e.g., native mobile application) debugging. As discussed in more detail below, rendering code that assembles and presents content portions as digital components within an application environment may be tested, and the test results may be provided to a developer of the application before the application is released to a user. For example, the tested rendering code may be developed to conform to specifications of a digital component distribution system ("DCDS") that provides content portions to be rendered by an application.
More specifically, the rendering code of the application may specify a layout between different content parts (referred to as content assets) received from the DCDS, obtain the content assets from a software development kit ("SDK"), and incorporate a view hierarchy to the content assets. Thus, unlike the case where complete digital components are provided for "as is" presentation to a web page or application, the rendering code of the application is responsible for combining the content assets in a manner that conforms to the DCDS specification that is also typically enforced by DCDS, such that application developers may need to implement rendering code that combines the content assets into digital components that conform to the DCDS specification.
Application developers typically cannot ensure that the rendering code they have implemented will actually generate digital components that conform to the DCDS specification before distributing the complete application to users. Additionally, application developers are often unable to "force" users to update their applications to new versions, thereby allowing application developers to rely on users voluntarily updating to new versions of applications to fix problems that may exist in rendering code. Furthermore, the inability of the application developer to test the rendering code before releasing the application to the user also prevents the application developer from testing the updated version of the rendering code without releasing the updated version of the application to the user, meaning that the rendering code updates included in the updated version of the application may still fail to fix the identified problem and may lead to further problems preventing the digital component rendered by the application from conforming to the specifications of the DCDS. Thus, it may be difficult for an application developer to implement rendering code that enables third-party content to be presented as native (e.g., first-party) content within their application.
As discussed in detail in this document, an SDK (or other component) for providing content assets to an application may be configured to include logic that detects rendering code issues of the application before the application is released to a user. In some implementations, the SDK can pass a test object (e.g., including a set of content assets) to the application, and collect from the application rendered signals (referred to as a set of signals) corresponding to the resulting digital components that the application renders using the test object. These rendering signals typically provide information about the structural and visual properties of the resulting digital assembly. These rendering signals may be compared to a compliance requirement set (also referred to as a requirement set) to determine whether the resulting digital component created by the rendering code complies with the specification of the DCDS. When the resulting digital component fails the compliance check, an overlay can be presented in the application that specifies a non-compliance status of the resulting digital component and/or information about the problem that caused the non-compliance status. This information may then be used by application developers to revise the rendering code, and any revisions to the rendering code may continue to be tested to ensure that the rendering code produces a conforming digital component before the application is available to the user.
As used in this document, the phrase "digital component" refers to a discrete unit of digital content or digital information (e.g., a video clip, an audio clip, a multimedia clip, an image, text, or another unit of content). The digital components may be electronically stored in a physical memory device or collection of files as a single file, and the digital components may take the form of video files, audio files, multimedia files, image files, or text files, and include advertising information such that the advertisement is one type of digital component. Typically, digital components are defined (or provided) by a single provider or source (e.g., advertiser, publisher, or other content provider). As discussed in more detail below, an application may render digital components as native elements within the application by combining multiple different content assets using rendering code that is part of the application. For example, the rendering code may incorporate the content assets into various views, and the associations between these views will indicate how the application presents the content assets together as digital components within the application.
This document refers to an SDK that performs various operations, but it should be understood that the operations discussed in this document may be performed by various components of a device executing an application.
FIG. 1 is a block diagram of an example environment 100 in which content is distributed to client devices. The example environment 100 includes a network 102, such as a Local Area Network (LAN), a Wide Area Network (WAN), the Internet, or a combination thereof. Network 102 connects client devices 106, digital component servers 108, and digital component distribution systems 110 (also referred to as distribution systems). The example environment 100 may include many different client devices 106 and digital component servers 108.
The client device 106 is an electronic device capable of requesting and receiving resources over the network 102. Example client devices 106 include personal computers, mobile communication devices, and other devices that can send and receive data over the network 102. The client device 106 typically includes a user application (such as a web browser) to facilitate the sending and receiving of data over the network 102, although a local application executed by the client device 106 may also facilitate the sending and receiving of data over the network 102.
An electronic document is data that presents a collection of content at a client device 106. Examples of electronic documents include web pages, word processing documents, portable Document Format (PDF) documents, images, videos, search result pages, and feeds. Native applications (e.g., "apps") (such as applications installed on mobile devices, tablet computers, or desktop computing devices) are also examples of electronic documents. The electronic document may be provided by an electronic document server 104 ("electronic document server") to a client device 106. For example, the electronic document server 104 may include a server hosting an issuer website. In this example, the client device 106 may initiate a request for a given publisher webpage, and the electronic server 104 hosting the given publisher webpage may respond to the request by sending machine-executable instructions that initiate presentation of the given webpage at the client device 106.
In another example, the electronic document server 104 may include an app server where the client device 106 may download native applications. In this example, the client device 106 may download files needed to install the application at the client device 106, and then execute the downloaded native application locally at the client device 104.
The electronic document may include various contents. For example, the electronic document may include static content (e.g., text or other specified content) that is within the electronic document itself and/or that does not change over time. The electronic document may also include dynamic content that may change over time and/or on a per-request basis. For example, the publisher of a given electronic document may maintain a data source that is used to populate portions of the electronic document. In this example, the given electronic document may include a tag or script that causes the client device 106 to request content from a data source when the given electronic document is processed (e.g., rendered or executed) by the client device 106. The client device 106 integrates the content obtained from the data sources into a given electronic document to create a composite electronic document that includes the content obtained from the data sources.
In some cases, a given electronic document may include a digital component tag or digital component script that references the digital component distribution system 110. In these cases, the digital component tag or digital component script is executed by the client device 106 when a given electronic document is processed by the client device 106. Execution of the digital component tag or digital component script configures the client device 106 to generate a request for a digital component 112 (referred to as a "component request") that is transmitted over the network 102 to the digital component distribution system 110. For example, a digital component tag or digital component script may enable the client device 106 to generate a packetized data request including a header and payload data. The component request 112 can include event data specifying characteristics, such as the name (or network location) of the server from which the digital component is being requested, the name (or network location) of the requesting device (e.g., client device 106), and/or information that the digital component distribution system 110 can use to select one or more digital components to provide in response to the request. The component request 112 is transmitted by the client device 106 to a server of the digital component distribution system 110 over the network 102 (e.g., a telecommunications network).
The component request 112 may include event data specifying other event characteristics, such as characteristics of the requested electronic document and the location at which the digital components of the electronic document may be presented. For example, event data specifying a reference (e.g., a URL) to an electronic document (e.g., a web page) in which the digital component is to be rendered, available locations of the electronic document available for rendering the digital component, sizes of the available locations, and/or types of media eligible for rendering in the locations may be provided to the digital component distribution system 110. Similarly, event data specifying keywords associated with the electronic document ("document keywords") or entities referenced by the electronic document (e.g., people, places, or things) may also be included in the component request 112 (e.g., as payload data) and provided to the digital component distribution system 110 in order to identify digital components that are eligible for presentation with the electronic document. The event data may also include search queries submitted from the client device 106 to obtain a search results page and/or data specifying search results and/or textual, audible, or other visual content included in the search results.
The component request 112 may also include event data related to other information, such as information that a user of the client device has provided, geographic information indicating the state or region to which the component request was submitted, or other information that provides context for the environment in which the digital component is to be displayed (e.g., the time of day of the component request, the day of the week of the component request, the type of device in which the digital component is to be displayed, such as a mobile device or tablet device). For example, component request 112 may be transmitted over a packetized network, and component request 112 itself may be formatted as packetized data with a header and payload data. The header may specify the destination of the packet and the payload data may include any of the information discussed above.
A distribution system 110, which includes one or more digital component distribution servers (e.g., a combination of computing hardware and software), selects a digital component to be presented with a given electronic document in response to receiving a component request 112 and/or using information included in the component request 112. In some embodiments, the digital components are selected in less than one second to avoid errors that may result from delaying the selection of the digital components. For example, the delay in providing the digital component in response to the component request 112 may result in an electronic document loading error at the client device 106, or cause portions of the electronic document to remain unfilled even after other portions of the electronic document are presented at the client device 106. Moreover, as the delay in providing digital components to the client device 106 increases, it is more likely that the electronic document will no longer be presented at the client device 106 when the digital components are delivered to the client device 106, thereby negatively impacting the user's experience with the electronic document. Further, delays in providing the digital component may cause delivery of the digital component to fail, for example, if the electronic document is no longer presented at the client device 106 when the digital component is provided.
In some implementations, the distribution system 110 is implemented in a distributed computing system that includes, for example, a collection of multiple computing devices 114 and a server that are interconnected and that identify and distribute digital components in response to requests 112. The set of multiple computing devices 114 operate concurrently to identify a set of Digital Components (DC) from a corpus of millions of available digital components that qualify to be presented in an electronic document 1-x ). For example, millions of available digital components may be indexed in the digital component database 116. Each digital component index entry may reference a corresponding digital component and/or include a Distribution Parameter (DP) that facilitates (e.g., conditions or limits) distribution/transmission of the corresponding digital component 1 -DP x ). For example, the distribution parameters may facilitate transmission of the digital component by requiring the component request to include at least one criterion that matches (e.g., completely matches or has some pre-specified level of similarity to) one of the distribution parameters of the digital component.
In some implementations, the distribution parameters for a particular digital component can include distribution keywords that must be matched (e.g., by electronic document, document keywords, or terms specified in the component request 112) in order for the digital component to qualify for presentation. The distribution parameters may also require that the component request 112 include information specifying a particular geographic region (e.g., country or state) and/or information specifying that the component request 112 originates from a particular type of client device (e.g., mobile device or tablet device) in order for the digital component to qualify for presentation.
The identification of qualified digital components may be split into multiple tasks 117a-117c, which are then assigned among computing devices within the set of multiple computing devices 114. For example, different computing devices in the collection 114 may each analyze different portions of the digital component database 116 to identify various digital components having distribution parameters that match the information included in the component request 112. In some implementations, each given computing device in set 114 may analyze a different data dimension (or set of dimensions) and communicate (e.g., transmit) the results of the analysis (results 1-3) 118a-118c back to digital component distribution system 110. For example, the results 118a-118c provided by each computing device in the set 114 may identify a subset of digital components that are eligible for distribution in response to a component request and/or a subset of digital components having particular distribution parameters. For example, the identification of the subset of digital components may include comparing the event data to distribution parameters and identifying the subset of digital components having distribution parameters that match at least some characteristics of the event data.
The digital component distribution system 110 aggregates the results 118a-118c received from the set of multiple computing devices 114 and uses information associated with the aggregated results to select one or more digital components to be provided in response to the request 112. For example, the digital component distribution system 110 can select a winning set of digital components (one or more digital components) based on the outcome of one or more component evaluation processes. In turn, the digital component distribution system 110 may generate and transmit reply data 120 (e.g., digital data representing a reply) over the network 102 that enables the client device 106 to integrate the winning set of digital components into a given electronic document such that the winning set of digital components and the content of the electronic document are presented together at a display of the client device 106.
In some implementations, the client device 106 executes instructions included in the reply data 120 that configure the client device 106 and enable the client device 106 to obtain a winning set of digital components from one or more digital component servers. For example, the instructions in the reply data 120 may include a network location (e.g., a Uniform Resource Locator (URL)) and a script that causes the client device 106 to transmit a Server Request (SR) 121 to the digital component server 108 to obtain a given winning digital component from the digital component server 108. In response to the request, the digital component server 108 will identify the given winning digital component specified in the server request 121 (e.g., within a database storing a plurality of digital components) and transmit digital component data (DC data) 122 to the client device 106, which presents the given winning digital component in the electronic document at the client device 106.
Conventional systems may provide pre-configured digital components for presentation at the client device 106. For example, the digital component data 122 may include a digital component that includes a preconfigured arrangement of content assets that indicates a manner in which the digital component is to be presented at the client device 106. In this example, neither the client device 106 nor the application executing on the client device is able to rearrange the location of various content assets presented within the digital component or modify the appearance of various elements of the digital component. Conversely, when a preconfigured digital component is provided for presentation within an application executing on the client device 106, the application will simply present the received preconfigured digital component.
Using pre-configured digital components for rendering within a native application (or other electronic document) limits the ability of application developers (or developers of other electronic documents) to customize the rendering of the digital components to complement the visual appearance of the application or even adjust the content assets based on the display characteristics of the client device 106. This may result in the presentation of digital components that are disruptive, confusing, illegible, or otherwise insufficiently perceptible to the user. This can lead to technical inefficiencies as a large amount of network resources are used to select and distribute digital components that fail to convey the information they are intended to convey. This results in wasted network bandwidth by transmitting these illegible digital components over the network 102, wasted memory by storing the digital components within the digital component database 116 and by storing the delivered digital components at the client device, and wasted limited display space at the client device by rendering the illegible digital components, otherwise useful information may be rendered.
In some cases, a native application (or other electronic document) may be configured to accept a collection of unassembled content assets and render these content assets as a resulting digital component. In these cases, the application is provided the flexibility to arrange and format the content assets based on the environment in which the resulting digital components are to be presented, making the resulting digital components clearer and less disruptive to the user experience. Additionally, the ability of an application to render digital components may help eliminate technical inefficiencies that may be encountered when pre-configured digital components are distributed to the application.
While enabling an application to combine content assets into a resulting digital component may provide advantages over traditional pre-configured digital components, it may also lead to other problems. For example, if an application developer does not properly implement rendering code responsible for rendering a resulting digital component, the resulting digital component may have similar problems as discussed above with reference to the preconfigured digital component, which may also result in the same technical inefficiencies discussed above. Additionally, if the rendering code is not implemented correctly, the digital components may not be fully rendered, further wasting network bandwidth, processing resources, and memory resources.
Exacerbating the potential problem discussed above is the fact that some systems do not provide application developers with any way of testing the rendering code of an application before it is released to a user. Instead, application developers need to implement rendering code that they believe will generate a resultant digital component that conforms to the DCDS110 specification, distribute the application to users, and wait for feedback from the DCDS110 if their rendering code does not generate a conforming digital component (i.e., a resultant digital component that conforms to the DCDS specification). This may also result in digital components that are illegible or otherwise fail, which may cause similar technical problems as discussed above (e.g. wasted network bandwidth, wasted memory, and wasted display space). This may also result in additional wasted network bandwidth if the user needs to download a new version of the application to correct errors in the rendering code.
As discussed in more detail below, the SDK of the client device may be modified to facilitate rendering of test of code and application rendering of digital components prior to distribution of the application to users. For example, when an application renders a test digital component (also referred to as a digital component) using a test object that includes a set of content assets, the SDK may collect a set of signals that specify rendering attributes of the test digital component (e.g., digital components generated using the set of content assets in the test object). The SDK may then invoke a validation process that compares the set of signals to a set of compliance requirements (e.g., specified by the DCDS) and determines whether the compliance requirements are satisfied. If the compliance requirements are not met, overlays can be generated and presented within the application, informing the application developer of any problems with testing the digital component rendering so that the application developer can correct the rendering code. This testing may continue until the rendering code produces a test digital component that meets all compliance requirements. The application developer can then distribute his application with confidence that the digital components rendered by the rendering code will meet the compliance requirements and avoid the technical problems discussed above.
FIG. 2A is a block diagram illustrating the generation of test rendering code that conforms to a digital component. In FIG. 2A, the client device 106 initiates a test request 202, and the test request 202 is transmitted to the DCDS 110. A test request is a request to receive content that is rendered (i.e., displayed) in an application executing on the client device 106. For example, when an application developer interacts with an application (e.g., launches the application), a test request may be triggered and the application manipulated to a state of a slot in which the application provides (or is otherwise available for) a digital component may be presented. For example, when a single pixel of a slot reserved for digital components is rendered in a display of the client device 106, a script may be triggered that generates and transmits a request for content to be rendered in the slot.
In some cases, the test request will include a unique identifier corresponding to the test digital component. The test digital component may be a digital component reserved for rendering code delivered to the application to test the application. For example, the test digital component may include a collection of known content assets that can be reliably evaluated by the client device's SDK during testing. The unique identifier may be a designated set of alphanumeric characters that uniquely identifies the test numeric component, such that an application developer may configure a script triggered by preparing a slot reserved for the numeric component to request testing of the numeric component using the unique identifier.
In some implementations, in addition to or instead of using the unique identifier of the test digital component, the application developer may pre-register or otherwise identify the client device 106 as a test device. For example, an application developer may interact with a user interface of the DCDS110 and register the client device 106 as a test device by provisioning a device identifier of the client device. Later, when the DCDS110 receives the test request 202 from the client device 106, the DCDS110 may identify the client device 106 as a test device (e.g., included in the test request 202 based on the device identifier).
The DCDS110 receives a test request 202 from a client device 106 and selects a test object 204 to provide to the client device 106 in response to the test request 202. The test object includes a set of content assets required to render the test digital component. For example, the collection of content assets may include one or more images, one or more videos, textual content, interactive user interface elements, or other content assets. Each of the content assets may be identified by an asset code that identifies a type of content included in the content asset and/or other information that facilitates rendering or grouping of the content assets into the test digital component.
The client device 106 obtains the test object 204 from the DCDS110 (e.g., over a network) and renders the test digital components 206 using rendering code 208 of an application executing on the client device 106. As shown in FIG. 2A, the test digital component 208 is built using content assets that include two images 210, text 212, a source information element 214 that identifies the source of the test digital component, and an interactive element 216 (e.g., learn more button) that initiates a request for more information about the test digital component in response to user interaction with the interactive element 216. Of course, the test digital component (or any digital component) may include additional, fewer, or different content assets than those discussed herein.
The test digital component 206 is provided (e.g., rendered or otherwise made available) in an interface 218 of an application executing on the client device 106 along with native content 220 of the application. When the rendering code 208 renders the test digital component 206 in the interface 218, the debugger 222 detects the readiness of the test digital component and invokes a verification process by which the compliance of the test digital component is evaluated. In some cases, the verification process is triggered only when the test digital component is actually presented in the display. In other cases, other events may trigger the verification process (e.g., the developer interacts with a button that invokes the verification process). Note that although debugger 222 is shown as a separate component with respect to rendering code 208, both components may be implemented within the same code library.
As described in more detail below, testing the conformance of a digital component can be evaluated based on whether a set of signals specifying rendering attributes (e.g., structure and/or presentation attributes) of the test digital component meets a set of conformance requirements that specify attributes of the conforming digital component that have been correctly rendered. The set of compliance requirements may be dictated by the DCDS110 and/or another system or entity responsible for ensuring that the digital components are compliant with the set of specifications.
In some implementations, the debugger 222 can be implemented in an SDK installed on the client device 106. For example, the debugger 222 may be included in an SDK provided by the DCDS110 or another system that provides digital components for the client device 106. In these embodiments, the application under test (e.g., the application executing the rendering code 208) may provide a signal to the SDK indicating that the test digital component has been rendered in the interface 218. In response to the indication, the SDK may collect (or otherwise obtain) a set of signals characterizing the presentation and/or structure of the test digital component rendered by the rendering code 208. The set of signals may specify, for example, hierarchical associations of different views used to present the different content assets (e.g., the combination of the content assets with the parent and child views), the location of the different content assets within the test digital component 206, the size of the display used to display the interface 218, the relative presentation location of the test digital component 208 within the interface 218 and/or display, the presentation size/resolution of the test digital component 206, the location of the content assets within the test digital component 206, and/or status information related to the interaction characteristics used by the test digital component 206 (e.g., performing click events, touch listeners).
The validation process compares the set of signals to the set of compliance requirements to determine whether the test digital component 206 rendered using the rendering code 208 meets the compliance requirements. For purposes of this example, assume that the test digital component 206 presented in FIG. 2A meets all compliance requirements such that the test digital component 208 is considered a compliant digital component.
In some implementations, the SDK can invoke the authentication process by performing an operation of the authentication process. In some implementations, the authentication process is invoked by the SDK by invoking a script that has been downloaded to the client device 106. Implementing the authentication process in a script separate from the SDK provides the ability to modify the authentication process without updating the SDK. For example, when an application is launched, the script may be downloaded or launched for use by the SDK, such that any updates to the verification process may be implemented by downloading an updated version of the script. In these embodiments, the SDK may request the script to perform the authentication process and pass the set of signals obtained from the application to the script. When the script completes the verification process (e.g., compares a set of signals obtained from the application to a set of compliance requirements), the script may pass the results of the verification process back to the SDK, which may then generate an overlay reporting the results of the verification process. In some cases, the SDK requests the overlaid shell document from a server (e.g., DCDS 110), populates the shell document with the results of the validation process, and provides the populated shell document as an overlay in interface 218.
For example, when the debugger 222 determines that the test digital component 206 is a conforming digital component, the debugger may generate an overlay 224 provided in the interface 218 and notify the application developer that a conformance problem has not been detected. With this information, application developers can continue to publish their applications knowing that rendering code 208 will generate conforming digital components when the applications are used by different users who download the applications.
FIG. 2B is a block diagram illustrating the generation of test rendering code that does not conform to digital components. In FIG. 2B, the client device 106 again initiates the test request 202 transmitted to the DCDS110, and the test object 204 is provided to the client device 106 in a manner similar to that discussed above with reference to FIG. 2A. The debugger 222 again collects a set of signals from the application about testing the digital component 206 and invokes a verification process.
In FIG. 2B, the collection of signals characterizing the test digital component 206 will reveal that the image 210 is overlapped and partially occluded by the source information element 214. For the purposes of this example, assume that the set of signals (rendered by rendering code 208) identifying these rendering attributes of test digital component 208 fails to meet the set of compliance requirements. In response to determining that the one or more compliance requirements are not satisfied, the debugger 222 (e.g., SDK) can generate and provide a non-compliant overlay 250 that is presented in the interface 218 of the application. The non-conforming overlay 250 includes data that informs the application developer that the debugger identified compliance issues with the test digital component 206 rendered by the rendering code 208. Non-conforming overlay 250 includes an interactive element (e.g., a "view problem" link) that will provide additional information about the problem identified by debugger 222 in response to interaction with the interactive element by an application developer. Thus, the application developer may be provided with information about the problem identified by the debugger 222 and/or information specifying how the application developer corrects the problem by modifying the rendered code 208.
Examples of information that may be provided to the application developer in response to interaction with an interactive element that does not conform to the overlay 250 include information indicating that the layout of content assets within the test digital component 206 may cause the user to accidentally click (or tap) on the test digital component. This information may also inform application developers when the resolution of the test digital component is too low, so that if the application is distributed to users without modifying the rendering code 208, the DCDS110 will not distribute the digital component to the application. This information may also notify the application developer when there are missing content assets. For example, in FIG. 2B, test digital component 206 lacks interactive element 216 included in test object 204 and presented in the compliance digital component presented in FIG. 2A. When the compliance requirement prohibits a particular content asset from being clickable, this information may also inform the application developer that the test digital component 206 has been rendered in a manner that the particular content asset is clickable. All of this information will enable the application developer to modify rendering code 208 to render the content asset in a form that is consistent with the digital component, as shown in FIG. 2A.
FIG. 3 is a flow diagram of an example process 300 for testing the conformance of rendering code. Process 300 may be performed by one or more computing devices. For example, the operations of process 300 may be performed by a client device and/or an SDK executing on the client device. The operations of process 300 may also be implemented as instructions stored on a non-transitory computer-readable medium and when executed by one or more servers (or other computing devices), the instructions cause the one or more servers to perform the operations of process 300.
A request for content provided to and/or rendered in an application is transmitted to a server (302). In some implementations, the request for content is a request for a test object that can be used to test the operation of rendering code implemented in the native application. The test objects include content assets needed to render test digital components (also referred to simply as digital components). For example, the test object may include one or more of an image, text, video, audio, or interactive element. Each of the content assets can include information identifying the asset type of each content asset and/or other information that can be used to group the content assets into conforming digital components.
In some implementations, the request for content includes a unique identifier indicating that the request is for a test object. For example, as discussed above, the test object may be identified by a unique identifier such that a request for content including the unique identifier constitutes a request for the test object. In these cases, the request is received by a server (e.g., of the DCDS 110) and it is determined that the request is for content to present in the application. The server also determines that the request for content includes an identifier corresponding to the testing environment. For example, the server may determine that the request includes a unique identifier corresponding to the test object. In response to determining that the request for content includes the unique identifier corresponding to the testing environment, the server selects a test object that includes content assets needed to render the digital component, and provides the test object to the client device in response to the request for content.
In some implementations, the request for content includes information that can be used to identify the client device submitting the request as a test device for the application developer. For example, as discussed above, an application developer may pre-register his device as a test device with a content distribution system (e.g., the DCDS110 of FIG. 1). When the client device generates a request for content, the request will include a device identifier of the client device and/or registration code provided in response to the client device registering as a test device, such that the request can be identified as a test object request from the registered test device. In these cases, the server receiving the request may determine that the request includes an identifier corresponding to the test environment. For example, the server may identify a device identifier of the client device and determine that the device identifier is included in a list of registered test devices. Additionally or alternatively, the server may identify registration code within the request that is generated and provided to the application developer when the client device is registered as a test device. In either case, the server may select test objects, including content assets needed to render the digital component, based on the device being identified as a test device. The server then provides the test object to the client device in response to the request for content based on the client device being identified as the test device.
A test object including a plurality of content assets is received (304). In some implementations, the test object is received by a client device used for a test application. For example, the test object may be delivered to the application through an SDK installed on the client device and in communication with the application.
The rendering, providing, and/or presentation of the test digital component by the application executing on the client device is detected by the client device (306). In some implementations, the rendering, providing, and/or presentation of the digital component is detected by a software development kit executing on the client device. For example, the provisioning or rendering of a digital component may be detected by the SDK based on rendering data generated by the application and passed to the SDK by the application when the digital component rendered using the test object is displayed. For example, when any digital component is provisioned or otherwise presented in a display of the application, the application may generate data specifying that the digital component has been generated and/or presented. This data may be similarly generated when the test digital components are presented and used to inform the SDK of the presence of the test digital components.
A set of signals specifying rendering attributes for the test digital component is obtained from the application (308). In some implementations, the set of signals includes at least a first signal indicative of visible attributes of the content asset, the visible attributes being presented by a digital component rendered using the content asset of the test object. For example, the first set of signals may specify content assets presented in the digital component, locations of the content assets within the test digital component, sizes of the content assets presented within the digital component, and/or other data that provides information about how the content assets are visually presented within the digital component.
The set of signals may also include a second signal indicative of hierarchical associations between content assets. For example, a signal collection may specify a user interface view to which a content asset is to be incorporated and a hierarchical relationship between different user interface views. More specifically, the signal set may specify, for each content asset, a user interface view to which the content asset is to be joined and a hierarchical relationship between different user interface views generated by the rendering code to generate the test digital component.
A user interface view (or view for short) is a building block of user interface components. The view occupies a rectangular area on the screen and is used to create the UI component. The views are arranged in a hierarchical tree structure that defines the dependency of the views on other views. Some of the settings of the parent view will be inherited by its child views (e.g., the lower level views in the hierarchical tree structure). Thus, hierarchical associations between content assets can be used in combination with the first signal to determine whether a content asset has been correctly rendered by the rendering code.
The authentication process is invoked (310). In some embodiments, the validation process compares a set of signals obtained from the application to a set of compliance requirements. Note that the compliance requirements are also referred to as requirements. The set of compliance requirements specifies attributes that are compliant with the digital component. In some cases, the set of compliance requirements may specify, for example, a particular type of view (or other user interface element) required to be used to display a particular type of content asset, the content asset required to be presented within a digital component, a minimum size and/or resolution of the digital component and/or the content asset of the specified type, limitations on interaction elements (e.g., the particular type of content asset that cannot be interacted with or the particular interaction element that must be enabled), a location of the content asset within the specified view, and/or a desired hierarchical view level of the specified content asset.
The authentication process is invoked by, for example, an SDK executing on a device, such as a mobile device or tablet device. In some cases, invoking the verification process may include the SDK performing the operation of the verification process (e.g., a comparison of the set of signals to the set of compliance requirements). In some cases, invoking the verification process may include the SDK requesting that the verification process be performed by a script that is not included as part of the SDK. The script may be installed on the same device as the SDK and instantiated at application start-up or device power-on. Alternatively, the script may be installed on a separate device (e.g., in addition to the device executing the SDK). In either case, the SDK may pass to the script a set of signals specifying rendering attributes of the test digital component and a request for a set of signals to be evaluated with reference to a set of compliance requirements.
It is determined whether the set of signals meets a set of compliance requirements (312). For example, the determination may be made by the SDK or a script that is independent of (i.e., not part of) the SDK. A potential advantage of having a separate script execute an evaluation process used to determine whether a set of compliance requirements is met is that the script can be updated without requiring the entire SDK to be updated. This provides more flexibility in updating and/or modifying the evaluation process used to evaluate the application (e.g., based on policy changes and/or newly identified aspects that need to be checked, such as newly discovered types of errors). For purposes of example, the following description assumes that the script performs the evaluation process, but the following description also applies to embodiments in which the verification process is performed by an SDK.
The determination may be made by a validation process that compares the set of signals to the set of compliance requirements. For example, the script may identify a particular compliance requirement and determine whether the set of signals meets the particular compliance requirement. In a specific example, the compliance requirement may specify that a particular content asset must exist and be successfully registered with the SDK in a specified manner. In this example, the script may determine whether the set of signals includes data that specifies that a particular content asset is present in the test digital component, as rendered by the rendering code. When the data specifies that a particular content asset is present within the test digital component, the script may determine that the aspect of the compliance requirement is achieved. When the signal set lacks data specifying the presence of a particular content asset within the test digital component, the script may determine that this aspect of the compliance requirement is not met.
Continuing with the example, the script may further determine whether the signal set includes data indicating that the particular content asset has been successfully (or properly) registered with the SDK. When the data specifies that a particular content asset is successfully (or properly) registered with the SDK, the script may determine that this aspect of the compliance requirement is achieved. When the signal set lacks data specifying that a particular content asset was successfully (or properly) registered with the SDK, the script may determine that this aspect of the compliance requirement was not achieved. The script may continue to evaluate the signal sets to determine whether each requirement in the set of compliance requirements is satisfied (e.g., reached) by the signal set that is specified to test the rendering properties of the digital component.
The script continues by outputting the evaluation result. In some implementations, the evaluation result indicates whether a test digital component rendered by rendering code of the application meets the set of compliance requirements. When the evaluation result indicates that the test digital component satisfies the compliance requirement set, the rendering code is classified as compliant with the rendering code. When the evaluation result indicates that the test digital component fails to meet the set of compliance requirements, the rendering code is classified as non-compliant.
In some embodiments, in order for a set of compliance requirements to be met, each individual requirement in the set of compliance requirements must be met, which is referred to as strict compliance. For example, assume that a compliance requirement set specifies five separate requirements for compliance with a digital component. In this example, strict conformance would require that the signal set include data indicating that the test number component includes five individual requirements specified by the conformance requirement set, such that the conformance requirement set is reached, and the rendering code is deemed to be conforming. Thus, when the script determines that one or more compliance requirements are not satisfied by a set of signals (e.g., the first signal and the second signal), the set of compliance requirements will be considered as not satisfied.
In some embodiments, only partial conformance is required to reach the set of conformance requirements, thereby classifying rendering code conformance. For example, assume that only three of five requirements must be met to meet compliance requirements. In this example, the compliance requirement set may be reached when the signal set includes data indicating that the test digital component satisfies at least three of the five separate requirements in the compliance requirement set.
In some embodiments, the set of compliance requirements may include mandatory requirements and optional aspects. For example, the mandatory requirements may be requirements related to the structure of the rendered test digital components and/or the content that needs to be presented in the test digital components. For example, an optional aspect may be a requirement that indicates that the presentation of the test digital component is more satisfactory, but does not require that the test digital component be considered a proper rendering. In this case, when a mandatory requirement is satisfied (e.g., reached) by a set of signals, the set of compliance requirements may be considered to have been reached even if the optional aspect is not satisfied by the set of signals.
In some cases, determining that the one or more compliance requirements are not met may include determining that the required assets are not included or properly registered with the software development kit, determining that a particular view presenting the content assets is less than a specified size, or that one or more of the content assets are presented outside of the boundaries of the particular view. As discussed above, this determination may be made based on a set of test signals that indicate a set of assets presented in the test digital component and corresponding rendering attributes (e.g., location, size, and other visual attributes) of the content assets.
When it is determined that the set of compliance requirements is satisfied by the set of signals, a compliance overlay is generated and presented in the application (314). In some implementations, the conforming overlay indicates that the test digital component rendered by the rendering code is a conforming digital component, such that the rendering code is deemed to be conforming. For example, as shown in FIG. 2A, a conforming overlay may indicate that no problems are detected by the debugger (e.g., script). Additionally or alternatively, the conforming overlay may explicitly indicate that the rendering code is conforming.
When it is determined that the set of compliance requirements is not satisfied by the set of signals, a non-compliant overlay is generated and presented in the application (316). For example, the SDK may provide a non-compliant overlay in response to determining that one or more compliance requirements are not satisfied. Within the application, non-compliance with the overlay may present an alert indicating that the test digital component fails to comply with one or more compliance requirements, such that the rendering code is deemed non-compliant. For example, as shown in FIG. 2B, a non-conforming overlay may indicate that a problem was detected by a debugger (e.g., a script). Additionally or alternatively, the conforming overlay may explicitly indicate that the rendering code is non-conforming.
In some implementations, non-compliant overlays are generated using a document populated with information about compliance requirements not met by the set of signals. For example, when the SDK obtains information (e.g., from a script) indicating that the set of compliance requirements is not satisfied, the SDK may obtain the form document from a specified location (e.g., a specified network location). The SDK may then populate the document with information indicating that the test digital component failed to meet the one or more compliance requirements.
In some implementations, the non-conforming overlay can include an interactive element. For example, a non-conforming overlay may include a link, a button, or another interactive user interface element that results in the presentation of a page that presents more detail about the problem detected by the rendered test digital component.
An interaction with a non-compliant overlay is detected (318). In some implementations, interaction with the non-conforming overlay is detected by detecting a tap or click on an interactive element included in the non-conforming overlay.
In response to detecting interaction with the non-conforming overlay, additional details are presented to the user in the application. In some implementations, the additional details may specify how the digital component fails to meet one or more compliance requirements. For example, the details presented in response to interaction with the interactive elements that do not conform to the overlay may indicate whether the layout of the content asset is likely to result in an accidental click on a digital component rendered by the rendering code of the application. The details may also indicate whether the resolution of the test digital component rendered by the rendering code is too low. The details may also indicate any desired content assets (e.g., sources of digital components) not present in the digital components rendered by the rendering code. The details may also indicate information identifying any content assets that are interactive but should not be interactive. Details may also indicate when any given view is too small. Any or all of the details listed above may be included and/or excluded from the presented information after interacting with the non-compliant overlay.
FIG. 4 is a flow diagram of an example process 400 for providing test objects to an application executing on a client device. The operations of process 400 may be performed by one or more computing devices. In some implementations, the operations of process 400 may be implemented as instructions stored on a non-transitory computer-readable medium. Execution of the instructions may result in one or more computing devices performing the operations of process 400.
A registration message is received that identifies the client device as a test device (402). As discussed above, the message identifying the client device as the test device may include a unique device identifier identifying the device. The device may be registered as a test device using a unique device identifier.
A request for content is received (404). The request for content may be a request to present the content in an application under test. In some implementations, the request will include a device identifier of the client device and/or registration code provided in response to the client device registering as a test device, such that the request can be identified as a test object request from the registered test device. In these cases, the server receiving the request may determine that the request includes an identifier corresponding to the test environment. For example, the server may identify a device identifier of the client device and determine that the device identifier is included in a list of registered test devices. Additionally or alternatively, the server may identify registration code within the request that is generated and provided to the application developer when the client device is registered as a test device.
In some implementations, the request for content includes a unique identifier indicating that the request is for a test object. For example, as discussed above, the test object may be identified by a unique identifier such that a request for content that includes the unique identifier constitutes a request for the test object. In these cases, the request is received by a server (e.g., of the DCDS 110) and it is determined that the request is for content to present in the application. The server also determines that the request for content includes an identifier corresponding to the testing environment. For example, the server may determine that the request includes a unique identifier corresponding to the test object. In response to determining that the request for content includes a unique identifier corresponding to the testing environment, the server selects a test object that includes content assets required to render the test digital component, and provides the test object to the client device in response to the request for content.
A test object including a content asset is selected in response to the request (406). As discussed above, the selected test objects may include content assets required for rendering code to render the test digital components.
The test object is provided to the device in response to the request (408). The test objects are provided to the device in unrendered form. That is, the individual content assets have not been rendered and arranged in the form of test digital components. Instead, individual content assets are included in the test object and provided to the device to be rendered by rendering code of a native application executing at the device.
FIG. 5 is a block diagram of an example computer system 500 that may be used to perform the operations described above. The system 500 includes a processor 510, a memory 520, a storage device 530, and an input/output device 540. For example, each of the components 510, 520, 530, and 540 may be interconnected using a system bus 550. Processor 510 is capable of processing instructions for execution within system 500. In one implementation, the processor 510 is a single-threaded processor. In another implementation, the processor 510 is a multi-threaded processor. The processor 510 is capable of processing instructions stored in the memory 520 or on the storage device 530.
The storage device 530 is capable of providing mass storage for the system 500. In one implementation, the storage device 530 is a computer-readable medium. In various different embodiments, storage device 530 may comprise, for example, a hard disk device, an optical disk device, a storage device shared by multiple computing devices over a network (e.g., a cloud storage device), or some other mass storage device.
The input/output device 540 provides input/output operations for the system 500. In one embodiment, the input/output device 540 may include one or more network interface devices, such as an Ethernet card, a serial communication device (e.g., and RS-232 port), and/or a wireless interface device (e.g., and 802.11 card). In another embodiment, the input/output devices may include driver devices, such as keyboards, printers, and display devices, which are configured to receive input data and send output data to the peripheral devices 560. However, other embodiments may also be used, such as a mobile computing device, a mobile communication device, a set-top box television client device, and so forth.
Although an example processing system has been described in fig. 5, implementations of the subject matter and the functional operations described in this specification can be implemented in other types of digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
The electronic document may, but need not, correspond to a file. The document may be stored in a portion of a file that holds other documents, in a single file dedicated to the document in question, or in multiple cooperating files.
Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a computer storage medium for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions may be encoded on an artificially generated propagated signal (e.g., a machine-generated electrical, optical, or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by data processing apparatus). The computer storage media may be or be included in a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Moreover, when the computer storage medium is not a propagated signal, the computer storage medium can be a source or destination of computer instructions encoded in an artificially generated propagated signal. The computer storage media may also be, or be included in, one or more separate physical components or media, such as multiple CDs, disks, or other storage devices.
The operations described in this specification can be implemented as operations performed by data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
The term "data processing apparatus" encompasses all kinds of devices, apparatus, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations of the foregoing. The apparatus can comprise special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment may implement a variety of different computing model infrastructures, such as web services, distributed computing, and grid computing infrastructures.
A computer program (also known as a program, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. The computer program may, but need not, correspond to a file in a file system. Program storage may be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with the instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such a device. Moreover, a computer may be embedded in another device, e.g., a mobile telephone, a Personal Digital Assistant (PDA), a mobile audio or video player, a game player, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a Universal Serial Bus (USB) flash drive), to name a few. Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices (e.g., EPROM, EEPROM, and flash memory devices); magnetic disks (e.g., internal hard disks or removable disks); a magneto-optical disk; and CD-ROM disks and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having: a display device for displaying information to a user, such as a CRT (cathode ray tube) or LCD (liquid crystal display) monitor; and a keyboard and a pointing device, such as a mouse or a trackball, by which a user can provide input to the computer. Other kinds of devices may also be used to provide for interaction with a user; for example, feedback provided to the user can be any form of sensory feedback, such as visual feedback, auditory feedback, or tactile feedback; and input from the user may be received in any form, including acoustic, speech, or tactile input. In addition, the computer may receive documents from a device used by the user by sending the documents to the device; the user is interacted with, for example, by sending a web page to a web browser on the user's client device in response to a request received from the web browser.
Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front-end component (e.g., a client computer having a graphical user interface or a web browser through which a user can interact with an implementation of the subject matter described in this specification), or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network ("LAN") and a wide area network ("WAN"), an internetwork (e.g., the internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
The computing system may include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, the server transmits data (e.g., HTML pages) to the client device (e.g., for displaying data to a user interacting with the client device and receiving user input from the user). Data generated at the client device (e.g., a result of the user interaction) may be received from the client device at the server.
While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any inventions or of what may be claimed, but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
Thus, particular embodiments of the present subject matter have been described. Other embodiments are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In some embodiments, multitasking and parallel processing may be advantageous.
Claims (21)
1. A method, comprising:
detecting, by a device, a rendering of a digital component by an application executing on the device;
obtaining, from the application, a set of signals specifying rendering attributes of the digital components, the set of signals including at least a first signal indicative of visible attributes of content assets included in a test digital component and a second signal indicative of hierarchical associations between the rendered content assets;
invoking, by the device, a validation process that compares the first signal and the second signal to a set of requirements that specify that the digital component-compliant attributes have been correctly rendered;
determining that one or more requirements are not met by the first signal or the second signal; and
providing, by the device, a non-compliant overlay that provides an alert within the application indicating that the digital component fails to comply with the one or more requirements in response to determining that the one or more requirements are not satisfied.
2. The method of claim 1, further comprising:
receiving, by a server, a registration message identifying the device as a test device for the application;
receiving, from the device, a request for content for provision to the application;
selecting, by the server, a test object including the content assets needed to render the digital component based on the device being identified as a test device; and
providing, by the server, the test object to the device in response to the request for content based on the device being identified as a test device.
3. The method of claim 1, further comprising:
receiving, by a server, a request for content for providing to the application;
determining, by the server, that the request for content includes an identifier corresponding to a testing environment;
in response to determining that the request for content includes the identifier corresponding to the testing environment, selecting, by the server, a test object that includes the content assets needed to render the digital component; and
providing, by the server, the test object to the device in response to the request for content.
4. The method of claim 1, wherein invoking, by the device, a verification process that compares the first and second signals to a set of requirements comprises requesting that the verification process be performed by a script instantiated at startup of the application.
5. The method of claim 1, further comprising:
detecting an interaction with the overlay; and
in response to detecting interaction with the overlay, providing additional detail regarding how the digital component failed to meet the one or more requirements.
6. The method of claim 1, further comprising:
obtaining, by the device, a document from a specified location; and
populating the document with information indicating that the digital component fails to meet the one or more requirements.
7. The method of claim 1, wherein:
obtaining a set of signals specifying rendering attributes of the digital component comprises obtaining a set of signals indicative of a set of content assets included in the digital component; and is
Determining that one or more requirements are not satisfied includes (i) determining that a desired asset is not included or properly registered with a software development kit, (ii) determining that a particular view that includes the content asset is less than a specified size, or (iii) determining that one or more of the content assets are located outside boundaries of the particular view.
8. A system, comprising:
one or more memory devices; and
one or more processors configured to execute instructions that cause the one or more processors to perform operations comprising:
detecting a rendering of a digital component by an application executing on a device;
obtaining, from the application, a set of signals specifying rendering attributes of the digital components, the set of signals including at least a first signal indicative of visible attributes of content assets included in a test digital component and a second signal indicative of hierarchical associations between the rendered content assets;
invoking a validation process that compares the first signal and the second signal to a set of requirements that specify that the digital component's attributes have been correctly rendered;
determining that one or more requirements are not met by the first signal or the second signal;
in response to determining that the one or more requirements are not satisfied, providing a non-compliant overlay that provides an alert within the application indicating that the digital component fails to comply with the one or more requirements.
9. The system of claim 8, further comprising a server comprising one or more computing devices, wherein the server is configured to perform operations comprising:
receiving a registration message identifying the device as a test device for the application;
receiving, from the device, a request for content for providing to the application;
selecting a test object including the content assets needed to render the digital component based on the device being identified as a test device;
providing the test object to the device in response to the request for content based on the device being identified as a test device.
10. The system of claim 1, further comprising a server comprising one or more computing devices, wherein the server is configured to perform operations comprising:
receiving a request for content for provision to the application;
determining that the request for content includes an identifier corresponding to a test environment;
in response to determining that the request for content includes the identifier corresponding to the test environment, selecting a test object that includes the content assets needed to render the digital component;
providing the test object in response to the request for content.
11. The system of claim 8, wherein invoking an authentication process that compares the first signal and the second signal to a set of requirements comprises requesting that the authentication process be performed by a script instantiated at startup of the application.
12. The system of claim 8, wherein the instructions cause the one or more processors to perform operations further comprising:
detecting an interaction with the overlay; and
in response to detecting interaction with the overlay, providing additional detail regarding how the digital component failed to meet the one or more requirements.
13. The system of claim 8, wherein the instructions cause the one or more processors to perform operations further comprising:
obtaining a document from a specified location; and
populating the document with information indicating that the digital component fails to meet the one or more requirements.
14. The system of claim 8, wherein:
obtaining a set of signals specifying rendering attributes for the digital component comprises obtaining a set of signals indicative of a set of content assets included in the digital component; and is provided with
Determining that one or more requirements are not satisfied includes (i) determining that a desired asset is not included or properly registered with a software development kit, (ii) determining that a particular view that includes the content asset is less than a specified size, or (iii) determining that one or more of the content assets are located outside boundaries of the particular view.
15. A non-transitory computer storage medium encoded with a computer program, the program comprising instructions that when executed by one or more data processing apparatus cause the one or more data processing apparatus to perform operations comprising:
detecting a rendering of a digital component by an application executing on a device;
obtaining, from the application, a set of signals specifying rendering attributes of the digital components, the set of signals including at least a first signal indicative of visible attributes of content assets included in a test digital component and a second signal indicative of hierarchical associations between the rendered content assets;
invoking a validation process that compares the first signal and the second signal to a set of requirements that specify that the digital component's attributes have been correctly rendered;
determining that one or more requirements are not met by the first signal or the second signal;
in response to determining that the one or more requirements are not satisfied, providing a non-compliant overlay that provides an alert within the application indicating that the digital component fails to comply with the one or more requirements.
16. The non-transitory computer storage medium of claim 15, wherein the instructions cause the one or more data processing apparatus to perform operations comprising:
receiving a registration message identifying the device as a test device for the application;
receiving a request for content for provision to the application;
selecting a test object including the content assets needed to render the digital component based on the device being identified as a test device;
providing the test object to the device in response to the request for content based on the device being identified as a test device.
17. The non-transitory computer storage medium of claim 15, wherein the instructions cause the one or more data processing apparatus to perform operations comprising:
receiving a request for content for provision to the application;
determining that the request for content includes an identifier corresponding to a testing environment;
in response to determining that the request for content includes the identifier corresponding to the testing environment, selecting a test object that includes the content assets needed to render the digital component;
providing the test object in response to the request for content.
18. The non-transitory computer storage medium of claim 15, wherein invoking a verification process that compares the first and second signals to a set of requirements comprises: requesting that the verification process be performed by a script instantiated at startup of the application.
19. The non-transitory computer storage medium of claim 15, wherein the instructions cause the one or more data processing apparatus to perform operations comprising:
detecting an interaction with the overlay; and
in response to detecting interaction with the overlay, providing additional detail regarding how the digital component failed to meet the one or more requirements.
20. The non-transitory computer storage medium of claim 15, wherein the instructions cause the one or more data processing apparatus to perform operations comprising:
obtaining a document from a specified location; and
populating the document with information indicating that the digital component fails to meet the one or more requirements.
21. The non-transitory computer storage medium of claim 15, wherein:
obtaining a set of signals specifying rendering attributes of the digital component comprises obtaining a set of signals indicative of a set of content assets included in the digital component; and is provided with
Determining that one or more requirements are not satisfied includes (i) determining that a desired asset is not included or properly registered with a software development kit, (ii) determining that a particular view that includes the content asset is less than a specified size, or (iii) determining that one or more of the content assets are located outside boundaries of the particular view.
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
PCT/US2020/030270 WO2021221616A1 (en) | 2020-04-28 | 2020-04-28 | Rendering debugger |
Publications (1)
Publication Number | Publication Date |
---|---|
CN115461725A true CN115461725A (en) | 2022-12-09 |
Family
ID=70680708
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202080100213.5A Pending CN115461725A (en) | 2020-04-28 | 2020-04-28 | Rendering debugger |
Country Status (7)
Country | Link |
---|---|
US (1) | US20230168993A1 (en) |
EP (1) | EP4111315A1 (en) |
JP (1) | JP2023523999A (en) |
KR (1) | KR20220154819A (en) |
CN (1) | CN115461725A (en) |
CA (1) | CA3179376A1 (en) |
WO (1) | WO2021221616A1 (en) |
Family Cites Families (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9218267B1 (en) * | 2013-08-14 | 2015-12-22 | Amazon Technologies, Inc. | Page rendering feedback |
US20160179658A1 (en) * | 2013-11-27 | 2016-06-23 | Ca, Inc. | User interface testing abstraction |
US9164874B1 (en) * | 2013-12-20 | 2015-10-20 | Amazon Technologies, Inc. | Testing conversion and rendering of digital content |
US20160077955A1 (en) * | 2014-09-16 | 2016-03-17 | International Business Machines Corporation | Regression testing of responsive user interfaces |
US20200034281A1 (en) * | 2017-01-11 | 2020-01-30 | Smartlytics Llc, Dba Quantyzd | System and method for automated intelligent mobile application testing |
-
2020
- 2020-04-28 CN CN202080100213.5A patent/CN115461725A/en active Pending
- 2020-04-28 CA CA3179376A patent/CA3179376A1/en active Pending
- 2020-04-28 JP JP2022565892A patent/JP2023523999A/en active Pending
- 2020-04-28 US US17/921,152 patent/US20230168993A1/en active Pending
- 2020-04-28 EP EP20725401.2A patent/EP4111315A1/en active Pending
- 2020-04-28 KR KR1020227037134A patent/KR20220154819A/en unknown
- 2020-04-28 WO PCT/US2020/030270 patent/WO2021221616A1/en unknown
Also Published As
Publication number | Publication date |
---|---|
CA3179376A1 (en) | 2021-11-04 |
KR20220154819A (en) | 2022-11-22 |
EP4111315A1 (en) | 2023-01-04 |
JP2023523999A (en) | 2023-06-08 |
US20230168993A1 (en) | 2023-06-01 |
WO2021221616A1 (en) | 2021-11-04 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11375044B2 (en) | Custom digital components | |
US8504913B2 (en) | Client-side components | |
JP6644811B2 (en) | Mobile application activity detector | |
US20160188432A1 (en) | Method and Apparatus for Intercepting Implanted Information in Application | |
US8533336B1 (en) | Automated web frontend sharding | |
CN108811514A (en) | System and method for implementing the presentation to content item with detecting the misapplication executed on a client device | |
AU2009279893A1 (en) | Content distribution for mobile device | |
US9865008B2 (en) | Determining a configuration of a content item display environment | |
US20100268759A1 (en) | Automated server controlled client-side logging | |
US20180293610A1 (en) | Methods and systems for integrating applications into a content recommendation network | |
US20110161325A1 (en) | System, method and computer-readable storage medium for generation and remote content management of compiled files | |
US20190139077A1 (en) | Providing reporting and analysis for campaign-driven messages and websites | |
US9369544B1 (en) | Testing compatibility with web services | |
US10997270B2 (en) | Optimized digital components | |
CN115461725A (en) | Rendering debugger | |
US20160330133A1 (en) | Providing network resources based on available user information | |
JP7405969B2 (en) | Incorporating a secure watermark into your content | |
CN113608737A (en) | Page generation method, device, equipment and medium | |
JP2022542203A (en) | Mini-program batch processing method, device, electronic device and readable storage medium | |
CN114402281A (en) | Dynamically configurable client application activity | |
JP7072619B2 (en) | Custom digital components | |
KR20160124303A (en) | Apparatus and method for providing service | |
JP2023551077A (en) | Local cryptography techniques for privacy protection | |
US20180143949A1 (en) | Web Content Extension System and Platform | |
JP2021140559A (en) | Program update management system, program update management method, and program update management program |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |