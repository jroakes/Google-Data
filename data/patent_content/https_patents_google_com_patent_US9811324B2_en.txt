US9811324B2 - Code caching system - Google Patents
Code caching system Download PDFInfo
- Publication number
- US9811324B2 US9811324B2 US14/726,376 US201514726376A US9811324B2 US 9811324 B2 US9811324 B2 US 9811324B2 US 201514726376 A US201514726376 A US 201514726376A US 9811324 B2 US9811324 B2 US 9811324B2
- Authority
- US
- United States
- Prior art keywords
- code
- source code
- execution
- secondary source
- executable
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
- G06F8/44—Encoding
- G06F8/443—Optimisation
- G06F8/4441—Reducing the execution time required by the program code
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/957—Browsing optimisation, e.g. caching or content distillation
- G06F16/9574—Browsing optimisation, e.g. caching or content distillation of access to content, e.g. by caching
-
- G06F17/30902—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
- G06F8/44—Encoding
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
- G06F8/44—Encoding
- G06F8/443—Optimisation
- G06F8/4434—Reducing the memory space required by the program code
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/3017—Runtime instruction translation, e.g. macros
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/44—Arrangements for executing specific programs
- G06F9/448—Execution paradigms, e.g. implementations of programming paradigms
- G06F9/4488—Object-oriented
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/44—Arrangements for executing specific programs
- G06F9/455—Emulation; Interpretation; Software simulation, e.g. virtualisation or emulation of application or operating system execution engines
- G06F9/45504—Abstract machines for programme code execution, e.g. Java virtual machine [JVM], interpreters, emulators
- G06F9/45529—Embedded in an application, e.g. JavaScript in a Web browser
-
- H04L67/2842—
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L67/00—Network arrangements or protocols for supporting network services or applications
- H04L67/50—Network services
- H04L67/56—Provisioning of proxy services
- H04L67/568—Storing data temporarily at an intermediate stage, e.g. caching
Definitions
- the subject technology relates to caching executable code and, in particular, relates to selecting source code for compiling, serializing and caching the executable code and deserializing the cached executable code prior to execution.
- VMs are used for execution of software code upon on-demand compilation, also referred to as Just in Time (JIT) compilation, in which compilation of code is performed immediately prior to execution of the code or part of the code is compiled on-demand (e.g., lazily).
- JIT Just in Time
- the code is embedded in a resource, for example a resource within a web page
- the speed with which the resource can be rendered within an application (e.g., a browser) running on a client device depends upon the speed of execution of the embedded code.
- a user of the client device may access the same resource repeatedly within the same work session, for example a web browser session, or across multiple independent work sessions.
- a noticeably long time may be needed for each compilation.
- the disclosed subject matter can be embodied in a system.
- the system includes one or more processors.
- the system also includes a memory.
- the memory includes instructions which, when executed, cause the one or more processors to implement a method.
- the instructions include code for receiving a first indication of primary source code awaiting execution.
- the instructions include code for checking a resource cache for cached data corresponding to the primary source code in response to receiving the first indication.
- the instructions include code for, upon a cache miss in the resource cache, obtaining first executable code compiled from the primary source code.
- the instructions include code for selecting secondary source code referenced in the primary source code.
- the instructions include code for obtaining second executable code compiled from the selected secondary source code.
- the instructions include code for serializing the first executable code and the second executable code into serialized code.
- the instructions include code for storing the serialized code as cached data in the resource cache
- the instructions may include code for obtaining execution results from execution of the first executable code in a first execution context, wherein the secondary source code is selected based on the execution results.
- the secondary source code may be selected based on one or more of a size of the secondary source code, a size of the second executable code, a prediction that the secondary source code is referenced in the primary source code, a number of times the secondary source code is referenced in the primary source code, a frequency of the secondary source code referenced in the primary source code, or a compile time of the secondary source code.
- the instructions may include code for receiving a second indication of the primary source code awaiting execution in a second execution context, wherein the second indication is received subsequent to the first indication.
- the instructions may include code for checking the resource cache for cached data corresponding to the primary source code and to the selected secondary source code, in response to receiving the second indication.
- the instructions may include code for, upon a cache hit in the resource cache, retrieving the cached data comprising the serialized code from the resource cache.
- the instructions may include code for deserializing the retrieved serialized code, into third executable code.
- the instructions may include code for providing the third executable code for execution in the second execution context.
- the first execution context and the second execution context can be two different virtual machine environments for code execution.
- the primary source code can be a script in a web page and the first execution context and the second execution context can be web browser sessions within which the script is executed.
- the primary source code can be a top-level script of a web page.
- the first executable code may include a set of references including fixed memory addresses specific to the first execution context, embedded in the first executable code.
- the instructions including code for serializing the first executable code may include code for replacing the embedded memory addresses with abstract addresses non-specific to the first execution context.
- the disclosed subject matter can be embodied in a system.
- the system includes one or more processors.
- the system also includes a memory.
- the memory includes instructions which, when executed, cause the one or more processors to implement a method.
- the instructions include code for receiving a first indication of primary source code awaiting execution.
- the instructions include code for checking a resource cache for cached data corresponding to the primary source code in response to receiving the first indication.
- the instructions include code for, upon a cache miss in the resource cache, obtaining first executable code compiled from the primary source code.
- the instructions include code for serializing the first executable code into serialized code based on one or more of a size of the primary source code, a number of times the primary source code is executed in a predefined period of time, or a compile time of the primary source code.
- the instructions include code for storing the serialized code as cached data in the resource cache.
- the instructions may include code for selecting secondary source code referenced in the primary source code, at least based on a size of the secondary source code, a number of times the secondary source code is referenced in the primary source code, a compile time of the secondary source code, or a combination thereof.
- the instructions may include code for obtaining second executable code compiled from the secondary source code.
- the instructions may include code for serializing the second executable code into the serialized code.
- the instructions may include code for obtaining execution results from execution of the first executable code in a first execution context, wherein the secondary source code is selected based on the execution results.
- the instructions may include code for receiving a second indication of the primary source code awaiting execution in a second execution context, wherein the second indication is received subsequent to the first indication.
- the instructions may include code for checking the resource cache for cached data corresponding to the primary source code and to the selected secondary source code, in response to receiving the second indication.
- the instructions may include code for, upon a cache hit in the resource cache, retrieving the cached data comprising the serialized code from the resource cache.
- the instructions may include code for deserializing the retrieved serialized code, into third executable code.
- the instructions may include code for providing the third executable code for execution in the second execution context.
- the first execution context and the second execution context may be two different virtual machine environments for code execution.
- the first executable code may include a set of references including memory addresses embedded in the first executable code, and the instructions including code for serializing the first executable code may include code for replacing the embedded memory addresses with abstract addresses.
- the disclosed subject matter can be embodied in a computer-readable medium that includes instructions that can be executed by a computer.
- the instructions include code for causing the computer to receive a first indication of primary source code awaiting execution.
- the instructions include code for causing the computer to check a resource cache for cached data corresponding to the primary source code in response to receiving the first indication.
- the instructions include code for, upon a cache miss in the resource cache, causing the computer to obtain first executable code compiled from the primary source code.
- the instructions include code for causing the computer to obtain execution results from execution of the first executable code in a first execution context.
- the instructions include code for causing the computer to select secondary source code referenced in the primary source code, based on the execution results.
- the instructions include code for causing the computer to obtain second executable code compiled from the selected secondary source code.
- the instructions include code for causing the computer to serialize the first executable code and the second executable code into serialized code.
- the instructions include code for causing the computer to store the serialized code as cached data in the resource cache.
- the first executable code may include a set of references including memory addresses embedded in the first executable code
- the instructions causing the computer to serialize the first executable code may include instructions to cause the computer to replace the embedded memory addresses with abstract addresses.
- the execution results may indicate a number of times the secondary source code referenced in the primary source code is executed at the execution of the primary source code.
- the instructions may include code for causing the computer to receive a second indication of the primary source code awaiting execution in a second execution context, wherein the second indication is received subsequent to the first indication.
- the instructions may include code for causing the computer to check the resource cache for cached data corresponding to the primary source code and to the selected secondary source code, in response to receiving the second indication.
- the instructions may include code for, upon a cache hit in the resource cache, causing the computer to retrieve the cached data comprising the serialized code from the resource cache.
- the instructions may include code for causing the computer to deserialize the retrieved serialized code, into third executable code.
- the instructions may include code for causing the computer to provide the third executable code for execution in the second execution context.
- the first execution context and the second execution context can be two different virtual machine environments for code execution.
- the instructions may include code for causing the computer to obtain a first execution profile associated with the first executable code and a second execution profile associated with the second executable code.
- the instructions may also include code for causing the computer to serialize the first execution profile and the second execution profile.
- the instructions may also include code for causing the computer to store the serialized first execution profile and second execution profile in the resource cache, wherein deserializing the retrieved serialized code includes deserializing the first execution profile and the second execution profile.
- FIG. 1 illustrates an example network environment in which code caching may be processed.
- FIG. 2 illustrates a client device to which code caching may be provided.
- FIG. 3 is a flow diagram of a code-caching platform by which serialization of a script into cached code and deserialization of cached code into executable code may be provided.
- FIGS. 4A-4B illustrate examples of processes by which serialization of a script into cached code may be provided.
- FIG. 5 conceptually illustrates an example electronic system with which some implementations of the subject technology are implemented.
- Abstraction is a process of replacing references in an object (e.g., code) to memory addresses and other objects specific to an execution context with instructions for recreating the references (e.g., relocation data) such that the object can be recreated in a new execution context.
- object e.g., code
- instructions for recreating the references e.g., relocation data
- Serializing is a process of generating a representation of an object (e.g., compiled executable code) as sequential data that can be transported and includes the object's data as well as information about the object such as the object's type or the types of data stored in the object.
- object e.g., compiled executable code
- Deserializing is a process of extracting and generating an object (e.g., compiled executable code) from the sequential data of a serialized object.
- object e.g., compiled executable code
- Source code is a collection of computer instructions specifying actions to be performed by a computer and written using a human-readable computer language.
- Executable code is a set of machine language instructions executable by a computer and produced by parsing and compiling source code.
- Execution Context is a set of operational parameters defining a computer system or a software emulation of a computer system (e.g., a virtual machine) within which executable code is executed.
- Relocation data are instructions or information used to restore abstracted code references to memory locations or objects in a current execution context.
- Load time of resources is an important part of the user experience when trying to access a resource via a computing device.
- the resource may be an application, file or document loaded from a local memory within the computing device or a network resource such as, for example, a file or a document within a webpage loaded from a network.
- dynamic scripts such as, for example, JAVASCRIPT® code embedded within a resource need to be compiled prior to being executed, and this can slow down the process of loading the resource. Therefore, it is desirable to improve efficiency of rendering resources on computing devices by caching compiled code into a resource cache and reusing the cached code for future accesses to the resource during subsequent sessions.
- Source code may be transformed by a compiler program into low-level machine code that is executable by the computer.
- the machine code might then be stored for execution.
- an interpreter can be used to analyze and perform the outcomes of the source code program directly on the fly.
- Parsing and compiling source code e.g., JAVASCRIPT® code
- JAVASCRIPT® code embedded in an application or a document such as, for example, a web page to produce executable code
- Machine language is the set of native instructions the computer carries out in hardware.
- the compiled code can be serialized and cached, for example in a binary format. Once the executable code is cached, on subsequent executions of the script, the source code no longer has to be re-parsed and re-compiled, and the executable code can be deserialized from the cache and executed.
- serialization During serialization of compiled code, the state of the code can be converted into a form that can be transported from an execution environment to other execution environments. Serialization process translates data structures or object states into a format that can be reconstructed in the same or another context (e.g., execution environment) based on the information embedded in the serialized object. Serialization may provide executable code, from the compiled code, for various components of the code and for objects the code references to such as, for example, data structures representing constants, string literals, object literals, function objects including relocation data necessary for on-demand compilation, shared pieces of code, references to the execution environment (e.g., VM), etc.
- execution environment e.g., VM
- FIG. 1 illustrates an example network environment 100 in which code caching may be processed.
- Network environment 100 includes client devices 101 a and 101 n and servers 109 a and 109 m . Although two client devices 101 a and 101 n , and two servers 109 a and 109 m are shown in FIG. 1 , the subject technology is not limited to such and can apply to more than two client devices and servers or just one client device and/or server.
- Client devices 101 a and 101 n and servers 109 a and 109 m can communicate with each other through network 105 .
- Server 109 a or 109 m can include computing devices similar to client devices and computer-readable storage devices (not shown).
- Each of client devices 101 a and 101 n can represent various forms of processing devices.
- Example processing devices can include a desktop computer, a laptop computer, a handheld computer, a personal digital assistant (PDA), a cellular telephone, a network appliance, a camera, a smart phone, an enhanced general packet radio service (EGPRS) mobile phone, a media player, a navigation device, an email device, a game console, or a combination of any these data processing devices or other data processing devices.
- Client devices 101 a and 101 n and servers 109 a and 109 m may be provided access to or receive application software executed or stored on any of the other client devices 101 a and 101 n or servers 109 a and 109 m.
- Servers 109 a and 109 m may be any system or device having a processor, a memory, and communications capability for providing content to client devices 101 a and 101 n .
- server 109 a or 109 m can be a single computing device, for example, a computer server.
- server 109 a or 109 m can represent more than one computing device working together to perform the actions of a server computer (e.g., cloud computing).
- server 109 a or 109 m can represent various forms of servers including, but not limited to a web server, an application server, a proxy server, a network server, or a server farm.
- client devices 101 a and 101 n may communicate wirelessly through a communication interface (not shown), which may include digital signal processing circuitry where necessary.
- the communication interface may provide for communications under various modes or protocols, for example, Global System for Mobile communication (GSM) voice calls, Short Message Service (SMS), Enhanced Messaging Service (EMS), or Multimedia Messaging Service (MMS) messaging, Code Division Multiple Access (CDMA), Time Division Multiple Access (TDMA), Personal Digital Cellular (PDC), Wideband Code Division Multiple Access (WCDMA), CDMA2000, or General Packet Radio System (GPRS), among others.
- GSM Global System for Mobile communication
- SMS Short Message Service
- EMS Enhanced Messaging Service
- MMS Multimedia Messaging Service
- CDMA Code Division Multiple Access
- TDMA Time Division Multiple Access
- PDC Personal Digital Cellular
- WCDMA Wideband Code Division Multiple Access
- CDMA2000 Code Division Multiple Access 2000
- GPRS General Packet Radio System
- the communication may occur through a radio-frequency transceiver (not shown
- network environment 100 can be a distributed client/server system that spans networks, for example, network 105 .
- Network 105 can be a large computer network, for example, a local area network (LAN), wide area network (WAN), the Internet, a cellular network, or a combination thereof connecting any number of mobile clients, fixed clients, and servers.
- network 105 can include, but is not limited to, any of the following network topologies, including a bus network, a star network, a ring network, a mesh network, a star-bus network, tree or hierarchical network, and the like.
- each client e.g., client devices 101 a and 101 n
- server 109 a or 109 m can occur via a virtual private network (VPN), Secure Shell (SSH) tunnel, or other secure network connection.
- VPN virtual private network
- SSH Secure Shell
- network 105 may further include a corporate network (e.g., intranet) and wireless access points.
- any of client devices 101 a or 101 n can communicate with each other and with servers 109 a or 109 via network 105 using a network protocol such as, for example, the Hypertext Transfer Protocol (HTTP) protocol.
- Client device 101 a or 101 n can receive user input for an application 107 a or 107 n (e.g., a web browser) within a user interface of client device 101 a or 101 n .
- the user input can specify which content to load.
- a user input can be a Uniform Resource Locator (URL) address associated with a website specifying what web content to be loaded from server 109 a or 109 m .
- URL Uniform Resource Locator
- each of client devices 101 a or 101 n can include a code-caching platform 103 a or 103 n , which can, check a cache for cached executable code based on a request from user, and provide the cached executable code for execution on client device 101 a or 101 n .
- the code-caching platform 103 or 103 n can also select parts of the executable code for caching.
- FIG. 2 illustrates a client device for which code caching may be provided.
- the client device 200 is similar to client devices 101 a and 101 n of FIG. 1 .
- the client device 200 includes a processor 201 , a network interface 203 , and a memory 205 .
- the processor 201 is configured to execute computer instructions that are stored in a computer-readable medium, for example, the memory 205 .
- the processor 201 may be a central processing unit (CPU).
- the network interface 203 is configured to allow the client device 201 to transmit and receive data in network 105 , for example, the Internet, an intranet, a local area network or a cellular network.
- the network interface 203 may include network interface cards (NICs).
- NICs network interface cards
- the memory 205 stores data and instructions. As shown, the memory 205 includes an application 207 , similar to applications 107 a and 107 n of FIG. 1 , and a code-caching platform 209 , similar to the code-caching platform 103 a and 103 n of FIG. 1 .
- the application 207 and the code-caching platform 209 may function within an execution environment such as the virtual machine 211 .
- Application 207 can be a software application executed on the client device 200 by processor 201 .
- the application 207 may be a web browser providing, to a user of the client device 200 , access to services provided by servers 109 a or 109 m via network 105 .
- the servers 109 a and 109 m may provide services to client device 200 in the form of websites and a web page provided by server 109 a or 109 m may include multiple source code or scripts (e.g., JAVASCRIPT®) that are compiled and executed upon being loaded at the client device 200 .
- the code-caching platform 209 may be configured to provide code-caching services to application 207 , where application 207 renders services provided by servers 109 a and 109 m to the client device 200 .
- the code-caching platform 209 receives an indication of source code embedded in an application 207 awaiting execution on client device 200 .
- the indication of the source code may be a link referring to a location of the source code embedded in application 207 in memory 205 .
- the indication can also be an identifier associated with the source code, or the full content of the source code.
- the code-caching platform 209 can check a resource cache 213 within memory 205 for cached executable code corresponding to the source code.
- the resource cache 213 may be stored in persistent/non-volatile memory.
- the source code, or parts of the source code may have been previously compiled and cached in the resource cache 213 .
- a sub-code also referred to as a secondary source code
- the secondary source code may be referenced within the source code based on various conditions such as, for example, a user input, an output from another secondary source code, etc.
- data related to the source code such as, for example, type information may have been cached. The cached data can be used by the compiler to produce an executable code more efficiently.
- the code-caching platform 209 may obtain executable code compiled from the source code by sending the source code to a compiler within the client device 200 (not shown in FIG. 2 ) to be compiled into the executable code, and provide the executable code for execution on client device 200 . If the cached executable code corresponding to the source code or a secondary source code referenced in the source code is not found in the resource cache 213 , the code-caching platform 209 may select secondary source code referenced in the source code to be compiled. The code-caching platform 209 may cache executable code corresponding to the source code and/or executable code corresponding to the secondary source code. However, if cached executable code corresponding to the source code is found in the resource cache 213 , the cached executable code can be retrieved from the source cache and executed without a need for compilation of the source code.
- the executable code may include a set of references.
- the references included in the executable code can be memory addresses, for example, embedded in the executable code corresponding to the execution environment (e.g., a virtual machine 211 ) in which the executable code is being executed.
- the embedded addresses may not be portable from one execution context to another.
- the relocation data generated by abstracting the embedded addresses can be portable across execution contexts.
- the relocation data can be used to implement abstraction of embedded addresses in the executable code, for example, by restoring the non-portable addresses after porting.
- the serialization includes abstracting the set of references in the executable code from an execution context (e.g., the virtual machine 211 ).
- Execution context provides an operating environment within a computer system with access to processing power and memory for executing the executable code.
- the code-caching platform 209 generates relocation data associated with the executable code to reflect the abstractions such that further conversion of the abstracted references can be performed based on the generated relocation data.
- the code-caching platform 209 can store the serialized code for the source code and the selected secondary source code referenced in the source code as cached data in the resource cache 213 within the memory 205 .
- Conventional cache management strategies may be used for managing the resource cache.
- cache tags can be used for identifying cached data location in the resource cache.
- the code-caching platform 209 can also provide the executable code for execution in the virtual machine 211 .
- the code-caching platform 209 may receive, a second indication of the source code awaiting executing, in a different virtual machine environment.
- the client device 200 may have been restarted or rebooted.
- the code-caching platform 209 can check the resource cache 213 within memory 205 for cached executable code corresponding to the source code or the selected secondary source code referenced in the source code. Since the secondary source code has been previously compiled and cached in the resource cache 213 , cached executable code corresponding to the secondary source code can be found in the resource cache 213 . Upon the cache hit in the resource cache 213 , the code-caching platform 209 retrieves the cached data from the resource cache 213 within memory 205 .
- the cached code includes the serialized code corresponding to the references abstracted from the secondary source code during the previous compile.
- the code-caching platform 209 can deserialize the retrieved serialized codes, into new executable secondary source codes. Deserialization process extracts the code from a sequence of stored data, using information (e.g., relocation data) accompanying the serialized data about the initial code, types of objects referenced by the initial code, and the types of data stored in the objects.
- the executable code generated through deserialization has structure, characteristics and behavior, similar to the initial executable code. Therefore, execution of the executable code, and objects referenced by the executable code, by a computer performs the same tasks performed by execution of the initial code.
- Both the code and the objects referenced by the code are subject to serialization and deserialization.
- the deserialization may include restoring the set of references from each secondary source code in new executable secondary source code using the retrieved serialized code, such that the new executable secondary source code is executable in a new virtual machine environment established on the client device 200 upon restarting.
- the code-caching platform 209 can then provide the new executable secondary source code for execution in the new virtual machine environment on client device 200 .
- the new executable secondary source code may be executed with other secondary source code referenced in the source code that has not been cached and is being compiled for this execution.
- the code-caching platform 209 may select new secondary source code for caching at different executions of a source-code.
- the code-caching platform 209 may also replace previously selected and cached secondary source code with other, for example, more frequently executed secondary source code, based on an execution history of secondary source code of source code.
- code caching by the code-caching platform 209 may be performed within a client device 101 a or 101 b without communication with a server 109 a or 109 b via network 105 .
- the source code that is being serialized and deserialized by the code-caching platform 209 may be code locally stored on a memory of the client device 101 a or 101 n.
- FIG. 3 is a flow diagram of a code-caching platform by which compilation and serialization of source code and/or selected sun-codes referenced in the source code into cached code and deserialization of cached code into executable code may be provided.
- the code-caching platform 209 may include a front-end 303 , a serializing module 309 and a deserializing module 319 .
- the front-end 303 may include a check module 305 and a compression module 307 .
- the front-end 303 receives source code 301 .
- the check module 305 checks data store 313 (shown as arrow 311 ) for cached serialized code corresponding to the source code.
- the front-end 303 sends the source code to compiler 327 (shown as arrow 325 ).
- the compiler 327 compiles the source code and stores the executable code and references.
- the compiler 327 may store the executable code and references in a memory location associated with an execution environment 331 (not shown in FIG. 3 ).
- the executable code can be sent to execution environment 331 (shown as arrow 329 ) for execution within the execution environment 331 , for example a virtual machine similar to virtual machine 211 of FIG. 2 , within a browser session.
- the compiler 327 can send the executable code and references to the serializing module 309 for serialization (shown as 335 ).
- the front-end 303 may select parts (e.g. secondary source codes) referenced in the source code for serialization, for example, based on a frequency of execution of the parts in past executions or based on the frequency of function calls referring to those parts within the source code.
- the code-caching platform 209 can select source code and/or secondary source code referenced in the source code for serialization and caching based on various criteria (e.g., heuristics).
- Some example criteria can be: size of the source code or secondary source codes; age of the source code or secondary source codes (e.g., based on the last revision date or an expiration date of the source code or the secondary source code); usage frequency of the source code or secondary source codes (e.g., cache the code after nth encounter); a frequency of a cached code being replaced in the resource cache 213 ; number of times the secondary source code is referenced in the primary source code; or a compile time of the secondary source code.
- the code-caching platform 209 may select a secondary source code referenced in the source code for serialization and caching based on predicting that the secondary source code is referenced in the source code. For example, the code-caching platform 209 may predict that the secondary source code is referenced in the source code when the source code is being compiled. Compile results from the source code may indicate that the secondary source code will be referenced by the source code during execution.
- the code-caching platform 209 may serialize source code if the source code has a size smaller than a threshold S.
- the rationale is that serializing large pieces of code may take a long time and may require high volumes of memory (e.g., determined based on available disk space on the client device 101 a - 101 n ) to store the cached data.
- Other example criteria can be cache access latency (e.g., cache entry size); compile time of the source code or parts of the source code (e.g., record how long the initial compile of the source code took and factor the time into decision), memory capacity of the client device 101 a - 101 n hosting the resource cache 213 ; a frequency of the source code update (e.g., if the source code is updated frequently, caching the source code may not be beneficial); etc.
- the code-caching platform 209 may calculate a trade-off between the above factors prior to selection of code to serialize. For example, weight factors can be defined for the source code or for parts of the source code to determine a level of importance of various criteria discussed above. The trade-off calculation can be for example performed based on the weight factors defined.
- a trade-off between the code size and the memory capacity of the client device 101 a - 101 n may result in foregoing caching of a code with a large size that may occupy a considerable memory space on the client device 101 a - 101 n , even though the code is called frequently.
- the front-end can make a decision about whether to serialize the executable code and references. For example, some criteria may be defined by servers 109 a or 109 m for types of source code or parts of the source code to be serialized and types to be compiled and executed without serialization. In addition, certain types of source code may need to be verified prior to every execution of the source code for security purposes. In such cases, the front-end 303 may flag the source code or parts of the source code as source code not to be serialized.
- Another code caching criteria may include application of code caching to codes that are compiled more than a predefined number of times. For example, a first time a cache miss is detected, the source code can be compiled but not serialized or cached. The source code can be marked as “compiled once”, without serialization of the code being performed. Similarly, the source code can be marked with a counter indicating a number of times the source code has been compiled until a predefined threshold C is reached, upon the C th cache miss, the code-caching platform 209 can serialize and cache the source code. Alternatively, instead of a generic marker, a timestamp can be set on the first cache miss and the time difference between the first and the C th cache miss can be used to make the serialization decision. The criteria can be translated, for example, to “If the compiled code is executed at least C times a week, then cache the compiled code”. Other criteria for deciding to cache source code can be considered such as for example compilation time, produced code size, HTTP cache header data, etc.
- the code-caching platform 209 may use execution data of the source code for selecting the secondary source code to be cached and used further in subsequent executions.
- the execution data may include, for example, other pieces of code that the executed source code references during execution, execution profile of the source code, whether the source code is executed often enough (e.g., more than a predefined number of times) to make caching worthwhile, type (e.g., user defined data structures) information observed during the execution, etc.
- the execution data may also be serialized, so that the data can be deserialized in an execution context. After deserialization, the execution data may be used alongside the deserialized code. For example, the execution profile may be used in the execution context to decide whether or not to spend time to optimize the executable code.
- Dynamically-typed languages such as, for example, JAVASCRIPT® provide an abundance of type information for objects defined in the source code.
- the dynamic types enable an object of the source code to have different types during different executions of the source code.
- observing various executions of source code may provide insights as to how often the type of an object varies.
- the type T of a particular object O can be determined based on the object content. However, when a source code interacts with object O, the source code does not have access to the type information and therefore the object type T is unknown to the source code. As a result, the source code needs to determine type T prior to accessing object O.
- the code caching platform 209 determines and caches the object type T. For example, the code caching platform 209 may observe, in the source code, a particular type of object at the time object O is accessed in an execution environment (e.g., in a website). The code caching platform 209 can associate the access website with type T of object accessed by the website.
- the code caching platform 209 can also cache the “how to access” information that was determined at the access time. Subsequently, when object O is accessed by a source code at the same execution environment, expected type T and access method for accessing object O are known from the cached data. The code caching platform 209 can also check whether the expected type T is the same as the type of the object at the current access. If the types match, the cached access method can be used for accessing object O without further determination of the access method needed.
- the object type T can provide information on access method for accessing object O in an execution context. Once the access method for accessing object O is determined, information about the access method can be stored in resource cache as type information and associated with the access method, during serializing. Using the stored type information, at the time of deserialization, subsequent accesses to object O can be made faster, without having to determine the access method.
- the serialization by the serializing module 309 can abstract references within the executable code by replacing addresses within the executable code with abstract addresses.
- the serializing module 309 provides serialized code corresponding to executable code and relocation data corresponding to the abstraction of the references within the executable code to front-end 303 (shown as 323 ).
- the serializing module 309 can find relevant parts and references corresponding to the executable code and references from the execution environment 331 .
- the serializing module 309 can convert the parts and references into a contiguous binary representation, independent from the execution environment 331 , to be included in the serialized code.
- the front-end 303 can store the serialized code produced by the serializing module 309 in data store 313 as cached serialized code.
- the serializing module 309 may encode the serialized code corresponding to the abstraction using a tag to differentiate the code from other data types within the serialized code.
- the front-end 303 may receive a new request for execution of the source code within a different execution environment 333 , for example a new VM within a new browser session.
- the check module 305 may successfully find the cached serialized code in data store 313 (cache hit).
- the front-end 303 can load the cached serialized code from data store 313 (shown as 317 ) and send the loaded cached serialized code to the deserializing module 319 .
- the front-end 303 can determine whether the cached serialized code corresponds to the same version of the source code.
- the front-end 303 may decide not to deserialize the cached serialized code and send a request to compiler 327 for the source code to be compiled.
- the front-end 303 may also evict the outdated cached codes to free up memory space.
- the front-end 303 may determine the versions of the cached serialized code and the source code based on a standard version confirmation process provided by a communication protocol within network 105 such as, for example the Hypertext Transfer Protocol (HTTP).
- HTTP Hypertext Transfer Protocol
- the deserializing module 319 Upon obtaining the cached serialized code from data store 313 , the deserializing module 319 verifies validity of the cached serialized code and deserializes the cached serialized code into executable code and references using relocation data within the serialized code. The deserializing module 319 sends the executable code and references to the execution environment 333 for execution (shown as 321 ). If the serialized code corresponds to parts of the source code, the parts of the source code that have not been cached can be compiled into executable code by compiler 327 and the executable code can be combined with the deserialized executable code prior to being executed in the execution environment 333 .
- serializing module 309 and the deserializing module 319 may be activated within different execution environments 331 and 333 .
- the serialized code is generated within execution environment 331 (where the executable code and references are generated and executed), while the executable code and references provided by the deserializing module 319 are generated in a subsequent execution environment 333 .
- the compression module 307 may compress the data, for example, by applying various compression algorithms on the serialized code prior to storing the serialized code in data store 313 .
- the compression module 307 may also decompress the cached serialized code prior to sending the cached serialized code to the deserializing module 319 .
- the cached serialized code can be used as a context independent full representation of the executable code and references in a different execution environment.
- the deserializing module 319 can mimic behavior of the compiler 327 when generating the executable code and references for execution environment 331 . Therefore, after deserialization of the cached serialized code into the executable code and references, execution of the executable code and references within an execution environment 333 can provide results equivalent of execution of the executable code and references provided by compiler 327 within the execution environment 331 .
- the process of deserialization by the deserializing module 319 can restore references using the relocation data within metadata 315 such that the references reflect differences between the execution environment 331 and the execution environment 333 .
- the serializing and the deserializing may run in different execution environments (e.g., VM instances)
- memory addresses of the executable code and references corresponding to the execution environment 331 may not be valid in the execution environment 333 .
- the serialization and deserialization ensure that the memory addresses in the deserialized executable code and references are valid addresses within the execution environment 333 .
- references to function addresses in the execution environment are not encoded verbatim by the serializing module 309 because those function addresses may be different between different execution environments 331 and 333 .
- the serializing module 309 may inspect each object within the source code and the executable code and references to determine how each object should be serialized. For example, certain unique objects (e.g. the canonical undefined-value) may be included in the executable code and references within an abstract index (e.g., root array). When such a unique object is serialized by the serializing module 309 , the serializing module 309 serializes the object by a unique abstract index. Upon deserialization of the unique object by the deserializing module 319 , the index is used for identifying the object.
- certain unique objects e.g. the canonical undefined-value
- an abstract index e.g., root array
- the source code may include built-in code, which are generated pieces of executable code that perform elementary tasks.
- the built-in code may be shared by multiple objects within the source code and therefore should be always available within the execution environment 331 (or 333 ).
- the serializing module 309 can map each built-in code to a built-in identifier and serializes the built-in identifier as a representative of the built-in code in the serialized code.
- the front-end 303 can find a built-in object with the same identifier in the execution environment 333 .
- the source code may include code-stub.
- Code-stub is similar to a built-in code, except that code-stubs can be generated on-demand and are not necessarily available on the execution environment 333 .
- the serializing module 309 can map code-stub to code-stub key when generating the serialized code.
- the front-end 303 can check whether the execution environment 333 includes the code-stub. If the execution environment 333 does not include the code-stub, the code-stub corresponding to the code-stub key is generated by the deserializing module 319 .
- the source code may include unique string literals.
- the unique string literals can be serialized verbatim, by the serializing module 309 .
- the front-end 303 checks whether that same string literal already exists in the execution environment 333 . If the unique string literal exists in the execution environment 333 , the deserializing module 319 canonicalizes the string literal to the already existing unique string. Canonicalization process converts the string literal with more than one representation (e.g., one representation in the cached serialized code and a second representation in the execution environment 333 ) into a standard or canonical form.
- objects that are serialized have references to a source string of the source code.
- the serializing module 309 can replace the object with a special representation.
- the deserializing module 319 can replace the special code with a reference to the source string that is provided separately at the time of deserializing within the execution environment 333 .
- addresses embedded into the executable code can be addresses of certain values in the execution environment or addresses of functions of the VM.
- the addresses of certain values in the execution environment and addresses of functions of the VM are known to the compiler and to the VM. These addresses can, for example, be represented by a reference identifier and the reference identifier can be used to restore the address when deserializing.
- the source code may include non-unique objects.
- the non-unique objects can be serialized as copies.
- the non-unique objects may consist of data fields and references to other objects. When serializing, the data fields can be copied and references to other objects, if unique, can be serialized as previously discussed with regard to unique objects.
- the following example describes a code-caching process from compilation to serialization and deserialization of a sample code.
- the sample JAVASCRIPT® code (A) is considered in this example.
- function foo ( ) ⁇ return 1; ⁇ foo ( );
- the executable code for sample code (A) may include instructions such as: function header, instructions to check against on stack overflow (calling stack overflow built-in), variable declaration “foo”, instantiation of closure for inner function ( ) ⁇ return 1; ⁇ , assigning closure to a global property named “foo”, loading a global property named “foo”, calling the loaded property, and returning undefined value.
- the executable code for sample code (A) may include references to relocation information, where the relocation information may indicate that: the stack overflow built-in is a built-in, the string literal “foo” is an object on the heap, the function description for ( ) ⁇ return 1; ⁇ is an object on the heap, the function closure initialization is implemented as run-time call and as such is an external reference, loading property is a call to a stub, calling property is a call to a stub, and the undefined value can be an object on the heap, for example a unique object as previously discussed with regards to FIG. 3 .
- the executable code for sample code (A) may also include metadata associated with the string literal “foo” such as, for example, “foo” is an object of type “internalized string” denoted by a map object, the string content is “foo”, and the length of the string is 3.
- the executable code for sample code (A) may also include function descriptions for the top-level function, and the inner function ( ) ⁇ return 1; ⁇ .
- the function descriptions may be objects of type “shared function information” denoted by a map object.
- the function descriptions may contain character positions for start and end points in the source code.
- the function descriptions may also point to the compiled code, if the sample code (A) has already been compiled.
- the inner function “foo” is compiled lazily.
- Lazy compilations means that the inner function “foo” is not compiled when the top-level code is compiled, but only a description of the inner function “foo” is created during the compilation of the top-level code.
- the inner function “foo” is eventually called (e.g., during an execution of the top-level code)
- the inner function “foo” is compiled on demand.
- an executable code for it does not exist and the executable code for the inner function cannot be serialized.
- a code-caching platform 209 may recognize that the inner function “foo” is called within the top-level code (“foo” is defined and called in sample code (A)). Having this recognition, the code-caching platform 209 can eagerly compile the inner function “foo” as part of compiling the top-level code and include the compiled code of the inner function “foo” in compilation of the top-level code and used the compiled code for serializing after compiling the top-level code.
- Another way for including the compiled code for the inner function “foo” in the serialized code is for the code-caching platform 209 to execute the top-level code at least once prior to serialization. Since the inner function “foo” is called during the execution of the top-level code, “foo” can be lazily compiled, as discussed above, and the compiled code can be stored in a memory. In this case, when serializing the top-level code afterwards, the inner function description for “foo” (created during the initial compilation of the top-level code) points to the lazily compiled code of the inner function “foo”. This can cause the code-caching platform 209 to serialize the inner function “foo” when serializing the top-level code.
- the serializing module 309 can serialize the sample code (A) by visiting the object graph, traversing references, starting at the function description for the top-level code.
- the code-caching platform 209 may keep a history of the objects already visited in data store 313 such that an object is not serialized more than once or run into an infinite loop.
- the objects that have already been visited and serialized can be represented (encoded) as back references.
- An object may contain either content or references to other objects. Object contents can be serialized verbatim.
- references to other objects can be either references to known objects, or references to objects that also need to be serialized.
- the function description may have a reference to the “shared function information” map, and to the compiled code for the function.
- Map objects encountered by the serializing module 309 can be canonical objects and part of the root list.
- the serializing module 309 may find the map objects in the root list and use the root list index to represent the objects.
- the code object for the top-level function can be serialized verbatim aside from the references to its map (for code objects) and the reference to the relocation information.
- the instruction stream may contain embedded pointers described by the relocation information. These pointers are also visited during serialization. Since the pointers need to be updated upon deserialization, they can be replaced by zero (0) values before serialized verbatim.
- the code object of the top-level function points to the function description of the inner function “foo”. If the inner function “foo” has already been compiled at this point, its function description points to the compiled code such that the serializing module 309 can traverse from the top-level function to the inner function “foo” and serialize the code objects of both top-level and inner functions.
- code stubs can be represented by a code stub key and built-ins can be represented by built-in IDs.
- String content can be serialized verbatim (aside from the string map) and external references can be mapped to external reference IDs.
- the process of deserialization by the deserializing module 319 may include retracing the order in which the serialization was performed by visiting the object graph. This tracing can be used to translate serialized code representations back to the counterparts in the execution environment 333 in which the deserialized code can be executed. For example, if an undefined value has been encoded as a root list index during serialization, the deserializing module 319 can use the root list index to find the undefined value in the execution environment 333 . In addition, back references can be translated back to references to objects that have already been deserialized.
- the deserialization result can be the function description for the top-level function.
- FIGS. 4A-4B illustrate examples of processes by which serialization of code into cached code may be provided.
- FIGS. 4A-4B are described with reference to FIGS. 1, 2 and 3 , the subject technology is not limited to such and can apply to other client devices and systems.
- FIG. 4A illustrates an example of a process for serializing code into cached code.
- the front-end 303 receives an indication (e.g., a link, an address, a URL, etc.) of a primary source code awaiting execution.
- the primary source code can be a script in a web page for execution in a current browser session.
- a user of the client device 101 a or 101 n hosting the code-caching platform 103 a or 103 n of FIG. 1 (or code-caching platform 209 of FIG. 2 ) may request execution of the primary source code by entering a URL address in the current browser session.
- the URL address may provide a link for loading a web page, which includes the embedded primary source code.
- the browser may send the indication of the primary source code to front-end 303 .
- the check module 305 checks a resource cache in data store 313 for cached data corresponding to the primary source code.
- the web page may have been loaded in another browser session prior to the current browser session and the code-caching platform 209 may have stored the executable code corresponding to the primary source code in data store 313 . If data store 313 includes an executable code corresponding to the primary source code, the checking of block 403 may return a cache hit. However, if the check at block 403 does not find a hit, the returned result may be a cache miss (shown as block 405 ).
- the front-end 303 can obtain executable code compiled from the primary source code. For example, the front-end 303 can send the primary source code to compiler 327 for compiling.
- the front-end 303 can select parts of the source code or secondary source code referenced in the primary source code.
- the secondary source code can be a function referenced in the primary source code.
- the selection of the parts of the source code can be based on various factors and criteria (heuristics) as discussed with respect to FIGS. 2 and 3 .
- the front-end 303 can obtain executable code compiled from the secondary source code.
- the front-end 303 can send the secondary source code to compiler 327 for compiling.
- the front-end 303 may send an entire source code including the primary source code and a set of secondary source codes referenced in the primary source code to the compiler without selecting the parts.
- the front-end 303 may send the source code, and/or selected secondary source codes referenced in the source code, to compiler 327 .
- Compiler 327 compiles the received primary source code or the secondary source code and sends the executable code to the serializing module 309 .
- the compiler 327 may store the executable code in a memory of the client device 101 a or 101 n .
- the executable code includes a set of references such as addresses and identifiers corresponding to objects in the source code, or the selected parts.
- the set of references corresponding to the executable code may include memory addresses embedded in the executable code corresponding to the execution environment 331 .
- the execution environments 331 (or 333 ) can be VMs within the web browser session in which the source code is executed.
- the references provide execution data for the executable code 329 to processor 201 when executing the executable code in an execution environment 331 , for example a VM environment created by an execution engine (not shown) for the executable code.
- the serializing module 309 serializes the executable code.
- the serialization includes abstracting the set of references in the executable code from the execution environment 331 and defining relocation data associated with the serialized code to reflect the abstractions, as previously discussed with regard to FIGS. 2 and 3 .
- Abstracting the set of references from the execution environment 331 by the serializing module 309 may include replacing embedded memory addresses with abstract addresses. For example, an embedded address can be converted to a function of the VM into a particular index in a predefined list of functions.
- an abstract address can be generated by replacing a memory address with an offset address from a starting address of a block of memory assigned to the executable code, and the embedded address may be converted into the relative offset from the start of the code.
- the front-end 303 stores the serialized code as cached data in a resource cache in data store 313 to be provided for execution in the execution environment 331 .
- the front-end 303 may determine availability of a processor 201 for performing the serializing. In such instances, if a processor is not available, the front-end 303 may delay the serializing until the processor becomes available.
- the source code may include references to multiple secondary source codes (e.g., functions).
- the executable code may include multiple executable secondary source codes such that each executable secondary source code corresponds to a secondary source code referenced in the source code.
- the front-end 303 can select executable secondary source code for serialization.
- the front-end 303 may also determine executable secondary source code to remain un-serialized within the serialized code.
- the front-end 303 may determine the deserializing of the secondary source code based on the references associated with the executable code, based on the relocation data, based on a type of the secondary source codes, based on a security identifier of the secondary source codes, etc.
- the source code may be a top-level script of an application 207 .
- the front-end 303 may select the top-level script of application 207 for serialization as source code, for example, based on predefined conditions.
- the front-end 303 may receive an indication (e.g., a link, an address, a URL, etc.) of the primary source code awaiting execution.
- the primary source code can be a script in a web page.
- the check module 305 checks the resource cache in data store 313 for cached data corresponding to the primary source code and to the secondary source code selected at block 409 of FIG. 4A . Upon a cache hit in the resource cache in data store 313 , the front-end 303 can retrieve the cached data including the serialized code from the resource cache in the data store 313 .
- the deserializing module 319 can deserialize the retrieved cached serialized code into executable code.
- the deserialization by the deserializing module 319 may include restoring, using the retrieved cached serialized code, the set of references in the executable code based on an execution environment 333 .
- the front-end 303 can provide the executable code and references for execution in the execution environment 333 .
- the deserialization by the deserializing module 319 may fail, for example due to data corruption.
- the front-end 303 can delete the cached serialized code from data store 313 . Therefore, the next time an indication of the source code awaiting execution is received, the check by the check module 305 may return a cache miss, as shown at block 403 of FIG. 4A , and the serializing process according to FIG. 4A can be performed.
- the selection of secondary source code of block 409 may be based on execution results obtained from execution of the executable code obtained at block 407 .
- the first executable code obtained at block 407 may be executed once or multiple times prior to selection of the secondary code.
- the code-caching platform 209 may obtain the execution results from execution of the first executable code in a first execution context and select the secondary source code based on the execution results.
- the code-caching platform 209 may collect data related to the execution to determine secondary source codes (e.g., functions) that are referenced and executed.
- the code-caching platform 209 may select the executed secondary source codes for caching instead of caching the entire source code. Because according to various conditions within the primary source code, conditions related to the execution environment on client device 200 , user input, etc., some secondary source codes (e.g., functions) may be executed and some may not.
- the code-caching platform 209 can determine secondary source codes that are executed by collecting data related to multiple executions of the primary source code on the client device 200 and determine secondary source codes that are executed more often that other secondary source codes.
- the code-caching platform 209 can select the secondary source code for caching based on the determination.
- the code-caching platform 209 may also determine function calls within the primary source code where each function call includes execution of a function.
- the code-caching platform 209 may collect information about execution of the function calls and select the functions that are being executed during the executing for caching.
- the code-caching platform 209 may select the secondary source code based on various other factors such as, for example, size of the secondary source code, size of the secondary executable code, number of times the secondary source code is referenced in the primary source code, compile time of the secondary source code, etc. For example,
- FIG. 4B illustrates an example of a process for serializing code into cached code based on a set of conditions.
- the front-end 303 receives an indication (e.g., a link, an address, a URL, etc.) of a primary source code awaiting execution.
- the check module 305 checks a resource cache in data store 313 for cached data corresponding to the primary source code, as previously discussed with respect to FIG. 4A . If the check at block 423 does not find a hit, the returned result may be a cache miss (shown as block 425 ).
- the front-end 303 can obtain executable code compiled from the primary source code. For example, the front-end 303 can send the primary source code to compiler 327 for compiling.
- the serializing module 309 serializes the executable code into serialized code based on size of the primary source code, number of times or frequency the primary source code is executed in a predefined period of time, compile time of the primary source code, or a combination thereof. For example, if the primary source code is executed less than 10 times during a week, the serializing module 309 may forego serializing the primary source code. However, a primary source code that is executed more often (e.g., more than 10 times during a week) may be serialized.
- the front-end 303 stores the serialized code as cached data in a resource cache in data store 313 to be provided for execution in an execution environment 331 or 333 .
- aspects of the subject technology are described in terms of caching executable code for execution in different execution environments such as instances of web browsers, where the data is serialized in one web browsing session and deserialized in another web browser session.
- the subject technology is not limited to the web browser environment.
- the subject technology may be applicable to caching executable code in any execution environment.
- the subject technology may be applicable to serializing and caching data in a first client device 101 a - 101 n of FIG. 1 (or server 109 a - 109 m of FIG.
- the above-described features and applications can be implemented as software processes that are specified as a set of instructions recorded on a computer readable storage medium (also referred to as computer readable medium).
- processing unit(s) e.g., processors, cores of processors, or other processing units
- processing unit(s) e.g., processors, cores of processors, or other processing units
- processing unit(s) e.g., processors, cores of processors, or other processing units
- Examples of computer readable media include, but are not limited to, CD-ROMs, flash drives, RAM chips, hard drives, EPROMs, etc.
- the computer readable media does not include carrier waves and electronic signals passing wirelessly or over wired connections.
- the term “software” is meant to include firmware residing in read-only memory or applications stored in magnetic storage, which can be read into memory for processing by a processor.
- multiple software technologies can be implemented as sub-parts of a larger program while remaining distinct software technologies.
- multiple software technologies can also be implemented as separate programs.
- any combination of separate programs that together implement a software technology described here is within the scope of the subject technology.
- the software programs when installed to operate on electronic systems, define specific machine implementations that execute and perform the operations of the software programs.
- a computer program (also known as source code, program, software, software application, script, code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages.
- the computer program can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment.
- a computer program may, but need not, correspond to a file in a file system.
- a program can be stored in a portion of a file that holds other programs or data (e.g., scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store modules, sub programs, or portions of code).
- a computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
- FIG. 5 conceptually illustrates an example electronic system with which some implementations of the subject technology can be implemented.
- Electronic system 500 can be a computer, phone, PDA, or any other sort of electronic device. Such an electronic system includes various types of computer readable media and interfaces for various other types of computer readable media.
- Electronic system 500 includes a bus 508 , processing unit(s) 512 , a system memory 504 , a read-only memory (ROM) 510 , a permanent storage device 502 , an input device interface 514 , an output device interface 506 , and a network interface 516 .
- processing unit(s) 512 includes a bus 508 , processing unit(s) 512 , a system memory 504 , a read-only memory (ROM) 510 , a permanent storage device 502 , an input device interface 514 , an output device interface 506 , and a network interface 516 .
- ROM read-only memory
- Bus 508 collectively represents all system, peripheral, and chipset buses that communicatively connect the numerous internal devices of electronic system 500 .
- bus 508 communicatively connects processing unit(s) 512 with ROM 510 , system memory 504 , and permanent storage device 502 .
- processing unit(s) 512 retrieves instructions to execute and data to process in order to execute the processes of the subject disclosure.
- the processing unit(s) can be a single processor or a multi-core processor in different implementations.
- ROM 510 stores static data and instructions that are needed by processing unit(s) 512 and other modules of the electronic system.
- Permanent storage device 502 is a read-and-write memory device. This device is a non-volatile memory unit that stores instructions and data even when electronic system 500 is off. Some implementations of the subject disclosure use a mass-storage device (for example, a magnetic or optical disk and its corresponding disk drive) as permanent storage device 502 .
- system memory 504 is a read-and-write memory device. However, unlike storage device 502 , system memory 504 is a volatile read-and-write memory, such a random access memory. System memory 504 stores some of the instructions and data that the processor needs at run-time. In some implementations, the processes of the subject disclosure are stored in system memory 504 , permanent storage device 502 , or ROM 510 .
- the various memory units include instructions for presenting web elements in accordance with some implementations. From these various memory units, processing unit(s) 512 retrieves instructions to execute and data to process in order to execute the processes of some implementations.
- Bus 508 also connects to input and output device interfaces 514 and 506 .
- Input device interface 514 enables the user to communicate information and select commands to the electronic system.
- Input devices used with input device interface 514 include, for example, alphanumeric keyboards and pointing devices (also called “cursor control devices”).
- Output device interfaces 506 enables, for example, the display of images generated by the electronic system 500 .
- Output devices used with output device interface 506 include, for example, printers and display devices, for example, cathode ray tubes (CRT) or liquid crystal displays (LCD). Some implementations include devices, for example, a touchscreen that functions as both input and output devices.
- CTR cathode ray tubes
- LCD liquid crystal displays
- bus 508 also couples electronic system 500 to a network (not shown) through a network interface 516 .
- the computer can be a part of a network of computers (for example, a local area network (“LAN”), a wide area network (“WAN”), or an Intranet, or a network of networks, for example, the Internet. Any or all components of electronic system 500 can be used in conjunction with the subject disclosure.
- Some implementations include electronic components, for example, microprocessors, storage and memory that store computer program instructions in a machine-readable or computer-readable medium (alternatively referred to as computer-readable storage media, machine-readable media, or machine-readable storage media).
- computer-readable media include RAM, ROM, read-only compact discs (CD-ROM), recordable compact discs (CD-R), rewritable compact discs (CD-RW), read-only digital versatile discs (e.g., DVD-ROM, dual-layer DVD-ROM), a variety of recordable/rewritable DVDs (e.g., DVD-RAM, DVD-RW, DVD+RW, etc.), flash memory (e.g., SD cards, mini-SD cards, micro-SD cards, etc.), magnetic or solid state hard drives, read-only and recordable Blu-Ray® discs, ultra density optical discs, any other optical or magnetic media, and floppy disks.
- CD-ROM compact discs
- CD-R recordable compact discs
- the computer-readable media can store a computer program that is executable by at least one processing unit and includes sets of instructions for performing various operations.
- Examples of computer programs or computer code include machine code, for example, is produced by a compiler, and files including higher-level code that are executed by a computer, an electronic component, or a microprocessor using an interpreter.
- ASICs application specific integrated circuits
- FPGAs field programmable gate arrays
- integrated circuits execute instructions that are stored on the circuit itself.
- the terms “computer”, “server”, “processor”, and “memory” all refer to electronic or other technological devices. These terms exclude people or groups of people.
- display or displaying means displaying on an electronic device.
- computer readable medium and “computer readable media” are entirely restricted to tangible, physical objects that store information in a form that is readable by a computer. These terms exclude any wireless signals, wired download signals, and any other ephemeral signals.
- implementations of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used
- Implementations of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of such back end, middleware, or front-end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network.
- Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
- LAN local area network
- WAN wide area network
- inter-network e.g., the Internet
- peer-to-peer networks e.g., ad hoc peer-to-peer networks.
- the computing system can include clients and servers.
- a client and server are generally remote from each other and may interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device).
- client device e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device.
- Data generated at the client device e.g., a result of the user interaction
- any specific order or hierarchy of steps in the processes disclosed is an illustration of example approaches. Based upon design preferences, it is understood that the specific order or hierarchy of steps in the processes may be rearranged, or that all illustrated steps be performed. Some of the steps may be performed simultaneously. For example, in certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the implementations described above should not be understood as requiring such separation in all implementations, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
- a phrase such as an “aspect” does not imply that such aspect is essential to the subject technology or that such aspect applies to all configurations of the subject technology.
- a disclosure relating to an aspect may apply to all configurations, or one or more configurations.
- a phrase such as an aspect may refer to one or more aspects and vice versa.
- a phrase such as a “configuration” does not imply that such configuration is essential to the subject technology or that such configuration applies to all configurations of the subject technology.
- a disclosure relating to a configuration may apply to all configurations, or one or more configurations.
- a phrase such as a configuration may refer to one or more configurations and vice versa.
Abstract
Description
function foo ( ) {return 1;}
foo ( ); (A)
The executable code for sample code (A) may include instructions such as: function header, instructions to check against on stack overflow (calling stack overflow built-in), variable declaration “foo”, instantiation of closure for inner function ( ) { return 1;}, assigning closure to a global property named “foo”, loading a global property named “foo”, calling the loaded property, and returning undefined value.
Claims (22)
Priority Applications (8)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/726,376 US9811324B2 (en) | 2015-05-29 | 2015-05-29 | Code caching system |
KR1020177028178A KR101851357B1 (en) | 2015-05-29 | 2016-03-29 | Code-caching system |
CN201680019416.5A CN107408055B (en) | 2015-05-29 | 2016-03-29 | Code cache system |
DE112016002416.9T DE112016002416T5 (en) | 2015-05-29 | 2016-03-29 | CODE INTERMEDIATE SYSTEM |
GB1715440.2A GB2553444B (en) | 2015-05-29 | 2016-03-29 | Code caching system |
PCT/US2016/024791 WO2016195790A1 (en) | 2015-05-29 | 2016-03-29 | Code caching system |
EP16715430.1A EP3304293B1 (en) | 2015-05-29 | 2016-03-29 | Code caching system |
JP2017551130A JP6329329B2 (en) | 2015-05-29 | 2016-03-29 | Code caching system |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/726,376 US9811324B2 (en) | 2015-05-29 | 2015-05-29 | Code caching system |
Publications (2)
Publication Number | Publication Date |
---|---|
US20160350089A1 US20160350089A1 (en) | 2016-12-01 |
US9811324B2 true US9811324B2 (en) | 2017-11-07 |
Family
ID=57398598
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/726,376 Expired - Fee Related US9811324B2 (en) | 2015-05-29 | 2015-05-29 | Code caching system |
Country Status (8)
Country | Link |
---|---|
US (1) | US9811324B2 (en) |
EP (1) | EP3304293B1 (en) |
JP (1) | JP6329329B2 (en) |
KR (1) | KR101851357B1 (en) |
CN (1) | CN107408055B (en) |
DE (1) | DE112016002416T5 (en) |
GB (1) | GB2553444B (en) |
WO (1) | WO2016195790A1 (en) |
Families Citing this family (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20170123760A1 (en) * | 2015-10-30 | 2017-05-04 | AppDynamics, Inc. | Code Correction During a User Session in a Distributed Business Transaction |
US11360750B1 (en) * | 2020-12-23 | 2022-06-14 | Sony Interactive Entertainment LLC | Systems and methods for converting a legacy code into an updated code |
US20220387886A1 (en) * | 2021-06-07 | 2022-12-08 | Sony Interactive Entertainment LLC | Systems and methods for emulation of graphical and audio parameters during a play of a legacy game |
CN114328061B (en) * | 2021-12-30 | 2024-03-29 | 湖南泛联新安信息科技有限公司 | High-performance signal monitoring method for logic simulation system |
Citations (26)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5530964A (en) | 1993-01-29 | 1996-06-25 | International Business Machines Corporation | Optimizing assembled code for execution using execution statistics collection, without inserting instructions in the code and reorganizing the code based on the statistics collected |
US6393415B1 (en) * | 1999-03-31 | 2002-05-21 | Verizon Laboratories Inc. | Adaptive partitioning techniques in performing query requests and request routing |
US20020184618A1 (en) * | 2001-06-04 | 2002-12-05 | Vasanth Bala | Networked client-server architecture for transparently transforming and executing applications |
US20050015758A1 (en) * | 2003-07-15 | 2005-01-20 | Geraint North | Shared code caching method and apparatus for program code conversion |
US20050028155A1 (en) * | 2002-12-02 | 2005-02-03 | Samsung Electronics Co., Ltd. | Java execution device and Java execution method |
US20050050547A1 (en) * | 2003-08-29 | 2005-03-03 | Whittle Derrick W. | Method and apparatus for providing desktop application functionality in a client/server architecture |
US20060179278A1 (en) * | 2005-02-08 | 2006-08-10 | Masakazu Suzuoki | Methods and apparatus for instruction set emulation |
US20060206874A1 (en) | 2000-08-30 | 2006-09-14 | Klein Dean A | System and method for determining the cacheability of code at the time of compiling |
US7389317B2 (en) | 1993-11-30 | 2008-06-17 | Texas Instruments Incorporated | Long instruction word controlling plural independent processor operations |
US20080263527A1 (en) * | 2007-04-18 | 2008-10-23 | Sony Computer Entertainment Inc. | Processor emulation using speculative forward translation |
US20090055821A1 (en) * | 2007-08-22 | 2009-02-26 | International Business Machines Corporation | Systems, methods, and computer products for just-in-time compilation for virtual machine environments for fast application startup and maximal run-time performance |
US20090307430A1 (en) | 2008-06-06 | 2009-12-10 | Vmware, Inc. | Sharing and persisting code caches |
US7761857B1 (en) * | 1999-10-13 | 2010-07-20 | Robert Bedichek | Method for switching between interpretation and dynamic translation in a processor system based upon code sequence execution counts |
US20110173597A1 (en) | 2010-01-12 | 2011-07-14 | Gheorghe Calin Cascaval | Execution of dynamic languages via metadata extraction |
US20110179347A1 (en) | 2009-09-30 | 2011-07-21 | Iain Andrew Russell Proctor | High performance php |
US20110307876A1 (en) * | 2010-06-14 | 2011-12-15 | Ottoni Guilherme D | Register mapping techniques for efficient dynamic binary translation |
US20110321010A1 (en) | 2010-06-24 | 2011-12-29 | Yifei Wang | Web application framework based on object oriented class mapping |
US8095507B2 (en) | 2008-08-08 | 2012-01-10 | Oracle International Corporation | Automated topology-based statistics monitoring and performance analysis |
US20120185822A1 (en) | 2011-01-13 | 2012-07-19 | Joo-Hwan Lee | Web browsing apparatus and method through storing and optimizing javascript® code |
US20120278558A1 (en) * | 2011-04-26 | 2012-11-01 | International Business Machines Corporation | Structure-Aware Caching |
US20120317363A1 (en) * | 2011-05-25 | 2012-12-13 | Nokia Corporation | Memory Caching for Browser Processes |
US8392881B1 (en) | 2008-05-13 | 2013-03-05 | Google Inc. | Supporting efficient access to object properties in a dynamic object-oriented programming language |
US20130159978A1 (en) | 2011-12-16 | 2013-06-20 | Microsoft Corporation | State capture after execution in dependent sequences |
US20130212567A1 (en) * | 2012-02-13 | 2013-08-15 | Microsoft Corporation | Generating and caching software code |
US20140095802A1 (en) * | 2012-09-28 | 2014-04-03 | Oracle International Corporation | Caching Large Objects In A Computer System With Mixed Data Warehousing And Online Transaction Processing Workload |
US20140095778A1 (en) * | 2012-09-28 | 2014-04-03 | Jaewoong Chung | Methods, systems and apparatus to cache code in non-volatile memory |
Family Cites Families (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8402224B2 (en) | 2005-09-20 | 2013-03-19 | Vmware, Inc. | Thread-shared software code caches |
JP2007233472A (en) * | 2006-02-27 | 2007-09-13 | Canon Inc | Information processor, and control method and control program of information processor |
-
2015
- 2015-05-29 US US14/726,376 patent/US9811324B2/en not_active Expired - Fee Related
-
2016
- 2016-03-29 CN CN201680019416.5A patent/CN107408055B/en active Active
- 2016-03-29 DE DE112016002416.9T patent/DE112016002416T5/en not_active Withdrawn
- 2016-03-29 KR KR1020177028178A patent/KR101851357B1/en active IP Right Grant
- 2016-03-29 WO PCT/US2016/024791 patent/WO2016195790A1/en active Application Filing
- 2016-03-29 GB GB1715440.2A patent/GB2553444B/en active Active
- 2016-03-29 EP EP16715430.1A patent/EP3304293B1/en active Active
- 2016-03-29 JP JP2017551130A patent/JP6329329B2/en active Active
Patent Citations (35)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5530964A (en) | 1993-01-29 | 1996-06-25 | International Business Machines Corporation | Optimizing assembled code for execution using execution statistics collection, without inserting instructions in the code and reorganizing the code based on the statistics collected |
US7389317B2 (en) | 1993-11-30 | 2008-06-17 | Texas Instruments Incorporated | Long instruction word controlling plural independent processor operations |
US6393415B1 (en) * | 1999-03-31 | 2002-05-21 | Verizon Laboratories Inc. | Adaptive partitioning techniques in performing query requests and request routing |
US7761857B1 (en) * | 1999-10-13 | 2010-07-20 | Robert Bedichek | Method for switching between interpretation and dynamic translation in a processor system based upon code sequence execution counts |
US20060206874A1 (en) | 2000-08-30 | 2006-09-14 | Klein Dean A | System and method for determining the cacheability of code at the time of compiling |
US7640153B2 (en) * | 2001-06-04 | 2009-12-29 | Hewlett-Packard Development Company, L.P. | Networked client-server architecture for transparently transforming and executing applications |
US20020184618A1 (en) * | 2001-06-04 | 2002-12-05 | Vasanth Bala | Networked client-server architecture for transparently transforming and executing applications |
US20050028155A1 (en) * | 2002-12-02 | 2005-02-03 | Samsung Electronics Co., Ltd. | Java execution device and Java execution method |
US20050015758A1 (en) * | 2003-07-15 | 2005-01-20 | Geraint North | Shared code caching method and apparatus for program code conversion |
US7805710B2 (en) * | 2003-07-15 | 2010-09-28 | International Business Machines Corporation | Shared code caching for program code conversion |
US7890961B2 (en) * | 2003-08-29 | 2011-02-15 | Yahoo! Inc. | Method and apparatus for providing desktop application functionality in a client/server architecture |
US20050050547A1 (en) * | 2003-08-29 | 2005-03-03 | Whittle Derrick W. | Method and apparatus for providing desktop application functionality in a client/server architecture |
US20060179278A1 (en) * | 2005-02-08 | 2006-08-10 | Masakazu Suzuoki | Methods and apparatus for instruction set emulation |
US7818724B2 (en) * | 2005-02-08 | 2010-10-19 | Sony Computer Entertainment Inc. | Methods and apparatus for instruction set emulation |
US8245202B2 (en) * | 2007-04-18 | 2012-08-14 | Sony Computer Entertainment Inc. | Processor emulation using speculative forward translation |
US20080263527A1 (en) * | 2007-04-18 | 2008-10-23 | Sony Computer Entertainment Inc. | Processor emulation using speculative forward translation |
US20090055821A1 (en) * | 2007-08-22 | 2009-02-26 | International Business Machines Corporation | Systems, methods, and computer products for just-in-time compilation for virtual machine environments for fast application startup and maximal run-time performance |
US8286152B2 (en) * | 2007-08-22 | 2012-10-09 | International Business Machines Corporation | Systems, methods, and computer products for just-in-time compilation for virtual machine environments for fast application startup and maximal run-time performance |
US8392881B1 (en) | 2008-05-13 | 2013-03-05 | Google Inc. | Supporting efficient access to object properties in a dynamic object-oriented programming language |
US20090307430A1 (en) | 2008-06-06 | 2009-12-10 | Vmware, Inc. | Sharing and persisting code caches |
US8095507B2 (en) | 2008-08-08 | 2012-01-10 | Oracle International Corporation | Automated topology-based statistics monitoring and performance analysis |
US20110179347A1 (en) | 2009-09-30 | 2011-07-21 | Iain Andrew Russell Proctor | High performance php |
US20110173597A1 (en) | 2010-01-12 | 2011-07-14 | Gheorghe Calin Cascaval | Execution of dynamic languages via metadata extraction |
US20110307876A1 (en) * | 2010-06-14 | 2011-12-15 | Ottoni Guilherme D | Register mapping techniques for efficient dynamic binary translation |
US8479176B2 (en) * | 2010-06-14 | 2013-07-02 | Intel Corporation | Register mapping techniques for efficient dynamic binary translation |
US20110321010A1 (en) | 2010-06-24 | 2011-12-29 | Yifei Wang | Web application framework based on object oriented class mapping |
US20120185822A1 (en) | 2011-01-13 | 2012-07-19 | Joo-Hwan Lee | Web browsing apparatus and method through storing and optimizing javascript® code |
US20120278558A1 (en) * | 2011-04-26 | 2012-11-01 | International Business Machines Corporation | Structure-Aware Caching |
US8867337B2 (en) * | 2011-04-26 | 2014-10-21 | International Business Machines Corporation | Structure-aware caching |
US20120317363A1 (en) * | 2011-05-25 | 2012-12-13 | Nokia Corporation | Memory Caching for Browser Processes |
US9069876B2 (en) * | 2011-05-25 | 2015-06-30 | Nokia Corporation | Memory caching for browser processes |
US20130159978A1 (en) | 2011-12-16 | 2013-06-20 | Microsoft Corporation | State capture after execution in dependent sequences |
US20130212567A1 (en) * | 2012-02-13 | 2013-08-15 | Microsoft Corporation | Generating and caching software code |
US20140095802A1 (en) * | 2012-09-28 | 2014-04-03 | Oracle International Corporation | Caching Large Objects In A Computer System With Mixed Data Warehousing And Online Transaction Processing Workload |
US20140095778A1 (en) * | 2012-09-28 | 2014-04-03 | Jaewoong Chung | Methods, systems and apparatus to cache code in non-volatile memory |
Non-Patent Citations (5)
Title |
---|
Hölzle, U., et al., Optimizing Dynamically-Typed Object-Oriented Languages with Polymorphic Inline Caches, ECOOP '91 European Conference on Object-Oriented Programming [online], 1991 [retrieved Aug. 19, 2017], Retrieved from Internet: <URL: https://link.springer.com/content/pdf/10.1007%2FBFb0057013.pdf>, pp. 21-38. * |
Hong et al., "Java Client Ahead-of-Time Compiler for Embedded Systems," Proceedings of the 2007 ACM SIGPLAN/SIGBED Conference on Languages, Compilers and Tools for Embedded Systems, Jun. 2007, pp. 63-72. |
International Search Report and Written Opinion dated Oct. 19, 2016, which issued in International Application No. PCT/US2016/024791. |
Sanghoon Jeon et al., "Reuse of JIT Compiled Code in JavaScript Engine," SAC'12, Mar. 25-29, 2012, 3 pages, Riva del Garda, Italy. |
Urs Holzle et al., "Optimizing Dynamically-Typed Object-Oriented Languages With Polymorphic Inline Caches," ECOOP '91 Proceedings, Springer Verlag Lecture Notes in Computer Science 512, Jul. 1991, 18 pages, Geneva, Switzerland. |
Also Published As
Publication number | Publication date |
---|---|
GB2553444A (en) | 2018-03-07 |
EP3304293B1 (en) | 2021-09-15 |
KR20170125398A (en) | 2017-11-14 |
JP6329329B2 (en) | 2018-05-23 |
CN107408055A (en) | 2017-11-28 |
US20160350089A1 (en) | 2016-12-01 |
GB2553444B (en) | 2018-09-05 |
GB201715440D0 (en) | 2017-11-08 |
WO2016195790A1 (en) | 2016-12-08 |
KR101851357B1 (en) | 2018-04-24 |
EP3304293A1 (en) | 2018-04-11 |
DE112016002416T5 (en) | 2018-03-08 |
JP2018510428A (en) | 2018-04-12 |
CN107408055B (en) | 2019-08-16 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
EP3876116B1 (en) | Method and apparatus for running mini program, electronic device, and storage medium | |
KR102294326B1 (en) | Prefetching application data for periods of disconnectivity | |
CN106708899B (en) | Automatic point burying method and device | |
US8700691B2 (en) | Minimal download and simulated page navigation features | |
US9152732B2 (en) | Browser cache assist for accessing web-based content | |
US8631394B2 (en) | Static resource processing | |
US20170323025A1 (en) | Browser acceleration method and browser device having accelerator | |
US9471704B2 (en) | Shared script files in multi-tab browser | |
US8572554B2 (en) | Method and system for integrating Java and JavaScript technologies | |
EP3304293B1 (en) | Code caching system | |
CN105122237A (en) | Sharing application states | |
US20110161840A1 (en) | Performance of template based javascript widgets | |
US9069876B2 (en) | Memory caching for browser processes | |
US9053107B1 (en) | Determining updates for files based on an organization of the files on different blocks of a storage device | |
CN103443763B (en) | Comprise to connect the ISA Bridge of the support called rewriteeing virtual function | |
WO2018140487A1 (en) | System and method for encapsulating computer communications | |
CN112087370A (en) | Method, system, electronic device and computer-readable storage medium for issuing GitHub Issues | |
US9116713B1 (en) | System and method for expression evaluation in a distributed networking environment | |
CN102156697A (en) | Method and terminal equipment for realizing webpage application through widget | |
US9672020B2 (en) | Selectively loading precompiled header(s) and/or portion(s) thereof | |
US8793663B2 (en) | Smart cache for a server test environment in an application development tool | |
KR20130103239A (en) | Method, server and terminal for providing web browsing service having translation | |
CN107341263B (en) | Static page data processing method and device | |
Williamson et al. | An overview of the VMTP transport protocol | |
CN115525305A (en) | Data processing method, application starting method, device, computer equipment and storage medium |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:GUO, YANG;VOGELHEIM, DANIEL;EISINGER, JOCHEN MATHIAS;SIGNING DATES FROM 20150529 TO 20150608;REEL/FRAME:035812/0119 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044129/0001Effective date: 20170929 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FEPP | Fee payment procedure |
Free format text: MAINTENANCE FEE REMINDER MAILED (ORIGINAL EVENT CODE: REM.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
LAPS | Lapse for failure to pay maintenance fees |
Free format text: PATENT EXPIRED FOR FAILURE TO PAY MAINTENANCE FEES (ORIGINAL EVENT CODE: EXP.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20211107 |