US6671875B1 - Manipulation of an object-oriented user interface process to provide rollback of object-oriented scripts from a procedural business logic debugger - Google Patents
Manipulation of an object-oriented user interface process to provide rollback of object-oriented scripts from a procedural business logic debugger Download PDFInfo
- Publication number
- US6671875B1 US6671875B1 US09/667,153 US66715300A US6671875B1 US 6671875 B1 US6671875 B1 US 6671875B1 US 66715300 A US66715300 A US 66715300A US 6671875 B1 US6671875 B1 US 6671875B1
- Authority
- US
- United States
- Prior art keywords
- language code
- procedural language
- oriented
- procedural
- debugger
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/44—Arrangements for executing specific programs
- G06F9/455—Emulation; Interpretation; Software simulation, e.g. virtualisation or emulation of application or operating system execution engines
- G06F9/45504—Abstract machines for programme code execution, e.g. Java virtual machine [JVM], interpreters, emulators
- G06F9/45508—Runtime interpretation or emulation, e g. emulator loops, bytecode interpretation
- G06F9/45512—Command shells
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/3664—Environments for testing or debugging software
Definitions
- the present invention is related to U.S. patent Ser. No. 09/666,849, which is entitled “Blending Object-Oriented Objects with Traditional Programming Languages” (hereinafter referred to as the “first related invention”), and U.S. patent Ser. No. 09/666,442, which is entitled “Synchronous Execution of Object-Oriented Scripts and Procedural Code from within an Interactive Test Facility” (hereinafter referred to as the “second related invention”), both of which are commonly assigned to the International Business Machines Corporation (“IBM”) and were filed concurrently herewith, and which are hereby incorporated herein by reference.
- IBM International Business Machines Corporation
- the present invention relates to computer software, and deals more particularly with a method, system, and computer program product for programmatically manipulating a user interface process to maintain synchronization of object-oriented programming language methods (or “scripts”) during a rollback operation in a procedural logic debugger.
- object-oriented programming language methods or “scripts”
- OO components are often used in the user interface. They may also be the main data objects that describe the business system (e.g. Customer objects, Order objects, and so forth in a customer ordering application).
- the business logic of the application might not be written using an OO language, but might be written instead in a more traditional procedural programming language. It might even be legacy code that only uses OO objects by introduction of a new graphical user interface (GUI).
- GUI graphical user interface
- test debuggers provide features that allow users to animate (i.e. display, and step through the logic of) the business logic which is invoked by GUI applications, where that business logic is often written in a procedural programming language. This is typically done using an event-driven facility which knows how to become active when a specific event from the graphical user interface causes invocation of a business logic code component. When the GUI event is triggered, a debugger for the procedural code is invoked. A window (referred to herein as a “test monitor window”) is then displayed to enable the developer to interact with and control the business logic debugging.
- Non-integrated debuggers typically provide the developer with a mechanism for backing up in the execution flow from one statement to a different statement in the subroutine or code component which is currently executing, or for positioning to a statement in a subroutine or code component other than the one currently executing.
- a graphical display of the debugger's execution history may be provided, from which the developer can select to reposition execution to an earlier-executed component.
- the code of a currently-executing function may be displayed in a graphical window, and the developer may be allowed to reposition to a previously executed code statement in that window. Explicitly repositioning the code statement that will execute next in this manner provides the developer with more control over the debugging process.
- the repositioning process moves a current statement pointer for the non-OO code
- UI user interface
- the non-OO code may have been invoked from an OO method, and the OO method may contain additional statements that are not to be executed until the invoked non-OO code completes.
- the OO code may also invoke other non-OO code components, and conversely the non-OO code may invoke other OO methods.
- U.S. Pat. No. 5,901,315 which is titled “Method for Debugging a Java Application Having Native Method Dynamic Load Libraries”, discloses a technique for allowing simultaneous debugging of Java code and native (e.g. C or C++) dynamic load library (DLL) functions, wherein a single debugger interface is provided for both.
- native e.g. C or C++
- DLL dynamic load library
- This programmatic synchronization should be provided even though the OO code and procedural components may be executing in different processes, different namespaces, and/or different software products.
- An object of the present invention is to provide a technique for programmatically manipulating code of an OO user interface that executes in an integrated, seamless manner with procedural language code components such that the OO code remains properly synchronized with the procedural language code when a repositioning operation occurs during operation of a code debugger.
- a further object of the present invention is to provide a technique for programmatic synchronization of object-oriented code and procedural language code components even though the methods and procedural components may be executing in different processes, different namespaces, and/or different software products.
- Still another object of the present invention is to provide this technique for programmatic synchronization in response to an explicit developer-initiated repositioning action during debugging.
- Another object of the present invention is to provide this technique for programmatic synchronization in response to a repositioning action initiated by a test debugger tool.
- Yet another object of the present invention is to provide this technique for programmatic synchronization in an integrated debugging environment where control efficiently passes back and forth between object-oriented code execution and procedural language code execution.
- the present invention provides a method, system, and computer program product for programmatically maintaining synchronization of object-oriented code during a repositioning operation occurring in a procedural language code debugger.
- This technique comprises: executing one or more object-oriented methods written in an object-oriented programming language; executing, under control of the procedural language code debugger, one or more procedural components written in a procedural programming language, wherein at least one of the procedural components contains one or more references to selected ones of the object-oriented methods; detecting a rollback of execution, in the procedural language code debugger, to a particular procedural component; determining whether any currently executing object-oriented methods should be rolled back, based upon the particular procedural component; and rolling back one or more of the currently executing object-oriented methods accordingly.
- the determination may further comprise interrogating a stack which comprises an element for each currently executing object-oriented method invoked by one or more currently executing procedural components, and determining (during the interrogation) whether an element corresponding to the particular procedural component is present on the stack.
- the rolling back may further comprise: popping all stack elements up to the corresponding element, if the corresponding element is present, or up through an element next preceding where the corresponding element would have been on the stack, otherwise; finding a set of frames on a user interface process stack where the set comprises those referencing a name of an object-oriented method that was invoked by the particular procedural component; positioning to a selected one of the set of frames, wherein the selected one is that which precedes an invocation of the object-oriented method having the name; and removing all frames from the user interface process stack up to the selected one.
- the procedural language code, debugger and the object-oriented method may operate in different processes, different software products, and/or in different namespaces.
- the detecting may further comprise detecting a user-initiated rollback, or detecting a rollback initiated by the procedural language code debugger.
- FIG. 1 is a block diagram of a computer workstation environment in which the present invention may be practiced
- FIGS. 2-4 illustrate flowcharts depicting logic that may be used to implement a preferred embodiment of the present invention
- FIG. 5 illustrates an example GUI that contains other embedded GUIs, showing the relationship between the GUIs and their invocation of OO scripts (and is used as the basis for FIG. 6 );
- FIG. 6 illustrates a simple example of program stacks, illustrating how the repositioning operation of the present invention must synchronize the stacks in both the OO world of the GUI and in the procedural language world of the procedural code debugger;
- FIGS. 7-10 illustrate sample code fragments and sample windows that will be used to describe operation of a preferred embodiment of the present invention.
- FIG. 1 illustrates a representative workstation hardware environment in which the present invention may be practiced.
- the environment of FIG. 1 comprises a representative computer or intelligent workstation 10 , such as a personal computer, including related peripheral devices.
- the workstation 10 includes a microprocessor 12 and a bus 14 employed to connect and enable communication between the microprocessor 12 and the components of the workstation 10 in accordance with known techniques.
- the workstation 10 typically includes a user interface adapter 16 , which connects the microprocessor 12 via the bus 14 to one or more interface devices, such as a keyboard 18 , mouse 20 , and/or other interface devices 22 , which can be any user interface device, such as a touch sensitive screen, digitized entry pad, etc.
- the bus 14 also connects a display device 24 , such as an LCD screen or monitor, to the microprocessor 12 via a display adapter 26 .
- the bus 14 also connects the microprocessor 12 to memory 28 and long-term storage 30 which can include a hard drive, diskette drive, tape drive, etc.
- Software programming code which embodies the present invention is typically accessed by the microprocessor 12 of the workstation 10 from long-term storage media 30 of some type, such as a CD-ROM drive or hard drive.
- long-term storage media 30 of some type, such as a CD-ROM drive or hard drive.
- such software programming code may be stored with storage associated with a server.
- the software programming code may be embodied on any of a variety of known media for use with a data processing system, such as a diskette, hard drive, or CD-ROM.
- the code may be distributed on such media, or may be distributed from the memory or storage of one computer system over a network of some type to other computer systems for use by such other systems.
- the programming code may be embodied in the memory 28 , and accessed by the microprocessor 12 using the bus 14 .
- the techniques and methods for embodying software programming code in memory, on physical media, and/or distributing software code via networks are well known and will not be further discussed herein.
- the present invention is implemented as objects (classes and methods) in an object-oriented programming language such as Smalltalk or JavaTM.
- object-oriented programming language such as Smalltalk or JavaTM.
- Java is a trademark of Sun Microsystems, Inc.
- the description herein of the preferred embodiment is primarily in terms of a Smalltalk implementation, although it will be obvious to one of skill in the art how an analogous Java implementation can be created using the teachings herein.
- the present invention has been implemented in the Interactive Test Facility (ITF) component of the IBM VisualAge® Generator Developer for OS/2® and Windows NT® 4.0, which are available from the International Business Machines Corporation (“IBM”).
- ITF Interactive Test Facility
- the present invention provides a technique for manipulating a user interface process to provide rollback of OO scripts when a rollback operation occurs in a procedural logic debugger of an interactive debugging environment, where that debugging environment supports integrated execution of OO and non-OO components and presents a single, logical interface while actually spanning multiple separate programming models which are based on different technologies. (Further, these OO and non-OO programming models may operate in different execution contexts and different namespaces, and may be provided by distinct software products.)
- the VisualAge Generator Interactive Test Facility allows a developer to mix debugging of OO or GUI scripts (referred to hereinafter as “GUI” scripts for ease of reference) and non-OO business logic. Synchronous execution of GUI scripts from within the VG business logic is provided by the special function keyword EZESCRPT, as described in those related inventions.
- GUI scripts When a GUI script is invoked from within procedural code executing in the interactive test facility, multiple OO processes (Smalltalk or Java processes, in the preferred embodiment) must be manipulated to transfer control seamlessly between the non-OO and OO code.
- GUI script that is invoked might actually call back into the procedural code (into the same or a different code component), so it is possible for numerous layers of OO code and non-OO code to be currently processing.
- the techniques with which this processing occurs are described in the related inventions.
- test monitor of the interactive test facility has previously allowed developers to reposition the next statement pointer, to alter the execution path during debugging.
- the capability to programmatically synchronize the GUI process in response to a repositioning operation has not been available therein until implementation of the present invention.
- existing prior art debuggers do not provide this type of synchronization during a repositioning operation in an integrated execution environment.
- the problem with supporting the repositioning operation in integrated execution environments occurs because the GUI scripts, which are executing in a Smalltalk or Java UI process, need to be synchronized with the repositioned procedural language code which is executing in a non-OO process.
- the code that supports the integrated dual debugging of the OO and non-OO code needs to roll back not only the procedural language process but also the original UI process, which invoked the procedural language process originally, in which the GUI script is running.
- the present invention provides for synchronizing the rollback of both the UI process and the non-OO process.
- a repositioning operation is initiated when no GUI scripts are currently executing in a UI process, then the repositioning operation occurs according to prior art techniques. That is, procedural test debuggers know how to manipulate their own execution stacks to pop off currently executing statements or currently executing code components (also referred to as functions, subroutines, or programs).
- GUI script may be synchronously invoked during the execution of a procedural code component.
- a special keyword (which will be referred to hereinafter as “EZESCRPT” for ease of reference) is used to trigger the invocation.
- the executing GUI script may contain numerous code statements that invoke additional procedural code components and/or manipulate different OO objects.
- GUI script To perform a rollback operation, since the user has requested to reposition the next statement pointer of the procedural code debugger to a statement prior to the invocation of this currently-executing GUI script, the entire GUI script must be popped off the UI process stack so that no further Smalltalk or Java statements (as appropriate) in that GUI script are run. In this situation, in addition to handling its own execution stacks, the interactive test facility must manipulate the UI process to roll back to a state before the particular GUI script that needs to be popped off. Note that it is not adequate to simply pop all GUI scripts off the UI process stack: instead, contextual information must be used to determine which GUI scripts should be popped off and which should stay on the stack to finish execution when testing resumes.
- the process frames on the UI process stack will be manipulated, according to the present invention, such that the correct GUI scripts remain on the stack.
- This type of manipulation of the process frames is available in the prior art, and is performed by prior art OO debuggers during OO code debugging.
- manipulating the process frames from an outside process such as from an interactive test facility in which procedural code is being debugged and rolled back, is not known in the art.
- FIG. 2 depicts an overview of the logic that may be used to implement the preferred embodiment of the present invention. This logic is invoked when a repositioning operation has been detected. (As stated earlier, a repositioning operation may be explicitly initiated by a developer, or it may be initiated by the interactive test facility based upon changes that are made while debugging. For ease of reference, the repositioning operation will be discussed hereinafter as if it is invoked explicitly by the developer.)
- the test in Block 205 checks to see if there is a GUI script to be rolled back, based on the value of a debugger rollback instance variable that may have been set during operation of FIG. 3 (in Block 345 ). If this test has a negative result, then the rollback operation occurs solely within the procedural code debugger and uses techniques which are known in the art, as indicated in Block 210 . Following operation of those prior art techniques, the procedural debugger is ready to execute the appropriate next statement (Block 215 ), and thus control returns (Block 235 ) from the processing of FIG. 2 to the invoking logic.
- FIG. 5A shows a GUI named “X” 500 , which includes 2 event triggers (denoted as “Push button 1 ”, element 501 , and “Event trigger 2 ”, element 505 ).
- GUI X also includes 2 embedded GUI's, named “Y” 510 and “Z” 520 .
- a procedural code component named “Function 1 ” 502 is invoked.
- Function 1 invokes a GUI script named “Script 1 ” 503 .
- GUI script stack 650 contains a stack element for each procedural code component that is currently executing a GUI script.
- GUIApplication As a GUI event that executes a procedural code component is fired, the GUI application that fired the event is wrappered with a unique instance of GUIApplication.
- GUIAppX when the developer presses push button 1 501 on GUI X 500 (and causes execution of Function 1 ), an instance is created which, for this example, is referred to as “GUIAppX”. This instance is pushed onto program stack 600 as element 605 .
- Function 1 502 encounters and invokes an EZESCRPT statement, an element is pushed onto GUI script stack 650 .
- the invocation of Script 1 503 therefore causes element 655 to be pushed onto GUI script stack 650 .
- Event trigger 2 505 is triggered (e.g. due to text changes in a field, enabling or disabling a field, executing a VG function directly from script code, etc.) before Function 1 502 , and Script 1 503 , completes.
- Function 2 506 is invoked when this event fires, and another instance of “GUIAppX” is therefore created (reflecting by this name that Event trigger 2 505 resides within GUI X 500 ).
- Corresponding element 604 is also pushed onto program stack 600 .
- an element 654 is pushed onto GUI script stack 650 . (If the non-OO component does not encounter an EZESCRPT statement, then no corresponding element will be pushed onto the GUI script stack 650 .)
- Event trigger 1 515 of embedded GUI Y 510 is then triggered, before either Function 1 502 or Function 2 506 has completed, causing invocation of Function 3 511 , as shown in FIG. 5B
- a GUIApplication which is denoted as “GUIAppY” in FIG. 6 is therefore created, and element 603 is pushed onto program stack 600 .
- Function 3 511 executes Script 1 503 (the same script that Function 1 502 is currently executing)
- element 653 is pushed onto GU[ script stack 650 .
- the event corresponding to Event trigger 2 505 of GUI X 500 is triggered again (before any currently-executing procedural code components or scripts complete), and Function 2 506 and Script 2 507 execute from this new event.
- Stack elements 602 and 652 correspond to these invocations. Finally, in this example, Event trigger 1 525 on GUI Z 520 is triggered, and Function 4 521 and ScriptZ 522 execute from this event. Stack elements 601 and 651 represent these invocations.
- the stacks contain elements representing multiple event firings from one GUI (i.e. the 3 triggered events from GUI X, each of which has a unique stack element) and multiple invocations of particular scripts (i.e. 2 invocations of Script 1 , each from an event on a different GUI, and 2 invocations of Script 2 , both from an event on the same GUT).
- the stack pointers 610 and 660 point to the element currently being executed in the non-OO and in the UI process, respectively.
- Each element placed on GUI script stack 650 contains an object which records the name of the GUI script, the name of the GUI application from which it was invoked, and a unique identification of the GUI application instance.
- the GUI application instance has not been shown in FIG. 6 .
- the unique GUI application instance enables differentiating between elements having the same script name and GUI application name, such as elements 652 and 654 , in order to associate the GUI script invocations with the proper component execution.
- use of the application instance may be omitted in an alternative embodiment of the present invention, if desired, such that only the GUI script name and GUI application name are used. The manner in which the flowcharts are to be altered for this alternative will be obvious to one of ordinary skill in the art.
- an object is built that will be compared (as will be described in more detail below) to the stacked objects on the GUI script stack.
- This object contains the name of the script to be rolled back to, as well as the identification of the GUI application instance in which the script is executing.
- the object is built in FIG. 3 and checked in Block 205 of FIG. 2 .
- Block 225 performs a rollback of the OO code, as depicted in more detail with reference to FIG. 4 .
- the UI process will be positioned to a method that is invoked according to the related inventions to run a GUI script, and which (in a Smalltalk implementation) may be named “runGuiScript:”.
- a rollback flag (which is preferably stored within each object placed on GUI script stack 650 ) is also set to either TRUE or FALSE during the processing of FIG. 4 .
- Block 230 checks the value of this rollback flag (which may have been set by Block 405 of FIG.
- FIG. 3 depicts the logic used by the preferred embodiment to determine whether there is a GUI script to be rolled back. This processing corresponds to Block 200 of FIG. 2, and evaluates the elements on a program stack for the non-OO code debugger to determine whether there is an OO script (1) that is currently being executed and (2) which needs to be cleaned up.
- the currently-executing application is “GUIAppZ” 601 .
- Stack pointer 610 points to the stacked element for this code component, which is located at the top of program stack 600 .
- the developer has requested to roll back processing to code component “GUIAppY” 603 (i.e. to execution of Function 3 511 , depicted in FIG. 5 B), as indicated by the moved stack pointer 611 .
- the logic of FIG. 3 will pop elements 601 and 602 off the stack 600 , leaving element 603 at the top of the stack as the code component to be executed next.
- FIG. 3 begins by declaring a local “rollback script object” instance (Block 300 ). (A local variable is used within the processing of FIG. 3 for performance reasons.) This local variable is then used at Blocks 340 and 345 to set a debugger rollback instance variable which is tested in Block 205 , as described above, after the processing of FIG. 3 completes.
- the object instance is designed to hold a rollback script object, and is initially nil.
- Block 305 checks the next element on the non-OO stack to see if it contains the target component or application program that is to be rolled back to. On the first iteration through this logic, the next element is the original element at the top of the non-OO stack. On subsequent iterations (i.e.
- Block 305 comprises determining whether the stack pointer 610 points to an element for the target component GUIAppY.
- the test in Block 305 has a negative result (as it does on the first and second iterations through this logic for the example stack 600 of FIG. 6 )
- execution is being rolled back to a previous non-OO code component, and processing continues at Block 310 .
- Block 330 processing transfers to Block 330 on the third iteration through this logic, when stack pointer 610 has moved to position 611 .
- the test in Block 310 asks whether the current non-OO code statement being executed within the code component represented by the top element on the non-OO stack is an EZESCRPT statement or analogous GUI invocation. If not, control transfers to Block 315 , which pops the top element off the non-OO stack and moves the stack pointer to point to this new top element, after which control returns to Block 305 . Otherwise, when the test in Block 310 has a positive response, Block 320 creates a rollback script object in which the script name and GUI application instance are set to the name and identifier obtained from the current program stack element. The rollback script object is then saved as the value of the local variable declared in Block 300 , and processing returns to Block 315 to move the stack pointer. (Note that the value in the local rollback script object may be overridden subsequently during the processing of FIG. 3 if a next-lower program stack element is found which is also executing a GUI invocation.)
- Control reaches Block 330 when the top element on the non-OO stack is the element for the target code component.
- the stack pointer will be at position 611 , pointing to code component GUIAppY.
- Block 330 performs the same test as Block 310 , to determine whether the target code component was executing a GUI script invocation. If so, then Block 335 creates and saves a rollback script object in the local variable declared at Block 300 , in the same manner previously described with reference to Block 320 . (This rollback script object overrides any previously-stored object that may have been created at Block 320 during this iteration through the processing of FIG. 3.)
- Block 340 is reached when the code component at the top of the non-OO stack is not currently executing a GUI script, and also following the processing of Block 335 .
- the test in Block 340 therefore checks to see if the local variable used to store the rollback script object has been changed from its initial nil value. If it has not, then there is no GUI script to manipulate (and neither Block 320 nor Block 335 was executed), so control simply returns to the invoking logic of FIG. 2 . Otherwise, when the variable has a non-nil value, the test in Block 340 has a positive result and Block 345 therefore sets a debugger rollback instance variable. Control then returns to the invoking logic in FIG. 2, where this instance variable is checked at Block 205 .
- the logic depicted in FIG. 4 performs the actual rolling back of the GUI script such that the UI process is properly synchronized with the non-OO process when the developer regains control of the debugging operation. This logic is invoked from Block 225 of FIG. 2 .
- the GUI rollback process begins at Block 400 , where the proper object on a GUI script stack (illustrated by stack 650 in FIG. 6) is located. This comprises searching through the stacked elements, beginning at the top, until finding a stacked object which has the same script name and the same GUI application instance as that which was stored in the rollback script object created during the processing of FIG. 3 . (See the description of Blocks 320 and 335 .) Any stacked elements that are evaluated during this process, and which do not match both the script name and GUI application instance, are popped off the GUI script stack.
- any objects on the GUI script stack having a matching script name and GUI application name but a different GUI application instance are counted using a counter that will be referred to hereinafter as “ObjectCount”.
- ObjectCount a counter that will be referred to hereinafter as “ObjectCount”.
- Block 405 sets a rollback flag in this stacked object to indicate that this GUI script is being rolled back. (This flag is subsequently checked at Block 230 of FIG. 2.)
- Block 410 obtains the class name of the GUI application that this script method belongs to. This comprises sending a message to the GUI application, using prior art techniques. The compiled methods for this class are then searched (Block 415 ) to find the method matching the name of the script being rolled back. If necessary, the class hierarchy chain is traversed, in case the method is inherited from a superclass. Block 425 asks whether the correct compiled method was located. If not, this is an error condition, and control transfers to Block 430 where the debugger rollback instance variable is preferably set to nil. (Alternative processing may be provided for error conditions and an error message may also be displayed, if desired.)
- Block 435 is reached when the correct compiled method was located.
- the correct Smalltalk UI process for the active non-OO process is located next, using techniques which are known in the art. (In the preferred Smalltalk embodiment, this comprises using a class variable which maps the UI process to the correct debugger instance. In a Java implementation, this comprises passing GUT script information to the Java image. Java code then determines the correct UI process.)
- Block 440 obtains all the process frames currently on this UI process stack, and creates a collection therefrom which has only the frames with matching method (i.e. script) names.
- Block 445 checks whether the number of entries in this collection is at least as many as the value of the ObjectCount variable set in Block 400 . If not, this is an error condition and control transfers to Block 430 .
- Block 450 (see FIG. 4B) where the collection is filtered.
- This filtering process comprises evaluating each process frame in the collection, and keeping only those where the method prior to the script invocation is a method of the interactive test facility. (This handles the case where the method was invoked in ways other than by an OO script invocation, such as a user invocation or recursive script invocations from within the script itself, as these other invocations are not subject to the manipulation technique of the present invention.)
- Block 455 checks to see if the number of frames in the resulting filtered collection is sufficient, that is, if the size of the filtered collection is greater than or equal to the ObjectCount value. If not, this is an error and control transfers to Block 430 . Otherwise, processing continues at Block 460 .
- Block 460 calculates the frame index of the correct script invocation. For example, if the filtered collection has 3 members and the ObjectCount value is 2, then the frame index points to the second of the 3 members in the collection.
- Block 465 adds 1 to this calculated frame index value, to enable moving below the script invocation to the “runGuiScript:” method which preceded it.
- Block 470 then invokes the Smalltalk method “dropToFrame:” to position execution at this runGuiScript: method.
- Block 475 signals a semaphore of the test facility (which is used as described in the second related invention), after which control returns to Block 430 to reset the debugger rollback instance variable to nil in order to prevent re-executing the rollback process.
- control Upon returning control to the Smalltalk engine (i.e., after returning to Block 230 of FIG. 2 ), execution of the GUI script will be skipped based upon this flag setting, and control will then return back to the ITF to enable the developer to continue the debugging process.
- Block 405 comprises sending a message to the Java UI requesting it to manipulate the top stacked element.
- the processing of Blocks 410 through 470 in a Java implementation is then performed, in a manner analogous to that described with reference to the Smalltalk preferred embodiment.
- FIG. 7 illustrates a sample test monitor window 700 that may occur when using a procedural code debugger.
- the execution stack monitor area 710 shows several stacked components that are in the process of executing, where highlighting shows that the topmost entry 711 is currently executing.
- FIG. 8 shows the highlighting having moved to the third entry 712 of this list, which in this example reflects the developer's choice to back up to this point in the execution path.
- FIG. 9 illustrates the UI process stack that is being manipulated according to the logic of FIG. 4 .
- the GUI application name of interest “SynchronousPatentExampleGUI” (which matches the component name selected at 712 of FIG. 8 ), is located in a process frame shown at 910 .
- the invoked GUI script name “scriptWhichnvokesFunction 2 ”, is shown at 911 in this process frame.
- This GUI script name 911 corresponds to the GUI script invocation 1010 that is shown in the procedural component named “VG_FUNCTION 1 ” 1000 of FIG. 10 .
- VG_FUNCTION 1 is also the name shown in selected entry 712 of FIG. 8 .
- the previously-executing component, named VG_FUNCTION 2 is shown in highlighted entry 711 of FIG. 7.
- the next-previous method invocation, shown at 920 is the runGuiScript:with: method previously discussed (wherein it was referred to as “runGuiScript:”, although in this figure it is shown as taking an additional parameter).
- the present invention enables OO code to be properly synchronized during rollback operations that are initiated within a procedural code debugger.
Abstract
Description
Claims (24)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/667,153 US6671875B1 (en) | 2000-09-21 | 2000-09-21 | Manipulation of an object-oriented user interface process to provide rollback of object-oriented scripts from a procedural business logic debugger |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/667,153 US6671875B1 (en) | 2000-09-21 | 2000-09-21 | Manipulation of an object-oriented user interface process to provide rollback of object-oriented scripts from a procedural business logic debugger |
Publications (1)
Publication Number | Publication Date |
---|---|
US6671875B1 true US6671875B1 (en) | 2003-12-30 |
Family
ID=29737126
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/667,153 Expired - Lifetime US6671875B1 (en) | 2000-09-21 | 2000-09-21 | Manipulation of an object-oriented user interface process to provide rollback of object-oriented scripts from a procedural business logic debugger |
Country Status (1)
Country | Link |
---|---|
US (1) | US6671875B1 (en) |
Cited By (23)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20010005852A1 (en) * | 1997-03-12 | 2001-06-28 | Bogle Phillip Lee | Active debugging environment for applications containing compiled and interpreted programming language code |
US20030084429A1 (en) * | 2001-10-26 | 2003-05-01 | Schaefer James S. | Systems and methods for table driven automation testing of software programs |
US20040015870A1 (en) * | 2001-05-16 | 2004-01-22 | Arbouzov Leonid M. | System and method for combinatorial test generation in a compatibility testing environment |
US20050034103A1 (en) * | 2003-08-08 | 2005-02-10 | Sun Microsystems, Inc. | Method and apparatus for transferring data in a distributed testing system |
US20060010058A1 (en) * | 2004-07-09 | 2006-01-12 | Microsoft Corporation | Multidimensional database currency conversion systems and methods |
US20060020608A1 (en) * | 2004-07-09 | 2006-01-26 | Microsoft Corporation | Cube update tool |
US20060020921A1 (en) * | 2004-07-09 | 2006-01-26 | Microsoft Corporation | Data cube script development and debugging systems and methodologies |
US20060059029A1 (en) * | 2004-08-24 | 2006-03-16 | International Business Machines Corporation | Autonomic installation and configuration of an enterprise business process on-demand |
US20060070081A1 (en) * | 2004-09-30 | 2006-03-30 | Microsoft Corporation | Integration of speech services with telecommunications |
US20070192364A1 (en) * | 2005-12-29 | 2007-08-16 | International Business Machines Corporation | Apparatus and method for porting of business logic among computer platforms |
US20070203981A1 (en) * | 2006-02-10 | 2007-08-30 | Fuji Xerox Co., Ltd. | Electronic device capable of recording conference information, computer system, conference information processing method, and program product therefor |
EP1555612A3 (en) * | 2004-01-02 | 2007-09-05 | Microsoft Corporation | System and method for implicit synchronization of message-queue-based user interface with an automatic code |
US20080284151A1 (en) * | 2005-04-22 | 2008-11-20 | Daimler Ag | Collision-Protected Front Frame Structure of a Truck |
US20090063580A1 (en) * | 2007-08-29 | 2009-03-05 | International Business Machines Corporation | Apparatus, system, and method for hierarchical rollback of business operations |
US20090222795A1 (en) * | 2008-02-29 | 2009-09-03 | International Business Machines Corporation | Debugger for a Declarative Event-Driven Programming Model |
US20090222793A1 (en) * | 2008-02-29 | 2009-09-03 | International Business Machines Corporation | Virtual Machine and Programming Language for Event Processing |
US20090222789A1 (en) * | 2008-02-29 | 2009-09-03 | International Business Machines Corporation | Compiler for a Declarative Event-Driven Programming Model |
US20090307652A1 (en) * | 2008-06-10 | 2009-12-10 | Microsoft Corporation | Automatic model-specific debugger extensions |
US20100125558A1 (en) * | 2008-11-19 | 2010-05-20 | Microsoft Corporation | Framework for Open Dynamic Reflective Applications |
CN102508769A (en) * | 2011-10-11 | 2012-06-20 | 北京锐安科技有限公司 | Debugged program debugging method based on core-implanted debugger |
US20140281253A1 (en) * | 2013-03-15 | 2014-09-18 | International Business Machines Corporation | Dynamically removing entries from an executing queue |
US20180067729A1 (en) * | 2016-09-06 | 2018-03-08 | Jacob Harris Apkon | Techniques for modifying execution of a computer program based on user input received through a graphical user interface |
CN110235131A (en) * | 2017-07-19 | 2019-09-13 | 西门子工业软件有限公司 | The method and system of robot program for simulating industry robot |
Citations (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5590330A (en) | 1994-12-13 | 1996-12-31 | International Business Machines Corporation | Method and system for providing a testing facility in a program development tool |
US5615371A (en) * | 1994-04-28 | 1997-03-25 | Nec Corporation | Debug processing system for user programs |
US5812850A (en) | 1995-11-13 | 1998-09-22 | Object Technology Licensing Corp. | Object-oriented symbolic debugger using a compiler driven database and state modeling to control program execution |
US5819093A (en) | 1995-03-03 | 1998-10-06 | Sun Microsystems, Inc. | System and method for a distributed debugger for debugging distributed application programs |
US5889991A (en) | 1996-12-06 | 1999-03-30 | International Business Machines Corp. | Method and system for customizing a palette using any java class |
US5901315A (en) | 1997-06-13 | 1999-05-04 | International Business Machines Corporation | Method for debugging a Java application having native method dynamic load libraries |
US6035419A (en) * | 1995-12-27 | 2000-03-07 | International Business Machines Corporation | Logical execution sequence error recovery method and system |
US6205465B1 (en) * | 1998-07-22 | 2001-03-20 | Cisco Technology, Inc. | Component extensible parallel execution of multiple threads assembled from program components specified with partial inter-component sequence information |
US6308315B1 (en) * | 1998-10-14 | 2001-10-23 | Sun Microsystems, Inc. | System and method for automatically and selectively promoting object variables to method fields and variables in a digital computer system |
US6385764B1 (en) * | 1999-01-29 | 2002-05-07 | International Business Machines Corporation | Method and apparatus for improving invocation speed of Java methods |
-
2000
- 2000-09-21 US US09/667,153 patent/US6671875B1/en not_active Expired - Lifetime
Patent Citations (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5615371A (en) * | 1994-04-28 | 1997-03-25 | Nec Corporation | Debug processing system for user programs |
US5590330A (en) | 1994-12-13 | 1996-12-31 | International Business Machines Corporation | Method and system for providing a testing facility in a program development tool |
US5819093A (en) | 1995-03-03 | 1998-10-06 | Sun Microsystems, Inc. | System and method for a distributed debugger for debugging distributed application programs |
US5812850A (en) | 1995-11-13 | 1998-09-22 | Object Technology Licensing Corp. | Object-oriented symbolic debugger using a compiler driven database and state modeling to control program execution |
US6035419A (en) * | 1995-12-27 | 2000-03-07 | International Business Machines Corporation | Logical execution sequence error recovery method and system |
US5889991A (en) | 1996-12-06 | 1999-03-30 | International Business Machines Corp. | Method and system for customizing a palette using any java class |
US5901315A (en) | 1997-06-13 | 1999-05-04 | International Business Machines Corporation | Method for debugging a Java application having native method dynamic load libraries |
US6205465B1 (en) * | 1998-07-22 | 2001-03-20 | Cisco Technology, Inc. | Component extensible parallel execution of multiple threads assembled from program components specified with partial inter-component sequence information |
US6308315B1 (en) * | 1998-10-14 | 2001-10-23 | Sun Microsystems, Inc. | System and method for automatically and selectively promoting object variables to method fields and variables in a digital computer system |
US6385764B1 (en) * | 1999-01-29 | 2002-05-07 | International Business Machines Corporation | Method and apparatus for improving invocation speed of Java methods |
Non-Patent Citations (3)
Title |
---|
"Mixed Mode State Saving for Object Oriented/Procedural Debugger," IBM Technical Disclosure Bulletin, Apr. 1, 1994, IBM, NB9404587, pp. 587-588.* * |
IBM Technical Disclosure Bulletin, Vol 34, No. 6, Nov. 1991, P. R. Chandler, W. A. Miller and J. K. Rayborn, "Smalltalk/V PM Officevision/2 Release 2 Mail Service" pp. 428-430. |
IBM Technical Disclosure Bulletin, Vol 37, No. 3 Mar. 1994, T. W. Medlin, G. Miller and M. P. Nally, "Interfacing Between Structured and Object-Oriented Languages" pp. 661-663. |
Cited By (43)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7203926B2 (en) * | 1997-03-12 | 2007-04-10 | Microsoft Corporation | Active debugging environment for applications containing compiled and interpreted programming language code |
US20010005852A1 (en) * | 1997-03-12 | 2001-06-28 | Bogle Phillip Lee | Active debugging environment for applications containing compiled and interpreted programming language code |
US20040015870A1 (en) * | 2001-05-16 | 2004-01-22 | Arbouzov Leonid M. | System and method for combinatorial test generation in a compatibility testing environment |
US6931627B2 (en) * | 2001-05-16 | 2005-08-16 | Sun Microsystems, Inc. | System and method for combinatorial test generation in a compatibility testing environment |
US20030084429A1 (en) * | 2001-10-26 | 2003-05-01 | Schaefer James S. | Systems and methods for table driven automation testing of software programs |
US6993748B2 (en) * | 2001-10-26 | 2006-01-31 | Capital One Financial Corporation | Systems and methods for table driven automation testing of software programs |
US20050034103A1 (en) * | 2003-08-08 | 2005-02-10 | Sun Microsystems, Inc. | Method and apparatus for transferring data in a distributed testing system |
US7840943B2 (en) * | 2003-08-08 | 2010-11-23 | Oracle America, Inc. | Method and apparatus for transferring data in a distributed testing system |
CN100432938C (en) * | 2004-01-02 | 2008-11-12 | 微软公司 | System and method for implicit synchronization of message-queue-based user interface with an automatic code |
EP1555612A3 (en) * | 2004-01-02 | 2007-09-05 | Microsoft Corporation | System and method for implicit synchronization of message-queue-based user interface with an automatic code |
US20060020608A1 (en) * | 2004-07-09 | 2006-01-26 | Microsoft Corporation | Cube update tool |
US20060010058A1 (en) * | 2004-07-09 | 2006-01-12 | Microsoft Corporation | Multidimensional database currency conversion systems and methods |
US7694278B2 (en) * | 2004-07-09 | 2010-04-06 | Microsoft Corporation | Data cube script development and debugging systems and methodologies |
US20060020921A1 (en) * | 2004-07-09 | 2006-01-26 | Microsoft Corporation | Data cube script development and debugging systems and methodologies |
US7614049B2 (en) | 2004-08-24 | 2009-11-03 | International Business Machines Corporation | Autonomic installation and configuration of an enterprise business process on-demand |
US20060059029A1 (en) * | 2004-08-24 | 2006-03-16 | International Business Machines Corporation | Autonomic installation and configuration of an enterprise business process on-demand |
US20060070081A1 (en) * | 2004-09-30 | 2006-03-30 | Microsoft Corporation | Integration of speech services with telecommunications |
US20060070086A1 (en) * | 2004-09-30 | 2006-03-30 | Microsoft Corporation | Application development with unified programming models |
US8266586B2 (en) * | 2004-09-30 | 2012-09-11 | Microsoft Corporation | Application development with unified programming models |
US7561673B2 (en) | 2004-09-30 | 2009-07-14 | Microsoft Corporation | Integration of speech services with telecommunications |
US20080284151A1 (en) * | 2005-04-22 | 2008-11-20 | Daimler Ag | Collision-Protected Front Frame Structure of a Truck |
US20070192364A1 (en) * | 2005-12-29 | 2007-08-16 | International Business Machines Corporation | Apparatus and method for porting of business logic among computer platforms |
US8139757B2 (en) * | 2006-02-10 | 2012-03-20 | Fuji Xerox Co., Ltd. | Electronic device capable of recording conference information, computer system, conference information processing method, and program product therefor |
US20070203981A1 (en) * | 2006-02-10 | 2007-08-30 | Fuji Xerox Co., Ltd. | Electronic device capable of recording conference information, computer system, conference information processing method, and program product therefor |
US20090063580A1 (en) * | 2007-08-29 | 2009-03-05 | International Business Machines Corporation | Apparatus, system, and method for hierarchical rollback of business operations |
US8001091B2 (en) | 2007-08-29 | 2011-08-16 | International Business Machines Corporation | Apparatus, system, and method for hierarchical rollback of business operations |
US20090222795A1 (en) * | 2008-02-29 | 2009-09-03 | International Business Machines Corporation | Debugger for a Declarative Event-Driven Programming Model |
US8677333B2 (en) | 2008-02-29 | 2014-03-18 | International Business Machines Corporation | Virtual machine and programming language for event processing |
US8627299B2 (en) | 2008-02-29 | 2014-01-07 | International Business Machines Corporation | Virtual machine and programming language for event processing |
US20090222789A1 (en) * | 2008-02-29 | 2009-09-03 | International Business Machines Corporation | Compiler for a Declarative Event-Driven Programming Model |
US8397216B2 (en) | 2008-02-29 | 2013-03-12 | International Business Machines Corporation | Compiler for a declarative event-driven programming model |
US20090222793A1 (en) * | 2008-02-29 | 2009-09-03 | International Business Machines Corporation | Virtual Machine and Programming Language for Event Processing |
US8365149B2 (en) * | 2008-02-29 | 2013-01-29 | International Business Machines Corporation | Debugger for a declarative event-driven programming model |
US20090307652A1 (en) * | 2008-06-10 | 2009-12-10 | Microsoft Corporation | Automatic model-specific debugger extensions |
US10169199B2 (en) * | 2008-06-10 | 2019-01-01 | Microsoft Technology Licensing, Llc | Automatic model-specific debugger extensions |
US20100125558A1 (en) * | 2008-11-19 | 2010-05-20 | Microsoft Corporation | Framework for Open Dynamic Reflective Applications |
US8707259B2 (en) | 2008-11-19 | 2014-04-22 | Microsoft Corporation | Framework for open dynamic reflective applications |
CN102508769A (en) * | 2011-10-11 | 2012-06-20 | 北京锐安科技有限公司 | Debugged program debugging method based on core-implanted debugger |
US20140281253A1 (en) * | 2013-03-15 | 2014-09-18 | International Business Machines Corporation | Dynamically removing entries from an executing queue |
US9158698B2 (en) * | 2013-03-15 | 2015-10-13 | International Business Machines Corporation | Dynamically removing entries from an executing queue |
US20180067729A1 (en) * | 2016-09-06 | 2018-03-08 | Jacob Harris Apkon | Techniques for modifying execution of a computer program based on user input received through a graphical user interface |
US10606727B2 (en) | 2016-09-06 | 2020-03-31 | Soroco Private Limited | Techniques for generating a graphical user interface to display documentation for computer programs |
CN110235131A (en) * | 2017-07-19 | 2019-09-13 | 西门子工业软件有限公司 | The method and system of robot program for simulating industry robot |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6671875B1 (en) | Manipulation of an object-oriented user interface process to provide rollback of object-oriented scripts from a procedural business logic debugger | |
US6668370B1 (en) | Synchronous execution of object-oriented scripts and procedural code from within an interactive test facility | |
US8079037B2 (en) | Generic, multi-instance method and GUI detection system for tracking and monitoring computer applications | |
AU2005203508B2 (en) | System and method for selecting test case execution behaviors for reproducible test automation | |
US6477666B1 (en) | Automatic fault injection into a JAVA virtual machine (JVM) | |
US6016474A (en) | Tool and method for diagnosing and correcting errors in a computer program | |
US6757905B1 (en) | Method and system for synchronous operation of linked command objects | |
US7321988B2 (en) | Identifying a code library from the subset of base pointers that caused a failure generating instruction to be executed | |
JPH07508116A (en) | Devices and systems for event recognition and notification | |
CA2211373C (en) | Learn mode script generation in a medical imaging system | |
US20030076366A1 (en) | Methods and systems for navigating deterministically through a graphical user interface | |
US20030106046A1 (en) | Inheritance breakpoints for use in debugging object-oriented computer programs | |
AU2005203386A1 (en) | Test automation stack layering | |
JPH076135A (en) | Cancellation / rerun mechanism of multilevel | |
US7567257B2 (en) | Partition-based undo of partitioned object graph | |
US20070240123A1 (en) | Method for creating software debug breakpoints activated by specific call patterns | |
EP0784264B1 (en) | A computer-implemented process for determining a minimum code set for an executable application in a data processing system | |
US20070143678A1 (en) | Method and apparatus for persistently resolving events to event source | |
US8261239B2 (en) | Locating a testable object in a functional testing tool | |
US6754888B1 (en) | Facility for evaluating a program for debugging upon detection of a debug trigger point | |
CN102855129A (en) | Method and system for automatically creating isolated processes | |
US8225328B2 (en) | Access to a target object with desired functionality | |
EP2168045A1 (en) | Exception-based error handling in an array-based language | |
US6625805B1 (en) | Dynamic byte code examination to detect whether a GUI component handles mouse events | |
US20040204894A1 (en) | Disambiguating like testable objects in a functional testing tool |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:LINDSEY, BETH BRIDGERS;LINDSEY, ANTHONY HAYDEN;WILSON, TIMOTHY;REEL/FRAME:011178/0359Effective date: 20000920 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026664/0866Effective date: 20110503 |
|
FPAY | Fee payment |
Year of fee payment: 12 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |