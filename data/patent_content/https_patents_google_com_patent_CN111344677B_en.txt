CN111344677B - Managing processing system efficiency - Google Patents
Managing processing system efficiency Download PDFInfo
- Publication number
- CN111344677B CN111344677B CN201880030646.0A CN201880030646A CN111344677B CN 111344677 B CN111344677 B CN 111344677B CN 201880030646 A CN201880030646 A CN 201880030646A CN 111344677 B CN111344677 B CN 111344677B
- Authority
- CN
- China
- Prior art keywords
- domain
- priority domain
- general purpose
- system memory
- low
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
- 238000012545 processing Methods 0.000 title claims abstract description 63
- 238000000034 method Methods 0.000 claims abstract description 31
- 238000003860 storage Methods 0.000 claims abstract description 10
- 238000010801 machine learning Methods 0.000 claims description 12
- 230000004044 response Effects 0.000 claims description 4
- 230000001133 acceleration Effects 0.000 claims 1
- 238000005457 optimization Methods 0.000 description 18
- 238000004590 computer program Methods 0.000 description 13
- 230000008569 process Effects 0.000 description 10
- 238000004460 liquid liquid chromatography Methods 0.000 description 7
- 238000013528 artificial neural network Methods 0.000 description 6
- 238000012549 training Methods 0.000 description 6
- 230000009471 action Effects 0.000 description 5
- 238000004891 communication Methods 0.000 description 5
- 238000010586 diagram Methods 0.000 description 4
- 230000007423 decrease Effects 0.000 description 3
- 230000009429 distress Effects 0.000 description 3
- 230000006870 function Effects 0.000 description 3
- 230000003993 interaction Effects 0.000 description 3
- 238000002955 isolation Methods 0.000 description 2
- 239000004973 liquid crystal related substance Substances 0.000 description 2
- 230000003287 optical effect Effects 0.000 description 2
- 238000005192 partition Methods 0.000 description 2
- 238000013515 script Methods 0.000 description 2
- 238000000926 separation method Methods 0.000 description 2
- 241000009334 Singa Species 0.000 description 1
- 230000002411 adverse Effects 0.000 description 1
- 230000005540 biological transmission Effects 0.000 description 1
- 230000001149 cognitive effect Effects 0.000 description 1
- 230000000694 effects Effects 0.000 description 1
- 230000002452 interceptive effect Effects 0.000 description 1
- 230000001788 irregular Effects 0.000 description 1
- 238000004519 manufacturing process Methods 0.000 description 1
- 230000007246 mechanism Effects 0.000 description 1
- 206010027175 memory impairment Diseases 0.000 description 1
- 238000012544 monitoring process Methods 0.000 description 1
- 230000000644 propagated effect Effects 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 230000001953 sensory effect Effects 0.000 description 1
- 238000000638 solvent extraction Methods 0.000 description 1
- 108020001568 subdomains Proteins 0.000 description 1
- 239000000758 substrate Substances 0.000 description 1
- 238000012546 transfer Methods 0.000 description 1
- 238000013519 translation Methods 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Abstract
Methods, systems, and computer storage media storing instructions for obtaining data that divides a plurality of general purpose processing units in a processing system into a high priority domain and a low priority domain, wherein the general purpose processing units in the high priority domain are assigned to perform one or more tasks including one or more high priority tasks, and the general purpose processing units in the low priority domain are assigned to perform one or more low priority tasks; obtaining a memory usage metric characterizing usage of system memory by the high priority domain and the low priority domain while the processing system is running; and adjusting the configuration of (i) the high priority domain, (ii) the low priority domain, or (iii) both, based on the memory usage metric, to adjust the usage of the system memory by the general purpose processing unit.
Description
Cross Reference to Related Applications
The present application claims priority from U.S. patent application Ser. No.62/589,535, entitled "management of processing System efficiency," filed on 11/21, 2017, which is incorporated herein by reference in its entirety.
Background
The present description relates to improving accelerated resource-intensive computing efficiency.
Hardware accelerators such as Graphics Processing Units (GPUs) or Tensor Processing Units (TPUs) have greater computational power than general-purpose processors such as conventional central processing units (Central Processing Unit, CPUs). As a result, accelerators have begun to push performance improvements for critical workloads. For example, accelerators are widely used for machine learning training and reasoning tasks.
Disclosure of Invention
The present specification describes a system implemented as a computer program on one or more computers at one or more locations that manages the efficiency of a processing system that includes a plurality of general purpose processing units.
The system divides a plurality of general purpose processing units (e.g., CPU cores) into high priority and low priority domains. The general purpose processing units in the high priority domain are assigned to perform one or more tasks including one or more high priority tasks, and the general purpose processing units in the low priority domain are assigned to perform one or more tasks including one or more low priority tasks. Typically, processing units in the low priority domain are not assigned to perform any high priority tasks. In addition, processing systems typically also include one or more hardware accelerators that are assigned a resource-intensive workload, such as a machine learning workload, and high priority tasks are tasks associated with the resource-intensive workload, i.e., tasks that support the workload assigned to the hardware accelerator.
As the processing system runs, the system obtains usage metrics that characterize the usage of system memory by the high priority domain and the low priority domain. Based on the memory usage metrics, the system adjusts the configuration of either (i) the high priority domain, (ii) the low priority domain, or (iii) both, to adjust the utilization of system memory by the general purpose processing units.
The system may repeatedly obtain the usage metrics and adjust the configuration at run-time to increase the efficiency of the processing system.
Particular embodiments of the subject matter described in this specification can be implemented to realize one or more of the following advantages. While in resource-intensive computing, a hardware accelerator is responsible for the most burdensome computing tasks, general purpose processors (e.g., CPUs) typically perform various supporting roles. For example, in a large-scale distributed machine learning system, the CPU may perform a supporting role of collecting and synchronizing machine learning model parameters. The supporting role of the CPU may degrade system performance by competing with the accelerator for shared resources (such as system memory). The described techniques divide a plurality of general purpose processing units into high priority and low priority domains, with memory requests within each sub-domain being processed by a respective memory controller and enjoying lower memory latency and cache latency. Furthermore, by filling the high priority domain with low priority CPU tasks, the throughput penalty due to splitting of domain partitions can be regained. Further, by comparing the metrics of the performance counters at run-time, the system may choose to enhance, throttle, or maintain resource configurations to reduce resource contention in and between the high and low priority domains.
The details of one or more embodiments of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
Drawings
FIG. 1 is a diagram of an example processing system designed to manage resource-intensive computing.
FIG. 2 is a flow diagram of an example process for managing resources on multiple processing units.
FIG. 3 is a flow chart of example software logic for configuring resources on multiple processing units.
Specific embodiments of the present invention will now be described in detail with reference to the accompanying drawings. For consistency, like elements in the various figures are indicated by like reference numerals.
DETAILED DESCRIPTION OF EMBODIMENT (S) OF INVENTION
FIG. 1 is a diagram of an example system 100 that manages resource-intensive computing. The system 100 includes an accelerator package 103 designed to handle high priority workloads, such as machine learning tasks, and a processor package 102 designed to handle low priority workloads, such as CPU tasks. For example, a CPU task includes collecting shared gradients from multiple accelerator packages. Accelerator package 103 is communicatively coupled to processor package 102 using one or more interfaces 112a and 112 b. The optimization runtime system (Optimization Runtime System) 120 manages the processor packages 102 to increase their computational efficiency. For example, the optimized runtime system 120 is a set of computer programs running on a computer system that includes a processor package 102 and an accelerator package 103.
The accelerator package 103 includes an accelerator engine 114 that performs intensive computations related to high priority workloads. For example, the accelerator engine 114 may be a TPU or GPU and the computation in the high priority workload involves training of the deep neural network, e.g., to repeatedly compute gradients of an objective function for training the neural network, or to perform reasoning using the deep neural network, i.e., after training the neural network, to generate an output using the deep neural network.
The processor package 102 includes 102, which includes cores 104a-104d responsible for performing computations, last-Level caches LLC (LLC) 106a-106d storing data for the computations, an interconnect 108a connecting the different processing cores and LLCs, and memory controllers 110a-110b. While the processor package 102 primarily handles low priority workloads, some computations (e.g., memory intensive computations) of high priority workloads still run on the processor package 102. For example, during training of the neural network, the processor package 102 may play a supporting role as a parameter server. As a parameter server, the processor package 102 may collect shared gradients from multiple accelerator packages during machine learning tasks, may aggregate calculated gradients, may update parameters in real-time using the gradients, and then provide updated parameter values to the accelerator packages. In another example, the processor package 102 may perform a feed operation, wherein the processor package interprets and reshapes the input data before sending the data to the accelerator package 103. In another example, the processor package 102 may handle irregular and complex support tasks, such as beam searching in machine translation applications.
As a result, in practice, the processor package 102 processes both low priority tasks and certain portions of high priority tasks. Low priority tasks may contend for shared resources (such as in-pipe resources, private caches shared by simultaneous multithreading, last level cache, and main memory bandwidth), thereby interfering with high priority tasks. To reduce performance bottlenecks, the optimization runtime system 120 divides the processor packages 102 into a low priority domain 126 and a high priority domain 124.
Each domain has its own dedicated processing unit, memory and memory controller. For example, the high priority domain 124 includes the dedicated cores 104a and 104b, the dedicated LLCs 106a and 106b, and the dedicated memory controller 110a. The low priority domain 125 includes the dedicated cores 104c and 104d, the dedicated LLCs 106c and 106d, and the dedicated memory controller 110b. For example, the optimization runtime system 120 can partition the processor packages 102 using Non-uniform memory access (Non-uniform memory access, NUMA) sub-domain performance isolation techniques. As a result, processor package 102 is exposed to an operating system running in a computer unit that includes system 100 as two NUMA domains, e.g., high priority domain 124 and low priority domain 126. Example techniques to implement NUMA subdomain performance isolation include Sub-NUMA clustering (Sub-NUMA Clustering, SNC), cluster-on-chip (CoD), and so forth. The control group interface 122 monitors, controls, and manages the processing of different groups in the sub-domains and their resource usage. Memory controllers 110a and 110b process memory requests in each NUMA sub-domain, respectively. As a result, local memory requests experience lower LLC and memory latency.
In some implementations, although the high priority domain 124 has been isolated from the low priority domain 126, low priority tasks may still interfere with high priority tasks due to a phenomenon known as shared memory backpressure. Shared memory backpressure occurs when a low priority task in the low priority domain 126 generates a large amount of memory traffic and saturates the bandwidth of the corresponding memory controller 110 b. In response, the memory controller 110b broadcasts a distress signal to all of the cores 104a-104d within the processor package. When the cores 104a-10d receive the distress signal from the memory controller 110b, they become throttled to avoid congestion of the interconnect 108 a. This mechanism is disadvantageous to the domain partitioning technique described above because each sub-domain (e.g., low priority sub-domain and high priority sub-domain) has already internally routed memory traffic. Memory saturation in the low priority domain 126 itself has only minimal impact on memory usage in the high priority domain 124, but shared memory backpressure still throttles the cores 104a-104b in the high priority domain 124. As a result, shared memory backpressure reduces the effectiveness of memory interference protection implemented by domain division techniques.
In some implementations, to reduce the impact of shared memory backpressure, the optimization runtime system 120 repeatedly measures the memory saturation level in the low priority domain 126, the high priority domain 124, and/or the processor package 102, and, where appropriate, performs some operations to reduce adverse effects.
For example, the optimization runtime system 120 may use existing hardware performance monitoring infrastructure, such as metrics from the Intel Uncore LLC consistency engine's performance event quick disconnect (FAST ASSERTED). The performance event reports the number of cycles of the distress signal. The optimization runtime system 120 can quantify the memory saturation by dividing this number of cycles by the total number of cycles passed between two low grade amounts. The optimization runtime system 120 then disables cache prefetching for low priority tasks in the low priority domain 126 to reduce memory traffic. This disabling may result in performance loss for low priority tasks, but may preserve performance in the high priority domain 124.
In some implementations, the optimization runtime system 120 backfills the high priority domain 124 with low priority tasks to improve system throughput. For example, the optimization runtime system 120 may be scheduled to run with a node level scheduler runtime to collect necessary task information, such as job priorities and configuration files, in both the high priority domain 124 and the low priority domain 126. The optimization runtime system 120 assigns both high-priority tasks and low-priority tasks to designated domains, with low-priority tasks being preferentially assigned to low-priority domains 126 and high-priority tasks being exclusively assigned to high-priority domains 124.
When a task is first scheduled on the processor package 102, the optimization runtime system 120 receives a high watermark (watermark) and a low watermark for each metric of the task. Optimizing the runtime system 120 performs different metrics at specific time intervals, including:
1. socket level memory bandwidth
2. Socket level memory latency
3. Socket level memory saturation
4. High priority domain memory bandwidth
Where "socket level" indicates that the metrics are performed across the processor package 102. By comparing the metrics to watermarks specified in the task profiles, the optimization runtime system 120 can choose to enhance, throttle, or maintain the resource configuration of low priority tasks in each domain. FIG. 3 and the associated description explain in detail the node-level resource management logic used by the optimization runtime system 120.
In summary, the optimization runtime system 120 operates when the processor packages 102 are assigned both high priority tasks and low priority tasks. The optimization runtime system 120 passes the performance of the processor package 102 by reallocating computing resources between high priority tasks and low priority tasks. As a result, high priority tasks will be isolated from disturbances of low priority tasks, such as memory disturbances, for example.
FIG. 2 is a flow diagram of an example process 200 for managing resources on multiple processing units. For convenience, process 200 will be described as being performed by a system, such as optimization runtime system 120 in FIG. 1.
The system may perform process 200 to configure resources on multiple processing units (e.g., processor packages 102) to improve performance of both high-priority and low-priority tasks.
As a first step, the system divides the plurality of processing units into a high priority domain and a low priority domain (210). As shown in fig. 1, the system assigns both high-priority tasks and low-priority tasks to the high-priority domain, while assigning only low-priority tasks to the low-priority domain. The low priority tasks are preferentially assigned to the low priority domain. Exemplary high priority tasks include machine learning tasks, and exemplary low priority tasks include CPU tasks.
The system then obtains shared system resource usage metrics for the high priority and low priority domains (220). For example, the system may perform four types of metrics on multiple processing units, including (1) socket level memory bandwidth, (2) socket level memory latency, (3) socket level memory saturation, and (4) high priority domain memory bandwidth. The system may measure at specified time intervals resulting in negligible performance overhead, e.g., once every 10 seconds.
In some implementations, when a task is first loaded onto multiple processing units, the system has previously collected a task profile. For example, the task profile may include a high watermark and a low watermark for each of the metrics described above.
By comparing the real-time metrics with the high and low watermarks, the system detects potential performance bottlenecks and configures memory usage in a high priority domain (230) and a low priority domain (240). For example, the system may disable or enable cache prefetching for processing cores in the low priority domain, and may activate or deactivate processing cores in both domains. Configuring the high priority and low priority domains is described below with reference to fig. 3.
The system may repeatedly perform steps 220-240 during task execution to improve overall system performance.
FIG. 3 is a flowchart of example software logic 300 for configuring resources on multiple processing units. For convenience, software logic 300 is described as being executed by a system, such as optimization runtime system 120 of FIG. 1.
After the system compares the real-time metrics with the high and low watermarks of the running task, the system may configure resources on the processing unit to reduce performance bottlenecks, as depicted in fig. 2.
The system measures socket level memory latency, socket level memory bandwidth, socket level memory saturation, and high priority domain memory bandwidth. By comparing the metric to the high watermark and the low watermark, the system can determine whether the current metric is "high" or "low". For example, the system may determine that a metric value greater than 90% of the high watermark is "high" and a metric value less than 10% of the low watermark is "low". The system configures resources on the plurality of processing units based on the following rules:
1) If the high priority domain memory bandwidth or socket level memory latency is high, the system throttles the high priority domain (302).
2) If the high priority domain memory bandwidth and socket level memory latency are both low, the system will enhance the high priority domain (304).
3) If any of the three socket level metrics is high, the system throttles the low priority field (306).
4) If the metrics for the three socket levels are all high, the system will enhance the low priority domain (308).
To throttle or enhance the high priority domain, the system increases or decreases the number of cores in the high priority domain, respectively. To medium or enhance the low priority domain, the system increases or decreases the number of cores in the low priority domain, respectively, and increases or decreases the number of cores in the low priority domain that use prefetching, respectively.
To throttle the high priority domain, the system checks if the number of cores operating in the high priority domain is greater than a minimum number of cores, e.g., as defined in the corresponding task profile (303). If so, the system will reduce the number of operation cores in the high priority domain by one.
To enhance the high priority domain, the system checks if the number of cores operating in the high priority domain is less than the maximum number of cores, e.g., as defined in the corresponding task profile (305). If so, the system will increase the number of operation cores in the high priority domain by one.
To throttle the low priority domain, the system checks if the number of cores in the low priority domain that use prefetching is greater than zero (307 a). If so, the system will shut down half of the prefetched cores in the low priority domain. Further, if the number of operation cores in the low priority domain is greater than the minimum number of cores (307 b), the system reduces the number of operation cores in the low priority domain by one.
To enhance the low priority domain, the system checks if the number of pre-fetch cores is less than the number of operation cores in the low priority domain (309 a). If so, the system will increase the number of prefetched cores in the low priority domain by one. Further, the system checks if the number of operating cores is less than the maximum number of cores in the low priority domain (309 b). If so, the system will increase the number of operation cores in the low priority domain by one.
To prioritize high priority task performance, the system is more demanding in disabling prefetching cores (turning off half of the cores in throttle mode, and adding only one core in boost mode).
The term "configuration" is used herein with respect to systems and computer program components. For a system of one or more computers to be configured to perform a particular operation or action, it is meant that the system has installed its software, firmware, hardware, or a combination thereof operable to cause the system to perform the operation or action. By one or more computer programs to be configured to perform a particular operation or action is meant that the one or more programs include instructions that, when executed by a data processing apparatus, cause the apparatus to perform the operation or action.
Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly embodied in computer software or firmware, in computer hardware, including the structures disclosed in this specification and their equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible, non-transitory storage medium, to perform or control the operation of data processing apparatus. The computer storage medium may be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them. Alternatively or additionally, the program instructions may be encoded on a manually-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by data processing apparatus.
The term "data processing apparatus" refers to data processing hardware and includes various means, devices, and machines for processing data, including for example a programmable processor, a computer, or multiple processors or computers. The apparatus may also be or further comprise a dedicated logic Circuit, for example a field programmable gate array (Field Programmable GATE ARRAY, FPGA) or an Application SPECIFIC INTEGRATED Circuit (ASIC). In addition to hardware, the apparatus may optionally include code that creates a runtime environment for the computer program, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
A computer program, which may also be referred to or described as a program, software application, app, module, software module, script, or code, may be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages; and it may be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data, such as one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, such as files that store one or more modules, sub programs, or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a data communication network.
In this specification, the term "database" is used broadly to refer to any collection of data: the data need not be structured in any particular way or structured at all, and it may be stored in a storage device at one or more locations. Thus, for example, an index database may include multiple data sets, each of which may be organized and accessed differently.
Similarly, in this specification, the term "engine" is used broadly to refer to a process, software-based system, or subsystem that is programmed to perform one or more specific functions. Typically, the engine will be implemented as one or more software modules or components installed on one or more computers in one or more locations. In some cases, one or more computers will be dedicated to a particular engine. In other cases, multiple engines may be installed and run on the same computer.
The processes and logic flows described in this specification can be performed by one or more programmable computers running one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, or combination of, special purpose logic circuitry (e.g., an FPGA or ASIC) and one or more programmed computers.
A computer suitable for running a computer program may be based on a general purpose or special purpose microprocessor or both, or on any other type of central processing unit. Typically, a central processing unit will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a central processing unit for executing or executing instructions and one or more memory devices for storing instructions and data. The central processing unit and the memory may be supplemented by, or incorporated in, special purpose logic circuitry. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data (e.g., magnetic, magneto-optical disks, or optical disks). A computer need not have such devices. Furthermore, the computer may be embedded in another device, such as a mobile phone, personal digital assistant (Personal DIGITAL ASSISTANT, PDA), mobile audio or video player, a gaming machine, a global positioning system (Global Positioning System, GPS) receiver, or a portable storage device, such as a universal serial bus (Universal Serial Bus, USB) flash drive, to name a few.
Computer readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, such as internal hard disks or removable disks; magneto-optical disk; CD ROM and DVD-ROM disks.
To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a Cathode Ray Tube (CRT) or Liquid crystal display (Liquid CRYSTAL DISPLAY, LCD) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices may also be used to provide for interaction with a user; for example, feedback provided to the user may be any form of sensory feedback, such as visual feedback, auditory feedback, or tactile feedback; and input from the user may be received in any form, including acoustic, speech, or tactile input. In addition, the computer may interact with the user by sending and receiving documents to and from the device used by the user. For example, by sending a web page to a web browser on the user device in response to a request received from the web browser. Moreover, the computer may interact with the user by sending text messages or other forms of messages to a personal device (e.g., a smart phone running a messaging application) and receiving a returned response message from the user.
The data processing apparatus for implementing the machine learning model may also include, for example, a dedicated hardware accelerator unit for processing the common and computationally intensive portions of the machine learning training or production (i.e., reasoning) workload.
The machine learning model may be implemented and deployed using a machine learning framework, such as TensorFlow framework, microsoft Cognitive Toolkit framework, APACHE SINGA framework, or Apache MXNet framework.
Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front-end component (e.g., a client computer having a graphical user interface, a Web browser, or an app through which a user can interact with an implementation of the subject matter described in this specification). Or any combination of one or more such back-end components, middleware components, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include a local area network (Local Area Network, LAN) and a wide area network (Wide Area Network, WAN), such as the internet.
The computing system may include clients and servers. The client and server are typically remote from each other and typically interact through a communication network. The relationship between client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, the server transmits data, such as HTML pages, to the user device, e.g., for the purpose of displaying data to and receiving user input from a user interacting with the device acting as a client. Data generated at the user device, e.g., results of a user interaction, may be received at the server from the device.
While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Similarly, although operations are depicted in the drawings and described in the claims in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
Specific embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying drawings do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous.
Claims (14)
1. A method for managing efficiency of a processing system, the method comprising:
Data is obtained that divides a plurality of general purpose processing units in a processor package of a processing system into a high priority domain and a low priority domain,
Wherein the processing system further comprises an accelerator package comprising a plurality of dedicated hardware accelerators, the dedicated hardware accelerators being assigned to perform accelerated workloads, wherein,
The general purpose processing units in the high priority domain are assigned to execute tasks comprising one or more high priority tasks and one or more low priority tasks,
The general purpose processing units in the low priority domain are assigned to execute only low priority tasks, and
The high priority task is a task supporting the accelerated workload; and
While the processing system is running, obtaining a shared memory usage metric characterizing usage of shared system memory by the high priority domain and the low priority domain; and
Adjusting a configuration of (i) the high priority domain, (ii) the low priority domain, or (iii) both, based on the shared memory usage metric, to adjust utilization of the shared system memory by the general purpose processing unit running low priority tasks;
wherein the shared memory usage metric comprises a metric of system memory saturation;
When the shared memory usage metric exceeds a first watermark, determining that the system memory saturation is high; and
In response to determining that the system memory saturation is high, the number of active general purpose processors in the low priority domain is reduced.
2. The method of claim 1, wherein the acceleration workload is a machine learning workload.
3. The method of claim 1, wherein the shared memory usage metric comprises a metric of system memory bandwidth.
4. A method according to claim 3, wherein said adjusting comprises:
Reducing the number of active general purpose processors in the low priority domain when the system memory bandwidth is high; or (b)
When the system memory bandwidth is low, the number of active general purpose processors in the low priority domain is increased.
5. The method of claim 3, wherein the shared memory usage metric comprises a metric of system memory latency.
6. The method of claim 5, wherein the adjusting comprises:
reducing the number of active general purpose processors in the low priority domain when the system memory latency is high; or (b)
When the system memory latency is low, the number of general purpose processors active in the low priority domain is increased.
7. The method of claim 1, wherein the adjusting comprises:
When the system memory saturation is low, the number of active general purpose processors in the low priority domain is increased.
8. The method of claim 5, wherein the shared memory usage metric comprises a metric of high priority domain memory bandwidth.
9. The method of claim 8, wherein the adjusting comprises:
Reducing the number of active general purpose processors in the high priority domain when the high priority domain memory bandwidth is high; or (b)
When the high priority domain memory bandwidth is low, the number of active general purpose processors in the high priority domain is increased.
10. The method of claim 5, wherein the adjusting comprises:
Reducing the number of active general purpose processors in the low priority domain when the measure of system memory bandwidth or system memory latency is high, and
When the metrics of system memory bandwidth and system memory latency are low, the number of active general purpose processors in the low priority domain is increased.
11. The method of claim 10, wherein the adjusting comprises:
reducing the number of active general purpose processors in the low priority domain using cache prefetching when the measure of system memory bandwidth or system memory latency is high, and
When the metrics of system memory bandwidth and system memory latency are low, the number of active general purpose processors in the low priority domain that use cache prefetching is increased.
12. The method of claim 8, wherein the adjusting comprises:
reducing the number of active general purpose processors in a high priority domain when the measure of high priority domain memory bandwidth or system memory latency is high, and
When the metrics of high priority domain memory bandwidth and system memory latency are low, the number of active general purpose processors in the high priority domain is increased.
13. A system for managing the efficiency of a processing system, the system comprising one or more computers and one or more storage devices storing instructions that, when executed by the one or more computers, cause the one or more computers to perform the operations of the respective method of any one of claims 1 to 12.
14. One or more computer storage media storing instructions that, when executed by one or more computers, cause the one or more computers to perform the operations of the respective method of any one of claims 1 to 12.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201762589535P | 2017-11-21 | 2017-11-21 | |
US62/589,535 | 2017-11-21 | ||
PCT/US2018/062111 WO2019104087A1 (en) | 2017-11-21 | 2018-11-20 | Managing processing system efficiency |
Publications (2)
Publication Number | Publication Date |
---|---|
CN111344677A CN111344677A (en) | 2020-06-26 |
CN111344677B true CN111344677B (en) | 2024-05-17 |
Family
ID=
Citations (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN101266557A (en) * | 2007-03-16 | 2008-09-17 | Sap股份公司 | Multi-objective allocation of computational jobs in client-server or hosting environments |
CN103918242A (en) * | 2011-10-03 | 2014-07-09 | 高通股份有限公司 | Method and apparatus for filtering and processing received vehicle peer transmissions based on reliability information |
Patent Citations (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN101266557A (en) * | 2007-03-16 | 2008-09-17 | Sap股份公司 | Multi-objective allocation of computational jobs in client-server or hosting environments |
CN103918242A (en) * | 2011-10-03 | 2014-07-09 | 高通股份有限公司 | Method and apparatus for filtering and processing received vehicle peer transmissions based on reliability information |
Non-Patent Citations (1)
Title |
---|
实时操作系统任务调度算法的硬件实现;李岩 等;《计算机工程与应用》;20101211;第46卷(第35期);第52-54、64页 * |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11704158B2 (en) | Managing processing system efficiency | |
US9571561B2 (en) | System and method for dynamically expanding virtual cluster and recording medium on which program for executing the method is recorded | |
US20160217003A1 (en) | Task Scheduling for Highly Concurrent Analytical and Transaction Workloads | |
CN106557369A (en) | A kind of management method and system of multithreading | |
US9239734B2 (en) | Scheduling method and system, computing grid, and corresponding computer-program product | |
JP6580307B2 (en) | Multi-core apparatus and job scheduling method for multi-core apparatus | |
JP2013504807A (en) | Method and apparatus for data center automation | |
Jeon et al. | TPC: Target-driven parallelism combining prediction and correction to reduce tail latency in interactive services | |
CN104407912A (en) | Virtual machine configuration method and device | |
US20200385726A1 (en) | Oversubscription scheduling | |
Huang et al. | Novel heuristic speculative execution strategies in heterogeneous distributed environments | |
CN107624181B (en) | Virtual machine management method and apparatus including idling and scheduling of virtual processors | |
CN104657198A (en) | Memory access optimization method and memory access optimization system for NUMA (Non-Uniform Memory Access) architecture system in virtual machine environment | |
CN104820616A (en) | Task scheduling method and device | |
KR20130080663A (en) | Method and apparatus for graphic processing using multi-threading | |
Razavi et al. | FA2: Fast, accurate autoscaling for serving deep learning inference with SLA guarantees | |
CN108574600B (en) | Service quality guarantee method for power consumption and resource competition cooperative control of cloud computing server | |
JP2015011365A (en) | Provisioning apparatus, system, provisioning method, and provisioning program | |
US8966225B2 (en) | Reducing number of processing units generating calculation result when communication time to another node takes longer than calculation time | |
CN114217974A (en) | Resource management method and system in cloud computing environment | |
CN103049326A (en) | Method and system for managing job program of job management and scheduling system | |
CN111344677B (en) | Managing processing system efficiency | |
Zhang et al. | Charm: Collaborative host and accelerator resource management for gpu datacenters | |
CN117369990A (en) | Method, device, system, equipment and storage medium for scheduling computing power resources | |
Sun et al. | An energy efficient and runtime-aware framework for distributed stream computing systems |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
GR01 | Patent grant |