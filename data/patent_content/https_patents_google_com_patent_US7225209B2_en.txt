US7225209B2 - Computer-implemented method for allocating new additional area for the dataset in storage based on the size of the new additional area wherein if the new area number does not exceed clipping threshold, the size of a new additional area being greater than the size of each previously allocated additional area of the dataset - Google Patents
Computer-implemented method for allocating new additional area for the dataset in storage based on the size of the new additional area wherein if the new area number does not exceed clipping threshold, the size of a new additional area being greater than the size of each previously allocated additional area of the dataset Download PDFInfo
- Publication number
- US7225209B2 US7225209B2 US10/703,998 US70399803A US7225209B2 US 7225209 B2 US7225209 B2 US 7225209B2 US 70399803 A US70399803 A US 70399803A US 7225209 B2 US7225209 B2 US 7225209B2
- Authority
- US
- United States
- Prior art keywords
- size
- area
- new
- additional area
- dataset
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related, expires
Links
- 238000000034 method Methods 0.000 title claims abstract description 53
- 238000004519 manufacturing process Methods 0.000 claims abstract description 16
- 230000006870 function Effects 0.000 claims description 43
- 230000015654 memory Effects 0.000 claims description 12
- 238000012886 linear function Methods 0.000 claims description 8
- 238000013500 data storage Methods 0.000 claims description 4
- 230000004044 response Effects 0.000 claims 11
- 230000003044 adaptive effect Effects 0.000 description 49
- 238000007726 management method Methods 0.000 description 17
- 238000010586 diagram Methods 0.000 description 5
- 230000008859 change Effects 0.000 description 4
- 238000004590 computer program Methods 0.000 description 2
- 230000008569 process Effects 0.000 description 2
- 239000004065 semiconductor Substances 0.000 description 2
- 238000013459 approach Methods 0.000 description 1
- 238000012986 modification Methods 0.000 description 1
- 230000004048 modification Effects 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 230000008520 organization Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/02—Addressing or allocation; Relocation
- G06F12/0223—User address space allocation, e.g. contiguous or non contiguous base addressing
- G06F12/023—Free address space management
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99951—File or database maintenance
- Y10S707/99956—File allocation
Definitions
- the invention relates to a technique, specifically a method, apparatus, and article of manufacture that implements the method, to determine an amount of space to allocate for a dataset as the dataset grows.
- This technique is particularly, though not exclusively, suited for use within a database management system.
- Database management systems allow large volumes of data to be stored and accessed efficiently and conveniently in a computer system.
- data is stored in database tables which effectively organize the data into rows and columns.
- a database engine responds to user commands to store and access the data.
- database objects like tables and indexes, are contained in datasets.
- a dataset is also referred to as a file.
- the dataset is typically stored on one or more hard disk drives.
- the amount of space available on the disk drives is limited and is managed by an operating system.
- An extent is an amount of space allocated on a logical volume for storing part of a dataset.
- a logical volume can be a single disk drive, a portion of a single disk drive, or a portion of multiple disk drives.
- a dataset may have one or more extents.
- each dataset is associated with a primary extent.
- additional, or secondary extents may be allocated to provide additional space for the dataset.
- the operating system has a limit as to the total number of secondary extents that may be allocated to a dataset.
- the size of each secondary extent is the same.
- An extent comprises pages for storing the dataset.
- the page size can be equal to four kilobytes, eight kilobytes, sixteen kilobytes, or thirty-two kilobytes.
- Logical volumes are mapped to physical disk drives and store data in units such as cylinders, for example.
- a cylinder has a predefined amount of storage space. The amount of storage space provided in a cylinder is specific to the disk drive model.
- the extent size may be specified in bytes, kilobytes, megabytes, pages, or cylinders.
- an exemplary dataset 20 has multiple extents in accordance with the prior art.
- the dataset 20 is stored in a primary extent 22 of size p and n secondary extents of size s, S 1 to S n , 24 to 26 , respectively.
- the database has parameters that allow a user to specify the size p of the primary extent and the size s of the secondary extents.
- the maximum size of that dataset is implicitly determined, and a primary extent is allocated initially to store that dataset.
- the size of the primary extent is typically smaller than the maximum size of the dataset.
- Secondary extents are allocated on demand to store the dataset as the dataset grows. The number of secondary extents that can be allocated for a dataset, also referred to as a maximum number of secondary extents, is limited.
- a system administrator may specify a primary and secondary extent size when creating tablespaces or indexes, or accept default sizes.
- the size of the secondary extent is small, typically the maximum number of extents is reached before the dataset can reach the maximum possible size. Therefore, the dataset is prevented from growing, and no additional data or records may be added to that dataset. Hence, an operation to add data cannot be completed and an application failure occurs, which may result in an application outage.
- the system administrator To increase the maximum amount of space that can be used for the dataset, the system administrator, through the facilities of the database management system, defines a new dataset with a new larger primary extent size and/or secondary extent sizes that are sufficiently large to store the maximum size of the dataset, copies the data from the old dataset to the new dataset, and renames the new dataset with the name of the old dataset. Creating the new dataset and copying the data takes time and increases the length of the application outage.
- the system administrator Since the system defined default size for the secondary extents is typically very small, the system administrator usually provides an explicit secondary extent size that is larger than the default secondary extent size to help prevent using up available extents. However, increasing the size of secondary extents may result in wasted space—especially for small datasets. Furthermore, it is not known whether a dataset will reach its ultimate size, therefore much of the allocated space may not be used.
- This technique should efficiently allocate space for small datasets. This technique should also reduce the likelihood of using the maximum number of extents prior to reaching the maximum size of the dataset.
- the present invention discloses a method, apparatus, and article of manufacture for allocating space for a dataset.
- a method and article of manufacture implementing the method, allocates space for a dataset.
- the dataset is associated with an initial area and zero or more additional allocated areas to provide space for storing the dataset.
- the size of a new additional area is determined.
- the new additional area is associated with a new area number, and the size of the new additional area is based on the new area number. Additional space for the dataset is allocated based on the size of the new additional area.
- an apparatus stores a dataset.
- a computer has a data storage device connected thereto.
- the data storage device has a plurality of areas for storing a dataset.
- the plurality of areas comprises an initial area having an initial area size and a plurality of additional areas having an additional-area size, wherein the additional-area size varies.
- the additional-area size monotonically increases.
- FIG. 1 depicts a dataset and the extents associated with the dataset in accordance with the prior art
- FIG. 2 depicts an illustrative computer system having an adaptive allocation module in accordance with an embodiment of the present invention
- FIG. 3 depicts a high-level flowchart of a portion of the database engine, or alternately the operating system, that invokes the adaptive allocation module of FIG. 2 ;
- FIG. 4 depicts a high-level block diagram of an embodiment of the adaptive allocation module of FIG. 2 ;
- FIG. 5 depicts a flowchart of a more-detailed embodiment of the adaptive allocation module of FIG. 4 ;
- FIG. 6 depicts a more-detailed flowchart of an embodiment of a technique to determine a calculated size of a new secondary extent of FIG. 5 ;
- FIG. 7 depicts a graph illustrating the size of secondary extents for datasets having a maximum dataset size of up to thirty-two gigabytes
- FIG. 8 depicts a graph illustrating the size of secondary extents for datasets having a maximum dataset size of sixty-four gigabytes
- FIG. 9 depicts exemplary primary and secondary extents to store a dataset having a maximum dataset size of sixty-four gigabytes that were allocated with a size that was determined in accordance with the technique of FIGS. 5 and 6 ;
- FIG. 10 depicts a flowchart of a more general embodiment of the technique of FIG. 6 ;
- FIG. 11 depicts a high-level flowchart of a process to create and populate an extent allocation look-up table in accordance with the technique of FIG. 6 , and using the extent allocation look-up table to determine the size of a new secondary extent;
- FIG. 12 depicts a diagram of the format of an exemplary extent allocation look-up table of FIG. 11 ;
- FIG. 13 depicts a diagram of an exemplary extent allocation look-up table using the format of FIG. 12 and generated in accordance with the technique of FIG. 6 ;
- FIG. 14 depicts an embodiment of a technique to determine a size of a secondary extent based on an extent number and a maximum dataset size using the extent allocation look-up table of FIG. 13 ;
- FIG. 15 depicts a graph of an alternate embodiment of the technique to determine the size of a secondary extent using an exponential function, and alternately a combination of a linear function and an exponential function.
- the teachings of the present invention can be utilized to improve performance and availability in substantially any system that allocates space for datasets.
- the invention is integrated as a component in a database management system. Alternately, the invention may be integrated in an operating system. To simplify the following discussion and facilitate reader understanding, the present invention will be described in the context of use in a database management system.
- a technique allocates space for a dataset.
- the size of a new additional area for that dataset is also small so that space is not wasted.
- the size of the additional areas also increases until, for large datasets, an additional-area clipping threshold is reached at which the size of the additional areas remains constant. In this way, a maximum number of additional areas is not likely to be used prior to reaching the maximum size of the dataset and allocating very large area sizes is avoided.
- a dataset is associated with an initial or primary area to provide space for initially storing the dataset.
- Each additional area is associated with an area number, and the size of the additional areas is based on the area number.
- area refers to a unit of space for storing, at least in part, a dataset or file.
- area refers to an extent.
- area is not limited to extents and may refer to other allocation units for storing datasets or files.
- FIG. 2 depicts an illustrative computer system 30 that utilizes the teachings of the present invention.
- the computer system 30 comprises a processor 32 , display 34 , input interfaces (I/F) 36 , communications interface 38 , memory 40 , disk memories 44 such as hard disk drive 46 and optical disk drive 48 , and output interface(s) 50 , all conventionally coupled by one or more busses 52 .
- the input interfaces 36 comprise a keyboard 54 and mouse 56 .
- the output interface is a printer 58 .
- the communications interface 38 is a network interface card (NIC) that allows the computer system 30 to communicate via a network, such as the Internet.
- NIC network interface card
- the memory 40 generally comprises different modalities, illustratively semiconductor memory, such as random access memory (RAM), and disk drives.
- the memory 40 stores operating system 60 and application programs such as the database management system 62 .
- the operating system 60 may be implemented by any conventional operating system, such as z/OS® (Registered Trademark of International Business Machines Corporation), AIX® (Registered Trademark of International Business Machines Corporation), UNIX® (Unix is a registered trademark in the United States and other countries licensed through X/Open Company Limited), and WINDOWS® (Registered Trademark of Microsoft Corporation), and LINUX® (Registered Trademark of Linus Torvalds).
- z/OS® Registered Trademark of International Business Machines Corporation
- AIX® Registered Trademark of International Business Machines Corporation
- UNIX® Unix is a registered trademark in the United States and other countries licensed through X/Open Company Limited
- WINDOWS® Registered Trademark of Microsoft Corporation
- LINUX® Registered Trademark of Linus Torvalds
- the database management system 62 is a DB2® system (DB2® is a registered trademark of International Business Machines Corporation). However, the inventive technique is not meant to be limited to a DB2® database management system, and may be used with other database management systems.
- a database engine 64 allows a user to execute commands to add data to, delete data from, update data within or search the database tables.
- the commands are Structured Query Language (SQL) statements that conform to a Structured Query Language standard as published by the American National Standards Institute (ANSI) or the International Standards Organization (ISO). In alternate embodiments, languages other than SQL may be used.
- SQL Structured Query Language
- the specific software modules that implement the present invention are incorporated in the database management system 62 .
- the software modules that implement the present invention are incorporated in the operating system 60 .
- the software modules are tangibly embodied in a computer-readable medium, for example, memory 40 or, more specifically, one of the disk drives 44 , and are comprised of instructions which, when executed, by the computer system 40 , cause the computer system 40 to utilize the present invention.
- the database management system 62 is comprised of the software modules and data.
- the memory 40 may store a portion of the software modules and data making up the database management system 62 in semiconductor memory, while other software modules and data are stored in disk memory.
- the memory 40 is comprised of the following:
- the present invention may be implemented as a method, apparatus, or article of manufacture using standard programming and/or engineering techniques to produce software, firmware, hardware, or any combination thereof.
- article of manufacture (or alternatively, “computer program product”) as used herein is intended to encompass a computer program accessible from any computer-readable device.
- FIG. 3 depicts a high-level flowchart of an embodiment of a portion of the database engine which invokes the adaptive allocation module of FIG. 2 .
- a command is received to add data to a dataset. For example, a SQL INSERT command may be received to add new data to a table associated with the dataset.
- Step 92 determines whether the dataset is full, in other words, whether the dataset has sufficient allocated space to store the new data. If not, in step 94 , the database engine invokes the adaptive allocation module to determine the size of a new additional area to be added, and allocates space for the new additional area based on the determined size.
- step 96 the database engine adds the data to the dataset. If step 92 determines that an additional area does not need to be allocated, step 92 proceeds to step 96 .
- FIG. 4 depicts a high-level flowchart of an embodiment of a technique of the adaptive allocation module of FIG. 2 .
- the dataset has an initial area and may have zero or more additional areas.
- the additional areas are associated with area numbers.
- step 100 the size of a new additional area is determined to provide additional space for the dataset.
- the new additional area is associated with a new additional area number.
- the size of the new additional area is based on the new additional area number. In a more particular embodiment, when the additional area number is low for a small dataset, the size of the new additional area is small. As the number of additional areas increases, the size of the new additional area increases until, for large datasets, an additional area clipping threshold is reached at which the size of the additional areas remains constant.
- step 102 additional space for the dataset is allocated based on the determined size of the new additional area.
- the initial area is a primary extent
- the additional areas are secondary extents
- the additional area numbers are secondary extent numbers.
- the term “primary quantity” refers to the variable called “PQTY” that contains the size of the primary extent.
- the system contains a default value for the size of the primary extent (PQTY_def).
- a user for example, the system administrator, may override the system default value by specifying a primary extent size which is stored in a variable called “PQTY_user.”
- the term “SQTY_user” refers to a variable that contains a user-specified value for the size of a secondary extent.
- the term “SQTY” refers to a size of the new secondary extent.
- variable “ss_extent” refers to a sliding scale extent value which is an intermediate value of the size of the new secondary extent that is determined based on the new secondary extent number and the maximum size of the dataset prior to applying at least a subset of the rules described below.
- MaxAlloc refers to a variable that contains the maximum size of a secondary extent for a dataset.
- the values of PQTY, PQTY_user, PQTY_def, SQTY, SQTY_user, ss_extent and MaxAlloc are specified in cylinders.
- PQTY, PQTY_user, PQTY_def, SQTY, SQTY_user, ss_extent and MaxAlloc are specified using any one of the following: bytes, kilobytes, gigabytes, and pages.
- the following are rules used by the adaptive allocation module to determine the size of the new secondary extent in one embodiment of the present inventive technique.
- Table 1 depicts, for various maximum dataset sizes, the maximum number of secondary extents to store the dataset at the maximum dataset size, and the maximum secondary extent size. For example, for a dataset that can store up to eight gigabytes, the maximum number of secondary extents to store that dataset is equal to 154, and the maximum secondary extent size is equal to 127 cylinders.
- the size of the secondary extents of the subset increases according to a sliding scale so that the maximum dataset size can be reached within the maximum number of secondary extents allowed for that dataset size.
- the maximum secondary extent size is equal to a first predetermined maximum size for datasets having a maximum dataset size that is less than a predetermined dataset size threshold.
- the predetermined dataset size threshold is equal to thirty-two gigabytes and the predetermined maximum size is equal to a first predetermined size limit.
- the first predetermined size limit is equal to 127 cylinders.
- the maximum secondary extent size is equal to a second predetermined size limit.
- the second predetermined size limit is equal to 559 cylinders.
- this technique improves disk space utilization, reduces the likelihood that the maximum number of extents is reached prior to the maximum dataset size, and can improve performance when adding data.
- space for small datasets is allocated efficiently because the size of the secondary extents is small when the number of secondary extents is low.
- the secondary extent size does not continue to increase beyond the maximum secondary extent size. Therefore the technique avoids very large secondary extent sizes. Contiguous space to allocate a very large extent may be difficult to find on a logical volume. Using a maximum secondary extent size increases the likelihood that sufficient space will be found on a logical volume to allocate to the new secondary extent.
- the predetermined secondary extent clipping threshold is the midpoint of the maximum number of secondary extents. Choosing the midpoint as the predetermined secondary extent clipping threshold helps to reduce the maximum secondary extent size and reduces the potential for wasting disk space.
- the midpoint is determined by dividing the maximum number of secondary extents for a full-size dataset by two. For example, if 255 secondary extents are used to reach the full size for a dataset, the midpoint is equal to 127 or 128, depending on the embodiment. Alternately, the midpoint is not used. For example, for small datasets having a maximum number of fifty-four secondary extents, the maximum size allowed for a secondary extent may not be reached.
- the predetermined secondary extent clipping threshold is not at the midpoint but is at a different point.
- FIG. 5 depicts a flowchart of an embodiment of the adaptive allocation module of FIG. 2 that implements the rules described above.
- the following variables may be supplied to the adaptive allocation module.
- the size of the primary extent (PQTY) either specified by a user (PQTY_user) or a default value (PQTY_def) rounded up to the nearest cylinder is provided.
- the size of a user-specified secondary extent (SQTY_user) may be provided.
- the maximum size of the dataset is provided.
- a dataset may have any of the following maximum dataset sizes: 1, 2, 4, 16, 32 or 64 gigabytes. However, the invention is not meant to be limited to 1, 2, 4, 16, 32 or 64 gigabyte datasets and may be used with other maximum dataset sizes.
- the adaptive allocation module determines whether a user specified that the secondary extent size is equal to zero. In particular, the adaptive allocation module determines whether the user-defined variable, called SQTY_user, is equal to zero. If so, the adaptive allocation module exits (step 110 ), and a new secondary extent is not allocated.
- SQTY_user the user-defined variable
- step 112 the adaptive allocation module determines a calculated size of the new secondary extent, ss_extent, based on the new secondary extent number and the maximum size of the dataset.
- the value of ss_extent represents a number of cylinders.
- a variable stores a maximum size of a secondary extent for a dataset, and is set equal to a first maximum value (FirstMaxValue). In one embodiment, the value of the first maximum value (FirstMaxValue) is equal to 127 (cylinders).
- Step 116 determines whether the maximum dataset size is greater than or equal to a dataset size threshold (SizeThreshold). If so, in step 118 , the maximum size of the secondary extent for the dataset (MaxAlloc) is set equal to a second maximum value (SecondMaxValue). In one embodiment, the value of the second maximum value is equal to 559 (cylinders). Step 118 continues to step 120 . If, in step 116 , the maximum dataset size is less than the dataset size threshold (SizeThreshold), step 116 proceeds to step 120 .
- step 120 the adaptive allocation module determines whether a user specified the size of the secondary extents. In particular, in step 120 , the adaptive allocation module determines whether the variable called SQTY_user is specified. In step 122 , the adaptive allocation module determines the size of the new secondary extent (SQTY), in cylinders, as follows:
- step 124 the adaptive allocation module allocates a new secondary extent with the number of cylinders specified by SQTY.
- step 126 the adaptive allocation module exits.
- step 120 determines that the user did not specify a secondary extent size
- step 128 the adaptive allocation module determines the size of the new secondary extent as follows:
- FIG. 6 depicts a more-detailed flowchart of determining a calculated size of the new secondary extent, ss_extent, based on the new secondary extent number and the maximum size of the dataset of step 112 of FIG. 5 .
- a variable called “Extent no.” represents the new secondary extent number about to be allocated.
- the adaptive allocation module will use either a first sliding-scale or a second sliding-scale to determine the calculated size of the new secondary extent, ss_extent, for at least a subset of secondary extent numbers.
- step 130 the adaptive allocation module determines whether the maximum size of the dataset is greater than or equal to thirty-two gigabytes. If not, step 132 determines whether the value of the new secondary extent number (extent no.) is less than one hundred twenty-eight, a first secondary extent clipping threshold. If so, in step 134 , the calculated size of the new secondary extent, ss_extent is set equal to the extent number. In this way, the intermediate value of the size of the new secondary extent is determined using a first sliding scale. The adaptive allocation module continues to step 138 which proceeds to step 116 of FIG. 5 . If step 132 determined that the value of the new secondary extent number is greater than or equal to 128, in step 136 , the calculated size of the new secondary extent, ss_extent, is set equal to 127, and step 136 proceeds to step 138 .
- step 130 the adaptive allocation module determined that the maximum dataset size is greater than or equal to thirty-two gigabytes, a second sliding scale will be used to determine the size of the new secondary extent.
- step 152 the adaptive allocation module determined that the value of the new secondary extent number is not less than one hundred twenty-eight, another secondary extent clipping threshold, in step 156 , the adaptive allocation module sets the value of ss_extent equal to 559, and the adaptive allocation module proceeds step 138 .
- the technique has two sliding scales.
- a first sliding scale is used for datasets which can grow up to sixteen gigabytes
- a second sliding scale is for datasets that can grow up to thirty-two gigabytes and sixty-four gigabytes.
- a single sliding scale is used for all dataset sizes.
- three or more dataset size thresholds may be provided and three or more respective sliding scales may be used.
- the slope of the function m represents the change in the size of the secondary extent divided by the change in the secondary extent number.
- the slope of the second sliding scale starts at one and increases to two, four and ten as the secondary extent numbers increase.
- the following exemplary pseudo-code is used to determine the size of the new secondary extent in cylinders.
- the variable ss_extent contains a calculated size of the new secondary extent in cylinders.
- FIG. 7 depicts a graph 160 illustrating the size of secondary extents for datasets having a maximum dataset size up to and including sixteen gigabytes that was generated in accordance with the technique of FIG. 6 .
- the x-axis 162 represents the extent number which ranges from one to a maximum number of secondary extents 164 which, in one embodiment is equal to 246.
- the y-axis 166 represents the size of the secondary extents in cylinders (Cyls).
- the size of the secondary extents increases linearly until reaching a maximum secondary extent size 168 at a secondary extent clipping threshold 170 , which, in this example, is equal to one hundred twenty-eight. For small datasets, for example, one gigabyte datasets, the sizes of the secondary extents increase with respect to the extent number, and the secondary extent clipping threshold is not reached.
- FIG. 8 depicts a graph 180 illustrating the size of secondary extents for datasets having a maximum dataset size of sixty-four gigabytes that was generated in accordance with the technique of FIG. 6 .
- the x-axis 182 represents the extent number.
- the y-axis 184 represents the size of the secondary extents in cylinders. Initially, the size of the secondary extents increases slowly, and continues to increase more rapidly as the secondary extent numbers increase until a secondary extent clipping threshold 186 is reached, at which point, the size of the secondary extents remains constant at the maximum secondary extent size 188 until the maximum number of secondary extents 190 is reached.
- the secondary extent clipping threshold 186 is equal to one hundred twenty-eight. The following relationship describes the relationship of the sum of the secondary extent sizes to the maximum size of the dataset:
- MaximumSizeOftheDataset ⁇ SizeOfPrimaryExtent + ⁇ i 1 MaximumNumberOfSecondaryExtents ⁇ ⁇ SizeOfSecondaryExtent ⁇ ( i )
- the secondary extent clipping threshold, the sliding scale, the maximum number of secondary extents and the maximum size of the secondary extents are chosen in accordance with the above relationship.
- the maximum size of the dataset is equal to the sum of the primary extent size and all secondary extent sizes. Alternately, the maximum size of the dataset is less than, but close to, the sum of the primary and secondary extent sizes.
- the secondary extent size, ss_extent monotonically increases.
- FIG. 9 depicts an exemplary dataset 200 having a maximum dataset size of sixty-four gigabytes, in which its secondary extents were allocated using the technique of FIG. 6 .
- the dataset 200 has a primary extent 202 .
- the first secondary extent S 1 204 has a size of one cylinder.
- the second secondary extent S 2 206 has a size of two cylinders.
- the size of the secondary extents continues to increase up to the 127 th secondary extent S 127 208 which has a size of 559 cylinders.
- the size of the secondary extents remains at 559 cylinders until the 255 th secondary extent number S 255 210 is reached.
- FIG. 9 shows the primary and secondary extents as contiguous blocks of memory. In practice, the primary and secondary extents may not be contiguous. In addition, the primary and secondary extents may reside on different volumes, that is, hard disk drives.
- FIG. 10 depicts a flowchart of a more general embodiment of the technique of determining a size of an additional area, for example, a secondary extent, of step 112 FIG. 5 .
- the term “Area no.” refers to a number of an additional area, such as, for example, a secondary extent number
- the term “ss_area” refers to the calculated size of the additional area, such as, for example, the calculated size of a secondary extent.
- the adaptive allocation module determines whether the maximum (max) dataset size is greater than or equal to a dataset size threshold (DatasetSizeThreshold).
- DatasetSizeThreshold a dataset size threshold
- ss_area is rounded to the nearest whole cylinder.
- the value of ss_area is rounded to the nearest whole cylinder.
- the polynomial is monotonically increasing. Step 226 proceeds to step 230 and exits.
- step 228 the value of ss_area is set equal to a low dataset maximum allocation value (LowDatasetMaxAlloc). Step 228 proceeds to step 230 and exits.
- the function f 1 can take any of the forms described above for f 0 .
- the first, second, . . . , nth thresholds have the following relationship: First threshold ⁇ second threshold ⁇ . . . ⁇ nth threshold
- the adaptive allocation module may have any number n thresholds at which the function that is used to determine the size of the additional area changes.
- steps 236 and 238 , and 240 and 242 determine the size of the additional area, as in steps 232 and 234 , except that the functions f 2 and f n , respectively, may differ.
- step 240 determines that the value of the new additional area number is not less than the Nth threshold, in step 244 , the adaptive allocation module is set equal to a high dataset maximum allocation value (HighDatasetMaxAlloc).
- the Nth threshold is a second additional area clipping threshold.
- the first and second additional area clipping thresholds may be the same. Alternately, the first and second additional area clipping thresholds may differ. Step 240 proceeds to step 230 and exits.
- FIG. 5 when the general technique of FIG. 10 is used with FIG. 5 , FIG. 5 is modified and the terms of FIG. 5 are used more generally.
- the term “ss_extent” of FIG. 5 is replaced with the term “ss_area.”
- the term “SQTY_user” refers to a user-specified additional area size
- the term “PQTY” refers to an initial area size
- the term “SQTY” refers to the size of the new additional area.
- Step 112 of FIG. 5 determines a calculated size of a new additional area based on the new additional area number and the maximum size of the dataset.
- Step 124 of FIG. 5 allocates a new additional area based on SQTY.
- FIG. 11 depicts a high-level flowchart of a process to allocate a secondary extent using an extent allocation look-up table that was generated in accordance with the technique of FIG. 6 .
- an extent allocation look-up table is created with secondary extent sizes that were calculated in accordance with FIG. 6 , for predetermined ranges of extent numbers for a set of maximum dataset sizes.
- the size of a new secondary extent is determined based on the look-up table.
- a secondary extent is allocated based on the size of the new secondary extent that was retrieved from the look-up table.
- the extent allocation look-up table may be applied to areas.
- FIG. 12 depicts a block diagram of the format 270 of an exemplary extent allocation look-up table entry of FIG. 11 .
- Each record of the lookup table has an extent number 272 , a maximum (Max) dataset size to which dataset can grow 274 , and a secondary extent size 276 .
- FIG. 13 depicts a block diagram of portions of an exemplary extent allocation look-up table 280 that is populated with values that were generated in accordance with the technique of FIG. 6 .
- the number of secondary extents ranges from 1 to 54. The value of the secondary extent is equal to the extent number.
- FIG. 14 depicts a more-detailed embodiment of a technique to determine a size of a secondary extent based on an extent number and a maximum dataset size using the extent allocation look-up table of step 120 of FIG. 5 .
- the adaptive allocation module determines a size of the new secondary extent, ss_extent, by looking up the size of the new secondary extent in the look-up table based on the value of the new secondary extent number and the maximum dataset size.
- FIG. 15 depicts a graph 300 of an alternate embodiment of the technique to determine the size of a secondary extent using an exponential function 302 .
- the x-axis 304 represents the secondary extent number.
- the y-axis 306 represents the size of the secondary extent.
- a and b are real numbers.
- the value of ss_extent is then rounded to the nearest whole cylinder value. In one embodiment, the value of b is equal to 1.05.
- the value of ss_extent is set equal to a maximum secondary extent size 310 .
- a linear function 312 is used to initially determine the size of the new secondary extent then, at a function change threshold 314 , the exponential function 302 is used to determine the size of the new secondary extent before reaching the maximum secondary extent size 310 at the first secondary extent clipping threshold 308 . In another alternate embodiment, the exponential function 302 is initially used to determine the size of the new secondary extent.
- the linear function (darkened line) 312 is used to determine the size of the secondary extent before reaching the maximum secondary extent size 310 at a second secondary extent clipping threshold 316 .
- a and b are real numbers. The value of ss_area is then rounded to the nearest whole cylinder value.
- M is a scaling factor to scale the function to the maximum additional area size.
- a is a factor to expand or contract the inverse tangent function along the x-axis.
- the value of x_offset is used to place the inverse tangent function at a desired point on the x-axis when the value of the extent number is equal to one.
- the value of y_offset is used to raise the inverse tangent function so that, at its limit, the value of the inverse tangent function approaches three.
- M is chosen such that the maximum secondary area size is reached as the additional area number becomes very large.
- At least one or any combination of the linear, polynomial, exponential or trigonometric functions described above are used, at least in part, to determine the size of a new additional area.
- the additional area sizes increase in steps for groups of additional areas. For example, the first five additional areas may have a size of one, and the next seven additional areas may have a size of three.
- the look-up table may be used to implement any of the above-described functions, and embodiments for determining the size of the additional area.
Abstract
Description
- the
operating system 60; - the
database management system 62; - a
database engine 64 to read data from, add data to, update data within, and delete data from a database table that is stored in a dataset; - one or
more datasets 66 to store respective database information; - a primary extent size (PQTY) 68 that may contain a value equal to the value of a system default size (PQTY_def) 70 or a user-specified size (PQTY_user) 72 to define the size of the primary extent for a dataset;
- a secondary extent size (SQTY) 74 that contains a value representing the size of a new secondary extent;
- a user-specified secondary extent size (SQTY_user) 78;
- an
adaptive allocation module 80 that determines the size of a new additional area, for example, a secondary extent, and allocates space for a dataset using a determined additional area size, for example, a secondary extent size, in accordance with an embodiment of the present inventive technique; and - an extent allocation look-up table 82 that stores a set of predefined secondary extent sizes based on the maximum size of a dataset and the secondary extent number and, in one embodiment, is used by the adaptive allocation module to determine the size of a new secondary extent.
- (1) To determine the size of the primary extent, if a user specifies a primary extent size (PQTY_user), the adaptive allocation module uses the user-specified primary extent size, that is, PQTY=PQTY_user; otherwise, the adaptive allocation module uses the default primary extent size, that is, PQTY=PQTY_def.
- (2) If the user does not specify a value for the secondary extent size, then the size of the new secondary extent can be no smaller than ten percent of the size of the primary extent for that dataset. In other words,
- SQTY=max(0.1*PQTY, min(ss_extent, MaxAlloc))
- For example, in one embodiment, the value of MaxAlloc is equal to 127 cylinders for a dataset having a maximum dataset size less than thirty-two Gigabytes, and the value of MaxAlloc is equal to 559 cylinders for a dataset having a maximum dataset size greater than or equal to thirty-two Gigabytes.
- Alternately, the size of the new secondary extent, SQTY, is determined as follows:
- SQTY=max(0.1*PQTY, min(ss_extent, 559 or 127 cylinders if the maximum dataset is size is greater than or equal to thirty-two Gigabytes, or less than thirty-two Gigabytes, respectively)).
- (3) If a user specified that no secondary extents are to be allocated, that is, the specified value of SQTY_user is equal to zero, then SQTY is also equal to zero, and no secondary extents are allocated.
- (4) If the user specified a value for the size of a secondary extent (SQTY_user) and if the specified value of SQTY_user>0, then the size of the new secondary extent is no smaller than that specified size in SQTY_user. In other words,
- SQTY=max(min(ss_extent, MaxAlloc), SQTY_user).
For example, in one embodiment, described above, the value of MaxAlloc is equal to 127 cylinders for a dataset having a maximum dataset size less than thirty-two Gigabytes, and the value of MaxAlloc is equal to 559 cylinders for a dataset having a maximum dataset size greater than or equal to thirty-two Gigabytes.
- SQTY=max(min(ss_extent, MaxAlloc), SQTY_user).
- Alternately, the size of the new secondary extent, SQTY, is determined as follows:
- SQTY=max(min(ss_extent, 559 or 127 cylinders if the maximum dataset is size is greater than or equal to thirty-two Gigabytes, or less than thirty-two Gigabytes, respectively), SQTY_user).
In an alternate embodiment, one or any combination of the rules may be applied in the adaptive allocation module.
- SQTY=max(min(ss_extent, 559 or 127 cylinders if the maximum dataset is size is greater than or equal to thirty-two Gigabytes, or less than thirty-two Gigabytes, respectively), SQTY_user).
TABLE 1 | ||
Maximum number of secondary | Maximum | |
Maximum Dataset | extents to store a dataset at the | Secondary |
Size | maximum dataset size | Extent Size |
(Gigabytes) | (assumes 1 cylinder to start) | (Cylinders) |
1 | 54 | 127 |
2 | 75 | 127 |
4 | 107 | 127 |
8 | 154 | 127 |
16 | 246 | 127 |
32 | 172 | 559 |
64 | 255 | 559 |
-
- SQTY=Max(min(ss_extent, MaxAlloc), SQTY_user).
In this way, the size of the new secondary extent in SQTY is not less than the value of a user-specified secondary extent size in SQTY_user.
- SQTY=Max(min(ss_extent, MaxAlloc), SQTY_user).
-
- SQTY=Max(0.1*PQTY_cyls, min(ss_extent, MaxAlloc)).
In this way, if a user did not specify the size of a secondary extent, the size of the new secondary extent is equal to at least ten percent of the size of the primary extent. Step 128 then proceeds to step 124 to allocate the new secondary extent based on the value of SQTY.
- SQTY=Max(0.1*PQTY_cyls, min(ss_extent, MaxAlloc)).
ss_extent=15+2*(Extent no.−15).
The adaptive allocation
ss_extent=111+4*(Extent no.−63).
The adaptive allocation
ss_extent=239+10*(Extent no.−95).
The adaptive allocation
/* Calculate the size of the secondary extent, in cylinders, using a sliding scale */ |
If maximum_dataset_size >= 32 Gigabytes Then Do |
/* Large dataset sliding scale */ |
MaxAlloc=559 |
Select |
When extent_no < 16 Then ss_extent = extent_no |
When extent_no < 64 Then ss_extent = 15 + 2 * (extent_no − 15) |
When extent_no < 96 Then ss_extent = 111 +4 * (extent_no − 63) |
When extent_no < 128 Then ss_extent = 239 + 10 * (extent_no − 95) |
Otherwise ss_extent = 559 |
End |
End |
Else Do |
/* Small dataset sliding scale */ |
MaxAlloc=127 |
If extent_no < 128 Then ss_extent = extent_no |
Else ss_extent = 127 |
End |
/* calculate 10% of the size of the primary extent (PQTY) but limit by the maximum |
size of the dataset of the sliding scales */ |
If no user-specified secondary extent size (SQTY_user), Then |
SQTY = Max(0.1*PQTY, Min(ss_extent, MaxAlloc)) |
End |
If there is a user-specified secondary extent size (SQTY_user) > 0, Then |
/* Use the greater of the sliding scale and the catalog secondary quantity */ |
/* allows a user to override with a larger SQTY_user to reach 64GB faster */ |
SQTY = Max(Min(ss_extent, MaxAlloc), SQTY_user) |
Allocate a new secondary extent having a size of SQTY |
The secondary extent clipping threshold, the sliding scale, the maximum number of secondary extents and the maximum size of the secondary extents are chosen in accordance with the above relationship. Ideally, in one embodiment, the maximum size of the dataset is equal to the sum of the primary extent size and all secondary extent sizes. Alternately, the maximum size of the dataset is less than, but close to, the sum of the primary and secondary extent sizes. In yet another embodiment, the secondary extent size, ss_extent, monotonically increases.
ss_area=f 0(Area No.).
ss_area=m*Area No.+b
ss_area=a n*(Area No.)n +a (n−1)*(Area No.)(n−1) + . . . +a 1*(Area No.)+a 0,
where an, a(n−1), . . . , a1 and a0 are real numbers. The value of ss_area is rounded to the nearest whole cylinder. In another embodiment, the polynomial is monotonically increasing.
Step 226 proceeds to step 230 and exits.
ss_area=f 1(Area no.).
The function f1 can take any of the forms described above for f0. In another embodiment, the first, second, . . . , nth thresholds have the following relationship:
First threshold<second threshold< . . . <nth threshold
ss_extent=a*b (extent no.).
In the exponential function above, a and b are real numbers. The value of ss_extent is then rounded to the nearest whole cylinder value. In one embodiment, the value of b is equal to 1.05. At a first secondary
ss_area=a*b (Area no.).
In the function above, a and b are real numbers. The value of ss_area is then rounded to the nearest whole cylinder value.
ss_area=M(tan−1(a(Area no.)−x_offset)+y_offset).
The variable “M” is a scaling factor to scale the function to the maximum additional area size. The variable “a” is a factor to expand or contract the inverse tangent function along the x-axis. The value of x_offset is used to place the inverse tangent function at a desired point on the x-axis when the value of the extent number is equal to one. The value of y_offset is used to raise the inverse tangent function so that, at its limit, the value of the inverse tangent function approaches three. The value of M is chosen such that the maximum secondary area size is reached as the additional area number becomes very large.
Claims (26)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/703,998 US7225209B2 (en) | 2003-11-06 | 2003-11-06 | Computer-implemented method for allocating new additional area for the dataset in storage based on the size of the new additional area wherein if the new area number does not exceed clipping threshold, the size of a new additional area being greater than the size of each previously allocated additional area of the dataset |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/703,998 US7225209B2 (en) | 2003-11-06 | 2003-11-06 | Computer-implemented method for allocating new additional area for the dataset in storage based on the size of the new additional area wherein if the new area number does not exceed clipping threshold, the size of a new additional area being greater than the size of each previously allocated additional area of the dataset |
Publications (2)
Publication Number | Publication Date |
---|---|
US20050102331A1 US20050102331A1 (en) | 2005-05-12 |
US7225209B2 true US7225209B2 (en) | 2007-05-29 |
Family
ID=34552020
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/703,998 Expired - Fee Related US7225209B2 (en) | 2003-11-06 | 2003-11-06 | Computer-implemented method for allocating new additional area for the dataset in storage based on the size of the new additional area wherein if the new area number does not exceed clipping threshold, the size of a new additional area being greater than the size of each previously allocated additional area of the dataset |
Country Status (1)
Country | Link |
---|---|
US (1) | US7225209B2 (en) |
Cited By (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20060212495A1 (en) * | 2005-03-18 | 2006-09-21 | Mikihiko Tokunaga | Method and system for storing data into a database |
US20110191565A1 (en) * | 2010-02-02 | 2011-08-04 | International Business Machines Corporation | Extent size optimization |
Families Citing this family (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7765400B2 (en) * | 2004-11-08 | 2010-07-27 | Microsoft Corporation | Aggregation of the knowledge base of antivirus software |
US9547672B2 (en) | 2012-09-24 | 2017-01-17 | Bmc Software, Inc. | Zero-outage database reorganization |
Citations (24)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4310883A (en) * | 1978-02-13 | 1982-01-12 | International Business Machines Corporation | Method and apparatus for assigning data sets to virtual volumes in a mass store |
US5247660A (en) | 1989-07-13 | 1993-09-21 | Filetek, Inc. | Method of virtual memory storage allocation with dynamic adjustment |
US5414826A (en) | 1990-01-31 | 1995-05-09 | Hewlett-Packard Company | System and method for memory management in microcomputer |
EP0703526A2 (en) * | 1994-09-22 | 1996-03-27 | Hewlett-Packard Company | Storage management system for concurrent generation and fair allocation of disk space |
EP0814405A2 (en) * | 1996-06-20 | 1997-12-29 | Sun Microsystems, Inc. | Method and apparatur for information processing and memory allocation system |
US5732402A (en) * | 1995-02-10 | 1998-03-24 | International Business Machines Corporation | System and method for data space management using buddy system space allocation |
US5778393A (en) * | 1996-05-20 | 1998-07-07 | International Business Machines Corporation | Adaptive multitasking for dataset storage |
US6085254A (en) | 1998-04-10 | 2000-07-04 | Telefonaktiebolaget Lm Ericsson (Publ) | Dynamic size alteration of memory files |
US6173291B1 (en) | 1997-09-26 | 2001-01-09 | Powerquest Corporation | Method and apparatus for recovering data from damaged or corrupted file storage media |
US6295539B1 (en) * | 1998-09-14 | 2001-09-25 | Computer Associates Think, Inc. | Dynamic determination of optimal process for enforcing constraints |
US6401089B2 (en) * | 1998-10-27 | 2002-06-04 | Computer Associates Think, Inc. | Method for maintaining exception tables for a check utility |
US6412053B2 (en) | 1998-08-26 | 2002-06-25 | Compaq Computer Corporation | System method and apparatus for providing linearly scalable dynamic memory management in a multiprocessing system |
US6453383B1 (en) | 1999-03-15 | 2002-09-17 | Powerquest Corporation | Manipulation of computer volume segments |
US6453404B1 (en) * | 1999-05-27 | 2002-09-17 | Microsoft Corporation | Distributed data cache with memory allocation model |
US6470360B1 (en) | 1999-12-20 | 2002-10-22 | Sybase, Inc. | Database system with improved methodology for page allocation |
US20030046294A1 (en) * | 2001-08-31 | 2003-03-06 | Bmc Software, Inc. | Symmetrical database data set allocation |
US20030120644A1 (en) * | 2001-12-17 | 2003-06-26 | International Business Machines Corporation | Method, apparatus, and computer program product for locating data in large datasets |
US6598224B1 (en) * | 1999-04-30 | 2003-07-22 | Kabushiki Kaisha Toshiba | Data management unit, computer system and computer-readable storage medium |
US6834290B1 (en) * | 1999-11-15 | 2004-12-21 | Quest Software, Inc. | System and method for developing a cost-effective reorganization plan for data reorganization |
WO2005043414A2 (en) * | 2003-10-29 | 2005-05-12 | Oracle International Corporation | Tracking space usage in a database |
WO2005050492A1 (en) * | 2003-11-17 | 2005-06-02 | Applera Corporation | Management of storage space for an embedded database in a software system |
US6965899B1 (en) * | 2001-09-28 | 2005-11-15 | Oracle International Corporation | Online reorganization and redefinition of relational database tables |
US7028041B2 (en) * | 2001-11-29 | 2006-04-11 | Wal-Mart Stores, Inc. | Methods and apparatus for database space calculation and error detection |
US7031987B2 (en) * | 1997-05-30 | 2006-04-18 | Oracle International Corporation | Integrating tablespaces with different block sizes |
-
2003
- 2003-11-06 US US10/703,998 patent/US7225209B2/en not_active Expired - Fee Related
Patent Citations (25)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4310883A (en) * | 1978-02-13 | 1982-01-12 | International Business Machines Corporation | Method and apparatus for assigning data sets to virtual volumes in a mass store |
US5247660A (en) | 1989-07-13 | 1993-09-21 | Filetek, Inc. | Method of virtual memory storage allocation with dynamic adjustment |
US5414826A (en) | 1990-01-31 | 1995-05-09 | Hewlett-Packard Company | System and method for memory management in microcomputer |
EP0703526A2 (en) * | 1994-09-22 | 1996-03-27 | Hewlett-Packard Company | Storage management system for concurrent generation and fair allocation of disk space |
US5732402A (en) * | 1995-02-10 | 1998-03-24 | International Business Machines Corporation | System and method for data space management using buddy system space allocation |
US6032160A (en) * | 1995-02-10 | 2000-02-29 | International Business Machines Corporation | Buddy system space allocation management |
US5778393A (en) * | 1996-05-20 | 1998-07-07 | International Business Machines Corporation | Adaptive multitasking for dataset storage |
EP0814405A2 (en) * | 1996-06-20 | 1997-12-29 | Sun Microsystems, Inc. | Method and apparatur for information processing and memory allocation system |
US7031987B2 (en) * | 1997-05-30 | 2006-04-18 | Oracle International Corporation | Integrating tablespaces with different block sizes |
US6173291B1 (en) | 1997-09-26 | 2001-01-09 | Powerquest Corporation | Method and apparatus for recovering data from damaged or corrupted file storage media |
US6085254A (en) | 1998-04-10 | 2000-07-04 | Telefonaktiebolaget Lm Ericsson (Publ) | Dynamic size alteration of memory files |
US6412053B2 (en) | 1998-08-26 | 2002-06-25 | Compaq Computer Corporation | System method and apparatus for providing linearly scalable dynamic memory management in a multiprocessing system |
US6295539B1 (en) * | 1998-09-14 | 2001-09-25 | Computer Associates Think, Inc. | Dynamic determination of optimal process for enforcing constraints |
US6401089B2 (en) * | 1998-10-27 | 2002-06-04 | Computer Associates Think, Inc. | Method for maintaining exception tables for a check utility |
US6453383B1 (en) | 1999-03-15 | 2002-09-17 | Powerquest Corporation | Manipulation of computer volume segments |
US6598224B1 (en) * | 1999-04-30 | 2003-07-22 | Kabushiki Kaisha Toshiba | Data management unit, computer system and computer-readable storage medium |
US6453404B1 (en) * | 1999-05-27 | 2002-09-17 | Microsoft Corporation | Distributed data cache with memory allocation model |
US6834290B1 (en) * | 1999-11-15 | 2004-12-21 | Quest Software, Inc. | System and method for developing a cost-effective reorganization plan for data reorganization |
US6470360B1 (en) | 1999-12-20 | 2002-10-22 | Sybase, Inc. | Database system with improved methodology for page allocation |
US20030046294A1 (en) * | 2001-08-31 | 2003-03-06 | Bmc Software, Inc. | Symmetrical database data set allocation |
US6965899B1 (en) * | 2001-09-28 | 2005-11-15 | Oracle International Corporation | Online reorganization and redefinition of relational database tables |
US7028041B2 (en) * | 2001-11-29 | 2006-04-11 | Wal-Mart Stores, Inc. | Methods and apparatus for database space calculation and error detection |
US20030120644A1 (en) * | 2001-12-17 | 2003-06-26 | International Business Machines Corporation | Method, apparatus, and computer program product for locating data in large datasets |
WO2005043414A2 (en) * | 2003-10-29 | 2005-05-12 | Oracle International Corporation | Tracking space usage in a database |
WO2005050492A1 (en) * | 2003-11-17 | 2005-06-02 | Applera Corporation | Management of storage space for an embedded database in a software system |
Non-Patent Citations (8)
Title |
---|
"Oracle 8i and Oracle 9i Data reorganization and Feature comparisons", Oracle white paper, Mar. 2002, 12 pages. * |
Dong Xie, "Fuzzy association rules discovered on effective reduced database algorithm", IEEE international conference on Fuzzy systems, 2005pp. 779-784. * |
Douglas Thain, "Operating system support for space allocation in grid storage systems", no date. * |
Eric W. Weisstein, "Inverse Tangent -from MathWorld", Eric Weisstein's world of Mathematics, copyright 1999 CRC Press LLC, copyright 1999-2003, Wolfran Research, Inc., http://mathworld.wolfram.com/InverseTangent.html. |
George Baklarz and Bill Wong, "DB2 Universal Database v7.1 for UNIX, Linux, Windows, and OS/2 Database Administration Certification Guide," Fourth Edition, 2001, pp. 419-420, Prentice Hall, Upper Saddle River, NJ, USA. |
IBM, "DFSMS Version 1 Release 5, DFSMS/MVS VIRS DFSMSdfp Storage Administration Reference," SC26-4920-05, Sixth Edition, Mar. 1999, p. 96, International Business Machines Corporation, http://publibz.boulder.ibm.com/epubs/pdf/dgtls205.pdf. |
Lionel Dyck, "reading and writing data using REXX EXECIO on OS/390 and z/OS", Technical support, Apr. 2003, 3 pages. * |
Tevfik Kosar et al. "data pipelines: enabling large scale mutli-protocol data transfers", MGC '04, ACM, 2004. * |
Cited By (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20060212495A1 (en) * | 2005-03-18 | 2006-09-21 | Mikihiko Tokunaga | Method and system for storing data into a database |
US20110191565A1 (en) * | 2010-02-02 | 2011-08-04 | International Business Machines Corporation | Extent size optimization |
US8775766B2 (en) | 2010-02-02 | 2014-07-08 | International Business Machines Corporation | Extent size optimization |
Also Published As
Publication number | Publication date |
---|---|
US20050102331A1 (en) | 2005-05-12 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6694325B2 (en) | Database method implementing attribute refinement model | |
US6993530B2 (en) | Method and apparatus for obtaining an identifier for a logical unit of data in a database | |
US8516218B2 (en) | Pattern-based mapping for storage space management | |
KR100390616B1 (en) | System and method for persistent and robust storage allocation | |
US6385626B1 (en) | Method and apparatus for identifying changes to a logical object based on changes to the logical object at physical level | |
US5822780A (en) | Method and apparatus for hierarchical storage management for data base management systems | |
US7225211B1 (en) | Multi-class storage mechanism | |
US8700674B2 (en) | Database storage architecture | |
US8825591B1 (en) | Dynamic storage mechanism | |
US9239843B2 (en) | Scalable de-duplication for storage systems | |
US6754657B2 (en) | Time stamping of database records | |
US8315995B1 (en) | Hybrid storage system | |
US8127095B1 (en) | Restore mechanism for a multi-class file system | |
US7676451B2 (en) | Selective database statistics recollection | |
US7769725B2 (en) | File profiling to minimize fragmentation | |
US7912869B1 (en) | Database component packet manager | |
US9542401B1 (en) | Using extents of indirect blocks for file mapping of large files | |
US11886401B2 (en) | Database key compression | |
US7386841B2 (en) | Technique for determining a target data type in a heterogeneous multi-level environment | |
US20030046294A1 (en) | Symmetrical database data set allocation | |
US7225209B2 (en) | Computer-implemented method for allocating new additional area for the dataset in storage based on the size of the new additional area wherein if the new area number does not exceed clipping threshold, the size of a new additional area being greater than the size of each previously allocated additional area of the dataset | |
US10078647B2 (en) | Allocating free space in a database | |
US11789951B2 (en) | Storage of data structures | |
EP1126373A2 (en) | Storage allocation system and method | |
Tikekar et al. | A generalized storage model for tertiary storage based systems |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEWFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:BRACEY, MICHAEL JOHN;CAMPBELL, JOHN JOSEPH;CHEN, JULIE;AND OTHERS;REEL/FRAME:014687/0956;SIGNING DATES FROM 20031006 TO 20031014 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
REMI | Maintenance fee reminder mailed | ||
FPAY | Fee payment |
Year of fee payment: 4 |
|
SULP | Surcharge for late payment | ||
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026664/0866Effective date: 20110503 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |
|
FEPP | Fee payment procedure |
Free format text: MAINTENANCE FEE REMINDER MAILED (ORIGINAL EVENT CODE: REM.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
LAPS | Lapse for failure to pay maintenance fees |
Free format text: PATENT EXPIRED FOR FAILURE TO PAY MAINTENANCE FEES (ORIGINAL EVENT CODE: EXP.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20190529 |