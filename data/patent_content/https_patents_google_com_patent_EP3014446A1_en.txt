EP3014446A1 - Asynchronous message passing for large graph clustering - Google Patents
Asynchronous message passing for large graph clusteringInfo
- Publication number
- EP3014446A1 EP3014446A1 EP14744684.3A EP14744684A EP3014446A1 EP 3014446 A1 EP3014446 A1 EP 3014446A1 EP 14744684 A EP14744684 A EP 14744684A EP 3014446 A1 EP3014446 A1 EP 3014446A1
- Authority
- EP
- European Patent Office
- Prior art keywords
- node
- messages
- cluster identifier
- nodes
- message
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/901—Indexing; Data structures therefor; Storage structures
- G06F16/9024—Graphs; Linked lists
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/54—Interprogram communication
- G06F9/546—Message passing systems or structures, e.g. queues
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06Q—INFORMATION AND COMMUNICATION TECHNOLOGY [ICT] SPECIALLY ADAPTED FOR ADMINISTRATIVE, COMMERCIAL, FINANCIAL, MANAGERIAL OR SUPERVISORY PURPOSES; SYSTEMS OR METHODS SPECIALLY ADAPTED FOR ADMINISTRATIVE, COMMERCIAL, FINANCIAL, MANAGERIAL OR SUPERVISORY PURPOSES, NOT OTHERWISE PROVIDED FOR
- G06Q10/00—Administration; Management
- G06Q10/06—Resources, workflows, human or project management; Enterprise or organisation planning; Enterprise or organisation modelling
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2209/00—Indexing scheme relating to G06F9/00
- G06F2209/54—Indexing scheme relating to G06F9/54
- G06F2209/548—Queue
Definitions
- Graphs are a basic modeling tool to model social, communication, and information networks.
- a graph G(V, E) consists of a set of nodes V , and a set of edges E £ V 2 where each edge connects two nodes in the graph.
- analysis is performed on large graphs that do not fit on one machine. Consequently, the graph is stored in several machines and mined in a distributed manner, for example by applying distributed programming tools like Map-Reduce or Hadoop.
- a basic analysis tool for graphs is to compute connected components of the graph.
- a connected component of a graph G(V,E) is a maximal set of nodes that can be reached from each other via sequences of edges of the graph.
- FIG. 2 illustrates a graph G with three connected components.
- Connected component 205 includes nodes A, B, C, and D
- connected component 210 includes nodes F, G, I, and H
- connected component 215 includes nodes J, K, L, and M.
- the connected components may also be referred to as a cluster of nodes.
- Computing connected components in graphs is a basic tool for computing coherent clusters of nodes and also to perform hierarchical clustering.
- computing clusters of nodes distributed across multiple machines can be time and cost prohibitive as the running time of the hashing functions are dependent on the size of the graph, the number of messages sent between machines during the rounds of Map-Reduce, and the number of rounds of Map-Reduce performed. It is a challenge is to compute connected components for a large graph in a small number of rounds of Map-Reduce.
- Implementations provide an asynchronous message passing framework for computing connected components in a large distributed graph.
- the asynchronous message passing frameworks utilizes a priority queue to pass messages between nodes. Each node is able to perform its share of the computations and send messages regardless of the state of its peers, unlike synchronous message passing frameworks such as Map-Reduce and Hadoop.
- Using the priority queue allows the system to send blocks of requests between distributed computing devices for more efficient processing.
- the framework also uses a smaller memory footprint because each node tracks only a minimum identifier for a potential connected component, rather than a set of possible identifiers. This also makes message sizes smaller. Because messaging is asynchronous, each node may independently checkpoint its state and can restart after failure at the last checkpointed state.
- Recovering from failure is also more efficient because the number of messages that need to be replayed to recover a single machine is significantly less than synchronous message passing frameworks.
- a leaf server can include memory storing a cluster identifier for each node assigned to the leaf server, at least one processor, and memory storing instructions that, when executed by the at least one processor, cause the leaf server to send asynchronous messages between neighboring nodes, the messages comprising an asynchronous message from a first node to a second node including the cluster identifier for the first node, wherein sending the asynchronous message is triggered by an update to the cluster identifier.
- the graph may include more than one billion nodes.
- the memory may further store instructions that, when executed by the at least one processor, cause the leaf server to propagate the message to the second node and compare the cluster identifier from the message with the cluster identifier for the second node to determine whether to update the cluster identifier for the second node.
- the instructions may cause the leaf server to update the cluster identifier for the second node with the cluster identifier from the message and generate messages to neighboring nodes of the second node, the messages including the updated cluster identifier.
- the leaf server may set a status of the second node to active as part of the updating and set the status of the second node to inactive in response to propagation of the messages to neighboring nodes.
- the instructions may further cause the leaf server to store the updated cluster identifier in persistent memory.
- the leaf server may also include a priority queue engine that propagates messages between neighboring nodes.
- a priority queue engine that propagates messages between neighboring nodes.
- the priority queue engine may be capable of bundling together messages directed to nodes on another leaf server before propagation of the messages and/or of intelligently skipping redundant messages rather than propagating the messages.
- the cluster identifier may represent the smallest identifier seen by the first node and the cluster identifier for the second node is to be updated when the cluster identifier from the message is smaller than the cluster identifier for the second node.
- at least one leaf server includes a plurality of processors and the at least one leaf server uses the plurality of processors to concurrently send multiple messages departing from nodes and to receive multiple messages arriving at nodes.
- Another aspect of the disclosure can be embodied in a method that includes propagating, using at least one processor, messages sent between nodes in a distributed graph in an asynchronous manner, the messages including respective cluster identifiers.
- the method may also include comparing a cluster identifier from the received message with a cluster identifier for the first node to determine whether to update the cluster identifier for the first node and, when it is determined that the cluster identifier of the first node is to be updated, updating the cluster identifier for the first node with the cluster identifier from the message and generating messages to neighboring nodes of the first node, the messages including the updated cluster identifier.
- a priority queue engine may control the propagating.
- the priority queue engine may propagate the messages in an arbitrary manner rather than a first-in-first- out or last-in-last-out manner.
- nodes in the distributed graph are assigned to one of a plurality of leaf servers with each leaf server having a respective priority queue engine, the priority queue engine being one of the respective priority queue engines, and wherein the priority queue engine bundles messages directed to nodes assigned to a remote leaf server of the plurality of leaf servers prior to propagating the messages. Propagating the messages at a particular leaf server can continue despite a failure of another leaf server.
- the method may further include storing the updated cluster identifier in persistent memory and, in response to the first node determining that it experienced a failure, obtaining the cluster identifier from the persistent memory and generating messages to the neighboring nodes of the first node, the messages requesting a cluster identifier from the respective neighboring nodes.
- the cluster identifier for the first node represents the smallest identifier seen by the first node and the cluster identifier for the first node is to be updated when the cluster identifier from the message is smaller than the cluster identifier for the first node.
- the method may also include setting a status of the first node to active as part of the updating, and setting the status of the first node to inactive in response to propagating the messages to the neighboring nodes.
- the propagating is performed without regard to respective states of the nodes in the distributed graph.
- a method in another aspect, includes receiving, using at least one processor, at a node in a distributed graph, a message with a first value and determining, at the node, that the first value replaces a current value for the node. Responsive to the determining, the method also includes setting a status of the node to active and sending messages that include the first value to neighboring nodes. The method may also include receiving, using the at least one processor, the messages to the neighboring nodes at a priority queue, wherein the priority queue propagates messages in an intelligently asynchronous manner, and wherein when the message is propagated to the neighboring nodes, the status of the node is set to inactive.
- the method may include one or more of the following features, for example, the node may be a first node and the method may further include receiving, at the first node, a request from a second node for messages sent after a first time and determining, at the first node, whether the messages to neighboring nodes were sent after the first time.
- the method includes re-sending the message to the second node and when the messages were not sent after the first time, the method includes ignoring the request.
- the second node sends the request after recovering a current value for the second node from a checkpoint.
- the first value and the current value may be cluster identifiers or the first value and the current value may be shortest path identifiers.
- Another aspect of the disclosure can be embodied on a computer- readable medium having recorded and embodied thereon instructions that, when executed by a processor of a computer system, cause the computer system to perform any of the methods disclosed herein.
- the system may reduce the time and cost of performing operations on a large distributed graph, such as determining connected components in a graph, computing the shortest path between two nodes, search, etc. Implementations not only reduce the number of messages sent, but also reduce the size of the messages. Also, because message passing is asynchronous, the processing time is reduced as nodes need not wait for other nodes to finish processing. The asynchronous nature also permits efficient recovery when a node or leaf stops responding temporarily, making the system robust under frequent failures.
- FIG. 1 illustrates an example system in accordance with the disclosed subject matter.
- FIG. 2 illustrates an example graph distributed across three leaves and including three clusters.
- FIG. 3 illustrates a flow diagram of an example process for computing connected components of a large distributed graph.
- FIG. 4 illustrates an example of asynchronous message passing, in accordance with an implementation.
- FIG. 5 shows an example of a computer device that can be used to implement the described techniques.
- FIG. 6 shows an example of a distributed computer device that can be used to implement the described techniques.
- FIG. 1 is a block diagram of a distributed graph system 100 in accordance with an example implementation.
- the system 100 may be used to calculate connected components of a large distributed graph using the techniques described herein.
- the graph system 100 may include root 120 and graph cluster 160.
- Root 120 and graph cluster 160 may be computing devices that take the form of a number of different devices, for example a standard server, a group of such servers, or a rack server system.
- the root 120 and the graph cluster 160 may be distributed systems implemented in a series of computing devices, such as a group of servers.
- the servers may be organized into a tree structure, with at least a root server 120 and leaf servers 150A to 150w.
- the tree may include intermediate servers, so that there are one or more layers between the root 120 and the leaf servers 150A to 150K.
- the root 120 and graph cluster 160 may be examples of computer device 600, as depicted in FIG. 6.
- the graph system 100 illustrated in FIG. 1 operates over a large graph with, for example, billions of nodes.
- the root 120 may include one or more servers that operate with the graph cluster 160 to perform operations on the data graph represented by nodes and edges 154.
- the nodes and edges 154 may be stored in one or more data structures that represent each node of the graph and an adjacency list for each node.
- the data structure may also represent other information, for example the attributes of the edges that link a node to its neighbors in the adjacency list.
- the root 120 may include one or more servers that receive commands or requests from a requester, such as client 170. The root 120 may initiate and monitor calculations performed on the graph and may manage the results of the calculations.
- the root 120 may facilitate searches and queries on the graph.
- the root 120 may also store instructions in memory 144 that, when executed by the hardware processor 142, cause the system 100 to perform operations.
- the root 120 and/or graph cluster 160 may include logic to process messages sent from one node to its neighbors.
- System 100 may also include a graph cluster 160.
- Graph cluster 160 may be a collection of distributed computing devices each with its own hardware processor and memory. The number of computing devices that comprise graph cluster 160 can vary.
- the graph cluster 160 may be divided into one or more leaf servers, such as leaf 150A, leaf 150B, leaf 150n, with n representing any positive integer.
- a leaf server may be a logical division of nodes in the graph, with each graph node being assigned to a leaf server.
- a leaf server may correspond to one computing device, or a leaf server may be a logical computing device and may share a physical computing device with other leaves.
- a node's assigned leaf may change as the graph is updated, making leaf assignments flexible.
- the root 120 may determine which nodes are assigned to each leaf as the nodes are added to the graph or updated.
- the root 120 may route processing requests to the leaf servers and act as the primary means of coordination between the leaves at processing time.
- leaves may send messages directly to each other rather than going through the root 120.
- the messages may be messages from a node in the graph to its neighbors.
- the graph cluster 160 may include one or more layers of intermediate servers between the root node 120 and the leaf servers 150, but are not shown in FIG. 1 for the sake of brevity.
- an intermediate server may be associated with, for example, 20 leaf servers.
- the intermediate server may be connected directly to the root 120, or there may be one or more additional layers between the intermediate server and the root 120.
- FIG. 1 shows communications directly between the root 120 and leaf servers 150, it is to be understood that intermediate devices may be used to direct communications and aggregate results using known methods, such as remote procedure calls.
- the root, intermediate, and leaf servers that make up the tree may, collectively, be referred to as the graph.
- Each of the leaf servers 150 that make up graph cluster 160 can include node states 152 and nodes and edges 154.
- a state for a node may be used in calculating connected components for the graph and may include a status and a cluster identifier.
- the cluster identifier identifies the cluster, or potential connected component, that a node belongs to.
- the cluster identifier in the state of a node V may change, but it generally represents the smallest identifier that the node V has seen. This is similar to a Hash-Only-Min hashing algorithm.
- the identifier may represent an identifier for the node with the greatest identifier received.
- the state for a node will contain the identifier of the connected component to which the node belongs.
- the state of a node may not be altered by messages sent between nodes, only by the node itself or the priority queue engine 156.
- each node state may include a status. The status may indicate whether the node is active or inactive. An active status indicates that the identifier in the state has changed and the node needs to send a message with the new identifier to its neighbors. After the message has been propagated the state status may be changed to inactive.
- the system has computed the connected components for the graph. At this point the state identifier for each node contains the identifier of the connected component to which the node belongs.
- Each leaf server 150 may also include a priority queue engine 156.
- Messages sent between nodes may be handled by the priority queue engine 156.
- the priority queue engine 156 may track which messages have been sent and which still need to be sent, but does not need to send messages in the order at which they arrive. In some implementations, the priority queue engine 156 may arbitrarily choose which message to propagate next. In some implementations, the priority queue engine 156 may bundle messages destined for other leaf servers together, and send the bundled messages together. This makes messaging more efficient. Furthermore, if a leaf is not responding, the priority queue engine 156 can keep track of messages not successfully acknowledged so that these messages can be resent when the leaf begins responding again. In some implementations, when the priority queue engine 156 propagates the messages from a node it may set the status of the node to inactive.
- Graph system 100 may be in communication with clients 170 over network 180.
- the network 180 may be for example, the Internet or the network 180 can be a wired or wireless local area network (LAN), wide area network (WAN), etc., implemented using, for example, gateway devices, bridges, switches, and/or so forth.
- LAN local area network
- WAN wide area network
- the system 100 may communicate with and transmit data to/from clients 170 or other computing devices.
- FIG. 3 illustrates a flow diagram of an example process 300 for computing connected components of a large distributed graph.
- the process 300 shown in FIG. 3 may be performed by a graph system distributed across multiple computing devices, such as graph system 100 of FIG. 1.
- the process 300 may speed the calculation of connected components in a distributed graph by using an asynchronous message passing protocol to calculate the cluster each node belongs to.
- a root such as root 120, may initiate process 300 to determine which cluster each node in the graph belongs to.
- Process 300 is described for one node, but it is understood that the process 300 occurs for all nodes simultaneously.
- FIG. 3 illustrates a cluster identifier being passed in the message, the message may pass other values, such as a shortest path identifier.
- the process may begin with the system initializing the state of the node (305).
- the initial state for a node will be an active status and an identifier set equal to the identifier of the node. Because each node is active, it will send a message to each neighbor, the message including its state identifier (310). This message may be sent to the priority queue and distributed by the priority queue engine. Any known or later developed method of sending messages between nodes may be used.
- the status of the node may change from active to inactive (315). In some implementations this can be done by the priority queue engine.
- the node may then enter a waiting stage, represented by the dashed line in FIG. 3.
- the node is waiting for a message with a cluster identifier. If no message ever arrives, the node will remain in the waiting stage.
- receives such a message (320) it may compare the value, e.g., the cluster identifier, from the message with the value, e.g., the cluster identifier, in its state (325). If the message cluster identifier is greater than or equal to the identifier in the state (325, No), the node does nothing and continues waiting for another message. While waiting the node has an inactive status.
- the node may change its status to active and change the cluster identifier in its state to the message cluster identifier (330). Because the node's status is active, it sends a message to its neighbors, via the priority queue (335). The message contains the updated cluster identifier received in the message. When the message is propagated by the priority queue engine, the status may change back to inactive (340). The node then returns to a waiting stage, waiting for another message. The system may also checkpoint the states of the nodes at various points while nodes are performing process 300.
- Checkpointing the state may cause the system to store the states for the nodes in persistent memory so that if the leaf fails or needs to restart for any reason, the node can determine the most recent state, and begin from that point.
- Different implementations may use different criteria to decide when to write checkpoints, as this can be a relatively expensive procedure.
- each leaf server may checkpoint the states of the nodes assigned to the leaf after a predetermined number of messages have been sent or propagated.
- the leaf may checkpoint the states after a predetermined amount of time. Other checkpointing criteria may also be used.
- a node or a leaf server fails (e.g., does not respond), the connected component computation process need not restart. Because the messaging is asynchronous and nodes can independently checkpoint their state, each node affected by the failure may pick up where it left off. For example, after a fault a node may initialize its state to the last checkpointed state for the node (345). This checkpointed state may be stored in persistent memory, as described above. As part of the initialization process, the node may use information in the checkpoint to determine whether to set its status to active or inactive. The node may then request from its neighbors any messages sent since the time of the checkpoint (350).
- the node may then set its status to inactive (355) and wait for messages, as indicated by the dashed line.
- the neighbors that receive the recovery request may ignore the request if they have no information to send. For example the neighbor node may determine whether it sent a message since the time of the checkpoint. If it has not, the request may be ignored. If the neighbor node did send a message, and the neighbor node is inactive, the neighbor node may send its cluster identifier to the node that sent the recovery request. If the neighbor nodes status is active, the priority queue engine already includes a message for the node that sent the recovery message, so another message does not need to be sent. Once the node that sent the recovery request begins receiving messages, it may process the messages as indicated above, with regard to steps 320 through 340.
- the priority queue engine may be propagating messages arbitrarily as it receives them. When the priority queue has no other messages to send, it may check the state of the nodes. If all nodes are inactive, the leaf may report that its nodes are inactive. Of course, if the priority queue receives a message from another leaf, it may report that its nodes are once again active (e.g., no longer inactive). A root node may track the status of each leaf in the distributed system. When each leaf is inactive, the clusters are stable and the system has computed the connected components for the graph. Process 300 has thus ended for all nodes in the graph and the value of the state cluster identifier for each node indicates which connected component in the graph the node belongs to.
- the system may store the cluster identifier from the node's state as an attribute of the node.
- the cluster identifier or other value sent via message can be used in various ways for additional graph processing such as suggesting new connections in a social networking graph, load distribution for traffic in a computer network graph, vision or image processing, machine learning, responding to search queries, knowledge discovery, etc.
- process 300 is illustrated as sending a lowest identifier, it is understood that the asynchronous messaging techniques may be used with a highest identifier with appropriate modifications.
- FIG. 4 illustrates an example of asynchronous messaging using cluster 215 of FIG. 2. While cluster 215 is used an example for brevity, it is understood that the computation of connected components would occur for all nodes of the graph simultaneously, and not just for the nodes of cluster 215. It is also understood that the representation of the states below uses alphanumeric values, e.g., ⁇ value, status ⁇ , for ease of explanation and the actual data structure implementation may use other representations that are more memory conscious. Upon initialization of the state, the nodes in cluster 215 may begin with the following states (Sv):
- the identifier in each state may be propagated to its neighbors.
- Node J sends J to Node L
- Node L sends L to Node J and Node M
- Node M sends M to Node L and Node K
- Node K sends K to Node M.
- the messages can be sent simultaneously and independently from each other.
- Node J is on a different leaf than Nodes K, L, and M.
- the priority queue of Leaf 150B may delay sending Node J's message to Node L so it can bundle the message with other messages directed to Leaf 150C.
- Node B may also be sending messages to Nodes D and C. These messages may be bundled with Node J's message to Node L and delivered together to the priority queue engine of Leaf 150C, thus making more efficient use of network resources.
- the priority queue engine on Leaf 150C may choose to propagate Node L's messages to Nodes M and J first, leaving the messages of M to Node L, M to Node K, and K to Node M in the queue.
- the priority queue engine may also set the status of L to inactive.
- Node M receives L's message and determines that L is less than M. Thus, Node M changes its cluster identifier to L and marks itself as active.
- Node M then sends a message to Node L and Node K with the identifier of L.
- Node J also receives Node L's message, but J is less than L, so Node J takes no action.
- the priority queue of Leaf 150B may propagate Node J's message to Node L to the priority queue of Leaf 150C, causing Node L to receive the identifier J. Because J is less than L, Node L changes its status to active, and sends a message to Node J and Node M with J as an identifier.
- the priority queue on Leaf 150C may have messages of M to Node L, M to Node K, K to Node M, L to Node L, L to Node K, J to Node J and J to Node M in the queue.
- the queue engine my propagate the messages J to Node M and J to Node J next, setting L's status to inactive.
- Node M Because J is lower than L Node M's current identifier, Node M changes its status to active, changes its identifier to J and sends a message to Node L and Node K with identifier J.
- the priority queue engine may propagate the message K to Node M next, setting K's status to inactive. Node M does nothing because K is not less than J, M's current status.
- the nodes may also checkpoint their state at appropriate times.
- the priority queue engine may intelligently choose which messages to send first, so that the total number of messages sent by the system is reduced. As one example, if the system uses a smallest identifier, the priority queue engine may propagate messages that include smaller identifiers and skip messages with higher identifiers to the same nodes because the latter would be redundant. Accordingly, using the example above the queue includes three messages to Nodes K and L, one with J, one with M, and one with L. Because J is lower than both M and L, the priority queue engine may propagate the message with J but skip the messages with M and L. When the priority queue engine skips the messages sending M and L it may still change the status of Node M, which sent the message to Nodes L and K, to inactive.
- the asynchronous message passing reduces contention and increases parallelism.
- the tradeoff for the ability to perform asynchronous message passing is that messages sent between two nodes must be idempotent, e.g., not alter the state of the source nor target nodes if the framework decides to resent them one or more times, and the messages must supersede all previous messages sent between the source and target nodes. In other words, the system is allowed to suppress any but the last message sent between two nodes without changing the behavior of the implemented algorithm.
- the asynchronous message passing framework described above may also be used with other techniques of graph analysis beyond computing connected components.
- the asynchronous message passing framework can be used to calculate a shortest path between nodes using the priority queue engine and checkpointing.
- the information included in the message sent between nodes and the operations performed at the nodes may differ from those discussed above, but the role of the priority queue engine and the fault tolerant techniques are similar.
- FIG. 5 shows an example of a generic computer device 500, which may be system 100 or client 170 of FIG. 1, which may be used with the techniques described here.
- Computing device 500 is intended to represent various example forms of computing devices, such as laptops, desktops, workstations, personal digital assistants, cellular telephones, smart phones, tablets, servers, and other computing devices, including wearable devices
- the components shown here, their connections and relationships, and their functions, are meant to be exemplary only, and are not meant to limit implementations of the inventions described and/or claimed in this document.
- Computing device 500 includes a processor 502, memory 504, a storage device 506, and expansion ports 510 connected via an interface 508.
- computing device 500 may include transceiver 546,
- Device 500 may communicate wirelessly through communication interface 544, which may include digital signal processing circuitry where necessary.
- Each of the components 502, 504, 506, 508, 510, 540, 544, 546, and 548 may be mounted on a common motherboard or in other manners as appropriate.
- the processor 502 can process instructions for execution within the computing device 500, including instructions stored in the memory 504 or on the storage device 506 to display graphical information for a GUI on an external input/output device, such as display 516.
- Display 516 may be a monitor or a flat touchscreen display.
- multiple processors and/or multiple buses may be used, as appropriate, along with multiple memories and types of memory.
- multiple computing devices 500 may be connected, with each device providing portions of the necessary operations (e.g., as a server bank, a group of blade servers, or a multi-processor system).
- the memory 504 stores information within the computing device 500.
- the memory 504 is a volatile memory unit or units.
- the memory 504 is a non-volatile memory unit or units.
- the memory 504 may also be another form of computer-readable medium, such as a magnetic or optical disk.
- the memory 504 may include expansion memory provided through an expansion interface.
- the storage device 506 is capable of providing mass storage for the computing device 500.
- the storage device 506 may be or contain a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network or other configurations.
- a computer program product can be tangibly embodied in such a computer-readable medium.
- the computer program product may also contain instructions that, when executed, perform one or more methods, such as those described above.
- the computer- or machine-readable medium is a storage device such as the memory 504, the storage device 506, or memory on processor 502.
- the interface 508 may be a high speed controller that manages bandwidth-intensive operations for the computing device 500 or a low speed controller that manages lower bandwidth-intensive operations, or a combination of such controllers.
- An external interface 540 may be provided so as to enable near area communication of device 500 with other devices.
- controller 508 may be coupled to storage device 506 and expansion port 514.
- the expansion port which may include various communication ports (e.g., USB, Bluetooth, Ethernet, wireless Ethernet) may be coupled to one or more input/output devices, such as a keyboard, a pointing device, a scanner, or a networking device such as a switch or router, e.g., through a network adapter.
- the computing device 500 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a standard server 530, or multiple times in a group of such servers. It may also be implemented as part of a rack server system. In addition, it may be implemented in a personal computer such as a laptop computer 522, or smart phone 536. An entire system may be made up of multiple computing devices 500 communicating with each other. Other configurations are possible.
- FIG. 6 shows an example of a generic computer device 600, which may be system 100 of FIG. 1, which may be used with the techniques described here.
- Computing device 600 is intended to represent various example forms of large- scale data processing devices, such as servers, blade servers, datacenters, mainframes, and other large-scale computing devices.
- Computing device 600 may be a distributed system having multiple processors, possibly including network attached storage nodes, that are interconnected by one or more communication networks.
- the components shown here, their connections and relationships, and their functions, are meant to be exemplary only, and are not meant to limit implementations of the inventions described and/or claimed in this document.
- Distributed computing system 600 may include any number of computing devices 680.
- Computing devices 680 may include a server or rack servers, mainframes, etc. communicating over a local or wide-area network, dedicated optical links, modems, bridges, routers, switches, wired or wireless networks, etc.
- each computing device may include multiple racks.
- computing device 680a includes multiple racks 658a - 658n.
- Each rack may include one or more processors, such as processors 652a-652n and 662a-662n.
- the processors may include data processors, network attached storage devices, and other computer controlled devices.
- one processor may operate as a master processor and control the scheduling and data distribution tasks.
- Processors may be interconnected through one or more rack switches 658, and one or more racks may be connected through switch 678. Switch 678 may handle communications between multiple connected computing devices 600.
- Each rack may include memory, such as memory 654 and memory 664, and storage, such as 656 and 666.
- Storage 656 and 666 may provide mass storage and may include volatile or non-volatile storage, such as network-attached disks, floppy disks, hard disks, optical disks, tapes, flash memory or other similar solid state memory devices, or an array of devices, including devices in a storage area network or other configurations.
- Storage 656 or 666 may be shared between multiple processors, multiple racks, or multiple computing devices and may include a computer-readable medium storing instructions executable by one or more of the processors.
- Memory 654 and 664 may include, e.g., volatile memory unit or units, a non-volatile memory unit or units, and/or other forms of computer-readable media, such as a magnetic or optical disks, flash memory, cache, Random Access Memory (RAM), Read Only Memory (ROM), and combinations thereof. Memory, such as memory 654 may also be shared between processors 652a-652n. Data structures, such as an index, may be stored, for example, across storage 656 and memory 654. Computing device 600 may include other components not shown, such as controllers, buses, input/output devices, communications modules, etc.
- An entire system such as system 100, may be made up of multiple computing devices 600 communicating with each other.
- device 680a may communicate with devices 680b, 680c, and 680d, and these may collectively be known as system 100.
- system 100 of FIG. 1 may include one or more computing devices 600 as root 120 and one or more of leaves 150, a separate computing device 600 as root 120, and one or more computing devices 600 as graph cluster 160.
- some of the computing devices may be located geographically close to each other, and others may be located geographically distant.
- the layout of system 600 is an example only and the system may take on other layouts or configurations.
- Various implementations can include implementation in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
- a programmable processor which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
- the systems and techniques described here can be implemented in a computing system that includes a back end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front end component (e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here), or any combination of such back end, middleware, or front end components.
- the components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include a local area network ("LAN”), a wide area network (“WAN”), and the Internet.
- LAN local area network
- WAN wide area network
- the Internet the global information network
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network.
- the relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
Abstract
Description
Claims
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201361841334P | 2013-06-29 | 2013-06-29 | |
US14/145,127 US9852230B2 (en) | 2013-06-29 | 2013-12-31 | Asynchronous message passing for large graph clustering |
PCT/US2014/044642 WO2014210501A1 (en) | 2013-06-29 | 2014-06-27 | Asynchronous message passing for large graph clustering |
Publications (2)
Publication Number | Publication Date |
---|---|
EP3014446A1 true EP3014446A1 (en) | 2016-05-04 |
EP3014446B1 EP3014446B1 (en) | 2019-02-20 |
Family
ID=52116707
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
EP14744684.3A Active EP3014446B1 (en) | 2013-06-29 | 2014-06-27 | Asynchronous message passing for large graph clustering |
Country Status (3)
Country | Link |
---|---|
US (1) | US9852230B2 (en) |
EP (1) | EP3014446B1 (en) |
WO (1) | WO2014210501A1 (en) |
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN108446864A (en) * | 2018-04-10 | 2018-08-24 | 广州新科佳都科技有限公司 | The fault early warning system and method for Transit Equipment based on big data analysis |
Families Citing this family (32)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9450992B2 (en) * | 2013-10-23 | 2016-09-20 | Facebook, Inc. | Node properties in a social-networking system |
US10148736B1 (en) * | 2014-05-19 | 2018-12-04 | Amazon Technologies, Inc. | Executing parallel jobs with message passing on compute clusters |
US10459978B2 (en) * | 2015-04-03 | 2019-10-29 | Oracle International Corporation | Distributed graph processing system that support remote data read with proactive bulk data transfer |
US10277601B1 (en) | 2015-05-11 | 2019-04-30 | Google Llc | System and method for recursive propagating application access control |
EP3294410A2 (en) | 2015-05-12 | 2018-03-21 | National University of Ireland Galway | Devices for therapeutic nasal neuromodulation and associated methods and systems |
WO2017039703A1 (en) * | 2015-09-04 | 2017-03-09 | Hewlett Packard Enterprise Development Lp | Hybrid graph processing |
US10635562B2 (en) * | 2015-09-04 | 2020-04-28 | Futurewei Technologies, Inc. | Fault tolerance in distributed graph processing networks |
US10506016B2 (en) | 2016-05-19 | 2019-12-10 | Oracle International Corporation | Graph analytic engine that implements efficient transparent remote access over representational state transfer |
US10275287B2 (en) | 2016-06-07 | 2019-04-30 | Oracle International Corporation | Concurrent distributed graph processing system with self-balance |
US10318355B2 (en) | 2017-01-24 | 2019-06-11 | Oracle International Corporation | Distributed graph processing system featuring interactive remote control mechanism including task cancellation |
US10534657B2 (en) | 2017-05-30 | 2020-01-14 | Oracle International Corporation | Distributed graph processing system that adopts a faster data loading technique that requires low degree of communication |
US10552274B1 (en) * | 2017-08-03 | 2020-02-04 | EMC IP Holding Company LLC | Asynchronous in-memory data checkpointing for distributed computing systems |
US10642867B2 (en) * | 2017-09-15 | 2020-05-05 | Adobe Inc. | Clustering based on a directed graph |
US20220232024A1 (en) | 2017-11-27 | 2022-07-21 | Lacework, Inc. | Detecting deviations from typical user behavior |
US10419469B1 (en) | 2017-11-27 | 2019-09-17 | Lacework Inc. | Graph-based user tracking and threat detection |
US11979422B1 (en) | 2017-11-27 | 2024-05-07 | Lacework, Inc. | Elastic privileges in a secure access service edge |
US11792284B1 (en) | 2017-11-27 | 2023-10-17 | Lacework, Inc. | Using data transformations for monitoring a cloud compute environment |
EP3776237A1 (en) * | 2018-03-31 | 2021-02-17 | Micron Technology, Inc. | Multiple types of thread identifiers for a multi-threaded, self-scheduling reconfigurable computing fabric |
KR102446709B1 (en) * | 2018-03-31 | 2022-09-26 | 마이크론 테크놀로지, 인크. | Execution control of a multi-threaded, self-scheduling, reconfigurable computing fabric |
CN109361741A (en) * | 2018-09-29 | 2019-02-19 | 上海优谦智能科技有限公司 | Utilize the system for going distributed transmission technology to protect personal information |
US20200179043A1 (en) | 2018-12-11 | 2020-06-11 | Neurent Medical Limited | Systems and methods for therapeutic nasal neuromodulation |
US11475318B2 (en) | 2019-05-29 | 2022-10-18 | Kyndryl, Inc. | Automated resolution of over and under-specification in a knowledge graph |
US11321394B2 (en) * | 2019-06-24 | 2022-05-03 | Thatdot, Inc. | Graph processing system |
US11201955B1 (en) | 2019-12-23 | 2021-12-14 | Lacework Inc. | Agent networking in a containerized environment |
US11188571B1 (en) | 2019-12-23 | 2021-11-30 | Lacework Inc. | Pod communication graph |
US11256759B1 (en) | 2019-12-23 | 2022-02-22 | Lacework Inc. | Hierarchical graph analysis |
US10873592B1 (en) | 2019-12-23 | 2020-12-22 | Lacework Inc. | Kubernetes launch graph |
US11896818B2 (en) | 2020-04-09 | 2024-02-13 | Neurent Medical Limited | Systems and methods for therapeutic nasal treatment |
US11883091B2 (en) | 2020-04-09 | 2024-01-30 | Neurent Medical Limited | Systems and methods for improving sleep with therapeutic nasal treatment |
US11461130B2 (en) | 2020-05-26 | 2022-10-04 | Oracle International Corporation | Methodology for fast and seamless task cancelation and error handling in distributed processing of large graph data |
US11379748B2 (en) | 2020-06-15 | 2022-07-05 | Bank Of America Corporation | System for threshold detection using learning reinforcement |
CN112559632A (en) * | 2020-12-15 | 2021-03-26 | 北京百度网讯科技有限公司 | Method, device, electronic equipment and medium for synchronizing state of distributed graph database |
Family Cites Families (17)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20030033582A1 (en) | 2001-05-09 | 2003-02-13 | Wavemarket, Inc. | Representations for estimating distance |
WO2005033884A2 (en) | 2003-10-03 | 2005-04-14 | Alphatech, Inc. | Methods and systems for determining a set of costs of routes in a network |
WO2005036839A2 (en) | 2003-10-03 | 2005-04-21 | Avici Systems, Inc. | Rapid alternate paths for network destinations |
US7827181B2 (en) | 2004-09-30 | 2010-11-02 | Microsoft Corporation | Click distance determination |
US7761448B2 (en) | 2004-09-30 | 2010-07-20 | Microsoft Corporation | System and method for ranking search results using click distance |
CN100558038C (en) | 2006-03-31 | 2009-11-04 | 国际商业机器公司 | Service logger and related system and method |
US20070297332A1 (en) | 2006-06-22 | 2007-12-27 | James Andrew Broberg | Distributed resource allocation in stream processing systems |
US8656017B2 (en) | 2007-05-16 | 2014-02-18 | Microsoft Corporation | Peer-to-peer collaboration system with edge routing |
EP2176754B1 (en) | 2007-06-26 | 2019-10-16 | Softlife Projects Limited Doing Business as Applied Cytometry Systems | System and method for optimizing data analysis |
US20090210489A1 (en) | 2008-02-18 | 2009-08-20 | Supratim Deb | Methods for peer-caching for faster lookups in peer-to-peer systems |
US8036220B2 (en) | 2008-06-20 | 2011-10-11 | Cisco Technology, Inc | Pre-dropping of a packet if its time-to-live (TTL) value is not large enough to reach a destination |
US8631094B1 (en) | 2008-08-08 | 2014-01-14 | Google Inc. | Distributed parallel determination of single and multiple source shortest paths in large directed graphs |
US20100083194A1 (en) | 2008-09-27 | 2010-04-01 | Yahoo! Inc. | System and method for finding connected components in a large-scale graph |
US8266301B2 (en) * | 2009-03-04 | 2012-09-11 | International Business Machines Corporation | Deployment of asynchronous agentless agent functionality in clustered environments |
US8572575B2 (en) * | 2009-09-14 | 2013-10-29 | Myspace Llc | Debugging a map reduce application on a cluster |
US8521782B2 (en) | 2011-07-20 | 2013-08-27 | Salesforce.Com, Inc. | Methods and systems for processing large graphs using density-based processes using map-reduce |
US10454997B2 (en) * | 2012-09-07 | 2019-10-22 | Avigilon Corporation | Distributed physical security system |
-
2013
- 2013-12-31 US US14/145,127 patent/US9852230B2/en active Active
-
2014
- 2014-06-27 WO PCT/US2014/044642 patent/WO2014210501A1/en active Application Filing
- 2014-06-27 EP EP14744684.3A patent/EP3014446B1/en active Active
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN108446864A (en) * | 2018-04-10 | 2018-08-24 | 广州新科佳都科技有限公司 | The fault early warning system and method for Transit Equipment based on big data analysis |
Also Published As
Publication number | Publication date |
---|---|
US20150006606A1 (en) | 2015-01-01 |
WO2014210501A1 (en) | 2014-12-31 |
EP3014446B1 (en) | 2019-02-20 |
US9852230B2 (en) | 2017-12-26 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9852230B2 (en) | Asynchronous message passing for large graph clustering | |
Li et al. | Parameter server for distributed machine learning | |
EP3014444B1 (en) | Computing connected components in large graphs | |
US9589069B2 (en) | Platform for continuous graph update and computation | |
US11210185B2 (en) | Method and system for data recovery in a data system | |
CN104794015B (en) | A kind of real-time stream calculation flow velocity perceives elasticity and performs tolerant system | |
CN103297543A (en) | Job scheduling method based on computer cluster | |
CN110134505A (en) | A kind of distributed computing method of group system, system and medium | |
Suh et al. | On performance of OpenDaylight clustering | |
EP3312723A1 (en) | Command processing method and server | |
CN103634411A (en) | Real-time market data broadcasting system and real-time market data broadcasting method with state consistency | |
CN108390771B (en) | Network topology reconstruction method and device | |
Karthikeyan et al. | Saldeft: Self-adaptive learning differential evolution based optimal physical machine selection for fault tolerance problem in cloud | |
CN107181774A (en) | Data movement between distributive data center | |
CN110888761A (en) | Fault-tolerant method based on active backup of key task part and stream processing platform | |
EP2884453A1 (en) | A computer implemented method, a system and computer program product for partitioning a graph representative of a communication network | |
CN103885856A (en) | Diagram calculation fault-tolerant method and system based on information regeneration mechanism | |
CN108415798A (en) | A kind of fault-tolerant implementation method of virtual machine based on KVM | |
Lin et al. | ReHRS: A hybrid redundant system for improving MapReduce reliability and availability | |
EP3701374A1 (en) | A system and method for high-performance general-purpose parallel computing with fault tolerance and tail tolerance | |
Xu et al. | BDPGO: balanced distributed pose graph optimization framework for swarm robotics | |
Peres | Concurrent self-adjusting distributed tree networks | |
US10374915B1 (en) | Metrics processing service | |
Suyu | Data Mining Association Rule Algorithm Based on Hadoop | |
Odarchenko et al. | Evaluation of sdn network scalability with different management level structure |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PUAI | Public reference made under article 153(3) epc to a published international application that has entered the european phase |
Free format text: ORIGINAL CODE: 0009012 |
|
17P | Request for examination filed |
Effective date: 20151112 |
|
AK | Designated contracting states |
Kind code of ref document: A1Designated state(s): AL AT BE BG CH CY CZ DE DK EE ES FI FR GB GR HR HU IE IS IT LI LT LU LV MC MK MT NL NO PL PT RO RS SE SI SK SM TR |
|
AX | Request for extension of the european patent |
Extension state: BA ME |
|
DAX | Request for extension of the european patent (deleted) | ||
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: EXAMINATION IS IN PROGRESS |
|
17Q | First examination report despatched |
Effective date: 20170630 |
|
RAP1 | Party data changed (applicant data changed or rights of an application transferred) |
Owner name: GOOGLE LLC |
|
GRAP | Despatch of communication of intention to grant a patent |
Free format text: ORIGINAL CODE: EPIDOSNIGR1 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: GRANT OF PATENT IS INTENDED |
|
RIC1 | Information provided on ipc code assigned before grant |
Ipc: G06F 9/54 20060101AFI20180622BHEPIpc: G06F 17/30 20060101ALI20180622BHEPIpc: G06Q 10/06 20120101ALI20180622BHEP |
|
INTG | Intention to grant announced |
Effective date: 20180713 |
|
GRAJ | Information related to disapproval of communication of intention to grant by the applicant or resumption of examination proceedings by the epo deleted |
Free format text: ORIGINAL CODE: EPIDOSDIGR1 |
|
GRAL | Information related to payment of fee for publishing/printing deleted |
Free format text: ORIGINAL CODE: EPIDOSDIGR3 |
|
GRAS | Grant fee paid |
Free format text: ORIGINAL CODE: EPIDOSNIGR3 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: EXAMINATION IS IN PROGRESS |
|
INTC | Intention to grant announced (deleted) | ||
GRAR | Information related to intention to grant a patent recorded |
Free format text: ORIGINAL CODE: EPIDOSNIGR71 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: GRANT OF PATENT IS INTENDED |
|
GRAA | (expected) grant |
Free format text: ORIGINAL CODE: 0009210 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: THE PATENT HAS BEEN GRANTED |
|
AK | Designated contracting states |
Kind code of ref document: B1Designated state(s): AL AT BE BG CH CY CZ DE DK EE ES FI FR GB GR HR HU IE IS IT LI LT LU LV MC MK MT NL NO PL PT RO RS SE SI SK SM TR |
|
INTG | Intention to grant announced |
Effective date: 20190111 |
|
REG | Reference to a national code |
Ref country code: GBRef legal event code: FG4D |
|
RIC1 | Information provided on ipc code assigned before grant |
Ipc: G06F 16/00 20190101ALI20190115BHEPIpc: G06F 9/54 20060101AFI20190115BHEPIpc: G06Q 10/06 20120101ALI20190115BHEP |
|
REG | Reference to a national code |
Ref country code: CHRef legal event code: EP |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R096Ref document number: 602014041278Country of ref document: DE |
|
REG | Reference to a national code |
Ref country code: ATRef legal event code: REFRef document number: 1099096Country of ref document: ATKind code of ref document: TEffective date: 20190315 |
|
REG | Reference to a national code |
Ref country code: IERef legal event code: FG4D |
|
REG | Reference to a national code |
Ref country code: NLRef legal event code: MPEffective date: 20190220 |
|
REG | Reference to a national code |
Ref country code: LTRef legal event code: MG4D |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: FIFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: NOFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190520Ref country code: NLFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: LTFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: PTFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190620Ref country code: SEFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: LVFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: RSFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: BGFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190520Ref country code: GRFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190521Ref country code: ISFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190620Ref country code: HRFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220 |
|
REG | Reference to a national code |
Ref country code: ATRef legal event code: MK05Ref document number: 1099096Country of ref document: ATKind code of ref document: TEffective date: 20190220 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: ESFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: DKFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: ALFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: SKFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: ITFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: ROFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: CZFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: EEFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220 |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R097Ref document number: 602014041278Country of ref document: DE |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: SMFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220Ref country code: PLFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220 |
|
PLBE | No opposition filed within time limit |
Free format text: ORIGINAL CODE: 0009261 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: NO OPPOSITION FILED WITHIN TIME LIMIT |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: ATFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220 |
|
26N | No opposition filed |
Effective date: 20191121 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: MCFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220 |
|
REG | Reference to a national code |
Ref country code: CHRef legal event code: PL |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: SIFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220 |
|
REG | Reference to a national code |
Ref country code: BERef legal event code: MMEffective date: 20190630 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: TRFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: LIFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20190630Ref country code: LUFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20190627Ref country code: CHFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20190630Ref country code: BEFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20190630 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: FRFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20190630 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: CYFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: HUFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMIT; INVALID AB INITIOEffective date: 20140627Ref country code: MTFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: MKFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20190220 |
|
P01 | Opt-out of the competence of the unified patent court (upc) registered |
Effective date: 20230506 |
|
PGFP | Annual fee paid to national office [announced via postgrant information from national office to epo] |
Ref country code: IEPayment date: 20230627Year of fee payment: 10Ref country code: DEPayment date: 20230626Year of fee payment: 10 |
|
PGFP | Annual fee paid to national office [announced via postgrant information from national office to epo] |
Ref country code: GBPayment date: 20230627Year of fee payment: 10 |