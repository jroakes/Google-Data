US9250874B1 - Sharing property descriptor information between object maps - Google Patents
Sharing property descriptor information between object maps Download PDFInfo
- Publication number
- US9250874B1 US9250874B1 US14/024,592 US201314024592A US9250874B1 US 9250874 B1 US9250874 B1 US 9250874B1 US 201314024592 A US201314024592 A US 201314024592A US 9250874 B1 US9250874 B1 US 9250874B1
- Authority
- US
- United States
- Prior art keywords
- descriptor array
- descriptor
- map
- array
- object map
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
- G06F8/43—Checking; Contextual analysis
- G06F8/436—Semantic checking
- G06F8/437—Type checking
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/01—Input arrangements or combined input and output arrangements for interaction between user and computer
- G06F3/048—Interaction techniques based on graphical user interfaces [GUI]
- G06F3/0484—Interaction techniques based on graphical user interfaces [GUI] for the control of specific functions or operations, e.g. selecting or manipulating an object, an image or a displayed text element, setting a parameter value or selecting a range
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/3668—Software testing
- G06F11/3672—Test management
- G06F11/3688—Test management for test execution, e.g. scheduling of test suites
Definitions
- Some dynamically-typed languages provide computational objects in the form of associative arrays.
- An associative array is an abstract data structure arranges as a collection of key-value pairs, such that each possible key appears at most once in the collection. Accordingly, property values may be stored and looked up by referencing a key. For example, a lookup may be performed based on a property name to locate a pointer to a memory location of the value.
- dynamically-typed languages dynamically generate object maps for computational objects at runtime to describe the memory layout of the objects.
- a computer-implemented method may include modifying an object data structure in a dynamic programming environment to change an initial number of object properties provided by the object data structure, generating a child object map for the modified object data structure, the child object map based on a parent object map for the unmodified object data structure, sharing a descriptor array associated with the base object map with the child object map in connection with generating the child object map, altering the descriptor array according to the modified object data structure, and limiting access to the descriptor array from the parent object map in accordance with the initial number of object properties of the unmodified object data structure.
- Other aspects include corresponding systems, apparatuses, and computer program products for implementation of the computer-implemented method.
- a machine-readable medium may include instructions stored thereon that, when executed by a processor, cause a machine to perform a method of tracking property representations in instantiated objects.
- the method may include modifying an object data structure in a dynamic programming environment to add a new object property to an initial number of object properties provided by the object data structure, generating a child object map for the modified object data structure, the child object map based on a parent object map for the unmodified object data structure, sharing a descriptor array associated with the base object map with the child object map in connection with generating the child object map, adding a new property descriptor for the new object property to the descriptor array, and limiting access to the descriptor array from the parent object map in accordance with the initial number of object properties of the unmodified object data structure.
- Other aspects include corresponding systems, apparatuses, and computer program products for implementation of the machine-readable medium.
- a system may include one or more processors and a memory.
- the memory may include instructions that, when executed by the one or more processors, cause the one or more processors to facilitate the steps of modifying an object data structure in a dynamic programming environment to change an initial number of object properties provided by the object data structure, generating a child object map for the modified object data structure, the child object map based on a parent object map for the unmodified object data structure, sharing a descriptor array associated with the base object map with the child object map in connection with generating the child object map, altering the descriptor array according to the modified object data structure, and limiting access to the descriptor array from the parent object map in accordance with the initial number of object properties of the unmodified object data structure.
- the previously described aspects and other aspects may provide one or more advantages, including, but not limited to, conserving memory space when generating dynamically typed information for object instances. Additionally type and mapping information is provided about properties stored in computational objects so that a runtime environment does not need to dynamically check the type of the property value if the type has already been checked, for example, when loading values from properties. When a new property value (or property object) is stored in a property having a current property type that is incompatible with the new property value the current property type and mapping information for the computational object changes so that the information about the properties of the computational object is always guaranteed to be accurate.
- FIG. 1 depicts a modification of an example computational object in a dynamic runtime environment on a computing device.
- FIG. 2 is a diagram depicting the dynamic generation of an example object map for an example modified computational object.
- FIG. 3 depicts sharing an example descriptor array for an example parent object map with one or more example child object maps.
- FIG. 4 depicts sharing a subset of descriptors between two object maps.
- FIG. 5 is a flowchart for an example process of sharing property descriptor information.
- FIG. 6 is a diagram illustrating an example electronic system for use in connection with tracking property representations when an example computational object is modified.
- FIG. 1 depicts a modification of an example computational object 101 in a dynamic runtime environment 102 on a computing device 103 , according to one or more aspects of the subject technology.
- executable instructions 104 are loaded into runtime environment 102 , compiled, and then executed. Instructions 104 , when executed, create computational object 101 and may perform a number of operations upon computational object 101 .
- Computational object 101 is a data structure such as an associative array that stores properties having set property values (e.g., a JavaScript dictionary object).
- Computational object 101 may not have a set number of properties and corresponding values but, rather, the number of properties may be changed by executable instructions 104 in response to predetermined execution paths, user input, or other influences on the runtime environment.
- executable instructions 104 may be embedded in one or more web pages, and the number of properties and/or their corresponding property values may change in response to specific user-initiated navigation paths and/or input associated with the web pages.
- Computational object 101 may store any type of property available to runtime environment 102 , and the type of a value stored in a heap property may not be known until runtime.
- computational object 101 may directly store small integers, but store pointers to other property values that must be allocated on the heap. For example, when storing a double value, a small object may be allocated on the heap to hold the value.
- boxing the technique of wrapping primitive values in objects is referred to as “boxing”.
- a computational object 101 (“Object A”) is dynamically modified to change an initial number of object properties provided by the object. Accordingly, in a first state 105 , Object A has one property p 1 having a small integer property type (“smi”). p 1 may be stored and read by runtime environment 102 directly from the object. During operation of computing device 103 , runtime environment 102 (in connection with executable instructions 104 ) adds a new property and changes the value and type of p 1 .
- shi small integer property type
- FIG. 2 is a diagram depicting the dynamic generation of an example object map for an example modified computational object, according to one or more aspects of the subject technology.
- each computation object of the subject technology has a corresponding object map (also called a “hidden class”) that describes its layout.
- Object maps generally map property names to values (e.g., via memory offsets indicating where the value is stored for an instance of a corresponding object), and in this respect each object in the runtime environment includes an object map corresponding to the specific arrangement of the object.
- object maps are dynamically generated to suit the addition or subtraction of different property types at runtime, or deprecated (e.g., designated or marked invalid) to indicate that a property representation is outdated.
- deprecated e.g., designated or marked invalid
- the deprecated maps will be garbage collected, saving memory in the runtime environment.
- a new map is generated for the object, and transition information is generated in the old map so that the new map and the memory location of the new property may be found when the property is being accessed.
- transition information is generated in the old map so that the new map and the memory location of the new property may be found when the property is being accessed.
- a new map is generated for the object, and the current or target map is deprecated.
- the new map includes a representation for the property that corresponds to the new property type.
- FIG. 2 is representative of how runtime environment 102 creates and deprecates object maps for Object A of FIG. 1 when the property values are updated and/or changed.
- Map M 1 is initially created for Object A during the first state 105 .
- M 1 like other maps of the subject technology, includes parameters to facilitate determining the location of named properties and their corresponding property representations so that runtime environment 102 may efficiently operate on the object corresponding to the map.
- each map includes a “transition array” that informs runtime environment 102 where to find properties not located in the current map and a “description array” that determines what properties are stored in the object and, for each property, a corresponding property representation.
- the transition array associates the property name with a location of a target (or child) map so that the location of the target map and value of the property name may be determined (e.g., found).
- a new map is created when a new property is added to an object, and the transition array of the parent or base map updated to include the location of the new map. For example, if a new property p 2 is added to Object A, the current map for the object M 1 is updated with a transition to target map M 2 , indicating that if a property p 2 is added to an object described by M 1 then M 2 should be used instead of M 1 .
- the transition array may include, for example, the name of the property in the map (e.g., in M 1 ) at a first position in the array, and a pointer to the target map at a second position in the array.
- a transition array may include multiple property names, each associated with a different target map.
- a “transition tree” of maps may be generated as objects are modified to delete or add properties, or change property types over time.
- a parent map may branch to one or more other child maps depending on how new properties were added at runtime. For example, an object having properties p 1 and p 2 may be in a different branch than an object having properties p 1 and p 3 (see, e.g., FIG. 3 ).
- the property name corresponding to the transition may be determined by indexing the last added descriptor in the target map.
- a descriptor array is conceptually an array of property descriptors, with each descriptor comprising a set of values for a corresponding object property.
- FIG. 2 depicts each descriptor of a map's descriptor array as including a key (e.g., “p 1 ”) and a corresponding representation for identifying the property type (e.g., “Db 1 ”).
- the key may be a property name or other identification for the property.
- M 1 's descriptor array informs runtime environment 102 that any object using map M 1 has a single property p 1 and that p 1 's representation is “Smi” (small integer).
- each descriptor array is sorted by the order that the properties were added, and each map stores the number of valid properties for the map.
- Each property descriptor may also include a memory pointer to its corresponding property value.
- the memory pointer may be, for example, an offset from a base memory location, so that the memory location of the property value.
- the subject technology provides a mechanism for sharing descriptor arrays between maps in the same transition tree.
- the descriptor array for the parent map may be automatically shared with the child map.
- a descriptor array may be shared by (1) updating the child map with a pointer to the descriptor array of the parent map, and then appending the new property to the descriptor array; or (2) by copying the descriptor array to the child map, adding the new property to the descriptor array in the child map, and then overwriting the descriptor array in the parent map and other related maps in the same branch of the transition tree with the new property descriptor array.
- each map following a property transition is associated with a descriptor array that includes all of the same descriptors as its patent map plus one additional descriptor.
- Each map further includes an ownership bit designating whether the map owns its own descriptor array. Only a map having ownership of the descriptor array is allowed to share the array with child maps. The ownership bit, when cleared, prevents a map from re-sharing its descriptor array. Ownership is acquired in connection with the addition of a new property descriptor. For example, if p 2 is added to Object A to create Object A′ then a new map is Generated for Object A′ and the descriptor array for Object A is shared with the new map. The ownership bits for the maps are then set to designate the new map as the owner of the descriptor array. By only allowing maps that own a descriptor array share the array the subject technology avoids redundant copies of the descriptor arrays and extension of maps in more than one direction.
- FIG. 2 also depicts how one or more maps in a branch of the transition tree may be deprecated when a property type is changed during runtime.
- property p 1 of Object A is changed from a small integer to a double.
- runtime environment 102 determines that the new type is not supported by M 1 's descriptor array.
- the runtime environment traverses to M 1 's base map M 0 using a back pointer of M 1 , and uses M 0 to create a new map M 3 for Object A.
- M 1 is subsequently deprecated by setting a deprecation bit in the map.
- the runtime environment may deprecate all maps in the same branch as a deprecated map.
- M 2 may have been created for Object B by adding a small integer property p 2 to Object A.
- M 2 may include transition information designating M 3 as the location of p 2
- M 3 may include a back pointer to M 2 . Accordingly, M 3 may be deprecated along with M 1 when the property type of p 1 is changed in Object A.
- M 3 has been deprecated some objects may still designate M 3 as their map (e.g., hold a pointer to M 3 ).
- Object B may designate M 2 , however, M 2 may be deprecated. Accordingly, the next time Object B is used, the runtime environment will identify M 2 as a deprecated map and associate Object B with an updated map M 4 that corresponds to the appropriate property types for p 1 and p 2 .
- FIG. 3 depicts sharing an example descriptor array for an example parent object map with one or more example child object maps, according to one or more aspects of the subject technology.
- a descriptor array 301 is allocated in an area of memory accessible by one or more maps.
- new property p 2 is added to Object A to create Object A′.
- Object A is associated with map M 3 , which holds a reference or pointer 302 to descriptor array 301 .
- new map M 4 is created and descriptor array 301 is shared with M 3 .
- Descriptor array 301 is shared by providing M 4 with a pointer 303 to the descriptor array, and by designating M 4 as the owner of the array by setting an ownership bit 303 of M 4 .
- Maps that transition to each other share descriptors for like properties Since a child map has the same properties as its parent map, plus one, the child map takes over the property descriptors from the parent map and extends it by a property descriptor for the additional property added to the corresponding object.
- the descriptor array may be shared by providing a pointer to each new map and keeping track of a single owner of the descriptor array. In this respect, the amount of memory overhead to store the descriptor array may be limited to the maximum number of properties in a branch a transition tree (e.g., overhead becomes O(n) instead of O(n 2 )).
- Descriptor array 301 may keep track of how much memory space is available for additional descriptors.
- a new property descriptor (e.g., for property p 2 ) may be added to descriptor array 301 at the end of the array, provided there is enough room or memory to add the descriptor.
- runtime environment 102 may be configured to allocate a predetermined amount of additional memory 305 for the array (e.g., an additional 50% of the currently allocated amount of memory for the array).
- memory for a new larger array is allocated and the values of the outdated descriptor array 301 copied into the larger array, and all pointers from related maps updated to point to the larger array.
- the new property descriptor may then be added to the end of the larger array, and the outdated array garbage collected.
- new property p 3 is added to a copy of Object A to create Object A′′.
- new map M 4 is created and descriptor array 301 is shared with M 3 .
- descriptor array 301 may be shared with M 5 by copying a portion 306 of the descriptor array owned by M 3 and adding a new property descriptor for new property p 3 .
- a new property descriptor array 307 for M 5 is generated along with a corresponding descriptor pointer 308 in M 5 .
- M 5 is then designated as the owner of descriptor array 306 by setting an ownership bit 309 of M 5 to avoid further redundant copies of descriptor array 306 along the new branch in the transition tree generated by the transition from M 3 to M 5 and beyond.
- FIG. 4 depicts sharing a subset of descriptors between two object maps, according to one or more aspects of the subject technology.
- each map may maintain a descriptor limiter designating the number of valid descriptors for the map.
- a descriptor limiter 401 of M 3 designates that M 3 owns one descriptor in descriptor array 301
- a descriptor limiter 402 of M 4 designates that M 4 owns two descriptors in the array.
- Property descriptors are ordered in a descriptor array according to the order their corresponding properties are added. Accordingly, the descriptor limiter of each map associated with a descriptor array may designate the number of descriptors owned by the map from the first descriptor position in the array.
- the descriptor array may be implemented as a vector or similar storage object.
- a search of the descriptor array may be limited by the number of valid descriptors, or inform a search when a descriptor is found at a position beyond the number of valid descriptors that the map for the value may be found through one or more map transitions.
- a map may use the number of valid descriptors when determining whether to protect referenced properties and objects from garbage collection. For example, references associated with the descriptor array that correspond to properties of an object instance may be designated as protected from garbage collection, while references associated with the descriptor array that do not correspond to an object instance are not protected. Accordingly, references corresponding to descriptors not owned by a current map may be declared to be weak references, allowing them to be marked for garbage collection when they are no longer associated with an instance of an object.
- the target map may be garbage collected. If a descriptor array is currently shared with an outdated map then the properties associated with the map should not be kept alive. Accordingly, when a target map becomes outdated, the map is cleared from transition arrays in associated maps, and the now-invalid descriptors for the outdated map are removed from the descriptor array by trimming the array in-place in memory.
- FIG. 5 is a flowchart for an example process of sharing property descriptor information, according to one or more aspects of the subject technology.
- the blocks of FIG. 5 do not need to be performed in the order shown. It is understood that the depicted order is an illustration of one or more example approaches, and are not meant to be limited to the specific order or hierarchy presented. The blocks may be rearranged, and/or two or more of the blocks may be performed simultaneously.
- one or more blocks of FIG. 5 may be executed by a machine or computing device.
- a non-transitory machine-readable medium may include machine-executable instructions thereon that, when executed by a machine or computing device perform the blocks of FIG. 5 .
- the blocks of FIG. 5 may be performed in association with dynamically-typed languages, specifically in a dynamic programming environment in which a computational object is modified at runtime.
- an object data structure is modified in a dynamic programming environment to change an initial number of object properties provided by the object data structure.
- the object data structure is modified by adding a new object property.
- the object data structure may be modified under different circumstances. For example, a current object property may be deleted or its type information changed.
- a child object map is generated for the modified object data structure, the child object map based on a parent object map for the unmodified object data structure.
- Each object in the dynamic programming environment maps properties stored in the object to locations (or offsets) in memory for corresponding values, and includes strong type information for those values.
- the object property is added to the object, the object morphs into a new object having a new map.
- the new map for the child object may include all reference information (e.g., offset values) for the properties referenced by the parent map, and new reference information for properties added to create the child object.
- maps are dynamically created in a tree formation, with each branch corresponding to objects having a different object property.
- Each map has transition information that allows the map to determine in what other map includes location and type information for a property.
- a property is located in a tree of maps by transitioning to each map and checking the map's property representations in the map's descriptor array. Maps are dynamically traversed using transition information in their transition arrays until the desired representation is identified. Accordingly, when a new map is created this transition information is updated to replace a map that includes invalid or stale information with a new map that includes recent information for the new arrangement of object properties.
- a descriptor array associated with the base object map is shared with the child object map in connection with generating the child object map.
- each map includes a descriptor array for storing the reference information corresponding to object instances of the map.
- the descriptor array may further store type information about each property value.
- the descriptor array may include a representation of the property's property type (e.g., “double” or “integer”).
- the descriptor array may be shared by copying the array or by providing a pointer to the array to the child map.
- sharing the descriptor array may include copying the descriptor array from the parent object map to the child object map, adding the new property descriptor to the end of the descriptor array in the child object map to create a modified descriptor array, and overwriting the descriptor array in the parent object map (e.g., and maps along the entire parent branch) with the modified descriptor array.
- sharing the descriptor array may include providing a pointer to the descriptor array in the child object map, designating the child object map as the owner of the descriptor array, and designating the parent object map as no longer owning the descriptor array.
- a second child object map may be generated for a second modified object data structure, the second child object map based on the parent object map. Accordingly, the descriptor array may be copied from the parent object map to the second child object map to generate a second descriptor array for the second child object map, and the second child object map designated as the owner of the second descriptor array.
- the runtime environment may make a determination that the parent object map owns the descriptor array before sharing the descriptor array.
- altering the descriptor array may include adding a new property descriptor for the new object property to the descriptor array.
- the new property descriptor may be appended to an end of the descriptor array,
- access to the descriptor array from the parent object map is limited in accordance with the initial number of object properties of the unmodified object data structure.
- access may be limited by setting a number of descriptors in the descriptor array that can be accessed through the parent object map, with the child object map having access to at least one more descriptor than the parent object map.
- property descriptors in the descriptor array are arranged in the order that the properties were added to a corresponding object.
- the property descriptors are further arranged for efficient searching of the descriptor array for a property.
- each property descriptor may include a key and an array pointer.
- the key of each property descriptor may be associated with an identifier for an object property, and the array pointer designating a position in the descriptor array of a different key that would otherwise be at the current position if the descriptor array were ordered for a binary search.
- pointers when a new property descriptor is added to the descriptor array pointers may be inserted into the array, starting at a right position of the array and moving linearly from the end, in the process moving elements that belong later in the array to the right, one by one (e.g., using an insertion-sort). Accordingly, each pointer in the descriptor array designates a position in the descriptor array of a key that would otherwise be at a current position of the pointer within the descriptor array when a binary search is performed on the descriptor array.
- each array pointer provides for intra-indexing of the descriptor array, and is paired with a corresponding key to form a key-pointer pair.
- the array pointer of each key-pointer pair designates the position in the array of a key that would otherwise be at the current position in the array, had the keys been ordered for a binary search.
- the array pointer at array position 2 ([d,1]) designates key c (at position 1 in the array) as being in position 2 for a binary search.
- FIG. 6 is a diagram illustrating an example electronic system for use in connection with tracking property representations when an example computational object is modified, according to one or more aspects of the subject technology.
- Electronic system 600 may be a computing device for execution of software that performs or implements one or more blocks of FIG. 5 .
- electronic system 600 may be representative of a server, computer, phone, PDA, laptop, tablet computer, touch screen or television with one or more processors embedded therein or coupled thereto, or any other sort of electronic device.
- Electronic system 600 may include various types of computer readable media and interfaces for various other types of computer readable media.
- electronic system 600 includes a bus 608 , processing unit(s) 612 , a system memory 604 , a read-only memory (ROM) 610 , a permanent storage device 602 , an input device interface 614 , an output device interface 606 , and a network interface 616 .
- processing unit(s) 612 includes a bus 608 , processing unit(s) 612 , a system memory 604 , a read-only memory (ROM) 610 , a permanent storage device 602 , an input device interface 614 , an output device interface 606 , and a network interface 616 .
- ROM read-only memory
- Bus 608 collectively represents all system, peripheral, and chipset buses that communicatively connect the numerous internal devices of electronic system 600 .
- bus 608 communicatively connects processing unit(s) 612 with ROM 610 , system memory 604 , and permanent storage device 602 .
- processing unit(s) 612 retrieves instructions to execute and data to process in order to execute the processes of the subject disclosure.
- the processing unit(s) can be a single processor or a multi-core processor in different implementations.
- ROM 610 stores static data and instructions that are needed by processing unit(s) 612 and other modules of the electronic system.
- Permanent storage device 602 is a read-and-write memory device. This device is a non-volatile memory unit that stores instructions and data even when electronic system 600 is off. Some implementations of the subject disclosure use a mass-storage device (such as a magnetic or optical disk and its corresponding disk drive) as permanent storage device 602 .
- system memory 604 is a read-and-write memory device. However, unlike storage device 602 , system memory 604 is a volatile read-and-write memory, such a random access memory. System memory 604 stores some of the instructions and data that the processor needs at runtime. In some implementations, the processes of the subject disclosure are stored in system memory 604 , permanent storage device 602 , and/or ROM 610 . From these various memory units, processing unit(s) 612 retrieves instructions to execute and data to process in order to execute the processes of some implementations.
- Bus 608 also connects to input and output device interfaces 614 and 606 .
- Input device interface 614 enables the user to communicate information and select commands to the electronic system.
- Input devices used with input device interface 614 include, for example, alphanumeric keyboards and pointing devices (also called “cursor control devices”).
- Output device interfaces 606 enables, for example, the display of images generated by the electronic system 600 .
- Output devices used with output device interface 606 include, for example, printers and display devices, such as cathode ray tubes (CRT) or liquid crystal displays (LCD). Some implementations include devices such as a touchscreen that functions as both input and output devices.
- CTR cathode ray tubes
- LCD liquid crystal displays
- bus 608 also couples electronic system 600 to a network (not shown) through a network interface 616 .
- the computer can be a part of a network of computers (such as a local area network (“LAN”), a wide area network (“WAN”), or an Intranet, or a network of networks, such as the Internet. Any or all components of electronic system 600 can be used in conjunction with the subject disclosure.
- Some implementations include electronic components, such as microprocessors, storage and memory that store computer program instructions in a machine-readable or computer-readable medium (alternatively referred to as computer-readable storage media, machine-readable media, or machine-readable storage media).
- computer-readable media include RAM, ROM, read-only compact discs (CD-ROM), recordable compact discs (CD-R), rewritable compact discs (CD-RW), read-only digital versatile discs (e.g., DVD-ROM, dual-layer DVD-ROM), a variety of recordable/rewritable DVDs (e.g., DVD-RAM, DVD-RW, DVD+RW, etc.), flash memory (e.g., SD cards, mini-SD cards, micro-SD cards, etc.), magnetic and/or solid state hard drives, read-only and recordable Blu-Ray® discs, ultra density optical discs, any other optical or magnetic media, and floppy disks.
- CD-ROM compact discs
- CD-R recordable compact discs
- the computer-readable media can store a computer program that is executable by at least one processing unit and includes sets of instructions for performing various operations.
- Examples of computer programs or computer code include machine code, such as is produced by a compiler, and files including higher-level code that are executed by a computer, an electronic component, or a microprocessor using an interpreter.
- ASICs application specific integrated circuits
- FPGAs field programmable gate arrays
- integrated circuits execute instructions that are stored on the circuit itself.
- the terms “computer”, “server”, “processor”, and “memory” all refer to electronic or other technological devices. These terms exclude people or groups of people.
- display or displaying means displaying on an electronic device.
- computer readable medium and “computer readable media” are entirely restricted to tangible, physical objects that store information in a form that is readable by a computer. These terms exclude any wireless signals, wired download signals, and any other ephemeral signals.
- implementations of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- a computer can interact with a user by sending documents to and receiving documents from a device that is used
- Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components.
- the components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network.
- Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
- LAN local area network
- WAN wide area network
- inter-network e.g., the Internet
- peer-to-peer networks e.g., ad hoc peer-to-peer networks.
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
- a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device).
- client device e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device.
- Data generated at the client device e.g., a result of the user interaction
- the term website may include any aspect of a website, including one or more web pages, one or more servers used to host or store web related content, and the like. Accordingly, the term website may be used interchangeably with the terms web page and server.
- the predicate words “configured to”, “operable to”, and “programmed to” do not imply any particular tangible or intangible modification of a subject, but, rather, are intended to be used interchangeably.
- a processor configured to monitor and control an operation or a component may also mean the processor being programmed to monitor and control the operation or the processor being operable to monitor and control the operation.
- a processor configured to execute code can be construed as a processor programmed to execute code or operable to execute code.
- a phrase such as an “aspect” does not imply that such aspect is essential to the subject technology or that such aspect applies to all configurations of the subject technology.
- a disclosure relating to an aspect may apply to all configurations, or one or more configurations.
- An aspect may provide one or more examples.
- a phrase such as an aspect may refer to one or more aspects and vice versa.
- a phrase such as an “embodiment” does not imply that such embodiment is essential to the subject technology or that such embodiment applies to all configurations of the subject technology.
- a disclosure relating to an embodiment may apply to all embodiments, or one or more embodiments.
- An embodiment may provide one or more examples.
- a phrase such as an “embodiment” may refer to one or more embodiments and vice versa.
- a phrase such as a “configuration” does not imply that such configuration is essential to the subject technology or that such configuration applies to all configurations of the subject technology.
- a disclosure relating to a configuration may apply to all configurations, or one or more configurations.
- a configuration may provide one or more examples.
- a phrase such as a “configuration” may refer to one or more configurations and vice versa.
- example is used herein to mean “serving as an example or illustration.” Any aspect or design described herein as “example” is not necessarily to be construed as preferred or advantageous over other aspects or designs.
Abstract
Description
A D ={[b,3],[c,0],[d,1],[a,2]} (1)
Key c is added after key b, key d after key c, key a after key d, and so on. The array pointer at array position 2 ([d,1]) designates key c (at
Claims (20)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/024,592 US9250874B1 (en) | 2013-09-11 | 2013-09-11 | Sharing property descriptor information between object maps |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/024,592 US9250874B1 (en) | 2013-09-11 | 2013-09-11 | Sharing property descriptor information between object maps |
Publications (1)
Publication Number | Publication Date |
---|---|
US9250874B1 true US9250874B1 (en) | 2016-02-02 |
Family
ID=55174929
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/024,592 Active 2033-10-19 US9250874B1 (en) | 2013-09-11 | 2013-09-11 | Sharing property descriptor information between object maps |
Country Status (1)
Country | Link |
---|---|
US (1) | US9250874B1 (en) |
Cited By (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20160103666A1 (en) * | 2014-10-08 | 2016-04-14 | Korea Advanced Institute Of Science And Technology | Performance improvement method in instance hosting environment and service system therefor |
US20170090757A1 (en) * | 2015-09-24 | 2017-03-30 | Oracle International Corporation | Configurable memory layouts for software programs |
CN108597027A (en) * | 2018-04-09 | 2018-09-28 | 腾讯科技（上海）有限公司 | The access method and device of graph data |
US10127136B2 (en) | 2015-09-24 | 2018-11-13 | Oracle International Corporation | Identifying and visualizing suboptimal memory layouts in software programs |
US10217254B2 (en) | 2015-09-24 | 2019-02-26 | Oracle International Corporation | Graphical editing of memory layout rules for software programs |
Citations (16)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4445177A (en) * | 1981-05-22 | 1984-04-24 | Data General Corporation | Digital data processing system utilizing a unique arithmetic logic unit for handling uniquely identifiable addresses for operands and instructions |
US20060026506A1 (en) * | 2004-08-02 | 2006-02-02 | Microsoft Corporation | Test display module for testing application logic independent of specific user interface platforms |
US20060206876A1 (en) * | 2005-03-08 | 2006-09-14 | International Business Machines Corporation | Method and apparatus for a programming framework for pattern matching and transformation of intermediate language expression trees |
US20070061625A1 (en) * | 2005-09-15 | 2007-03-15 | Acosta Juan Jr | Automation structure for software verification testing |
US20070162259A1 (en) * | 2006-01-10 | 2007-07-12 | Garrett Tricia Y | Method for converting a log of user manipulations of a computer program into task documentation |
US20090228507A1 (en) * | 2006-11-20 | 2009-09-10 | Akash Jain | Creating data in a data store using a dynamic ontology |
US20100042929A1 (en) * | 2008-08-12 | 2010-02-18 | International Business Machines Corporation | Verification of software applications |
US20110055289A1 (en) * | 2009-09-03 | 2011-03-03 | Russel Ennis | Method and system for managing component objects used in a plurality of composite objects |
US20120054603A1 (en) * | 2010-08-30 | 2012-03-01 | Sap Ag | View model aspects of component objects |
US20120173998A1 (en) * | 2011-01-04 | 2012-07-05 | International Business Machines Corporation | Three-dimensional gui object stores in automation test tools |
US8244775B1 (en) * | 2008-05-13 | 2012-08-14 | Google Inc | Using map objects to access object properties in a dynamic object-oriented programming language |
US8392881B1 (en) * | 2008-05-13 | 2013-03-05 | Google Inc. | Supporting efficient access to object properties in a dynamic object-oriented programming language |
US20130263085A1 (en) * | 2012-04-02 | 2013-10-03 | The Mathworks, Inc. | Object property - value specification using pop-up graphical interfaces |
US20140053074A1 (en) * | 2012-08-17 | 2014-02-20 | Samsung Electronics Co., Ltd. | Method and apparatus for generating and utilizing a cloud service-based content shortcut object |
US20140143762A1 (en) * | 2012-11-21 | 2014-05-22 | Fujitsu Limited | Symbolic execution of dynamic programming languages |
US8904347B2 (en) * | 2005-09-15 | 2014-12-02 | Ca, Inc. | Apparatus, method and system for building software by composition |
-
2013
- 2013-09-11 US US14/024,592 patent/US9250874B1/en active Active
Patent Citations (17)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4445177A (en) * | 1981-05-22 | 1984-04-24 | Data General Corporation | Digital data processing system utilizing a unique arithmetic logic unit for handling uniquely identifiable addresses for operands and instructions |
US20060026506A1 (en) * | 2004-08-02 | 2006-02-02 | Microsoft Corporation | Test display module for testing application logic independent of specific user interface platforms |
US20060206876A1 (en) * | 2005-03-08 | 2006-09-14 | International Business Machines Corporation | Method and apparatus for a programming framework for pattern matching and transformation of intermediate language expression trees |
US20070061625A1 (en) * | 2005-09-15 | 2007-03-15 | Acosta Juan Jr | Automation structure for software verification testing |
US8904347B2 (en) * | 2005-09-15 | 2014-12-02 | Ca, Inc. | Apparatus, method and system for building software by composition |
US20070162259A1 (en) * | 2006-01-10 | 2007-07-12 | Garrett Tricia Y | Method for converting a log of user manipulations of a computer program into task documentation |
US20090228507A1 (en) * | 2006-11-20 | 2009-09-10 | Akash Jain | Creating data in a data store using a dynamic ontology |
US8244775B1 (en) * | 2008-05-13 | 2012-08-14 | Google Inc | Using map objects to access object properties in a dynamic object-oriented programming language |
US8392881B1 (en) * | 2008-05-13 | 2013-03-05 | Google Inc. | Supporting efficient access to object properties in a dynamic object-oriented programming language |
US8527950B2 (en) * | 2008-08-12 | 2013-09-03 | International Business Machines Corporation | Verification of software applications |
US20100042929A1 (en) * | 2008-08-12 | 2010-02-18 | International Business Machines Corporation | Verification of software applications |
US20110055289A1 (en) * | 2009-09-03 | 2011-03-03 | Russel Ennis | Method and system for managing component objects used in a plurality of composite objects |
US20120054603A1 (en) * | 2010-08-30 | 2012-03-01 | Sap Ag | View model aspects of component objects |
US20120173998A1 (en) * | 2011-01-04 | 2012-07-05 | International Business Machines Corporation | Three-dimensional gui object stores in automation test tools |
US20130263085A1 (en) * | 2012-04-02 | 2013-10-03 | The Mathworks, Inc. | Object property - value specification using pop-up graphical interfaces |
US20140053074A1 (en) * | 2012-08-17 | 2014-02-20 | Samsung Electronics Co., Ltd. | Method and apparatus for generating and utilizing a cloud service-based content shortcut object |
US20140143762A1 (en) * | 2012-11-21 | 2014-05-22 | Fujitsu Limited | Symbolic execution of dynamic programming languages |
Non-Patent Citations (8)
Title |
---|
G. C. Archer et al., "A new object-oriented finite element analysis program architecture", [Online], 1999, pp. 63-75, [Retrieved from Internet on Sep. 16, 2015], . * |
G. C. Archer et al., "A new object-oriented finite element analysis program architecture", [Online], 1999, pp. 63-75, [Retrieved from Internet on Sep. 16, 2015], <http://www.lmc.ep.usp.br/pesquisas/BEM/oop/fem003.pdf>. * |
Peter Lyngbaek et al., "An Approach to Object Sharing in Distributed Data base Systems", [Online], 1983, pp. 364-375, [Retrieved from Internet on Sep. 16, 2015], . * |
Peter Lyngbaek et al., "An Approach to Object Sharing in Distributed Data base Systems", [Online], 1983, pp. 364-375, [Retrieved from Internet on Sep. 16, 2015], <http://www.vldb.org/conf/1983/P364.PDF>. * |
Pieter Van Zyl et al, "Comparing the Performance of Object Databases and ORM Tools", [Online], 2006, pp. 1-11, [Retrieved from Internet on Sep. 16, 2015], . * |
Pieter Van Zyl et al, "Comparing the Performance of Object Databases and ORM Tools", [Online], 2006, pp. 1-11, [Retrieved from Internet on Sep. 16, 2015], <http://researchspace.csir.co.za/dspace/bitstream/10204/984/1/van%20zyl-2006.pdf>. * |
R. Bourret et al., "A Generic Load/Extract Utility for Data Transfer Between XML Documents and Relational Databases", [Online], IEEE 2000, pp. 1-10, [Retrieved from Internet on Sep. 16, 2015], . * |
R. Bourret et al., "A Generic Load/Extract Utility for Data Transfer Between XML Documents and Relational Databases", [Online], IEEE 2000, pp. 1-10, [Retrieved from Internet on Sep. 16, 2015], <https://www.dvs.tu-darmstadt.de/publications/pdf/xmldbms.pdf>. * |
Cited By (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20160103666A1 (en) * | 2014-10-08 | 2016-04-14 | Korea Advanced Institute Of Science And Technology | Performance improvement method in instance hosting environment and service system therefor |
US20170090757A1 (en) * | 2015-09-24 | 2017-03-30 | Oracle International Corporation | Configurable memory layouts for software programs |
US10127136B2 (en) | 2015-09-24 | 2018-11-13 | Oracle International Corporation | Identifying and visualizing suboptimal memory layouts in software programs |
US10217254B2 (en) | 2015-09-24 | 2019-02-26 | Oracle International Corporation | Graphical editing of memory layout rules for software programs |
US10489130B2 (en) * | 2015-09-24 | 2019-11-26 | Oracle International Corporation | Configurable memory layouts for software programs |
CN108597027A (en) * | 2018-04-09 | 2018-09-28 | 腾讯科技（上海）有限公司 | The access method and device of graph data |
CN108597027B (en) * | 2018-04-09 | 2022-04-15 | 腾讯科技（上海）有限公司 | Method and device for accessing graphic data |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10552069B2 (en) | Caching the topology of a distributed data storage system | |
US8332359B2 (en) | Extended system for accessing electronic documents with revision history in non-compatible repositories | |
JP4906292B2 (en) | Method, system, and computer-readable medium for merging data from multiple data sources for use in an electronic document | |
US9250874B1 (en) | Sharing property descriptor information between object maps | |
US10430281B2 (en) | Space efficient cascading point in time copying | |
US9335976B1 (en) | Tracking property representations in modified computational objects | |
US8732127B1 (en) | Method and system for managing versioned structured documents in a database | |
US9449063B2 (en) | Synchronization of form fields in a client-server environment | |
US20140297751A1 (en) | Sharing application objects among multiple tenants | |
US11188661B2 (en) | Semi-rule based high performance permission management | |
US8527480B1 (en) | Method and system for managing versioned structured documents in a database | |
KR20080081276A (en) | Disk-based cache | |
US8346869B2 (en) | Granular data synchronization for editing multiple data objects | |
US9529857B1 (en) | Disambiguation of place geometry | |
US9594798B2 (en) | File system with per-file selectable integrity | |
EP4060520A1 (en) | Bookmark conservation service | |
US20170364496A1 (en) | Visualization interface for information object system | |
US8341114B2 (en) | System for updating information stored on a remote device | |
US20130067338A1 (en) | Dynamic navigation region based on site usage | |
US8898122B1 (en) | Method and system for managing versioned structured documents in a database | |
US9002810B1 (en) | Method and system for managing versioned structured documents in a database | |
US9201797B1 (en) | Per-selector dispatch | |
US10733159B2 (en) | Maintaining immutable data and mutable metadata in a storage system | |
US11556504B2 (en) | File sharing service controller | |
US9645923B1 (en) | Generational garbage collector on multiple heaps |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:VERWAEST, TOON WIM JAN;CLIFFORD, DANIEL KENNETH;SIGNING DATES FROM 20130910 TO 20130913;REEL/FRAME:031272/0697 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044566/0657Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 8TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1552); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 8 |