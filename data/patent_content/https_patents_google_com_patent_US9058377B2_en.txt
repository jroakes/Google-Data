US9058377B2 - Fixed width encoding document posting lists - Google Patents
Fixed width encoding document posting lists Download PDFInfo
- Publication number
- US9058377B2 US9058377B2 US13/153,264 US201113153264A US9058377B2 US 9058377 B2 US9058377 B2 US 9058377B2 US 201113153264 A US201113153264 A US 201113153264A US 9058377 B2 US9058377 B2 US 9058377B2
- Authority
- US
- United States
- Prior art keywords
- deltas
- bytes
- sequence
- delta
- total number
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active, expires
Links
Images
Classifications
-
- G06F17/30657—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/30—Information retrieval; Database structures therefor; File system structures therefor of unstructured textual data
- G06F16/33—Querying
- G06F16/3331—Query processing
Definitions
- the technical field relates to methods and apparatuses for encoding posting lists stored in search engine indices.
- a search engine is typically utilized by a user to locate desired pieces of information. For example, a user may perform a keyword search where the user inputs one or more keywords to a search engine, which returns back to the user a search result set containing documents that include at least one or all of the inputted keywords.
- a search engine must also satisfy the expectation of the user to receive and explore the search results quickly.
- search results are encoded for the purposes of speed and saving memory space.
- search engines have faced a common problem in dealing with a tradeoff between time and space when implementing an encoding scheme. On one hand, a simplified encoding scheme usually allows a quicker decoding process, but requires more memory space. On the other hand, a more complex encoding scheme typically has a slower decoding process but consumes less memory space.
- Implementations of the subject matter described in this specification may include an apparatus comprising: a server obtaining a sequential list of one or more of document identification numbers, each of the document identification numbers uniquely identifying a document; and an encoding device operatively connected to said server, said encoding device generating a sequence of deltas from the sequential list of one or more of the document identification numbers, for each delta in the sequence of deltas, determining if the each delta is greater than or equal to a first maximum value of a first predetermined byte number, and for each of the deltas greater than or equal to the first maximum value, recalculating, the deltas as one or more multiples of the first maximum value and a remainder value, said encoding device determining a first total number of bytes for encoding the sequence of deltas based on the first predetermined byte number.
- the encoding device determines if the each delta is greater than or equal to a second maximum value of a second predetermined byte number, and for each of the deltas greater than or equal to the second maximum value, recalculates, the deltas as one or more multiples of the second maximum value and a remainder value, said encoding device determining a second total number of bytes for encoding the sequence of deltas based on the second predetermine byte number.
- the encoding device compares the first total number of bytes and the second total number of bytes, and encodes the sequence of deltas using a first predetermined byte number if the first total number of bytes is smaller than the second total number of bytes and encodes the sequence of deltas using the second predetermined byte number if the first total number of bytes is greater than or equal to the second total number of bytes.
- said server receives a search request and one or more keywords, said server obtaining the sequential list of one or more of the document identification numbers based on the received search request and one or more keywords.
- the first predetermined byte number is 1 and the second predetermined byte number is 2.
- implementations of the subject matter described in this specification may include a computer-implemented method for encoding, comprising: obtaining a sequential list of one or more of the document identification numbers; generating a sequence of deltas based on the sequential list of one or more of the document identification numbers; for each delta in the sequence of deltas, determining if the each delta is greater than or equal to a first maximum value of a first predetermined byte number, and for each of the deltas greater than or equal to the first maximum value, recalculating the deltas as one or more multiples of the first maximum value and a remainder value; and determining a first total number of bytes for encoding the sequence of deltas based on the first predetermined byte number.
- the method further comprising: for the each delta in the sequence of deltas, determining the each delta is greater than or equal to a second maximum value of a second predetermined byte number, for each of the deltas greater than or equal to the second maximum value, recalculating the deltas as one or more multiples of the second maximum value and a remainder value; and determining a second total number of bytes for encoding the sequence of deltas based on the second predetermined byte number.
- the method further comprising: comparing the first total number of bytes and the second total number of bytes; encoding the sequence of deltas using a first predetermined byte number if the first total number of bytes is smaller than the second total number of bytes; and encoding the sequence of deltas using the second predetermined byte number if the first total number of bytes is greater than or equal to the second total number of bytes.
- the method further comprising: receiving a search request and one or more keywords, and obtaining the sequential list of one or more of the document identification numbers based on the received search request and one or more keywords.
- the first predetermined byte number is 1 and the second predetermined byte number is 2.
- implementations of the subject matter described in this specification may include a computer-readable medium having computer-executable instructions, which, when executed by a computer having one or more processors, cause the computer to perform steps of: obtaining a sequential list of one or more of the document identification numbers; generating a sequence of deltas based on the sequential list of one or more of the document identification numbers; for each delta in the sequence of deltas, determining if the each delta is greater than or equal to a first maximum value of a first predetermined byte number, and for each of the deltas greater than or equal to the first maximum value, recalculating the deltas as one or more multiples of the first maximum value and a remainder value; and determining a first total number of bytes for encoding the sequence of deltas based on the first predetermined byte number.
- said computer-executable instructions which, when executed by the computer, cause the computer to perform additional step of: for the each delta in the sequence of deltas: determining if the each delta is greater than or equal to a second maximum value of a second predetermined byte number, for each of the deltas greater than or equal to the second maximum value, recalculating the deltas as one or more multiples of the second maximum value and a remainder value if the each delta is greater than or equal to the second maximum value; and determining a second total number of bytes for encoding the sequence of deltas based on the second predetermine byte number.
- said computer-executable instructions which, when executed by the computer, cause the computer to perform additional step of: comparing the first total number of bytes and the second total number of bytes; encoding the sequence of deltas using a first predetermined byte number if the first total number of bytes is smaller than the second total number of bytes; and encoding the sequence of deltas using the second predetermined byte number if the first total number of bytes is greater than or equal to the second total number of bytes.
- said computer-executable instructions which, when executed by the computer, cause the computer to perform additional step of: receiving a search request and one or more keywords, and obtaining the sequential list of one or more of the document identification numbers based on the received search request and one or more keywords.
- the first predetermined byte number is 1 and the second predetermined byte number is 2.
- implementations of the subject matter described in this specification may include an apparatus comprising: a memory storing an encoded list to be decoded; and a decoding device operatively connected to said memory, said decoding device receiving a document identification number; obtaining the encoded list to be decided; extracting from the encoded list a predetermined byte number used to encode each of sequential numbers in the encoded list; and calculating a sum of one or more of the sequential numbers in the encoded list, said calculated sum is not smaller than the document identification number.
- the sum is calculated by: reading out sequentially and adding the sequential numbers in the encoded list to the sum until the sum is not smaller than the document identification number.
- the sum is calculated by: when the sum is not smaller than the document identification number, determining if a last read-out sequential number in the encoded list is equal to a maximum value of the predetermined byte number, reading out and adding a next sequential number in the encoded list to the sum.
- implementations of the subject matter described in this specification may include a computer-implemented method for decoding, comprising: receiving a document identification number; obtaining the encoded list to be decided; extracting from the encoded list a predetermined byte number used to encode each of sequential numbers in the encoded list; and calculating a sum of one or more of the sequential numbers in the encoded list, said calculated sum is not smaller than the document identification number.
- the method further comprising: reading out sequentially and adding the sequential numbers in the encoded list to the sum until the sum is not smaller than the document identification number.
- the method further comprising: when the sum is not smaller than the document identification number, determining if a last read-out sequential number in the encoded list is equal to a maximum value of the predetermined byte number, reading out and adding a next sequential number in the encoded list to the sum.
- implementations of the subject matter described in this specification may include a computer-readable medium having computer-executable instructions, which, when executed by a computer having one or more processors, cause the computer to perform steps of: receiving a document identification number; obtaining the encoded list to be decided; extracting from the encoded list a predetermined byte number used to encode each of sequential numbers in the encoded list; and calculating a sum of one or more of the sequential numbers in the encoded list, said calculated sum is not smaller than the document identification number.
- said computer-executable instructions which, when executed by the computer, cause the computer to perform additional step of: reading out sequentially and adding the sequential numbers in the encoded list to the sum until the sum is not smaller than the document identification number.
- said computer-executable instructions which, when executed by the computer, cause the computer to perform additional step of: when the sum is not smaller than the document identification number, determining if a last read-out sequential number in the encoded list is equal to a maximum value of the predetermined byte number, reading out and adding a next sequential number in the encoded list to the sum.
- FIG. 1 is a block diagram illustrating an overall system for implementing fixed width encoding of a document posting list according to some embodiments
- FIG. 2 is a flow diagram illustrating a process for transmitting a search request and receiving a search result by a user terminal according to some embodiments
- FIG. 3 is flow diagram illustrating a process for receiving a search request and providing a search result by a server according to some embodiments.
- FIG. 4 is a flow diagram illustrating processes for an encoder according to some embodiments.
- FIG. 5 is a flow diagram illustrating processes for an encoding function according to some embodiments.
- FIG. 6 is a flow diagram illustrating processes for a decoder according to some embodiments.
- FIG. 7 is a block diagram illustrating an example computing device arranged for fixed width encoding according to some embodiments.
- the present disclosure provides an efficient fixed width encoding scheme for a sequence of numbers, such as a sequence of document identification numbers.
- a search engine assigns document identification numbers to uniquely identify documents that are available to be searched.
- a search engine builds an index, a sequence of document identification numbers is compiled as a posting list.
- the sequence of document identification numbers is encoded.
- the efficient encoding and decoding of posting lists may lead to significant performance gains for a search engine.
- efficient encoding and decoding require less resource consumption. As a result there may be less overhead cost for running a search engine.
- the decoder can be very efficient.
- the decoder may make use of a packed sum of absolute differences (“psadbw”) streaming SIMD extensions 2 (“SSE2”) instruction to decode up to 16 one-byte values in 2-5 cycles.
- psadbw packed sum of absolute differences
- SSE2 streaming SIMD extensions 2
- FIG. 1 is a block diagram illustrating an overall system 100 in which a user terminal device 101 transmits a search request to, and receives a search result from, a search engine server 102 via a network 103 , which may be the Internet, a cellular network, a wired network, wireless or other conventional network technology. It is to be understood that, in practice, there will be plural and likely a very large number of user terminal devices 101 (only one is shown). Also, the search engine server 102 may be a unitary device but would be preferably be implemented as a server farm or a distributed computing system in order to handle simultaneous connections with many user terminal devices 101 .
- the user terminal device 101 may include components such as one or more applications 104 , one or more browsers 105 , one or more processors (CPUs) 106 , and one or more memories 107 .
- Examples of the user terminal device 101 include such known devices as desktop computers, portable computers, mobile devices, tablets, etc.
- Conventional components such as displays, speakers, microphones, connectors, and input devices may also be included in the user terminal device 101 as is well known.
- the CPU and memory devices may be arranged as dedicated units each programmed with the functionalities described herein for the various functional units or may be hardware resources that are shared among multiple functional units.
- the hardware design choice for such arrangements is governed by routine engineering principles such as size, weight, cost, etc based on components available at the time of implementation.
- inventive techniques and aspects described herein, although shown in block diagram form, may be implemented using a combination of hardware, firmware and/or software as is known in the art.
- the search engine server 102 may include a search engine 108 , an encoder engine 109 , a decoder engine 110 , a document database 111 , an encoder database 112 , a decoder database 113 , one or more processors (CPUs) 114 , and one or more memory devices 115 .
- a search engine 108 may include a search engine 108 , an encoder engine 109 , a decoder engine 110 , a document database 111 , an encoder database 112 , a decoder database 113 , one or more processors (CPUs) 114 , and one or more memory devices 115 .
- the search engine 108 , the encoder engine 109 , the decoder engine 110 , the document database 111 , the encoder database 112 , and/or the decoder database 113 may be part of the search engine server 102 as illustrated, or independent components in communication with the search engine server 102 .
- the search engine 108 and the document database 111 may be implemented to generate a search result based on a received search request from the user terminal device 101 via the network 103 .
- the search engine 108 may receive a search query including one or more keywords from the user terminal device 101 , and perform a search using the document database 111 to generate a search result.
- the document database 111 may include any type of documents, such as web pages, electronic files, etc., each of which is identified by an unique document identification number (not shown).
- the encoder engine 109 and the encoder database 112 may be implemented to perform an encoding process according to some embodiments. For instance, while building the search index, the encoder engine 109 may receive a list of search results from the search engine 108 , perform an encoding process to encode the list of document identification numbers of those search results, and store the encoded posting list in the encoder database 112 .
- the decoder engine 110 and the decoder database 113 may be implemented to perform a decoding process according to some embodiments.
- the decoder engine 110 may receive an encoded posting list from the search engine 109 , perform a decoding process to obtain the list of stored document identification numbers, and store that list in the decoder database 113 .
- the search engine 108 , the document database 111 , the encoder database 112 , and the decoder database 113 may be considered optional components.
- the search server 102 may receive a search result directly from other servers (not shown) to be encoded or decoded by the encoder engine 109 or the decoder engine 110 .
- the encoded or decoded search result may be transmitted to one or more of the other servers or the user terminal device 101 without storing the encoded/decoded search result in the encoder database 112 or the decoder database 113 .
- FIG. 2 illustrates a flow diagram for a process 200 of performing a search and receiving a search result by a user terminal according to some embodiments.
- the process 200 may be implemented by the application 104 or the browser 105 in FIG. 1 .
- a user invokes an application 104 installed on the user terminal 101 or launches a browser 105 to perform a search.
- the user may use an input device (not shown) on the user terminal 101 to input one or more keywords to the application 104 or the browser 105 .
- the user terminal 101 generates a search query based on the inputted one or more keywords.
- the generated search query is transmitted to a search engine server 102 via the network 103 at step 206 .
- the user terminal 101 receives, as a search result, a list of documents. Also, the list of documents is displayed on the user terminal 101 . In some embodiments, the list of documents is displayed using by the application 104 or the browser 105 . The specifics of how the list of documents is displayed are outside the primary scope of concepts of the present invention, and thus, will not be discussed further in detail.
- FIG. 3 illustrates a flow diagram for an exemplary process 300 of receiving a search query and providing a search result by the search engine server 102 .
- the search engine server 102 receives from a user terminal device 101 a search query containing one or more keywords.
- the search engine 108 generates, as a search result, a list of document identification numbers, using the received search query. Each of the document identification numbers uniquely identifies a document responsive to the search query.
- the search engine 108 generates the search result by performing a search in the document database 111 to obtain the list of document identification numbers. In such embodiments, the document identification numbers are previously assigned to documents stored in the document database 111 . While the process to generate the search result is described as being performed by the search engine 108 , in some embodiments, the process may be performed by other server(s) (not shown) in communication with the search engine server 102 .
- the list of document identification numbers (search result) is encoded by the encoding engine 109 , which will be explained in detail below.
- the encoded list of document identification numbers is stored in the encoder database 112 at step 308 .
- the search engine server 102 transmits the search result to the user terminal device 101 via the network 103 .
- step 304 The specifics of the process to generate a search result (step 304 ) and to transmit the search to the user terminal device 101 (step 308 ) are outside the primary scope of concepts of the present invention, and thus, will not be discussed further in detail.
- FIG. 4 illustrates a flow diagram for an exemplary process 400 for implementing the encoding at step 306 in FIG. 3 .
- the encoder engine 109 implements the process 400 utilizing the encoder database 112 .
- the encoder engine 109 receives a list of document identification numbers (a posting list) from the search engine 108 or other servers (not shown) in communication with the search engine server 102 .
- the encoder engine 109 converts the received list of document identification numbers into a sequence of deltas. Specifically, each document identification number on the list is replaced with the difference from the previous document identification number on the list. For example, supposed that the encoder engine 109 receives a list of document identification numbers (0, 20, 100, 500, 600, 1000, 1010, 1500). The encoder engine 109 converts that list into a sequence of deltas (0, 20, 80, 400, 100, 400, 10, 490). By converting the list into a sequence of deltas, the magnitudes of the numbers become smaller and require less memory space.
- one way to encode it is to determine how many bytes are needed to encode each delta individually. For example, a value under 256 can be encoded in one byte, and a value between 256 and 65535 can be encoded in two bytes, and so on.
- Such an encoding scheme is based on a variable length encoding scheme. While each delta uses only as many bytes as is strictly required and no bytes are wasted, because each delta has a variable number of bytes, an indicator needs to be stored for each delta to indicate the number of bytes used.
- variable length encoding scheme which may encode the sequence of deltas as the following:
- each pair of numbers has a first number indicating the number of bytes used and a second number as the delta.
- a variable length encoding scheme requires many instructions to decode since the number of bytes used needs to be looked up first, and only then can a delta be decoded.
- utilizing a fixed width encoding scheme which will be described in detail below, provides better decoding efficiency.
- the deltas of a typical posting list may have a predictable distribution. For example, if a common word like “the”, which occurs in almost all documents, is used as a keyword to generate the posting list, the deltas for the list will be very small (i.e., less than 256). However, for uncommon words like “antidisestablishmentarianism,” the deltas are usually very large. In other words, by analyzing the distribution of deltas for a list of document identification numbers, a fixed number of bytes can be predetermined for encoding all the deltas in the list of document identification numbers. As such, for a list of document identification numbers generated based on common words, the fixed number of bytes is predetermined to be small, such as one byte. For a list of document identification numbers generated based on uncommon words, the fixed number of bytes is predetermined to be higher, depending upon uncommonness of the word.
- a fixed byte number needs to be predetermined for the posting list to make sure the deltas in the posting list are properly encoded.
- One way would be to choose a number of bytes required to encode the maximum delta in the posting list.
- such approach would likely end up using more memory space than necessary since a single statistical outlier delta which is very large can cause all the other relatively small deltas to be encoded in a large number of bytes.
- an encoded posting list is often decoded in order to assess a particular element in the list.
- assessing a particular element involves a summation of all the deltas between a current position and the position of the particular element.
- any overflow deltas can be separated into multiple parts such that each of the parts can be encoded in the fixed number of bytes.
- the sum of the multiple parts is the overflow delta of the element. For example, if one byte is used as the fixed number of bytes, the maximum value is 255.
- a delta of 400 which is greater than 255, can be separated into 255 and 145. As a result, each of 255 and 145 can be encoded in one byte.
- a fixed encoding according to some embodiments is described in reference to steps 406 to 422 .
- Width represents a byte number used and “MaximumWidth” represents a maximum byte number utilized for the encoding process 400 .
- Width represents a byte number used
- MaximumWidth represents a maximum byte number utilized for the encoding process 400 .
- Width represents a byte number used
- Width represents a maximum byte number utilized for the encoding process 400 .
- Width represents a byte number used
- MaximumWidth represents a maximum byte number utilized for the encoding process 400 .
- MinimumSize represents the minimal number of bytes used to encode a sequence of deltas.
- Width is set to one
- MaximumWidth is set to four
- MinimumSize is set to infinity.
- each of Width and MaximumWidth may be set to any number greater than or equal to one
- MaximumWidth is greater than or equal to Width.
- the process 400 performs 1-byte (Width), 2-byte, 3-byte and 4-byte (MaximumWidth) encoding and determines which encoding uses the minimal number of bytes (MinimumSize) to encode the sequence of deltas.
- Sequence represents the sequence of deltas received
- Buffer represents an output buffer for an encoding function (which will be discussed below)
- TotalSize represents the total number of bytes used to encode the sequence of deltas for each encoding
- Index is a tracked positional number for the sequence of deltas.
- Sequence is set to equal to the sequence of deltas received
- Buffer is set to equal to an output buffer of the encoding function
- TotalSize and Index are set to zero.
- step 410 it is determined whether the tracked positional number (Index) is smaller than the length of the sequence of deltas (length(Sequence)). If Index is smaller than length(Sequence), steps 412 and 414 are performed. If Index is not smaller than length(Sequence), which means there is no more element in the Sequence to be encoded, steps 416 , 418 , 420 , 422 , and 424 are performed.
- an encoding function EncodeInteger (Buffer, Sequence[Index], Width)] is applied to determine a number of bytes (NumberBytes) used to encode the Index-th element in the sequence (Sequence[Index]) at step 412 .
- the encoding function is described in detail in FIG. 5 below.
- SequenceValue which equals to the value of the Index-th element in the sequence (Sequence[Index]), is compared with the determined MaximumEntry. If SequenceValue is greater than or equal to the MaximumEntry, the function EmitEntry(Buffer, Width, MaximumEntry) is performed to take the value of MaximumEntry and write to Buffer up to the Width bytes from the integer representation of MaximumEntry at step 506 . If SequenceValue is greater than or equal to the MaximumEntry, it is determined that SequenceValue is an overflowed value with respect to the MaximumEntry. In other words, SequenceValue is too large to be stored in the byte number, Width.
- SequenceValue is updated by subtracting MaximumEntry from SequenceValue, and the output buffer (Buffer) is updated by adding Width to Buffer.
- the process then proceeds back to step 504 to determine whether the updated SequenceValue is greater than or equal to MaximumEntry. If the updated SequenceValue is again greater than or equal to MaximumEntry, steps 506 and 508 are again performed.
- the overflowed SequenceValue are “split” into smaller parts such that each of the smaller parts is able to fit into the byte number, Width. In other words, the overflowed SequenceValue is encoded as multiple(s) of the value of MaximumEntry and a remainder value.
- SequenceValue is neither greater than nor equal to the MaximumEntry
- the process proceeds to 510 to perform the function EmitEntry(Buffer, Width, SequenceValue) to take the value of SequenceValue and write to Buffer up to the byte number Width from the integer representation of SequenceValue. If SequenceValue is neither greater than nor equal to the MaximumEntry, then SequenceValue is able to be encoded in the byte number (Width). As a result, the encoding for the Index-th element is completed.
- a return function subtracts the original output buffer (OriginalBuffer) from the output buffer (Buffer) to return, as an output of the encoding function, the number of bytes used to encode the Index-th element.
- the TotalSize is updated by adding the TotalSize and the determined NumberBytes at step 414 , and Index is incremented by one.
- the process proceeds back to step 410 to determine whether there is a next element in the sequence by comparing Index with the length of the Sequence. As a result, steps 412 and 414 are performed for every delta in the sequence.
- the process proceeds to step 416 to determine whether the total number of bytes used to encode the sequence of deltas (TotalSize) is smaller than the minimal number of bytes used to encode the sequence of deltas (MinimumSize) thus far. If TotalSize is smaller than MinimumSize, then TotalSize now represents the minimal number of bytes used to encode the sequence of deltas. As such, MinimumSize is set equal to the TotalSize at step 418 . At step 420 , Width is incremented by one.
- MinimumSize By comparing TotalSize determined for each encoding (1-byte, 2-byte, and so on) with the MinimumSize, and setting MinimumSize to equal to TotalSize when TotalSize is smaller than MinimumSize, the final value for MinimumSize would be associated with the encoding using the minimum size of bytes.
- Width is smaller than MaxiumumWidth. If the Width is smaller than the Max_byte, the process goes back to step 408 to repeat steps 408 to 422 for the next encoding using the updated Width.
- step 424 the process proceeds to step 424 to output the encoding associated with the minimal number of bytes used (MinimumSize).
- FIG. 6 illustrates a flow diagram for an exemplary process 600 for decoding an encoded posting list.
- the decoder engine 110 implements the process 600 utilizing the decoder database 113 .
- an encoded posting list is often decoded in order to assess a particular element in the list.
- assessing a particular element is basically adding up all the deltas in between a current position and the position of the particular element.
- the decoder engine 110 receives bytes containing an encoded posting list and an integer to be decoded from the search engine 108 or other servers (not shown).
- BytesEncoded is set to equal the bytes containing the encoded posting list and Integer is set to equal to the integer to be decoded.
- the byte number used to encode each element in a posting list is known, there is no need to look up the byte number for each element in the posting list in a decoding process. Instead, the byte number is stored in the first byte of the bytes (BytesEncoded) containing the encoded posting list.
- CurrentValue is provided and initialized to zero.
- CurrentValue represents a sum of the decoded deltas.
- Step 610 it is determined whether the sum of the decoded deltas (CurrentValue) is smaller than the integer to be decoded (Integer). If CurrentValue is smaller than the integer to be decoded, a function, ReadInteger(BytesEncoded, Width), is performed to read out the next delta (or Width bytes as integer representation) and assign the readout delta to LastValue at step 612 . CurrentValue is updated by adding the readout delta (LastValue) to the CurrentValue. Also, the bytes containing the encoded posting list (BytesEncoded) is advanced to a next delta by incrementing the bytes containing the encoded posting list (BytesEncoded) by Width.
- step 614 it is determined whether the readout delta (LastValue) is equal to the maximum number (MaximumEntry) at step 614 . If the readout delta is equal to the maximum number, the process proceeds to step 616 , which performs the same as at step 612 . Specifically, the function, ReadInteger(BytesEncoded, Width), is performed to read out the next encoded delta and assign the readout delta to LastValue. CurrentValue is updated by adding the readout delta (LastValue) to CurrentValue. Also, the bytes containing the encoded posting list (BytesEncoded) is advanced to a next delta by incrementing the bytes containing the encoded posting list (BytesEncoded) by Width.
- step 618 If the readout delta is not equal to the maximum number, the process proceeds to step 618 to return as an output the sum of the decoded deltas (CurrentValue).
- FIG. 7 is a block diagram illustrating an example computing device 700 that is arranged for fixed width encoding/decoding in accordance with the present disclosure.
- computing device 700 typically includes one or more processors 710 and system memory 720 .
- a memory bus 730 can be used for communicating between the processor 710 and the system memory 720 .
- processor 710 can be of any type including but not limited to a microprocessor ( ⁇ P), a microcontroller ( ⁇ C), a digital signal processor (DSP), or any combination thereof.
- Processor 710 can include one more levels of caching, such as a level one cache 711 and a level two cache 712 , a processor core 713 , and registers 714 .
- the processor core 713 can include an arithmetic logic unit (ALU), a floating point unit (FPU), a digital signal processing core (DSP Core), or any combination thereof.
- a memory controller 715 can also be used with the processor 710 , or in some implementations the memory controller 715 can be an internal part of the processor 710 .
- system memory 720 can be of any type including but not limited to volatile memory (such as RAM), non-volatile memory (such as ROM, flash memory, etc.) or any combination thereof.
- System memory 720 typically includes an operating system 721 , one or more applications 722 , and program data 724 .
- Application 722 includes encoding/decoding algorithm 723 that is arranged to perform a fixed width encoding/decoding.
- Program Data 724 includes encoding/decoding data 725 that is useful for performing a fixed width encoding/decoding, as will be further described below.
- application 722 can be arranged to operate with program data 724 on an operating system 721 such that a fixed width encoding/decoding is performed. This described basic configuration is illustrated in FIG. 7 by those components within dashed line 701 .
- Computing device 700 can have additional features or functionality, and additional interfaces to facilitate communications between the basic configuration 701 and any required devices and interfaces.
- a bus/interface controller 740 can be used to facilitate communications between the basic configuration 701 and one or more data storage devices 750 via a storage interface bus 741 .
- the data storage devices 750 can be removable storage devices 751 , non-removable storage devices 752 , or a combination thereof.
- Examples of removable storage and non-removable storage devices include magnetic disk devices such as flexible disk drives and hard-disk drives (HDD), optical disk drives such as compact disk (CD) drives or digital versatile disk (DVD) drives, solid state drives (SSD), and tape drives to name a few.
- Example computer storage media can include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data.
- Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device 700 . Any such computer storage media can be part of device 700 .
- Computing device 700 can also include an interface bus 742 for facilitating communication from various interface devices (e.g., output interfaces, peripheral interfaces, and communication interfaces) to the basic configuration 701 via the bus/interface controller 740 .
- Example output devices 760 include a graphics processing unit 761 and an audio processing unit 762 , which can be configured to communicate to various external devices such as a display or speakers via one or more A/V ports 763 .
- Example peripheral interfaces 770 include a serial interface controller 771 or a parallel interface controller 772 , which can be configured to communicate with external devices such as input devices (e.g., keyboard, mouse, pen, voice input device, touch input device, etc.) or other peripheral devices (e.g., printer, scanner, etc.) via one or more I/O ports 773 .
- An example communication device 780 includes a network controller 781 , which can be arranged to facilitate communications with one or more other computing devices 790 over a network communication via one or more communication ports 782 .
- the communication connection is one example of a communication media.
- Communication media may typically be embodied by computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media.
- a “modulated data signal” can be a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.
- communication media can include wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, radio frequency (RF), infrared (IR) and other wireless media.
- RF radio frequency
- IR infrared
- the term computer readable media as used herein can include both storage media and communication media.
- Computing device 700 can be implemented as a portion of a small-form factor portable (or mobile) electronic device such as a cell phone, a personal data assistant (PDA), a personal media player device, a wireless web-watch device, a personal headset device, an application specific device, or a hybrid device that include any of the above functions.
- a small-form factor portable (or mobile) electronic device such as a cell phone, a personal data assistant (PDA), a personal media player device, a wireless web-watch device, a personal headset device, an application specific device, or a hybrid device that include any of the above functions.
- PDA personal data assistant
- Computing device 700 can also be implemented as a personal computer including both laptop computer and non-laptop computer configurations.
- the implementer may opt for a mainly hardware and/or firmware vehicle; if flexibility is paramount, the implementer may opt for a mainly software implementation; or, yet again alternatively, the implementer may opt for some combination of hardware, software, and/or firmware.
- a signal bearing medium examples include, but are not limited to, the following: a recordable type medium such as a floppy disk, a hard disk drive, a Compact Disc (CD), a Digital Video Disk (DVD), a digital tape, a computer memory, etc.; and a transmission type medium such as a digital and/or an analog communication medium (e.g., a fiber optic cable, a waveguide, a wired communications link, a wireless communication link, etc.).
- a typical data processing system generally includes one or more of a system unit housing, a video display device, a memory such as volatile and non-volatile memory, processors such as microprocessors and digital signal processors, computational entities such as operating systems, drivers, graphical user interfaces, and applications programs, one or more interaction devices, such as a touch pad or screen, and/or control systems including feedback loops and control motors (e.g., feedback for sensing position and/or velocity; control motors for moving and/or adjusting components and/or quantities).
- a typical data processing system may be implemented utilizing any suitable commercially available components, such as those typically found in data computing/communication and/or network computing/communication systems.
Abstract
Description
Claims (15)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/153,264 US9058377B2 (en) | 2011-06-03 | 2011-06-03 | Fixed width encoding document posting lists |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/153,264 US9058377B2 (en) | 2011-06-03 | 2011-06-03 | Fixed width encoding document posting lists |
Publications (2)
Publication Number | Publication Date |
---|---|
US20140067862A1 US20140067862A1 (en) | 2014-03-06 |
US9058377B2 true US9058377B2 (en) | 2015-06-16 |
Family
ID=50188933
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/153,264 Active 2033-04-08 US9058377B2 (en) | 2011-06-03 | 2011-06-03 | Fixed width encoding document posting lists |
Country Status (1)
Country | Link |
---|---|
US (1) | US9058377B2 (en) |
Families Citing this family (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10460418B2 (en) * | 2017-02-10 | 2019-10-29 | Microsoft Technology Licensing, Llc | Buffer index format and compression |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20090248725A1 (en) * | 2008-03-27 | 2009-10-01 | International Business Machines Corporation | Compressability estimation of non-unique indexes in a database management system |
US20090313238A1 (en) * | 2008-06-13 | 2009-12-17 | Microsoft Corporation | Search index format optimizations |
US20120275374A1 (en) * | 2011-04-29 | 2012-11-01 | Lsi Corporation | Rate matching for wideband code division multiple access |
-
2011
- 2011-06-03 US US13/153,264 patent/US9058377B2/en active Active
Patent Citations (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20090248725A1 (en) * | 2008-03-27 | 2009-10-01 | International Business Machines Corporation | Compressability estimation of non-unique indexes in a database management system |
US20090313238A1 (en) * | 2008-06-13 | 2009-12-17 | Microsoft Corporation | Search index format optimizations |
US8166041B2 (en) * | 2008-06-13 | 2012-04-24 | Microsoft Corporation | Search index format optimizations |
US20120275374A1 (en) * | 2011-04-29 | 2012-11-01 | Lsi Corporation | Rate matching for wideband code division multiple access |
Also Published As
Publication number | Publication date |
---|---|
US20140067862A1 (en) | 2014-03-06 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN110520870B (en) | Flexible hardware for high throughput vector dequantization with dynamic vector length and codebook size | |
CN110879807B (en) | File format for quick and efficient access to data | |
CN110879854B (en) | Searching data using superset tree data structures | |
US11163734B2 (en) | Data processing method and system and client | |
CN108921552B (en) | Evidence verification method and device | |
US11018692B2 (en) | Floating point data set compression | |
CN111857550A (en) | Method, apparatus and computer readable medium for data deduplication | |
WO2015195726A1 (en) | Efficient storage of related sparse data in a search index | |
US9154157B2 (en) | Search unit to accelerate variable length compression/decompression | |
Isenko et al. | Where is my training bottleneck? hidden trade-offs in deep learning preprocessing pipelines | |
EP3846021B1 (en) | Data output method, data acquisition method, device, and electronic apparatus | |
CN114139693A (en) | Data processing method, medium, and electronic device for neural network model | |
US9058377B2 (en) | Fixed width encoding document posting lists | |
CN110852057A (en) | Method and device for calculating text similarity | |
US9564917B1 (en) | Instruction and logic for accelerated compressed data decoding | |
CN114065704A (en) | Data compression method, electronic device and computer program product | |
US20150378676A1 (en) | Idempotent representation of numbers in extensible languages | |
CN110990406A (en) | Fuzzy query method, device, equipment and medium | |
CN112101511A (en) | Sparse convolutional neural network | |
US11645323B2 (en) | Coarse-to-fine multimodal gallery search system with attention-based neural network models | |
Taylor | Optimizing applications for multi-core processors, using the Intel integrated performance primitives | |
CN112417131A (en) | Information recommendation method and device | |
US11966597B1 (en) | Multi-domain configurable data compressor/de-compressor | |
EP1700208B1 (en) | Apparatus and method to avoid floating point control instructions in floating point to integer conversion | |
US20240111439A1 (en) | Multi-domain configurable data compressor/de-compressor |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:DESHWAL, PRIYENDRA;PETROVIC, SRDJAN;SHANKAR, ASIM;REEL/FRAME:026395/0292Effective date: 20110603 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044334/0466Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 8TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1552); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 8 |