VERWEISREFERENCE
Unter Schutz gestellt werden und Gegenstand des Gebrauchsmusters sind dabei, entsprechend den Vorschriften des Gebrauchsmustergesetzes, lediglich Vorrichtungen wie in den beigefügten Schutzansprüchen definiert, jedoch keine Verfahren. Soweit nachfolgend in der Beschreibung gegebenenfalls auf Verfahren Bezug genommen wird, dienen diese Bezugnahmen lediglich der beispielhaften Erläuterung der in den beigefügten Schutzansprüchen unter Schutz gestellten Vorrichtung oder Vorrichtungen.Be provided under protection and subject of the utility model are, according to the provisions of the utility model law, only devices as defined in the appended claims, but no method. Wherever in the description, if appropriate, reference is made to methods, these references are merely illustrative of the device or devices set forth in the appended claims.
HINTERGRUNDBACKGROUND
Ein Datenzentrum oder ein System von vernetzten Datenzentren kann zur Speicherung großer Datenmengen verschiedene Systeme zur Datenspeicherung verwenden. Die Daten dürfen Kunden und/oder internen Systemen über eine Schnittstelle zugänglich gemacht werden, die Anfragen von einer Datenbankabfragesprache entgegennimmt, wie z. B. Structured Query Language (strukturierte Abfragesprache-„SQL”). Um auf die Daten zuzugreifen, können der Kunde und/oder interne Systeme der Schnittstelle, die sich auf einem Zwischenserver befinden, eine SQL-Abfrage zur Verfügung stellen, die den Zugriff auf die Daten, die sich in der Datenspeicherung befinden, erleichtert. Eine typische SQL-Abfrage, die der Kunde an den Zwischenserver weitergeben kann ist eine SQL-Abfrage, die den JOIN-Vorgang enthält. Die SQL-Abfrage kann zusätzliche Klauseln enthalten, die die Weiterverarbeitung der Ergebnisse des Join-Vorgangs und anderer Klauseln, wie die „WHERE”-Klausel, „GROUP BY”-Klausel, „HAVING”-Klausel, „ORDERED BY”-Klausel und andere dieser Klauseln festlegen, wie durch den SQL-Standard beschrieben.A data center or a networked data center system can use a variety of data storage systems to store large amounts of data. The data may be made available to customers and / or internal systems via an interface that accepts requests from a database query language, such as: B. Structured Query Language (Structured Query Language "SQL"). To access the data, the client and / or internal systems of the interface located on an intermediate server may provide an SQL query that facilitates access to the data residing in the data storage. A typical SQL query that the customer can pass to the intermediate server is an SQL query that contains the JOIN operation. The SQL query may contain additional clauses that further process the results of the join operation and other clauses, such as the "WHERE" clause, the "GROUP BY" clause, the "HAVING" clause, the "ORDERED BY" clause, and so on specify other of these clauses as described by the SQL standard.
Die Datenspeicherung kann als Teil einer relationalen Datenbank organisiert werden. Insbesondere können die Daten einer relationalen Datenbank als Hierarchie organisiert werden. Angenommen, es gibt eine Menge von Datenbanktabellen A, B, C, und D, wobei A die übergeordnete oder die Wurzel der Hierarchie ist, B und D sind untergeordnete Datenbanktabellen von A, und C ist eine untergeordnete Datenbanktabelle von B. Insbesondere kann jeder Datensatz von B eine untergeordnete eines genauen Datensatzes von A, sein, wobei jeder Datensatz von C eine untergeordnete eines genauen Datensatzes von B, sein kann und jeder Datensatz von D kann eine untergeordnete einer genauen Zeile A. sein. Mit anderen Worten, kann man sich einen Datensatz, der der oben erwähnten Hierarchie entspricht, als eine Menge von hierarchischen Bäumen vorstellen, von denen jeder einen Datensatz von A an der Spitze enthält.Data storage can be organized as part of a relational database. In particular, the data of a relational database can be organized as a hierarchy. For example, suppose there are a lot of database tables A, B, C, and D, where A is the parent or root of the hierarchy, B and D are child tables of A, and C is a child database of B. In particular, each record B may be a child of an exact record of A, where each record of C may be a child of an exact record of B, and each record of D may be a child of an exact row A. In other words, a set of data corresponding to the above-mentioned hierarchy may be thought of as a set of hierarchical trees, each containing a record of A at the top.
Ein Kunden- und/oder internes System kann über einen Zwischenserver, wie oben erwähnt, auf diese hierarchische Datenstruktur zugreifen. Insbesondere kann der Kunde eine oder mehrere SQL-Operationen auf dieser hierarchischen Datenstruktur ausführen, wie eine SQL-Abfrage durchführen, die die „JOIN”-Operation enthält. Ein Beispiel für eine Abfrage, die der Kunde an den Zwischenserver weitergeben kann ist, „AUSWAHL * VON EINEM [LEFT OUTER]] JOIN B AN <Prädikate B> [LEFT OUTER] VERBINDUNG C AN <Prädikate C>,” wobei „[LEFT OUTER]” anzeigt, dass die Operation „LEFT OUTER” optional ist und <Prädikate X> weist eine Reihe von Booleschen Konjunktionen auf einer Tabelle X und allen vorhergehenden Tabellen in der JOIN-Operation auf (z. B. Tabellen A und B oder Tabellen A, B und C) ähnlich denen, die im SQL-Standard beschrieben sind. Die Abfrage kann auch eine „WHERE”-Klausel enthalten, wobei die Prädikate der „WHERE”-Klausel eine Folge von Booleschen Konjunktionen auf Tabelle A, Tabelle B und/oder Tabelle C sind. Genauer gesagt, weisen die Klammern um „LEFT OUTER” darauf hin, dass die Anweisung „LEFT OUTER” festgelegt werden, aber entfallen kann.A customer and / or internal system can access this hierarchical data structure via an intermediate server as mentioned above. In particular, the customer may execute one or more SQL operations on this hierarchical data structure, such as executing an SQL query containing the "JOIN" operation. An example of a query that the customer can pass to the intermediate server is "SELECTION * OF ONE [LEFT OUTER]] JOIN B AN <predicates B> [LEFT OUTER] CONNECTION C TO <predicates C>," where "[LEFT OUTER] "indicates that the operation" LEFT OUTER "is optional and <predicates X> has a series of Boolean conjunctions on a table X and all previous tables in the JOIN operation (eg, tables A and B or tables A, B and C) are similar to those described in the SQL standard. The query may also contain a "WHERE" clause, where the predicates of the "WHERE" clause are a sequence of Boolean conjunctions on Table A, Table B, and / or Table C. More specifically, the brackets around "LEFT OUTER" indicate that the instruction "LEFT OUTER" may be specified but may be omitted.
Wie aus der „JOIN”-Operation hervorgeht, z. B. „EIN JOIN B AUF <Prädikate B> JOIN C AUF <Prädikate C>” kombiniert mit einer „WHERE”-Klausel, „WHERE <Prädikate WHERE>,” erstellt alle Kombinationen von Datensätzen (Datensatz1, Datensatz2, Datensatz3), sodass Datensatz1 ein Datensatz von Tabelle A, ist, Datensatz2 ein Datensatz von Tabelle B und Datensatz3 ein Datensatz der Tabelle C und alle Booleschen Prädikate <Prädikate B>, <Prädikate C> und <Prädikate WHERE>, erfüllt sind. Wird dies für die Tabelle B festgelegt, erstellt die Operation „LEFT OUTER JOIN” eine Zeile für Tabelle A und Tabelle C, unabhängig davon, ob es Zeilen in Tabelle B gibt, die die „<Prädikate B>” erfüllen. Wie nach dem Stand der Technik bekannt, wenn für die Tabelle C angegeben, erzeugt die „LEFT OUTER JOIN”-Operation eine Zeile für Tabelle A und Tabelle B unabhängig davon, ob es Zeilen in Tabelle C gibt, die die „<Prädikate C>” erfüllen.As can be seen from the "JOIN" operation, e.g. For example, "ON JOIN B ON <predicates B> JOIN C ON <predicates C>" combined with a "WHERE" clause, "WHERE <predicates WHERE>," creates all combinations of records (record 1 , record 2 , record 3 ), so that record 1 is a record of table A, record 2 is a record of table B and record 3 is a record of table C and all boolean predicates <predicates B>, <predicates C> and <predicates WHERE>. If set to table B, the LEFT OUTER JOIN operation creates a row for both table A and table C, regardless of whether there are rows in table B that satisfy the "predicates B>". As known in the art, when indicated for Table C, the "LEFT OUTER JOIN" operation generates a row for Table A and Table B, regardless of whether there are rows in Table C that contain the "<predicates C>" fulfill.
Normalerweise kann ein Kunde und/oder ein internes System, das mit einer „JOIN”-Operation eine einzelne Abfrage erteilt, nicht die Ressourcen des Datenzentrums beeinträchtigen (z. B. verfügbarer Speicher, verfügbare Netzwerkbandbreite, verfügbare Lese-/Suchzeiten, verfügbare Verarbeitungszyklen usw.). Wenn jedoch ein Datenzentrum Tausende von Kunden bedient die selbst Tausende von Clients bedienen können, lösen sich die Ressourcen des Datenzentrums schnell auf, wenn Hunderte oder Tausende dieser JOIN-Abfragen empfangen und durchgeführt werden.Normally, a customer and / or an internal system issuing a single query with a "JOIN" operation may not affect the resources of the data center (eg, available memory, available network bandwidth, available read / seek times, available processing cycles, etc .). However, when a data center serves thousands of customers that can serve thousands of clients, the data center's resources quickly disintegrate when hundreds or thousands of these JOIN queries are received and executed.
KURZDARSTELLUNG SUMMARY
Um diese und andere Probleme zu lösen, sieht diese Offenbarung eine Vorrichtung zum Durchführen einer hierarchischen Verknüpfung auf einem hierarchisch geclusterten Datenstrom vor. In einem Aspekt kann die Vorrichtung einen Speicher enthalten, der so konfiguriert ist, dass er eine Abfragebedingung speichert die bestimmt, ob eine strukturierte Abfragesprache geeignet ist, um einen nicht-gepufferten Lesevorgang auf einem hierarchischen Datenspeicher und einem Prozessor, der mit dem Speicher in Verbindung steht durchzuführen, wobei der Prozessor so konfiguriert ist, dass er eine Abfrage der strukturierten Abfragesprache („SQL”) empfängt und die SQL-Abfrage für die Abfragebedingung auswertet. Der Prozessor kann auch so konfiguriert sein, dass er die SQL-Abfrage in eine Lesevorgangsabfrage für die hierarchische Datenspeicherung umwandelt. Weiterhin kann, wenn die SQL-Abfrage die Abfragebedingung erfüllt, der Prozessor so konfiguriert ist, dass er einen nicht-gepufferten Lesevorgang auf der hierarchischen Datenspeicherung, basierend auf der Lesevorgangsabfrage, durchführt, wobei der nicht-gepufferte Lesevorgang zu einem hierarchisch geclusterten Datenstrom führt und nach mindestens einem Prädikat der SQL-Abfrage auswertet, um eine Vielzahl von Datensatzergebnissen an eine Clientvorrichtung zu übertragen.To address these and other problems, this disclosure provides an apparatus for performing a hierarchical link on a hierarchically clustered data stream. In one aspect, the device may include a memory configured to store a query condition that determines whether a structured query language is appropriate for a non-buffered read on a hierarchical data store and a processor in communication with the store and the processor is configured to receive a Structured Query Language ("SQL") query and to evaluate the query condition SQL query. The processor may also be configured to convert the SQL query to a read transaction query for hierarchical data storage. Furthermore, if the SQL query satisfies the query condition, the processor is configured to perform an un-buffered read on the hierarchical data storage based on the read operation query, wherein the non-buffered read results in a hierarchically clustered data stream evaluates at least one predicate of the SQL query to transmit a plurality of record results to a client device.
In einem anderen Aspekt der Vorrichtung stellt die Abfragebedingung fest, dass die SQL-Abfrage zum Durchführen des nicht-gepufferten Lesevorgangs gültig ist, wenn eine Vielzahl der in der SQL-Abfrage identifizierten Tabellen, von oben nach unten hierarchisch sind.In another aspect of the device, the query condition determines that the SQL query is valid to perform the non-buffered read when a plurality of the tables identified in the SQL query are hierarchical from top to bottom.
In einem weiteren Aspekt der Vorrichtung ist der Prozessor so konfiguriert, um die SQL-Abfrage für die Abfragebedingung auszuwerten, indem ein Datenbankschema für die hierarchische Datenspeicherung ausgewertet wird.In another aspect of the apparatus, the processor is configured to evaluate the query condition SQL query by evaluating a hierarchical data storage database schema.
In einem noch anderen Aspekt der Vorrichtung legt die Abfragebedingung fest, dass die Vielzahl der in der SQL-Abfrage identifizierten Tabellen top-down hierarchisch ist, wenn jede Tabelle der Vielzahl von Tabellen nur ein ordnungsgemäßer Vorgänger oder ein ordnungsgemäßer Nachfolger einer anderen Tabelle in der Vielzahl von Tabellen ist.In yet another aspect of the apparatus, the query condition determines that the plurality of tables identified in the SQL query are top-down hierarchical if each table of the plurality of tables is just one proper predecessor or successor of another table in the plurality of tables.
In einem noch weiteren Aspekt der Vorrichtung ist die Abfragebedingung nicht erfüllt, wenn eine erste Tabelle einer Vielzahl von Tabellen eine hierarchische Beziehung zu einer zweiten Tabelle der Vielzahl von Tabellen aufweist, die nicht ordnungsgemäß ein Vorgänger oder Nachfolger ist.In yet another aspect of the apparatus, the query condition is not satisfied when a first table of a plurality of tables has a hierarchical relationship with a second table of the plurality of tables that is not properly a predecessor or successor.
In einem anderen Aspekt der Vorrichtung legt die Abfragebedingung fest, dass die SQL-Abfrage für das Durchführen des nicht-gepufferten Lesevorgangs gültig ist, wenn mindestens ein Prädikat der SQL-Abfrage spezifiziert dass, wenn ein Datensatz einer ersten Tabelle mit Datensätzen einer zweiten Tabelle verbunden werden soll, die Datensätze der zweiten Tabelle Nachfolger des Datensatzes der ersten Tabelle sind und der Datensatz der ersten Tabelle nicht mit den Datensätzen der zweiten Tabelle verknüpft ist, die ein Nachfolger des Datensatzes der ersten Tabelle sind.In another aspect of the device, the query condition determines that the SQL query is valid for performing the non-buffered read if at least one predicate of the SQL query specifies that when a record of a first table is associated with records of a second table The records of the second table are descendants of the record of the first table, and the record of the first table is not linked to the records of the second table, which are a descendant of the record of the first table.
In einem weiteren Aspekt der Vorrichtung ist der Prozessor so konfiguriert, dass er die SQL-Abfrage für die Abfragebedingung auswertet, indem bestätigt wird, dass ein Präfix eines Primärschlüsselwertes von mindestens einem Datensatz der Datensätze der zweiten Tabelle einen Primärschlüsselwert des Datensatzes der ersten Tabelle umfasstIn another aspect of the apparatus, the processor is configured to evaluate the query condition SQL query by verifying that a prefix of a primary key value of at least one record of the records of the second table comprises a primary key value of the record of the first table
In noch einem anderen Aspekt der Vorrichtung legt die Abfragebedingung fest, dass die SQL-Abfrage für das Durchführen des nicht-gepufferten Lesevorgangs gültig ist, wenn die SQL-Abfrage nur aus einem Operationstyp einer ersten Instanz eines Operationstyps besteht.In yet another aspect of the device, the query condition determines that the SQL query is valid for performing the non-buffered read if the SQL query consists of only one operation type of a first instance of an operation type.
In noch einem weiteren Aspekt der Vorrichtung umfasst der Operationstyp einen SQL-Operationstyp „LEFT OUTER JOIN”.In yet another aspect of the device, the operation type includes a SQL operation type "LEFT OUTER JOIN".
In einem weiteren Aspekt der Vorrichtung ist der Prozessor ferner konfiguriert, um die SQL-Abfrage für die Abfragebedingung auszuwerten, indem bestimmt wird, ob nach einer Instanz eines Operationstyps „LEFT OUTER JOIN” in der SQL-Abfrage keine anderen Variationen einer SQL-JOIN-Operation, anders als die Operation „LEFT OUTER JOIN”, auftreten.In another aspect of the apparatus, the processor is further configured to evaluate the query query SQL query by determining whether, after an instance of an operation type "LEFT OUTER JOIN" in the SQL query, no other variations of an SQL JOIN Operation, unlike the operation "LEFT OUTER JOIN" occur.
In einem weiteren Aspekt der Vorrichtung legt die Abfragebedingung fest, dass die SQL-Abfrage für das Durchführen des nicht-gepufferten Lesevorgangs gültig ist, dass, wenn eine erste Join-Bedingung an einer Vorgängertabelle nicht erfüllt ist, eine zweite Join-Bedingung an einer nachfolgenden Tabelle ebenfalls nicht erfüllt ist.In a further aspect of the device, the query condition determines that the SQL query is valid for performing the non-buffered read, that if a first join condition on a predecessor table is not met, a second join condition on a subsequent one Table is also not satisfied.
In noch einem anderen Aspekt der Vorrichtung ist der Prozessor konfiguriert, um die SQL-Abfrage für die Abfragebedingung auszuwerten, indem bestimmt wird, dass mindestens ein Prädikat eine Konjunktion der Form „X.A = Y.B” umfasst, wobei: X eine erste Tabelle, A eine erste Spalte der ersten Tabelle, Y eine zweite Tabelle und B eine zweite Spalte der zweiten Tabelle ist.In yet another aspect of the apparatus, the processor is configured to evaluate the SQL query for the query condition by determining that at least one predicate comprises a conjunction of the form "XA = YB", where: X is a first table, A is a first column of the first table, Y is a second table and B is a second column of the second table.
Diese Offenbarung sieht auch ein Verfahren zum Durchführen einer hierarchischen Verknüpfung auf einem hierarchisch geclusterten Datenstrom vor. Das Verfahren umfasst die Speicherung in einem computerlesbaren Speicher, eine Abfragebedingung, die bestimmt, ob eine SQL(Structured Query Language)-Abfrage zum Durchführen und empfangen eines nicht-gepufferten Lesevorgangs auf einem hierarchischen Datenspeicher, mit einem Prozessor in Verbindung mit dem computerlesbaren Speicher einer SQL(Structured Query Language)-Abfrage, geeignet ist. Das Verfahren kann auch das Bewerten der SQL-Abfrage für die Abfragebedingung und das Transformieren der SQL-Abfrage in eine Leseoperationsabfrage für die hierarchische Datenspeicherung umfassen, und wenn die SQL-Abfrage die Abfragebedingung erfüllt, einen nicht-gepufferten Lesevorgang an der hierarchischen Datenspeicherung, basierend auf der Lesevorgangsabfrage, durchführen, wobei der nicht-gepufferte Lesevorgang zu einem hierarchisch geclusterten Datenstrom führt und nach mindestens einem Prädikat der SQL-Abfrage auswertet, um eine Vielzahl von Datensatzergebnissen an eine Clientvorrichtung zu übertragen.This disclosure also provides a method of performing a hierarchical join on a hierarchically clustered data stream. The method includes storage in one computer-readable storage, a query condition that determines whether a SQL (Structured Query Language) query performs and receives a non-buffered read on a hierarchical data store, with a processor in conjunction with the computer-readable storage of a SQL (Structured Query Language) - Query, is appropriate. The method may also include evaluating the SQL query for the query condition and transforming the SQL query into a read operation query for the hierarchical data storage, and if the SQL query satisfies the query condition, a non-buffered read based on the hierarchical data storage on the read operation query, wherein the non-buffered read results in a hierarchically clustered data stream and evaluates for at least one predicate of the SQL query to transmit a plurality of record results to a client device.
In einem anderen Aspekt des Verfahrens stellt die Abfragebedingung fest, dass die SQL-Abfrage zum Durchführen des nicht-gepufferten Lesevorgangs gültig ist, wenn eine Vielzahl der in der SQL-Abfrage identifizierten Tabellen, von oben nach unten hierarchisch sind.In another aspect of the method, the query condition determines that the SQL query is valid to perform the non-buffered read when a plurality of the tables identified in the SQL query are hierarchical from top to bottom.
In einem weiteren Aspekt des Verfahrens umfasst die Auswertung der SQL-Abfrage für die Abfragebedingung, das Auswerten eines Datenbankschemas für die hierarchische Datenspeicherung.In another aspect of the method, the evaluation of the SQL query for the query condition includes evaluating a database schema for the hierarchical data storage.
In einem noch anderen Aspekt der Vorrichtung legt die Abfragebedingung fest, dass die Vielzahl der in der SQL-Abfrage identifizierten Tabellen top-down hierarchisch ist, wenn jede Tabelle der Vielzahl von Tabellen nur ein ordnungsgemäßer Vorgänger oder ein ordnungsgemäßer Nachfolger einer anderen Tabelle in der Vielzahl von Tabellen ist.In yet another aspect of the apparatus, the query condition determines that the plurality of tables identified in the SQL query are top-down hierarchical if each table of the plurality of tables is just one proper predecessor or successor of another table in the plurality of tables.
In einem noch weiteren Aspekt des Verfahrens ist die Abfragebedingung nicht erfüllt, wenn eine erste Tabelle einer Vielzahl von Tabellen mit einer hierarchischen Beziehung zu einer zweiten Tabelle der Vielzahl von Tabellen aufweist, die nicht ordnungsgemäß ein Vorgänger oder Nachfolger ist.In yet another aspect of the method, the query condition is not met when a first table of a plurality of tables having a hierarchical relationship with a second table has the plurality of tables that is not properly a predecessor or successor.
In einem anderen Aspekt des Verfahrens legt die Abfragebedingung fest, dass die SQL-Abfrage für das Durchführen des nicht-gepufferten Lesevorgangs gültig ist, wenn mindestens ein Prädikat der SQL-Abfrage spezifiziert dass, wenn ein Datensatz einer ersten Tabelle mit Datensätzen einer zweiten Tabelle verbunden werden soll, die Datensätze der zweiten Tabelle Nachfolger des Datensatzes der ersten Tabelle sind und der Datensatz der ersten Tabelle nicht mit den Datensätzen der zweiten Tabelle verknüpft ist, die ein Nachfolger des Datensatzes der ersten Tabelle sind.In another aspect of the method, the query condition determines that the SQL query is valid for performing the non-buffered read if at least one predicate of the SQL query specifies that when a record of a first table is associated with records of a second table The records of the second table are descendants of the record of the first table, and the record of the first table is not linked to the records of the second table, which are a descendant of the record of the first table.
In einem weiteren Aspekt des Verfahrens umfasst das Auswerten der SQL-Abfrage für die Abfragebedingung die Bestätigung, dass ein Präfix eines Primärschlüsselwertes von mindestens einem Datensatz der Datensätze der zweiten Tabelle einen Primärschlüsselwert des Datensatzes der ersten Tabelle umfasst.In another aspect of the method, evaluating the SQL query for the query condition comprises confirming that a prefix of a primary key value of at least one record of the records of the second table comprises a primary key value of the record of the first table.
In noch einem anderen Aspekt des Verfahrens legt die Abfragebedingung fest, dass die SQL-Abfrage für das Durchführen des nicht-gepufferten Lesevorgangs gültig ist, wenn die SQL-Abfrage nur aus einem Operationstyp einer ersten Instanz eines Operationstyps besteht.In yet another aspect of the method, the query condition determines that the SQL query is valid for performing the non-buffered read if the SQL query consists of only an operation type of a first instance of an operation type.
In noch einem weiteren Aspekt des Verfahrens umfasst der Operationstyp einen SQL-Operationstyp „LEFT OUTER JOIN”.In yet another aspect of the method, the operation type includes a SQL operation type "LEFT OUTER JOIN".
In einem anderen Aspekt des Verfahrens, umfasst das Auswerten der SQL-Abfrage für die Abfragebedingung die Bestimmung, ob nach einer Instanz eines Operationstyps „LEFT OUTER JOIN” in der SQL-Abfrage keine anderen Variationen einer SQL-JOIN-Operation, anders als die Operation „LEFT OUTER JOIN”, auftreten.In another aspect of the method, evaluating the SQL query for the query condition involves determining whether after an instance of an operation type "LEFT OUTER JOIN" in the SQL query, there are no other variations of a SQL JOIN operation other than the operation "LEFT OUTER JOIN" occur.
In einem weiteren Aspekt des Verfahrens legt die Abfragebedingung fest, dass die SQL-Abfrage für das Durchführen des nicht-gepufferten Lesevorgangs gültig ist, wenn eine erste Join-Bedingung an einer Vorgängertabelle nicht erfüllt ist, eine zweite Join-Bedingung an einer nachfolgenden Tabelle ebenfalls nicht erfüllt ist.In another aspect of the method, the query condition determines that the SQL query is valid for performing the non-buffered read, if a first join condition on a predecessor table is not met, a second join condition on a subsequent table, too is not fulfilled.
In noch einem anderen Aspekt des Verfahrens ist der Prozessor konfiguriert, um die SQL-Abfrage für die Abfragebedingung auszuwerten, indem bestimmt wird, dass mindestens ein Prädikat eine Konjunktion der Form „X.A = Y.B,” umfasst, wobei: X eine erste Tabelle, A eine erste Spalte der ersten Tabelle, Y eine zweite Tabelle und B eine zweite Spalte der zweiten Tabelle ist.In yet another aspect of the method, the processor is configured to evaluate the SQL query for the query condition by determining that at least one predicate comprises a conjunction of the form "XA = YB," where: X is a first table, A a first column of the first table, Y is a second table, and B is a second column of the second table.
Diese Offenbarung sieht ferner ein computer-lesbares Medium mit gespeicherten computerlesbaren Anweisungen vor, die, wenn sie von einem Prozessor ausgeführt werden einen Prozessor dazu veranlassen, ein Verfahren durchzuführen, wobei das Verfahren das Speichern eine Abfragebedingung in einem computerlesbaren Speicher umfasst, die festlegt, ob eine SQL(Structured Query Language)-Abfrage zum Durchführen und empfangen eines nicht-gepufferten Lesevorgangs auf einem hierarchischen Datenspeicher, mit einem Prozessor in Verbindung mit dem computerlesbaren Speicher einer SQL(Structured Query Language)-Abfrage, geeignet ist. Das Verfahren kann auch das Auswerten der SQL-Abfrage für die Abfragebedingung und das Transformieren der SQL-Abfrage in eine Leseoperationsabfrage für die hierarchische Datenspeicherung umfassen und, wenn die SQL-Abfrage die Abfragebedingung erfüllt, einen nicht-gepufferten Lesevorgang an der hierarchischen Datenspeicherung, basierend auf der Lesevorgangsabfrage, durchführen, wobei der nicht-gepufferte Lesevorgang zu einem hierarchisch geclusterten Datenstrom führt. Das Verfahren kann auch das Auswerten des hierarchisch geclusterten Datenstroms, nach mindestens einem Prädikat der SQL-Abfrage umfassen, um eine Vielzahl von Datensatzergebnisse zu erhalten und diese Vielzahl von Datensatzergebnisse an eine Client-Vorrichtung zu übermitteln.This disclosure further provides a computer readable medium having stored computer readable instructions that, when executed by a processor, cause a processor to perform a method, the method comprising storing a query condition in computer readable memory that determines whether a Structured Query Language (SQL) query for performing and receiving a non-buffered read on a hierarchical data store that is compatible with a processor in conjunction with the computer-readable memory of a Structured Query Language (SQL) query. The method can also evaluate the SQL query for the query condition and transform the SQL query into one If the SQL query satisfies the query condition, it performs a non-buffered read on the hierarchical data store based on the read task query, the non-buffered read resulting in a hierarchically clustered data stream. The method may also include evaluating the hierarchically clustered data stream for at least one predicate of the SQL query to obtain a plurality of record results and transmitting that plurality of record results to a client device.
In einem anderen Aspekt des computerlesbaren Mediums stellt die Abfragebedingung fest, dass die SQL-Abfrage zum Durchführen des nicht-gepufferten Lesevorgangs gültig ist, wenn eine Vielzahl der in der SQL-Abfrage identifizierten Tabellen, von oben nach unten hierarchisch sind.In another aspect of the computer-readable medium, the query condition determines that the SQL query is valid to perform the non-buffered read when a plurality of the tables identified in the SQL query are hierarchical from top to bottom.
In einem weiteren Aspekt des computerlesbaren Mediums umfasst die Auswertung der SQL-Abfrage für die Abfragebedingung, das Auswerten eines Datenbankschemas für die hierarchische DatenspeicherungIn another aspect of the computer readable medium, the evaluation of the SQL query for the query condition includes evaluating a database schema for the hierarchical data storage
In einem noch anderen Aspekt der Vorrichtung legt die Abfragebedingung fest, dass die Vielzahl der in der SQL-Abfrage identifizierten Tabellen top-down hierarchisch ist, wenn jede Tabelle der Vielzahl von Tabellen nur ein ordnungsgemäßer Vorgänger oder ein ordnungsgemäßer Nachfolger einer anderen Tabelle in der Vielzahl von Tabellen ist.In yet another aspect of the apparatus, the query condition determines that the plurality of tables identified in the SQL query are top-down hierarchical if each table of the plurality of tables is just one proper predecessor or successor of another table in the plurality of tables.
In einem noch weiteren Aspekt des computerlesbaren Mediums ist die Abfragebedingung nicht erfüllt, wenn eine erste Tabelle einer Vielzahl von Tabellen eine hierarchische Beziehung zu einer zweiten Tabelle der Vielzahl von Tabellen aufweist, die nicht ordnungsgemäß ein Vorgänger oder Nachfolger ist.In yet another aspect of the computer-readable medium, the query condition is not satisfied when a first table of a plurality of tables has a hierarchical relationship with a second table of the plurality of tables that is not properly a predecessor or successor.
In einem anderen Aspekt des computerlesbaren Mediums legt die Abfragebedingung fest, dass die SQL-Abfrage für das Durchführen des nicht-gepufferten Lesevorgangs gültig ist, wenn mindestens ein Prädikat der SQL-Abfrage festlegt, dass, wenn ein Datensatz einer ersten Tabelle mit Datensätzen einer zweiten Tabelle verbunden werden soll, die Datensätze der zweiten Tabelle Nachfolger des Datensatzes der ersten Tabelle sind und der Datensatz der ersten Tabelle nicht mit den Datensätzen der zweiten Tabelle verknüpft ist, die ein Nachfolger des Datensatzes der ersten Tabelle sind.In another aspect of the computer-readable medium, the query condition determines that the SQL query is valid for performing the non-buffered read if at least one predicate of the SQL query determines that if one record of a first table of records of a second Table 2 is to be joined, the records of the second table are descendants of the record of the first table, and the record of the first table is not linked to the records of the second table, which are a descendant of the record of the first table.
In einem weiteren Aspekt des computerlesbaren Mediums umfasst das Auswerten der SQL-Abfrage für die Abfragebedingung die Bestätigung, dass ein Präfix eines Primärschlüsselwertes von mindestens einem Datensatz der Datensätze der zweiten Tabelle einen Primärschlüsselwert des Datensatzes der ersten Tabelle umfasst.In another aspect of the computer readable medium, evaluating the query query SQL query comprises confirming that a prefix of a primary key value of at least one record of the records of the second table comprises a primary key value of the record of the first table.
In noch einem anderen Aspekt des computerlesbaren Mediums legt die Abfragebedingung fest, dass die SQL-Abfrage für das Durchführen des nicht-gepufferten Lesevorgangs gültig ist, wenn die SQL-Abfrage nur aus einem Operationstyp einer ersten Instanz eines Operationstyps besteht.In yet another aspect of the computer readable medium, the query condition determines that the SQL query is valid for performing the non-buffered read if the SQL query consists of only one operation type of a first instance of an operation type.
In noch einem weiteren Aspekt des computerlesbaren Mediums umfasst der Operationstyp einen SQL-Operationstyp „LEFT OUTER JOJN”.In yet another aspect of the computer readable medium, the operation type includes an SQL operation type "LEFT OUTER JOJN".
In einem anderen Aspekt des computerlesbaren Mediums, umfasst das Auswerten der SQL-Abfrage für die Abfragebedingung die Bestimmung, ob nach einer Instanz eines Operationstyps „LEFT OUTER JOIN” in der SQL-Abfrage keine anderen Variationen einer SQL-JOIN-Operation, als der Operationstyp „LEFT OUTER JOIN”, auftritt.In another aspect of the computer-readable medium, evaluating the SQL query for the query condition involves determining whether after an instance of an operation type "LEFT OUTER JOIN" in the SQL query, no other variations of a SQL JOIN operation than the operation type "LEFT OUTER JOIN" occurs.
In einem weiteren Aspekt des computerlesbaren Mediums legt die Abfragebedingung fest, dass die SQL-Abfrage für das Durchführen des nicht-gepufferten Lesevorgangs gültig ist, wenn eine erste Join-Bedingung an einer Vorgängertabelle nicht erfüllt ist, eine zweite Join-Bedingung an einer Nachfolge-Tabelle ebenfalls nicht erfüllt ist.In another aspect of the computer-readable medium, the query condition determines that the SQL query is valid for performing the non-buffered read if a first join condition on a predecessor table is not met, a second join condition on a successor Table is also not satisfied.
In noch einem anderen Aspekt des computerlesbaren Mediums wird die SQL-Abfrage für die Abfragebedingung ausgewertet, indem bestimmt wird, dass mindestens ein Prädikat eine Konjunktion der Form „X.A = Y.B,” umfasst, wobei: X eine erste Tabelle, A eine erste Spalte der ersten Tabelle, Y eine zweite Tabelle und B eine zweite Spalte der zweiten Tabelle ist.In yet another aspect of the computer readable medium, the SQL query for the query condition is evaluated by determining that at least one predicate comprises a conjunction of the form "XA = YB," where: X is a first table, A is a first column of first table, Y is a second table and B is a second column of the second table.
KURZBESCHREIBUNG DER ZEICHNUNGENBRIEF DESCRIPTION OF THE DRAWINGS
Die dazugehörigen Zeichnungen sind nicht bestimmungsgemäß maßstabsgetreu. In den Zeichnungen ist jede identische oder nahezu identische Komponente, die in verschiedenen Figuren dargestellt ist, durch eine gleiche Bezugszahl bezeichnet. Aus Gründen der Klarheit kann nicht jede Komponente in jeder Zeichnung bezeichnet werden. Die Zeichnungen umfassen Folgendes:The corresponding drawings are not to scale as intended. In the drawings, each identical or nearly identical component shown in different figures is designated by a like reference numeral. For clarity, not every component in each drawing can be labeled. The drawings include the following:
1 veranschaulicht ein Beispiel eines relationalen Schnittstellensystems in Verbindung mit Client-Geräten und einem oder mehreren hierarchischen Datenspeichern, gemäß den Aspekten der Offenbarung. 1 FIG. 12 illustrates an example of a relational interface system in conjunction with client devices and one or more hierarchical datastores, in accordance with the aspects of the disclosure.
2 veranschaulicht ein Beispiel des relationalen Schnittstellensystems von 1, gemäß den Aspekten der Offenbarung. 2 illustrates an example of the relational interface system of 1 in accordance with the aspects of the disclosure.
3 veranschaulicht ein Beispiel eines Nachrichtenaustauschs (Message passing), der zwischen verschiedenen Komponenten und Systemen des in 2 gezeigten relationalen Schnittstellensystems und gemäß den Aspekten der Offenbarung, erfolgen kann. 3 FIG. 4 illustrates an example of message passing that is shared between various components and systems of the present invention 2 shown relational interface system and in accordance with the aspects of the disclosure.
DETAILLIERTE BESCHREIBUNGDETAILED DESCRIPTION
Die vorliegende Offenbarung bezieht sich auf ein relationales Schnittstellensystem, das die Verbindung zwischen einem oder mehreren Client-Geräten und einem oder mehreren hierarchischen Datenspeichern ermöglicht. Insbesondere sieht diese Offenbarung ein relationales System vor, das verschiedene Structured Query Languages („SQL”) (strukturierte Datenbankabfragesprachen) eines Client-Gerätes akzeptieren kann, um zu bewerten, ob eine oder mehrere SQL-Abfragen mit einer oder mehreren vordefinierten Abfragebedingungen übereinstimmen und dann einen nicht-gepufferten Lesevorgang aus einem oder mehreren hierarchischen Datenspeichern, basierend auf der Bewertung, durchführt. Der nicht-gepufferte Lesevorgang stellt eine effiziente Methode bereit, womit das relationale System einen hierarchisch geclusterten Datenstrom aus einem oder mehreren hierarchischen Datenspeichern lesen kann.The present disclosure relates to a relational interface system that facilitates the connection between one or more client devices and one or more hierarchical data stores. In particular, this disclosure provides a relational system that can accept various Structured Query Languages ("SQL") of a client device to evaluate whether one or more SQL queries match one or more predefined query conditions, and then performs a non-buffered read from one or more hierarchical data stores based on the score. The non-buffered read provides an efficient method by which the relational system can read a hierarchically clustered stream of data from one or more hierarchical data stores.
Das relationale Schnittstellensystem stellt eine Weiterentwicklung gegenüber aktuellen Technologien für den Zugriff auf hierarchisch organisierte Datenspeicher dar, da der nicht-gepufferte Lesevorgang auf einem oder mehreren hierarchisch organisierten Datenspeichern durchgeführt werden kann, sodass das relationale Schnittstellensystem nicht mehrere Leseanforderungen desselben Datenspeichers durchführen muss. Darüber hinaus kann der nicht-gepufferte Lesevorgang mit einer festen Bindung an die Menge der Pufferung erreicht werden. Zusätzlich reduzieren die beschriebenen Systeme und Verfahren die verstrichene Zeit zwischen dem Zeitpunkt einer Anforderung von einem Client-Gerät zum System, bis zu dem Zeitpunkt, an dem das Client-Gerät die Antwort auf die Anforderung erhalten hat.The relational interface system is a further development over current technologies for accessing hierarchically organized data stores because the non-buffered read can be performed on one or more hierarchically organized data stores so that the relational interface system does not have to perform multiple read requests of the same data store. In addition, the non-buffered read can be achieved with a fixed link to the amount of buffering. In addition, the described systems and methods reduce the elapsed time between the time a request from a client device to the system until the time the client device received the response to the request.
Auf diese Weise reduziert der nicht-gepufferte Lesevorgang den Verbrauch der Ressourcen, die benötigt werden, um mehrere Datenbanktabellen abzurufen und zu verknüpfen, erheblich (z. B. Prozessorzyklen, Such-/Lesezeiten, Speicher mit wahlfreiem Zugriff usw.), wenn eine oder mehrere SQL-Abfragen empfangen werden, wie etwa SQL-Abfragen mit der „JOIN”-Operation, „LEFT OUTER JOIN”-Operation und anderen solchen Operationen.In this way, the non-buffered read significantly reduces the consumption of the resources needed to retrieve and link multiple database tables (eg, processor cycles, search / read times, random access memory, etc.) if one or more multiple SQL queries are received, such as SQL queries with the "JOIN" operation, "LEFT OUTER JOIN" operation, and other such operations.
1 veranschaulicht ein Beispiel einer Datenzentrumsumgebung 102 in der das relationale Schnittstellensystem 104 mit einem oder mehreren Client-Geräten 114–118 und einem oder mehreren hierarchischen Datenspeichern 106–112 in Verbindung steht. Das relationale Schnittstellensystem 104 kann eine oder mehrere Schnittstellen zu den Client-Vorrichtungen 114–118 für den Zugriff auf einen oder mehrere Datenspeicher 106–112 aufweisen. Die an den Client-Geräten 114–118 bereitgestellte Schnittstelle kann eine grafische Benutzeroberfläche, eine Befehlszeilenschnittstelle oder eine Kombination der beiden sein. Die Schnittstelle kann auch eine Schnittstelle zur Anwendungsprogrammierung („API”) umfassen, die den programmgesteuerten Betrieb einer oder mehreren empfangenen SQL-Abfragen erleichtert, wie beispielsweise durch ein RPC-System („Remote Procedure Call”-Aufruf entfernter Prozeduren). Darüber hinaus kann die den Client-Geräten 114–118 bereitgestellte Schnittstelle, eine Schnittstelle sein, die unter Verwendung einer oder mehrere Internets verwandter Technologien entwickelt wird, wie beispielsweise die Hypertext Markup Language (Hypertext-Auszeichnungssprache-„HTML”), JavaScript, Extensible Markup Language (Seitenbeschreibungssprache-„XML”), Cascading Style Sheets („CSS”) oder jegliche anderen Technologien. 1 illustrates an example of a data center environment 102 in the the relational interface system 104 with one or more client devices 114 - 118 and one or more hierarchical data stores 106 - 112 communicates. The relational interface system 104 can have one or more interfaces to the client devices 114 - 118 for accessing one or more data stores 106 - 112 exhibit. The on the client devices 114 - 118 provided interface may be a graphical user interface, a command line interface or a combination of the two. The interface may also include an application programming interface ("API") that facilitates the programmatic operation of one or more received SQL queries, such as a Remote Procedure Call (RPC) remote procedure call (RPC) system. In addition, the client devices 114 - 118 provided interface, an interface developed using one or more Internet related technologies, such as the Hypertext Markup Language (HTML), JavaScript, Extensible Markup Language, Cascading Style Sheets ("CSS") or any other technologies.
Die Schnittstelle kann konfiguriert sein, um eine oder mehrere Abfragen von den Client-Geräten 114–118 für den Zugriff des hierarchischen Datenspeichers 106–112 zu empfangen. Die Abfragen können für den Zugriff oder die Verwaltung von Daten in einem relationalen Datenbankverwaltungssystem („RDBMS”) nach dem SQL-Standard oder einer anderen Abfragesprache formatiert sein. Beispiele von Abfragen, die durch die Client-Geräte 114–118 bereitgestellt werden können, können Abfragen umfassen, die „SELECT”-Operationen, „JOIN”-Operationen, Varianten von „JOIN”-Operationen (z. B. „INNER JOIN,” „LEFT OUTER JOIN,” „NATURAL JOIN,” etc.), „UNION”-Operationen oder jegliche anderen Operationen des SQL-Standards enthalten.The interface may be configured to receive one or more queries from the client devices 114 - 118 for accessing the hierarchical data store 106 - 112 to recieve. The queries may be formatted to access or manage data in a relational database management system ("RDBMS") according to the SQL standard or other query language. Examples of queries made by the client devices 114 - 118 queries that include "SELECT" operations, "JOIN" operations, variants of "JOIN" operations (eg, "INNER JOIN,""LEFT OUTER JOIN,""NATURALJOIN," etc .), "UNION" operations, or any other SQL standard operations.
Ferner kann das objektrelationale Schnittstellensystem 104 so konfiguriert sein, um eine oder mehrere SQL-Abfragen in eine Abfrage zu transformieren, die durch die hierarchischen Datenspeicher 106–112 verständlich ist. Somit können die hierarchischen Datenspeicher 106–112 beispielsweise auf einem Server oder einem anderen Gerät implementiert sein, das keine SQL-Abfragen versteht. Diesbezüglich kann die relationale Schnittstelle 104 so konfiguriert sein, um die empfangenen SQL-Abfragen von einem oder mehreren Client-Geräten 114–118 zu interpretieren, die SQL-Abfragen in eine von den Datenspeichern 106–112 verständliche Abfragesprache zu transformieren, einen oder mehrere Datenströme von den Datenspeichern 106–112, basierend auf der anfänglichen SQL-Abfrage empfangen und die Ergebnisse an die Client-Geräte 114–118, basierend auf den empfangenen Datenströmen, übermitteln.Furthermore, the object-relational interface system 104 be configured to transform one or more SQL queries into a query by the hierarchical data store 106 - 112 is understandable. Thus, the hierarchical data storage 106 - 112 for example, be implemented on a server or other device that does not understand SQL queries. In this regard, the relational interface 104 be configured to receive the received SQL queries from one or more client devices 114 - 118 to interpret the SQL queries in one of the datastores 106 - 112 understandable query language to transform one or more data streams from the data stores 106 - 112 , based on the initial SQL query received and the results sent to the client devices 114 - 118 based on the received data streams.
Obwohl die hierin offenbarten Systeme und Verfahren nicht durch irgendeine spezielle Datenstruktur begrenzt sind, können die Datenspeicher 106–112 in Computer-Register implementiert werden als eine oder mehrere Objektdatenbanken mit einer oder mehreren Entitäten, die eine Vielzahl von unterschiedlichen Feldern und Datensätzen definieren, eine oder mehrere relationale Datenbanken, die durch eine oder mehrere Tabellen mit einer Vielzahl von unterschiedlichen Feldern und Datensätzen, Extensible Markup Language (Seitenbeschreibungssprache-„XML”) Dokumente, flache Dateien, ein mehrdimensionales Array (z. B. ein 1-dimensionales Array, ein 2-dimensionales Array, etc.) oder Kombinationen davon, definiert sind. Die Datenspeicher 106–112 können auch in jedes computerlesbare Format formatiert werden. Zusätzlich können die Datenspeicher 106–112 alle Arten von Informationen umfassen, die ausreichend sind, um jeweils relevante Informationen zu identifizieren, wie etwa Zahlen, beschreibenden Text, urheberrechtlich geschützte Codes, Referenzen zu Daten, die in anderen Bereichen desselben oder eines unterschiedlichen Speichers gespeichert werden (einschließlich andere Netzwerkstandorte) oder Informationen, die von einer Funktion verwendet werden, um die jeweils relevanten Daten zu berechnen. Although the systems and methods disclosed herein are not limited by any particular data structure, the data memories may 106 - 112 are implemented in computer registers as one or more object databases with one or more entities defining a plurality of different fields and records, one or more relational databases defined by one or more tables having a plurality of different fields and records, Extensible Markup Language (page description language "XML") documents, flat files, a multi-dimensional array (e.g., a 1-dimensional array, a 2-dimensional array, etc.), or combinations thereof. The data storage 106 - 112 can also be formatted in any computer-readable format. In addition, the data storage 106 - 112 include all types of information sufficient to identify relevant information, such as numbers, descriptive text, copyrighted codes, references to data stored in other areas of the same or different memory (including other network locations), or information that are used by a function to calculate the relevant data.
Ein Datensatz von einem oder mehreren der Datenspeicher 106–112 kann ein oder mehrere Attribute aufweisen. Die Attribute können Informationen über den Datensatz speichern. Abhängig von den in den hierarchischen Datenspeichern 106–112 gespeicherten Informationen können die Attribute solche Dinge wie Mitarbeiterinformationen (deren Datensätze sich auf Mitarbeiter beziehen), Werbekampagneninformationen (deren Datensätze sich auf Werbekampagnen beziehen), Werbeschlüsselwortinformationen (deren Datensätze sich auf Werbeschlüsselwörter beziehen) und ähnliche Informationen umfassen.A record of one or more of the data stores 106 - 112 can have one or more attributes. The attributes can store information about the record. Depending on the hierarchical data stores 106 - 112 stored information, the attributes may include such things as employee information (whose records relate to employees), advertising campaign information (whose records relate to advertising campaigns), advertising keyword information (whose records relate to advertising keywords) and similar information.
Die Attribute für jeden Datensatz können ferner ein Primärschlüsselattribut und ein oder mehrere Fremdschlüsselattribute umfassen. Das Primärschlüsselattribut des Datensatzes kann einen Primärschlüsselwert speichern, der den Datensatz eindeutig identifiziert. In einer Implementierung können mehrere Attribute eines gegebenen Datensatzes konstruiert werden, um den Primärschlüsselwert zu bilden, der den gegebenen Datensatz eindeutig identifiziert. Eines oder mehrere Fremdschlüsselattribute können jeweils einen Fremdschlüsselwert speichern, der einen anderen Datensatz identifiziert. Des Weiteren kann der primäre Schlüsselwert des untergeordneten Datensatzes, um einen untergeordneten Datensatz mit seinem übergeordneten Datensatz zu verknüpfen, Teile des primären Schlüsselwerts des übergeordneten Datensatzes enthalten. In einer Implementierung kann der Primärschlüsselwert des untergeordneten Datensatzes den Primärschlüsselwert des übergeordneten Datensatzes als Präfix enthalten. In einer anderen Implementierung kann der übergeordnete Datensatz ein oder mehrere N Primärschlüsselattribute aufweisen, wobei der untergeordnete Datensatz M Primärschlüsselattribute aufweisen kann (wobei M größer oder gleich N) und die ersten N Werte aus den M Primärschlüsselattributen des untergeordneten Datensatzes den primären Schlüsselattributen des übergeordneten Datensatzes entsprechen.The attributes for each record may further include a primary key attribute and one or more foreign key attributes. The primary key attribute of the record can store a primary key value that uniquely identifies the record. In one implementation, multiple attributes of a given record may be constructed to form the primary key value that uniquely identifies the given record. One or more foreign key attributes may each store a foreign key value identifying another record. In addition, to associate a child record with its parent record, the child key primary key value may include portions of the primary key value of the parent record. In one implementation, the primary key value of the child record may include the primary key value of the parent record as a prefix. In another implementation, the parent record may have one or more N primary key attributes, wherein the child record M may have primary key attributes (where M is greater than or equal to N) and the first N values from the M primary key attributes of the child record correspond to the primary key attributes of the parent record ,
Wenn zum Beispiel der Primärschlüsselwert des übergeordneten Datensatzes „325” ist und der Primärschlüsselwert des untergeordneten Datensatzes „478”, Kann ein neuer Primärschlüsselwert für den untergeordneten Datensatz wie „325,478” oder „325:478” erstellt werden, wobei der Primärschlüsselwert des übergeordneten Datensatzes dem Primärschlüsselwert des untergeordneten Datensatzes vorangestellt wurde. Auf diese Weise kann das objektrelationale Schnittstellensystem 104 problemlos über/untergeordnete Relationen identifizieren, wenn der Datenstrom von einem oder mehreren hierarchischen Datenspeichern 106–112 empfangen wird.For example, if the primary key value of the parent record is "325" and the child key's primary key value is "478", a new primary key value for the child record such as "325.478" or "325: 478" can be created, with the primary key value of the parent record Primary key value of the child record was prepended. This allows the object-relational interface system 104 Easily identify over / subordinate relations if the data stream is from one or more hierarchical data stores 106 - 112 Will be received.
Das relationale Schnittstellensystem 104 kann mit einem oder mehreren Client-Geräten 114–118 über das Netzwerk 122 in Verbindung stehen und das relationale Schnittstellensystem 104 kann mit einem oder mehreren hierarchischen Datenspeichern 106–112 über ein Netzwerk 124 in Verbindung stehen. Die Netzwerke 122–124 können ein oder mehrere Typen von Kommunikationskanälen umfassen, einschließlich Ethernet, Universal Serial Bus („USB”), Small Computer System Interface (SCSI), Kombinationen der vorgenannten und andere solcher drahtgebundenen Kommunikationskanäle. Die Netzwerke 122–124 können auch drahtlose Kommunikationskanäle umfassen, wie Bluetooth (z. B. drahtlose Kommunikationskanäle, die im Bandbereich von 2400–2480 MHz arbeiten), Variationen von IEEE 802.11 (z. B. IEEE 802.11a , IEEE 802.11b usw.), („WiMAX”) und andere derartige drahtlose Technologien (z. B. jede Funktechnologie, die in den industriellen, wissenschaftlichen und medizinischen („ISM”) Funkbändern betrieben wird).The relational interface system 104 can work with one or more client devices 114 - 118 over the network 122 and the relational interface system 104 can be with one or more hierarchical data stores 106 - 112 over a network 124 keep in touch. The networks 122 - 124 may include one or more types of communication channels, including Ethernet, Universal Serial Bus ("USB"), Small Computer System Interface (SCSI), combinations of the foregoing and other such wired communication channels. The networks 122 - 124 may also include wireless communication channels, such as Bluetooth (e.g., wireless communication channels operating in the band range of 2400-2480 MHz), variations of IEEE 802.11 (eg IEEE 802.11a . IEEE 802.11b etc.), ("WiMAX") and other such wireless technologies (e.g., any radio technology operating in the industrial, scientific and medical ("ISM") radio bands).
Die Netzwerke 122–124 können auch verschiedene Typen von Netzwerken umfassen. Beispielsweise können die Netzwerke 122–124 Wide Area Network (Weitverkehrsnetzwerk-„WAN”), wie das Internet, ein Local Area Network (lokales Netzwerk-„LAN”), ein Personal Area Network (persönliches Netzwerk-„PAN”) oder eine Kombination von WANs, LANs, und PANs umfassen. Das Netzwerk 122 kann auch das Netzwerk 124 umfassen und umgekehrt.The networks 122 - 124 may also include various types of networks. For example, the networks 122 - 124 Wide Area Network (WAN) such as the Internet, a Local Area Network (LAN), a Personal Area Network (PAN), or a combination of WANs, LANs, and PANs include. The network 122 can also network 124 include and vice versa.
Die Client-Geräte 114–118 können jegliche Art von Client-Gerät oder -system konfigurieren, um dem relationalen Schnittstellensystem 104 eine oder mehrere SQL-Abfragen zur Verfügung zu stellen. So können beispielsweise die Client-Geräte 114–118 einen Desktop-Computer, ein Mobilgerät, wie ein Laptop, ein Smartphone, ein Personal Display Assistant (persönlicher digitaler Assistent-„PDA”), einen Tablet-Computer oder andere solcher Mobilgeräte, umfassen. Die Client-Geräte 114–118 können auch andere Systeme, wie beispielsweise Bereitstellungssysteme, Telekommunikationssysteme, Datencenter-Systeme und ein anderes derartiges System umfassen. Jedes der Client-Geräte 114–118 kann so konfiguriert sein, um mit dem relationalen Schnittstellensystem 104 über eine Schnittstelle zu kommunizieren, die durch das relationale Schnittstellensystem 104 zur Verfügung gestellt wird. Darüber hinaus kann das relationale Schnittstellensystem 104 so konfiguriert sein, dass Datensatzergebnisse für ein oder mehrere Client-Geräte 114–118, basierend auf den SQL-Abfragen, die von dem einen oder den mehreren Clientgeräten 114–118 zur Verfügung gestellt werden, bereitgestellt werden. The client devices 114 - 118 You can configure any type of client device or system to use the relational interface system 104 to provide one or more SQL queries. For example, the client devices 114 - 118 a desktop computer, a mobile device such as a laptop, a smartphone, a Personal Display Assistant (PDA), a tablet computer, or other such mobile device. The client devices 114 - 118 may also include other systems, such as provisioning systems, telecommunications systems, data center systems, and another such system. Each of the client devices 114 - 118 can be configured to work with the relational interface system 104 communicate through an interface through the relational interface system 104 is made available. In addition, the relational interface system 104 be configured to record results for one or more client devices 114 - 118 based on the SQL queries made by the one or more client devices 114 - 118 be made available.
2 veranschaulicht ein Beispiel des relationalen Schnittstellensystems 104 von 1, gemäß den Aspekten der Offenbarung. Wie in 2 dargestellt, kann das relationale Schnittstellensystem 104 einen Speicher 202 umfassen, der mit einem Prozessor 204 kommuniziert. Das relationale Schnittstellensystem 104 kann eine beliebige Vielzahl von Anwendungen im Speicher 202 instanziieren und/oder speichern, wie beispielsweise eine Front-End-Benutzerschnittstelle 206, einen SQL-Abfrageanalysator 208, einen SQL-Abfrageplaner 210, einen Schemamanager 212, einen Plandurchführungsvorbereiter 214 und einen Join-Planausführer 216 2 illustrates an example of the relational interface system 104 from 1 in accordance with the aspects of the disclosure. As in 2 can represent the relational interface system 104 a memory 202 include that with a processor 204 communicated. The relational interface system 104 can use any variety of applications in memory 202 instantiate and / or store, such as a front-end user interface 206 , an SQL query analyzer 208 , an SQL query planner 210 , a schema manager 212 , a plan execution preparer 214 and a join plan executer 216
Der Prozessor 204 kann ein beliebiger konventioneller Prozessor oder ein Mikroprozessor sein, wie beispielsweise eine zentrale Verarbeitungseinheit („CPU”) oder ein spezielles Gerät, wie beispielsweise eine anwendungsspezifische integrierte Schaltung („ASIC”).The processor 204 may be any conventional processor or microprocessor, such as a central processing unit ("CPU") or a dedicated device, such as an application specific integrated circuit ("ASIC").
Obwohl 2 funktional den Prozessor 204 veranschaulicht, wobei der Speicher 202 und andere Elemente des relationalen Schnittstellensystems 104 innerhalb des gleichen Blocks liegen, wird der Fachmann verstehen, dass der Prozessor 204 und der Speicher 202 in der Praxis mehrere Prozessoren und Speicher umfassen können, die in dem gleichen physischen Gehäuse untergebracht werden können oder nicht. So kann beispielsweise der Speicher 204 eine Festplatte oder ein anderes Speichermedium sein, das sich in einem von dem relationalen Schnittstellensystems 104 separaten Gehäuse befindet. Demgemäß werden Bezugnahmen auf einen oder mehrere Prozessoren, einen oder mehrere Speicher des relationalen Schnittstellensystems 104 so verstanden, dass Bezugnahmen auf eine Sammlung von Prozessoren, Computer oder Speicher, die parallel betrieben werden können oder nicht, hinweisen. Anstatt einen einzelnen Prozessor für die Durchführung der hierin beschriebenen Operationen zu verwenden, können einige der Komponenten einen eigenen Prozessor aufweisen, der die Operation durchführt, die sich auf die spezifische Funktion der Komponente bezieht.Even though 2 functional the processor 204 illustrates where the memory 202 and other elements of the relational interface system 104 within the same block, the skilled person will understand that the processor 204 and the memory 202 in practice, may include multiple processors and memories that may or may not be housed in the same physical enclosure. For example, the memory 204 a hard disk or other storage medium located in one of the relational interface system 104 separate housing is located. Accordingly, references to one or more processors, one or more relational interface system memories 104 understood to refer to a collection of processors, computers or memory that may or may not operate in parallel. Rather than using a single processor to perform the operations described herein, some of the components may have their own processor that performs the operation related to the specific function of the component.
Der Speicher 202 kann jede Art von Speicher sein, der Informationen speichern kann, die für den Prozessor 204 zugänglich sind, umfassend ein computer-lesbares Medium oder anderes Medium auf dem Daten gespeichert sind, die mithilfe eines elektronischen Geräts gelesen werden können, z. B. eine Festplatte, eine Speicherkarte, ein Read Only Memory (ROM), ein Random Access Memory (RAM), eine Digital Versatile Disc (DVD) oder ein anderer optischer Datenträger sowie andere schreibfähige und schreibgeschützte Speicher. Die Systeme und Verfahren können unterschiedliche Kombinationen der vorstehend Genannten beinhalten, wobei unterschiedliche Abschnitte der der Software-Funktionalitäten des relationalen Schnittstellensystems 104 auf unterschiedlichen Datenträgerarten gespeichert werden.The memory 202 can be any type of memory that can store information for the processor 204 are accessible, comprising a computer-readable medium or other medium are stored on the data that can be read using an electronic device, eg. For example, a hard disk, a memory card, a read only memory (ROM), a random access memory (RAM), a digital versatile disc (DVD) or other optical disk, and other writable and read-only memory. The systems and methods may include different combinations of the above, with different portions of the software functionalities of the relational interface system 104 stored on different types of media.
Der Speicher 202 kann einen beliebigen Satz von computer-ausführbaren Anweisungen umfassen, die direkt (z. B. Maschinencode) oder indirekt (z. B. Skripte) vom Prozessor 204 ausgeführt werden. So können beispielsweise computer-ausführbare Anweisungen als Computer-Code auf einem computerlesbaren Medium gespeichert werden. Diesbezüglich können die Begriffe „Anweisungen”, „Anwendung”, „Programme” und „Anwendungen” hierin austauschbar verwendet sein. Die Anweisungen können im Zielcode-Format zur direkten Verarbeitung durch den Prozessor 204 oder in jeglicher sonstigen Computersprache, einschließlich Skripts oder Sammlungen, unabhängiger Quellcode-Module, die auf Anfrage interpretiert oder im Voraus kompiliert werden, gespeichert sein. Funktionen, Verfahren und Routinen der Anweisungen werden unten ausführlicher erklärt.The memory 202 may include any set of computer-executable instructions that are direct (eg, machine code) or indirect (eg, scripts) from the processor 204 be executed. For example, computer-executable instructions may be stored as computer code on a computer-readable medium. In this regard, the terms "instructions", "application", "programs" and "applications" may be used interchangeably herein. The instructions may be in target code format for direct processing by the processor 204 or in any other computer language, including scripts or collections, independent source code modules that are interpreted upon request or compiled in advance. Functions, procedures and routines of the instructions are explained in more detail below.
In verschiedenen hierin beschriebenen Beispielen kann sich der Prozessor 204 entfernt vom relationalen Schnittstellensystem 104 befinden und kann mit einer oder mehreren Komponenten und/oder Anwendungen, wie beispielsweise der Speicher 202 und/oder die Komponenten 206–216, drahtlos über ein Netzwerk (z. B. ein lokales Netzwerk, ein Weitbereichsnetzwerk, etc.) kommunizieren. Zudem können eine oder mehrere Komponenten 206–216 innerhalb anderen Servern oder Computer untergebracht oder implementiert werden und das relationale Schnittstellensystem 104 kann Informationen von diesen Komponenten 206–216 empfangen. So können beispielsweise die Komponenten 206–216 in einem anderen Server oder Computer gespeichert sein und der Prozessor 204 kann Informationen von jedem dieser anderen Server und/oder Computer empfangen. In anderen Aspekten werden einige der hierin beschriebenen Prozesse auf einem Prozessor ausgeführt, der innerhalb des relationalen Schnittstellensystems 104 angeordnet ist und andere durch einen entfernten Prozessor, der in einem überwachten Server untergebracht ist, umfassend der Durchführung von Operationen zur Ermittlung dessen, ob eine SQL-Abfrage zum Ausführen eines nicht-gepufferten Lesevorgangs oder zur Verarbeitung eines hierarchisch geclusterten Datenstroms gültig ist.In various examples described herein, the processor may 204 away from the relational interface system 104 can and may contain one or more components and / or applications, such as the memory 202 and / or the components 206 - 216 , communicate wirelessly over a network (eg, a local area network, a wide area network, etc.). In addition, one or more components 206 - 216 housed or implemented within other servers or computers and the relational interface system 104 can get information from these components 206 - 216 receive. So For example, the components 206 - 216 be stored in another server or computer and the processor 204 can receive information from any of these other servers and / or computers. In other aspects, some of the processes described herein are executed on a processor within the relational interface system 104 and others by a remote processor residing in a monitored server, including performing operations to determine whether an SQL query is valid to perform an un-buffered read or to process a hierarchically clustered data stream.
Das relationale Schnittstellensystem 104 kann eine Front-End-Benutzeroberfläche 206 für die Kommunikation mit einem oder mehreren Client-Geräten 114–118 implementieren. Die Front-End-Benutzeroberfläche 206 kann so konfiguriert werden, um eine grafische Benutzeroberfläche, eine Befehlszeilenschnittstelle oder eine Kombination von beiden, anzuzeigen. Die Front-End-Benutzeroberfläche 206 kann ferner eine API implementieren, auf die von einem oder mehreren Client-Geräten 114–118 für die Kommunikation mit einem oder mehreren hierarchischen Datenspeichern 106–112, oder eine Kombination davon, zugegriffen werden kann. Darüber hinaus kann die Front-End-Benutzeroberfläche 206 so konfiguriert werden, um eine SQL-Abfrage, wie zuvor erwähnt, zu akzeptieren. Zudem kann die Front-End-Benutzeroberfläche 206 so konfiguriert werden, um Daten als Ergebnis der SQL-Abfrage darzustellen oder zu übertragen, wie z. B. die Datensätze, die als Ergebnis aus einer SQL-Abfrage resultieren, die eine „JOIN”-Operation umfassen.The relational interface system 104 can be a front-end user interface 206 for communication with one or more client devices 114 - 118 to implement. The front-end user interface 206 can be configured to display a graphical user interface, a command-line interface, or a combination of both. The front-end user interface 206 may also implement an API to which one or more client devices 114 - 118 for communication with one or more hierarchical data stores 106 - 112 , or a combination thereof, can be accessed. In addition, the front-end user interface 206 be configured to accept an SQL query as previously mentioned. In addition, the front-end user interface 206 be configured to display or transmit data as a result of the SQL query, such as: For example, the records that result as a result from an SQL query that include a "JOIN" operation.
Wenn die Front-End-Benutzerschnittstelle 206 eine SQL-Abfrage empfängt, kann die Front-End-Benutzeroberfläche 206 die SQL-Abfrage zu dem SQL-Analysator 208 kommunizieren. Der SQL-Analysator 208 kann so konfiguriert werden, um die empfangene SQL-Abfrage in deren verschiedene Komponenten zu analysieren. So kann beispielsweise der SQL-Abfrageanalysator 208 die Prädikate einer SQL-JOIN-Abfrage zerlegen und die zerlegten Prädikate als Filterprädikate speichern, um angewendet zu werden, wenn der hierarchisch geclusterte Datenstrom vom hierarchischen Datenspeicher 106–112 empfangen wird. Wenn der SQL-Abfrageanalysator 208 beispielsweise eine SQL-Abfrage von „SELECT * FROM Tabelle1 JOIN Tabelle2 ON Tabelle1.Spalte1 = Tabelle2.Spalte2 JOIN Tabelle3 ON Tabelle2.Spalte2 = Tabelle3.Spalte3” empfängt, kann der SQL-Abfrageanalysator 208 die Prädikate in ein erstes Prädikat von „Tabelle1.Spalte1 = Tabelle2.Spalte2” und ein zweites Prädikat von „Tabelle2.Spalte2 = Tabelle3.Spalte3” zerlegen. Diese beiden Prädikate können als Filterprädikate verwendet werden, um zu bestimmen, ob die Datensätze innerhalb des empfangenen hierarchisch geclusterten Datenstroms als Ausgabe erzeugt werden und/oder zu einem oder mehreren Client-Geräte 114–118 übertragen werden sollen.If the front-end user interface 206 can receive a SQL query, the front-end user interface 206 the SQL query to the SQL analyzer 208 communicate. The SQL analyzer 208 can be configured to parse the received SQL query into its various components. For example, the SQL query analyzer 208 decompose the predicates of a SQL JOIN query and store the decomposed predicates as filter predicates to apply when the hierarchically clustered data stream is from the hierarchical data store 106 - 112 Will be received. If the SQL query analyzer 208 For example, an SQL query of "SELECT * FROM Table 1 JOIN Table 2 ON Table 1. Column 1 = Table 2. Column 2 JOIN Table 3 ON Table 2. Column 2 = Table 3. Column 3 " receives the SQL query analyzer 208 decompose the predicates into a first predicate of "Table 1. Column 1 = Table 2. Column 2 " and a second predicate of "Table 2. Column 2 = Table 3. Column 3 ". These two predicates may be used as filter predicates to determine whether the records within the received hierarchically clustered data stream are generated as output and / or to one or more client devices 114 - 118 to be transferred.
Bei der Dekonstruktion der Prädikate kann der SQL-Abfrageanalysator 208 diese Prädikate trennen, die an „LEFT OUTER JOIN”-Operationen beteiligt sind und diese Prädikate, die an nicht-„LEFT OUTER JOIN”-Operationen beteiligt sind. So kann beispielsweise der SQL-Abfrageanalysator 208 alle Prädikate aus „ON”-Klauseln für Tabellen speichern, die nicht zusammen mit allen Prädikaten aus irgendwelchen „WHERE”-Klauseln solcher Operationen, an einer „LEFT OUTER JOIN”-Operation beteiligt sind. Ferner können die Prädikate aus den „ON”-Klauseln jeder Tabelle, die an einer „LEFT OUTER JOIN”-Operation beteiligt sind, in einem separaten Verzeichnis gespeichert werden, wobei jeder Ort einer bestimmten Tabelle entspricht, die an der „LEFT OUTER JOIN”-Operation beteiligt ist.When decoding the predicates, the SQL query analyzer can 208 separating these predicates involved in LEFT OUTER JOIN operations and those predicates involved in non-LEFT OUTER JOIN operations. For example, the SQL query analyzer 208 store any predicates of "ON" clauses for tables that do not participate in a "LEFT OUTER JOIN" operation along with any predicates from any "WHERE" clauses of such operations. Furthermore, the predicates from the "ON" clauses of each table involved in a "LEFT OUTER JOIN" operation may be stored in a separate directory, each location corresponding to a particular table associated with the "LEFT OUTER JOIN". Operation is involved.
Weiter noch kann der SQL-Abfrageanalysator 208 die Prädikate in deren Ligaturen zerlegen. Ein Prädikat kann als Ligatur betrachtet werden, wenn es eine Einzeloperation umfasst, wie z. B. „A.X = B.Y” oder „A.X = Z”. Im vorstehenden Beispiel umfassen die beiden oben genannten Ligaturen übereinstimmend „Tabelle1.Spalte1 = Tabelle2.Spalte2” und „Tabelle2.Spalte1 = Tabelle3.Spalte3”. Tatsächlich kann es Fälle geben, in denen komplexe Prädikate in mehrere Ligaturen zerlegt werden. Wie im Folgenden erläutert, kann das relationale Schnittstellensystem 104 die Ligaturen einer SQL-Abfrage nutzen, um zu bestimmen, ob die SQL-Abfrage als Abfrage für einen nicht-gepufferten Lesevorgang in den hierarchischen Datenspeichern 106–112 geeignet ist.Further still, the SQL query analyzer 208 decompose the predicates into their ligatures. A predicate can be considered a ligature if it comprises a single operation, such as For example, "AX = BY" or "AX = Z". In the above example, the two ligatures mentioned above coincide "Table 1. Column 1 = Table 2. Column 2 " and "Table 2. Column 1 = Table 3. Column 3 ". In fact, there may be cases where complex predicates are broken down into multiple ligatures. As explained below, the relational interface system 104 Use the ligatures of an SQL query to determine if the SQL query is being queried for a non-buffered read in the hierarchical datastores 106 - 112 suitable is.
Abweichend von 2 wird der Begriff „nicht-gepufferter Lesevorgang” erläutert, um dem Leser das Verständnis der Systeme und Verfahren, wie hierin offenbart, zu erleichtern. Wie moderne Datenbanksysteme verstanden werden, umfasst eine Datenbank, die sich auf einem Server befindet, nicht immer alle benötigten Informationen, um eine gegebene SQL-Abfrage auszuwerten. In vielen Fällen können verschiedene Datenbanktabellen einer Datenbank auf verschiedenen Server gespeichert werden, die zur Auswertung der gegebenen SQL-Abfrage erforderlich sein können. Da eine relationale Datenbank ohne Rücksicht auf die hierarchische Anordnung der darin gespeicherten Daten implementiert werden kann, muss ein Server, der die gegebene SQL-Abfrage auswertet, möglicherweise mehrere Leseanforderungen an diese Datenbank senden, um ausreichende Informationen zur Bewertung der empfangenen SQL-Abfragen aus verschiedenen Tabellen zu sammeln. Wenn der auswertende Server (z. B. der Server, der die SQL-Abfrage auswertet) die angeforderten Informationen von diesen disparaten Tabellen empfängt, kann der auswertende Server die empfangenen Informationen zum Auswerten der Prädikate der SQL-Abfrage speichern (d. h. die empfangenen Informationen „puffern”), sobald alle erforderlichen Informationen empfangen wurden. Selbst in einer Datenbank die nicht als relationale Datenbank implementiert ist, wie beispielsweise eine objektorientierte Datenbank, gibt es nur wenig Rücksicht darauf, ob die darin gespeicherten Daten hierarchisch angeordnet sind.Deviating from 2 the term "non-buffered read" is discussed to assist the reader in understanding the systems and methods as disclosed herein. As understood by modern database systems, a database residing on a server does not always include all the information needed to evaluate a given SQL query. In many cases, different database tables of a database can be stored on different servers, which may be required to evaluate the given SQL query. Since a relational database can be implemented without regard to the hierarchical arrangement of the data stored therein, a server that evaluates the given SQL query may need to send multiple read requests to that database to obtain sufficient information to evaluate the received SQL queries from different ones To collect tables. If the evaluating server (for example, the server that evaluates the SQL query) disparts the requested information from them Tables receives, the evaluating server, the received information for evaluating the predicates of the SQL query store (ie, the received information "buffer"), as soon as all required information has been received. Even in a database that is not implemented as a relational database, such as an object-oriented database, there is little consideration as to whether the data stored therein is hierarchical.
In diesem Zusammenhang bedeutet der Begriff „nicht-gepufferter Lesevorgang”, dass das relationale Schnittstellensystem 104 die Prädikate der empfangenen SQL-Abfrage, als den hierarchisch geclusterten Datenstrom von Datensätzen aus den hierarchischen Datenspeichern 106–112 auswerten kann. Ein hierarchisch geclusterter Datenstrom kann ein Datenstrom sein, der eine Sequenz von Datensätzen aus einem hierarchisch organisierten Datenspeicher enthält, wobei der Datenstrom so geordnet ist, dass jeder Datensatz nach seinem übergeordneten Datensatz und vor jedem anderen Datensatz seiner übergeordneten Tabelle geordnet wird.In this context, the term "non-buffered read" means that the relational interface system 104 the predicates of the received SQL query, as the hierarchically clustered data stream of records from the hierarchical data stores 106 - 112 can evaluate. A hierarchically clustered data stream may be a data stream containing a sequence of records from a hierarchically organized data store, the stream being ordered so that each record is ordered by its parent record and before any other record in its parent table.
Insbesondere während einige Pufferungen vorhanden sein können, kann die Pufferung auf einen einzelnen Datensatz von jeder Tabelle, die an der JOIN-Operation der empfangenen SQL-Abfrage beteiligt ist, begrenzt sein. Darüber hinaus kann das relationale Schnittstellensystem 104 einige Pufferungen im Empfangsprozess des hierarchisch geclusterten Datenstroms von einem oder mehreren hierarchischen Datenspeichern 106–112 durchführen. In einer Implementierung kann feste obere Grenze bezüglich der Menge an Pufferung in dem relationalen Schnittstellensystem 104 etabliert werden und die durch das relationale Schnittstellensystem 104 durchgeführte Pufferung kann diese feste obere Grenze erfüllen.In particular, while some buffering may be present, buffering may be limited to a single record of each table involved in the JOIN operation of the received SQL query. In addition, the relational interface system 104 some buffering in the receive process of the hierarchically clustered data stream from one or more hierarchical data stores 106 - 112 carry out. In one implementation, there may be a fixed upper bound on the amount of buffering in the relational interface system 104 be established by the relational interface system 104 Buffering performed can meet this fixed upper limit.
Zudem kann das relationale Schnittstellensystem 104 bestimmte Daten, die von den hierarchischen Datenspeichern 106–112 empfangen werden, ignorieren, wenn das relationale Schnittstellensystem 104 feststellt, dass die zu ignorierenden Daten für kein Ergebnis, das für den JOIN-Vorgang erforderlich ist, relevant sind. So können beispielsweise die zu ignorierenden Daten einen oder mehrere Datensätze enthalten, deren übergeordnete Datensätze die anwendbaren Prädikate der JOIN-Operation nicht erfüllen.In addition, the relational interface system 104 certain data from the hierarchical data stores 106 - 112 receive, ignore if the relational interface system 104 determines that the data to ignore is not relevant to any result required for the JOIN operation. For example, the data to ignore may contain one or more records whose parent records do not satisfy the applicable JOIN operation predicates.
Da ferner der Datenstrom der empfangen wird hierarchisch geclustert ist, muss das relationale Schnittstellensystem 104 keine gesamte Datenbanktabelle, oder einen Teil davon, die mehr als einen Datensatz enthält speichern, bevor die Datensätze der Datenbanktabelle ausgewertet werden. Da der empfangene Datenstrom hierarchisch geclustert ist, erkennt das relationale Schnittstellensystem 104, wann ein gegebener Datensatz ein übergeordneter Datensatz ist und wenn ein Satz von Datensätzen untergeordnete Datensätze sind, die sich auf diesen übergeordneten Datensatz beziehen. Somit ist der nicht-gepufferte Aspekt des Lesevorgangs eine Weiterentwicklung gegenüber dem aktuellen Stand der Technik, da das relationale Schnittstellensystem 104 nur Datensätze anfordern muss, um die empfangene SQL-Abfrage einmal auszuwerten und darf nur einen minimalen Satz von Datensätzen speichern, um die Prädikate der empfangenen SQL-Abfrage bei der Ausführung der JOIN-Operationen der empfangenen SQL-Abfrage auszuwerten.Further, since the data stream that is being received is hierarchically clustered, the relational interface system must 104 Do not save an entire database table, or part of it, that contains more than one record before evaluating the records of the database table. Since the received data stream is hierarchically clustered, the relational interface system recognizes 104 when a given record is a parent record and if a set of records are child records related to that parent record. Thus, the non-buffered aspect of the read is a further development over the current state of the art because of the relational interface system 104 only need to request records to evaluate the received SQL query once and save only a minimal set of records to evaluate the predicates of the received SQL query when executing the JOIN operations of the received SQL query.
Die nächsten beiden Komponenten des relationalen Schnittstellensystems 104, die die SQL-Abfrage verarbeiten, umfassen den SQL-Abfrageplaner 210 und den Plandurchführungsvorbereiter 214. Diese beiden Komponenten können einen Satz von Abfragebedingungen wirksam einsetzen, die festlegen, wann die empfangene SQL-Abfrage für das relationale Schnittstellensystem 104 gültig sein kann, um den nicht-gepufferten Lesevorgang durchzuführen. Das relationale Schnittstellensystem 104 kann so konfiguriert sein, dass, wenn irgendeine der Abfragebedingungen nicht erfüllt ist, die relationale Schnittstelle 104 den nicht-gepufferten Lesevorgang durchführt. In einer anderen Einstellung kann das relationale Schnittstellensystem 104 so konfiguriert sein, dass das relationale Schnittstellensystem 104 den nicht-gepufferten Lesevorgang durchführt, selbst wenn eine Abfragebedingung nicht erfüllt ist. Permutationen der vorhergehenden Einstellungen sind ebenfalls möglich.The next two components of the relational interface system 104 that process the SQL query include the SQL query planner 210 and the plan execution preparer 214 , These two components can leverage a set of query conditions that determine when the received SQL query for the relational interface system 104 may be valid to perform the non-buffered read. The relational interface system 104 may be configured so that if any of the query conditions are not met, the relational interface 104 performs the non-buffered read. In another setting, the relational interface system 104 be configured to use the relational interface system 104 performs the non-buffered read even if a query condition is not met. Permutations of the previous settings are also possible.
Der SQL-Abfrageplaner 210 kann konfiguriert werden, um zu bestimmen, ob die empfangene SQL-Abfrage eine oder mehrere Abfragebedingungen erfüllt. Eine erste Abfragebedingung kann festlegen, dass die SQL-Abfrage für die Durchführung des nicht-gepufferten Lesevorgangs gültig ist, wenn die in der SQL-Abfrage identifizierten Tabellen, top-down hierarchisch sind. Insbesondere kann diese erste Abfragebedingung angeben, dass die SQL-Abfrage eine gültige Abfrage ist, wenn die SQL-Abfrage die „JOIN”-Operation aufruft und die an der „JOIN”-Operation beteiligten Tabellen top-down hierarchisch sind. Die Tabellen der SQL-Abfrage können als hierarchisch top-down betrachtet werden, wenn für jede Tabelle X die an der Join-Operation beteiligt ist, jede andere Tabelle Y die an der Join-Operation beteiligt ist, entweder ein ordnungsgemäßer Vorgänger oder ein ordnungsgemäßer Nachfolger der Tabelle X in der Tabellenhierarchie ist, wobei alle anderen hierarchischen Beziehungen ausgeschlossen sind.The SQL query planner 210 can be configured to determine if the received SQL query satisfies one or more query conditions. A first query condition may specify that the SQL query is valid to perform the non-buffered read if the tables identified in the SQL query are top-down hierarchical. In particular, this first query condition may indicate that the SQL query is a valid query if the SQL query calls the "JOIN" operation and the tables involved in the "JOIN" operation are top-down hierarchical. The tables of the SQL query can be considered hierarchically top-down if, for each table X involved in the join operation, any other table Y involved in the join operation, either a proper predecessor or a proper successor Table X is in the table hierarchy, excluding all other hierarchical relationships.
Angenommen, die „JOIN”-Operation beinhaltet die Datenbanktabellen A, B, C, und D, wobei A übergeordnet oder die Wurzel der Hierarchie ist, B und D sind untergeordnete Datenbanktabellen von A, und C ist eine untergeordnete Datenbanktabelle von B. In dieser beispielhaften Hierarchie, kann eine SQL-Abfrage mit einer „JOIN”-Operation von „A JOIN B JOIN C” diese erste Abfragebedingung erfüllen, aber eine SQL-Abfrage mit einer „JOIN”-Operation von „A JOIN B JOIN D” kann diese erste Abfragebedingung nicht erfüllen, da die Tabellen B und D als Geschwister (sibling) betrachtet werden (d. h., B und D sind weder richtige Vorfahren voneinander, noch richtige Nachfolger).For example, suppose the JOIN operation includes database tables A, B, C, and D, where A is the parent or root of the hierarchy, B and D are child database tables of A, and C is a child database table of B. In this example hierarchy, an SQL query with a "JOIN" operation of "A JOIN B JOIN C" may satisfy this first query condition, but an SQL query with a "JOIN" Operation of "A JOIN B JOIN D" can not satisfy this first query condition since tables B and D are considered siblings (ie, B and D are neither true ancestors of one another nor correct successors).
Um zu bestimmen, ob die an der SQL-Abfrage beteiligten Tabellen top-down hierarchisch sind, kann der SQL-Abfrageplaner 210 mit einem Schemamanager 212 kommunizieren. Der Schemamanager 212 kann ein oder mehrere Datenbankschemata für die hierarchischen Datenspeicher 106–112 speichern. Der SQL-Abfrageplaner 210 kann ein Datenbankschema für einen oder mehrere der Datenspeicher 106–112 anfordern und diese mit Tabellen und Spalten des empfangenen Datenbankschemas mit den Tabellen vergleichen, die in der empfangenen SQL-Abfrage erscheinen. Auf diese Weise ist es nicht erforderlich, dass der SQL-Abfrageplaner 210 Daten aus den Datenspeichern 106–112 abruft, sondern er kann für diese Informationen den Schemamanager 212 nutzen.To determine whether the tables involved in the SQL query are top-down hierarchical, the SQL query planner 210 with a schema manager 212 communicate. The schema manager 212 can one or more database schemas for the hierarchical data store 106 - 112 to save. The SQL query planner 210 can create a database schema for one or more of the datastores 106 - 112 and compare them with tables and columns of the received database schema with the tables that appear in the received SQL query. In this way, it is not required that the SQL query planner 210 Data from the data stores 106 - 112 but he can use the schema manager for this information 212 use.
In einer Implementierung kann der SQL-Abfrageplaner 210 die Anordnung der Operationen in der empfangenen SQL-Abfrage ändern. So kann beispielsweise der SQL-Abfrageplaner 210 die „JOIN”-Operationen nach dem Verifizieren der ersten Bedingung (z. B. dass die Tabellen, die an den „JOIN”-Operationen beteiligt sind, top-down hierarchisch sind) so anordnen, dass jeder beteiligten Tabelle alle ihre Vorgänger vorausgehen und alle Nachfolger folgenIn one implementation, the SQL query planner 210 change the order of operations in the received SQL query. For example, the SQL query planner 210 the "JOIN" operations after verifying the first condition (e.g., that the tables involved in the "JOIN" operations are top-down hierarchical) order that each table involved precede all its predecessors, and all successors follow
Eine zweite Abfragebedingung, die der SQL-Abfrageplaner 210 auswerten kann, umfasst die Prädikate der empfangenen SQL-Abfrage. Insbesondere kann die zweite Abfragebedingung festlegen, dass die SQL-Abfrage für das Durchführen des nicht-gepufferten Lesevorgangs gültig ist, wenn mindestens ein Prädikat der SQL-Abfrage spezifiziert dass, wenn ein Datensatz einer ersten Tabelle mit Datensätzen einer zweiten Tabelle verbunden werden soll, die Datensätze der zweiten Tabelle Nachfolger des Datensatzes der ersten Tabelle sind und der Datensatz der ersten Tabelle nicht mit den Datensätzen der zweiten Tabelle verknüpft ist, die ein Nachfolger des Datensatzes der ersten Tabelle sind.A second query condition, the SQL query planner 210 can evaluate the predicates of the received SQL query. In particular, the second query condition may determine that the SQL query is valid for performing the non-buffered read if at least one predicate of the SQL query specifies that when a record of a first table is to be connected to records of a second table Second-table records are descendants of the first-table record, and the first-record record is not linked to the second-table records that are a descendant of the first-record record.
Anders ausgedrückt, kann diese zweite Abfragebedingung definieren, dass die in der „JOIN” oder in der begleitenden „WHERE” oder „ON”-Klausel angegebenen Prädikate so sein müssen, dass es eine Tabelle X und eine Tabelle Y, gibt und Tabelle X ein geeigneter Vorfahr der Tabelle Y, ist, wobei die Prädikate garantieren, dass jeder Datensatz der Tabelle X nur mit Datensätzen der Tabelle Y verknüpft ist, die Nachfolger dieses Datensatzes der Tabelle X und nicht zu Tabelle Y sind, die Nachfolger irgendeines anderen Datensatzes der Tabelle X sind. Der Schwerpunkt dieser zweiten Abfragebedingung besteht darin sicherzustellen, dass die Datensätze der Y-Tabellen eines Datensatzes von X-Tabellen nur mit diesem Datensatz von X-Tabellen und nicht mit irgendeinem anderen Datensatz von X-Tabellen verbunden sind.In other words, this second query condition may define that the predicates indicated in the "JOIN" or in the accompanying "WHERE" or "ON" clause must be such that there is a table X and a table Y, and table X. appropriate ancestor of table Y, where the predicates guarantee that each record of table X is linked only to records of table Y that are descendants of that record of table X and not to table Y, the descendants of any other record of table X. are. The emphasis of this second query condition is to ensure that the records of the Y-Tables of an X-Tables record are related only to that record of X-Tables and not to any other record of X-Tables.
SQL-Abfrage Planer 210 kann auch überprüfen, ob die empfangene SQL-Abfrage diese zweite Bedingung erfüllt, indem sie mit dem Schemamanager 212 kommuniziert. In einem Beispiel kann der SQL-Abfrageplaner 210 ein oder mehrere Datenbankschemata von dem Schemamanager 212 anfordern, um die empfangene SQL-Abfrage, unter Verwendung der hierarchischen Primär- und Fremdschlüssel der Datenbankspeicher 106–112, auszuwerten. Wie bereits erwähnt, kann bei einer Implementierung, wenn ein Tabellen-Y-Datensatz ein ordnungsgemäßer Nachfolger eines Tabellen-Y-Datensatzes ist, das Primärschlüsselattribut des Tabellen-Y-Datensatzes den Primärschlüsselwert des Datensatzes der Tabelle X als Präfix aufweisen. In einer anderen Implementierung, wenn mehrere Attribute zusammen den Primärschlüssel des Datensatzes der Tabelle X bilden (d. h., den übergeordneten Datensatz), kann der Primärschlüssel der Datensätze der Tabelle Y (d. h., den untergeordneten Datensatz) Attribute aufweisen, die dem Primärschlüssel ihrer übergeordneten Tabelle entsprechen sowie optional ein oder mehrere zusätzliche Attribute.SQL query planner 210 can also verify that the received SQL query meets this second condition by using the schema manager 212 communicated. In one example, the SQL query planner 210 One or more database schemas from the schema manager 212 request the received SQL query, using the database and database hierarchical primary and foreign keys 106 - 112 to evaluate. As mentioned earlier, in one implementation, if a Table Y record is a proper successor of a Table Y record, the primary key attribute of the Table Y record may be prefixed to the primary key value of the Table X record. In another implementation, if multiple attributes together make up the primary key of the table X record (ie, the parent record), the primary key of the records of table Y (ie, the child record) may have attributes that correspond to the primary key of their parent table and optionally one or more additional attributes.
Unter Verwendung einer oder mehrerer empfangener Datenbankschemata kann der SQL-Abfrageplaner 210 auch die Prädikate der empfangenen SQL-Abfrage vergleichen, um zu bestätigen, dass mindestens ein Prädikat einer „JOIN”-Operation ein Prädikat aufweist, das für alle Primärschlüsselattribute der Tabelle X-Datensätze äquivalent zu „X.K = Y.K”, ist. Anders gesagt, kann der SQL-Abfrageplaner 210 bestimmen, dass, wenn ein Prädikat „X.K = Y.K” festlegt, dass der Wert des X.K-Feldes ein Präfix für den Wert des Y.K-Feldes ist.Using one or more received database schemas, the SQL query planner 210 also compare the predicates of the received SQL query to confirm that at least one predicate of a "JOIN" operation has a predicate that is equivalent to "XK = YK" for all primary key attributes of the Table X records. In other words, the SQL query planner 210 determine that if a predicate "XK = YK" specifies that the value of the XK field is a prefix to the value of the YK field.
Eine weitere Abfragebedingung kann angeben, dass die empfangene SQL-Abfrage nur einen bestimmten Operationstyp enthält, der einer ersten Instanz dieses Operationstyps folgt. Insbesondere kann diese dritte Abfragebedingung festlegen, dass nach einer Instanz eines Operationstyps „LEFT OUTER JOIN” in der empfangenen SQL-Abfrage, keine anderen Variationen einer SQL-JOIN-Operation, anders als der Operationstyp „LEFT OUTER JOIN”, auftreten.Another query condition may indicate that the received SQL query contains only one particular operation type following a first instance of this operation type. In particular, this third query condition may specify that after an instance of an operation type "LEFT OUTER JOIN" in the received SQL query, no other variations of a SQL JOIN operation other than the operation type "LEFT OUTER JOIN" occur.
Der SQL-Abfrageplaner 210 kann überprüfen, ob die empfangene SQL-Abfrage diese dritte Bedingung erfüllt, indem die Operationen der empfangenen SQL-Abfrage identifiziert werden und anschließend ermittelt wird, ob irgendwelche anderen „JOIN”-Operationen, die keine „LEFT OUTER JOIN”-Operationen sind, nach einer ersten „LEFT OUTER JOIN”-Operation auftreten. Mit dieser Abfragebedingung kann der SQL-Abfrageplaner 210 die empfangene SQL-Abfrage in separate Operationen zerlegen, wenn eine „JOIN”-Operation anders als eine „LEFT OUTER JOIN”-Operation nach einer ersten „LEFT OUTER JOIN”-Operation erscheint: Operationen, die die Operation „LEFT OUTER JOIN” und alle anderen verbleibenden Operationen aufrufen. Insbesondere können die zerlegten Operationen alle Operationen umfassen, bis hin zur und einschließlich der ersten „LEFT OUTER JOIN”-Operation der empfangenen SQL-Abfrage, einschließlich jeder nachfolgenden „LEFT OUTER JOIN”-Operation bis zu, aber nicht einschließlich, der nächstfolgenden „LEFT OUTER JOIN”-Operation und alle verbleibenden Operationen.The SQL query planner 210 can check if the received SQL query this third Condition is met by identifying the operations of the received SQL query and then determining whether any other "JOIN" operations that are not "LEFT OUTER JOIN" operations occur after a first "LEFT OUTER JOIN" operation. With this query condition, the SQL query planner 210 break the received SQL query into separate operations if a "JOIN" operation other than a "LEFT OUTER JOIN" operation appears after a first "LEFT OUTER JOIN" operation: operations that perform the "LEFT OUTER JOIN" operation and call all other remaining operations. In particular, the decomposed operations may include all operations up to and including the first "LEFT OUTER JOIN" operation of the received SQL query, including any subsequent "LEFT OUTER JOIN" operation up to, but not including, the following "LEFT OUTER JOIN "operation and all remaining operations.
Eine vierte Abfragebedingung kann schließlich festlegen, dass eine SQL-Abfrage zur Durchführung eines nicht-gepufferten Lesevorgangs gültig ist, wenn für jeden Datensatz der Tabelle Y, der an einer „JOIN”-Operation der SQL-Abfrage beteiligt ist und der ein ordnungsgemäßer Nachfolger eines Datensatzes einer Tabelle X ist, wobei die Prädikate in der „ON”-Klausel für diese „JOIN”-Operation (z. B. „LEFT OUTER JOIN Y ON <Prädikate>”) gewährleisten, dass die Prädikate auf den Datensätzen der Tabelle X nicht erfüllt werden, wenn die Prädikate in den Datensätzen der Tabelle Y nicht erfüllt sind. Darüber hinaus kann diese vierte Abfragebedingung weiterhin gelten, wenn Tabelle X und Tabelle Y an einer „LEFT OUTER JOIN”-Operation beteiligt sind, wobei Tabelle X und Tabelle Y direkt miteinander verbunden sind und es gibt keine andere Tabelle zwischen Tabelle X und Tabelle Tin der gesamten JOIN-Operation.Finally, a fourth query condition may determine that an SQL query is valid to perform an un-buffered read if any record of the table Y participating in a "JOIN" operation of the SQL query is a proper successor to a query Is the record of a table X, the predicates in the "ON" clause for that "JOIN" operation (eg, "LEFT OUTER JOIN Y ON <predicates>") ensuring that the predicates on the records of table X are not met if the predicates in the records of table Y are not met. In addition, this fourth query condition may still hold if Table X and Table Y are involved in a "LEFT OUTER JOIN" operation, where Table X and Table Y are directly linked together, and there is no other table between Table X and Table Tin entire JOIN operation.
Der SQL-Abfrageplaner 210 kann überprüfen, ob die empfangene SQL-Abfrage diese vierte Abfragebedingung erfüllt, indem bestätigt wird, dass die Prädikate eine Konjunktion der Form „X.A = Y.B” (oder umgekehrt) umfassen, wobei „X.A” eine Referenz auf einen Feldwert des Datensatzes von Tabelle X ist und „ Y.B” eine Referenz auf einen Feldwert des Datensatzes von Tabelle Y. Diese vierte Bedingung legt bei der Auswertung der empfangenen SQL-Abfrage ein Kaskadierungsverhalten fest, sodass das Fehlen eines Bezugsdatensatzes für Tabelle X das Fehlen eines Bezugsdatensatzes für eine absteigende Tabelle Y von Tabelle X impliziert.The SQL query planner 210 can verify that the received SQL query satisfies this fourth query condition by confirming that the predicates comprise a conjunction of the form "XA = YB" (or vice versa), where "XA" is a reference to a field value of the record of table X. and "YB" is a reference to a field value of the record of table Y. This fourth condition determines a cascading behavior in the evaluation of the received SQL query, so that the absence of a reference record for table X indicates the absence of a descending table Y reference record Table X implies.
Beim Auswerten der Prädikatklauseln der „JOIN”-Operationen der empfangenen SQL-Abfrage können der SQL-Abfrageanalysator 208 und/oder der SQL-Abfrageplaner 210 alle „INNER JOIN”-Prädikate in der empfangenen SQL-Abfrage zusammen mit beliebigen „WHERE”-Klauselprädikate in einem einzigen Satz von Prädikaten anordnen. Insbesondere wenn der SQL-Abfrageplaner 210 eine SQL-Abfrage auswertet, die eine „JOIN”-Operation der Form „X JOIN Y” beinhaltet, können alle Prädikate, die im Abgleich mit den verfügbaren Tabellen X und Y ausgewertet werden als „JOIN”-Prädikate betrachtet werden, auch wenn sie in den „ON”-Klauseln der späteren „JOIN”-Operationen auftreten oder wenn diese Prädikate in den „WHERE”-Klauseln der empfangenen SQL-Abfrage auftreten. Obwohl das vorstehende Beispiel zwei Tabellen veranschaulicht die an der „JOIN”-Operation beteiligt sind ist es auch möglich, dass mehr als zwei Tabellen an der „JOIN”-Operation beteiligt sind und dass alle Prädikate, die gegen diese Tabellen bewertet werden können, als „JOIN”-Prädikate gelten.When evaluating the predicate clauses of the "JOIN" operations of the received SQL query, the SQL query analyzer can 208 and / or the SQL query planner 210 arrange all "INNER JOIN" predicates in the received SQL query along with any "WHERE" clause predicates into a single set of predicates. Especially if the SQL query planner 210 evaluates an SQL query that includes a "JOIN" operation of the form "X JOIN Y", all predicates that are evaluated in alignment with the available tables X and Y can be considered as "JOIN" predicates, even if they are occur in the "ON" clauses of the later "JOIN" operations or when these predicates occur in the "WHERE" clauses of the received SQL query. Although the above example illustrates two tables involved in the "JOIN" operation, it is also possible that more than two tables are involved in the "JOIN" operation, and that all predicates that can be evaluated against these tables are considered to be "JOIN" predicates apply.
Zusätzlich kann der SQL-Abfrageplaner 210 weitere Feldreferenzen in Prädikaten der empfangenen SQL-Abfrage durch äquivalente Feldreferenzen aus anderen Tabellen ersetzen, sodass die Prädikate angewendet werden können. Wenn beispielsweise Prädikate „X.A = Z.B” und „Z.B = Y.C, ” vorliegen, kann der SQL-Abfrageplaner 210 die Feldreferenz „ Y.C” mit der Feldreferenz „Z.B” im ersten Prädikat mit dem Ergebnis „X.A = Y.C”. ersetzen, dies ist ein Prädikat, welches auf die „JOIN”-Operation „X JOIN Y” angewendet werden kann, weil diese „JOIN”-Operation nur auf die Felder der Tabellen X und Y verweist. Der Abfrageplaner 210 kann in seiner Auswertung alle Prädikate enthalten, die entsprechend dem Vorhergehenden transformiert werden, obwohl die transformierten Prädikate möglicherweise nicht als solche in der empfangenen SQL-Abfrage spezifiziert worden sind.In addition, the SQL query planner 210 replace other field references in predicates of the received SQL query with equivalent field references from other tables so that the predicates can be applied. For example, if there are predicates "XA = ZB" and "ZB = YC," then the SQL query planner 210 the field reference "YC" with the field reference "ZB" in the first predicate with the result "XA = YC". replace, this is a predicate that can be applied to the "JOIN" operation "X JOIN Y" because this "JOIN" operation refers only to the fields of tables X and Y. The query planner 210 may include in its evaluation all the predicates that are transformed according to the previous one, although the transformed predicates may not have been specified as such in the received SQL query.
Der SQL-Abfrageplaner 210 kann dann die weitere Verarbeitung der empfangenen SQL-Abfrage an den Planausführungsvorbereiter 214 weiterleiten. Es ist auch möglich, dass der Planausführungsvorbereiter 214 die empfangene SQL-Abfrage gleichzeitig oder im Wesentlichen als SQL-Abfrageplaner 210 auswertet. Der Plandurchführungsvorbereiter 214 kann auch so konfiguriert werden, dass er die SQL-Abfrage in eine Lesevorgangsabfrage für die hierarchischen Datenspeicher 106–112 umwandelt.The SQL query planner 210 can then continue processing the received SQL query to the plan execution primer 214 hand off. It is also possible that the plan execution preparer 214 the received SQL query simultaneously or essentially as an SQL query planner 210 evaluates. The plan execution preparer 214 can also be configured to translate the SQL query into a read task query for the hierarchical data store 106 - 112 transforms.
In einem Beispiel kann der Plandurchführungsvorbereiter 214 die empfangene SQL-Abfrage in einen Lesevorgang umwandeln, indem er den Primärschlüsselwert des ersten Datensatzes, der in einer höchsten an der SQL-Abfrage beteiligten Tabelle erscheint (d. h. die Tabelle an oder am nächsten zur Root-Ebene), und den Primärschlüsselwert des letzten Datensatzes, der in der höchsten an der SQL-Abfrage beteiligten Tabelle erscheint, identifizieren. Der Plandurchführungsvorbereiter 214 kann einen oder mehrere Sentinelwerte angeben, die die Anfangs- und Endsätze für den Lesevorgang identifizieren. Ein Sentinelwert kann ein bestimmter Wert sein, der nicht innerhalb des zulässigen Wertbereichs für ein Aufzeichnungsmerkmal liegt, wie beispielsweise den niedrigsten möglichen Wert oder den höchstmöglichen Wert. Der Primärschlüsselwert des ersten Datensatzes kann angeben, wo eine hierarchische Datenspeicherung anzusetzen hat, und der Primärschlüsselwert des zweiten Datensatzes kann anzeigen, dass die hierarchische Datenspeicherung den Lesevorgang nach diesem Datensatz stoppen sollte.In one example, the scheduling preparer 214 convert the received SQL query to a read by displaying the primary key value of the first record that appears in a highest SQL query table (that is, the table at or closest to the root level) and the primary key value of the last record Identify the table that appears in the highest table involved in the SQL query. The plan execution preparer 214 can specify one or more sentinel values that represent the beginning and ending records for the read operation identify. A sentinel value can be a specific value that is not within the allowable value range for a recording characteristic, such as the lowest possible value or the highest possible value. The primary key value of the first record may indicate where a hierarchical data store is to be set, and the primary key value of the second record may indicate that the hierarchical data store should stop reading after that record.
In einem anderen Beispiel kann der Plandurchführungsvorbereiter 214 eine Lesevorgangsanweisung formulieren, die auf jede der an den „JOIN”-Operationen beteiligten Tabellen der empfangenen SQL-Abfrage verweist. Der Lesevorgangsanweisung kann einen Start-Sentinelwert eines ersten Datensatzes und einen entsprechenden Endwert einer beteiligten Tabelle festlegen. Auf diese Weise kann der Lesevorgang speziell anweisen, welche Datensätze die hierarchischen Datenspeicher 106–112 abrufen sollen. Unabhängig vom Aufbau des Lesevorgangs wird, da die hierarchischen Datenspeicher Datensätze in einer hierarchisch gruppierten Anordnung speichern, jeder nachgeordnete Datensatz zwischen einem Start- und dem Enddatensatz der höchsten Tabelle, die an der SQL-Abfrage beteiligt ist, gelesen und dem relationalen Schnittstellensystem 104 übermittelt.In another example, the scheduling preparer may 214 formulate a read operation statement that references each of the tables of the received SQL query involved in the "JOIN" operations. The read operation statement may specify a start sentinel value of a first record and a corresponding end value of a table involved. In this way, the read process can specifically instruct which records the hierarchical data store 106 - 112 to retrieve. Regardless of the structure of the read operation, since the hierarchical data stores store records in a hierarchically grouped arrangement, each child record is read between a start and end record of the highest table involved in the SQL query and the relational interface system 104 transmitted.
Da das relationale Schnittstellensystem 104 den hierarchisch gruppierten Datenstrom von den Datenspeichern 106 bis 112 empfängt, kann der Joinplan-Ausführer 216 so konfiguriert sein, dass er die Datensätze des empfangenen Datenstroms mit den Prädikaten der empfangenen SQL-Abfrage abgleicht. Der Joinplan-Ausführer 216 kann zu dieser Ausführung verschiedene Operationen über den empfangenen hierarchisch gruppierten Datenstrom durchführen.Because the relational interface system 104 the hierarchically grouped data stream from the data stores 106 to 112 can receive the join plan exporter 216 be configured to match the records of the received data stream with the predicates of the received SQL query. The join plan exporter 216 For this embodiment, it may perform various operations on the received hierarchically grouped data stream.
In einer Reihe von Operationen kann der Joinplan-Ausführer 216 den hierarchisch gruppierten Datenstrom in eine oder mehrere Datensatzkombinationen decodieren. Eine Datensatzkombination kann maximal einen Datensatz für jede Tabelle enthalten, die an der einen oder mehreren „JOIN”-Operationen der empfangenen SQL-Abfrage beteiligt ist. Diese anfänglichen Decodierungsoperationen können die auszuwertenden Datensatzkombinationen mit den Prädikaten der empfangenen SQL-Abfrage abgleichen. Eine Datensatzkombination kann mit den Prädikaten der empfangenen SQL-Abfrage abgeglichen werden, wenn die Datensatzkombination als vollständig erkannt wird. Eine Datensatzkombination kann als vollständige Datensatzkombination angesehen werden, wenn deren hierarchisch niedrigster Datensatz keine untergeordneten Datensätze (z. B. der Datensatz, der in der Hierarchie am tiefsten ist) mehr aufweist. Der Joinplan-Ausführer 216 kann auch Prädikate mit unvollständigen Datensatzkombinationen abgleichen, sofern die dort vorhandenen Datensätze dies unterstützen. In einer Implementierung kann das Auswerten der Prädikate mit unvollständigen Datensatzkombinationen bei der Bestimmung helfen festzustellen, ob der Joinplan-Ausführer 216 die nächste Gruppe von Nachfolgedatensätzen, die der Joinplan-Ausführer 216 von den Datensätzen 106–112 empfängt, ignoriert.In a series of operations, the join plan exporter can 216 decode the hierarchically grouped data stream into one or more record combinations. A record combination can contain a maximum of one record for each table involved in the one or more "JOIN" operations of the received SQL query. These initial decoding operations can match the record combinations to be evaluated with the predicates of the received SQL query. A record combination can be matched against the predicates of the received SQL query if the record combination is recognized as complete. A record combination can be considered a complete record combination if its lowest hierarchical record no longer has any child records (for example, the record lowest in the hierarchy). The join plan exporter 216 can also match predicates with incomplete record combinations, provided that the existing records support this. In one implementation, evaluating the predicates with incomplete record combinations may help in determining whether the join plan exporter 216 the next group of successor records that the join plan exporter 216 from the records 106 - 112 receives, ignores.
Beim Ausführen dieser Decodieroperationen kann der Joinplan-Ausführer 216 die auszuwertenden Datensatzkombinationen durch die Errichtung einer „aktuellen Datensatzkombination” festhalten, die den letzten nicht verworfenen, nicht ignorierten Datensatz, der aus den hierarchischen Datenspeichern 106–112 gelesen wird, umfassen. Wie nachstehend erörtert, kann ein Datensatz verworfen oder ignoriert werden, wenn der Datensatz, dem die „aktuelle Datensatzkombination” hinzugefügt wird, eine Verbindung (die im Vorfeld von der Dekonstruktion der Prädikate durch den SQL-Abfrageanalysator 208 abgeleitet wurde) nicht erfüllt wird.When executing these decode operations, the join plan exporter can 216 record the record combinations to be evaluated by constructing a "current record combination" containing the last non-discarded, non-ignored record from the hierarchical data stores 106 - 112 is read. As discussed below, a record may be discarded or ignored if the record to which the "current record combination" is added connects (in advance of the decoding of the predicates by the SQL query analyzer 208 was derived) is not met.
Die „aktuelle Datensatz-kombination” kann auch Vorläufer-Datensätze für den nicht verworfenen, nicht ignorierten Datensatz in der Hierarchie enthalten. Der Join-Plan-Ausführer 216 kann auch einen Speicher für erwartete Nachfolger-Datensätze des letzten nicht verworfenen, nicht ignorierten Datensatzes anlegen, wobei dieser Speicher mit dem Nullwert gesetzt werden kann. In einem Beispiel kann der Joinplan-Ausführer 216 ein Array (eindimensional, mehrdimensional usw.) zum Speichern der „aktuellen Datensatzkombination” aufbauen, wobei jedes Array-Element dem Array eines Datensatzes aus einer bestimmten Tabelle entspricht. Es ist möglich, dass einige Zellen des Arrays den NULL-Wert speichern.The "current record combination" may also include precursor records for the non-dropped, non-ignored record in the hierarchy. The join plan exporter 216 can also create an expected successor record memory of the last non-discarded, non-ignored record, and this memory can be set to the null value. In one example, the join plan exporter 216 build an array (one-dimensional, multi-dimensional, etc.) to store the "current record combination," where each array element corresponds to the array of a record from a particular table. It is possible that some cells of the array store the NULL value.
Während dieses Decodiervorgangs muss die „aktuelle Datensatzkombination” nicht notwendigerweise eine sein, die übereinstimmend erzeugt wird, wobei eine Übereinstimmung bedeutet, dass die Datensatzkombination die Prädikate der empfangenen SQL-Abfrage erfüllt. Es ist jedoch möglich, dass ein Datensatz in einer „übereinstimmenden” Datensatzkombination NULL sein kann, wenn die entsprechende Tabelle an einer „LEFT OUTER JOIN”-Operation beteiligt ist und wenn in der entsprechenden Tabelle kein Datensatz vorhanden ist, der als Ersatz für NULL verwendet werden könnte, wobei die resultierende Datensatzkombination die Prädikate, die für die „LINKE OUTER JOIN”-Operation spezifiziert sind, erfüllen würde.During this decoding process, the "current record combination" does not necessarily have to be one that is created consistently, where a match means that the record combination satisfies the predicates of the received SQL query. However, it is possible for a record in a "matched" record combination to be NULL if the corresponding table is involved in a "LEFT OUTER JOIN" operation and if there is no record in the corresponding table that substitutes for NULL where the resulting record combination would satisfy the predicates specified for the "LEFT OUTER JOIN" operation.
In einem Beispiel kann der Joinplan-Ausführer 216 die aktuelle Datensatzkombination erzeugen, wenn der Joinplan-Ausführer 216 bestimmt, dass die aktuelle Datensatzkombination abgeschlossen ist. Eine Datensatzkombination gilt als vollständig, wenn keine größeren Datensatzkombinationen vorhanden sind, die die aktuelle Datensatzkombination als Präfix enthalten. Wenn es größere Datensatzkombinationen gibt, die die aktuelle Datensatzkombination als Präfix enthalten, identifiziert der Joinplan-Ausführer 216 die größeren Datensatzkombinationen für die Produktion und nicht die kleinere.In one example, the join plan exporter 216 generate the current record combination if the join plan exporter 216 determines that the current record combination is completed. A record combination is considered complete if there are no larger record combinations that prefix the current record combination. If there are larger record combinations that contain the current record combination as a prefix, the join plan exporter identifies 216 the larger record combinations for production and not the smaller one.
Angenommen, der empfangene, hierarchisch gruppierte Datenstrom enthält die Datensätze A1, B1.3, C1.3.2, C1.3.3, B1.4, C1.4.2, A2, A3, B3.7, B3.8, C3.8.1, wobei Buchstaben auf Tabellen, Zahlen einzelner Datensätze verweisen und ein Punkt („.”) einen nachfolgen Datensatz bezeichnet. Somit ist in diesem vorangehenden Beispiel A1 ein Datensatz der Tabelle A und B1.3 ein Datensatz der Tabelle B, aber Datensatz A1 ist ein Vorgänger des Datensatzes B1.3. Entsprechend ist C1.3.2 ein Datensatz der Tabelle C und hat einen ersten Vorgänger von Datensatz B1.3 und einen zweiten Vorgänger von Datensatz A1.Assume that the received, hierarchically grouped data stream contains the data sets A1, B1.3, C1.3.2, C1.3.3, B1.4, C1.4.2, A2, A3, B3.7, B3.8, C3.8.1, where Letters on tables refer to numbers of individual records and a dot (".") Designates a subsequent record. Thus, in this previous example A1, a record of table A and B1.3 is a record of table B, but record A1 is a predecessor of record B1.3. Accordingly, C1.3.2 is a record of Table C and has a first predecessor of record B1.3 and a second predecessor of record A1.
Somit kann der Joinplan-Ausführer 216 in diesem Beispiel, wenn der Joinplan-Ausführer 216 den Datensatz A2 dekodiert, eine Datensatzkombination von „(A2)” als vollständig betrachten, da es keinen untergeordneten Datensatz B2.x gibt, um einen größeren Datensatz aus der Kombination „(A2, B2.X)” zu bilden. Im Gegensatz dazu kann der Joinplan-Ausführer 216 eine Datensatzkombination von „(A3)” nicht als abgeschlossen erkennen, da es sich bei der Datensatzkombination „(A3)” um ein Präfix der Datensatzkombination „(A3, B3.7)” handelt.Thus, the join plan exporter can 216 in this example, if the join plan exporter 216 decodes record A2, considers a record combination of "(A2)" complete because there is no child record B2.x to form a larger record from the combination "(A2, B2.X)". In contrast, the join plan exporter can 216 does not recognize a record combination of "(A3)" as completed because the record combination "(A3)" is a prefix of the record combination "(A3, B3.7)".
Jedoch kann nicht jede vollständige Datensatzkombination durch den Joinplan-Ausführer 216 als ein Datensatzergebnis für die empfangene SQL-Abfrage erzeugt werden. Die Bestimmungsanalyse „vollständiger” Datensatzkombinationen ist eine Form des Bestimmungsvorgangs, ob die aktuelle Datensatzkombination für die Produktion geeignet ist (d. h. zur weiteren Verarbeitung an die Client-Geräte 114–118 usw.). Andere Analysevorgänge können ebenfalls durchgeführt werden, wie beispielsweise ob jede beteiligte Tabellen Prädikate der empfangenen SQL-Abfrage im Rahmen der aktuellen Datensatzkombination beinhaltet oder ob die Datensatzkombination einen Eintrag für jede an der „JOIN”-Operation beteiligten Tabelle beinhaltet, der nicht verbindend für eine „LEFT OUTER JOIN”-Operation genutzt wird. Wie nachstehend erörtert, kann das Auswerten der Prädikate generell gleichzeitig als Vorgang zum Anlegen der aktuellen Datensatzkombination auftreten.However, not every complete record combination can be done by the join plan exporter 216 generated as a record result for the received SQL query. The determination analysis of "complete" record combinations is one form of determining whether the current record combination is suitable for production (ie, for further processing to the client devices 114 - 118 etc.). Other parsing operations may also be performed, such as whether each involved table includes predicates of the received SQL query within the current record combination, or whether the record combination includes an entry for each table involved in the "JOIN" operation that is not binding for a " LEFT OUTER JOIN "operation is used. As discussed below, evaluating the predicates may generally occur simultaneously as a process of creating the current record combination.
In einigen Fällen ist es nicht möglich, auf der Grundlage des aktuell empfangenen Datensatzes zu bestimmen, ob die aktuelle Datensatzkombination abgeschlossen ist. In einer Implementierung kann der Joinplan-Ausführer 216 bestimmen, ob die aktuelle Datensatzkombination abgeschlossen ist, nachdem der nächste empfangene Datensatz mit der aktuellen Datensatzkombination abgeglichen wurde. So kann beispielsweise der Joinplan-Ausführer 216 bestimmen, dass die aktuelle Datensatzkombination „(A3, B3.7”) abgeschlossen ist, wenn der nächste Datensatz B3.8 empfangen wird (und somit eine aktuelle Datensatzkombination „(A3, B3.8)” ergibt, aber nicht eine mit der Bezeichnung C3.7.X.In some cases, it is not possible to determine whether the current record combination is complete based on the currently received record. In one implementation, the join plan exporter can 216 determine if the current record combination is complete after the next received record has been matched with the current record combination. For example, the join plan exporter 216 determine that the current record combination "(A3, B3.7") is complete when the next record B3.8 is received (thus yielding a current record combination "(A3, B3.8)", but not one labeled C3.7.X.
Somit kann in einer Implementierung der Joinplan-Ausführer 216 zuerst bestimmen, ob die aktuelle Datensatzkombination abgeschlossen ist, beispielsweise durch Abgleichen des primären Schlüsselwerts des nächsten empfangenen Datensatzes mit einem oder mehreren Primärschlüsselwerten von Datensätzen der aktuellen Datensatzkombination, somit wird möglicherweise die aktuelle Datensatzkombination erzeugt, abhängig davon, ob sie die Prädikate der empfangenen SQL-Abfrage erfüllt und dann entsprechend einen neuen Datensatz aus den hierarchischen Datenspeichern 106–112 liest/decodiert.Thus, in one implementation, the join plan exporter 216 first determine whether the current record combination is complete, for example, by matching the primary key value of the next received record with one or more primary key values of records of the current record combination, thus possibly generating the current record combination, depending on whether it matches the predicates of the received SQL record. Query fulfilled and then according to a new record from the hierarchical data stores 106 - 112 read / decoded.
In einer anderen Implementierung kann der Joinplan-Ausführer 216 bestimmen, welche Tabelle dem nächsten empfangenen Datensatz entspricht, um zu bestimmen, ob die aktuelle Datensatzkombination abgeschlossen ist. Unter Bezugnahme des vorstehenden Beispiels von („A1, B1.3, C1.3.2, C1.3.3, B1.4, C1.4.2, A2, A3, B3.7, B3.8, C3.8.1”) bestimmt der Joinplan-Ausführer 216, dass die Datensatzkombination „(A3, B3.7)” dann abgeschlossen ist, wenn der nächste Datensatz im hierarchisch geclusterten Datenstrom kein C-Datensatz ist. Wird jedoch der der nächste empfangene Datensatz als C-Datensatz bestimmt, erwartet der Joinplan-Ausführer 216 aufgrund der Anordnung des hierarchisch geclusterten Datenstroms einen Datensatz mit der Form C3.7.X. Wenn also der Joinplan-Ausführer 216 einen beliebigen nicht-C-Datensatz empfängt, bedeutet dies, dass kein Datensatz mit der Form C3.7.X. existiert, da diese Datensätze nach B3.7 empfangen werden müssen, allerdings noch vor einem beliebigen anderen B- oder A-Datensatz.In another implementation, the join plan exporter may be 216 determine which table corresponds to the next received record to determine if the current record combination is complete. Referring to the above example of ("A1, B1.3, C1.3.2, C1.3.3, B1.4, C1.4.2, A2, A3, B3.7, B3.8, C3.8.1"), the join plan determines -Ausführer 216 in that the record combination "(A3, B3.7)" is completed when the next record in the hierarchically clustered data stream is not a C record. However, if the next received record is determined to be a C record, the join plan exporter expects 216 due to the arrangement of the hierarchically clustered data stream, a data set with the form C3.7.X. So if the join plan exporter 216 receiving any non-C record means that no record of the form C3.7.X. exists because these records must be received after B3.7, but before any other B or A record.
Beim Auswerten und Sammeln von Datensätzen aus dem hierarchisch geclusterten Datenstrom kann der Joinplan-Ausführer 216 auch die von dem SQL-Abfrageanalysator 208 dekonstruierten Konjunktionen bewerten. In einem Beispiel kann der Joinplan-Ausführer 216 jede der Konjunktionen für die aktuelle Datensatzkombination bewerten, die beibehalten wird. Der Joinplan-Ausführer 216 kann jede der Konjunktionen bewerten, wenn ein Datensatz zur aktuellen Datensatzkombination hinzugefügt wird. Ist eine Konjunktion nicht erfüllt, kann der Joinplan-Ausführer 216 die Datensatzkombination mit dem hinzugefügten Datensatz als eine „Fehlanpassung” erkennen. mit dem hinzugefügten Datensatz als eine „Fehlanpassung” erkennen. Danach kann der Joinplan-Ausführer 216 jeden Datensatz im empfangenen, hierarchisch geclusterten Datenstrom ignorieren und/oder verwerfen, wenn der untergeordnete Datensatz eine Fehlanpassung erkennen lässt (d. h. „Datensatz ohne Übereinstimmung”). Somit überspringt der Joinplan-Ausführer 216 effektiv Datensätze, die hierarchisch niedriger sind als der Datensatz ohne Übereinstimmung. Wenn der Joinplan-Ausführer 216 dann den nächsten Datensatz in der Hierarchie auf derselben Ebene des nicht übereinstimmenden Datensatzes oder eines Datensatzes einer Vorgängertabelle der Tabelle erreicht, die nicht mit dem Datensatz übereinstimmt, kann dieser nächste Datensatz den nicht übereinstimmenden Datensatz und die Verknüpfung ersetzen, und der Joinplan-Ausführer 216 wertet daraufhin die Verbindungselemente der empfangenen SQL-Abfrage erneut aus.When evaluating and collecting records from the hierarchically clustered data stream, the join plan exporter can 216 also from the SQL query analyzer 208 evaluate deconstructed conjunctions. In one example, the join plan exporter 216 Evaluate each of the conjunctions for the current record combination that is retained. The join plan exporter 216 can evaluate each of the conjunctions when adding a record to the current record combination. If a conjunction is not met, the join plan exporter can 216 recognize the record combination with the added record as a "mismatch". with the added Detect record as a "mismatch". After that, the join plan exporter can 216 ignore and / or discard any record in the received, hierarchically clustered data stream if the child record indicates a mismatch (ie, "record not matched"). Thus, the join plan exporter skips 216 effectively records that are hierarchically lower than the record without match. If the join plan exporter 216 then reaches the next record in the hierarchy at the same level of the mismatched record or a record of a previous table of the table that does not match the record, that next record can replace the mismatched record and link, and the join plan exporter 216 then re-evaluates the connectors of the received SQL query.
Die vorstehende Betrachtung hinsichtlich der „Unstimmigkeit”, basierend auf die Filterung eines Unterbaums im Rahmen von Fehlanpassungen findet auch für äußere Join-Konjunktionen Anwendung. Diese „Unstimmigkeit”, basierend auf der Filterung eines Unterbaums wird für fehlgeschlagene äußere Join-Konjunktionen angewendet, weil der Joinplan-Ausführer 216 aufgrund einer „Outer-Join”-Operation einen Nachfolgeeffekt erwartet.The above consideration of "disagreement" based on the filtering of a sub-tree in the context of mismatches also applies to outer join conjunctions. This "discrepancy", based on the filtering of a subtree, is applied to failed outer join conjunctions because of the join plan exporter 216 expected to have a successor effect due to an "outer join" operation.
Der Joinplan-Ausführer 216 kann die folgenden Semantiken für äußere Join-Datensätze (z. B. Datensätze für Tabellen, die in der „JOIN”-Operation enthalten sind, unter Verwendung einer „LEFT OUTER JOIN”-Operation) festlegen: Bei einer Datensatzkombination (A, B) sollte eine äußere Join-Datensatzkombination von (A, B, NULL) erzeugt werden, wenn die dritte Tabelle äußerlich verbunden ist und keine C-Datensätze vorliegen, sodass die Datensatzkombination „(A, B, C)” die äußeren Verknüpfungsbedingungen der Verknüpfungsoperation mit der dritten Tabelle erfüllt. Wenn es eine Datensatzkombination (A, B, C) gibt, für die die Prädikate aus der ON-Klausel des LEFT GUTER JOIN in Tabelle C zutreffen, aber Konjunktionen der WHERE-Klausel falsch sind, wird kein äußerer Join-Datensatz (A, B, NULL) erzeugt.The join plan exporter 216 For example, you can set the following semantics for outer join records (for example, records for tables contained in the JOIN operation using a LEFT OUTER JOIN operation): For a record combination (A, B) If an outer join-record combination of (A, B, NULL) is generated when the third table is externally connected and there are no C records, then the record combination "(A, B, C)" matches the outer join conditions of the join operation with the third table met. If there is a record combination (A, B, C) for which the predicates from the ON clause of the LEFT GOOD JOIN in Table C apply, but conjunctions of the WHERE clause are false, no outer join record (A, B , NULL).
Der Joinplan-Ausführer 216 kann diese Semantik erreichen, indem der höchste Tabellenindex beibehalten wird (z. B. eine Zahl, die einer Tabelle in der „JOIN”-Operation entspricht, die in aufsteigender Reihenfolge ausgehend von der ersten Tabelle nummeriert ist), für den der Joinplan-Ausführer 216 einen Datensatz mit der Erfüllung der anwendbaren Join-Prädikate erkannt hat. Der Joinplan-Ausführer 216 kann dann die Generierung einer Outer-Join-Datensatzkombination festlegen, wenn alle potentiell übereinstimmenden Datensätze für eine von außen verbundene Tabelle abgeglichen worden sind. Wenn der Joinplan-Ausführer 216 beispielsweise eine aktuelle Datensatzkombination (A, B...) erkennt, kann der Joinplan-Ausführer 216 entscheiden, ob ein äußerer Join-Datensatz 216 erzeugt werden soll, wenn er entweder einen Ersatz für den Datensatz A oder B aus den hierarchischen Datenspeichern 106–112 empfängt, dies würde anzeigen, dass der Joinplan-Ausführer 216 den gesamten Unterbaum unter dem Datensatz B gelesen und/oder decodiert hat.The join plan exporter 216 This semantics can be achieved by maintaining the highest table index (for example, a number that corresponds to a table in the "JOIN" operation numbered in ascending order from the first table) for which the join plan exporter 216 has recognized a record that satisfies the applicable join predicates. The join plan exporter 216 can then specify the generation of an outer join record combination when all potentially matching records for an externally linked table have been matched. If the join plan exporter 216 For example, if a current record combination (A, B ...) recognizes the join plan exporter 216 decide if an outer join record 216 should be generated if it is either a replacement for record A or B from the hierarchical data stores 106 - 112 This would indicate that the join plan exporter is receiving 216 has read and / or decoded the entire sub-tree under record B.
Wenn der höchste Tabellenindex anzeigt, dass der Joinplan-Ausführer 216 keinen Datensatz für die dritte Tabelle gefunden hat, die den äußeren Joinbedingungen entspricht, kann der Joinplan-Ausführer 216 eine Datensatzkombination aus „(A, B, 0)” erzeugen. In diesem Datensatz kann der höchste Tabellenindex auch NULL betragen, wenn der Datensatz von „(A, B, NULL)” durch den gemeinsamen Joinplan-Ausführer 216 erzeugt wird. Diese Situation kann auftreten, wenn der höchste Tabellenindex kleiner ist als der Tabellenindex der Tabelle C, wobei dies anzeigt, dass keine Datensätze der Tabelle C gefunden wurden, die die Prädikate der empfangenen SQL-Abfrage erfüllten.When the highest table index indicates that the join plan exporter 216 The join plan exporter can not find a record for the third table that matches the outer join conditions 216 create a record combination of "(A, B, 0)". In this record, the highest table index may also be NULL if the record of "(A, B, NULL)" by the common join plan exporter 216 is produced. This situation can occur when the highest table index is less than the table index of table C, indicating that no records of table C were found that satisfied the predicates of the received SQL query.
Auf diese Weise führt der Joinplan-Ausführer 216 effektiv einen nicht-gepufferten Lesevorgang der hierarchischen Datenspeicher 106–112 ohne Zwischenspeicherung durch. Wie vorstehend erläutert, entscheidet der Joinplan-Ausführer 216 über die Nichtbeachtung oder Verwerfung von Datensätzen, wie beispielsweise Datensätze, von denen der der Joinplan-Ausführer 216 weiß, dass sie einer vorhandenen Konjunktion nicht entsprechen. Da der Joinplan-Ausführer 216 zum Bestimmen, ob Datensätze dieser Tabelle Konjunktionen entsprechen, nicht eine gesamte Tabelle beibehalten muss, kann der Joinplan-Ausführer 216 nur einen kleineren Teil des Speichers dafür bestimmen, um die Datensätze des hierarchisch geclusterten Datenstroms auszuwerten. Anders als Datenbanksysteme gemäß dem gegenwärtigen Stand der Technik erfordert der Joinplan-Ausführer 216 viel weniger Aufwand, um JOIN-Operationen einer SQL-Abfrage auszuwerten.This is how the join plan exporter performs 216 effectively a non-buffered read of the hierarchical data store 106 - 112 without caching by. As discussed above, the join plan exporter decides 216 about disregarding or rejecting records, such as records, of which the join plan exporter 216 know that they do not correspond to an existing conjunction. As the join plan exporter 216 To determine whether records in this table match conjunctions, do not need to keep an entire table, the join plan exporter can 216 determine only a minor portion of the memory for evaluating the records of the hierarchically clustered data stream. Unlike current state-of-the-art database systems, the Join Plan exporter requires 216 much less effort to evaluate JOIN operations of an SQL query.
3 veranschaulicht ein Beispiel eines Nachrichtenaustauschs 302 (Message passing), der zwischen verschiedenen Komponenten und Systemen des in 2 gezeigten relationalen Schnittstellensystems 104 und gemäß den Aspekten der Offenbarung, erfolgen kann. Zunächst kann die Front-End-Benutzeroberfläche 206 eine SQL-Abfrage von den Client-Geräten 114–118 (Nachricht 304) erhalten. Die Front-End-Benutzeroberfläche 206 kann dann die empfangene SQL-Anfrage an den SQL-Abfrageanalysator 208 (Nachricht 306) übermitteln. Wie oben erläutert, kann der SQL-Abfrageanalysator 208 die Prädikate der empfangenen SQL-Abfrage analysieren und erkennen. Ferner kann der SQL-Abfrageanalysator 208 die Verbindungen der Prädikate der empfangenen SQL-Abfrage dekonstruieren. 3 illustrates an example of a message exchange 302 (Message passing), which is between different components and systems of in 2 shown relational interface system 104 and in accordance with the aspects of the disclosure. First, the front-end user interface 206 an SQL query from the client devices 114 - 118 (Message 304 ) receive. The front-end user interface 206 can then receive the received SQL query to the SQL query analyzer 208 (Message 306 ) to transfer. As explained above, the SQL Query Analyzer 208 Analyze and recognize the predicates of the received SQL query. Furthermore, the SQL Abfrageanalysator 208 deconstruct the connections of the predicates of the received SQL query.
Danach kann der SQL-Abfrageanalysator 208 eine Überprüfung der Abfragebedingungen der empfangenen SQL-Abfrage vom SQL-Abfrageplaner 210 (Nachricht 308) anfordern. Um Abfragebedingungen der empfangenen SQL-Abfrage zu bestätigen, kann der SQL-Abfrageplaner 210 ein oder mehrere Datenbankschemata von dem Schemamanager 212 (Nachricht 310/Nachricht 312) anfordern und der SQL-Abfrageplaner kann die empfangene SQL-Abfrage gegen die angeforderten Datenbankschemata (Operation 314) bewerten.After that, the SQL query analyzer can 208 a check of the query conditions of the received SQL query from the SQL query planner 210 (Message 308 ). To confirm query conditions of the received SQL query, the SQL query planner 210 One or more database schemas from the schema manager 212 (Message 310 /Message 312 ) and the SQL query planner can retrieve the received SQL query against the requested database schemata (operation 314 ).
Danach kann der SQL-Abfrageplaner 210 eine Umwandlung des Lesevorgangs der empfangenen SQL-Abfrage anfordern (Nachricht 316). Wie vorstehend erläutert, kann der Planausführungsvorbereiter 214 die Anforderung des Lesevorgangs durchführen (Operation 318).After that, the SQL query planner 210 Request a conversion of the read of the received SQL query (message 316 ). As discussed above, the plan execution preparer 214 perform the read request (operation 318 ).
Die Lesevorgangsanforderung kann an die hierarchischen Datenspeicher 106–112 übermittelt werden, was dazu führen kann, dass die hierarchischen Datenspeicher 106–112 einen hierarchisch geclusterten Datenstrom an das relationale Schnittstellensystem 104 übermittelt (Operation 320). Der Joinplan-Ausführer 216 kann die Decodierung der Datensätze innerhalb des hierarchisch geclusterten Datenstroms und deren Auswertung durchführen. Der Joinplan-Ausführer 216 kann in einem Beispiel die JOIN-Prädikate und/oder Konjunktionen von dem SQL-Abfrageanalysator 208 anfordern (Nachricht 322), die dann wiederum die angeforderten JOIN-Prädikate und/oder Konjunkte an den Joinplan-Ausführer 216 (Message 324) übermitteln können. Danach kann der Joinplan-Ausführer 216 die empfangenen Prädikate und/oder Konjunktionen über einen oder mehrere decodierte Datensätze oder Datensatzkombinationen, die aus dem hierarchisch geclusterten Datenstrom empfangenen werden, auswerten (Operation 326). Dann kann der Joinplan-Ausführer 216 eine oder mehrere Join-Operationen der empfangenen SQL-Abfrage für die Datensätze durchführen, die die empfangenen Prädikate und/oder Konjunktionen erfüllen. Der Joinplan-Ausführer 216 kann dann die Ergebnisse der Join-Operation an die Front-End-Benutzeroberfläche 206 kommunizieren (Nachricht 328), die dann die Ergebnisse an eine oder mehrere Client-Vorrichtungen 114–118, die anfänglich die SQL-Abfrage gesendet haben (Nachricht 330), kommunizieren. Wie bereits erwähnt, kann die Kommunikation der Datensatzergebnisse das Anzeigen der Datensatzergebnisse auf einer graphischen Benutzeroberfläche auf einer Befehlszeilenschnittstelle oder das übermitteln der Datensatzergebnisse über eine API oder ähnliches, umfassen.The read request can be sent to the hierarchical datastores 106 - 112 be transmitted, which can lead to hierarchical data storage 106 - 112 a hierarchically clustered data stream to the relational interface system 104 transmitted (operation 320 ). The join plan exporter 216 can perform the decoding of the data records within the hierarchically clustered data stream and their evaluation. The join plan exporter 216 In one example, the JOIN predicates and / or conjunctions from the SQL query analyzer 208 request (message 322 ), which in turn will return the requested JOIN predicates and / or conjuncts to the join plan exporter 216 (Message 324 ). After that, the join plan exporter can 216 evaluate the received predicates and / or conjunctions over one or more decoded records or record combinations received from the hierarchically clustered data stream (Operation 326 ). Then the join plan exporter 216 perform one or more join operations of the received SQL query on the records that satisfy the received predicates and / or conjunctions. The join plan exporter 216 can then see the results of the join operation to the front-end UI 206 communicate (message 328 ), which then sends the results to one or more client devices 114 - 118 that initially sent the SQL query (message 330 ) communicate. As previously mentioned, the communication of the record results may include displaying the record results on a graphical user interface on a command line interface or transmitting the record results via an API or the like.
Auf diese Weise stellt das relationale Schnittstellensystem 104 eine Weiterentwicklung gegenüber aktuellen Technologien für den Zugriff auf hierarchisch organisierte Datenspeicher dar, da der nicht-gepufferte Lesevorgang auf einem oder mehreren hierarchisch organisierten Datenspeichern durchgeführt werden kann, sodass das relationale Schnittstellensystem nicht mehrere Leseanforderungen desselben Datenspeichers durchführen muss. Darüber hinaus kann der nicht-gepufferte Lesevorgang mit einer festen Bindung an die Menge der Pufferung erreicht werden. Zusätzlich reduzieren die beschriebenen Systeme und Verfahren die verstrichene Zeit zwischen dem Zeitpunkt einer Anforderung von einem Client-Gerät zum System, bis zu dem Zeitpunkt, an dem das Client-Gerät die Antwort auf die Anforderung erhalten hat.In this way, the relational interface system provides 104 This is a further development over current technologies for accessing hierarchically organized datastores because the non-buffered read can be performed on one or more hierarchically organized datastores so that the relational interface system does not have to perform multiple read requests of the same datastore. In addition, the non-buffered read can be achieved with a fixed link to the amount of buffering. In addition, the described systems and methods reduce the elapsed time between the time a request from a client device to the system until the time the client device received the response to the request.
Dementsprechend reduzieren die durch das relationale Schnittstellensystem 104 durchgeführten Lese- und Verbindungsvorgänge den Verbrauch der Ressourcen (z. B. Prozessorzyklen, Such-/Lesezeiten, Speicher mit wahlfreiem Zugriff usw.), die benötigt werden, um mehrere Datenbanktabellen abzurufen und zu verknüpfen, erheblich, wenn eine oder mehrere SQL-Abfragen empfangen werden, wie etwa SQL-Abfragen mit der „JOIN”-Operation, „LEFT OUTER JOIN”-Operation und anderen ähnlichen Operationen.Accordingly, those through the relational interface system reduce 104 For example, when performing read and connect operations, the consumption of resources (eg, processor cycles, search / read times, random access memory, etc.) needed to retrieve and link multiple database tables significantly, if one or more SQL queries such as SQL queries with the "JOIN" operation, "LEFT OUTER JOIN" operation, and other similar operations.
Auch, wenn diese und andere Variationen und Kombinationen der oben beschriebenen Merkmale verwendet werden können, ohne von dem in den Ansprüchen definierten Gegenstand abzuweichen, ist die vorstehende Beschreibung der Ausführungsformen nur als Veranschaulichung und nicht als Einschränkung des in den Ansprüchen definierten Gegenstands anzusehen. Es wird ferner darauf hingewiesen, dass die Angabe von Beispielen (sowie Formulierungen wie „zum Beispiel”, „einschließlich” und dergleichen) nicht als Einschränkung des beanspruchten Gegenstands auf die spezifischen Beispiele auszulegen ist; vielmehr sollen die Beispiele nur einige von vielen möglichen Aspekte veranschaulichen.Also, if these and other variations and combinations of the features described above can be used without departing from the subject matter defined in the claims, the foregoing description of the embodiments is to be considered as illustrative only and not as a limitation on the subject matter defined in the claims. It should also be understood that the indication of examples (as well as phrases such as "for example", "including" and the like) should not be construed as limiting the claimed subject matter to the specific examples; rather, the examples are only intended to illustrate some of many possible aspects.
ZITATE ENTHALTEN IN DER BESCHREIBUNG QUOTES INCLUDE IN THE DESCRIPTION
Diese Liste der vom Anmelder aufgeführten Dokumente wurde automatisiert erzeugt und ist ausschließlich zur besseren Information des Lesers aufgenommen. Die Liste ist nicht Bestandteil der deutschen Patent- bzw. Gebrauchsmusteranmeldung. Das DPMA übernimmt keinerlei Haftung für etwaige Fehler oder Auslassungen.This list of the documents listed by the applicant has been generated automatically and is included solely for the better information of the reader. The list is not part of the German patent or utility model application. The DPMA assumes no liability for any errors or omissions.
Zitierte Nicht-PatentliteraturCited non-patent literature
-
IEEE 802.11 [0057] IEEE 802.11 [0057]
-
IEEE 802.11a [0057] IEEE 802.11a [0057]
-
IEEE 802.11b [0057] IEEE 802.11b [0057]