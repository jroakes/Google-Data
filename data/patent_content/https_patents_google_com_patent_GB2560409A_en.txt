GB2560409A - Executing computational graphs on graphics processing units - Google Patents
Executing computational graphs on graphics processing units Download PDFInfo
- Publication number
- GB2560409A GB2560409A GB1800176.8A GB201800176A GB2560409A GB 2560409 A GB2560409 A GB 2560409A GB 201800176 A GB201800176 A GB 201800176A GB 2560409 A GB2560409 A GB 2560409A
- Authority
- GB
- United Kingdom
- Prior art keywords
- operations
- computational graph
- data
- data entity
- buffer parameters
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Withdrawn
Links
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T1/00—General purpose image data processing
- G06T1/20—Processor architectures; Processor configuration, e.g. pipelining
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/10—Interfaces, programming languages or software development kits, e.g. for simulating neural networks
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/901—Indexing; Data structures therefor; Storage structures
- G06F16/9024—Graphs; Linked lists
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/50—Allocation of resources, e.g. of the central processing unit [CPU]
- G06F9/5005—Allocation of resources, e.g. of the central processing unit [CPU] to service a request
- G06F9/5027—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resource being a machine, e.g. CPUs, Servers, Terminals
- G06F9/5038—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resource being a machine, e.g. CPUs, Servers, Terminals considering the execution order of a plurality of tasks, e.g. taking priority or time dependency constraints into consideration
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/06—Physical realisation, i.e. hardware implementation of neural networks, neurons or parts of neurons
- G06N3/063—Physical realisation, i.e. hardware implementation of neural networks, neurons or parts of neurons using electronic means
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/10—Interfaces, programming languages or software development kits, e.g. for simulating neural networks
- G06N3/105—Shells for specifying net layout
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
Abstract
Generating a data entity that causes a processing unit to process a computational graph, including the actions of receiving data identifying a computational graph, the computational graph including a plurality of nodes representing operations; obtaining compilation artifacts for processing the computational graph on a processing unit; and generating a data entity from the compilation artefacts, wherein the data entity, when invoked, causes the processing unit to process the computational graph by executing the operations represented by the plurality of nodes. A directed acyclic graph (DAG) representing a user defined neural network may be compiled for processing between multiple graphics processing units (GPUs) and central processing units (CPUs). A sequentially numbered list of operations representing the processes required to operate the neural network and a sequentially numbered list of data representing weights of nodes in the network may be used to assign data to the processors.
Description
(56) Documents Cited:
None (32) 06.01.2017 (33) US (58) Field of Search:
Other: No search performed: Section 17(5)(b) (71) Applicant(s):
Google LLC
1600 Amphitheatre Parkway, Mountain View 94043, California, United States of America (72) Inventor(s):
Jingyue Wu
Christopher Daniel Leary (74) Agent and/or Address for Service:
Boult Wade Tennant LLP
Verulam Gardens, 70 Gray's Inn Road, LONDON, WC1X 8BT, United Kingdom (54) Title of the Invention: Executing computational graphs on graphics processing units
Abstract Title: Compiling and executing computational graphs representing neural networks on graphics processing units (GPUs) (57) Generating a data entity that causes a processing unit to process a computational graph, including the actions of receiving data identifying a computational graph, the computational graph including a plurality of nodes representing operations; obtaining compilation artifacts for processing the computational graph on a processing unit; and generating a data entity from the compilation artefacts, wherein the data entity, when invoked, causes the processing unit to process the computational graph by executing the operations represented by the plurality of nodes. A directed acyclic graph (DAG) representing a user defined neural network may be compiled for processing between multiple graphics processing units (GPUs) and central processing units (CPUs). A sequentially numbered list of operations representing the processes required to operate the neural network and a sequentially numbered list of data representing weights of nodes in the network may be used to assign data to the processors.
Input Buffer Parameters
130
FIG. 1B
1/5
I
Data Entity Generator
105
Compiler
103
Computational Graph System
100
Client
102
FIG. 1A
2/5
FIG. 1B
3/5
FIG. 2
4/5
FIG. 3
5/5
FIG. 4
EXECUTING COMPUTATIONAL GRAPHS ON GRAPHICS PROCESSING UNITS
BACKGROUND [0001] This specification relates to processing computational graphs representing neural networks.
[0002] Neural networks are machine learning models that employ one or more layers of models to generate an output, e.g., one or more classifications, for a received input. Some neural networks include one or more hidden layers in addition to an output layer. The output of each hidden layer is used as input to the next layer in the network, i.e., the next hidden layer or the output layer of the network. Each layer of the network generates an output from a received input in accordance with current values of a respective set of parameters for the layer.
SUMMARY [0003] This specification generally describes a system implemented as computer programs on one or more computers in one or more locations that generates a data entity. When the data entity is invoked, the data entity causes a graphic processing unit (GPU) to process a computational graph by executing operations associated with the computational graph.
[0004] In general, one innovative aspect of the subject matter described in this specification can be embodied in a method of operations comprising: receiving data identifying a computational graph, the computational graph including a plurality of nodes representing operations; obtaining compilation artifacts for processing the computational graph on a processing unit; and generating a data entity from the compilation artifacts, wherein the data entity, when invoked, causes the processing unit to process the computational graph by executing the operations represented by the plurality of nodes.
[0005] The foregoing and other embodiments can each optionally include one or more of the following features, alone or in combination. In particular, one embodiment includes all the following features in combination. The compilation artifacts further include: buffer data representing a plurality of buffer parameters and associations between the plurality of buffer parameters and the operations, each of the plurality of buffer parameters being associated with a respective operation of the operations. The compilation artifacts further include: respective logical numbers assigned to the plurality of buffer parameters, and data specifying associations between the logical numbers and the operations represented by the plurality of nodes. The compilation artifacts further include: a data structure representing (i) a sequence of operations and (ii) dependencies between the operations. The data structure is a Directed Acyclic Graph (DAG). The method further includes maintaining a plurality of libraries, each of the plurality of libraries storing one or more sub-routines. The compilation artifacts further include: library data representing a plurality of buffer parameters and associations between the plurality of buffer parameters and the plurality of libraries, each of the plurality of buffer parameters being associated with a respective library of the plurality of libraries.
The compilation artifacts further include: machine code that is configured to process the computational graph. The operations are operations for processing an input of a neural network through one or more layers of the neural network to generate an output of the neural network. The operations are operations for training a neural network by adjusting values of parameters of the neural network. The processing unit is a GPU or a central processing unit (CPU).
[0006] In general, another innovative aspect of the subject matter described in this specification can be embodied in a method of operations comprising: receiving input buffer parameters that are user-specific inputs to a computational graph, the computational graph including a plurality of nodes representing operations; receiving a data entity including buffer data representing (i) a plurality of buffer parameters including the input buffer parameters and (ii) associations between the plurality of buffer parameters and the operations; and invoking the data entity with the input buffer parameters to cause a processing unit to process the computational graph in accordance with the input buffer parameters by executing the operations.
[0007] The foregoing and other embodiments can each optionally include one or more of the following features, alone or in combination. In particular, one embodiment includes all the following features in combination. The invoking the data entity with the input buffer parameters includes: based on the data entity, identifying one or more operations from the computational graph, the one or more operations corresponding to the input buffer parameters, and enqueuing the one or more operations on the processing unit to process the computational graph. The operations include a plurality of groups of operations and the data entity includes a data structure representing (i) a plurality of streams, each stream representing a sequence of operations and (ii) dependencies between the operations, and wherein invoking the data entity with the input buffer parameters comprising: based on the data entity, identifying a plurality of streams from the computational graph, each stream being associated with a respective group of operations from the operations, for each stream of the plurality of streams, enqueuing the respective group of operations into the stream that is associated with the respective group of operations, and based on the data entity, defining dependencies between the plurality of groups of operations. The processing unit is a GPU or a CPU.
[0008] The subject matter described in this specification can be implemented in particular embodiments so as to realize one or more of the following advantages. A conventional compiling system requires a host CPU to process operations. In the conventional compiling system, a GPU is idle while the host CPU is processing some operations. Thus, the conventional compiling system inefficiently uses the hardware resources of the GPU. Unlike the conventional compiling system, the system described in this specification generates a data entity that includes all necessary descriptions for executing operations. In particular, the data entity is generated at compilation time, and then the data entity can be invoked at run time to cause the GPU to process the computational graph. This allows all of the operations represented by the computational graph to be enqueued on the GPU as a whole, thus improves the efficiency of the machine including a GPU.
[0009] The details of one or more embodiments of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
BRIEF DESCRIPTION OF THE DRAWINGS [0010] FIG. 1A illustrates an example computational graph system for generating a data entity from a computational graph.
[0011] FIG. IB illustrates example machines for processing a computational graph.
[0012] FIG. 2 is a flow chart of an example process for generating a data entity from a computational graph.
L0013J FIG. 3 is a flow chart of an example process for invoking a data entity to process a computational graph by executing operations represented by the computational graph.
[0014] FIG. 4 is a flow chart of an example process for invoking a data entity to process a computational graph by executing operations represented by the computational graph.
[0015] Like reference numbers and designations in the various drawings indicate like elements.
DETAILED DESCRIPTION [0016] This specification generally describes a computational graph system that generates a data entity that, when invoked, causes a graphics processing unit (GPU) to process a computational graph by executing operations represented by the computational graph. In particular, when the data entity is invoked with input buffer parameters, the data entity is enqueued into a GPU as a whole and the GPU processes the computational graph in accordance with the input buffer parameters.
[0017] FIG. 1A illustrates an example computational graph system 100 for generating a data entity from a computational graph . The computational graph system 100 is an example of a system implemented as computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below can be implemented.
[0018] A user of a client 102 can request operations be performed on a computational graph representing a neural network. The client 102 can be an application running on a computer. As part of the request, the client 102 provides data identifying a computational graph to the computational graph system 100 and specifies types of operations to be performed on the computational graph. For example, the request can identify a computational graph representing an inference for a particular neural network and can identify an input on which the inference should be performed. As another example, the request can identify a computational graph representing a neural network to be trained and an input, such as training data, on which the training should be performed.
[0019] The computational graph system 100 receives data including a computational graph as input. The computational graph represents computations of a machine learning model with nodes representing operations. In particular, a computational graph expresses computations, e.g. of a machine learning model, with nodes representing operations and directed edges representing data dependencies between operations. An incoming edge to a node represents a flow of an input into the node, i.e., an input argument to the operation represented by the node. If all arguments required for an operation are available to the operation node, the node is enabled and can be executed.
[0020] An outgoing edge from a node represents a flow of an output of the operation represented by the node to be used as an input to an operation represented by another node. Thus, a directed edge connecting a first node in the graph to a second node in the graph indicates that an output generated by the operation represented by the first node is used as an input to the operation represented by the second node.
[0021] In some implementations, the operations represented in the computational graph are linear algebraic operations, e.g., matrix multiply, neural network operations, or operations for a different kind of machine learning model. A neural network is a machine learning model that employs one or more layers of nonlinear units to predict an output for a received input. Some neural networks are deep neural networks that include one or more hidden layers in addition to an output layer. The output layer of each hidden layer is used as input to another layer in the network, i.e., another hidden layer, the output layer, or both. Some layers of the network generate an output from a received input in accordance with a current value of a respective set of parameters, while other layers of the network may not have parameters. [0022] The operations represented by the computational graph may be operations necessary for the neural network to compute an inference, i.e., to process an input through the layers of the neural network to generate a neural network output for the input. Additionally or alternatively, the operations represented by the computational graph may be operations necessary to train the neural network by performing a neural network training procedure to adjust the values of the parameters of the neural network, e.g., to determine trained values of parameters from initial values of the parameters using backpropagation. In some cases, e.g., during training of the neural network, the operations represented by the computational graph can include operations performed by multiple replicas of the neural network.
[0023] By way of illustration, a neural network layer that receives an input from a previous layer can use a parameter matrix to perform a matrix multiplication between the parameter matrix and the input. In some cases, the matrix multiplication can be represented as multiple nodes in the computational graph. For example, a matrix multiplication can be divided into multiple multiplication and addition operations, and each operation can be represented by a different node in the computational graph. The operation represented by each node can generate a respective output, which flows on a directed edge to a subsequent node. After the operation represented by a final node generates a result of the matrix multiplication, the result flows, on a directed edge, to another node. The result is equivalent to an output of the neural network layer that performs the matrix multiplication.
[0024] In some other cases, the matrix multiplication is represented as one node in the graph. The operations represented by the node can receive, as inputs, an input tensor on a first directed edge and a weight tensor, e.g., a parameter matrix, on a second directed edge.
The node can process, e.g., perform a matrix multiplication of, the input and weight tensors to output, on a third directed edge, an output tensor, which is equivalent to an output of the neural network layer.
[0025] Other neural network operations that may be represented by nodes in the computational graph include other mathematical operations, e.g., subtraction, division, and gradient computations; array operations, e.g., concatenate, splice, split, or rank; and neural network building block operations, e.g., SoftMax, Sigmoid, rectified linear unit (ReLU), or convolutions.
[0026] In an example system, one or more sets of nodes in the computational graph may represent operations that control the dataflow through a computational graph. The one or more sets of nodes may, for instance, represent conditional, recursive, and/or iterative control flow statements including: if statements, while loops, do-while loops, for loops for-each loops, or nested control flow statements that include a combination of these statements.
[0027] The one or more sets of nodes in the computational graph may represent some operations that can translate into operations of high performance libraries which contain high performance implementations of linear algebraic, e.g., matrix multiply, or neural network operations, e.g., backward convolution.
[0028] In an example compilation system, the compilation system fuses multiple operations, into a fusion operation that can be translated into a call at code generation time that performs all the fused operations. This fusion process produces efficient code for devices such as CPUs or GPUs.
[0029] The computational graph system 100 includes a compiler 103 and a data entity generator 105. The compiler 103 can translate the computational graph of operations to produce machine code that, when executed by one or more devices, causes the devices to perform the operations represented by the computational graph. In some implementations, a machine can include one or more devices, e.g., GPUs and CPUs. A GPU can be controlled by a host CPU. The GPU receives various requests from the host program operated by the host CPU. For example, the GPU can receive requests for launching single data-parallel subroutines at a time, for marking points of interests in a sequence of launches, or for allocating or deallocating GPU memory that is a dedicated memory on the GPU device.
[0030] In particular, when the device on which a computational graph is to be executed is a GPU, the compiler 103 generates compilation artifacts for processing the computational graph on a GPU. The compilation artifacts include all descriptions necessary to execute the operations represented by the nodes of the computational graph. In some implementations, the compilation artifacts include machine code, a data structure, buffer data, and library data. [0031] The machine code is generated to process the computational graph. For example, the machine code can be generated for the nodes of the computational graph, a sequence of the operations in the computational graph, and array sizes of the operations in the computational graph. Since this machine code is generated for a particular computational graph, the machine code does not need to account for all possible array sizes of operations. Thus, the machine code can improve the processing speed. The machine code is used for the GPU to process the computational graph. For example, the GPU can execute particular operations represented by the computational graph using the machine code. In some implementations, the machine code may not include code for a CPU. Even if the machine code does not include code for a CPU, the GPU can execute the operations by invoking a data entity. The details of the data entity will be described in greater detail below with reference to FIG. IB.
[0032] In some implementations, the compilation artifacts include the data structure. In some implementations, the data structure can be a DAG. The data structure may represent (i) a sequence of the operations represented by the nodes of the computational graph and (ii) dependencies between the operations.
[0033] In some implementations, the compilation artifacts include buffer data. The buffer data specifies which operation is executed on which buffer when the GPU processes the computational graph by executing the operations represented by the computational graph.
The buffer data represents buffer parameters and associations between the buffer parameters and the operations. In some implementations, the buffer parameters can be logical numbers. For example, a respective logical number can be assigned to each buffer and a particular operation can be operated on a particular buffer by specifying the logical number assigned to the particular buffer.
[0034] In some implementations, the compilation artifacts include library data. The library data represents which GPU library should be called for a particular operation. In some implementations, the library data can also represent which buffer is used for which GPU library. Like the buffer data, respective logical numbers can be assigned to each library and a particular GPU library can be called for a particular buffer by specifying the logical number assigned to the particular buffer.
[0035] The data entry generator 105 generates a data entity from the compilation artifacts. The data entity may include all descriptions necessary to execute the operations represented by the nodes of the computational graph. For example, all the compilation artifacts described above can be bundled together to form the data entity. As a result, the data entity includes the machine code, the data structure, e.g., DAG, the buffer data, and the library data. In some implementations, characteristics of the machine code, the data structure, the buffer data, and the library data in the compilation artifacts can be preserved in the data entry. For example, dependencies between the operations in the compilation artifacts can be preserved in the data entry. In some implementations, the data entry can be loaded into a memory of a machine. [0036] The computational graph system 100 provides the data entity to one of machines 160-166 over a data communication network 114. Examples of machines 160-166 may include a computing device, a personal computer, a mobile device, and a server. Each machine may, for example, include one or more devices 120-126, such as a GPU and a CPU. Referring to FIG. 1A, the machines 160-166 respectively include devices 120-126, e.g., GPUs. Since the data entity includes all the descriptions necessary to execute the operations, the machine that receives the data entity can cause a device, e.g., a GPU, to process the entire computational graph using the data entity. In some implementations, since all necessary description, for example to configure the GPU and buffers, are already determined at compile time and included in the data entity, the GPU can proceed processing the entire computational graph so that frequent interaction between the GPU and a host CPU, as typical in conventional systems, can be reduced or avoided. When the data entity is invoked, the device, e.g., a GPU, processes the computational graph by executing the operations represented by the nodes of the computational graph and generate an output. The machine including the device can return the output to the computational graph system 100, which can return the requested output to the client 102. In some implementations, the network 114 can be local area network (FAN) or wide area network (WAN). In some implementations, the machines 160-166 can additionally include a memory, e.g., a random access memory (RAM), for storing instructions and data and a processor for executing stored instructions. Generally, each machine is a hardware resource that performs operations independent of other machines. [0037] FIG. IB illustrates example machines 160-166 and example devices 120-126 for processing a computational graph. In FIG. IB, the machines 160-166 respectively include the devices 120-126, e.g., GPUs. The machine 160 receives input buffer parameters 130.
The input buffer parameters 130 are user-specific inputs to a computational graph. In addition, the machines 160-166 can receive the data entity from the computational graph system 100. In this example, the machine 160 that includes the device 120 receives the data entity from the computational graph system 100. The machine 160 invokes the data entity with the input buffer parameters and causes the device 120 to process the computational graph. Since the data entity is generated from the compilation artifacts including buffer data, the data entity includes the buffer data. The data entity includes the input buffer parameters and associations between the input buffer parameters and the operations. Thus, the operations from the computational graph can be identified based on the input buffer parameters. The operations are enqueued on the device 120 as a whole. When the operations are enqueued on the device 120, the device 120 processes the computational graph by executing the enqueued operations and generates an output. The machine 160 return the output to the computational graph system 100, which can return the output to the client 102. [0038] In some implementations, multiple machines 160-166 can respectively receive the input buffer parameters 130 and the data entity. In this example, the operations are enqueued into each of the devices 120-126 and the devices 120-126 can simultaneously process the computational graph by executing the operations. The devices 120-126 generates respective outputs and the machines 160-166 return the outputs to the computational graph system 100. [0039] FIG. 2 is an example flow chart for generating a data entity from a computational graph. In some implementations, the generation of the data entity is carried out in the context of a compilation task ahead of processing the computational graph. In some examples, the generation is carried out on a host CPU and the processing of the computational graph occurs, based on the generated data entity, on a GPU.
[0040] For convenience, the process 200 will be described as being performed by a system of one or more computers, located in one or more locations, and programmed appropriately in accordance with this specification. For example, an example computational graph system 100 of FIG. 1 A, appropriately programmed, can perform the process 200.
[0041] The system receives data identifying a computational graph (202). The computational graph may include nodes representing operations.
[0042] The system obtains compilation artifacts for processing the computational graph on a GPU (204). The compilation artifacts are generated by a compiler that compiles the computational graph for processing by the GPU. The compilation artifacts include descriptions necessary to execute the operations represented by the nodes of the computational graph. For example, the compilation artifacts include machine code, a data structure representing multiple sequences of operations and dependencies between the operations, buffer data, and library data.
[0043] The system generates a data entity from the compilation artifacts (206). When the data entity is invoked, the data entity causes the GPU to process the computational graph by executing the operations represented by the plurality of nodes. The data entity may include all descriptions necessary to execute the operations represented by the nodes of the computational graph. For example, all the compilation artifacts described above can be bundled together to form the data entity. As a result, the data entity includes the machine code, the data structure, e.g., DAG, the buffer data, and the library data to cause the GPU to process the computational graph by executing the operations. In some implementations, characteristics of the machine code, the data structure, the buffer data, and the library data in the compilation artifacts can be preserved in the data entry. For example, dependencies between the operations in the compilation artifacts can be preserved in the data entry. In some implementations, the data entry can be loaded into a memory of a machine.
[0044] FIG. 3 is an example flow chart for invoking a data entity to process a computational graph by executing operations represented by the computational graph. For convenience, the process 300 will be described as being performed by one or more GPUs.
For example, example machines 160-166 of FIG. IB, appropriately programmed, can perform the process 300.
[0045] The machine receives input buffer parameters (302). The machine can include one or more devices such as a GPU and a CPU. The input buffer parameters are user-specific inputs to a computational graph. In some implementations, the machine can receive the input buffer parameters from a user. The computational graph includes a plurality of nodes representing operations.
[0046] The machine receives a data entity (304). The data entity may include buffer data representing (i) a plurality of buffer parameters including the input buffer parameters and (ii) associations between the plurality of buffer parameters and the operations. In some implementations, the machine can receive the data entity from a computational graph system. [0047] The machine invokes the data entity with the input buffer parameters (306). When the data entity is invoked, the data entity causes a device, e.g., a GPU, to process the computational graph in accordance with the input buffer parameters by executing the operations. In some implementations, operations from the computational graph corresponding to the input parameter buffers can be identified based on the data entity. The machine enqueues the identified operations as a whole into the device to process the computational graph.
[0048] FIG. 4 is an example flow chart for invoking a data entity to process a computational graph by executing operations represented by the computational graph. For convenience, the process 400 will be described as being performed by one or more GPUs.
For example, example machines 160-166 of FIG. IB, appropriately programmed, can perform the process 400. The machines can include one or more devices such as a GPU and a CPU. In this example, the operations include multiple groups of operations and the data entity includes a data structure representing (i) streams and (ii) dependencies between the operations in the streams.
[0049] The machine, based on the data entity, identifies streams from the computational graph (402). Each stream can be associated with a respective group of operations from the operations.
[0050] The machine, for each stream, enqueues the respective group of operations into the stream that is associated with the respective group of operations (404). For each stream, the machine can identify the respective group of operations based on the date entity. Once the machine identifies the respective groups of operations for the streams, the machine enqueues the respective group of operations into each stream.
[0051] The machine, based on the data entity, defines dependencies between the plurality of groups of operations (406). The data entity includes the data structure representing dependencies between the operations. From the dependencies between the operations, dependencies between the plurality of groups of operations can be determined. In some implementations, dependencies from all of the streams can be made to a particular stream. This particular stream can be defined as a primary stream.
[0052] Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non transitory program carrier for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them. The computer storage medium is not, however, a propagated signal.
[0053] The term “data processing apparatus” encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit). The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.
[0054] A computer program (which may also be referred to or described as a program, software, a software application, a module, a software module, a script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a stand alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub programs, or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
[0055] As used in this specification, an “engine,” or “software engine,” refers to a software implemented input/output system that provides an output that is different from the input. An engine can be an encoded block of functionality, such as a library, a platform, a software development kit (“SDK”), or an object. Each engine can be implemented on any appropriate type of computing device, e.g., servers, mobile phones, tablet computers, notebook computers, music players, e-book readers, laptop or desktop computers, PDAs, smart phones, or other stationary or portable devices, that includes one or more processors and computer readable media. Additionally, two or more of the engines may be implemented on the same computing device, or on different computing devices.
[0056] The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
[0057] Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit. Generally, a central processing unit will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few. [0058] Computer readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
[0059] To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user’s client device in response to requests received from the web browser.
[0060] Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), e.g., the Internet.
[0061] The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
[0062] While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
[0063] Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
[0064] Further implementations are summarized in the following examples:
[0065] Example 1: A method comprising: receiving data identifying a computational graph, the computational graph including a plurality of nodes representing operations; obtaining compilation artifacts for processing the computational graph on a processing unit; and generating a data entity from the compilation artifacts, wherein the data entity, when invoked, causes the processing unit to process the computational graph by executing the operations represented by the plurality of nodes.
[0066] Example 2: The method of example 1, wherein the compilation artifacts further include: buffer data representing a plurality of buffer parameters and associations between the plurality of buffer parameters and the operations, each of the plurality of buffer parameters being associated with a respective operation of the operations.
[0067] Example 3: The method of example 2, wherein the compilation artifacts further include: respective logical numbers assigned to the plurality of buffer parameters, and data specifying associations between the logical numbers and the operations represented by the plurality of nodes.
[0068] Example 4: The method of one of examples 1 to 3, wherein the compilation artifacts further include: a data structure representing (i) a sequence of operations and (ii) dependencies between the operations.
[0069] Example 5: The method of example 4, wherein the data structure is a Directed Acyclic Graph.
[0070] Example 6: The method of one of examples 1 to 5, further comprising: maintaining a plurality of libraries, each of the plurality of libraries storing one or more sub-routines. [0071] Example 7: The method of example 6, wherein the compilation artifacts further include: library data representing a plurality of buffer parameters and associations between the plurality of buffer parameters and the plurality of libraries, each of the plurality of buffer parameters being associated with a respective library of the plurality of libraries.
[0072] Example 8: The method of one of examples 1 to 7, wherein the compilation artifacts further include: machine code that is configured to process the computational graph.
[0073] Example 9: The method of one of examples 1 to 8, wherein the operations are operations for processing an input of a neural network through one or more layers of the neural network to generate an output of the neural network.
[0074] Example 10: The method of one of examples 1 to 9, wherein the operations are operations for training a neural network by adjusting values of parameters of the neural network.
[0075] Example 11: The method of one of examples 1 to 10, wherein the processing unit is a graphic processing unit (GPEf) or a central processing unit (CPEf).
[0076] Example 12: A method comprising, receiving input buffer parameters that are userspecific inputs to a computational graph, the computational graph including a plurality of nodes representing operations; receiving a data entity including buffer data representing (i) a plurality of buffer parameters including the input buffer parameters and (ii) associations between the plurality of buffer parameters and the operations; and invoking the data entity with the input buffer parameters to cause a processing unit to process the computational graph in accordance with the input buffer parameters by executing the operations.
[0077] Example 13: The method of example 12, wherein invoking the data entity with the input buffer parameters comprising: based on the data entity, identifying one or more operations from the computational graph, the one or more operations corresponding to the input buffer parameters, and enqueuing the one or more operations on the processing unit to process the computational graph.
[0078] Example 14: The method of example 12 or 13, wherein the operations include a plurality of groups of operations and the data entity includes a data structure representing (i) a plurality of streams, each stream representing a sequence of operations and (ii) dependencies between the operations, and wherein invoking the data entity with the input buffer parameters comprising: based on the data entity, identifying a plurality of streams from the computational graph, each stream being associated with a respective group of operations from the operations, for each stream of the plurality of streams, enqueuing the respective group of operations into the stream that is associated with the respective group of operations, and based on the data entity, defining dependencies between the plurality of groups of operations.
[0079] Example 15: The method of one of examples 12 to 14, wherein the processing unit is a GPU or a CPU.
[0080] Example 16: A system comprising one or more computers and one or more storage devices storing instructions that when executed by the one or more computers cause the one or more computers to perform system operations comprising: receiving data identifying a computational graph, the computational graph including a plurality of nodes representing operations; obtaining compilation artifacts for processing the computational graph on a processing unit; and generating a data entity from the compilation artifacts, wherein the data entity, when invoked, causes the processing unit to process the computational graph by executing the operations represented by the plurality of nodes.
[0081] Example 17: The system of example 16, wherein the compilation artifacts further include: buffer data representing a plurality of buffer parameters and associations between the plurality of buffer parameters and the operations, each of the plurality of buffer parameters being associated with a respective operation of the operations.
[0082] Example 18: The system of example 17, wherein the compilation artifacts further include: respective logical numbers assigned to the plurality of buffer parameters, and data specifying associations between the logical numbers and the operations represented by the plurality of nodes.
[0083] Example 19: The system of one of examples 16 to 18, wherein the compilation artifacts further include: a data structure representing (i) a sequence of operations and (ii) dependencies between the operations.
[0084] Example 20: The system of example 19, wherein the data structure is a Directed Acyclic Graph.
[0085] Example 21: The system of one of examples 16 to 20, further comprising: maintaining a plurality of libraries, each of the plurality of libraries storing one or more subroutines.
[0086] Example 22: The system of example 21, wherein the compilation artifacts further include: library data representing a plurality of buffer parameters and associations between the plurality of buffer parameters and the plurality of libraries, each of the plurality of buffer parameters being associated with a respective library of the plurality of libraries.
[0087] Example 23: The system of one of examples 16 to 22, wherein the compilation artifacts further include: machine code that is configured to process the computational graph. [0088] Example 24: The system of one of examples 16 to 23, wherein the operations are operations for processing an input of a neural network through one or more layers of the neural network to generate an output of the neural network.
[0089] Example 25: The system of one of examples 16 to 24, wherein the operations are operations for training a neural network by adjusting values of parameters of the neural network.
[0090] Example 26: The system of one of examples 16 to 25, wherein the processing unit is a GPU or a CPU.
[0091] Example 27. A system comprising one or more computers and one or more storage devices storing instructions that when executed by the one or more computers cause the one or more computers to perform system operations comprising: receiving input buffer parameters that are user-specific inputs to a computational graph, the computational graph including a plurality of nodes representing operations; receiving a data entity including buffer data representing (i) a plurality of buffer parameters including the input buffer parameters and (ii) associations between the plurality of buffer parameters and the operations; and invoking the data entity with the input buffer parameters to cause a processing unit to process the computational graph in accordance with the input buffer parameters by executing the operations.
[0092] Example 28: The system of example 27, wherein invoking the data entity with the input buffer parameters comprising: based on the data entity, identifying one or more operations from the computational graph, the one or more operations corresponding to the input buffer parameters, and enqueuing the one or more operations on the processing unit to process the computational graph.
[0093] Example 29: The system of example 27 or 28, wherein the operations include a plurality of groups of operations and the data entity includes a data structure representing (i) a plurality of streams, each stream representing a sequence of operations and (ii) dependencies between the operations, and wherein invoking the data entity with the input buffer parameters comprising: based on the data entity, identifying a plurality of streams from the computational graph, each stream being associated with a respective group of operations from the operations, for each stream of the plurality of streams, enqueuing the respective group of operations into the stream that is associated with the respective group of operations, and based on the data entity, defining dependencies between the plurality of groups of operations.
[0094] Example 30: The system of one of examples 27 to 29, wherein the processing unit is a GPU or a CPU.
[0095] Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.
Claims (16)
1. A method of generating a data entity from a computational graph, the method comprising:
receiving data identifying a computational graph, the computational graph including a plurality of nodes representing operations;
obtaining compilation artifacts for processing the computational graph on a processing unit; and generating a data entity from the compilation artifacts, wherein the data entity, when invoked, causes the processing unit to process the computational graph by executing the operations represented by the plurality of nodes.
2. The method of claim 1, wherein the compilation artifacts further include:
buffer data representing a plurality of buffer parameters and associations between the plurality of buffer parameters and the operations, each of the plurality of buffer parameters being associated with a respective operation of the operations.
3. The method of claim 2, wherein the compilation artifacts further include: respective logical numbers assigned to the plurality of buffer parameters, and data specifying associations between the logical numbers and the operations represented by the plurality of nodes.
4. The method of any preceding claim, wherein the compilation artifacts further include: a data structure representing (i) a sequence of operations and (ii) dependencies between the operations.
5. The method of claim 4, wherein the data structure is a Directed Acyclic Graph.
6. The method of any preceding claim, further comprising:
maintaining a plurality of libraries, each of the plurality of libraries storing one or more sub-routines.
7. The method of claim 6, wherein the compilation artifacts further include:
library data representing a plurality of buffer parameters and associations between the plurality of buffer parameters and the plurality of libraries, each of the plurality of buffer parameters being associated with a respective library of the plurality of libraries.
8. The method of any preceding claim, wherein the compilation artifacts further include: machine code that is configured to process the computational graph.
9. The method of any of claims 1-8, wherein the operations are operations for processing an input of a neural network through one or more layers of the neural network to generate an output of the neural network.
10. The method of any of claims 1-8, wherein the operations are operations for training a neural network by adjusting values of parameters of the neural network.
11. The method of any preceding claim, wherein the processing unit is a graphic processing unit (GPU) or a central processing unit (CPU).
12. A method of invoking a data entity to process a computational graph on a processing unit, the method comprising, receiving input buffer parameters that are user-specific inputs to a computational graph, the computational graph including a plurality of nodes representing operations;
receiving a data entity including buffer data representing (i) a plurality of buffer parameters including the input buffer parameters and (ii) associations between the plurality of buffer parameters and the operations; and invoking the data entity with the input buffer parameters to cause a processing unit to process the computational graph in accordance with the input buffer parameters by executing the operations.
13. The method of claim 12, wherein invoking the data entity with the input buffer parameters comprising:
based on the data entity, identifying one or more operations from the computational graph, the one or more operations corresponding to the input buffer parameters, and enqueuing the one or more operations on the processing unit to process the computational graph.
14. The method of claim 12 or claim 13, wherein the operations include a plurality of groups of operations and the data entity includes a data structure representing (i) a plurality of streams, each stream representing a sequence of operations and (ii) dependencies between the operations, and wherein invoking the data entity with the input buffer parameters comprising: based on the data entity, identifying a plurality of streams from the computational graph, each stream being associated with a respective group of operations from the operations, for each stream of the plurality of streams, enqueuing the respective group of operations into the stream that is associated with the respective group of operations, and based on the data entity, defining dependencies between the plurality of groups of operations.
15. The method of any of claims 12-14, wherein the processing unit is a GPU or a CPU.
16. A system comprising one or more computers and one or more storage devices storing instructions that when executed by the one or more computers cause the one or more computers to perform the method of any preceding claim.
Intellectual
Property
Office
Application No: GB1800176.8
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/400,937 US10325340B2 (en) | 2017-01-06 | 2017-01-06 | Executing computational graphs on graphics processing units |
Publications (2)
Publication Number | Publication Date |
---|---|
GB201800176D0 GB201800176D0 (en) | 2018-02-21 |
GB2560409A true GB2560409A (en) | 2018-09-12 |
Family
ID=61190469
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
GB1800176.8A Withdrawn GB2560409A (en) | 2017-01-06 | 2018-01-05 | Executing computational graphs on graphics processing units |
Country Status (6)
Country | Link |
---|---|
US (2) | US10325340B2 (en) |
CN (2) | CN108460458B (en) |
DE (2) | DE202018100069U1 (en) |
GB (1) | GB2560409A (en) |
SG (1) | SG10201800154RA (en) |
WO (1) | WO2018129366A1 (en) |
Families Citing this family (8)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
DE102018110687A1 (en) | 2017-05-05 | 2018-11-08 | Intel Corporation | Dynamic accuracy management for deep learning integer primitives |
CN109522521A (en) * | 2018-11-16 | 2019-03-26 | 北京中创碳投科技有限公司 | A kind of data processing method, device and computer equipment |
KR20200083048A (en) | 2018-12-31 | 2020-07-08 | 삼성전자주식회사 | Neural network system predicting polling time and neural network model processing method using the same |
CN111459464B (en) * | 2019-01-22 | 2023-04-25 | 阿里巴巴集团控股有限公司 | Node fusion method, code generation method and device |
CN111667060B (en) * | 2019-03-08 | 2022-12-09 | 上海寒武纪信息科技有限公司 | Deep learning algorithm compiling method and device and related products |
CN111626398B (en) * | 2019-02-28 | 2022-12-09 | 上海寒武纪信息科技有限公司 | Operation method, device and related product |
CN111292223B (en) | 2020-01-22 | 2023-07-25 | 北京百度网讯科技有限公司 | Graph calculation processing method and device, electronic equipment and storage medium |
CN112631605B (en) * | 2020-12-31 | 2024-04-26 | 深圳前海微众银行股份有限公司 | Code compiling method, device and equipment of federal learning model and storage medium |
Family Cites Families (23)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4309756A (en) | 1971-02-17 | 1982-01-05 | Beckler Robert I | Method of automatically evaluating source language logic condition sets and of compiling machine executable instructions directly therefrom |
US6519767B1 (en) | 1995-06-07 | 2003-02-11 | Microsoft Corporation | Compiler and method for automatically building version compatible object applications |
US6311265B1 (en) * | 1996-03-25 | 2001-10-30 | Torrent Systems, Inc. | Apparatuses and methods for programming parallel computers |
US5844554A (en) | 1996-09-17 | 1998-12-01 | Bt Squared Technologies, Inc. | Methods and systems for user interfaces and constraint handling configurations software |
JP2001249949A (en) * | 2000-03-07 | 2001-09-14 | Nec Corp | Feeling generation method, feeling generator and recording medium |
US20050114850A1 (en) | 2003-10-29 | 2005-05-26 | Saurabh Chheda | Energy-focused re-compilation of executables and hardware mechanisms based on compiler-architecture interaction and compiler-inserted control |
US7996671B2 (en) | 2003-11-17 | 2011-08-09 | Bluerisc Inc. | Security of program executables and microprocessors based on compiler-architecture interaction |
US7343482B2 (en) | 2004-10-20 | 2008-03-11 | Arm Limited | Program subgraph identification |
US7954094B2 (en) | 2006-03-27 | 2011-05-31 | International Business Machines Corporation | Method for improving performance of executable code |
US20080276252A1 (en) * | 2007-05-04 | 2008-11-06 | Microsoft Corporation | Kernel event visualization |
CN101894051A (en) * | 2010-07-29 | 2010-11-24 | 中国科学技术大学 | Primary and secondary data structure-based CPU-GPU cooperative computing method |
BRPI1104413B1 (en) * | 2011-09-19 | 2020-12-01 | Universidade Estadual De Campinas - Unicamp | gas leak detection system and method, method of determining the magnitude and location of gas leak through neural networks and use in rigid and / or flexible tubing |
US8707314B2 (en) * | 2011-12-16 | 2014-04-22 | Advanced Micro Devices, Inc. | Scheduling compute kernel workgroups to heterogeneous processors based on historical processor execution times and utilizations |
US9332083B2 (en) * | 2012-11-21 | 2016-05-03 | International Business Machines Corporation | High performance, distributed, shared, data grid for distributed Java virtual machine runtime artifacts |
GB2510348A (en) * | 2013-01-31 | 2014-08-06 | Ibm | Data transmissions using RDMA, data structures and fingerprints of the data structures |
US11061539B2 (en) * | 2013-03-15 | 2021-07-13 | The Mathworks, Inc. | Reference nodes in a computational graph |
US9104432B2 (en) | 2013-06-24 | 2015-08-11 | International Business Machines Corporation | Extracting stream graph structure in a computer language by pre-executing a deterministic subset |
US9424079B2 (en) | 2013-06-27 | 2016-08-23 | Microsoft Technology Licensing, Llc | Iteration support in a heterogeneous dataflow engine |
CN104915187A (en) * | 2014-03-13 | 2015-09-16 | 华为技术有限公司 | Graph model calculation method and device |
WO2015191731A1 (en) | 2014-06-13 | 2015-12-17 | The Charles Stark Draper Laboratory, Inc. | Systems and methods for software analytics |
US9760406B2 (en) * | 2014-09-02 | 2017-09-12 | Ab Initio Technology Llc | Controlling data processing tasks |
CN105701506B (en) * | 2016-01-12 | 2019-01-18 | 杭州电子科技大学 | A kind of improved method based on transfinite learning machine and rarefaction representation classification |
CN106055576B (en) * | 2016-05-20 | 2018-04-10 | 大连理工大学 | A kind of fast and effectively image search method under large-scale data background |
-
2017
- 2017-01-06 US US15/400,937 patent/US10325340B2/en active Active
-
2018
- 2018-01-05 SG SG10201800154RA patent/SG10201800154RA/en unknown
- 2018-01-05 GB GB1800176.8A patent/GB2560409A/en not_active Withdrawn
- 2018-01-05 WO PCT/US2018/012650 patent/WO2018129366A1/en active Application Filing
- 2018-01-08 DE DE202018100069.1U patent/DE202018100069U1/en active Active
- 2018-01-08 CN CN201810015495.3A patent/CN108460458B/en active Active
- 2018-01-08 CN CN202111658733.0A patent/CN114429201A/en active Pending
- 2018-01-08 DE DE102018100258.0A patent/DE102018100258A1/en active Pending
-
2019
- 2019-06-06 US US16/433,819 patent/US20190287210A1/en active Pending
Non-Patent Citations (1)
Title |
---|
None * |
Also Published As
Publication number | Publication date |
---|---|
WO2018129366A1 (en) | 2018-07-12 |
SG10201800154RA (en) | 2018-08-30 |
DE102018100258A1 (en) | 2018-07-12 |
US20190287210A1 (en) | 2019-09-19 |
US20180197267A1 (en) | 2018-07-12 |
CN108460458B (en) | 2022-01-11 |
CN114429201A (en) | 2022-05-03 |
DE202018100069U1 (en) | 2018-04-09 |
US10325340B2 (en) | 2019-06-18 |
GB201800176D0 (en) | 2018-02-21 |
CN108460458A (en) | 2018-08-28 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20210295161A1 (en) | Training neural networks represented as computational graphs | |
US10325340B2 (en) | Executing computational graphs on graphics processing units | |
US11087216B2 (en) | Modifying computational graphs | |
US11769061B2 (en) | Processing computational graphs | |
US20220027202A1 (en) | Stream-based accelerator processing of computational graphs | |
US10789544B2 (en) | Batching inputs to a machine learning model | |
US20210049231A1 (en) | Multiple Output Fusion For Operations Performed In A Multi-Dimensional Array of Processing Units | |
US11763146B1 (en) | Processing loops in computational graphs | |
US20210295158A1 (en) | End-to-end optimization | |
US20200210851A1 (en) | Augmenting neural networks | |
US9600254B1 (en) | Loop branch reduction | |
Kramer et al. | The alea reactive dataflow system for gpu parallelization |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
WAP | Application withdrawn, taken to be withdrawn or refused ** after publication under section 16(1) |