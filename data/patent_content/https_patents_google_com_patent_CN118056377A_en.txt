CN118056377A - Quantum-resistant, cryptographic hash-based signature computation acceleration - Google Patents
Quantum-resistant, cryptographic hash-based signature computation acceleration Download PDFInfo
- Publication number
- CN118056377A CN118056377A CN202180102987.6A CN202180102987A CN118056377A CN 118056377 A CN118056377 A CN 118056377A CN 202180102987 A CN202180102987 A CN 202180102987A CN 118056377 A CN118056377 A CN 118056377A
- Authority
- CN
- China
- Prior art keywords
- hash
- computer
- message
- implemented method
- input
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 230000001133 acceleration Effects 0.000 title description 4
- 238000000034 method Methods 0.000 claims abstract description 56
- 238000004364 calculation method Methods 0.000 claims description 29
- 230000006870 function Effects 0.000 claims description 20
- 238000012795 verification Methods 0.000 claims description 3
- 238000004422 calculation algorithm Methods 0.000 description 12
- 238000004891 communication Methods 0.000 description 11
- 238000012545 processing Methods 0.000 description 5
- 230000002093 peripheral effect Effects 0.000 description 4
- 230000005540 biological transmission Effects 0.000 description 3
- 230000001413 cellular effect Effects 0.000 description 3
- VBMOHECZZWVLFJ-GXTUVTBFSA-N (2s)-2-[[(2s)-6-amino-2-[[(2s)-6-amino-2-[[(2s,3r)-2-[[(2s,3r)-2-[[(2s)-6-amino-2-[[(2s)-2-[[(2s)-6-amino-2-[[(2s)-2-[[(2s)-2-[[(2s)-2,6-diaminohexanoyl]amino]-5-(diaminomethylideneamino)pentanoyl]amino]propanoyl]amino]hexanoyl]amino]propanoyl]amino]hexan Chemical compound NC(N)=NCCC[C@@H](C(O)=O)NC(=O)[C@H](CCCCN)NC(=O)[C@H](CCCCN)NC(=O)[C@H]([C@@H](C)O)NC(=O)[C@H]([C@H](O)C)NC(=O)[C@H](CCCCN)NC(=O)[C@H](C)NC(=O)[C@H](CCCCN)NC(=O)[C@H](C)NC(=O)[C@H](CCCN=C(N)N)NC(=O)[C@@H](N)CCCCN VBMOHECZZWVLFJ-GXTUVTBFSA-N 0.000 description 2
- 108010068904 lysyl-arginyl-alanyl-lysyl-alanyl-lysyl-threonyl-threonyl-lysyl-lysyl-arginine Proteins 0.000 description 2
- 239000000758 substrate Substances 0.000 description 2
- 238000013459 approach Methods 0.000 description 1
- 238000003491 array Methods 0.000 description 1
- 230000002238 attenuated effect Effects 0.000 description 1
- 230000008859 change Effects 0.000 description 1
- 230000002939 deleterious effect Effects 0.000 description 1
- 238000011161 development Methods 0.000 description 1
- 230000018109 developmental process Effects 0.000 description 1
- 230000000694 effects Effects 0.000 description 1
- 238000005516 engineering process Methods 0.000 description 1
- 238000000605 extraction Methods 0.000 description 1
- 239000000835 fiber Substances 0.000 description 1
- GVVPGTZRZFNKDS-JXMROGBWSA-N geranyl diphosphate Chemical compound CC(C)=CCC\C(C)=C\CO[P@](O)(=O)OP(O)(O)=O GVVPGTZRZFNKDS-JXMROGBWSA-N 0.000 description 1
- 230000036541 health Effects 0.000 description 1
- 239000011810 insulating material Substances 0.000 description 1
- 230000002427 irreversible effect Effects 0.000 description 1
- 238000004519 manufacturing process Methods 0.000 description 1
- 239000000463 material Substances 0.000 description 1
- 238000007620 mathematical function Methods 0.000 description 1
- 238000010295 mobile communication Methods 0.000 description 1
- 238000012986 modification Methods 0.000 description 1
- 230000004048 modification Effects 0.000 description 1
- 238000012806 monitoring device Methods 0.000 description 1
- 230000003121 nonmonotonic effect Effects 0.000 description 1
- 230000008672 reprogramming Effects 0.000 description 1
- 230000004044 response Effects 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 230000003068 static effect Effects 0.000 description 1
- 238000012546 transfer Methods 0.000 description 1
- 239000013598 vector Substances 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Abstract
This document describes techniques and apparatuses related to accelerating quantum-resistant, cryptographic hash-based signature computation. Upon receipt of an input message, one or more processors (106) implement a hash Guan Liqi (114). The hash Guan Liqi (114) is configured to initialize variables, load an input message and the initialized variables into an input buffer (502), and perform hash-based signature computation (404, 520). The hash-based signature computation (404, 520) is repeated a predetermined number of iterations, each iteration involving loading at least a portion of the digest message (410, 526) directly into a configurable location in the input buffer (502). In so doing, this method of iterative hash computation bypasses memory copies and bus latency, thereby speeding up quantum-resistant, cryptographic hash-based signature computation.
Description
Background
The world is increasingly impacted by various cyber attacks due to the ever-increasing computing of society and the associated internet of things (IoT) expansion. These network attacks can not only seriously affect the information security of people, but also seriously affect the physical security of people. To thwart network attacks, many security measures are implemented on computing devices to prevent unauthorized access and manipulation of device data and communications. Some of these security measures employ digital signature schemes, typically based on asymmetric encryption algorithms, including Rivest-Shamir-Adleman (RSA) and Elliptic Curve Digital Signature Algorithms (ECDSA). These asymmetric cryptographic algorithms base their security aspects on the significant amount of time required to decode using classical computing techniques.
However, advances in quantum computing may make these commonly used asymmetric cryptographic algorithms vulnerable to network attacks. This is because quantum computers can compute exponentially faster than classical computers. For example, quantum computing algorithms such as the shell algorithm and the Grover algorithm may provide a secondary acceleration for brute force searching. In response, cryptographic algorithms have been developed that are considered secure against cyber attacks performed by quantum computers. However, many of these quantum-resistant cryptographic algorithms take too much time to compute, making most implementations unsuitable for many applications, such as on limited devices.
Disclosure of Invention
This document describes techniques and apparatuses related to accelerating quantum-resistant, cryptographic hash-based signature computation. Upon receipt of an input message, one or more processors implement hashing Guan Liqi. The hash manager is configured to initialize variables, load an input message and the initialized variables into the input buffer, and perform hash-based signature computation. The hash-based signature computation is repeated for a predetermined number of iterations, each iteration involving loading at least a portion of the digest message directly into a configurable location in the input buffer. In so doing, this method of iterative hash computation bypasses memory copies and bus latency, thereby speeding up quantum-resistant, cryptographic-hash-based signature computation.
This summary is provided to introduce a simplified concepts for accelerating quantum-resistant, cryptographic hash-based signature computation, which is further described below in the detailed description and illustrated in the drawings. This summary is not intended to identify essential features of the claimed subject matter, nor is it intended to be used to determine the scope of the claimed subject matter.
Drawings
Details of one or more aspects of accelerating quantum-resistant, cryptographic-hash-based signature computation are described in this document with reference to the following figures:
FIG. 1 illustrates an example operating environment including an example computing device capable of implementing cryptographic techniques and other security functions in accordance with one or more aspects disclosed in this document;
FIG. 2 illustrates one example integrated circuit component implemented as a cryptographic coprocessor;
FIG. 3 illustrates the operation of the hash manager when executed by a processor;
FIG. 4 illustrates an example method implemented by a hash manager for accelerating iterative hash-based signature computation;
FIG. 5 illustrates an example method implemented by a hash manager for accelerating iterative hash-based signature computation by loading at least a portion of a digest message directly into a configurable location in an input buffer and performing the hash computation for a predetermined number of iterations; and
Fig. 6 illustrates an integrated circuit component implemented as a system-on-chip (SoC) that can implement aspects of hash-based signature computation that accelerate iterations.
The use of the same reference numbers in different instances may indicate similar features or components.
Detailed Description
SUMMARY
Computing devices often include integrated circuits with security circuitry and software to provide protection against flaws, attacks, and other potentially damaging events. The security circuitry and software may implement a number of security paradigms, such as adherence to guidelines including those outlined in the National Institute of Standards and Technology (NIST) and/or Public Key Cryptography (PKCS). For example, during a firmware update, security circuitry and software that complies with PKCS standards may verify the authenticity and integrity of data received and executed by a computing device using digital signatures (e.g., cryptographic signatures). A digital signature scheme is a mathematical scheme used to verify digital messages or documents. A valid digital signature gives the recipient confidence to know that the message was generated by a known sender ("authenticity") and that it was sometimes not manipulated during transmission ("integrity"). In so doing, the security circuitry and software reduce the chance that the information will inadvertently expose or otherwise use some of the functionality in a deleterious or otherwise unauthorized manner.
In today's computing environments, bad actors can use a large number of attack vectors to overlay encrypted data or attack computing devices at countless levels. For example, recent developments in quantum computing have greatly attenuated many of these security paradigms, as they assume attacks using classical computing techniques. Thus, an attacker using quantum computing may be able to gain unauthorized access or control of a computing device or device data through various network attacks. For example, the computing device may cryptographically encrypt the sensitive data and transmit the encrypted data over a network. An attacker connected to the network can take the encrypted data and decrypt it using quantum computation. In another example, an attacker may be able to inject malware into a computing device (such asRouter or IoT device). If an attacker successfully installs fraudulent code segments into a computing device without the computing device verifying the authenticity or integrity of the firmware update, an unauthorized reconfiguration of the computing device can either not override confidential or sensitive data, or even cause the device to operate unintentionally, thereby posing a potential security risk to a human operator.
In an attempt to count these potential attacks and secure data transmissions on a computing device, the present disclosure describes an integrated quantum-resistant security paradigm. One such software-based security paradigm that is theorized to resist quantum computer network attacks is iterative hash-based signature computation ("hash computation"). Hash-based signature schemes combine a one-time signature scheme (e.g., a Lamport one-time signature scheme) with a Merkle tree structure (e.g., a technique that combines many keys within a single larger structure). The one-time signature scheme is built from any cryptographically secure one-way function, such as a cryptographic hash function (e.g., a hash algorithm, a trap function, an irreversible function).
A cryptographic hash function is a mathematical function that maps an arbitrary length input data stream ("input message") to a fixed length output ("digest message"). The iterative hash computation includes repeating the cryptographic hash function for the number of iterations. Due to this iterative hash calculation approach, any modification to the incoming message will change the message digest completely with very high probability (e.g., avalanche effect). The cryptographic hash function is thus effective in secure and efficient transmission and processing of digital information.
However, methods that implement quantum-based, software-based security paradigms on security circuits employing hardware architectures for iterative hash computation are less suitable for time-sensitive constrained devices. For example, when performing iterative hash computations using a conventional hardware architecture, the cryptographic processor may perform many bus transactions to transmit and retrieve results during a single iteration. In addition, the cryptographic processor may reprogram the hash engine and load new inputs for each iteration. Thus, the time required to perform a single hash calculation in an iterative hash calculation scheme is typically twice the amount of time to perform a single hash calculation in a non-iterative hash calculation scheme. Executing computationally expensive algorithms (such as hashing algorithms) each time each of the above operations is performed in an iteration significantly slows down processing and is also power consuming for limited devices.
In contrast, this document describes techniques and apparatus to accelerate quantum-resistant, cryptographic-hash-based signature computation by loading at least a portion of a digest message directly into a configurable location in an input buffer. In so doing, this method of iterative hash computation bypasses memory copies and bus latency, thereby speeding up quantum-resistant, cryptographic hash-based signature computation.
The following discussion describes an operating environment, techniques that may be employed in an operating environment, example methods, and a system-on-a-chip (SoC) in which components of the operating environment may be embodied. In the context of the present disclosure, reference is made to an operating environment by way of example only.
Operating environment
The following discussion describes an operating environment, techniques that may be employed in the operating environment, and various devices or systems in which components of the operating environment can be embodied. In the context of the present disclosure, reference is made to an operating environment by way of example only.
FIG. 1 illustrates an example operating environment 100 including an example computing device 102 capable of implementing cryptographic techniques and other security functions. Examples of computing devices 102 include a smart phone 102-1, a tablet computer 102-2, a wireless router 102-3, a set top box 102-4, a Network Attached Storage (NAS) device 102-5, a wearable computing device 102-6 (e.g., a computerized watch), and an automobile 102-7. Although not shown, the computing device 102 may also be implemented as any of a mobile station (e.g., a fixed or mobile STA), a mobile communication device, a client device, a home automation and control system, an entertainment system, a game console, a personal media device, a health monitoring device, an drone, a camera, an internet appliance capable of wireless internet access and browsing, an IoT device, a security system, and so forth. Note that the electronic device 102 can be wearable, non-wearable, but mobile or relatively non-mobile (e.g., desktop, appliance). Note also that the electronic device 102 can be used with or embedded in many electronic devices 102 or peripheral devices, such as in an automobile or as an accessory to a laptop computer. Computing device 102 may implement cryptographic or security functions for any suitable purpose, such as to enable security functions for a particular type of computing device, enable secure network access, encrypt data for storage, verify software signatures, authenticate users or other devices, sign electronic files or documents, and so forth. For clarity or visual brevity, the computing device 102 may provide other functionality or include components or interfaces omitted from fig. 1.
The computing device 102 includes a printed circuit board assembly 104 (PCBA) 104 on which components of the computing device and interconnections are embodied. Alternatively or additionally, components of the computing device 102 can be embodied on other substrates, such as flexible circuit material or other insulating material. Although not shown, computing device 102 may also include a housing, various human input devices, a display, a battery pack, an antenna, and so forth. Typically, the electrical and electromechanical components of computing device 102 are assembled onto a Printed Circuit Board (PCB) to form PCBA 104. The various components of PCBA 104 (e.g., processor and memory) are then programmed and tested to verify proper functioning of PCBA 104.PCBA 104 is connected to other portions of computing device 102 or assembled into a housing with other portions of computing device 102.
As illustrated, PCBA 104 includes one or more processors 106 and a computer-readable medium 108. Processor(s) 106 may be any suitable single-core or multi-core processor (e.g., application Processor (AP), digital Signal Processor (DSP), central Processing Unit (CPU), graphics Processing Unit (GPU)). The processor(s) 106 may be configured to execute instructions or commands stored within the computer-readable medium 110 to implement the operating system 112 and the hash manager 114, the hash manager 114 having an initialization module 116, a cryptographic module 118, and/or a hash module 120 stored within the computer-readable storage medium 110. The computer readable storage medium 110 may include one or more non-transitory storage devices, such as random access memory (RAM, dynamic RAM (DRAM), non-volatile RAM (NVRAM), or Static RAM (SRAM)), read Only Memory (ROM), or flash memory), a hard drive, an SSD, or any type of medium suitable for storing electronic instructions, each coupled to a computer system bus. The term "coupled" may refer to two or more elements in direct contact (physically, electrically, magnetically, optically, etc.), or to two or more elements not in direct contact with each other but still co-operate and/or interact with each other.
PCBA 104 may also include I/O ports 122 and a communication system 124. The I/O ports 122 allow the computing device 102 to interact with other devices or users. The I/O ports 122 may include any combination of internal or external ports, such as USB ports, audio ports, serial ATA (SATA) ports, PCIe-express based ports or slots, secure digital input/output (SDIO) slots, and/or other conventional ports. Various peripheral devices may be operatively coupled to I/O port 122 such as a Human Input Device (HID), external computer readable storage medium, or other peripheral device.
Communication system 124 enables communication of device data, such as received data, transmitted data, or other information as described herein, and may provide connectivity to one or more networks and other devices connected thereto. An example communication system includes an NFC transceiver, compliant with various IEEE 802.15Standard WPAN radio compliant with various IEEE 802.11/>WLAN radio of any of the standards, WWAN (3 GPP compliant) radio for cellular telephones, various IEEE 802.16/>, compliantStandard Wireless Metropolitan Area Network (WMAN) radios, infrared (IR) transceivers conforming to the infrared data association (IrDA) protocol, and wired Local Area Network (LAN) ethernet transceivers. The device data communicated through the communication system 124 may be packaged or framed depending on the communication protocol or standard through which the computing device 102 is communicating. The communication system 124 may include a wired interface, such as an ethernet or fiber optic interface for communicating over a local network, intranet, or the internet. Alternatively or additionally, the communication system 124 may include a wireless interface that facilitates communication over a wireless network, such as a wireless LAN, cellular network, or WPAN.
Although not shown, the computing device 102 can also include a system bus, interconnect, crossbar, or data transfer system that couples the various components within the device. The system bus or interconnect can include any one or combination of different bus structures, such as a memory bus or memory controller, a peripheral bus, a universal serial bus, and/or a processor or local bus that utilizes any of a variety of bus architectures.
PCBA 104 also includes an integrated circuit component 126. In various embodiments, the integrated circuit component 126 may be a secure root of trust (RoT) Application Specific Integrated Circuit (ASIC) component including a cryptographic coprocessor, a processor, a microcontroller, a microprocessor, a system on a chip (SoC), or the like that is operatively interface to the processor 106 (e.g., a host processor). The integrated circuit component 126 (e.g., hash engine, hash accelerator) may be implemented as embedded system security with computing power to perform the calculations required to verify the authenticity and integrity of the downloaded software. The integrated circuit component 126 may be communicatively coupled to the secure non-volatile computer-readable storage medium 108 through a dedicated interface. In some embodiments, the integrated circuit component 126 may include a hash engine (e.g., a processor configured to perform a hash function). In another embodiment, the integrated circuit component 126 may be a hash engine.
In more detail, consider one example of an integrated circuit component 126 implemented as a cryptographic coprocessor 202, as shown in fig. 2. This is just one example, as the integrated circuit component 126 may be implemented as a cryptographic microprocessor, microcontroller, soC, or the like. In this embodiment, the cryptographic coprocessor 202 may operate as a hash engine. In other implementations, the integrated circuit component 126 may be, for example, a SoC having components that include a processor that operates as a hash engine.
As illustrated in FIG. 2, the cryptographic coprocessor 202 may include an arithmetic and logic unit 204 (ALU 204), a register file 206, a control unit 208, a hardware counter 210, and an input/output (I/O) unit 212. The ALU 204 may be configured to perform arithmetic and logical operations on received data. The register file 206 may be an array of processor registers (e.g., control registers) that function as a high-speed semi-transitory memory configured for fast data access during program or functional processing. The registers may be tightly coupled to the ALU 204 or other execution unit to enable the cryptographic coprocessor 202 to quickly access working data. To further facilitate access to data, the register file may include multiple read ports or multiple write ports to enable the ALU 204 and/or execution units to retrieve multiple operands simultaneously in a single cycle. The cryptographic coprocessor 202 or ALU 204 and its execution units may use a register address space separate from the system address space to access the register file. In some cases, registers are numbered for access via a register address space. A register file may be formed of flip-flops to speed up the reading and writing of bits of data. The control unit 208 may be configured to control the data flow of the entire system. Hardware counters 210 (e.g., hardware performance counters, processor performance counters) may count events, transactions, or iterations occurring at the processor level. For example, the hardware counter 210 may count the number of instructions and cycles of program execution. The I/O unit 212 may include ports that operably interface with other components of the device.
Techniques for accelerating hash computation
In an aspect, the computing device 102 may implement steps for verifying a hash-based signature. For example, the processor(s) 106 may receive an input message (e.g., firmware update, configuration data file) and a digital signature signed with the same private key. To verify the integrity and authenticity of an input message, an iterative hash calculation may be performed that generates a digest message of the input message. In another aspect, the computing device 102 may implement steps for public key calculation and public key signing.
In aspects, upon receipt of an input message, the processor(s) 106 operatively connected to the computer-readable medium 108 and the integrated circuit component 126 may run an extraction/execution loop that loops through instructions of the hash manager 114 stored in the computer-readable medium 108. In another embodiment, upon receiving an input message, the processor(s) 106 may load the input message to the integrated circuit component 126 and instruct the integrated circuit component 126 to run a fetch/execute loop that loops through instructions of the hash manager 114 stored in the computer-readable medium 108.
Fig. 3 illustrates the operation of the hash manager 114 (not shown) when executed by a processor (e.g., the processor(s) 106). In one aspect, hash Guan Liqi 114 selects pattern 302. The mode selection 302 may be a binary decision, including a mode configured for a single hash calculation and a mode configured for an iterative hash calculation. If the selected pattern 302 indicates an iterative hash calculation 304, the hash manager 114 may execute the initialization module 116. The initialization module 116 may initialize the variables 306 for iterative hash computation. For example, the processor may program the values of the following variables: input message length, copy offset, copy length, update offset, and update length. The values of these variables may be used to identify byte indices within the incoming message. The processor may also program the desired number of iterations to perform a hash calculation and assign the value to a variable referred to herein as an iteration counter. For example, the processor may assign a value of 255 to the iteration counter variable, thereby programming the hash calculation to perform up to 256 times. The values of the variables used for iterative hash computation may be loaded into configurable locations within an input buffer (e.g., a register file of cryptographic coprocessor 202).
Next, or in parallel with the operation of initialization module 116, hash manager 114 may load 308 the input message into a configurable location in an input buffer of integrated circuit component 126. Once the input messages and variables for the iterative hash computation have been loaded, the hash manager 114 may trigger 310 execution of the iterative hash computation on the integrated circuit component 126.
Fig. 4 illustrates an example method 400 implemented by the hash manager 114 to accelerate iterative hash computations. In an aspect, hash Guan Liqi 114 (not shown) may determine the selected mode. If the selected mode indicates an iterative hash calculation, the hash manager 114 may execute the cryptographic module 118. The cryptographic module 118 may implement various cryptographic techniques, such as dividing an input message into n message blocks ("chunks (chunking)") 404 or adding data to the beginning, middle, or end of an input message ("padding") 406. In some implementations, the cryptographic module 118 may incorporate random data into the input message ("salted"). In another embodiment, some or all of the operations of cryptographic module 118 may be included in hash module 120.
In addition to the above description, the input message may be a concatenated string of bits (e.g., 256 bits, 512 bits) including substrings of various lengths, such as prefixes, suffixes, secret seeds, and/or counters, in various orders and at different index locations within the input message. In one embodiment, the input message may be 55 bytes long with a 22 byte prefix, a 1 byte counter, and a 32 byte secret seed. In this embodiment, the 22-byte prefix may be padding data added to the beginning of the input message, the 1-byte counter may be part of the input message, wherein the hash module 120 monotonically increases the value by 1 bit for iteration, and the 32-byte secret seed may include bytes of the input message or bytes of the digest message. In an embodiment, the 1-byte counter may be incremented or decremented in a non-monotonic manner. In other embodiments, the 1-byte counter may be initialized to a value configured for use cases, including hash-based signature verification or public key calculation and signing.
The hash manager 114 may then execute the hash module 120. The hashing module 120 may involve performing a hash calculation 408, decrementing an iteration counter 410, determining whether the iteration counter is greater than zero 412, loading at least a portion of the digest message 414 if the iteration counter is greater than zero, determining whether a 1-byte counter 416 is present in the input message, and incrementing a 1-byte counter 418 if a 1-byte counter is present. In more detail, a hash engine using the input message as input may perform a hash calculation 408. The hash engine may perform a cryptographic hash function to generate a digest message. The hash engine may implement any cryptographic hash function that meets certain criteria, such as SHA 256. The length of the digest message may vary depending on the cryptographic hash function utilized.
After performing the hash computation 408 or in parallel therewith, the hash module 120 may decrement the iteration counter by a count value 410. If the iteration counter value is greater than zero 412, then the hash module 116 may load at least a portion of the digest message directly into a configurable location 414 in the input buffer. Next, or in parallel with loading at least a portion of the digest message, hash manager 114 may determine whether a 1-byte counter 416 is present in the input message. If a 1 byte counter does exist in the incoming message, the hashing module 120 may increment 418 the 1 byte counter by a count value. Once the 1-byte counter in the input message is incremented, the hashing module 120 can continue to repeat the operation of the hashing module 120 until the iteration counter count is no longer greater than zero. If a 1 byte counter is not present in the input message, the hashing module 120 can continue to repeat the operation of the hashing module 120 until the iteration counter count is no longer greater than zero. When the iteration counter value is no longer greater than zero, the hashing module 120 may cease execution and the hash manager 114 may communicate 420 the result of the iterative hash calculation (e.g., digest message) to a processor (e.g., hash-based message authentication code (HMAC) core, host processor).
Loading at least a portion of the digest message directly into the configurable location in the input buffer for a predetermined number of iterations avoids the bus latency associated with bus transactions and utilizes fast access memory to speed up hash computation. Further, at least a portion of the digest message may be loaded into a configurable location of the input buffer, updating the secret seed of the previous input message, and thus enabling the hash engine to execute without requiring reprogramming.
Example method
This section describes example methods for accelerating iterative hash computations. Fig. 5 illustrates an example method 500 implemented by a hash manager (e.g., hash manager 114) to accelerate iterative hash computations by loading at least a portion of a digest message directly into a configurable location in an input buffer and performing the hash computation a predetermined number of iterations. As illustrated, the input buffer 502 includes an input message 504 having a prefix 506, a1 byte counter 508, and a secret seed 510. Prefix 506 may be, for example, 22 bytes long. The 1-byte counter may, for example, start with an 8-bit binary value (e.g., binary 00000000) equal to 0. The secret seed 510 may be, for example, 32 bytes long. The input buffer 502 may also include variables that are initialized by an initialization module (not shown). The update offset 512 variable may be a 6-bit or 8-bit string equal to 22. The copy length 514 variable may be a 6-bit or 8-bit string equal to 23. The copy length (not shown) variable may be a 6-bit or 8-bit string equal to the digest message length. In one embodiment, the duplicate length may be equal to at least a portion of the digest message length. The update length (not shown) may be a 6-bit or 8-bit string equal to the length of a 1-byte counter. In addition, the input buffer may include an 8-bit iteration counter 516 variable. For example, the iteration counter may be initialized to a value of 255 (e.g., binary 11111111). The iteration counter may determine the number of iterations of the repeated hash computation.
Fig. 5 also illustrates a hash module 518. In an aspect, the hash module 518 is implemented by a hash engine (not shown). For example, the hash engine may be a cryptographic coprocessor implementing cryptographic hash function SHA 256. A hash engine using the input message as input may perform iterative hash calculations. For example, hash module 518 may perform hash computation 520 to generate a digest message (not shown). Next, the hash module 518 may decrement the iteration counter 522. For example, the iteration counter 516 may be decremented to the count value 254 (e.g., binary 11111110). Next, the hash module 518 may determine whether the iteration counter 516 value is greater than zero. If the value of the iteration counter 516 is not greater than zero, the hashing module 518 may stop executing and the hash Guan Liqi (not shown) can communicate the digest message to the processor. If the iteration counter 516 value is greater than zero, the hash module 518 can load 526 at least a portion of the digest message into a configurable location in the input buffer 502. For example, a hash engine executing SHA256 may generate a 32-byte digest message. The hash module 518 may load bits of the digest message into the secret seed portion of the input message, replacing the old secret seed. As a result, the incoming message is updated with at least a portion of the 32 byte digest message. Next, the hash module 518 may determine whether a 1-byte counter 528 is present in the input message 504. If the hash module 518 determines that the 1-byte counter 508 does exist in the input message, the hash module may increment 530 the 1-byte counter. For example, the 1-byte counter 508 may increment to a count value of 1 (e.g., binary 00000001). In doing so, the hashing module 120 may monotonically increase the 1-byte counter 508 value by 1 bit for iteration. For example, a monotonic increase in the 1-byte counter 508 value may confuse the input message. If a 1-byte counter 508 is not present in the input message 504, the hash module 518 can proceed to the next hash calculation execution 520. In this way, at least a portion of the digest message for a given iteration may be directly loaded back into a configurable location in input buffer 502, updating the input message for the next hash calculation ("repeated hash calculation"). In so doing, this method of iterative hash computation bypasses memory copies and bus latency, thereby speeding up quantum-resistant, cryptographic hash-based signature computation.
System on chip
Fig. 6 illustrates an integrated circuit component (e.g., integrated circuit component 126) implemented as SoC 600 that can implement aspects of accelerating iterative hash computation. SoC 600 may be a single chip that includes components fabricated on the same semiconductor substrate. Alternatively, the SoC may be a plurality of such chips that are looped together. SoC 600 can be implemented in any suitable device, such as a smart phone, cellular phone, netbook, tablet computer, server, wireless router, network attached storage, camera, smart appliance, printer, set top box, or any other suitable type of device. Although described with reference to a SoC, the entities of fig. 6 may also be implemented as ASICs, field Programmable Gate Arrays (FPGAs), and the like.
SoC600 can be integrated with electronic circuitry, including components described in the operating systems listed herein. SoC600 can also include an integrated data bus (not shown) that couples the various components of the SoC for data communication between the components. The integrated data bus or other components of SoC600 may be exposed or accessed through an external port, such as a JTAG port. For example, components of SoC600 may be tested, configured, or programmed (e.g., flash) through external ports at different manufacturing stages.
In this example, soC 600 includes a computer-readable storage medium 602, one or more processors 604, a hash engine 606, and an I/O unit 608. The computer readable storage medium 602 may include one or more non-transitory storage devices, such as RAM ((DRAM, NVRAM, or SRAM), ROM, or flash memory), a hard drive, an SSD, or any type of medium suitable for storing electronic instructions, each coupled to a computer system bus. The computer-readable storage medium 602 may include all or some of the instructions of the hash Guan Liqi (e.g., the hash manager 114). Processor(s) 604 may implement instructions of a hash manager. In some implementations, any secure root of trust (RoT) component can be implemented as the hash engine 604, including a cryptographic processor. In addition, the hash engine 604 may implement any cryptographic hash function, such as SHA256.
Although the subject matter has been described in language specific to structural features and/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described herein, including the order in which they are performed.
Example
In the following sections, examples are provided.
Example 1: a computer-implemented method, comprising: loading a first input message into an input buffer; computing, by a hash engine and using the first input message as input, a hash calculation, the hash calculation resulting in a digest message; loading at least a portion of the summary message directly into a configurable location in the input buffer; and repeating the hash computations for a predetermined number of iterations, each of the repeated hash computations producing at least a portion of a digest message that is directly loaded into a configurable location in the input buffer for use as input to be used by a later iteration of the repeated hash computation.
Example 2: the computer-implemented method of example 1, wherein the hash engine is a cryptographic processor that implements a cryptographic hash function.
Example 3: the computer-implemented method of example 1, wherein the digest message is 32 bytes in length.
Example 4: the computer-implemented method of example 1, wherein the input buffer is a register file of the hash engine.
Example 5: the computer-implemented method of example 1, wherein loading at least a portion of the digest message directly into the configurable location in the input buffer is accomplished without loading the digest message into a memory external to the hash engine.
Example 6: the computer-implemented method of example 1, wherein the first input message is a bit string comprising a concatenation of a prefix, a counter, and a secret seed.
Example 7: the computer-implemented method of example 5, wherein the first input message is 56 bytes in length.
Example 8: the computer-implemented method of example 1, wherein at least a portion of the digest message is directly loaded into the input buffer at a configurable location in place of a secret seed.
Example 9: the computer-implemented method of example 1, wherein the hash computation is repeated up to 256 times.
Example 10: the computer-implemented method of example 1, further comprising: decrementing the iteration counter; and if the input message of the repeated hash calculation includes a 1-byte counter, incrementing the 1-byte counter.
Example 11: the computer-implemented method of example 10, wherein, at initialization, the iteration counter is assigned a value in the range of 0 to 255.
Example 12: the computer-implemented method of example 11, wherein the iteration counter is loaded into a register of the hash engine.
Example 13: the computer-implemented method of example 10, wherein the 1-byte counter begins with a value configured for hash-based signature verification.
Example 14: the computer-implemented method of example 13, wherein the 1-byte counter increases monotonically.
Example 15: a computing device, comprising: at least one processor; and at least one computer-readable storage medium comprising instructions that, when executed by the at least one processor, cause the processor to perform the method of any of the preceding examples.
Conclusion(s)
Although implementations of techniques and apparatus for implementing, accelerating quantum-resistant cryptographic hash-based signature computation have been described in language specific to features and/or methods, it is to be understood that the subject matter of the appended claims is not necessarily limited to the specific features or methods described. Rather, the specific features and methods are disclosed as example embodiments that enable acceleration of quantum-resistant cryptographic hash-based signature computation.
Claims (15)
1. A computer-implemented method, comprising:
Loading a first input message into an input buffer;
computing, by a hash engine and using the first input message as input, a hash calculation, the hash calculation producing a digest message;
loading at least a portion of the summary message directly into a configurable location in the input buffer; and
Repeating the hash computations for a predetermined number of iterations, each of the repeated hash computations producing at least a portion of a digest message that is directly loaded into the configurable location in the input buffer for use as input to be used by a later iteration of the repeated hash computation.
2. The computer-implemented method of claim 1, wherein the hash engine is a cryptographic processor implementing a cryptographic hash function.
3. The computer-implemented method of claim 1, wherein the digest message is 32 bytes in length.
4. The computer-implemented method of claim 1, wherein the input buffer is a register file of the hash engine.
5. The computer-implemented method of claim 1, wherein loading at least a portion of the digest message directly into the configurable location in the input buffer is accomplished without loading the digest message into a memory external to the hash engine.
6. The computer-implemented method of claim 1, wherein the first input message is a concatenated string of bits comprising a prefix, a counter, and a secret seed.
7. The computer-implemented method of claim 6, wherein the first input message is 56 bytes in length.
8. The computer-implemented method of claim 1, wherein the first input message includes a secret seed loaded into the configurable location in the buffer memory, and the configurable location in the input buffer directly loading at least a portion of the digest message replaces the secret seed.
9. The computer-implemented method of claim 1, wherein the hash computation is repeated up to 256 times.
10. The computer-implemented method of claim 1, further comprising:
Decrementing the iteration counter; and
If the repeated hash calculated input message includes a1 byte counter, the 1 byte counter is incremented.
11. The computer-implemented method of claim 10, wherein the iteration counter is assigned a value in the range of 0 to 255 at initialization.
12. The computer-implemented method of claim 11, wherein the iteration counter is loaded into a register of the hash engine.
13. The computer-implemented method of claim 10, wherein the 1-byte counter starts at a value configured for hash-based signature verification.
14. The computer-implemented method of claim 13, wherein the 1-byte counter increases monotonically.
15. A computing device, comprising:
at least one processor; and
At least one computer-readable storage medium comprising instructions that, when executed by the at least one processor, cause the processor to perform the method of any preceding claim.
Publications (1)
Publication Number | Publication Date |
---|---|
CN118056377A true CN118056377A (en) | 2024-05-17 |
Family
ID=
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11822901B2 (en) | Cryptography using a cryptographic state | |
Castelluccia et al. | On the difficulty of software-based attestation of embedded devices | |
US9043615B2 (en) | Method and apparatus for a trust processor | |
US7711960B2 (en) | Mechanisms to control access to cryptographic keys and to attest to the approved configurations of computer platforms | |
Seshadri et al. | SWATT: Software-based attestation for embedded devices | |
US8291226B2 (en) | Method and apparatus for securely booting from an external storage device | |
US10496841B2 (en) | Dynamic and efficient protected file layout | |
US10944568B2 (en) | Methods for constructing secure hash functions from bit-mixers | |
US20090282254A1 (en) | Trusted mobile platform architecture | |
US20100106976A1 (en) | Representation and verification of data for safe computing environments and systems | |
CN115048652A (en) | End-to-end security for hardware running verified software | |
US20180241568A1 (en) | Verification of code signature with flexible constraints | |
US20110179281A1 (en) | Hash function using a quasi-group operation | |
Ronen et al. | Pseudo constant time implementations of TLS are only pseudo secure | |
US10536264B2 (en) | Efficient cryptographically secure control flow integrity protection | |
US10372943B1 (en) | Cryptographic ASIC with combined transformation and one-way functions | |
Jacob et al. | Securing FPGA SoC configurations independent of their manufacturers | |
US20220021544A1 (en) | Secure Serial Peripheral Interface (SPI) Flash | |
US20100281260A1 (en) | Hash function based on polymorphic code | |
CN118056377A (en) | Quantum-resistant, cryptographic hash-based signature computation acceleration | |
KR20240050406A (en) | Accelerate quantum-resistant, cryptographic hash-based signature computation | |
TWI807766B (en) | Secure chip-wide communication | |
Warsi et al. | Secure Firmware based Lightweight Trusted Platform Module (FLTPM) for IoT Devices | |
WO2023143696A1 (en) | Apparatus and method for memory integrity verification | |
Berki | Creating an integrated secure microcontroller using hardware secure elements. Using various algorithms for quality comparison. Testing new algorithms. |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication |