US8095530B1 - Detecting common prefixes and suffixes in a list of strings - Google Patents
Detecting common prefixes and suffixes in a list of strings Download PDFInfo
- Publication number
- US8095530B1 US8095530B1 US12/177,102 US17710208A US8095530B1 US 8095530 B1 US8095530 B1 US 8095530B1 US 17710208 A US17710208 A US 17710208A US 8095530 B1 US8095530 B1 US 8095530B1
- Authority
- US
- United States
- Prior art keywords
- strings
- characters
- character
- substring
- unique
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F7/00—Methods or arrangements for processing data by operating upon the order or content of the data handled
- G06F7/02—Comparing digital values
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/95—Retrieval from the web
- G06F16/955—Retrieval from the web using information identifiers, e.g. uniform resource locators [URL]
- G06F16/9566—URL specific, e.g. using aliases, detecting broken or misspelled links
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2207/00—Indexing scheme relating to methods or arrangements for processing data by operating upon the order or content of the data handled
- G06F2207/02—Indexing scheme relating to groups G06F7/02 - G06F7/026
- G06F2207/025—String search, i.e. pattern matching, e.g. find identical word or best match in a string
Definitions
- This description relates to online crawling and search and, in particular, to detecting common prefixes and suffixes in a list of strings.
- Online resources or content items (e.g., web pages, video files, audio files, documents, etc.) available on the Internet can be associated with a document identifier, e.g., a Uniform Resource Locator (URL), that can be used to identify and locate a content item.
- a document identifier e.g., a Uniform Resource Locator (URL)
- URL Uniform Resource Locator
- the Internet is organic and heterogeneous, often many distinct URLs point to the same content item. Thus, even though the URLs themselves are different, the data fetched from the distinct URLs can be identical. Because of this, a web crawler that loads URLs from link tags on web pages that point to content (e.g., to index, store, and make the content accessible via a search query) may download the identical content that is specified by two different URLs.
- resources e.g., video files
- other online content e.g., text-based HTML web pages
- bandwidth is an expensive and limited resource, it is desirable to avoid downloading the same content more than once.
- a computer-implemented method includes receiving a plurality of character strings.
- the number of strings (M) in the plurality of strings having a unique substring of X characters at an extremity of the string is determined, the number of strings (N) in the plurality of strings having at least X characters in the string is determined.
- a probability is determined, based on a predetermined model for a distribution of characters in the strings, that the unique substring of X characters would occur M or more times out of the N strings, given that the unique character string occurs at least once. Based on the probability, the number M, and the number N, it is determined that the unique character string is a significant affix in the plurality of character strings, and the unique character string is stored.
- a computer-implemented method includes receiving a plurality of character strings. For unique character substrings of X characters at an extremity of strings in the plurality of strings, the number of strings (M) in the plurality of strings having the unique substring is determined, where X runs from a predetermined minimum length to a predetermined maximum length. For the different values of X, the numbers of strings (N X ) in the plurality of strings having at least X characters in the string is determined. For the unique character strings of X characters, a probability is determined, based on a predetermined model for a distribution of characters in the strings, that the unique character substrings would occur M or more times out of the N X strings, given that the unique character string occurs at least once.
- the number M, and the number N X it is determined whether the unique character strings of X characters are significant affixes in the plurality of character strings, and for unique character strings that are significant affixes, at least one of the unique character strings is stored.
- a computer program product tangibly embodied on a computer-readable medium includes executable instructions that, when executed, are configured to cause a data processing apparatus to receive a plurality of character strings.
- the executable instructions when executed, are configured to cause the data processing apparatus to determine, for unique character substrings of X characters at an extremity of strings in the plurality of strings, the number of strings (M) in the plurality of strings having the unique character substring, where X runs from 1 to n, with n being the length in characters of the longest character string in the plurality of strings.
- the executable instructions when executed, further are configured to cause the data processing apparatus to determine, for the different values of X, the number of strings (N X ) in the plurality of strings having at least X characters in the string, and, for the unique character strings of X characters, to determine a probability, based on a predetermined model for a distribution of characters in the strings, that the unique character substrings would occur M or more times out of the N X strings, given that the unique character string occurs at least once.
- the executable instructions when executed, further are configured to cause the data processing apparatus to determine, based on the probability, the number M, and the number N X , whether the unique character strings of X characters are significant affixes in the plurality of character strings, and, for unique character strings that are significant affixes, to store at least one of the unique character strings.
- FIG. 1 is a schematic block diagram of a system for determining the relevance of a URL parameter for identifying a content item referenced by the URL.
- FIG. 2 is a schematic block diagram of a system for determining automatically significant prefixes and suffixes in a plurality of character strings.
- FIG. 3 is a flowchart illustrating example operations of the system of FIG. 1 .
- FIG. 4 is a flowchart illustrating other example operations of the system of FIG. 1 .
- FIG. 5 is a flowchart illustrating more example operations of the system of FIG. 2 .
- FIG. 6 is a flowchart illustrating example operations of the system of FIG. 2 .
- FIG. 7 is a flowchart illustrating other example operations of the system of FIG. 2 .
- FIG. 1 is a schematic block diagram of a system 100 for identifying different URLs that reference the same content and for generating canonical URLs that are equivalent, for purposes of identifying the content, to the different URLs that reference the same content.
- the system 100 can receive, as input, a number of different URLs, some of which reference the same content and some of which reference different content. Based on this input the system can determine which portions of the URLs are relevant, and which portions are irrelevant, to the identification of the content. From this information the system 100 may determine canonical URLs that provide a simple template of the basic relevant parameters that are required to identify content.
- a canonicalized version of the new URL can be compared to the canonical URLs, and if the canonicalized version of the new URL matches a canonical URL that references already-downloaded content, the new URL can be equated with the canonical URL, such that the content referenced by the new URL need not be downloaded. If a match is not found then the content referenced by the new URL can be downloaded for further analysis and use.
- a web crawler 104 can crawl or otherwise search through a corpus of content files 102 (e.g., websites available on the world-wide web (WWW)) to select material (e.g., web pages, documents, audio files, and video files) for storage in an indexed form in a data center 108 .
- a module 106 that includes an indexer 107 can compress, index, and rank the selected material before the material is stored in the data center 108 .
- an analysis module 110 can identify different URLs that reference the same content and can determine a canonical URL equivalent to the different URLs that reference the identical content.
- a client 112 may submit a search query to a search engine server 114 to request material relevant to the query.
- a user of the client 112 can enter the query through a web browser running on the client 112 .
- the query can be expressed in the form of an unstructured text string entered in a single entry field of the browser, and the query can include a number of phrases, where a phrase can be a single word, a group of words, or a character string.
- the query may include a text string that is generated from an audio file, e.g., when the user submits a query in the form of a spoken message that is converted to the text string through a voice recognition processor.
- An intake module 116 of the server 114 can receive the query from the client 112 , and a parser 118 can parse the query into subcomponents.
- a search engine running on the server 114 can use phrases specified in the query, as well as synonyms and stems for the phases, to identify highly-ranked material that satisfy the query.
- the server 114 can return responses to the query via an output module 120 to the web browser of the client 112 , where the responses contain information (e.g., webpages, documents, video files, audio files) satisfying the query along with ranking information and references to the identified documents.
- the query can include a URL that references content desired by a user.
- the URL of the desired content, and/or parsed components of the URL can be passed to the compression, indexing, and ranking module 106 , where a comparison module 121 can compare it to a list of canonical URLs stored in database 128 . If a match between a canonical URL and a canonicalized version of the URL of the desired content exists, the desired content can be served from the data store 108 , and if a match does not exist, the desired content can be sourced from another location.
- a download module 122 (e.g., included in the web crawler 104 ) can be used to download content files identified by URLs.
- the web crawler 104 can include a program or an automated script that browses the WWW in a methodical, automated manner to identify content for analysis, storage, and serving to client users.
- the download module 122 can be used to download content files identified by URLs.
- the web crawler 104 can include a program or an automated script that browses the WWW in a methodical, automated manner to identify content for analysis, storage, and serving to client users.
- the download module 122 can be downloaded by the download module 122 .
- the web crawler can identify the content referenced by all URLs on a web page for download. Then, any URLs in the downloaded content can be followed to identify additional content for downloading. This process of following the links in the URLs of downloaded content to identify additional content for downloading can be repeated to identify and download a large corpus of content.
- Other implementations of the web crawler can use different methods to
- the analysis module 110 can analyze the URLs and the content to determine parameters of the URLs that are relevant or irrelevant to the identification of unique content files.
- HTTP hypertext transfer protocol
- URLs typically include a host, a path, and a query.
- host specifies the name of the host
- path specifies a path on the host
- query specifies a query.
- http specifies that the HTTP protocol is used to access the content.
- the analysis module 110 can include a parser 111 configured to parse URLs to determine different parts of the URL (e.g., the host, path, and different parameters).
- two URLs that reference the same content file might differ in any of the host, the path, or the query parts of the URL.
- the host part (“xyz.com”) and the path part (“content”) of the URLs are identical, and the three URLs differ only in their query parts.
- the query portion of the URLs can include a sequence of parameter-value pairs separated by ampersands. In general, the exact order of the parameters within the URL does not play a role in identifying particular content.
- a canonicalization function that transforms the input URL into its equivalence class can be applied to the URLs and the results of the function can then be compared.
- the URLs shown in equations (4) and (5) point to the same content, and their canonicalized URLs are also equal, as they should be.
- the URL shown in equation (6) points to different content and has a different canonical URL than that of the URLs shown in equations (4) and (5).
- Such a canonicalization function is universal across HTTP URLs and can be applied to any URL.
- the question of whether the parameter can be safely removed from the URL according to a canonicalization function depends on how the parameter is used in URLs that are specific to a particular host.
- Other parameters that are common to many hosts may be classified as either universally relevant or universally irrelevant to the identification of a content item.
- Parameters that generally are relevant across all hosts are parameters whose values capture the most information about which content item is being requested, e.g. a filename, a folder, or a content ID.
- a good canonicalization function maintains such parameters as relevant, while discarding parameters that are identified as irrelevant to the identification of specific content items.
- relevant parameters can include parameters that uniquely identify a content file, e.g., a content identification parameter or a path that includes a filename.
- Relevant parameters also include parameters that assist in uniquely identifying a content file, even though the parameters themselves do not uniquely identify the content, e.g., parameters that identify a path, a content category, and certain parameters that identify some general file names of file types (e.g., file extensions that are generally known to refer to different content, such as “mpg,” “mov,” and “wmv.”
- Irrelevant parameters can include parameters that refer to state information, session parameters that are not essential for retrieval (e.g., tracking IDs), session parameters essential for retrieval but that do not identify or assist in identifying content (e.g., login information or session IDs), and parameters that are obsolete.
- irrelevant vs. relevant parameters may be necessary to the retrieval of the content, even though their value does not give information about which content item is referenced by the URL. For example, a host specified by the URL may require such a parameter to validate a user's login credentials. Because a canonicalization function is used only to determine which equivalence class a URL falls into for purposes of identifying a content item, and is not used to generate a valid URL that could be used to retrieve the content item, necessary, irrelevant parameters can be discarded by a canonicalization function even if they are necessary for the retrieval of the content. Thus, although canonical URLs are useful for relating different URLs that reference the same content, canonical URLs cannot necessarily be used to retrieve the content.
- an information content calculation module (ICCM) 124 within the analysis module 110 can analyze the relationships between a number of different URLs and a number of different content files referenced by the URLs to determine the information content of each parameter.
- the ICCM 124 can use a generalized algorithm based on information theory to classify each parameter as relevant or irrelevant given a corpus of URLs and the content referenced by the URLs. This corpus can be compiled from URLs that have been crawled by the web crawler 104 and the content that has been downloaded by the download module 122 .
- the ICCM 124 receives as input a number of URLs that differ in at least some of their query parameters and also receives as input fingerprints of the content referenced by the URLs.
- a fingerprint of a content file can be a hash of the content file (e.g., an MD5 hash), which provides a small-size hexadecimal string that represents the content file.
- the fingerprints of the content files can be downloaded by the download module 112 , or can be generated within the system 100 by a fingerprint generator 116 .
- the fingerprint generator 116 can be part of the analysis module 110 .
- the fingerprint of a content item can be the entire content item itself.
- the information content of a parameter can be illustrated with the examples shown in the following four tables, each of which considers a case showing four relationships between the value of the URL parameter and a fingerprint of a content file referenced by the URL.
- the value of a parameter, V is shown in a column on the left
- a fingerprint (FP) is shown in a column on the right.
- the ICCM 124 can compute an entropy of the fingerprint values conditional on the values of the parameters of the URLs and an entropy of the parameter values conditional on the fingerprint values.
- These entropies can also be known as the conditional entropies, H(fingerprints
- V) also can be known as the entropy of fingerprint values conditional on the parameter values
- F) can be known as the entropy of the parameter values conditional on the fingerprint values. Both entropies can be measured in units of bits.
- F) is H ( V
- V) is H ( F
- F) 2 bits and H(F
- V) 0 bits.
- F) 1 bits and H(F
- V) 1 bit.
- F) 0 bits and H(F
- V) 0 bits.
- V) represents the uncertainty that remains about which fingerprint is pointed to by a URL having a particular parameter, given that the value of the parameter is known. If H(F
- F) represents the uncertainty that remains about the value of the parameter, given that the fingerprint is known. If the parameter value is essentially random and not related to the fingerprint, H(V
- a relevancy calculation module (RCM) 126 , which can determine whether a parameter is relevant or not, based, at least in part, on the values of H(F
- RCM relevancy calculation module
- the above calculations can be applied to a group of URLs that all refer to the same host and path, or to a group of URLs that all refer to the same host but to different paths, or to URLs that can refer to any host/path combination.
- entropies when entropies are calculated for a cluster of URLs that refer to a particular host or host/path combination, if the host or host/path cluster contains fewer than a fixed number of URLs, no rules are generated for the cluster. Otherwise, for each query parameter in the URLs, the ICCM 124 and the RCM 126 can determine whether the parameter is relevant or not, using the entropy quantities described above.
- a canonical URL generator (CUG) 127 can generate canonical URLs by applying rules to parameters of a URL based on whether the parameters in the URLs are relevant or not.
- the rule can be ⁇ ParameterName: IGNORE>.
- the rule can be ⁇ ParameterName: ACCEPT>.
- the automatically generated rules for each host or host/path can be merged together and applied by the CUG 127 to all URLs that reference the particular host.
- the automatically generated rules can also be combined with a list of manually generated heuristic rules to generate the final list of rules for each host.
- Such manually generated rules may include a rule that orders individual URL parameters alphabetically, a case-sensitivity rule that converts all upper case letters to lower case letters, a rule that deems any parameter having a name equal to “vid,” “file,” or “path” to be relevant, and a rule that deems any parameter having a name equal to “sessionid” to be irrelevant.
- a database of such rules can be maintained in the system 100 , e.g., in the RCM 126 .
- the entropy calculation is performed for parameters using all URLs for a given host, rather than for individual host/path clusters on a host, no host/path rule merging is required.
- the automatically generated rules can also be combined with the list of manually generated heuristic rules.
- the RCM 126 may determine that the rule for the parameter can be host/path specific, such that it is different for different host/path combinations. In another implementation, the RCM 126 may determine the final rule for the parameter, which can apply for all host/path combinations, by calculating a ratio between the number of host/paths for which the parameter is relevant to the number of host/paths for which the parameter is irrelevant.
- the RCM 126 may determine that the parameter is a relevant final rule, and if the ratio is below or equal to the threshold value then the RCM 126 may deep the parameter to be irrelevant. In another implementation, the RCM 126 may determine that a parameter is relevant for all paths on a host if the parameter is determined to be relevant on any of the paths for the host.
- an automatically generated rule for a URL parameter may conflict with a manually generated heuristic rule for a particular host.
- the manually generated heuristic rule may trump the automatically generated rule for that URL parameter on that host.
- the final rules as determined by the ICCM 124 and the RCM 126 can be used by the CUG 127 in a canonicalization function to transform a URL into its equivalence class, for example, by accepting or rejecting certain parameters as relevant for purposes of identifying a unique content file.
- Canonical URLs can be stored in a data store 128 , which, in one implementation, can be part of the compression, indexing, and ranking module 106 .
- a canonicalization function can be applied to compare URLs that reference the same host and path, or URLs that reference only the same host, or URLs that reference any host and any path.
- the canonicalization function may not drop any query parameters, but it may alter the URL according to the one or more heuristic rules.
- URL parameters can be ordered alphabetically or made case-insensitive.
- URLs can be unescaped, to convert them to their unescaped equivalents.
- special URL encoded characters e.g., “%20,” which represents a space between characters in an HTTP URL
- query parameters can be deemed relevant or irrelevant based on a fixed list of relevant or irrelevant parameters.
- the web crawler 104 can use the canonical URLs as follows. As the web crawler 104 crawls through and extracts URLs from web pages, an extracted URL can be parsed, e.g., by a parser 130 , to determine the components of the URL and then the URL is canonicalized according to a canonicalization function to produce a canonical URL. A comparison module 132 of the web crawler 104 can query the database 128 to determine whether a matching canonical URL exists in the database 128 , and if a content item corresponding to the matching URL has been retrieved before. If the content item has been retrieved before, the download module 122 of the crawler need not download the content again, and the web crawler 104 can discard the URL from further consideration.
- the download module 122 downloads the content referenced by the original extracted URL (not the canonicalized URL) and stores the content in the data store 108 .
- the ICCM 124 , the RCM 126 , and the CUG 127 can generate a canonical URL from the original extracted URL, and this canonical URL is stored in the database 128 and serves to index the downloaded content.
- An indexer 107 can index the content, such that the content can be easily retrieved based on the index information, such as, for example, the canonical URL, keywords, and other metadata.
- the fingerprint generator 116 can compute a fingerprint of the downloaded content to provide training data for the above-described information theoretical techniques used to generate canonical URLs.
- the download module 122 can periodically download a small, random sample content items that are referenced by discarded URLs. These discarded URLs and the content they point to can provide further evidence to support or refute existing rules, or can provide training data for new rules.
- a query parameter of a URL can itself be a URL.
- the presence of certain, specific character sequences e.g. “http” and “://” in the value of a query parameter can indicate that the query parameter is in fact itself a URL.
- the relevance of a group of two or more parameters, considered together can be determined by the ICCM 124 and the RCM 126 . This is done because the group of parameters might be considered relevant by the RCM 126 even if the parameters would be deemed irrelevant when considered individually.
- This relevancy information can be determined automatically as follows. After an initial analysis, as described above, of whether or not parameters on a host are individually relevant, the ICCM 124 and the RCM 126 can analyze tuples (e.g., pairs, triples etc.) of query parameters, where at least one of the parameters in the tuple has been marked as individually irrelevant. Then, the ICCM 1224 can determine H(V′
- tuples e.g., pairs, triples etc.
- the ICCM 124 would determine that H(V′
- F) 0 and H(F
- V′) 0.
- the RCM 126 therefore would determine that the tuple is relevant, and both the path and file parameters would be deemed relevant for purposes of identifying a content file.
- a canonicalization function would retain both parameters as relevant.
- Whether a URL parameter is case-sensitive for purposes of identifying a content file, can be analyzed by the system 100 .
- the parameter likely is not case-sensitive.
- a canonicalization function applied by the CUG 127 can discard case information for case-insensitive query parameters, but retain case information for case-sensitive parameters.
- the analysis module 110 can determine automatically whether or not a parameter is case-sensitive as follows.
- the ICCM 124 can create a set of test URLs in which the case information of a parameter is removed by converting each value of the parameter into lower case for all the URLs in the set.
- the set of URLs with a value having its case information removed can be denoted as lower(V).
- the ICCM 124 can determine the quantity, H(F
- the value of this quantity is 1 bit, which, if the value of the threshold is less than 1, would indicate that the parameter is case-sensitive and that the case of the parameter values should be preserved according to a canonicalization function.
- the ICCM 124 can determine the information content of a path for purposes of identifying a content file.
- path components of a set of URLs can be considered as URL parameters, and the entropy values, H(V
- this analysis is performed on a per-host basis, such that the information content of paths on a particular host are considered.
- the generated canonicalization rules then would specify on a per-host basis whether the path itself or any of its components should be stripped during canonicalization.
- the path parameter may be irrelevant to the identification of the content file and can be stripped from the URL during canonicalization of the URL.
- a path would be deemed to be irrelevant if considered individually, but a tuple of the path and one or more query parameters may be deemed to be relevant, so path parameters generally should be analyzed together with the regular query parameters as tuples, as described above.
- Calculating a conditional entropy of a host portion of a set of URLs to determine whether the host is relevant to the identification of unique content files may not yield significant information.
- certain parts of a host name can be analyzed individually to determine whether they are relevant to the identification of a unique content file. For example, a portion of the host name that appears before the domain name can be analyzed (e.g., in the host name, video.google.com, the domain is “google.com” and the prefix is “video.”).
- the non-domain prefix part of the host can be treated as a separate query parameter to be processed by the ICCM 124 to determine its information content.
- the analysis module 110 can pass a known URL that references a known content item having a known fingerprint to the web crawler 104 .
- the analysis module 110 can instruct the web crawler 104 to modify or remove a value of the URL parameter that is initially determined to be irrelevant and then to download the content item referenced by the modified URL.
- the comparison module 132 can compare the downloaded content item to the known content item (or can compare their fingerprints).
- a smaller size fingerprint of the content file can be downloaded by the download module 122 . For example, if two HTTP content files are identical, it is likely that value of the “Content-Length” header field of the two files also is identical.
- the download module 122 may issue an HTTP HEAD request to download some or all header information of content files referenced by URLs rather than issuing an HTTP GET request to download the entire content, and the information downloaded in response to the HEAD request can be used as a fingerprint of the content files in the entropy calculations performed by the ICCM 124 .
- the ultimate determination of whether or not a URL parameter is relevant to the identification of content files can be based on multiple sources of information, including the conditional entropy calculations, H(V
- the RCM 126 may determine that a relevance determination based on the conditional entropy calculations is accurate 90% of the time, that a relevance determination based on manual heuristic rules is accurate 95% of the time, and that a relevance determination based on a fixed list of relevant and irrelevant parameters is accurate 80% of the time. Then, the RCM 126 may compute a probability that a parameter is relevant based on the combination of the information derived from these different analyses.
- an initial determination of the probability that the parameter is relevant can be determined by the RCM 126 . Then, only parameters whose probabilities lie within some predetermined range of uncertainty (e.g. 10% ⁇ p ⁇ 90%) would be tested by the HTTP HEAD or HTTP GET request for content referenced by a modified URL.
- portions of a host name can be analyzed to determine whether they provide information relevant to the identification of a particular content file. For example, in the host name, “video.google.com,” the domain is “google.com” and the prefix is “video,” and the prefix may provide information relevant to the identification of a particular content file. It is also possible to identify automatically the prefix portions of URLs, as well as other character strings.
- FIG. 2 is a schematic block diagram of a system 200 for automatically identifying automatically significant prefixes in a group of character strings (e.g., URLs), where the prefixes are significant in that they are portions of URLs or character strings that are common to a statistically significant portion of the URLs or character strings in a group of URLs or character strings. Identification of such significant prefixes can be beneficial for identifying and classifying similar subject matter. For example, in the case of a collection of URLs, by identifying prefixes that are common to a group of URLs, common subject matter referenced by the URLs of the group can be identified.
- URLs e.g., URLs
- the URL parameters in the significant prefix can be deemed irrelevant for the identification of content files, such that only the remaining URL parameters that are not part of the significant prefix need to be analyzed to determine if they are relevant or not.
- Significant suffixes in a collection of character strings also can be identified automatically, which can be beneficial for identifying, for example, common file extensions in a number of content identifiers.
- the system 200 can receive, as input, a number of different character strings. Based on this input, the system 200 can determine whether certain initial substrings in the strings are significant prefixes or whether they are just randomly occurring character sequences. The system 200 also can determine whether certain terminal substrings in the strings are significant suffixes or whether they are just randomly occurring substrings of characters. To do this, an analysis module 202 can analyze individual strings in a collection of strings to determine whether a unique substring of characters at the beginning and/or end of the strings occurs with a frequency that is statistically significant enough to determine that the unique substring must be a deliberate sequence of characters that is a prefix or suffix and not a randomly occurring sequence of characters.
- an analysis module 202 can receive a plurality of character strings for analysis via an input module 204 .
- the input module 204 can receive the plurality of character strings from a variety of different places.
- the input module 204 can receive the character strings from a data store 206 , where the data store can be a local data store or a remote data store.
- the data store could be a data store 108 that stores URLs identified and stored by a web crawler 104 .
- the input module 202 can receive the character strings via a connection to a network 208 (e.g., to a Wide Area Network or to a Local Area Network) from another device that is also connected to network.
- a network 208 e.g., to a Wide Area Network or to a Local Area Network
- the input module 204 can pass the character strings to a string parser 210 that can parse the strings into substrings that can be analyzed to determine whether the substrings are significant affixes (i.e., prefixes or suffixes) in the plurality of strings.
- the substrings can be a single character long or can be as long as the character string from which the substring is derived.
- a counter 212 in the analysis module 202 can count a number of different quantities.
- the counter 212 can count the number of strings in the plurality of strings having at least one character, having at least two characters, having at least three characters, etc., up to the number of strings having the greatest number of characters of any string in the plurality of strings.
- the counter 212 also can count the number of strings having a unique substring of characters at the beginning of the string. For example, among the strings, “aad,” “ad,” “art,” “aab,” “aa,” “aardvark,” “aat,” “bad,” “base,” the counter 212 may count four strings that include the substring “aa” at the beginning of the string.
- the counter 212 may count three strings that include the substring “Prefix_” and two strings that include the substring “Pre_” at the beginning of the string.
- a probability calculator 214 in the analysis module 202 can be used to determine a probability with which a particular character substring would occur at the beginning or end of a string, based on information about the character set from which the strings are drawn and a probability distribution over characters in the character set from which the strings are drawn.
- the probability calculator 214 may use as input a particular predetermined character set from which the strings are drawn.
- the probability calculator 214 may use as input an empirically determined character set from which the strings are drawn.
- a character code from which the strings are drawn can be determined by the string parser 210 , which may parse the plurality of character strings to determine a character code of all the characters used in the character strings.
- the probability distribution over characters can be a uniform distribution. That is, for a character set having s characters, the probability of finding a specific character at a given position in a string may be assumed to be 1/s.
- the probability distribution over characters can be a non-uniform distribution, where the actual distribution is determined according to a priori assumptions or according to empirically determined information. For example, in one non-uniform probability distribution of characters, a probability of a particular character occurring in the character strings may be set equal to a generally accepted probability of the character occurring in a particular language (e.g., English).
- the probability of a particular character occurring in the character strings may be set proportional to the frequency of the character in a corpus of content (e.g., text from randomly sampled web pages, URLs randomly sampled from the Internet, examples of a particular genre of literature, records randomly sampled from a particular database).
- the probability of a particular character occurring in the character strings may be determined empirically by determining the frequency with which each character used in the character strings occurs in the corpus of character strings under consideration and then using this frequency, appropriately normalized, as the probability with which the character will occur in the character strings.
- T a test statistic
- the numerator of eq. (23) gives the probability that the character sequence of the prefix occurs M or more times, while the denominator gives the probability that the prefix occurs at least once.
- the result of the test statistic calculations can be passed to a comparison module 216 that can compare the value of the test statistic to a desired significance level. Based on this comparison, the comparison module 216 can determine whether the character sequence is a significant prefix or whether the character sequence is only a random or otherwise insignificant occurrence. For example, the comparison module 216 may determine that the character sequence under investigation is a significant prefix if the test statistic is lower than a significance level.
- the significance level can be representative of, for example, a one, two, three, or four sigma event.
- significant prefixes having a length of 1 character up to a length L are sought, where L is the length of the longest string.
- the loop may begin by searching for significant prefixes with a minimum length greater than 1 character (e.g., if the strings are all URLs beginning with “www”) and may end with a maximum length that is less than the length of the longest string (e.g., so that very long prefixes are not sought and/or because prefixes having a length equal to the length of the longest string can be disallowed, as explained below).
- a sublist of strings having a length greater than or equal to i is considered, and within the sublist, substrings having X characters at the beginning of the string are considered.
- the number of strings, M, having the same sequence of X characters at the beginning of the string is counted. Also, the total number, N x , of strings having at least X characters is counted, and a test statistic, T, is determined. If the value of the test statistic is below a predetermined value, then this indicates that the event of seeing at least this many repetitions of the same substring just by chance is sufficiently unlikely, and the substring, S, is deemed a significant prefix.
- the comparison module 216 may determine that the following group of character strings are significant prefixes: “P,” “Pr,” Pre,” “Pref,” Prefi,” “Prefix,” “Prefix,” “Prefix1_,” Pre_,” “R,” “Re,” “Rep,” “Repe,” “Repea,” “Repeat.”
- the comparison module 216 can additionally filter the group by eliminating from the group any character string that is a subprefix of another longer prefix.
- this rule would eliminate the character strings “P,” “Pr,” Pre,” “Pref,” Prefi,” “Prefix,” “Prefix,” “R,” “Re,” “Rep,” “Repe,” and “Repea” from the group.
- a group of character strings flagged as significant prefixes also can be filtered by eliminating from the group any character string that is not followed by another character in the plurality of character strings. Application of this rule to the above group of strings would result in the string “Repeat” being removed from the group.
- the data store 206 or 208 can be a random access memory (RAM), a hard disk, an optical disk, a flash memory, a paper copy or any kind of temporary or permanent storage medium.
- RAM random access memory
- the data store 206 or 208 can be a random access memory (RAM), a hard disk, an optical disk, a flash memory, a paper copy or any kind of temporary or permanent storage medium.
- prefixes and suffixes of a string can both be known as affixes at extremities of strings, which can be determined automatically using the techniques described above.
- FIG. 3 is a flowchart 300 illustrating example operations of the system of FIG. 1 .
- a plurality of uniform resource locators are received ( 302 ).
- the URLs can be received as a result of a web crawling process performed by the web crawler 104 .
- the URLs can be received from a database that stores a group of URLs.
- the URLs identify content files, and include at least one parameter.
- An information content of a first parameter of the URLs is determined, where the information content provides a measure of the relevance of the parameter to the identification of a unique content file ( 304 ). Then, it is determined, based, at least in part, on the information content of the parameter, that the first parameter is irrelevant to the identification of a unique content file by the URLs ( 306 ).
- the information content of the first parameter can be determined by an ICCM 124 that calculates an entropy of values of the fingerprints conditional on values of the first parameter for the URLs and that calculates an entropy of values of the first parameter conditional on values of the fingerprints.
- an information content of a second parameter of the URLs can be determined ( 308 ). Then, it can be determined, based, at least in part, on the information content of the second parameter, that the second parameter is relevant to the identification of a unique content file by the URLs ( 310 ).
- the information content of the second parameter also can be determined by the ICCM 124 , which can calculate an entropy of values of the fingerprints conditional on values of the second parameter and which can calculate an entropy of values of the first parameter conditional on values of the fingerprints.
- Another URL can be received in addition to the plurality of URLs ( 312 ), and the other URL can be identified as equivalent to one of the plurality of URLs for purposes of identifying a particular content file ( 314 ), based at least on the other URL and the equivalent URL having an identical value for the second parameter, even though the other URL and the equivalent URL have different values for the first parameter.
- the web crawler 104 may locate a URL as a result of a crawling process, which may be canonicalized and compared to the canonical URLs in the database 128 . If the other URL and one of the canonical URLs have identical values for relevant parameters in the URLs they may be identified as equivalent for purposes of identifying a content file, even though the other URL and the equivalent URL have different values for the first parameter.
- the server can compare the other URL to canonical URLs stored in a database. Then, if the other URL and one of the canonical URLs have identical values for relevant parameters in the URLs they may be identified as equivalent for purposes of identifying a content file, even though the other URL and the equivalent URL have different values for the first parameter. If such a match is found between the canonicalized form of the other URL and one of the canonical URLs, then the server may serve the requested content from cached content that is identified by the canonical URL.
- a copy of a particular content file can be cached ( 316 ), and a copy of the cached particular content file can be served ( 318 ) in response to a request for a content file identified by the other URL, and a copy of the cached particular content file also can be served in response to a request for a content file identified by the equivalent URL ( 320 ).
- FIG. 4 is a flowchart 400 illustrating other example operations of the system of FIG. 1 .
- a plurality of URLs are received ( 402 ), where the URLs identify a host and content files and include at least one parameter.
- An information content of the parameters, relevant to the identification of a unique content file, is determined ( 404 ), and the determination is based, at least in part, on an entropy of values of fingerprints of the content files conditional on values of the parameters and based, at least in part, on an entropy of values of the parameters conditional on values of the fingerprints.
- First parameters that are irrelevant to the identification of a unique content file on the host by the URLs are determined ( 406 ) based, at least in part, on the information content of the first parameters.
- second parameters that are relevant to the identification of a unique content file on the host by the URLs are determined ( 408 ) based, at least in part, on the information content of the second parameters.
- canonical URLs for identifying content files on the host can be determined based on which of the first and second parameters are included in the received URLs ( 410 ) and these canonical URLs can be stored ( 412 ) (e.g., in the database 128 ).
- the CUG 127 can canonicalize one of the received URLs by applying a canonicalization function to the URL.
- the canonicalization function can act to retain relevant parameters and discard irrelevant parameters in the received URL.
- Another URL in addition to the plurality of URLs can be received ( 416 ).
- the other URL can be canonicalized and compared to the stored canonical URLs ( 418 ), and, if the comparison yields a match between the other URL and a stored canonical URL ( 420 ), then a content file identified by the other URL can be downloaded and stored ( 422 ). Otherwise, a content file identified by the other URL can be equated with an already-stored content file identified by the canonical URL that matches the other URL ( 424 ).
- FIG. 5 is a flowchart 500 illustrating other example operations of the system of FIG. 1 .
- a plurality of URLs are received ( 502 ), where the URLs identify a host and content files and include at least one parameter.
- An information content of the parameters, relevant to the identification of a unique content file, is determined ( 504 ), and the determination is based, at least in part, on an entropy of values of fingerprints of the content files conditional on values of the parameters and based, at least in part, on an entropy of values of the parameters conditional on values of the fingerprints.
- First parameters that are irrelevant to the identification of a unique content file on the host by the URLs are determined ( 506 ) based, at least in part, on the information content of the first parameters.
- second parameters that are relevant to the identification of a unique content file on the host by the URLs are determined ( 508 ) based, at least in part, on the information content of the second parameters.
- a URL is received, where the URL includes a first parameter that has been determined to be irrelevant to the identification of a unique content file on the host ( 510 ).
- a first fingerprint of a content file identified by the received URL is received ( 512 ).
- a test URL identical to the received URL but for the omission of the first parameter from the test URL is generated ( 514 ).
- a second fingerprint of a content file identified by the test URL is received ( 516 ), and the first and second fingerprints are compared ( 518 ). The determination that the first parameter is irrelevant to the identification of a unique content file on the host can be refined based at least in part on the comparison ( 520 ).
- FIG. 6 is a flowchart 600 illustrating example operations of the system of FIG. 2 .
- a plurality of character strings is received ( 602 ).
- the input module 204 may receive the plurality of strings from the data store 206 .
- the number of strings (M) in the plurality of strings having a unique substring of X characters at an extremity of string is determined ( 604 ).
- the counter 212 can count the number M.
- the number of strings (N) in the plurality of strings having at least X characters in the string can be counted ( 606 ), e.g., by the counter 212 .
- a probability can be determined, based on a predetermined model for a distribution of characters in the strings, that the unique substring of X characters would occur M or more times out of the N strings, given that the unique character string occurs at least once ( 608 ).
- the probability calculator 214 can determine this probability. Based on the probability, the number M, and the number N, it can be determined that the unique character string is a significant affix in the plurality of character strings ( 610 ).
- the comparison module 216 can perform this comparison.
- the unique character string that has been determined to be a significant affix is stored ( 612 ), e.g., on data store 206 or 218 .
- FIG. 7 is a flowchart 700 illustrating other example operations of the system of FIG. 2 .
- a plurality of character strings is received ( 702 ).
- the number of strings (M) having the unique substring is determined ( 704 ), where X runs from a predetermined minimum length to a predetermined maximum length.
- the numbers of strings (N X ) in the plurality of strings having at least X characters in the string is determined ( 706 ).
- a probability is determined, based on a predetermined model for a distribution of characters in the strings, that the unique character substrings would occur M or more times out of the N X strings, given that the unique character string occurs at least once ( 708 ). Based on the probability, the number M, and the number N X , it is determined ( 710 ) whether the unique character strings of X characters are significant affixes in the plurality of character strings. For unique character strings that are significant affixes, at least one of the unique character strings is stored ( 712 ).
- Implementations of the various techniques described herein may be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. Implementations may implemented as a computer program product, i.e., a computer program tangibly-embodied in a machine-readable storage device (e.g., a random access memory, a read only memory, a hard disk, an optical disk, or combinations thereof), for execution by, or to control the operation of, data processing apparatus, e.g., a programmable processor, a computer, or multiple computers.
- a machine-readable storage device e.g., a random access memory, a read only memory, a hard disk, an optical disk, or combinations thereof
- data processing apparatus e.g., a programmable processor, a computer, or multiple computers.
- a computer program such as the computer program(s) described above, can be written in any form of programming language, including compiled or interpreted languages, and can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.
- a computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.
- Method steps may be performed by one or more programmable processors executing a computer program to perform functions by operating on input data and generating output. Method steps also may be performed by, and an apparatus may be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
- FPGA field programmable gate array
- ASIC application-specific integrated circuit
- processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer.
- a processor will receive instructions and data from a read-only memory or a random access memory or both.
- Elements of a computer may include at least one processor for executing instructions and one or more memory devices for storing instructions and data.
- a computer also may include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks.
- Information carriers suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.
- semiconductor memory devices e.g., EPROM, EEPROM, and flash memory devices
- magnetic disks e.g., internal hard disks or removable disks
- magneto-optical disks e.g., CD-ROM and DVD-ROM disks.
- the processor and the memory may be supplemented by, or incorporated in special purpose logic circuitry.
- implementations may be implemented on a computer having a display device, e.g., a cathode ray tube (CRT) or liquid crystal display (LCD) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer.
- a display device e.g., a cathode ray tube (CRT) or liquid crystal display (LCD) monitor
- keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
- Implementations may be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation, or any combination of such back-end, middleware, or front-end components.
- Components may be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (LAN) and a wide area network (WAN), e.g., the Internet.
- LAN local area network
- WAN wide area network
Abstract
A computer-implemented method includes receiving a plurality of character strings. The number of strings (M) in the plurality of strings having a unique substring of X characters at an extremity of the string is determined, the number of strings (N) in the plurality of strings having at least X characters in the string is determined. A probability is determined, based on a predetermined model for a distribution of characters in the strings, that the unique substring of X characters would occur M or more times out of the N strings, given that the unique character string occurs at least once. Based on the probability, the number M, and the number N, it is determined that the unique character string is a significant affix in the plurality of character strings, and the unique character string is stored.
Description
This description relates to online crawling and search and, in particular, to detecting common prefixes and suffixes in a list of strings.
Online resources or content items (e.g., web pages, video files, audio files, documents, etc.) available on the Internet can be associated with a document identifier, e.g., a Uniform Resource Locator (URL), that can be used to identify and locate a content item. Because the Internet is organic and heterogeneous, often many distinct URLs point to the same content item. Thus, even though the URLs themselves are different, the data fetched from the distinct URLs can be identical. Because of this, a web crawler that loads URLs from link tags on web pages that point to content (e.g., to index, store, and make the content accessible via a search query) may download the identical content that is specified by two different URLs. Yet some kinds of resources (e.g., video files) require significant network resources to download compared with other online content (e.g., text-based HTML web pages), because these resources are intrinsically high bandwidth content. Because bandwidth is an expensive and limited resource, it is desirable to avoid downloading the same content more than once.
Therefore, there is a need for a system that automatically identifies and manages document identifiers that reference the same content and thereby reduces the waste of resources both on the search engine side and the web server side.
In a first general aspect, a computer-implemented method includes receiving a plurality of character strings. The number of strings (M) in the plurality of strings having a unique substring of X characters at an extremity of the string is determined, the number of strings (N) in the plurality of strings having at least X characters in the string is determined. A probability is determined, based on a predetermined model for a distribution of characters in the strings, that the unique substring of X characters would occur M or more times out of the N strings, given that the unique character string occurs at least once. Based on the probability, the number M, and the number N, it is determined that the unique character string is a significant affix in the plurality of character strings, and the unique character string is stored.
In another general aspect, a computer-implemented method includes receiving a plurality of character strings. For unique character substrings of X characters at an extremity of strings in the plurality of strings, the number of strings (M) in the plurality of strings having the unique substring is determined, where X runs from a predetermined minimum length to a predetermined maximum length. For the different values of X, the numbers of strings (NX) in the plurality of strings having at least X characters in the string is determined. For the unique character strings of X characters, a probability is determined, based on a predetermined model for a distribution of characters in the strings, that the unique character substrings would occur M or more times out of the NX strings, given that the unique character string occurs at least once. Based on the probability, the number M, and the number NX, it is determined whether the unique character strings of X characters are significant affixes in the plurality of character strings, and for unique character strings that are significant affixes, at least one of the unique character strings is stored.
In another general aspect, a computer program product tangibly embodied on a computer-readable medium includes executable instructions that, when executed, are configured to cause a data processing apparatus to receive a plurality of character strings. The executable instructions, when executed, are configured to cause the data processing apparatus to determine, for unique character substrings of X characters at an extremity of strings in the plurality of strings, the number of strings (M) in the plurality of strings having the unique character substring, where X runs from 1 to n, with n being the length in characters of the longest character string in the plurality of strings. The executable instructions, when executed, further are configured to cause the data processing apparatus to determine, for the different values of X, the number of strings (NX) in the plurality of strings having at least X characters in the string, and, for the unique character strings of X characters, to determine a probability, based on a predetermined model for a distribution of characters in the strings, that the unique character substrings would occur M or more times out of the NX strings, given that the unique character string occurs at least once. The executable instructions, when executed, further are configured to cause the data processing apparatus to determine, based on the probability, the number M, and the number NX, whether the unique character strings of X characters are significant affixes in the plurality of character strings, and, for unique character strings that are significant affixes, to store at least one of the unique character strings.
In one implementation, a web crawler 104 can crawl or otherwise search through a corpus of content files 102 (e.g., websites available on the world-wide web (WWW)) to select material (e.g., web pages, documents, audio files, and video files) for storage in an indexed form in a data center 108. A module 106 that includes an indexer 107 can compress, index, and rank the selected material before the material is stored in the data center 108. As discussed in more detail below, an analysis module 110 can identify different URLs that reference the same content and can determine a canonical URL equivalent to the different URLs that reference the identical content.
During a search process, a client 112 may submit a search query to a search engine server 114 to request material relevant to the query. For example, a user of the client 112 can enter the query through a web browser running on the client 112. The query can be expressed in the form of an unstructured text string entered in a single entry field of the browser, and the query can include a number of phrases, where a phrase can be a single word, a group of words, or a character string. In some implementations, the query may include a text string that is generated from an audio file, e.g., when the user submits a query in the form of a spoken message that is converted to the text string through a voice recognition processor. An intake module 116 of the server 114 can receive the query from the client 112, and a parser 118 can parse the query into subcomponents. In response to query, a search engine running on the server 114 can use phrases specified in the query, as well as synonyms and stems for the phases, to identify highly-ranked material that satisfy the query. The server 114 can return responses to the query via an output module 120 to the web browser of the client 112, where the responses contain information (e.g., webpages, documents, video files, audio files) satisfying the query along with ranking information and references to the identified documents.
In another implementation, the query can include a URL that references content desired by a user. The URL of the desired content, and/or parsed components of the URL can be passed to the compression, indexing, and ranking module 106, where a comparison module 121 can compare it to a list of canonical URLs stored in database 128. If a match between a canonical URL and a canonicalized version of the URL of the desired content exists, the desired content can be served from the data store 108, and if a match does not exist, the desired content can be sourced from another location.
To identify content for storage in the data store 108, a download module 122 (e.g., included in the web crawler 104) can be used to download content files identified by URLs. For example, the web crawler 104 can include a program or an automated script that browses the WWW in a methodical, automated manner to identify content for analysis, storage, and serving to client users. Once the content has been identified by the web crawler it can be downloaded by the download module 122. In one implementation, the web crawler can identify the content referenced by all URLs on a web page for download. Then, any URLs in the downloaded content can be followed to identify additional content for downloading. This process of following the links in the URLs of downloaded content to identify additional content for downloading can be repeated to identify and download a large corpus of content. Other implementations of the web crawler can use different methods to crawl, identify, and download online content.
Once a number of URLs and the content that they reference have been downloaded, the analysis module 110 can analyze the URLs and the content to determine parameters of the URLs that are relevant or irrelevant to the identification of unique content files. For example, hypertext transfer protocol (HTTP) URLs typically include a host, a path, and a query. Thus, in the example URL, http://host/path?query, “host” specifies the name of the host, “path” specifies a path on the host, and “query” specifies a query. The prefix “http” specifies that the HTTP protocol is used to access the content. Details of the structure and format of URLs can be found in the Internet request for comments (RFC) 2396 about uniform resource identifiers, available at http://www.faqs.org/rfcs/rfc2396.html, in Internet RFC 3986 about uniform resource identifier general syntax, available at http://www.ietforg/rfc/rfc3986.txt, and in Internet RFC2616 about the HTTP protocol, available at http://www.faqs.org/rfcs/rfc2616.html, each of which is incorporated herein by reference for all purposes. The analysis module 110 can include a parser 111 configured to parse URLs to determine different parts of the URL (e.g., the host, path, and different parameters).
In general, two URLs that reference the same content file (e.g., a video file) might differ in any of the host, the path, or the query parts of the URL. For example, the following four URLs might reference the same video content file:
http://xyz.com/content/video?file=news20080115&player=small (1)
http://xyz.com/content/video?player=small&file=news20080115 (2)
http://xyz.com/content/video?player=small&file=news20080115&irrelevantparam=1 (3)
In each case of the example URLs (1), (2), and (3), the host part (“xyz.com”) and the path part (“content”) of the URLs are identical, and the three URLs differ only in their query parts. Because this is true for a large proportion of URLs that point to the same video, we treat this example situation first, where only the query part of the URLs vary, while the host and the path are identical for all the URLs under consideration. As shown in the URLs above, the query portion of the URLs can include a sequence of parameter-value pairs separated by ampersands. In general, the exact order of the parameters within the URL does not play a role in identifying particular content.
http://xyz.com/content/video?file=news20080115&player=small (1)
http://xyz.com/content/video?player=small&file=news20080115 (2)
http://xyz.com/content/video?player=small&file=news20080115&irrelevantparam=1 (3)
In each case of the example URLs (1), (2), and (3), the host part (“xyz.com”) and the path part (“content”) of the URLs are identical, and the three URLs differ only in their query parts. Because this is true for a large proportion of URLs that point to the same video, we treat this example situation first, where only the query part of the URLs vary, while the host and the path are identical for all the URLs under consideration. As shown in the URLs above, the query portion of the URLs can include a sequence of parameter-value pairs separated by ampersands. In general, the exact order of the parameters within the URL does not play a role in identifying particular content.
In general, to determine whether two URLs (URL 1 and URL2) reference, or point to, the same content without retrieving the content itself, a canonicalization function, C(URL), that transforms the input URL into its equivalence class can be applied to the URLs and the results of the function can then be compared. A perfect canonicalization function would have the property that C(URL1)=C(URL2) if and only if URL1 and URL2 point to the same content.
An example canonicalization function is a function that rearranges the parameter-value pairs of URLs, so that the parameter names are in alphabetical order. For example, such a function, when applied to the URLs, http://xyz.com/video?z=1&m=2&a=3, http://xyz.com/video?m=2&z=3&z=1, and http://xyz.com/video?z=1&q=4&a=3 yields:
C(http://xyz.com/video?z=1&m=2&a=3)=http://xyz.com/video?a=3&m=2&z=1 (4)
C(http://xyz.com/video?m=2&z=3&z=1)=http://xyz.com/video?a=3&m=2&z=1 (5)
C(http://xyz.com/video?z=1&q=4&a=3)=http://xyz.com/video?a=3&q=4&z=1 (6)
C(http://xyz.com/video?z=1&m=2&a=3)=http://xyz.com/video?a=3&m=2&z=1 (4)
C(http://xyz.com/video?m=2&z=3&z=1)=http://xyz.com/video?a=3&m=2&z=1 (5)
C(http://xyz.com/video?z=1&q=4&a=3)=http://xyz.com/video?a=3&q=4&z=1 (6)
The URLs shown in equations (4) and (5) point to the same content, and their canonicalized URLs are also equal, as they should be. The URL shown in equation (6) points to different content and has a different canonical URL than that of the URLs shown in equations (4) and (5). Such a canonicalization function is universal across HTTP URLs and can be applied to any URL.
There are other canonicalization functions that may be applicable to URLs that identify content on some hosts but may not be applicable to URLs that identify content on other hosts. For example, on some hosts, a particular query parameter might be unnecessary and can be dropped entirely without affecting the content the URL references. Thus, for example, the following two URLs might point to the same content, if the parameter “junk” in the URL is irrelevant to the identification of a content item:
http://xyz.com/video?junk=123&file=news.mpeg, (7)
http://xyz.com/video?file=news.mpeg. (8)
However, on a different host the parameter “junk” may provide useful information for the identification of unique content files an should not be discarded in a canonicalization process
http://xyz.com/video?junk=123&file=news.mpeg, (7)
http://xyz.com/video?file=news.mpeg. (8)
However, on a different host the parameter “junk” may provide useful information for the identification of unique content files an should not be discarded in a canonicalization process
Thus, for some URL parameters, the question of whether the parameter can be safely removed from the URL according to a canonicalization function depends on how the parameter is used in URLs that are specific to a particular host. Other parameters that are common to many hosts may be classified as either universally relevant or universally irrelevant to the identification of a content item. Parameters that generally are relevant across all hosts are parameters whose values capture the most information about which content item is being requested, e.g. a filename, a folder, or a content ID. Thus, a good canonicalization function maintains such parameters as relevant, while discarding parameters that are identified as irrelevant to the identification of specific content items.
For example, relevant parameters can include parameters that uniquely identify a content file, e.g., a content identification parameter or a path that includes a filename. Relevant parameters also include parameters that assist in uniquely identifying a content file, even though the parameters themselves do not uniquely identify the content, e.g., parameters that identify a path, a content category, and certain parameters that identify some general file names of file types (e.g., file extensions that are generally known to refer to different content, such as “mpg,” “mov,” and “wmv.” Irrelevant parameters can include parameters that refer to state information, session parameters that are not essential for retrieval (e.g., tracking IDs), session parameters essential for retrieval but that do not identify or assist in identifying content (e.g., login information or session IDs), and parameters that are obsolete.
Note that a distinction can be drawn between two partially related dichotomies: irrelevant vs. relevant parameters, and unnecessary vs. necessary parameters. Some parameters that are irrelevant to the identification of a content item may be necessary to the retrieval of the content, even though their value does not give information about which content item is referenced by the URL. For example, a host specified by the URL may require such a parameter to validate a user's login credentials. Because a canonicalization function is used only to determine which equivalence class a URL falls into for purposes of identifying a content item, and is not used to generate a valid URL that could be used to retrieve the content item, necessary, irrelevant parameters can be discarded by a canonicalization function even if they are necessary for the retrieval of the content. Thus, although canonical URLs are useful for relating different URLs that reference the same content, canonical URLs cannot necessarily be used to retrieve the content.
To determine automatically and empirically whether parameters used in a URL are relevant or irrelevant for purposes of identifying a content item, an information content calculation module (ICCM) 124 within the analysis module 110 can analyze the relationships between a number of different URLs and a number of different content files referenced by the URLs to determine the information content of each parameter. As explained in more detail below, the ICCM 124 can use a generalized algorithm based on information theory to classify each parameter as relevant or irrelevant given a corpus of URLs and the content referenced by the URLs. This corpus can be compiled from URLs that have been crawled by the web crawler 104 and the content that has been downloaded by the download module 122.
In general, the ICCM 124 receives as input a number of URLs that differ in at least some of their query parameters and also receives as input fingerprints of the content referenced by the URLs. A fingerprint of a content file can be a hash of the content file (e.g., an MD5 hash), which provides a small-size hexadecimal string that represents the content file. The fingerprints of the content files can be downloaded by the download module 112, or can be generated within the system 100 by a fingerprint generator 116. For example, the fingerprint generator 116 can be part of the analysis module 110. In another implementation, the fingerprint of a content item can be the entire content item itself. By examining each parameter of the URLs individually and how they relate to the fingerprints, the ICCM 124 can determine an information content, relevant to the identification of a unique content item, possessed by each parameter.
The information content of a parameter can be illustrated with the examples shown in the following four tables, each of which considers a case showing four relationships between the value of the URL parameter and a fingerprint of a content file referenced by the URL. In each case, the value of a parameter, V, is shown in a column on the left, and a fingerprint (FP) is shown in a column on the right.
TABLE 1 |
Case 1 |
V | FP | ||
A | 1 | ||
B | 1 | ||
C | 1 | ||
D | 1 | ||
TABLE 2 |
Case 2 |
V | FP | ||
A | 1 | ||
A | 3 | ||
A | 2 | ||
A | 4 | ||
TABLE 3 |
Case 3 |
V | FP | ||
A | 1 | ||
B | 1 | ||
A | 2 | ||
B | 2 | ||
TABLE 4 |
Case 4 |
V | FP | ||
A | 1 | ||
C | 3 | ||
B | 2 | ||
D | 4 | ||
In case 1, four different values of the parameter (A, B, C, D) map to a single fingerprint (1). Thus, unique values of the parameter do not correlate with unique fingerprints, and therefore the parameter value does not contribute any information for identifying the content file. In case 2, one value of the parameter (A) maps to four different fingerprints (1, 3, 2, 4). In this case, a singe parameter value correlates with multiple unique parameter values, and therefore the parameter value does not contribute any information for identifying the content file. In case 3, there are two values of the parameter (A, B) and there are two values of the fingerprint (1, 2). However, there is not a one-to-one correlation between the parameter values and the fingerprints, so the unique parameter values do not identify unique content files in this case. In case 4, four unique parameter values map to four different fingerprints, and therefore, in this case, the value of the parameter provides relevant information for the identification of a unique content file.
To perform an analysis of the information content of a URL parameter quantitatively, the ICCM 124 can compute an entropy of the fingerprint values conditional on the values of the parameters of the URLs and an entropy of the parameter values conditional on the fingerprint values. These entropies can also be known as the conditional entropies, H(fingerprints|values) (or H(F|V)) and H(values|fingerprints) (or H(V|F)), respectively. The first entropy, H(F|V), also can be known as the entropy of fingerprint values conditional on the parameter values, and the second entropy, H(V|F), can be known as the entropy of the parameter values conditional on the fingerprint values. Both entropies can be measured in units of bits.
The formula used to compute the conditional entropy is
where P(x) is the probably of an event, x, and P(x, y) is the joint probability of events x and y. These probabilities are computed by dividing a count of the parameter values or fingerprints in the list of URLs by the total number of URLs. For the purpose of this calculation, if the parameter is not present in a specific URL, a special “unused” value marker can be substituted.
When equation (9) is applied to the combinations of parameter values and fingerprints in Table 1 above, the entropy H(V|F) is
H(V|F)=−4·(0.25)·log2(0.25)+P(1)·log2 P(1)=2 bits, (10)
and the entropy H(F|V) is
H(F|V)=−4·(0.25)·log2(0.25)+4·(0.25)·log2(0.25)=0 bits. (11)
Similarly, for Case 2, H(V|F)=2 bits and H(F|V)=0 bits. For Case 3, H(V|F)=1 bits and H(F|V)=1 bit. For Case 4, H(V|F)=0 bits and H(F|V)=0 bits.
H(V|F)=−4·(0.25)·log2(0.25)+P(1)·log2 P(1)=2 bits, (10)
and the entropy H(F|V) is
H(F|V)=−4·(0.25)·log2(0.25)+4·(0.25)·log2(0.25)=0 bits. (11)
Similarly, for Case 2, H(V|F)=2 bits and H(F|V)=0 bits. For Case 3, H(V|F)=1 bits and H(F|V)=1 bit. For Case 4, H(V|F)=0 bits and H(F|V)=0 bits.
The value of H(F|V) represents the uncertainty that remains about which fingerprint is pointed to by a URL having a particular parameter, given that the value of the parameter is known. If H(F|V) is relatively high, the parameter does not provide much information about the fingerprint, and it is likely to be an irrelevant parameter. The value of H(V|F) represents the uncertainty that remains about the value of the parameter, given that the fingerprint is known. If the parameter value is essentially random and not related to the fingerprint, H(V|F) will be relatively high.
After the ICCM 124 has calculated H(F|V) and H(V|F), these entropy values can be passed to a relevancy calculation module (RCM) 126, which can determine whether a parameter is relevant or not, based, at least in part, on the values of H(F|V) and H(V|F). For example, the RCM 126 may deem a parameter relevant if and only if the values of both H(F|V) and H(V|F) are below respective thresholds chosen to produce an efficient tradeoff between ignoring a parameter that is actually relevant, which leads to content items that are not downloaded even though they should be, and keeping a parameter that is not relevant, which leads to retrieving the same content item more than once. Thus for example, if the thresholds for both H(V|F) and H(F|V) are each 0.5 bits, then based on the above entropy calculations for the Cases 1-4, the parameter, V, in Cases 1, 2, and 3 would be deemed irrelevant, while the parameter would be deemed relevant in Case 4.
The above calculations can be applied to a group of URLs that all refer to the same host and path, or to a group of URLs that all refer to the same host but to different paths, or to URLs that can refer to any host/path combination. In one implementation, when entropies are calculated for a cluster of URLs that refer to a particular host or host/path combination, if the host or host/path cluster contains fewer than a fixed number of URLs, no rules are generated for the cluster. Otherwise, for each query parameter in the URLs, the ICCM 124 and the RCM 126 can determine whether the parameter is relevant or not, using the entropy quantities described above. Then, a canonical URL generator (CUG) 127 can generate canonical URLs by applying rules to parameters of a URL based on whether the parameters in the URLs are relevant or not. For irrelevant parameters, the rule can be <ParameterName: IGNORE>. For relevant parameters, the rule can be <ParameterName: ACCEPT>.
When the ICCM 124 and the RCM 126 automatically determine rules by considering clusters of URLs for different hosts or host/path combinations, then the automatically generated rules for each host or host/path can be merged together and applied by the CUG 127 to all URLs that reference the particular host. The automatically generated rules can also be combined with a list of manually generated heuristic rules to generate the final list of rules for each host. Such manually generated rules may include a rule that orders individual URL parameters alphabetically, a case-sensitivity rule that converts all upper case letters to lower case letters, a rule that deems any parameter having a name equal to “vid,” “file,” or “path” to be relevant, and a rule that deems any parameter having a name equal to “sessionid” to be irrelevant. A database of such rules can be maintained in the system 100, e.g., in the RCM 126. When the entropy calculation is performed for parameters using all URLs for a given host, rather than for individual host/path clusters on a host, no host/path rule merging is required. In this implementation, the automatically generated rules can also be combined with the list of manually generated heuristic rules.
It is possible that rules for a parameter generated from clusters of URLs from some host/path combinations may conflict with rules for the parameter generated from other clusters of URLs from other host/path combinations. In such a situation, in one implementation, the RCM 126 may determine that the rule for the parameter can be host/path specific, such that it is different for different host/path combinations. In another implementation, the RCM 126 may determine the final rule for the parameter, which can apply for all host/path combinations, by calculating a ratio between the number of host/paths for which the parameter is relevant to the number of host/paths for which the parameter is irrelevant. If the ratio is above a threshold value, the RCM 126 may determine that the parameter is a relevant final rule, and if the ratio is below or equal to the threshold value then the RCM 126 may deep the parameter to be irrelevant. In another implementation, the RCM 126 may determine that a parameter is relevant for all paths on a host if the parameter is determined to be relevant on any of the paths for the host.
It is further possible that an automatically generated rule for a URL parameter may conflict with a manually generated heuristic rule for a particular host. In such a case, in one implementation, the manually generated heuristic rule may trump the automatically generated rule for that URL parameter on that host.
The final rules as determined by the ICCM 124 and the RCM 126 can be used by the CUG 127 in a canonicalization function to transform a URL into its equivalence class, for example, by accepting or rejecting certain parameters as relevant for purposes of identifying a unique content file. Canonical URLs can be stored in a data store 128, which, in one implementation, can be part of the compression, indexing, and ranking module 106. A canonicalization function can be applied to compare URLs that reference the same host and path, or URLs that reference only the same host, or URLs that reference any host and any path. If no automatically generated rules are generated for a corpus of URLs (e.g., URLs that reference a specific host) the canonicalization function may not drop any query parameters, but it may alter the URL according to the one or more heuristic rules. For example, as described above, URL parameters can be ordered alphabetically or made case-insensitive. In addition, URLs can be unescaped, to convert them to their unescaped equivalents. Thus, special URL encoded characters (e.g., “%20,” which represents a space between characters in an HTTP URL) can be converted into normal characters. According to another exemplary heuristic rule, query parameters can be deemed relevant or irrelevant based on a fixed list of relevant or irrelevant parameters.
Once rules based on the information content of URL parameters have been defined for use with a canonicalization function and canonical URLs have been determined, the web crawler 104 can use the canonical URLs as follows. As the web crawler 104 crawls through and extracts URLs from web pages, an extracted URL can be parsed, e.g., by a parser 130, to determine the components of the URL and then the URL is canonicalized according to a canonicalization function to produce a canonical URL. A comparison module 132 of the web crawler 104 can query the database 128 to determine whether a matching canonical URL exists in the database 128, and if a content item corresponding to the matching URL has been retrieved before. If the content item has been retrieved before, the download module 122 of the crawler need not download the content again, and the web crawler 104 can discard the URL from further consideration.
If a matching canonical URL is not found in the database 128, then the download module 122 downloads the content referenced by the original extracted URL (not the canonicalized URL) and stores the content in the data store 108. The ICCM 124, the RCM 126, and the CUG 127 can generate a canonical URL from the original extracted URL, and this canonical URL is stored in the database 128 and serves to index the downloaded content. An indexer 107 can index the content, such that the content can be easily retrieved based on the index information, such as, for example, the canonical URL, keywords, and other metadata. In addition, the fingerprint generator 116 can compute a fingerprint of the downloaded content to provide training data for the above-described information theoretical techniques used to generate canonical URLs.
To account for the dynamic nature of the web, in some implementations, the download module 122 can periodically download a small, random sample content items that are referenced by discarded URLs. These discarded URLs and the content they point to can provide further evidence to support or refute existing rules, or can provide training data for new rules.
In some cases, a query parameter of a URL can itself be a URL. The presence of certain, specific character sequences (e.g. “http” and “://” in the value of a query parameter can indicate that the query parameter is in fact itself a URL. For example, the URL, http://xyz.com/video?irrelevant=1&url=“http://abc.com/video?irrelevant2=2” includes a host name (“xyz.com”), a path name (“video”) and two parameters (“irrelevant” and “url”). The parameter named “url” has the value http://abc.com/video?irrelevant2=2. When canonicalizing a URL that includes as one of its parameters another URL, the value of this other URL also can be canonicalized. For example, the following URLs:
http://xyz.com/video?irrelevant=1&url=“http://abc.com/video?irrelevant2=2” (12)
http://xyz.com/video?irrelevant=2&url=“http://abc.com/video?irrelevant2=3” (13)
each might be transformed via a canonicalization function, C(URL) to the canonical URL
http://xyz.com/video?url=“http://abc.com/video” (14)
where the parameters “irrelevant” and “irrelevant2” are determined to be irrelevant. Thus, when certain character sequences (e.g., “http” or “://”) are detected in the value of a URL parameter (e.g., by theparser 130 in the web crawler or the parser in the analysis module 110), a rule can be triggered to canonicalize the value of the URL parameter itself.
http://xyz.com/video?irrelevant=1&url=“http://abc.com/video?irrelevant2=2” (12)
http://xyz.com/video?irrelevant=2&url=“http://abc.com/video?irrelevant2=3” (13)
each might be transformed via a canonicalization function, C(URL) to the canonical URL
http://xyz.com/video?url=“http://abc.com/video” (14)
where the parameters “irrelevant” and “irrelevant2” are determined to be irrelevant. Thus, when certain character sequences (e.g., “http” or “://”) are detected in the value of a URL parameter (e.g., by the
In another implementation, the relevance of a group of two or more parameters, considered together, can be determined by the ICCM 124 and the RCM 126. This is done because the group of parameters might be considered relevant by the RCM 126 even if the parameters would be deemed irrelevant when considered individually. For example, when analyzing the four following URLs that each reference a content item having a different fingerprint, e.g., fingerprints equal to “15”, “16”, “17”, and “18”, respectively,
http://xyz.com/video?path=cats/kittens&file=a.mpg, (15)
http://xyz.com/video?path=cats/kittens&file=b.mpg, (16)
http://xyz.com/video?path=cats/tigers&file=a.mpg, (17)
http://xyz.com/video?path=cats/tigers&file=b.mpg, (18)
theICCM 124 may consider the path and file parameters to be irrelevant, because H(V|F)=1 for both the path and file parameters, and this entropy value may be above some predetermined threshold. However, both the path and file parameters are required to uniquely determine which content item is referenced by the URL, and therefore the combination of the path and file parameters is relevant.
http://xyz.com/video?path=cats/kittens&file=a.mpg, (15)
http://xyz.com/video?path=cats/kittens&file=b.mpg, (16)
http://xyz.com/video?path=cats/tigers&file=a.mpg, (17)
http://xyz.com/video?path=cats/tigers&file=b.mpg, (18)
the
This relevancy information can be determined automatically as follows. After an initial analysis, as described above, of whether or not parameters on a host are individually relevant, the ICCM 124 and the RCM 126 can analyze tuples (e.g., pairs, triples etc.) of query parameters, where at least one of the parameters in the tuple has been marked as individually irrelevant. Then, the ICCM 1224 can determine H(V′|F) and H(F|V′) as described above, where V′ indicates a parameter tuple, and the RCM can use the results of the entropy calculations to determine if the tuple is a relevant parameter. If it is, all the individual parameters in the tuple are deemed relevant by the RCM 126, so that they will all be considered in a canonicalized version of a URL.
For example, when considering the relevance of the path/file tuple for the URLs (15), (16), (17), and (18), the ICCM 124 would determine that H(V′|F)=0 and H(F|V′)=0. The RCM 126 therefore would determine that the tuple is relevant, and both the path and file parameters would be deemed relevant for purposes of identifying a content file. A canonicalization function would retain both parameters as relevant.
Whether a URL parameter is case-sensitive, for purposes of identifying a content file, can be analyzed by the system 100. In a first example, if two different URLs using the parameter v=video.mpg and using the parameter v=VIDEO.mpg, respectively, each reference a content file having the same fingerprint, then the parameter likely is not case-sensitive. However, in a second example, if four URLs using the parameters, v=video.mpg, v=VIDEO.mpg, v=video2.mpg, and v=VIDEO2.mpg, reference content files having fingerprints, fp=1, fp=2, fp=3, and fp=4, respectively, then the parameter likely is case-sensitive. After determining the case-sensitivity of a parameter, a canonicalization function applied by the CUG 127 can discard case information for case-insensitive query parameters, but retain case information for case-sensitive parameters. The analysis module 110 can determine automatically whether or not a parameter is case-sensitive as follows.
The ICCM 124 can create a set of test URLs in which the case information of a parameter is removed by converting each value of the parameter into lower case for all the URLs in the set. The set of URLs with a value having its case information removed can be denoted as lower(V). Then, the ICCM 124 can determine the quantity, H(F|lower(V))−H(F|V), which measures the reduction in uncertainty (e.g., entropy) about the fingerprints of content files given the addition of case information to the values. If this quantity is greater than some predetermined threshold, the parameter can be deemed case-sensitive by the RCM 126, and case should be preserved during canonicalization. If the quantity is lower than the threshold, then the parameter is case insensitive and every value for the parameter should be converted to lower case according to a canonicalization function. By way of example, for the first set of URLs above, this quantity is 0 bits, because case information provides no information about the content file referenced by the parameter, v, since URLs having the parameters v=video.mpg and v=VIDEO.mpg both reference the same content file. For the second set of URLs, the value of this quantity is 1 bit, which, if the value of the threshold is less than 1, would indicate that the parameter is case-sensitive and that the case of the parameter values should be preserved according to a canonicalization function.
In another implementation, the ICCM 124 can determine the information content of a path for purposes of identifying a content file. For example, path components of a set of URLs can be considered as URL parameters, and the entropy values, H(V|F) and H(F|V), can be calculated to determine the information content of path components of the URLs. In general, this analysis is performed on a per-host basis, such that the information content of paths on a particular host are considered. The generated canonicalization rules then would specify on a per-host basis whether the path itself or any of its components should be stripped during canonicalization. For example, if the URLs http://site.com/path1?video=a.mpeg and http://site.com/path2?video=a.mpeg each reference the content file, then the path parameter may be irrelevant to the identification of the content file and can be stripped from the URL during canonicalization of the URL. Often, a path would be deemed to be irrelevant if considered individually, but a tuple of the path and one or more query parameters may be deemed to be relevant, so path parameters generally should be analyzed together with the regular query parameters as tuples, as described above.
Calculating a conditional entropy of a host portion of a set of URLs to determine whether the host is relevant to the identification of unique content files may not yield significant information. However, certain parts of a host name can be analyzed individually to determine whether they are relevant to the identification of a unique content file. For example, a portion of the host name that appears before the domain name can be analyzed (e.g., in the host name, video.google.com, the domain is “google.com” and the prefix is “video.”). Thus, for a cluster of URLs having the same domain name, the non-domain prefix part of the host can be treated as a separate query parameter to be processed by the ICCM 124 to determine its information content. Thus, for the URLs and corresponding fingerprints, http://www1.site.com/watch?video=1; fp=1 and http://www2.site.com/watch?video=1; fp=1, the prefix (www1 or www2) of the host name is not relevant to the identification of the content file.
In some implementations, after the ICCM 124 performs an initial analysis of the information content of a URL parameter and the RCM 126 makes an initial determination that a parameter is irrelevant to the identification of a content file, the accuracy of this initial determination can be tested or refined automatically by the system 100. In one implementation, the analysis module 110 can pass a known URL that references a known content item having a known fingerprint to the web crawler 104. The analysis module 110 can instruct the web crawler 104 to modify or remove a value of the URL parameter that is initially determined to be irrelevant and then to download the content item referenced by the modified URL. The comparison module 132 can compare the downloaded content item to the known content item (or can compare their fingerprints). An indication from the comparison module 132 that the two content items are identical then would confirm a hypothesis that the URL parameter is indeed irrelevant and would refute a hypothesis that the parameter is relevant. Conversely, if the comparison module 132 indicates that the two content items are not identical, then this would confirm a hypothesis that the URL parameter actually is relevant.
In some implementations, to further reduce the amount of duplicative content that is downloaded by the web crawler 104, instead of downloading an entire content file from which a fingerprint can be generated for use in entropy calculations performed by the ICCM 124, a smaller size fingerprint of the content file can be downloaded by the download module 122. For example, if two HTTP content files are identical, it is likely that value of the “Content-Length” header field of the two files also is identical. Thus, the download module 122 may issue an HTTP HEAD request to download some or all header information of content files referenced by URLs rather than issuing an HTTP GET request to download the entire content, and the information downloaded in response to the HEAD request can be used as a fingerprint of the content files in the entropy calculations performed by the ICCM 124.
The ultimate determination of whether or not a URL parameter is relevant to the identification of content files can be based on multiple sources of information, including the conditional entropy calculations, H(V|F) and H(F|V), performed by the ICCM 124, manual heuristic rules, and the appearance of the parameter name on a predetermined list of relevant or irrelevant parameters. These multiple sources of information can be combined using Bayes's theorem to determine an ultimate probability that a parameter is relevant or irrelevant. For example, the RCM 126 may determine that a relevance determination based on the conditional entropy calculations is accurate 90% of the time, that a relevance determination based on manual heuristic rules is accurate 95% of the time, and that a relevance determination based on a fixed list of relevant and irrelevant parameters is accurate 80% of the time. Then, the RCM 126 may compute a probability that a parameter is relevant based on the combination of the information derived from these different analyses.
Therefore, to reduce the overall bandwidth cost of testing a hypothesis that a URL parameter is irrelevant by retrieving the content item referenced by a modified URL or a fingerprint of the content item, an initial determination of the probability that the parameter is relevant can be determined by the RCM 126. Then, only parameters whose probabilities lie within some predetermined range of uncertainty (e.g. 10%<p<90%) would be tested by the HTTP HEAD or HTTP GET request for content referenced by a modified URL.
As discussed above, portions of a host name can be analyzed to determine whether they provide information relevant to the identification of a particular content file. For example, in the host name, “video.google.com,” the domain is “google.com” and the prefix is “video,” and the prefix may provide information relevant to the identification of a particular content file. It is also possible to identify automatically the prefix portions of URLs, as well as other character strings.
The system 200 can receive, as input, a number of different character strings. Based on this input, the system 200 can determine whether certain initial substrings in the strings are significant prefixes or whether they are just randomly occurring character sequences. The system 200 also can determine whether certain terminal substrings in the strings are significant suffixes or whether they are just randomly occurring substrings of characters. To do this, an analysis module 202 can analyze individual strings in a collection of strings to determine whether a unique substring of characters at the beginning and/or end of the strings occurs with a frequency that is statistically significant enough to determine that the unique substring must be a deliberate sequence of characters that is a prefix or suffix and not a randomly occurring sequence of characters.
In one implementation, an analysis module 202 can receive a plurality of character strings for analysis via an input module 204. The input module 204 can receive the plurality of character strings from a variety of different places. For example, the input module 204 can receive the character strings from a data store 206, where the data store can be a local data store or a remote data store. In one implementation the data store could be a data store 108 that stores URLs identified and stored by a web crawler 104. In another implementation, the input module 202 can receive the character strings via a connection to a network 208 (e.g., to a Wide Area Network or to a Local Area Network) from another device that is also connected to network.
The input module 204 can pass the character strings to a string parser 210 that can parse the strings into substrings that can be analyzed to determine whether the substrings are significant affixes (i.e., prefixes or suffixes) in the plurality of strings. The substrings can be a single character long or can be as long as the character string from which the substring is derived.
A counter 212 in the analysis module 202 can count a number of different quantities. For example, the counter 212 can count the number of strings in the plurality of strings having at least one character, having at least two characters, having at least three characters, etc., up to the number of strings having the greatest number of characters of any string in the plurality of strings. The counter 212 also can count the number of strings having a unique substring of characters at the beginning of the string. For example, among the strings, “aad,” “ad,” “art,” “aab,” “aa,” “aardvark,” “aat,” “bad,” “base,” the counter 212 may count four strings that include the substring “aa” at the beginning of the string. Among the strings, “Prefix1_asdf,” “Prefix1_blijef,” “Prefix1_belwf,” “Repeat,” “Repeat,” “Pre_agsdg,” and “Pre_giejw,” the counter 212 may count three strings that include the substring “Prefix_” and two strings that include the substring “Pre_” at the beginning of the string.
A probability calculator 214 in the analysis module 202 can be used to determine a probability with which a particular character substring would occur at the beginning or end of a string, based on information about the character set from which the strings are drawn and a probability distribution over characters in the character set from which the strings are drawn.
In one implementation, the probability calculator 214 may use as input a particular predetermined character set from which the strings are drawn. For example, the character set can include letters of one or more known languages, numerical digits, printable American Standard Code for Information Interchange (“ASCII”) characters, certain “Unicode”) characters (which might be encoded in the Unicode Transformation Format “UTF-8” for example), and/or characters that are allowable in URLs (e.g., alphanumerical characters, reserved characters (i.e., “;”, “/”, “?”, “:”, “@”, “=”, “&” “%”) and special characters (i.e., “$”, “,” “, “.”, “+”, “!”, “*”, “'”, “(”, “)”)). In another implementation, the probability calculator 214 may use as input an empirically determined character set from which the strings are drawn. For example, a character code from which the strings are drawn can be determined by the string parser 210, which may parse the plurality of character strings to determine a character code of all the characters used in the character strings.
In one implementation, the probability distribution over characters can be a uniform distribution. That is, for a character set having s characters, the probability of finding a specific character at a given position in a string may be assumed to be 1/s. In another implementation, the probability distribution over characters can be a non-uniform distribution, where the actual distribution is determined according to a priori assumptions or according to empirically determined information. For example, in one non-uniform probability distribution of characters, a probability of a particular character occurring in the character strings may be set equal to a generally accepted probability of the character occurring in a particular language (e.g., English). In another example of a non-uniform probability distribution of characters, the probability of a particular character occurring in the character strings may be set proportional to the frequency of the character in a corpus of content (e.g., text from randomly sampled web pages, URLs randomly sampled from the Internet, examples of a particular genre of literature, records randomly sampled from a particular database). In another example of a non-uniform probability distribution of characters, the probability of a particular character occurring in the character strings may be determined empirically by determining the frequency with which each character used in the character strings occurs in the corpus of character strings under consideration and then using this frequency, appropriately normalized, as the probability with which the character will occur in the character strings.
Once a probability distribution over characters of the character set has been determined, the probability of a particular sequence of characters occurring as a prefix in a string can be determined. For example, if the characters are drawn from a uniform distribution over a number of characters, s, then the probably of a particular substring of X characters occurring as a prefix in a string is p=(1/s)X. Therefore, the probability that there are exactly M occurrences of that sequence in a list of N strings of random sequences of characters (assuming that the sequences are independent) is given by the binomial distribution:
P(M,N,substring)=Binom(M,N,(1/s)X) (19)
P(M,N,substring)=Binom(M,N,(1/s)X) (19)
For a non-uniform distribution of symbol probabilities, the probability that there are exactly M occurrences of the substrings sequence of characters in a list of N strings of random sequences of characters (assuming that the sequences are independent) is given by:
P(M,N,substring)=Binom(M,N,Product(P(substring[i]),i=1 . . . X))) (21)
where X is the length of the substring, and where psubstring[i] is the probability of the appearance of any individual character, i, at a particular location in the character string. Thus, equations (19) and (20) are special cases of their general counterparts, equations (21) and (22), respectively. In the special cases of equations (19) and (20) p_substring[i]=(1/s).
These equations can be used to determine whether, out of a total of N strings, M strings having particular substring prefix is a statistically significant event. However, because it is known that a particular character sequence of a substring under investigation must occur at least once, a general constraint is M>=1. Thus, the probability calculator 214 can determine a test statistic, T, that measures the probability that the specific character sequence of the substring under investigation appears M or more times out of N strings, given that it appears at least once; i.e.,
where the numerator of eq. (23) gives the probability that the character sequence of the prefix occurs M or more times, while the denominator gives the probability that the prefix occurs at least once.
The result of the test statistic calculations can be passed to a comparison module 216 that can compare the value of the test statistic to a desired significance level. Based on this comparison, the comparison module 216 can determine whether the character sequence is a significant prefix or whether the character sequence is only a random or otherwise insignificant occurrence. For example, the comparison module 216 may determine that the character sequence under investigation is a significant prefix if the test statistic is lower than a significance level. The significance level can be representative of, for example, a one, two, three, or four sigma event.
To determine all significant prefixes in a plurality of character strings, the above techniques can be iterated, for example, according to the following pseudocode, where L is the length, in characters, of the longest string, and s is the number of characters in the character code:
For X=1 to L
-
- Sublist=every string S in the Plurality of Character Strings with length(S)>=X
- Substrings=first X characters of each string in Sublist
- For each unique string S in Substrings
- M=count of S in Substrings
- N=number of strings in Substrings
- T=TestStatistic(M, N, S
- If T<SignificanceLevel
- S is a significant prefix
- End
- End
End
According to this pseudocode, significant prefixes having a length of 1 character up to a length L are sought, where L is the length of the longest string. In practice, the loop may begin by searching for significant prefixes with a minimum length greater than 1 character (e.g., if the strings are all URLs beginning with “www”) and may end with a maximum length that is less than the length of the longest string (e.g., so that very long prefixes are not sought and/or because prefixes having a length equal to the length of the longest string can be disallowed, as explained below). A sublist of strings having a length greater than or equal to i is considered, and within the sublist, substrings having X characters at the beginning of the string are considered. For each unique substring, S, in the list of substrings, the number of strings, M, having the same sequence of X characters at the beginning of the string is counted. Also, the total number, Nx, of strings having at least X characters is counted, and a test statistic, T, is determined. If the value of the test statistic is below a predetermined value, then this indicates that the event of seeing at least this many repetitions of the same substring just by chance is sufficiently unlikely, and the substring, S, is deemed a significant prefix.
Thus, when the techniques of this pseudocode are applied to the plurality of strings, “Prefix1_asdf,” “Prefix1_blijef,” “Prefix1_belwf,” “Repeat,” “Repeat,” “Pre_agsdg,” and “Pre_giejw,” the comparison module 216 may determine that the following group of character strings are significant prefixes: “P,” “Pr,” Pre,” “Pref,” Prefi,” “Prefix,” “Prefix,” “Prefix1_,” Pre_,” “R,” “Re,” “Rep,” “Repe,” “Repea,” “Repeat.”
After a group of character strings has been flagged as significant prefixes within a plurality of character strings, the comparison module 216 can additionally filter the group by eliminating from the group any character string that is a subprefix of another longer prefix. In the above example, this rule would eliminate the character strings “P,” “Pr,” Pre,” “Pref,” Prefi,” “Prefix,” “Prefix,” “R,” “Re,” “Rep,” “Repe,” and “Repea” from the group. A group of character strings flagged as significant prefixes also can be filtered by eliminating from the group any character string that is not followed by another character in the plurality of character strings. Application of this rule to the above group of strings would result in the string “Repeat” being removed from the group. Thus, application of both of these filtering rules after applying the techniques exemplified by the pseudocode above would result in the prefixes “Pre_” and “Prefix1” being determined as significant prefixes automatically from the plurality of potential prefixes listed above.
Significant prefixes that have been determined automatically can be stored, e.g., on the data store 206 or on a local data store 218. The data store 206 or 208 can be a random access memory (RAM), a hard disk, an optical disk, a flash memory, a paper copy or any kind of temporary or permanent storage medium.
The above techniques also can be used to determine whether character strings at the ends of strings are significant suffixes, by reversing the order of characters in a string before applying the techniques described above. Thus, prefixes and suffixes of a string can both be known as affixes at extremities of strings, which can be determined automatically using the techniques described above.
An information content of a first parameter of the URLs is determined, where the information content provides a measure of the relevance of the parameter to the identification of a unique content file (304). Then, it is determined, based, at least in part, on the information content of the parameter, that the first parameter is irrelevant to the identification of a unique content file by the URLs (306). For example, in one implementation, the information content of the first parameter can be determined by an ICCM 124 that calculates an entropy of values of the fingerprints conditional on values of the first parameter for the URLs and that calculates an entropy of values of the first parameter conditional on values of the fingerprints.
In another implementation, an information content of a second parameter of the URLs can be determined (308). Then, it can be determined, based, at least in part, on the information content of the second parameter, that the second parameter is relevant to the identification of a unique content file by the URLs (310). For example, the information content of the second parameter also can be determined by the ICCM 124, which can calculate an entropy of values of the fingerprints conditional on values of the second parameter and which can calculate an entropy of values of the first parameter conditional on values of the fingerprints.
Another URL can be received in addition to the plurality of URLs (312), and the other URL can be identified as equivalent to one of the plurality of URLs for purposes of identifying a particular content file (314), based at least on the other URL and the equivalent URL having an identical value for the second parameter, even though the other URL and the equivalent URL have different values for the first parameter. For example, after a number of canonical URLs have been generated and stored in the database 128, the web crawler 104 may locate a URL as a result of a crawling process, which may be canonicalized and compared to the canonical URLs in the database 128. If the other URL and one of the canonical URLs have identical values for relevant parameters in the URLs they may be identified as equivalent for purposes of identifying a content file, even though the other URL and the equivalent URL have different values for the first parameter.
In another example, if a user requests a content file referenced by the other URL from a server, the server can compare the other URL to canonical URLs stored in a database. Then, if the other URL and one of the canonical URLs have identical values for relevant parameters in the URLs they may be identified as equivalent for purposes of identifying a content file, even though the other URL and the equivalent URL have different values for the first parameter. If such a match is found between the canonicalized form of the other URL and one of the canonical URLs, then the server may serve the requested content from cached content that is identified by the canonical URL. Thus, a copy of a particular content file can be cached (316), and a copy of the cached particular content file can be served (318) in response to a request for a content file identified by the other URL, and a copy of the cached particular content file also can be served in response to a request for a content file identified by the equivalent URL (320).
In one implementation, canonical URLs for identifying content files on the host can be determined based on which of the first and second parameters are included in the received URLs (410) and these canonical URLs can be stored (412) (e.g., in the database 128). For example, the CUG 127 can canonicalize one of the received URLs by applying a canonicalization function to the URL. The canonicalization function can act to retain relevant parameters and discard irrelevant parameters in the received URL. Another URL in addition to the plurality of URLs can be received (416). The other URL can be canonicalized and compared to the stored canonical URLs (418), and, if the comparison yields a match between the other URL and a stored canonical URL (420), then a content file identified by the other URL can be downloaded and stored (422). Otherwise, a content file identified by the other URL can be equated with an already-stored content file identified by the canonical URL that matches the other URL (424).
Then, a URL is received, where the URL includes a first parameter that has been determined to be irrelevant to the identification of a unique content file on the host (510). A first fingerprint of a content file identified by the received URL is received (512). A test URL identical to the received URL but for the omission of the first parameter from the test URL is generated (514). A second fingerprint of a content file identified by the test URL is received (516), and the first and second fingerprints are compared (518). The determination that the first parameter is irrelevant to the identification of a unique content file on the host can be refined based at least in part on the comparison (520).
Implementations of the various techniques described herein may be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. Implementations may implemented as a computer program product, i.e., a computer program tangibly-embodied in a machine-readable storage device (e.g., a random access memory, a read only memory, a hard disk, an optical disk, or combinations thereof), for execution by, or to control the operation of, data processing apparatus, e.g., a programmable processor, a computer, or multiple computers. A computer program, such as the computer program(s) described above, can be written in any form of programming language, including compiled or interpreted languages, and can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.
Method steps may be performed by one or more programmable processors executing a computer program to perform functions by operating on input data and generating output. Method steps also may be performed by, and an apparatus may be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. Elements of a computer may include at least one processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer also may include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory may be supplemented by, or incorporated in special purpose logic circuitry.
To provide for interaction with a user, implementations may be implemented on a computer having a display device, e.g., a cathode ray tube (CRT) or liquid crystal display (LCD) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
Implementations may be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation, or any combination of such back-end, middleware, or front-end components. Components may be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (LAN) and a wide area network (WAN), e.g., the Internet.
While certain features of the described implementations have been illustrated as described herein, many modifications, substitutions, changes and equivalents will now occur to those skilled in the art. It is, therefore, to be understood that the appended claims are intended to cover all such modifications and changes as fall within the true spirit of the embodiments.
Claims (35)
1. A computer-implemented method comprising:
receiving a plurality of character strings;
determining, by at least one processor of a computer system, the number of strings (M) in the plurality of strings having a unique substring of X characters at an extremity of the string;
determining, by at least one of the processors of the computer system, the number of strings (N) in the plurality of strings having at least X characters in the string, where N>M;
determining, by at least one of the processors of the computer system, a probability, P, that the unique substring of X characters would occur M or more times out of the N strings, given that the unique character string occurs at least once, wherein the probability, P, is based on a probability that the unique substring of X characters occurs exactly M times,
divided by a probability that the unique substring of X characters occurs at least once,
where
and where Psubstring[i] represents the probability of the appearance of any individual character, i, at a particular location in the character string;
determining, by at least one of the processors of the computer system, based on the probability, the number M, and the number N, that the unique character string is a significant affix in the plurality of character strings; and
storing the unique character string.
2. The method of claim 1 , wherein the extremity of the string is the beginning of the string and wherein the affix is a prefix of the string.
3. The method of claim 1 , wherein the extremity of the string is the end of the string and wherein the affix is a suffix of the string.
4. The method of claim 1 , wherein the character strings are composed from a number (S) of individual characters, and wherein psubstring[i] is equal to 1/S.
5. The method of claim 4 , wherein the characters include ASCII printable characters.
6. The method of claim 4 , wherein the characters include letters of an alphabet and numerical digits.
7. The method of claim 1 , wherein the plurality of character strings includes a plurality of uniform resource locators.
8. The method of claim 1 , wherein the character strings are composed from a number (S) of individual characters, and wherein psubstring[i] is equal to a probability of the particular character appearing anywhere in a corpus of character strings representative of a population from which the plurality of character strings is drawn.
9. The method of claim 8 , wherein the corpus comprises the plurality of character strings.
10. The method of claim 8 , wherein the plurality of character strings includes uniform resource locators and wherein the corpus comprises a sample of uniform resource locators drawn from the Internet.
11. The method of claim 8 , wherein the symbols include ASCII printable characters.
12. The method of claim 8 , wherein the symbols include letters of an alphabet and numerical digits.
13. The method of claim 1 , wherein the characters in the unique substring of X characters are members of a character set of all the characters used in the character strings.
14. A computer-implemented method comprising:
receiving a plurality of character strings;
for unique character substrings of X characters at an extremity of strings in the plurality of strings, determining, by at least one processor of a computer system, the number of strings (M) in the plurality of strings having the unique substring, where X runs from a predetermined minimum length to a predetermined maximum length;
determining, by at least one of the processors of the computer system, for the different values of X, the numbers of strings (NX) in the plurality of strings having at least X characters in the string;
for the unique character strings of X characters, determining, by at least one of the processors of the computer system, a probability, P, that the unique character substrings would occur M or more times out of the NX strings, given that the unique character string occurs at least once, wherein the probability, P, is based on a probability that the unique substring of X characters occurs exactly M times,
divided by a probability that the unique substring of X characters occurs at least once,
where
and where Psubstring[i] represents the probability of the appearance of any individual character, i, at a particular location in the character string;
determining, by at least one of the processors of the computer system, based on the probability, the number M, and the number NX, whether the unique character strings of X characters are significant affixes in the plurality of character strings; and
for unique character strings that are significant affixes, storing at least one of the unique character strings.
15. The method of claim 14 , further comprising:
generating, by at least one of the processors of the computer system, a list of unique character strings that are significant affixes in the plurality of character strings, wherein the list excludes unique character strings that are substrings of other character strings that are significant affixes.
16. The method of claim 14 , further comprising:
generating, by at least one of the processors of the computer system, a list of unique character strings that are significant affixes in the plurality of character strings, wherein the list excludes unique character strings that are not followed by another character.
17. The method of claim 14 , wherein the extremity of the string is the beginning of the string and wherein the affix is a prefix of the string.
18. The method of claim 14 , wherein the character strings are composed from a number (S) of individual characters, and wherein psubstring[i] is equal to 1/S.
19. The method of claim 14 , wherein the plurality of character strings includes a plurality of uniform resource locators.
20. The method of claim 14 , wherein the character strings are composed from a number (S) of individual characters, and wherein psubstring[i] is equal to a probability of the particular character appearing anywhere in a corpus of character strings representative of a population from which the plurality of character strings is drawn.
21. The method of claim 20 , wherein the corpus includes the plurality of character strings.
22. The method of claim 20 , wherein the plurality of character strings includes uniform resource locators and wherein the corpus includes a sample of uniform resource locators drawn from the Internet.
23. The method of claim 20 , wherein the individual characters include letters of an alphabet and numerical digits.
24. The method of claim 14 , wherein the characters in the unique substring of X characters are members of a character set of all the characters used in the character strings.
25. A computer program product tangibly embodied on a non-transitory computer-readable storage medium and including executable instructions that, when executed, are configured to cause at least one processor of a data processing apparatus to:
receive a plurality of character strings;
for unique character substrings of X characters at an extremity of strings in the plurality of strings, determine the number of strings (M) in the plurality of strings having the unique substring, where X runs from a predetermined minimum length to a predetermined maximum length;
determine, for the different values of X, the numbers of strings (NX) in the plurality of strings having at least X characters in the string;
for the unique character strings of X characters, determine a probability, P, that the unique character substrings would occur M or more times out of the NX strings, given that the unique character string occurs at least once, wherein the probability, P, is based on a probability that the unique substring of X characters occurs exactly M times,
divided by a probability that the unique substring of X characters occurs at least once,
where
and where psubstring [i] represents the probability of the appearance of any individual character, i, at a particular location in the character string;
determine, based on the probability, the number M, and the number NX, whether the unique character strings of X characters are significant affixes in the plurality of character strings; and
for unique character strings that are significant affixes, store at least one of the unique character strings.
26. The computer program product of claim 25 , further comprising executable instructions that, when executed, are configured to cause at least one of the processors of the data processing apparatus to:
generate a list of unique character strings that are significant affixes in the plurality of character strings, wherein the list excludes unique character strings that are substrings of other character strings that are significant affixes.
27. The computer program product of claim 25 , further comprising executable instructions that, when executed, are configured to cause at least one of the processors of the data processing apparatus to:
generate a list of unique character strings that are significant affixes in the plurality of character strings, wherein the list excludes unique character strings that are not followed by another character.
28. The computer program product of claim 25 , wherein the extremity of the string is the beginning of the string and wherein the affix is a prefix of the string.
29. The computer program product of claim 25 , wherein the character strings are composed from a number (S) of individual characters, and wherein psubstring [i] is equal to 1/S.
30. The computer program product of claim 25 , wherein the plurality of character strings includes a plurality of uniform resource locators.
31. The computer program product of claim 25 , wherein the character strings are composed from a number (S) of individual characters, and wherein psubstring[i] is equal to a probability of the particular character appearing anywhere in a corpus of character strings representative of a population from which the plurality of character strings is drawn.
32. The computer program product of claim 31 , wherein the corpus includes the plurality of character strings.
33. The computer program product of claim 31 , wherein the plurality of character strings includes uniform resource locators and wherein the corpus includes a sample of uniform resource locators drawn from the Internet.
34. The computer program product of claim 31 , wherein the individual characters include letters of an alphabet and numerical digits.
35. The computer program product of claim 25 , wherein the characters in the unique substring of X characters are members of a character set of all the characters used in the character strings.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US12/177,102 US8095530B1 (en) | 2008-07-21 | 2008-07-21 | Detecting common prefixes and suffixes in a list of strings |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US12/177,102 US8095530B1 (en) | 2008-07-21 | 2008-07-21 | Detecting common prefixes and suffixes in a list of strings |
Publications (1)
Publication Number | Publication Date |
---|---|
US8095530B1 true US8095530B1 (en) | 2012-01-10 |
Family
ID=45419211
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US12/177,102 Expired - Fee Related US8095530B1 (en) | 2008-07-21 | 2008-07-21 | Detecting common prefixes and suffixes in a list of strings |
Country Status (1)
Country | Link |
---|---|
US (1) | US8095530B1 (en) |
Cited By (18)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20110078558A1 (en) * | 2009-09-30 | 2011-03-31 | International Business Machines Corporation | Method and system for identifying advertisement in web page |
US8407186B1 (en) * | 2009-03-31 | 2013-03-26 | Symantec Corporation | Systems and methods for data-selection-specific data deduplication |
US20130318082A1 (en) * | 2012-05-24 | 2013-11-28 | Fujitsu Limited | Generation apparatus, generation method, searching apparatus, and searching method |
US20150347599A1 (en) * | 2014-05-28 | 2015-12-03 | Arcadia Solutions, LLC | Systems and methods for electronic health records |
US20160205109A1 (en) * | 2015-01-13 | 2016-07-14 | Microsoft Technology Licensing, Llc | Website access control |
US20160308998A1 (en) * | 2015-04-20 | 2016-10-20 | Gild, Inc. | Capturing candidate profiles |
US20170011120A1 (en) * | 2015-07-06 | 2017-01-12 | International Business Machines Corporation | Multiple sub-string searching |
US20170272464A1 (en) * | 2016-03-15 | 2017-09-21 | Vade Retro Technology Inc. | METHODS, SYSTEMS AND DEVICES TO MITIGATE THE EFFECTS OF SIDE EFFECT URLs IN LEGITIMATE AND PHISHING ELECTRONIC MESSAGES |
US20190026259A1 (en) * | 2016-01-19 | 2019-01-24 | International Business Machines Corporation | List manipulation in natural language processing |
US10824811B2 (en) * | 2018-08-01 | 2020-11-03 | Sap Se | Machine learning data extraction algorithms |
US10832819B2 (en) | 2014-05-28 | 2020-11-10 | Arcadia Solutions, LLC | Systems and methods for electronic health records |
US10878269B2 (en) | 2018-06-19 | 2020-12-29 | Sap Se | Data extraction using neural networks |
WO2022003410A1 (en) * | 2020-06-30 | 2022-01-06 | Td Ameritrade Ip Company, Inc. | String processing of clickstream data |
US11238357B2 (en) * | 2017-07-21 | 2022-02-01 | Google Llc | Generating computationally-efficient representations of large datasets |
US11249965B2 (en) * | 2018-05-24 | 2022-02-15 | Paypal, Inc. | Efficient random string processing |
US11361046B2 (en) * | 2016-10-17 | 2022-06-14 | Google Llc | Machine learning classification of an application link as broken or working |
US11562590B2 (en) | 2020-05-21 | 2023-01-24 | Sap Se | Real-time data item prediction |
US20230379399A1 (en) * | 2022-05-20 | 2023-11-23 | Samsung Electronics Co., Ltd. | Application server assisted content management in cellular network |
Citations (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6411952B1 (en) * | 1998-06-24 | 2002-06-25 | Compaq Information Technologies Group, Lp | Method for learning character patterns to interactively control the scope of a web crawler |
US6547829B1 (en) * | 1999-06-30 | 2003-04-15 | Microsoft Corporation | Method and system for detecting duplicate documents in web crawls |
US20060218143A1 (en) * | 2005-03-25 | 2006-09-28 | Microsoft Corporation | Systems and methods for inferring uniform resource locator (URL) normalization rules |
US20080010291A1 (en) * | 2006-07-05 | 2008-01-10 | Krishna Leela Poola | Techniques for clustering structurally similar web pages |
US20080162448A1 (en) * | 2006-12-28 | 2008-07-03 | International Business Machines Corporation | Method for tracking syntactic properties of a url |
US7552109B2 (en) * | 2003-10-15 | 2009-06-23 | International Business Machines Corporation | System, method, and service for collaborative focused crawling of documents on a network |
US7627613B1 (en) * | 2003-07-03 | 2009-12-01 | Google Inc. | Duplicate document detection in a web crawler system |
-
2008
- 2008-07-21 US US12/177,102 patent/US8095530B1/en not_active Expired - Fee Related
Patent Citations (7)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6411952B1 (en) * | 1998-06-24 | 2002-06-25 | Compaq Information Technologies Group, Lp | Method for learning character patterns to interactively control the scope of a web crawler |
US6547829B1 (en) * | 1999-06-30 | 2003-04-15 | Microsoft Corporation | Method and system for detecting duplicate documents in web crawls |
US7627613B1 (en) * | 2003-07-03 | 2009-12-01 | Google Inc. | Duplicate document detection in a web crawler system |
US7552109B2 (en) * | 2003-10-15 | 2009-06-23 | International Business Machines Corporation | System, method, and service for collaborative focused crawling of documents on a network |
US20060218143A1 (en) * | 2005-03-25 | 2006-09-28 | Microsoft Corporation | Systems and methods for inferring uniform resource locator (URL) normalization rules |
US20080010291A1 (en) * | 2006-07-05 | 2008-01-10 | Krishna Leela Poola | Techniques for clustering structurally similar web pages |
US20080162448A1 (en) * | 2006-12-28 | 2008-07-03 | International Business Machines Corporation | Method for tracking syntactic properties of a url |
Cited By (29)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8407186B1 (en) * | 2009-03-31 | 2013-03-26 | Symantec Corporation | Systems and methods for data-selection-specific data deduplication |
US8869025B2 (en) * | 2009-09-30 | 2014-10-21 | International Business Machines Corporation | Method and system for identifying advertisement in web page |
US20110078558A1 (en) * | 2009-09-30 | 2011-03-31 | International Business Machines Corporation | Method and system for identifying advertisement in web page |
US20130318082A1 (en) * | 2012-05-24 | 2013-11-28 | Fujitsu Limited | Generation apparatus, generation method, searching apparatus, and searching method |
US20150347599A1 (en) * | 2014-05-28 | 2015-12-03 | Arcadia Solutions, LLC | Systems and methods for electronic health records |
US10832819B2 (en) | 2014-05-28 | 2020-11-10 | Arcadia Solutions, LLC | Systems and methods for electronic health records |
US10154041B2 (en) * | 2015-01-13 | 2018-12-11 | Microsoft Technology Licensing, Llc | Website access control |
US20160205109A1 (en) * | 2015-01-13 | 2016-07-14 | Microsoft Technology Licensing, Llc | Website access control |
CN107408115B (en) * | 2015-01-13 | 2020-10-09 | 微软技术许可有限责任公司 | Web site filter, method and medium for controlling access to content |
CN107408115A (en) * | 2015-01-13 | 2017-11-28 | 微软技术许可有限责任公司 | web site access control |
US20160308998A1 (en) * | 2015-04-20 | 2016-10-20 | Gild, Inc. | Capturing candidate profiles |
US10558690B2 (en) | 2015-07-06 | 2020-02-11 | International Business Machines Corporation | Multiple sub-string searching |
US10546002B2 (en) * | 2015-07-06 | 2020-01-28 | International Business Machines Corporation | Multiple sub-string searching |
US20170011120A1 (en) * | 2015-07-06 | 2017-01-12 | International Business Machines Corporation | Multiple sub-string searching |
US10956662B2 (en) * | 2016-01-19 | 2021-03-23 | International Business Machines Corporation | List manipulation in natural language processing |
US20190026259A1 (en) * | 2016-01-19 | 2019-01-24 | International Business Machines Corporation | List manipulation in natural language processing |
US10142366B2 (en) * | 2016-03-15 | 2018-11-27 | Vade Secure, Inc. | Methods, systems and devices to mitigate the effects of side effect URLs in legitimate and phishing electronic messages |
US20170272464A1 (en) * | 2016-03-15 | 2017-09-21 | Vade Retro Technology Inc. | METHODS, SYSTEMS AND DEVICES TO MITIGATE THE EFFECTS OF SIDE EFFECT URLs IN LEGITIMATE AND PHISHING ELECTRONIC MESSAGES |
US11361046B2 (en) * | 2016-10-17 | 2022-06-14 | Google Llc | Machine learning classification of an application link as broken or working |
US11238357B2 (en) * | 2017-07-21 | 2022-02-01 | Google Llc | Generating computationally-efficient representations of large datasets |
US11249965B2 (en) * | 2018-05-24 | 2022-02-15 | Paypal, Inc. | Efficient random string processing |
US10878269B2 (en) | 2018-06-19 | 2020-12-29 | Sap Se | Data extraction using neural networks |
US10824811B2 (en) * | 2018-08-01 | 2020-11-03 | Sap Se | Machine learning data extraction algorithms |
US11562590B2 (en) | 2020-05-21 | 2023-01-24 | Sap Se | Real-time data item prediction |
WO2022003410A1 (en) * | 2020-06-30 | 2022-01-06 | Td Ameritrade Ip Company, Inc. | String processing of clickstream data |
US11438428B2 (en) | 2020-06-30 | 2022-09-06 | Td Ameritrade Ip Company, Inc. | String processing of clickstream data |
US11917028B2 (en) | 2020-06-30 | 2024-02-27 | Charles Schwab & Co., Inc. | String processing of clickstream data |
US20230379399A1 (en) * | 2022-05-20 | 2023-11-23 | Samsung Electronics Co., Ltd. | Application server assisted content management in cellular network |
US11895213B2 (en) * | 2022-05-20 | 2024-02-06 | Samsung Electronics Co., Ltd. | Application server assisted content management in cellular network |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US8095530B1 (en) | Detecting common prefixes and suffixes in a list of strings | |
US9081861B2 (en) | Uniform resource locator canonicalization | |
US10650087B2 (en) | Systems and methods for content extraction from a mark-up language text accessible at an internet domain | |
US9760570B2 (en) | Finding and disambiguating references to entities on web pages | |
US7809710B2 (en) | System and method for extracting content for submission to a search engine | |
US20090089278A1 (en) | Techniques for keyword extraction from urls using statistical analysis | |
US20070143317A1 (en) | Mechanism for managing facts in a fact repository | |
US20070239704A1 (en) | Aggregating citation information from disparate documents | |
US20060161543A1 (en) | Systems and methods for providing search results based on linguistic analysis | |
US7310633B1 (en) | Methods and systems for generating textual information | |
US8793120B1 (en) | Behavior-driven multilingual stemming | |
US8180751B2 (en) | Using an encyclopedia to build user profiles | |
US8200670B1 (en) | Efficient document clustering | |
US8423885B1 (en) | Updating search engine document index based on calculated age of changed portions in a document | |
US20150206101A1 (en) | System for determining infringement of copyright based on the text reference point and method thereof | |
US20050010556A1 (en) | Method and apparatus for information retrieval | |
US8954438B1 (en) | Structured metadata extraction | |
Nie et al. | Extracting objects from the web | |
US10380195B1 (en) | Grouping documents by content similarity | |
WO2022198756A1 (en) | Information pushing method and apparatus based on hot event, computer device, and storage medium | |
CN114117242A (en) | Data query method and device, computer equipment and storage medium | |
JP2006164086A (en) | Online knowledge search support system and online knowledge search support method | |
JP2003173351A (en) | Method, device, program and storage medium for analysis, collection and retrieval of information | |
US11726972B2 (en) | Directed data indexing based on conceptual relevance | |
EP2662785A2 (en) | A method and system for non-ephemeral search |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:LLOYD, MATTHEW;REEL/FRAME:021359/0284Effective date: 20080716 |
|
REMI | Maintenance fee reminder mailed | ||
LAPS | Lapse for failure to pay maintenance fees | ||
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20160110 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044142/0357Effective date: 20170929 |