CN105719229B - Resolution control of application program transparentization based on instruction stream interception - Google Patents
Resolution control of application program transparentization based on instruction stream interception Download PDFInfo
- Publication number
- CN105719229B CN105719229B CN201510725095.8A CN201510725095A CN105719229B CN 105719229 B CN105719229 B CN 105719229B CN 201510725095 A CN201510725095 A CN 201510725095A CN 105719229 B CN105719229 B CN 105719229B
- Authority
- CN
- China
- Prior art keywords
- frame
- factors
- user experience
- back buffer
- frames
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T1/00—General purpose image data processing
- G06T1/20—Processor architectures; Processor configuration, e.g. pipelining
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T15/00—3D [Three Dimensional] image rendering
- G06T15/005—General purpose rendering architectures
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T2210/00—Indexing scheme for image generation or computer graphics
- G06T2210/36—Level of detail
Abstract
A method is provided for controlling image resolution at run-time of a graphics system. In use, the instruction stream and shader of the running program are intercepted and analyzed in real time. When a resolution change event request is generated on-the-fly, the change is made by modification of shader assembly code or graphics library instructions.
Description
Cross reference to related patent applications
The following priority is claimed to the application: U.S. provisional patent application No. 61/609268 filed on 3/10/2012, entitled "Dynamic Resolution Rendering by Way of Command stream interception," and U.S. provisional patent application No. 61/747630 filed on 31/12/2012, entitled "Playability-Aware Power ConservationAdaptation of Graphics System" (Graphics System energy saving management based on Play Performance awareness) ". This application is a partial continuation of the following U.S. patent applications (CIP): U.S. patent Application No. 12/229215 filed on 20.8.2008, entitled "Multimode Parallel Graphics Rendering system and method supporting Task-Object Division," U.S. patent Application No. 13/437869 filed on 2.4.2012, entitled "visualization method Vertical-Synchronization in Graphics Systems," and U.S. patent Application No. 13/789518 filed on 7.3.7.2013, entitled "Application-transport Resolution Control by Way of Command Stream Interception" Resolution Control Transparent to Application program in Command Stream Interception, "each of which is filed by lucidx and is hereby incorporated by reference.
Technical Field
The present invention relates generally to the field of computer graphics rendering, and more particularly, to performance enhancement approaches and means to support GPU-based, cross-platform, 3D graphics rendering processes.
Background
Power conservation management is critical when the graphics system uses a battery or other similar consumable power source. In particular, top-level video game applications in the contemporary gaming industry are very demanding with respect to graphics processing power consumption. These applications are typically run on desktop computers with powerful stand-alone GPUs at high frame rates of 50-300fps (frames per second, the same applies below).
The independent GPU is a module consuming a lot of power in the computer system, and therefore, it is a main practice to replace an integrated GPU without an external power supply. The integrated GPU consumes much less power. However, as battery-powered devices, such as laptops, tablets, and mobile phones, increasingly use integrated GPUs, it is desirable to optimize the power consumption of the integrated GPUs to achieve greater usage efficiency. This is particularly important for real-time graphics applications, such as video games, where there is a particular need for these applications to be able to be played in the above mentioned battery powered devices. In view of this, the implementation goal of the present invention is mainly integrated GPU, although it is also applicable to stand-alone GPU.
An integrated GPU (also referred to as an iGPU) is a type of graphics processor integrated on a motherboard, which may also have graphics elements embedded on a multi-core CPU chip, working in conjunction with one or more CPU cores. The integrated GPU does not use separate graphics storage, but rather shares memory with the computer system. Integrated GPUs are generally less expensive than stand-alone GPUs, but tend to perform poorly in performance and operation. Integrated GPUs find application in embedded systems, mobile phones, personal computers, workstations, and gaming machines. Over 90% of new desktop and notebook computers carry integrated GPUs, which are typically far less powerful than dedicated video cards. Computers with integrated graphics processors account for 90% of all PCs and laptops. These integrated graphics processor configurations are less costly than stand-alone graphics processor configurations, but also result in performance loss. As a result of previous experience, integrated GPUs have generally not been suitable for running 3D games. However, modern integrated graphics processors are also capable of trying to run new games. Two types of integrated GPUs, such as HD Graphics 3000 from Intel corporation and Fusion IGPs from AMD corporation, have enhanced performance, which can compete with inexpensive stand-alone video cards, but are still far from expensive stand-alone video cards. The iGPU of the old platform is integrated on the motherboard, while the new platform (e.g., Intel core i series and AMD Fusion) integrates the GPU into the CPU chip.
The satisfaction degree of the game player is a main determining factor for judging the use superiority and inferiority of the video game product. It is based on the user experience effect throughout the game, which in turn depends on frame rate, image resolution, responsiveness, and minimal boring latency (e.g., loading time). Unfortunately, power consumption management often compromises the user experience by reducing power consumption by automatically reducing frame rate, resolution, or backlight brightness, resulting in a severe impact on the playability index (playability) of the game. We define the easy-play index as the processing power of the graphics system, even if power is reduced, to meet the user experience that players need in video games. The experience of a game player is affected by a number of factors: frame rate, resolution, response latency, resource loading time, and image quality. The playful suitability index defines a critical value of each factor and ensures that the user experiences an energy-saving baseline not lower than a specified threshold to some extent. The playful index area is shown in FIG. 1, which depicts the range of the best and tolerable user experience. The lower bound of the playful index specifies the lowest power consumption allowed, i.e., threshold 1, to prevent degradation of the user experience.
There are a number of ways in the prior art to manage graphics power consumption. They are all automatically initiated to power save mode based on manual initiation to power save mode or triggered by frame duration or battery status. None of the above approaches are driven by the trade-off of energy savings and playability indices for gaming applications as described in the present invention.
Typically, prior art power management solutions address power consumption by reducing performance, clock speed and frequency, refresh rate, or adjusting screen brightness. According to Wyatt et al, in US 2008/0143729, refresh rate adjustment of the graphics subsystem is for the purpose of power conservation, and can only be in a power-saving mode, not combined with the user experience. Lin et al in US 2003/0233592 implement two power-saving implementations of a graphics system, one by disabling the graphics system to obtain strobe time, and the other by reducing the clock frequency of the graphics-rendering engine by calculating a clock scaling factor. Both are triggered by measuring the frame duration. Fan et al in US 2009/0295794 disclose a method of power saving for a GPU by disabling some of the stream processors when the graphics processing unit is in a power saving mode. Wyatt et al in the US 2012/0206461 patent teaches operating a self-refresh display device in a self-refresh mode to save power. One or more power saving states are set in a graphics controller connected to a display device. Woo-Up KWon, US2012/0280921, discloses an energy saving method for controlling screen brightness by sending screen touch actions. The HassanAzar et al patent, US 2010/0123725, discloses a method of adjusting graphics previously generated by either a stand-alone GPU or an integrated GPU. When the screen backlight is reduced, the adjusting method can be used for fusing the energy-saving technology with the image quality maintenance. The Hassan patent aims to adjust the video image while minimizing the impact on graphics processing performance. However, this does not automatically sense the value of the gameplay index limit for the gaming application.
Huang et al, in the US 2011/0157191 patent, address the situation where a user operates a graphics-intensive application from a relatively stable power source (e.g., alternating current in a wall socket). Huang no longer terminates applications or uses a depletable DC power source when resources are unavailable due to power outage or travel, etc., but teaches how to automatically limit the frame rate of applications that run on stand-alone graphics processing units that use batteries or other depletable energy sources. By automatically limiting the frame rate and the power consumption rate, the service life of the power stored in the battery is prolonged. Another embodiment of the Huang implementation more efficiently applies automatic power saving techniques by applying a low power state immediately after the last frame is rendered and displayed during the inactive detection period. The Huang invention is completely unaware of the gameplay indices of the gaming application.
The "dynamic resolution rendering" white paper written by Doug Binks by Intel describes how developers dynamically change their rendering resolution rather than statically selecting resolution. Their dynamic resolution rendering uses a view function to constrain the rendering effects to off-screen render targets and then zoom the view. This technique is either ported into the application as part of custom code or used by application developers for graphics rendering. Applications without custom migration functionality cannot use the dynamic resolution rendering method.
All of the above mentioned methods and systems, including: adjusting refresh rate, stopping gating of the graphics system, reducing clock frequency, reducing screen brightness, dynamic resolution rendering, or graphics adjustment are all to save energy. However, the prior art does not explicitly relate to the playful index of an application, such that monitoring the frame rate or image resolution improves both power consumption and user experience, while also being implemented in any gaming application. To achieve the above objective in the prior art, a piece of customized code (such as "dynamic resolution rendering" mentioned by Doug Binks of Intel) must be transplanted as part of the application before the application is run.
Specifically, the dynamic resolution rendering technique in the related art uses a view function to constrain a rendering effect to a rendering target outside the screen and then zoom the view. The method is ported as part of the code to the application.
Obviously, if the playful index is not considered in the real-time graphics application to which the power saving method is applied, it may also ultimately affect the user experience.
The user experience in real-time graphics applications is closely related to the frame rate and latency of the graphics processing system, and graphics applications include: games, CAD, three-dimensional graphics simulation, virtual reality, augmented reality, or other graphics applications, but is not limited thereto. The industry requires high FPS and low latency to increase reaction speed and reduce input lag. Common practice and existing methods employ one of two methods: (a) ignoring the refresh rate of the screen, which would produce a high FPS but show tearing, (b) enabling vertical synchronization (i.e., V-SYNC) to eliminate tearing, but would limit the screen refresh rate, further improving responsiveness. In effect, the V-SYNC reduces the frame rate of the application to coincide with the screen refresh rate.
Thus, incorporating the V-SYNC solution into the present invention greatly limits the user experience and is incompatible with industry requirements.
The applicant of this patent is also the assignee of U.S. application No. 13/437,869, entitled "Virtualization Method of Vertical-Synchronization in Graphics Systems," the entire contents of which are hereby incorporated by reference.
In different use scenarios, one of the most demanding is virtual reality, including virtual reality and augmented reality in a mobile environment. In a first embodiment, a completely virtual world is presented, typically using a head-mounted display, that can be combined with some parts of the human body, especially the rotational movement of the head and eyes or other body languages, to further enhance realism.
It is well known that the motion behavior of the human body, in particular the head and eyes, and the delays in the picture seen, are linked to negative effects both inside and outside the body, which may even lead to nausea, headache, fatigue and other stress effects of varying degrees on different individuals. Similar problems occur when stuttering and tearing are present.
Recent studies have shown that the minimum requirements to prevent this negative impact are to reduce the end-to-end delay to within 20 milliseconds and to require a stable FPS of 60, 95 or even 120. The challenges of augmented reality are stronger because the additional processing of the real world adds additional delay to the overall process.
Even in high-end systems, these conditions are difficult to satisfy, and therefore the problem is particularly obvious when the medium-low end system is adapted to the conditions.
Disclosure of Invention
The present invention provides a method and system for an automatic power saving technique for video games or similar real-time graphics applications, while also keeping the user experience level above a defined minimum. The minimum tolerable limit of the user experience is defined as the playful worthiness index. Due to the good power consumption management, the playful index can be guaranteed.
The ease of play index pre-warning helps keep the player experience within allowable limits when power consumption management is performed. The main factors controlling power consumption include frame rate, image resolution, image brightness, and responsiveness. Each of these factors can potentially compromise the playful index. Furthermore, because of the interdependencies between factors, when monitoring one power consumption factor, all other factors must be monitored simultaneously, which keeps the playful index within predetermined limits. The factor of image resolution plays an important role in the present invention in view of its transparency, dynamic and automatic application capabilities, and no customized migration in applications in advance. The method will run transparently, simultaneously with the game application, dynamically adjusting the resolution to accommodate the frame rate.
The invention meets the energy-saving requirement of real playing index early warning during operation, and particularly relates to Integrated GPUs (iGPUs) playing an important role in battery-powered equipment (notebook computers, tablet computers and mobile phones). In addition, the invention can also be applied to independent GPUs.
Another need addressed by the present invention is to increase the frame rate by using a dynamic resolution approach, which is not related to power saving, but rather serves exclusively for graphics devices that are not an exhaustive source of performance. For such power supply conditions, improving the user experience (by increasing FPS) appears to be more important than saving energy.
Drawings
In order that the embodiments of the invention may be more fully understood in the practice, the following detailed description of illustrative embodiments may be read in conjunction with the accompanying drawings, which are briefly described below:
FIG. 1. user experience versus power consumption.
Fig. 2. interdependence between power consumption, resolution and frame rate.
FIG. 3 illustrates a playful index area of a video game as a function of frame rate.
FIG. 4A illustrates a playful index area of a video game as a function of image resolution.
FIG. 4B. virtualization layer and its location in the graphics system.
Fig. 4c. principle of inter-frame dependency.
Fig. 4d. ability of a sample to be written from one resolution to a different resolution.
Fig. 5 shows an example of response degradation caused by a delay of a frame.
FIG. 6 illustrates a playful index area of a video game as a function of response lag.
FIG. 7 is a feedback mechanism for an application in power consumption management based on a playful index.
Figure 8 is a flow diagram of index-driven power management.
Fig. 9a shows an example of a six-phase screen action within one second.
Fig. 9b. scene motion presentation at high frame state of 60 FPS.
Fig. 9c motion presentation of the same scene at the 6FPS low frame state. The results shown are completely identical to those of fig. 9B, but with the energy saving effect.
FIGS. 10 and 11 are flow diagrams according to further aspects of the invention
Detailed Description
Embodiments of the present invention provide a method and system for a graphics system to apply automatic power saving techniques in running video games or similar real-time graphics applications that will ensure that the user experience is above a defined minimum level. The threshold value that the user experience can tolerate is defined as the playful index. Due to the good power consumption management, the playful index can be guaranteed.
The present invention relates mainly to graphics applications and video games with the most demanding real-time requirements, and can also be applied to other real-time programs. The ease of play index pre-warning can help the game player's experience remain within a tolerable range when power consumption management is performed. Fig. 1 depicts the variation in user experience from the "optimal" high value end, through "reasonable", down to "tolerable", i.e. the lowest acceptable experience, during power consumption saving management. According to fig. 1, the level of user experience may be expressed in terms of power consumption, such that only a given user experience area is playable. The playability index continues to deteriorate outside this area, preventing the user from enjoying the game. To achieve energy-efficient management including the playful index pre-warning function, we must define allowable playful index limits and cannot override. Two possible power consumption limits are defined in fig. 1, threshold 1 and threshold 2 respectively. Threshold 1 is sensitive and even a slight power failure may destroy the gameplay-ready index.
The main factors of the playable index of the video game include: frame rate, image resolution, image brightness, and response speed, all of which are limited by power savings.
The interdependence between frame rate, image resolution and power consumption is shown in fig. 2. For clarity of description of the interrelationship we assume that this is a linear function, although it is not necessarily linear. Fig. 2a and 2b show that power consumption is proportional to frame rate, resolution, respectively. Fig. 2c shows that the frame rate is inversely proportional to the resolution. Fig. 2d shows the relationship between the three components in a proportional relationship. A virtual plane 24 is created on which frame rate and resolution are traded off. For example, if the number of Frames Per Second (FPS) drops below 15, it will cause the user to experience lag and dullness, where reducing image resolution may improve the user experience and keep power consumption unchanged.
Frame rate is the primary tool for controlling video game power consumption. It is common for the frame rate to vary dramatically from scene to scene in a game. Even if the user moves the mouse to look around at the same position, the frame rate is high when looking in one direction, and the frame rate may be reduced after changing the angle of view. As can be seen from fig. 3, generally, the frame rate of the game is lower than 15FPS, and the playability is lost. Between 15 and 30FPS just for playability. This is caused by the fact that the frame rate variation is not smooth and sharp, giving the user an unstable impression. Fortunately, the frame rate can be increased by trading off image resolution, i.e., using low resolution rendering. Even if the visual quality is reduced, the overall experience is significantly improved from "not fit for play" to "just fit for play", from "not fit for play" to "fit for play", or from "just fit for play" to "fit for play". These tradeoffs can be done dynamically while the game is running.
Both threshold 31 and threshold 32 in fig. 3 are dynamic thresholds, which means that the thresholds can be automatically adjusted during the application process. Threshold 31 represents the lowest frame rate allowed at a given time, while preserving the playful worthiness index. This threshold is closely related to power consumption. Its value can be dynamically changed according to the current power of the mobile device. When the battery is fully charged, the device may provide a higher FPS, and as power is consumed, the FPS should be gradually decreased until the lowest playable FPS. This means that the user experience level can be expressed as a function of the amount of power, from optimal, to reasonable, to tolerable, process. For example, a device with 99% power may support 70FPS, and a device with 20% power may only support 30 FPS.
Although the threshold 31 is at the edge of the unpaid region, in some cases the threshold may be moved downward without violating the playability in order to save power. This is possible when the scene is not changing, i.e. moving slowly or not. Fig. 9 illustrates such a case. The embodiment of fig. 9A illustrates a 6-level sequence of actions that will occur within a given time, i.e., 1 second. The sequence of FIG. 9B is played within a high frame rate, playable area of 60 FPS. Each stage repeats itself several times without actually changing the displayed image. FIG. 9C plays the same sequence within 1 second of the same time, but at a frame rate of only 6 FPS. Reducing the FPS can save energy. The threshold 31 is located at a relatively unpleasantly location to substantially reduce FPS, but the image is nevertheless displayed normally and the playable index is not corrupted.
Temporary reduction of the dynamic threshold may only occur when the amount of motion in the scene is low. The measurement of motion can be achieved by parsing and analyzing a transformation matrix consisting of object, camera and mouse transformations. Another method of detecting slow or zero motion is to compare the images of successive frames.
Threshold 32 represents the highest frame rate at a given time. This threshold is not necessarily related to power consumption, but it may limit the upper bound of the FPS. The policies for the FPS dynamic thresholds may be predefined by the user or mobile vendor according to the dynamic thresholds 31 and 32.
Image resolution, i.e., the sum of pixels in the digital image. Resolution describes the detail possessed by the images of the video game. Resolution directly affects the playful index, as shown in FIG. 4A: the "just fit" and "not fit" areas are demarcated according to resolution, forming two resolution thresholds. The application can only run within the resolution range allowed by the threshold. Resolution also affects power management and power consumption. The higher the resolution, the greater the power consumption. Therefore, the resolution can be used to adjust the power consumption with reference to the manner of processing of the frame rate. The trade-off between resolution and frame rate can help maintain a given power consumption level, as shown in fig. 2D.
The principle of dynamic thresholding is equally applicable to the image resolution and at least one threshold is defined. Fig. 4A shows two thresholds. The threshold 41 reduces power consumption by setting a minimum resolution for a given time, while ensuring a playful index. Similar to the low threshold of the FPS, the value of the resolution may also be dynamically adjusted according to the battery level of the mobile device. The device may provide the highest resolution when the battery is fully charged, and a lower resolution may help to conserve power when the battery is down. As with the FPS example, the user experience is from optimal, to reasonable, to tolerable, and is affected by the image resolution, which is a function of the battery power. On the other hand, the maximum dynamic threshold 42 can control the upper limit of the image resolution, which is not related to energy saving.
The resolution control task of the present invention is performed by the virtualization layer, which is capable of separating the resolution state of the application from the frame buffer. The virtualization layer is also referred to as a dynamic resolution modifier 425, as shown in FIG. 4B. The resolution is virtualized during the frame generation process and the final physical value is obtained in the post-buffer. As a general mechanism, resolution results can be separated from the parameters of the local application, benefiting most notebook, tablet and cell phone devices.
While the application is running, its command stream and shader stream are extracted and analyzed. If a resolution change is required, an immediate resolution change is generated by an instruction modifier and/or shader assembly code modifier of the associated graphics library. Several modification commands include: viewpoint function (OpenGL: glViewport, DirectX: SetViewPort/SetViewports), render target selection function, cleanup function, stretch function, and the like.
The uploaded shader code is modified on-the-fly to compensate for the changed resolution. For example, the modification of one shader code is to make up for a smaller rendering area inside both the drawing area and the sampling area. Original shader code before modification:
132：CreatePixelShader：D3DDisassemble BEFORE Patching Done.
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_sampler s0，mode_default
dcl_sampler s1，mode_default
dcl_resource_texture2d(float，float，float，float)t0
dcl_resource_texture2d(float，float，floatfloat)t1
dcl_input_ps linear v1.xy
dcl_output o0.xyzw
dcl_output o1.xyzw
sample_indexable(texture2d)(float，float，float，float)o0.xyzw，v1.xyxx，t0.xyzw，s0
sample_indexable(texture2d)(float，float，float，float)o1.xyzw，v1.xyxx，t1.xyzw，s1
ret
modified (patched) shader code:
139：CreatePixelShader：D3DDisassemble AFTER Patching
Done.140：**********************
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer cb13[17]，immediateIndexed
dcl_constantbuffer cb12[2]，immediateIndexed
dcl_sampler s0，mode_default
dcl_sampler s1，mode_default
dcl_resource_texture2d(float，floatfloat，float)t0
dcl_resource_texture2d(float，float，float，float)t1
dcl_input_ps linear v1.xy
dcl_output o0.xyzw
dcl_output o1.xyzw
dcl_temps2
mov r1.xyzw，cb13[1].xyzw
mov r1.xyzw，v1.xyxx
mul r1.xyzw，r1.xyzw，cb13[1].xyzw
sample_indexable(texture2d)(float，float，float，float)o0.xyzw，r1.xyzw，t0.xyzw，s0
mov r1.xyzw，cb13[2].xyzw
mov r1.xyzw，v1.xyxx
mul r1.xyzw，r1.xyzw，cb13[2].xyzw
sample_indexable(texture2d)(float，float，float，float)o1.xyzw，r1.xyzw，t1.xyzw，s1
ret
the patched (modified) and original shaders may cache their hash values (hash values) separately for fast query optimization.
A 2D HUD (front mirror display) is a special case that, unlike a 3D scene, must not be modified. Rendering a 2D HUD typically takes only a small fraction of the overall frame rendering time, but its rendering effect at low resolution is not satisfactory to the user. The change in resolution should only be applied to 3D scenes. The method of selective treatment of HUDs is based on the fact that: the HUD task is the last task to write a frame into the back buffer. In assembly code, of the two terms of shader code and constants, search for a particular pattern, one can always be done at the start of the HUD task. Therefore, the detection of the front mirror display is done in three steps by accumulating instructions, performing analysis, and releasing commands to the rendering pipeline.
FIG. 4B illustrates a method of intercepting and manipulating graphics command streams and shader code streams to modify resolution. The dynamic resolution modifier 425 is broken down into five blocks. The intercept block is used to monitor the contextual environment of the streaming data. The stream analysis block is used to analyze the stream components and structure of the frame, such as which resources are for input, which resources are for output, which shader code is for various stages in the GPU pipeline, what is the current state of the 3D device, and so on in upcoming commands. The inter-frame dependency detection block is used to test the dependency of the resources, which is to ensure that no artifacts occur, since rendering is to be done on the basis of the updated resources in the previous frame. The inter-frame dependence is shown in fig. 4C. First, task i creates and changes resources (i.e., rendering targets) to be reused (e.g., textures) by subsequent frames, task j for the next frame and task k for the subsequent frame. If the resolution control changes, task i overwrites the resources, reducing the texture size, and therefore a corresponding change in the subsequent frames is necessary to prevent artifacts from occurring.
FIG. 4D shows an embodiment that can sample from one resolution and then overwrite to another different resolution. The task is illustrated in a non-limiting embodiment, and execution includes reading one type of texture resource, processing, and writing to a second type of texture resource. (a) Native application, no change in resolution. The two texture resources are the same original resolution. (b) An application that modifies the resolution. Both resources assume a compressed resolution. (c) During the process from creation, processing of a first resource to writing of a second resource, a change in resolution may occur. This task must have an according scaling resolution. It is noted that it is not always possible to read one resource and then translate it to another, as in the above embodiments. It may also read multiple resources and then write to one resource, or read one resource and write to multiple resources, or read multiple resources and write to multiple resources.
Returning to FIG. 4B, the inputs from blocks 421 through 424 facilitate resolution control module 426 in achieving the desired resolution. The execution command is passed to the instruction and shader code modification module. The change in resolution is accomplished by changing 3D API (a.k.a. graphics library) commands, particularly (but not limited to) view functions, shader code modifications, or changing GPU device state.
Each texture resource in a frame must determine a rendering resolution. The desired resolution may be different from the original resolution as encoded by the 'native' application. We achieve resolution reduction of texture resources by modifying 3D API commands to render only a portion of the resources. For the sample resources that have already been modified, the sample regions must be recalculated using an appropriate method, since they no longer possess the resolution of the original resource. This situation involves all resources as the frame progresses. However, a 2D HUD is typically the last element in a frame to be rendered. To ensure visual quality, the HUD must be rendered with the original resolution. Therefore the HUD must first be detected and the entire HUD pre-processed image must be extended to the entire resource size (the 3D scene before HUD rendering). High quality transformation can greatly improve visual quality. From this point, the rendering should run with full resolution.
Detecting HUD is accomplished by checking back the most recent command after accumulating the number of 3D API instructions to a certain extent (e.g., 30-40 instructions). The number of post-buffer output tasks is closely related to the subsequent frame (post-buffer write local). In this way, HUD tasks can be detected in most cases. In practice, the frequency of detection errors is quite low and frames that are in error can be discarded without being perceived by the user. In some special games, the frame correlation mentioned above is not very strong, and shader analysis should be used to search for known patterns in the shader code to identify the start of the HUD task.
1. target frame rate-this is the frame rate that the processing mechanism wants to achieve.
2. Maximum allowed quality impact-defines the level of degradation of resolution. Reducing the resolution by a large amount can affect the user experience. For example, if the reasonable value is 0.5, this means that in our attempt to achieve the target frame rate, the resolution is allowed to be modified to 1/4 pixels which contain the original game resolution.
The processing mechanism receives the following information in real time:
GPU load-present and past GPU loads
CPU load-present and past CPU loads
3. Frame Rate-present and past frame rates
● by looking at the GPU load and CPU load, we can see if the GPU can adjust the frame rate.
● take into account the current and past frame rates in conjunction with the GPU load and decide to decrease/increase the current resolution of the user.
● excessive rates may lead to instability: too much higher than the target frame rate results in a decrease in resolution. Lower than the target frame rate may result in increased resolution, etc. This undesirable behavior hurts the user experience.
We can prevent this from happening by the following logic:
if the current frame rate and the target frame rate are sufficiently close, the resolution will not change.
Another consequence of reducing the frame rate in video games is poor input response. An excellent interactive game requires accurate timing or fast response to user input. The lower the FPS, the higher the input delay. High input delays can cause a lag in the response of the real-time imaging system, interfering with games that require precise timing or fast response. Good responsiveness is obtained by minimizing input delay. The low frame rate has a negative impact on the responsiveness of the game because such applications are relatively late in responding to player input. Poor responsiveness tends to deteriorate the playful worthiness index. Fig. 5 shows an example of poor responsiveness caused by frame delay. The prior art has been able to reduce FPS by frame delay, such as Huang et al application US 2011/0157191. A worse case occurs in user input 1, affecting the display of frame 3 from the time frame 1 is displayed, causing a delay of two frames. The best case occurs in user input 2, where initialization occurs before frame 3 is displayed, affecting the image displayed in frame 4, resulting in only a single frame delay. The single frame delay is normal, but if the application does not know the delay of two or more frames, it will further degrade the speed of response of the user input. A slow input delay may make the game less responsive requiring precise timing or fast reaction. Figure 6 illustrates how response delays affect the playable indices of the game.
In addition to input delay, another factor that affects response speed is the loading time of game resources. Graphics data, such as texture databases, must be loaded into the GPU each time the game is started, and also from time to time during the game. If the game experiences an automatic drop in frame rate without the application's awareness, the user experience is compromised due to the lengthy loading time. The loading phase must be handled differently than at other times in the game. At other times in the game, the game will have a reduced speed due to the reduced FPS, but will still maintain a playable index. The loading phase acts as a recurring pause in the game that is not playable, giving the player the impression of occasional jamming of the game, and must be accelerated to ensure a playable index. When the FPS is artificially continually dropped and the loading phase is detected, the frame rate must be reset back to the unrestricted value or some larger value until the loading is complete.
Dimming the display backlight may reduce power consumption. In this case, the visual quality of the image may be impaired. In order to maintain the visual quality of the displayed image, the contrast of the image needs to be adjusted when converting the video image to the RGB color space. It should be noted that the backlight/contrast management must be done on a playable basis with the image quality.
FIG. 7 illustrates an energy savings management mechanism based on game playful indices. Basically, this is a mechanism for closed-loop feedback, with power consumption sampled at the beginning of each frame and adjusted, if necessary, by modifying the playful index influencing factors, including frame rate, resolution, backlight, etc. Other factors of the playful index, including response speed and resource loading time, are directly affected by the change in frame rate, and are also taken into account in the playful index for setting new FPS levels. Data collector 707 reads power consumption state 706, collects the following factor states for the easy play index: frame rate 701, resolution 702, response delay time 703, resource loading time 704, and backlight level 705. The analysis module 708 may obtain the expected power consumption δ by analyzing the deviation between the current power consumption and the energy saving requirement. On the basis that both the response speed and the resource loading time are kept at appropriate levels, the expected power consumption can be generated after the regulator 709 appropriately modifies the frame rate, resolution, backlight, and the like.
The playable index driven power management of the present invention, at the frame level, is shown in fig. 8. The current power consumption state and the playful index factors may be queried at 801. If the current frame is present in the game resource loading process 802, the frame rate should preferably be set to an unlimited or some high limit to speed up the loading process. Otherwise, the power consumption state will calculate the expected power consumption δ 803 according to the power management policy. If no change is required 804, flow stops processing this frame and waits for the next frame 813. Otherwise, we have to decide which factors, backlight or frame rate, to modify. If backlight adjustment is employed, the appropriate backlight value is calculated at 812 while the playable index is checked. If the resulting image quality is below the playable level, we go back to choosing to modify the frame rate. The tracking of the frame rate begins with calculating an expected FPS value 806. Both changing the FPS and modifying the resolution may be tradeoffs 808. This situation may occur when the desired FPS changes such that the playful index falls below a threshold 807. The final modification of the FPS will be further tested 809 for its effect on response delay. If the response time results in unpleasantness, another round of FPS/resolution tradeoff is initiated. Eventually, both the FPS and the resolution are properly adjusted and the playful index based power consuming system waits for the next frame to arrive 813.
One aspect set forth in the present invention is the combination of dynamic resolution modification and the following processes: the method includes collecting and analyzing a frame of user experience factors, comparing the factors to respective dynamically preset thresholds, and optimizing and generating adjusted instruction streams and shader streams for the GPU using the methods disclosed herein and the virtual vertical synchronization mechanism disclosed in patent 13/437869 to further enhance the user experience of using real-time graphics applications. Improving the user experience includes achieving an optimal balance among all performance such as frame rate, heating conditions, power consumption, visual quality, and input delay/response speed.
Fig. 10 is a flow chart of an embodiment of the present application. According to the brief framework mode of implementation 1000, in step 1002, the screen availability is evaluated in advance according to the completion of the back Buffer (BF). If the BF needs to be displayed, the system activates the data acquisition module at step 1004 to monitor the user experience factors for the intra-frame 1006. This factor results from the original application and user input 10061, which includes but is not limited to: a mouse, a keyboard, a joystick, a head-mounted tracking device, or any other input. The influencing factors include at least one of the following: frame rate, image resolution, GPU utilization, GPU frequency, CPU utilization, CPU frequency, and backlight (hereinafter simply "frame factor") 1010. In addition, the data acquisition module 1004 acquires state factors of the system that can also affect the user experience and are outside of the frame, including but not limited to: response delay, resource load time, power consumption, power, temperature, charger availability (hereinafter simply "system factor") 1010. The data acquisition module is implemented through a virtualization layer that separates, among other things, the frame's own factors and their associated frames. The separated frame self factors and system factors are sent to a threshold definition module 1008 to set a set of values to define a minimum allowable level for at least one of the factors. Once the threshold is set, the analysis module 1010 compares the frame factor to the threshold to define the allowable adjustment range for the frame factor. The adjustment module then uses these adjustment ranges to adjust and optimize the frame's own factors, resulting in a set of adjusted factors 1012. The adjusted back buffer or one or more out-of-picture buffers may need to be rendered later in step 1014 depending on these adjusted factors. If the screen is available (1016), a "show instruction," such as "present" in a Windows environment or "swap buffers" implemented by OpenGL, will send the adjusted BF to the FF to show the currently adjusted frame 1018. If the screen is not available 1020, based on the threshold, we can decide to wait for the screen to be available without blocking the next application command (depending on the particular presentation queue size, to prevent excessive hysteresis), or to fetch the screen in a jammed fashion (equivalent to allowing a queue of size 0), or to discard the BF. By adjusting the parameters and thresholds, these can all be present in our mechanism.
Further, according to this embodiment, if the BF has no opportunity to be rendered and displayed 1022, the task stream exhibiting the frame is sent to the dependent processing software module 1024. Each task is characterized in that the updating task of the input and output resources is determined, and after the dependency is determined, the updating task is stored in a simple frame, and then the frame is rendered to BF. Since the draw call does not involve future frames that require resources and independent rendering commands, it can be discarded in advance, which reduces the number of rendering commands in a simple frame and can reduce system resources and time consumed in rendering. The purpose of creating and rendering simple frames is to ensure the continuous availability of resources for successive frames, preventing artifacts from occurring. Once a simple frame is rendered, it is dropped. At worst, this simple frame mode also ensures high responsiveness of single frame delay, and at best, the ratio of the number of single frame delays in a frame drops to the effect of fig. 6 of patent 13/437869, and the larger the difference between the FPS and the screen refresh rate, the smaller the ratio of single frame delays at best. It is therefore an object of this invention to improve user experience and response speed by increasing the application FPS. However, as mentioned above, the higher the FPS and the greater the difference in refresh rate of the applied FPS from the screen, the higher the chance of image tearing occurring. This is obvious as higher FPS results in more image tearing events, but due to the fact that the dead time between successive frames becomes smaller, the impact of image tearing on visual quality is reduced and thus visual disparity becomes smaller. Although the impact of tearing in these cases is reduced, sub-optimal processes still have an impact on the overall user experience. On the other hand, the smaller the correlation between frames, the shorter the simple frame, and the application needs to increase the FPS. However, the higher the correlation between frames, the longer the simple frame, and the less the improvement effect of applying FPS. Therefore, another object of the present invention is: once a dependency is determined by the dependent processor software module, the degree of dependency between frames is defined. As mentioned above, if there is no inter-frame dependency, the frame will be discarded. Returning to FIG. 10, assuming that inter-frame dependencies have been detected (1028) (1026), then the dependency level is defined by dependency level definition module 1030. For example, the dependency level may be defined in terms of the total number of dependent tasks of a frame and a percentage of the total number of tasks. In this embodiment, the dependency threshold 1032 is defined and dynamically displayed by the data acquisition module 1034 based on inter-frame and out-of-frame user experience factors. Once the inter-frame dependency threshold is set, the current analysis inter-frame dependency level of the current frame is calculated and then compared to the threshold. If the calculated inter-frame dependency is lower than the threshold of step 1036, then the simple frame is rendered at step 1038 based on local factors that depend on the task. No additional data collection and data analysis is required, nor is the resolution changed, in order to save time and power. However, if the calculated inter-frame dependency is above the threshold predefined in step 1040, then the frame needs to be analyzed. Data 1042 in data collector 1044 is a function of defining a threshold for inter-frame, out-of-frame user experience parameters, and once the threshold is defined, analyzing the local command for the frame and comparing it to the threshold (1046). The adjustment software module 1048 adjusts the simple frame stream of commands to generate adjusted simple frames. The adjusted simple frame is then rendered at step 1050, using the adjusted instruction stream in place of the associated command stream originally generated by the native application. For example, the adjustment scheme may include a change in resolution of the image resulting from the dynamic resolution modification module inputting data to the data collector. It should also be noted that whenever the resource image resolution changes, information on its original resolution will not be preserved, and the sampling area of these resources should be recalculated whenever a simple frame is dropped or displayed in a full frame. Once the adjusted simple frame is generated, the resources it relies on are saved in consecutive frames, and this simple frame can be discarded.
Thus, according to an embodiment based on the degree of inter-frame dependency, two sets of simple frames may be created. A low inter-frame dependency may create a short simple frame and a high inter-frame dependency requires the creation of a long simple frame. The longer the simple frame, the lower the improvement effect of applying FPS. Also, since a long simple frame requires a long pipe queue, the response effect is reduced, and a short simple frame allows a short pipe queue to be used, the response performance can be greatly improved. Therefore, another outcome of this invention is: a method is disclosed for shortening simple frames using the simple frame adjustment mechanism discussed above, which enables higher FPS and response speed, and also improves user experience.
Fig. 11 illustrates another embodiment of the invention, and the dependency threshold may be defined by module 1032 or data acquisition module 1034. If the back buffer defined by module 1002 cannot be displayed and dependencies have been detected by modules 1024 and 1026, then the detected dependency level is compared to the currently defined dependency threshold to make further decisions. According to one embodiment of the decision process: if the dependency is high, such as greater than 80% or 90% of the frame resources being dependent resources, then process 1040 is configured to process the entire original frame based on the original factors of the frame, rather than using simple frame techniques. The computation of simple frames consumes system resources. Rendering a frame, even a simple frame, can cost even more than computing the simple frame. If the dependency is high, rendering the entire frame will consume less effort, and this analysis process uses raw instructions rather than simple frame techniques to avoid critical percentage situations of independent resources. In this embodiment, module 1038 renders the simple frame only if the dependency level is below a threshold. In addition, other factors may be considered in determining whether to reduce the frame, one of which is synchronized with the refresh rate of the picture. To avoid delay, the back buffer is already ready for a frame to be rendered prior to or adjacent to any one of the vertical synchronization events. Thus, while the overall cost of computing and rendering a simple frame is lower than the cost of rendering a frame using the original application factors, according to the conclusion of this invention: if there is a high probability that a frame will not be prepared in advance for an upcoming vertical event, the system will skip the step of thinning the frame.
According to another aspect shown in fig. 11, once module 1030 has calculated the inter-frame correlation, module 1003 reconsiders the likelihood of frame display based on inter-frame dependencies and some other factors. If the inter-frame dependency is high and therefore the expected simple frame is long, this may affect the early decision not to display this frame (otherwise the flow does not go through the left branch of the flow chart) and may even be exactly opposite to the previous decision. For example, the decision is based on the time to hold until the next vertical synchronization event, and the opposite decision may be made. If the time to the next vertical synchronization event is kept shorter than the time required to generate the current frame, whether a simple frame or a full frame, plus the estimated time required to generate the next frame, a decision opposite to the previous decision may be made: along the right side of the flow chart, the current frame is sent to the back buffer for presentation. If the inter-frame dependency is low and the expected simple frame is also short, then this will support the previous decision not to display the current frame, just to render it, and then to discard it, whether this frame is all of one simple frame or not, based on the time to keep to the next vertical synchronization event, in order to avoid artifacts appearing.
Claims (33)
1. A computer-implemented method of optimizing and presenting the rendering of frames in a graphics system based on user experience factors, the method comprising the steps of:
receiving one or more frames from a graphics system;
receiving and storing user experience factors;
defining a threshold based on user experience factors for one or more frames;
analyzing the self-factors and the system factors of one or more frames based on the defined threshold;
providing an adjusting module, and adjusting the user experience factors of the frame by using the adjusting module;
selectively presenting the content in the adjusted back buffer based on the adjusted user experience factors;
determining whether a screen is available for display; and
if the screen is available for display, the contents of the adjusted or unadjusted back buffer are transferred to the preceding frame for display,
wherein the method further comprises: evaluating the usability of the screen in advance before completing a back buffer; and if the contents of the back buffer can be displayed, activating the data collection module such that the data collection module monitors the user experience factors and user input of the internal frame.
2. The method of claim 1, wherein if the screen is not available for display, the contents of the back buffer are saved to a graphics pipe queue.
3. The method of claim 1, wherein the step of transferring the contents of the adjusted back buffer to the frame buffer comprises sending a current command or a command to swap buffers to display the contents of the adjusted back buffer.
4. The method of claim 1, wherein the monitored factors include one or more of self factors of the frame, system factors, and user input.
5. The method of claim 4, wherein the frame's own factors include one or more of frame rate, image resolution, GPU utilization, GPU frequency, CPU utilization, and backlight.
6. The method of claim 4, wherein the system factors include one or more of response delay, resource loading time, heat, power consumption, temperature, charger availability, and power level.
7. The method of claim 4, wherein the user input is from one or more of a mouse, a keyboard, a joystick, any form of controller, and a head-mounted tracking device.
8. The method of claim 1, wherein the data collection module separates the current frame's own factors from other frames associated with the frame, and wherein the step of defining the threshold comprises defining a minimum allowable level for at least one of the factors.
9. The method of claim 1, wherein the analyzing step comprises comparing the frame's own factor to a threshold to determine an allowable adjustment range for adjusting the frame's own factor.
10. The method of claim 1, wherein the adjustment module adjusts the frame's own factors within a range allowed by a set of adjustment factors.
11. The method of claim 1, wherein the data collection module further receives input to reduce a delay in displaying frames in the back buffer.
12. A system for optimizing rendering and presentation of rendered frames in a user experience factor-based graphics system, the system comprising:
a graphics processing unit providing one or more frames for rendering;
a non-transitory memory to receive and store user experience factors;
the non-transitory memory contains operational instructions that, when received from a graphics system, include the steps of:
defining a threshold based on user experience factors for one or more frames;
analyzing self and system factors of one or more frames based on the defined threshold;
providing an adjusting module, and adjusting the user experience factors of the frame by using the adjusting module;
selectively presenting content in the adjusted back buffer based on the adjusted user experience factors;
determining whether a screen is available for display; and
if the screen is available for display, the contents of the adjusted or unadjusted back buffer are transferred to the preceding frame for display,
wherein the operation instruction further comprises the steps of: evaluating the usability of the screen in advance before completing a back buffer; and if the contents of the buffer can be displayed, activating the data collection module such that the data collection module monitors the user experience factors and user input of the internal frame.
13. The system of claim 12, wherein if the screen is not available for display, the contents of the back buffer are placed in a graphics pipe queue.
14. The system of claim 12, wherein transferring the contents of the adjusted or unadjusted back buffer to the previous frame comprises sending a current command or a command to swap buffers to display the contents of the adjusted or unadjusted back buffer.
15. The system of claim 12, wherein the monitored factors include one or more of self factors of the frame, system factors, and user input.
16. The system of claim 15, wherein the frame's own factors include one or more of frame rate, image resolution, GPU utilization, GPU frequency, CPU utilization, and backlight.
17. The system of claim 15, wherein the system factors include one or more of response delay, resource loading time, heat, power consumption, temperature, charger availability, and power.
18. The system of claim 15, wherein the user input comprises input from one or more of a mouse, a keyboard, a joystick, any form of controller, and a head-mounted tracking device.
19. The system of claim 12, wherein the data collection module separates the current frame's own factors from other frames associated with the frame, and wherein the step of defining the threshold comprises defining a minimum allowable level for at least one of the factors.
20. The system of claim 12, wherein the frame's own factor is compared to a threshold to determine an allowable adjustment range for adjusting the frame's own factor.
21. The system of claim 12, wherein the adjustment module adjusts the frame's own factors within a range allowed by a set of adjustment factors.
22. The system of claim 12, wherein the data collection module further receives input to reduce a delay in displaying frames in the back buffer.
23. A non-transitory computer readable medium storing a program that causes a graphics processing unit to perform processing of an image and provide operational instructions when one or more frames are received from the graphics processing unit, the operational instructions comprising the steps of:
defining a threshold based on user experience factors for one or more frames;
analyzing self and system factors of one or more frames based on the defined threshold;
providing an adjusting module, and adjusting the user experience factors of the frame by using the adjusting module;
selectively presenting content in the adjusted back buffer based on the adjusted user experience factors;
determining whether a screen is available for display; and
if the screen is available for display, the contents of the adjusted or unadjusted back buffer are transferred to the preceding frame for display,
wherein the operation instruction further comprises the steps of: evaluating the usability of the screen in advance before completing a back buffer; and if the contents of the back buffer can be displayed, activating the data collection module such that the data collection module monitors the user experience factors and user input of the internal frame.
24. The computer readable medium of claim 23, wherein if the screen is not available for display, the contents of the back buffer are placed in a graphics pipe queue.
25. The computer readable medium of claim 23, wherein the step of transferring the contents of the adjusted back buffer to the frame buffer comprises sending a current command or a command to swap buffers to display the contents of the adjusted back buffer.
26. The computer-readable medium of claim 23, wherein the monitored factors include one or more of self factors, system factors, and user inputs of the frame.
27. The computer readable medium of claim 26, wherein the frame's own factors include one or more of frame rate, image resolution, GPU utilization, GPU frequency, CPU utilization, and backlight.
28. The computer-readable medium of claim 26, wherein the system factors include one or more of response delay, resource loading time, heat, power consumption, temperature, charger availability, and power level.
29. The computer readable medium of claim 26, wherein the user input comprises input from one or more of a mouse, a keyboard, a joystick, any form of controller, and a head mounted tracking device.
30. The computer-readable medium of claim 23 wherein the data collection module separates the current frame's own factors from other frames associated with the frame, and wherein the step of defining the threshold includes defining a minimum allowable level for at least one of the factors.
31. The computer readable medium of claim 23, wherein the analyzing step comprises comparing the frame's own factors to a threshold to determine the allowable adjustment range.
32. The computer readable medium of claim 23, wherein the adjustment module adjusts the frame's own factors to the extent allowed by a set of adjustment factors.
33. The computer readable medium of claim 23, wherein the data collection module further receives input to reduce a delay in displaying frames in the buffer.
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/576,248 US20150177822A1 (en) | 2008-08-20 | 2014-12-19 | Application-transparent resolution control by way of command stream interception |
US14/576,248 | 2014-12-19 |
Publications (2)
Publication Number | Publication Date |
---|---|
CN105719229A CN105719229A (en) | 2016-06-29 |
CN105719229B true CN105719229B (en) | 2020-03-03 |
Family
ID=56145010
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN201510725095.8A Active CN105719229B (en) | 2014-12-19 | 2015-10-30 | Resolution control of application program transparentization based on instruction stream interception |
Country Status (1)
Country | Link |
---|---|
CN (1) | CN105719229B (en) |
Families Citing this family (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN107398070B (en) * | 2017-07-19 | 2018-06-12 | 腾讯科技（深圳）有限公司 | Display control method and device, the electronic equipment of a kind of game picture |
CN108427199A (en) * | 2018-03-26 | 2018-08-21 | 京东方科技集团股份有限公司 | A kind of augmented reality equipment, system and method |
CN113132798B (en) * | 2019-12-30 | 2022-03-15 | 海信集团有限公司 | Video playing method, device, electronic equipment and medium |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN1430766A (en) * | 2000-04-14 | 2003-07-16 | 皮克塞(研究)有限公司 | System and method for generating visual representations of graphical data and digital document processing |
CN1469240A (en) * | 2002-07-16 | 2004-01-21 | System and method for providing intermediate target in graphic system | |
CN103813124A (en) * | 2012-11-12 | 2014-05-21 | 索尼公司 | Image processing device and image processing method |
Family Cites Families (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8933949B2 (en) * | 2010-10-01 | 2015-01-13 | Z124 | User interaction across cross-environment applications through an extended graphics context |
US8961316B2 (en) * | 2002-12-10 | 2015-02-24 | Ol2, Inc. | System and method for improving the graphics performance of hosted applications |
US8184089B2 (en) * | 2009-07-29 | 2012-05-22 | Samsung Electronics Co., Ltd. | Backlight level selection for display devices |
US9256265B2 (en) * | 2009-12-30 | 2016-02-09 | Nvidia Corporation | Method and system for artificially and dynamically limiting the framerate of a graphics processing unit |
US8576276B2 (en) * | 2010-11-18 | 2013-11-05 | Microsoft Corporation | Head-mounted display device which provides surround video |
-
2015
- 2015-10-30 CN CN201510725095.8A patent/CN105719229B/en active Active
Patent Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN1430766A (en) * | 2000-04-14 | 2003-07-16 | 皮克塞(研究)有限公司 | System and method for generating visual representations of graphical data and digital document processing |
CN1469240A (en) * | 2002-07-16 | 2004-01-21 | System and method for providing intermediate target in graphic system | |
CN103813124A (en) * | 2012-11-12 | 2014-05-21 | 索尼公司 | Image processing device and image processing method |
Also Published As
Publication number | Publication date |
---|---|
CN105719229A (en) | 2016-06-29 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9082196B2 (en) | Application-transparent resolution control by way of command stream interception | |
US20150177822A1 (en) | Application-transparent resolution control by way of command stream interception | |
US8754904B2 (en) | Virtualization method of vertical-synchronization in graphics systems | |
US9984431B2 (en) | GPU workload prediction and management | |
US8072459B2 (en) | Data processing unit with multi-graphic controller and method for processing data using the same | |
KR20180048886A (en) | GPU workload characterization and power management using command stream hinting | |
US10007292B2 (en) | Energy aware dynamic adjustment algorithm | |
CN111465966B (en) | Apparatus and method for command stream optimization and enhancement | |
US20120320068A1 (en) | Dynamic context switching between architecturally distinct graphics processors | |
CN105719229B (en) | Resolution control of application program transparentization based on instruction stream interception | |
US11954792B2 (en) | Real-time GPU rendering with performance guaranteed power management | |
WO2021000220A1 (en) | Methods and apparatus for dynamic jank reduction | |
TW202230325A (en) | Methods and apparatus for display panel fps switching | |
US20210358079A1 (en) | Methods and apparatus for adaptive rendering | |
US11847995B2 (en) | Video data processing based on sampling rate | |
WO2021151228A1 (en) | Methods and apparatus for adaptive frame headroom | |
WO2021000226A1 (en) | Methods and apparatus for optimizing frame response | |
Chen et al. | A User-Centric CPU-GPU Governing Framework for 3-D Mobile Games | |
US10678553B2 (en) | Pro-active GPU hardware bootup | |
WO2021196175A1 (en) | Methods and apparatus for clock frequency adjustment based on frame latency | |
US11238772B2 (en) | Methods and apparatus for compositor learning models | |
WO2023230744A1 (en) | Display driver thread run-time scheduling | |
WO2021232328A1 (en) | Methods and apparatus for tickless pre-rendering | |
US11615537B2 (en) | Methods and apparatus for motion estimation based on region discontinuity | |
US11087431B2 (en) | Methods and apparatus for reducing draw command information |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
C06 | Publication | ||
PB01 | Publication | ||
C10 | Entry into substantive examination | ||
SE01 | Entry into force of request for substantive examination | ||
TA01 | Transfer of patent application right |
Effective date of registration: 20180809Address after: American CaliforniaApplicant after: Google limited liability companyAddress before: Israeli nanitaniaApplicant before: LUCIDLOGIX TECHNOLOGIES LTD. |
|
TA01 | Transfer of patent application right | ||
GR01 | Patent grant | ||
GR01 | Patent grant |