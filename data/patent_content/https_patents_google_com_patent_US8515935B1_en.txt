CROSS-REFERENCE TO RELATED APPLICATION
This application is a continuation application and claims the priority of U.S. application Ser. No. 11/756,127, filed May 31, 2007 and entitled “IDENTIFYING RELATED QUERIES,” the contents of which are incorporated herein by reference.
FIELD
The following disclosure relates to information retrieval.
BACKGROUND
Locating a desired portion of information on the World Wide Web (“web”) can be challenging because the amount of information available. Query processing systems permit a user to search information on the web, and attempt to return search results that are relevant to a search query provided by the user. The goal of a query processing system is to provide links to high quality, relevant search results (e.g., links to web pages) to the user used on the search query.
SUMMARY
According to one aspect, there is disclosed a method. The method can include receiving a first search query and a second search query, generating a first image based on the first search query, and a second image based on the second search query, and determining if the first search query and the second search query are related by comparing the first image to the second image.
One or more of the following features may also be included. The method can include determining a query volume associated with the first search query during a period of time, and a query volume associated with the second search query during the period of time. Determining if the first search query and the second search query are related can include determining that the first search query and the second search query are related when the query volume associated with the first search query and the query volume associated with the second search query exhibit a similar rise or decrease during the period of time. Generating a first image based on the first search query, and a second image based on the second search query can include generating the first image based on the query volume associated with the first search query, and generating the second image based on the query volume associated with the second search query.
According to another feature, determining if the first search query and the second search query are related can include determining that the first search query and the second search query are related when the first image and the second image exhibit similar rises or decreases in query volume during the period of time. Determining a query volume associated with the first search query, and a query volume associated with the second search query can also include determining the query volume associated with the first search query based on the search volume of the first search query relative to all queries during the period of time, and determining the query volume associated with the second search query based on the search volume of the second search query relative to all queries during the period of time. Additionally, the method can include displaying that the first search query and the second search query are related.
According to another aspect, there is a method that includes generating a first image based on a first search query, generating a second image based on a second search query, processing the first image to generate a first set of wavelets corresponding to the first image, processing the second image to generate a second set of wavelets corresponding to the second image, and determining if the first search query and the second search query are related by comparing at least some of the first set wavelets to at least some of the second set of wavelets.
According to a feature, the method can include identifying a first subset of top wavelets from the first set of wavelets, and identifying a second subset of top wavelets from the second set of wavelets. Determining if the first search query and the second search query are related can include determining if the first search query and the second search query are related by comparing the first subset of top wavelets to the second subset of top wavelets.
According to yet another aspect, a method is disclosed. The method includes generating a plurality of images, where each image is associated with a respective search query of a plurality of search queries, processing the plurality of images to generate a set of wavelets for each of the plurality of images, and identifying a respective subset of top wavelets for each set of wavelets. The method also includes generating signatures for each of the plurality of images based on the subset of top wavelets for each respective image, and determining if a first search query of the plurality of search queries is related to a second search query of the plurality of search queries by comparing a signature corresponding to the first query to a signature corresponding to the second search query.
According to a feature, generating signatures for each of the plurality of images based on the subset of top wavelets for each respective image includes generating signatures for each of the plurality of images using a min-hash algorithm to compress the subset of top wavelets. Additionally, the method can include identifying at least a portion of signatures for comparison using a hashing scheme, which can be a locality sensitive hashing scheme.
These general and specific aspects may be implemented using a system, a method, or a computer program, or any combination of systems, methods, and computer programs. Aspects of the invention can include none, one or more of the following advantages. Search results can be provided to user based on a user provided query and one or more system identified second queries that are determined to be related. While conventional query processing systems provide search results to users based on their queries, they are ineffective at providing a user with search results based on related queries that may identify relevant search results to the user even though the related queries differ from the user's query.
BRIEF DESCRIPTION OF THE DRAWINGS
Having thus described the invention in general terms, reference will now be made to the accompanying drawings, which are not necessarily drawn to scale and wherein:
FIG. 1 shows an example search system.
FIG. 2 shows an example server in the search system of FIG. 1, according to an illustrative implementation.
FIG. 3 shows an example log processing system in the search system of FIG. 1, according to an illustrative implementation.
FIG. 4 shows a block diagram flow chart illustrating an example method of identifying related queries, according to an illustrative implementation.
FIG. 5 shows a block diagram flow chart illustrating an example method of identifying related queries, according to another illustrative implementation.
FIG. 6 shows an illustrative 2-D image of relative query volume for a search query, according to an implementation.
FIG. 7 shows a block diagram flow chart illustrating an example method of identifying related queries, according to another illustrative implementation.
FIG. 8 shows an illustrative 2-D image of relative query volume for a search query, according to another implementation.
DETAILED DESCRIPTION
The present disclosure now will be described more fully hereinafter with reference to the accompanying drawings, in which some, but not all implementations are shown. Indeed, these implementations can be embodied in many different forms and should not be construed as limited to the implementations set forth herein; rather, these implementations are provided so that this disclosure will satisfy applicable legal requirements. Like numbers refer to like elements throughout.
The following disclosure describes systems, methods, and computer program products that can identify related search queries that exhibit similar rises or decreases in volume over a period of time. In this disclosure, the term “site” or “website” includes any domain or subdomain (e.g., google.com, labs.google.com, etc.) or a domain plus a uniform resource locator prefix (e.g., geocities.com/Athens/). Additionally, although the disclosure focuses on searches related to web sites, implementations are also applicable to searching any machine-readable and machine-storable information (e.g., document).
This disclosure is described with reference to block diagrams and flowchart illustrations of methods, apparatuses (i.e., systems) and computer program products. It will be understood that blocks of the block diagrams and flowchart illustrations, and combinations of blocks in the block diagrams and flowchart illustrations, respectively, may be implemented by computer program instructions. These computer program instructions may be loaded onto a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions which execute on the computer or other programmable data processing apparatus create means for implementing the functions specified in the flowchart block or blocks.
These computer program instructions may also be stored in a computer-readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in the computer-readable memory produce an article of manufacture including instruction means that implement the function(s) specified in the flowchart block or blocks. The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions that execute on the computer or other programmable apparatus provide steps for implementing the function(s) specified in the flowchart block or blocks.
Accordingly, blocks of the block diagrams and flowchart illustrations support combinations of means for performing the specified functions, combinations of steps for performing the specified functions and program instruction means for performing the specified functions. It will also be understood that each block of the block diagrams and flowchart illustrations, and combinations of blocks in the block diagrams and flowchart illustrations, can be implemented by special purpose hardware-based computer systems that perform the specified functions or steps, or combinations of special purpose hardware and computer instructions.
Referring now to FIG. 1, an example search system 100 is shown according to an illustrative implementation. The system 100 includes clients 110 a, 110 b, 110 c, . . . 110 x in communication with a server 120 via one or more networks 140. Although multiple clients 110 a, 110 b, 110 c, . . . 110 x and a single server 120 are illustrated in FIG. 1, there can be more servers and more or fewer clients. For instance, some of the functions performed by the server 120 can be performed by one or more other servers such that the server 120 can represent several devices, such as a network of computer processors and/or servers. Additionally, in some implementations a client can perform a function of the server 120 and the server 120 can perform a function of a client. Other architectures, i.e., non client server, are possible.
The clients 110 a, 110 b, 110 c, . . . 110 x can include a device, such as a personal computer, a wireless telephone, a personal digital assistant (PDA), a lap top computer, or another type of computation or communication device, a thread or process running on one of these devices, and/or an object executable by one of these devices. The server 120 can include one or more servers that gather, process, maintain, manage information and/or provide search results to users. In an example implementation, the server 120 can include a log processing system 125 that processes and stores information associated with, for example, search queries, such as search queries input by clients' 110 a, 110 b, 110 c, . . . 110 x. The server 120 can also include a query processing system 135 usable by the clients 110 a, 110 b, 110 c, . . . 110 x. The query processing system 135 can identify search queries and determine those related search queries, e.g., those having similar rises or decreases in volume.
The network(s) 140 can include one or more local area networks (LANs), wide area networks (WANs), telephone networks, such as the Public Switched Telephone Network (PSTN), intranets, the Internet, and/or or other type of network. The clients 110 a, 110 b, 110 c, . . . 110 x and server 120 can connect to the network(s) 140 via wired, wireless, or optical or other connections. In alternative implementations, one or more of the devices illustrated in FIG. 1 are directly connected to another one of the devices. For example, in one implementation, the clients 110 a, 110 b, 110 c, . . . 110 x are directly connected to the server 120.
FIG. 2 shows the server 120 of FIG. 1, according to an illustrative implementation. The server 120 can include a bus 210, a processor 220, a main memory 230, a read only memory (ROM) 240, a storage device 250, one or more input devices 260, one or more output devices 270, and a communication interface 280. The bus 210 can include one or more paths that permit communication among the components of server 120.
The processor 220 includes any type of conventional processor, microprocessor or processing logic that interprets and executes instructions. The main memory 230 can include a random access memory (RAM) or another type of dynamic storage device that stores information and instructions for execution by processor 220. The ROM 240 can include a conventional ROM device or another type of static storage device that stores static information and instructions for use by the processor 220, including, for instance, an operating system. Additionally, the storage device 250 can include a magnetic and/or optical recording medium and its corresponding drive.
The server 120 can also include an input device 260 having one or more conventional mechanisms that permit a user to input information to the server 120, such as a keyboard, a mouse, a pen, voice recognition and/or biometric mechanisms, or the like. The output device 270 includes one or more conventional mechanisms that output information to the user, such as a display, a printer, a speaker, or the like. The communication interface 280 can include any transceiver-like mechanism that enables the server 120 to communicate with other devices and/or systems. For example, the communication interface 280 can include mechanisms for communicating with another device or system via one or more networks, such as the network(s) 140.
In operation the server 120 can store data associated with individual search queries and/or search results (e.g., web pages) and can perform searches based on inputs from clients 110 a, 110 b, 110 c, . . . 110 x. In one implementation, the server 120 performs these operations in response to the processor 220 executing software instructions contained in a computer-readable medium, such as memory 230. The software instructions can be read into the memory 230 from another computer readable medium, such as a data storage device 250, or from another device via the communication interface 280. The software instructions contained in the memory 230 cause processor 220 to perform processes described in this disclosure. Alternatively, hardwired circuitry can be used in place of or in combination with software instructions to implement processes consistent with the disclosure. Thus, implementations are not limited to any specific combination of hardware circuitry and software.
FIG. 3 is a functional block diagram of an example log processing system 125 of FIG. 1, according to an illustrative implementation. The log processing system 125 can include a front end 310 and a data storage 320. The logical blocks illustrated in FIG. 3 can be implemented in software, hardware, or a combination of hardware and software. In addition, each of the functional blocks can represent one or more computer processors, threads, and/or objects. It should also be understood that in alternative implementations, the functions performed by one of the blocks in FIG. 3 can be performed by another block. In other implementations, a single logical block/processing device can perform at least some of the functions of the log processing system 125.
The front end 310 receives information associated with clients' 110 a, 110 b, 110 c, . . . 110 x input of search queries and/or access of various web pages/sites. For example, the front end 310 can receive search queries when a client 110 a, 110 b, 110 c, . . . 110 x inputs a search query into a search engine, such as Google®. The front end 310 can forward this information to the data storage 320, which can store the search queries. For example, the data storage 320 can include information identifying search queries that have been entered by clients 110 a, 110 b, 110 c, . . . 110 x. The data storage 320 can also store information indicating a total number of times each of the search queries has been entered by clients 110 a, 110 b, 110 c, . . . 110 x and/or the particular times and/or dates the search queries have been entered. For instance, the data storage 320 can include the total number of queries for each day, and the total number of times a particular search query has been entered in a given day. The data storage 320 can store this search query and/or related information corresponding to a past period of time, such as 30 days, a year, or the like. Alternatively, or in addition to the information described above, the data storage 320 can store a list or ranking of top search queries.
FIG. 4 shows a block diagram flow chart illustrating an example method of identifying related queries, according to an illustrative implementation. In particular, the method permits the identification of search queries that exhibit similar rises or decreases in volume over a period of time. The method begins with the generation of a 2-D image representing the relative volume of a search query (block 410). The relative volume represented may include the relative volume of the search query over a period of time. Next, the 2-D image is processed to generate wavelets representing the 2-D image (block 420). One example method for generating wavelets is described in ‘Wavelets for computer graphics: A primer, part 1’, by Eric J. Stollnitz, Tony D. DeRose, and David H. Salesin, IEEE Computer Graphics and Applications, 15(3):76-84, May 1995, the contents of which are incorporated by reference. Top wavelets, which include high magnitude coefficients and/or represent significant characteristics of the 2-D image, are identified (block 430). The top wavelets corresponding to the 2-D image are compared to the top wavelets of other search queries to identify related queries (block 440). According to an implementation, once identified, related queries for a particular query entered by a user may be displayed to the user, and/or search results for the related query may be provided to the user along with the search results for the query entered by the user.
FIG. 5 shows a block diagram flow chart illustrating an example method of identifying related queries, according to another implementation. According to an implementation, the method can be implemented by the server 120 of FIG. 1. A search query of interest is identified, where the search query is referenced as ‘Q’ in FIG. 5 for convenience (block 510). The search query ‘Q’ can be received at the server 120 from one of more clients 110 a, 110 b, 110 c, . . . 110 x and optionally stored by the log processing system 125 within the data storage 330. According to an implementation, the search query ‘Q’ can be identified by the query processing system 135 of the server 120. The query processing system 135 can identify the search query ‘Q’ as a query of interest, for instance, as a search query stored in the data storage 330 that ranks as a top search query received from the one or more clients 110 a, 110 b, 110 c, . . . 110 x. As an illustrative example, the query processing system may identify the search query ‘Q’ as one of the top 1,000,000 search queries stored in a list or ranking of search queries received by the server 120.
Next, the total number of all search queries for each smallest-desired-time unit ‘H’ (e.g., one day) over a specified past time period ‘D’ are identified (block 530). According to an implementation, the query processing system 135 can collect and/or tally the total number of queries for each time unit ‘H’ over a specified past time period from information stored within the data storage 330 of the log processing system 125. The number of time units ‘H’ for which the total number of queries are collected may vary, such as 30 days, 90 days, a year, or the like. According to an implementation, the number of time units ‘H’ are adjustable by a user associated with a client 110 a, 110 b, 110 c, . . . 110 x or an administrator associated with the server 120. The number ‘D’ of time units ‘H’ establishes a historical window for which search queries will be examined to identify search queries exhibiting similar rises or decreases in volume.
The total number of queries for search query ‘Q’ during each time unit ‘H’ over the specified past time period ‘D’ is identified (block 530). According to an implementation, the query processing system 135 can collect and/or tally the total number of queries for search query ‘Q’ for each time unit ‘H’ over the specified past time period from information stored within the data storage 330 of the log processing system 125.
Next, the number of queries for search query ‘Q’ for each time unit ‘H’ are normalized by, for example, the queries-per-time-unit for that day (block 540) to identify the relative volume for the search query ‘Q’ out of the total volume. Normalizing permits the identification of increases and decreases for a search query by eliminating the effects of increasing query volumes. For instance, on a particular hour, there may be 10 requests for search query ‘Q’ out of a total of 100 search queries/hour for that day, where a request for search query ‘Q’ represents 10% of search queries. At the same hour on a different day, there may be 20 requests for search query ‘Q’ out of a total of 1000 search queries/hour for that day, such that requests for the search query ‘Q’ represents only 2% of search queries. Although the number of search queries for ‘Q’ rise from 10 to 20 in the above examples, the relative volume of search queries for ‘Q’ decline from 10% to 2%. According to an implementation, the normalization can be implemented by the query processing system 135.
A two-dimensional image is generated of the relative query volume for the search query ‘Q’, which represents the percentage of the total volume of queries that the search query ‘Q’ represented across a period of time (block 550). According to an implementation, the two-dimensional image illustrates the percentage of total volume of a search query ‘Q’ across the past time period ‘D’. The two-dimensional image can be generated by the query processing system 135. FIG. 6 shows an illustrative graph 600 including a two dimensional image 610 illustrating the relative query volume for a search query ‘Q’. Although the two dimensional image 610 shown in FIG. 6 includes the relative query volume, in percentage points, for a particular search query on each time unit ‘H’ over the course of several weeks, the two dimensional image 610 can alternatively be illustrated by a 3-D surface, histogram, 2-D line, line graph, bar graph, or other image that graphically illustrates relative query volume over a period of time.
According to an implementation, the query processing system 135 pre-processes each 2-D image by blurring the images (block 560). Blurring an image creates a new, processed image from the original 2-D image where each pixel in the new image is a weighted average of the original pixel and its neighboring pixels. This process softens the hard edges of an image, which aids in matching processes so that edges (and thus image contents) do not have to be exactly aligned for a match to be identified. According to another implementation, the query processing system 135 can effect blurring of an original 2-D image by applying a Gaussian blur filter or convolving the image with a small sub-image that will weight an original pixel value based on the value of each of its surrounding neighbors. For instance, convolving an image with the sub-image
will weight the original pixel's value as 5× the value of each of its surrounding eight neighbors. Larger sub-images may be used that take into account more neighbors, and different weightings may also be used.
According to an implementation, each pre-processed image is processed to generate wavelets to represent the image (block 570). Wavelets are a known mathematical tool for hierarchically decomposing functions. and can be used to represent a 2-D image. The top wavelets for each pre-processed image are identified (block 570). The top wavelets are those wavelets that have high magnitude coefficients, and which represent the main characteristics of the image. According to an implementation, the top wavelets include those whose magnitude exceeds a threshold value. The threshold value can be automatically determined as a function of the size of an image or may encompass a top percentage of the wavelets. For instance, the threshold value may be set to include the top 10% of the wavelets. According to another implementation, the threshold value may be manually set, such as the top 100 wavelets.
The top wavelets can be represented as quantized top wavelets that represent a binary vector (block 580), where the ton wavelets can be represented by a limited number of bits. According to an implementation, 2 bits are assigned to every wavelet coefficient. To effect this, the coefficients can be sorted based on their magnitude, irrespective of whether the coefficient is positive or negative. If a top wavelet is positive, it is assigned a value of 01, and if it is negative it is assigned a value of 10. Wavelets that do not exceed a threshold value are assigned a value of 00. According to another implementation, more bits can be used to identify whether wavelets exceed additional threshold values. For instance, 3 or more bits may be used and assigned to wavelets based on whether the wavelet is positive, negative, and/or exceeds two or more threshold values.
According to another implementation, after the top wavelets can be identified, the top wavelets can be subjected to another combination of transformation and quantization to extract a description of the 2-D pre-processed image. For instance, an alternative transformation could be effected by removal, variance normalization and projection using a PCA (Principal Components Analysis) basis learned from data derived from a previous time period. An illustrative example of an alternative quantization is a 5-level quantization defined by each coefficients' expected percentile values. For instance, 10%, 30%, 70%, and 90% could be the dividing lines for the quantization levels represented by −2, −1, 0, 1, 2.
According to an implementation, the generation of quantized top wavelets for queries ( blocks 510, 520, 530, 540, 550, 560, 570) is performed for each search query of interest (block 580), such as search queries identified in a list or ranking of search queries received by the server 120. The quantized top wavelets for each query of interest can be stored in memory, for instance, the data storage 330.
Next, the quantized top wavelets for the particular query are compared with all of the quantized top wavelets associated with other search queries (block 590). According to an implementation, this may be performed by the log processing system 125. In one implementation, a related query to the particular query is determined by identifying the stored query in the database that includes the most similar top wavelets (i.e., coefficients) to the particular query (block 590). To effect the comparison, the binary vectors representing the quantized top wavelets are compared against other binary vectors to identify the bit positions that are similar or different. Similar binary vectors differ in fewer bit positions that vectors that differ. According to an implementation, the queries that are most similar may be ranked in terms of their similarity, and a threshold value can be used to identify those queries that are deemed similar. For instance, the top 5 or 10 percent of vectors, ranked in terms of their similarity, may be deemed to be similar queries.
FIG. 7 shows a block diagram flow chart illustrating an example method of identifying related queries, according to another illustrative implementation. The method begins with the generation of a 2-D image representing the relative volume of a search query (block 710). The 2-D image is then processed to generate wavelets representing the 2-D image (block 720). The top wavelets are identified (block 730). To reduce the number of images that must be compared to a particular query of interest to identify related queries for that query, signatures are generated based on the top wavelets (block 740).
According to an implementation, a Min-Hash algorithm may be used to create the signature by compressing the number of top-wavelets. For instance, for each top-wavelet vector, a binary vector (i.e., a row of 0/1 numbers) can be generated, with a ‘0’ in position ‘1’ if the wavelet-I is not within a top number of wavelets, such as within the top 1000 wavelets for an image. If the wavelet-I is within the top number of wavelets, position ‘I’ can be a ‘1’ value. Next, an arbitrary value for reducing the number of top wavelets is selected, such as 50 or 100, which is used to identify the independent permutations of the generated rows. For each permutation, the first row position in which there is a 1 is identified. The value of the first position can be concatenated and used as the new signature of an image. According to an implementation, the process of creating a new signature may be implemented by the log processing system 125 and new signatures may be stored in the data storage 330.
After the new signatures are generated corresponding to each search query to be compared, one or more hashing schemes can be used to identify those signatures that should be compared to identify related queries (block 750). According to an implementation, a locality-sensitive hashing (LSH) scheme can be implemented, for instance, by the log processing system 125. LSH selects small, random, but non-overlapping members of the signature and hashes them into bins repeatedly (for instance, 10 or 20 times) to ensure that no member of a signature is used twice. With each query, the same division of signatures is used to effect the hashing. As an illustrative example, if the first members of a signature that are hashed are from positions 1, 5, 8, 10, 91, and 101, then every query will have members from those same positions that are hashed. According to an implementation, each set of hashes are stored in their own hash table, such that the number of hash sets corresponds to the number of hash tables, and every query includes a subset of members hashing to the same number of hash tables. Using this technique, which may be implemented by the log processing system 125, permits a signature associated with a particular query of interest to be compared against a small number of signatures (associated with other search queries) in matching bins instead of all signatures. The bins, according to an implementation, are stored within the data storage 330.
As an illustrative example, if a new search query has a signature that is hashed into 20 hash tables, queries within each of the locations of the 20 hash tables are examined. Using this process the system can determine those queries that are most often identified within the same hash tables. Where a query is located in many of the same hash tables, it is likely that the query has many of the same values in many of the same hash positions, which results in the system determining that the a query is related to the new search query.
Although the above implementations are described with respect to a 2-D image, images of other dimensions can also be implemented and used to identify related queries using the techniques described herein. For instance, a 1-dimensional image could be used, such as a 1-dimensional image illustrating the relative query volume of a particular query for each day of a week. A 3-D dimensional image could be used to break down the relative volume of a query based on weeks (one axis), days (second axis), and hours of the day (third axis). Still other variables may be used to create 4 or 5 dimensional images. For instance, a 4-D dimensional image could include the same axis described in the 3-D image, plus an additional axis representing the countries of origin for a search query. Yet another variable could be represented by a 5th axis to generate a 5-D dimensional image, such as a property or origin of the query. For instance, a Google™ query may be defined as a froogle query, web query, image query, or the like.
FIG. 8 shows an illustrative 2-D image 810 of relative query volume for a search query, according to another implementation. The 2-D image 810 of FIG. 8 does not include a time axis because the 2-D image corresponds to a particular period of time, such as a day, hour, or week. A series of 2-D images like the illustrative 2-D image 810 of FIG. 8 permits the matching of multiple images for each query without utilizing time as an image axis. This permits the matching of queries illustrating similar volume decreases or increases but not necessarily at the same time. For instance, two seemingly unrelated search queries run at different times of the year may exhibit the same query volume trends even though the search queries are temporally shifted.
It will be apparent to one of ordinary skill in the art that aspects of the invention, as described above, can be implemented in many different forms of software, firmware, and hardware in the implementations illustrated in the figures. The actual software code or specialized control hardware used to implement aspects consistent with the principles of the invention is not limiting of the invention. Thus, the operation and behavior of the aspects were described without reference to the specific software code—it being understood that one of ordinary skill in the art would be able to design software and control hardware to implement the aspects based on the description herein.