US9263053B2 - Method and apparatus for generating a candidate code-vector to code an informational signal - Google Patents
Method and apparatus for generating a candidate code-vector to code an informational signal Download PDFInfo
- Publication number
- US9263053B2 US9263053B2 US13/667,001 US201213667001A US9263053B2 US 9263053 B2 US9263053 B2 US 9263053B2 US 201213667001 A US201213667001 A US 201213667001A US 9263053 B2 US9263053 B2 US 9263053B2
- Authority
- US
- United States
- Prior art keywords
- vector
- code
- fixed codebook
- vectors
- codebook code
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active, expires
Links
Images
Classifications
-
- G—PHYSICS
- G10—MUSICAL INSTRUMENTS; ACOUSTICS
- G10L—SPEECH ANALYSIS OR SYNTHESIS; SPEECH RECOGNITION; SPEECH OR VOICE PROCESSING; SPEECH OR AUDIO CODING OR DECODING
- G10L19/00—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis
- G10L19/04—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis using predictive techniques
- G10L19/08—Determination or coding of the excitation function; Determination or coding of the long-term prediction parameters
- G10L19/12—Determination or coding of the excitation function; Determination or coding of the long-term prediction parameters the excitation function being a code excitation, e.g. in code excited linear prediction [CELP] vocoders
-
- G—PHYSICS
- G10—MUSICAL INSTRUMENTS; ACOUSTICS
- G10L—SPEECH ANALYSIS OR SYNTHESIS; SPEECH RECOGNITION; SPEECH OR VOICE PROCESSING; SPEECH OR AUDIO CODING OR DECODING
- G10L19/00—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis
- G10L19/04—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis using predictive techniques
- G10L19/08—Determination or coding of the excitation function; Determination or coding of the long-term prediction parameters
- G10L19/083—Determination or coding of the excitation function; Determination or coding of the long-term prediction parameters the excitation function being an excitation gain
-
- G—PHYSICS
- G10—MUSICAL INSTRUMENTS; ACOUSTICS
- G10L—SPEECH ANALYSIS OR SYNTHESIS; SPEECH RECOGNITION; SPEECH OR VOICE PROCESSING; SPEECH OR AUDIO CODING OR DECODING
- G10L19/00—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis
- G10L19/005—Correction of errors induced by the transmission channel, if related to the coding algorithm
-
- G—PHYSICS
- G10—MUSICAL INSTRUMENTS; ACOUSTICS
- G10L—SPEECH ANALYSIS OR SYNTHESIS; SPEECH RECOGNITION; SPEECH OR VOICE PROCESSING; SPEECH OR AUDIO CODING OR DECODING
- G10L19/00—Speech or audio signals analysis-synthesis techniques for redundancy reduction, e.g. in vocoders; Coding or decoding of speech or audio signals, using source filter models or psychoacoustic analysis
- G10L2019/0001—Codebooks
- G10L2019/0013—Codebook search algorithms
Definitions
- the present disclosure relates, in general, to signal compression systems and, more particularly, to Code Excited Linear Prediction (CELP)-type speech coding systems.
- CELP Code Excited Linear Prediction
- CELP Code Excited Linear Prediction
- FIG. 12 is a block diagram of a CELP encoder 1200 of the prior art.
- an input signal s(n) such as a speech signal
- LPC Linear Predictive Coding
- the spectral parameters are denoted by the transfer function A(z).
- the spectral parameters are applied to an LPC Quantization block 1202 that quantizes the spectral parameters to produce quantized spectral parameters A q that are suitable for use in a multiplexer 1208 .
- the quantized spectral parameters A q are then conveyed to multiplexer 1208 , and the multiplexer 1208 produces a coded bitstream based on the quantized spectral parameters and a set of codebook-related parameters, ⁇ , ⁇ , k, and ⁇ , that are determined by a squared error minimization/parameter quantization block 1207 .
- the quantized spectral, or Linear Predictive, parameters are also conveyed locally to an LPC synthesis filter 1205 that has a corresponding transfer function 1/A q (z).
- LPC synthesis filter 1205 also receives a combined excitation signal u(n) from a first combiner 1210 and produces an estimate of the input signal s(n) based on the quantized spectral parameters A q and the combined excitation signal u(n).
- Combined excitation signal u(n) is produced as follows.
- An adaptive codebook code-vector c ⁇ is selected from an adaptive codebook (ACB) 1203 based on an index parameter ⁇ and the combined excitation signal from the previous subframe u(n-L).
- the adaptive codebook code-vector c ⁇ is then weighted based on a gain parameter ⁇ 1230 and the weighted adaptive codebook code-vector is conveyed to first combiner 1210 .
- a fixed codebook code-vector c k is selected from a fixed codebook (FCB) 1204 based on an index parameter k.
- the fixed codebook code-vector c k is then weighted based on a gain parameter ⁇ 1240 and is also conveyed to first combiner 1210 .
- First combiner 1210 then produces combined excitation signal u(n) by combining the weighted version of adaptive codebook code-vector c ⁇ with the weighted version of fixed codebook code-vector c k .
- LPC synthesis filter 1205 conveys the input signal estimate ⁇ (n) to a second combiner 1212 .
- the second combiner 1212 also receives input signal s(n) and subtracts the estimate of the input signal ⁇ (n) from the input signal s(n).
- the difference between input signal s(n) and the input signal estimate ⁇ (n) is applied to a perceptual error weighting filter 1206 , which filter produces a perceptually weighted error signal e(n) based on the difference between ⁇ (n) and s(n) and a weighting function W(z).
- Perceptually weighted error signal e(n) is then conveyed to squared error minimization/parameter quantization block 1207 .
- Squared error minimization/parameter quantization block 1207 uses the error signal e(n) to determine an optimal set of codebook-related parameters ⁇ , ⁇ , k, and ⁇ that produce the best estimate s(n) of the input signal s(n).
- FIG. 13 is a block diagram of a decoder 1300 of the prior art that corresponds to the encoder 1200 .
- the coded bitstream produced by the encoder 1200 is used by a demultiplexer 1308 in the decoder 1300 to decode the optimal set of codebook-related parameters, ⁇ , ⁇ 1330 , k, and ⁇ 1340 .
- the decoder 1300 uses a process that is identical to the synthesis process performed by encoder 1200 , by using an adaptive codebook 1303 , a fixed codebook 1304 , signals u(n) and u(n-L), code-vectors c ⁇ and c k , and a LPC synthesis filter 1305 to generate output speech.
- an adaptive codebook 1303 a fixed codebook 1304 , signals u(n) and u(n-L), code-vectors c ⁇ and c k , and a LPC synthesis filter 1305 to generate output speech.
- the speech ⁇ (n) output by the decoder 1300 can be reconstructed as an exact duplicate of the input speech estimate ⁇ (n) produced by the encoder 1200 .
- FIG. 14 is a block diagram of an exemplary encoder 1400 of the prior art that utilizes an equivalent, and yet more practical, system compared to the encoding system illustrated by encoder 1200 .
- the variables are given in terms of their z-transforms.
- the weighting function W(z) can be distributed and the input signal estimate ⁇ (n) can be decomposed into the filtered sum of the weighted codebook code-vectors:
- E ⁇ ( z ) W ⁇ ( z ) ⁇ S ⁇ ( z ) - W ⁇ ( z ) A q ⁇ ( z ) ⁇ ( ⁇ ⁇ ⁇ C ⁇ ⁇ ( z ) + ⁇ ⁇ ⁇ C k ⁇ ( z ) ) ( 2 )
- W(z)S(z) corresponds to a weighted version of the input signal.
- Equation 6 represents the perceptually weighted error (or distortion) vector e(n) produced by a third combiner 1408 of encoder 1400 and coupled by the combiner 1408 to a squared error minimization/parameter quantization block 1407 .
- a formula can be derived for minimization of a weighted version of the perceptually weighted error, that is, ⁇ e ⁇ 2 , by squared error minimization/parameter quantization block 1407 .
- the adaptive codebook (ACB) component is optimized first by assuming the fixed codebook (FCB) contribution is zero, and then the FCB component is optimized using the given (previously optimized) ACB component.
- the ACB/FCB gains that is, codebook-related parameters ⁇ and ⁇ , may or may not be re-optimized, that is, quantized, given the sequentially selected ACB/FCB code-vectors c ⁇ and c k .
- ⁇ * argmin ⁇ ⁇ ⁇ x w T ⁇ x w - ( x w T ⁇ Hc ⁇ ) 2 c ⁇ T ⁇ H T ⁇ Hc ⁇ ⁇ , ( 11 )
- ⁇ * is an optimal ACB index parameter, that is, an ACB index parameter that minimizes the bracketed expression.
- ⁇ is a parameter related to a range of expected values of the pitch lag (or fundamental frequency) of the input signal, and is constrained to a limited set of values that can be represented by a relatively small number of bits. Since x w is not dependent on ⁇ , Equation 11 can be rewritten as follows:
- ⁇ * argmax ⁇ ⁇ ⁇ ( x w T ⁇ Hc ⁇ ) 2 c ⁇ T ⁇ H T ⁇ Hc ⁇ ⁇ ( 12 )
- Equation 13 can be simplified to:
- Equation 10 can be simplified to:
- Equations 13 and 14 represent the two expressions necessary to determine the optimal ACB index ⁇ and ACB gain ⁇ in a sequential manner. These expressions can now be used to determine the optimal FCB index and gain expressions.
- the vector x w (or x w (n)) is produced by a first combiner 1404 that subtracts a filtered past synthetic excitation signal h zir (n), after filtering past synthetic excitation signal u(n-L) by a weighted synthesis zero input response H zir (z) filter 1401 , from an output s w (n) of a perceptual error weighting filter W(z) 1402 of input speech signal s(n).
- ⁇ Hc ⁇ is a filtered and weighted version of ACB code-vector c ⁇ , that is, ACB code-vector c ⁇ filtered by zero state weighted synthesis filter H zs (z) 1415 to generate y(n) and then weighted based on ACB gain parameter ⁇ 1430 .
- Equation 16 argmax k ⁇ ⁇ ( x 2 T ⁇ Hc k ) 2 c k T ⁇ H T ⁇ Hc k ⁇ , ( 16 ) where k* is an optimal FCB index parameter, that is, an FCB index parameter that maximizes the bracketed expression.
- FCB gain ⁇ argmax k ⁇ ⁇ ( d 2 T ⁇ c k ) 2 c k T ⁇ ⁇ ⁇ ⁇ c k ⁇ , ( 17 ) in which the optimal FCB gain ⁇ is given as:
- the encoder 1400 provides a method and apparatus for determining the optimal excitation vector-related parameters ⁇ , ⁇ , k, and ⁇ .
- higher bit rate CELP coding typically requires higher computational complexity due to a larger number of codebook entries that require error evaluation in the closed loop processing.
- FIG. 1 is an example block diagram of at least a portion of a coder, such as a portion of the coder in FIG. 12 , according to one embodiment
- FIG. 2 is an example block diagram of a FCB candidate code-vector generator according to one embodiment
- FIG. 3 is an example illustration of a flowchart outlining the operation of a coder according to one embodiment
- FIG. 4 is an example illustration of a flowchart outlining candidate code-vector construction operation of a coder according to one embodiment
- FIG. 5 is an example illustration of two conceptual candidate code-vectors c k [i] according to one embodiment
- FIG. 6 is an example illustration of a flowchart outlining the operation of a coder according to one embodiment
- FIG. 7 is an example illustration of a flowchart outlining the operation of a coder according to one embodiment
- FIG. 8 is an example illustration of a flowchart outlining the operation of a coder according to one embodiment
- FIG. 9 is an example illustration of a flowchart outlining the operation of a coder according to one embodiment.
- FIG. 10 is an example block diagram of the fixed codebook candidate code-vector generator from FIG. 1 according to one embodiment
- FIG. 11 is an example illustration of a flowchart outlining the operation of a coder according to one embodiment
- FIG. 12 is a block diagram of a Code Excited Linear Prediction (CELP) encoder of the prior art
- FIG. 13 is a block diagram of a CELP decoder of the prior art.
- FIG. 14 is a block diagram of another CELP encoder of the prior art.
- Embodiments of the present disclosure can solve a problem of searching higher bit rate codebooks by providing for pre-quantizer candidate generation in a Code Excited Linear Prediction (CELP) speech coder.
- Embodiments can address the problem by generating a set of initial FCB candidates through direct quantization of a set of vectors formed using inverse weighting functions and the FCB target signal and then evaluating a weighted error of those initial candidates to produce a better overall code-vector.
- Embodiments can also apply variable weights to vectors and can sum the weighted vectors as part of preselecting candidate code-vectors.
- Embodiments can additionally generate a set of initial fixed codebook candidates through direct quantization of a set of vectors formed using inverse weighting functions and the fixed codebook target signal and then evaluate the weighted errors of that initial set of candidates to produce a better overall code-vector.
- Other embodiments can also generate a set of initial FCB candidates through direct quantization of a set of vectors formed using inverse weighting functions and the FCB target signal, and then evaluating a weighted error of those initial candidates to determine a better initial weighting function for a given pre-quantizer function.
- a method and apparatus can generate a candidate code-vector to code an information signal.
- the method can include producing a weighted target vector from an input signal.
- the method can include processing the weighted target vector through an inverse weighting function to create a residual domain target vector.
- the method can include performing a first search process on the residual domain target vector to obtain an initial fixed codebook code-vector.
- the method can include performing a second search process over a subset of possible codebook code-vectors for a low weighted-domain error to produce a final fixed codebook code-vector.
- the subset of possible codebook code-vectors can be based on the initial fixed codebook code-vector.
- the method can include generating a codeword representative of the final fixed codebook code-vector.
- the codeword can be for use by a decoder to generate an approximation of the input signal.
- FIG. 1 is an example block diagram of at least a portion of a coder apparatus 100 , such as a portion of the coder 1200 , according to one embodiment.
- the coder 100 can include an input 122 , a target vector generator 124 , a FCB candidate code-vector generator 110 , a FCB 104 , a zero state weighted synthesis filter H equivalent 105 , an error minimization block 107 , a first gain parameter ⁇ weighting block 141 , a combiner 108 , and an output 126 .
- the coder 100 can also include a second zero state weighted synthesis filter H equivalent 115 , a second error minimization block 117 , a second gain parameter ⁇ weighting block 142 , and a second combiner 118 .
- the zero state weighted synthesis filter equivalent 105 , the error minimization block 107 , and the combiner 108 , as well as the second zero state weighted synthesis filter H equivalent 115 , the second error minimization block 117 , and the second combiner 118 can operate similarly to the zero state weighted synthesis filter 1405 , the squared error minimization parameter quantizer 1407 , and the combiner 1408 , respectively, as illustrated in FIG. 14 .
- a zero state weighted synthesis filter H is not actually implemented, but rather a mathematical equivalent is implemented as discussed with respect to Eqs. 16, 17, and 18.
- the input 122 can receive and may process an input signal s(n).
- the input signal s(n) can be a digital or analog input signal.
- the input can be received wirelessly, through a hard-wired connection, from a storage medium, from a microphone, or otherwise received.
- the input signal s(n) can be based on an audible signal, such as speech.
- the target vector generator 124 can receive the input signal s(n) from the input 122 and can produce a target vector x 2 from the input signal s(n).
- the FCB candidate code-vector generator 110 can receive the target vector x 2 and can construct a set of candidate code-vectors c k [i] and an inverse weighting function ⁇ (x 2 ,i), where i can be an index for the candidate code-vectors c k [i] where 0 ⁇ i ⁇ N, and N is at least one.
- the set of candidate code-vectors c k [i] can be based on the target vector x 2 and can be based on the inverse weighting function.
- the inverse weighting function can remove weighting from the target vector x 2 in some manner. For example, an inverse weighting function can be based on
- FCB 104 may also use the inverse weighting function result as a means of further reducing the search complexity, for example, by searching only a subset of the total pulse/position combinations.
- the error minimization block 117 may also select one of a plurality of candidate code-vectors c k [i] with lower squared sum value of e i as c k i *. That is, after the best candidate code-vector c k i * is found by way of square error minimization, the fixed codebook 104 may use c k i * as an initial “seed” code-vector which may be iterated upon.
- the inverse weighting function result ⁇ (x 2 , i*) may also be used in this process to help reduce search complexity.
- i* can represent the index value of the optimum candidate code-vector c k [i] .
- the remaining blocks can perform the corresponding functions.
- the error minimization block 107 can provide the indices i of the candidate code-vectors and the index value i* of the optimum candidate code-vector and the zero state weighted synthesis filter 105 can receive the candidate code-vectors c k [i] (not shown).
- the FCB candidate code-vector generator 110 can construct the set of candidate code-vectors c k [i] based on the target vector x 2 , based on an inverse filtered vector, and based on a backward filtered vector as described below.
- the set of candidate code-vectors c k [i] can also be based on the target vector x 2 and based on a sum of a weighted inverse filtered vector and weighted backward filtered vector as described below.
- the error minimization block 117 can evaluate an error vector e i associated with each of the plurality of candidate code-vectors c k [i] .
- the error vector can be analyzed to select a single FCB code-vector c k [i*] , where the FCB code-vector c k [i*] can be one of the candidate code-vectors c k [i] .
- the squared error minimization/parameter quantization block 107 can generate a codeword k representative of the FCB code-vector c k [i] .
- the codeword k can be used by a decoder to generate an approximation ⁇ (n) of the input signal s(n).
- the error minimization block 107 or another element can output the codeword k at the output 126 by transmitting the codeword k and/or storing the codeword k.
- the error minimization block 117 may generate and output the codeword k.
- Each candidate code-vector c k [i] can be processed as if it were generated by the FCB 104 by filtering it through the zero state weighted synthesis filter 105 for each candidate c k [i] .
- the FCB candidate code-vector generator 110 can evaluate an error value associated with each iteration of the plurality of candidate code-vectors c k [i] from the plurality of times to produce a FCB code-vector c k based on the candidate code-vector c k [i] with the lowest error value.
- Multiple ⁇ (x 2 ,i) outputs can be used to determine a codebook output, which can be c k [i] or c k .
- c k [i] can be a starting point for determining c k , where c k [i] can allow for fewer iterations of k and can allow for a better overall result by avoiding settling on a local minima and missing a more global minimum error ⁇ .
- FIG. 2 is an example block diagram of the FCB candidate code-vector generator 110 according to one embodiment.
- the FCB candidate code-vector generator 110 can include an inverse filter 210 , a backward filter 220 , and another processing block for a FCB candidate code-vector generator 230 .
- the FCB candidate code-vector generator 110 can construct a set of candidate code-vectors c k [i] , where i can be an index for the candidate code-vectors c k [i] .
- the set of candidate code-vectors c k [i] can be based on the target vector x 2 and can be based on an inverse weighting function, such as ⁇ (x 2 ,i).
- the inverse weighting function can be based on an inverse filtered vector and the inverse filter 210 can construct the inverse filtered vector from the target vector x 2 .
- r can be the inverse filtered vector
- H ⁇ 1 can be a zero-state weighted synthesis convolution matrix formed from an impulse response of a weighted synthesis filter
- x 2 can be the target vector.
- Other variations are described in other embodiments.
- the inverse weighting function can be based on a backward filtered vector, and the backward filter 220 can construct the backward filtered vector from the target vector x 2 .
- H T can be a transpose of a zero-state weighted synthesis convolution matrix formed from an impulse response of a weighted synthesis filter
- x 2 can be the target vector.
- This expression can be a generalized form for generating a plurality of pre-quantizer candidates that can be assessed for error in the weighted domain. An example of such a function is given as:
- f ⁇ ( x 2 , i ) a i ⁇ r ⁇ r ⁇ + b i ⁇ d 2 ⁇ d 2 ⁇ , ( 23 )
- a i and b i are a set of respective weighting coefficients for iteration i.
- the effect of coefficients a i and b i can be to produce a weighted sum of the inverse and backward filtered target vectors, which can then form the set of pre-quantizer candidate vectors.
- Embodiments of the present disclosure can allow various coefficient functions to be incorporated into the weighting of the normalized vectors in Eq. 23.
- a i 1 - i / ( N - 1 )
- ⁇ b i i / ( N - 1 )
- ⁇ 0 ⁇ i ⁇ N ( 24 )
- candidates can have a linear distribution of values over a given range.
- the sets of coefficients can be: a i ⁇ 1.0, 0.667, 0.333, 0.0 ⁇ , and b i ⁇ 0.0, 0.333, 0.667, 1.0 ⁇ .
- Another example may incorporate the results of a training algorithm, such as the Linde-Buzo-Gray (or LBG) algorithm, where many values of a and b can be evaluated offline using a training database, and then choosing a, and b, based on the statistical distributions.
- a training algorithm such as the Linde-Buzo-Gray (or LBG) algorithm
- LBG Linde-Buzo-Gray
- Such methods for training are well known in the art.
- B i may be a class of linear phase filtering characteristics intended to shape the residual domain quantization error in a way that more closely resembles that of the error in the weighted domain.
- the weighted signal can then be quantified into a form that can be utilized by the particular FCB coding process.
- U.S. Pat. No. 5,754,976 to Adoul and U.S. Pat. No. 6,236,960 to Peng disclose coding methods that use unit magnitude pulse codebooks that are algebraic in nature. That is, the codebooks are generated on the fly, as opposed to being stored in memory, searching various pulse position and amplitude combinations, finding a low error pulse combination, and then coding the positions and amplitudes using combinatorial techniques to form a codeword k that is subsequently used by a decoder to regenerate c k and further generate an approximation ⁇ (n) of the input signal s(n).
- the codebook disclosed in U.S. Pat. No. 6,236,960 can be used to quantify the inverse weighted signal into a form that can be utilized by the particular FCB coding process.
- the i-th pre-quantizer candidate c k [i] may be obtained from Eq. 22 by iteratively adjusting a gain term g Q as:
- This expression describes a process of selecting g Q such that the total number of unit amplitude pulses in c k [i] equals m.
- c k [i*] it is also not necessary for c k [i*] to contain the exact number of pulses as allowed by the FCB.
- the FCB configuration may allow c k to contain 20 pulses, but the pre-quantizer stage may use only 10 or 15 pulses. The remaining pulses can be placed by the post search, which will be described later with respect to FIG. 9 .
- the pre-quantizer stage may place more pulses than allowed by the FCB configuration.
- the post search may remove pulses in a way that attempts to minimize the weighted error.
- the number of pulses in the pre-quantizer vector can be generally equal to the number of pulses allowed by a particular FCB configuration.
- the post search may involve removing a unit magnitude pulse from one position and placing the pulse at a different location that results in a lower weighted error. This process may be repeated until the codebook converges or until a predetermined maximum number of iterations is reached.
- the candidate codebook for generating c k [i] may be different than the codebook for generating c k . That is, the best candidate c k [i*] may generally be used to reduce complexity or improve overall performance of the resulting code-vector c k , by using c k [i*] as a means for determining the best inverse function ⁇ (x 2 ,i*), and then proceeding to use ⁇ (x 2 ,i*) as a means for searching a second codebook c′ k .
- Such an example may include using a Factorial Pulse Coded (FPC) codebook for generating c k [i*] , and then using a traditional ACELP codebook to generate c′ k , wherein the inverse function ⁇ (x 2 ,i*) is used in the secondary codebook search c′ k , and the candidate code-vectors c k [i] are discarded.
- FPC Factorial Pulse Coded
- a traditional ACELP codebook to generate c′ k
- the pre-selection of pulse signs for the secondary codebook c′ k may be based on a plurality of inverse functions ⁇ (x 2 ,i), and not directly on the candidate code-vectors c k [i] .
- This embodiment may allow performance improvement to existing codecs that use a specific codebook design, while maintaining interoperability and backward compatibility.
- the ACB/FCB parameters may be jointly optimized.
- the joint optimization can also be used for evaluation of N pre-quantizer candidates.
- Eq. 17 can become:
- y 2 [i] Hc k [i] can be the i-th pre-quantizer candidate filtered though the zero state weighted synthesis filter 105 and y T c k [i] can be a correlation between the i-th pre-quantizer candidate and the scaled backward filtered ACB excitation.
- FIG. 3 is an example illustration of a flowchart 300 outlining the operation of the coder 100 according to one embodiment.
- the flowchart 300 illustrates a method that can include the embodiments disclosed above.
- a target vector x 2 can be generated from a received input signal s(n).
- the input signal s(n) can be based on an audible speech input signal.
- a plurality of inverse weighting functions ⁇ (x 2 ,i) can be constructed based on the target vector x 2 .
- a plurality of candidate code-vectors c k [i] can also be constructed based on the target vector x 2 and inverse weighting functions ⁇ (x 2 ,i).
- the plurality of inverse weighting functions ⁇ (x 2 ,i) (and/or plurality of candidate code-vectors c k [i] ) can be constructed based on an inverse filtered vector and based on a backward filtered vector along with the target vector x 2 .
- the plurality of inverse weighting functions ⁇ (x 2 ,i) (and/or plurality of candidate code-vectors c k [i] ) can also be constructed based on a sum of a weighted inverse filtered vector and a weighted backward filtered vector along with the target vector x 2 .
- an error value ⁇ associated with each code-vector of the plurality of inverse weighting functions ⁇ (x 2 ,i) (and/or plurality of candidate code-vectors c k [i] ) can be evaluated to produce a fixed codebook code-vector c k .
- errors ⁇ [i] of c k [i] can be evaluated to produce c k [i*] , then c k [i*] can be used as a basis for further searching on c k .
- the value k can be the ultimate codebook index that is output.
- a codeword k representative of the fixed codebook code-vector c k can be generated, where the codeword can be used by a decoder to generate an approximation ⁇ (n) of the input signal s(n).
- the codeword k can be output.
- the codeword k can be a fixed codebook index parameter codeword k that can be output by transmitting the fixed codebook index parameter k and/or storing the fixed codebook index parameter k.
- FIG. 4 is an example illustration of a flowchart 400 outlining the operation of block 320 of FIG. 3 according to one embodiment.
- an inverse filtered vector r can be constructed from the target vector x 2 .
- the inverse weighting function ⁇ (x 2 , i) of block 320 can be based on the inverse filtered vector r constructed from the target vector x 2 .
- H ⁇ 1 can be a zero-state weighted synthesis convolution matrix formed from an impulse response of a weighted synthesis filter
- x 2 can be the target vector.
- Other variations are described in other embodiments above.
- a backward filtered vector d 2 can be constructed from the target vector x 2 .
- the inverse weighting function ⁇ (x 2 , i) of block 320 can be based on the backward filtered vector d 2 constructed from the target vector x 2 .
- H T can be a transpose of a zero-state weighted synthesis convolution matrix formed from an impulse response of a weighted synthesis filter
- a plurality of inverse weighting functions ⁇ (x 2 ,i) (and/or plurality of candidate code-vectors c k [i] ) can be constructed based on a weighting of the inverse filtered vector r and a weighting of the backward filtered vector d 2 , where the weighting can be different for each of the associated candidate code-vectors c k [i] .
- the weighting can be based on
- f ⁇ ( x 2 , i ) a i ⁇ r ⁇ r ⁇ + b i ⁇ d 2 ⁇ d 2 ⁇ or other weighting described above.
- the candidate code-vectors c k [1] and c k [2] can correspond to factorial pulse coded vectors for different functions ⁇ (x 2 , 1) and ⁇ (x 2 , 2) of a target vector.
- one of the candidate code-vectors, c k [i] can be used as a basis for choosing codeword c k that generates a fixed codebook index parameter k.
- the fixed codebook index parameter k can identify, at least in part, a set of pulse amplitude and position combinations, such as including a pulse amplitude 510 and a position 520 , in a codebook.
- the set of pulse amplitude and position combinations can be used for functions ⁇ (x 2 , 1) and ⁇ (x 2 , 2) for a chosen candidate code-vector c k [i*] , such as, for example, code-vector c k [1] .
- the illustration 500 is only intended as a conceptual example and does not correspond to any actual number of pulses, positions of pulses, code-vectors, or signals.
- FIG. 6 is an example illustration of a flowchart 600 outlining the operation of the coder 100 according to one embodiment.
- the functions of flowchart 600 may be implemented within the fixed codebook candidate code-vector generator 110 .
- the flowchart 600 illustrates a method that can include the embodiments disclosed above.
- the return value of function ⁇ (x 2 ,i) can be redefined as a residual domain target vector b, where vector b is a different variable from the b, weighting coefficient.
- a scalar gain value g Q can be initialized to some value, and in this case, an estimate can be used based on an average of the vector magnitudes:
- m can be the total or desired number of unit magnitude pulses
- L can be the vector length
- b(n) can be the n th element of the residual domain target vector b.
- an iterative search process can begin by which the gain value g Q can be varied to produce a pre-quantizer candidate c k [i] that can contain the appropriate number of unit magnitude pulses m, the positions of which correspond to a low residual domain error, i.e., ⁇ g Q c k [i] ⁇ b ⁇ 2 can be a minimum.
- c k [i] can be generated according to:
- g Q can be increased at 670 so that fewer unit magnitude pulses m are generated when repeating Eq. 32. Likewise, if it is determined at 640 that
- g Q can be decreased at 680 so that fewer unit magnitude pulses m are generated when repeating Eq. 32.
- the method described above involves jointly quantizing a plurality of elements within the residual domain target vector b to produce an initial codebook candidate vector c k [i] through an iterative search process.
- the functions of flowchart 700 may be implemented within the fixed codebook candidate code-vector generator 110 , and this flowchart 700 may occur after the flowchart 400 of FIG. 4 .
- a median search based quantization method may be employed that may be more efficient. This can be an iterative process involving finding an optimum pulse configuration satisfying the pulse sum constraint for a given gain and then finding an optimum gain for the optimum pulse configuration.
- a practical example of such a median search based quantization is given in ITU-T Recommendation G.718 entitled “Frame error robust narrow-band and wideband embedded variable bit-rate coding of speech and audio from 8-32 kbit/s”, section 6.11.6.2.4, pp. 153, which is hereby incorporated by reference.
- FIG. 7 is an example illustration of a flowchart 700 outlining the operation of the coder 100 according to one embodiment.
- This method of the flowchart 700 can tend to minimize the residual domain error ⁇ g ⁇ circumflex over (b) ⁇ b ⁇ 2 .
- This flowchart 700 may occur after the flowchart 400 of FIG. 4 .
- the main parameter for the search is the sum of pulse magnitudes m.
- b d ⁇
- the initial gain g for finding the optimum vector may be given by:
- y ⁇ ( n ) round ⁇ ( b d ⁇ ( n ) g ) , ⁇ 0 ⁇ n ⁇ m , ( 37 ) is obtained.
- the resulting vector y may or may not satisfy the FPC constraint.
- the following definition is made:
- the VQ search process may optionally expand the vector at 762 and can finish at 764 with a pre-quantizer candidate c k i *.
- the intermediate vector is modified to generate a vector satisfying the FPC constraint. For example, if S y is greater than m, then at 772 S y ⁇ m pulses in y can be removed.
- One pulse is removed from y at each of the above locations, which correspond to the locations of the S y ⁇ m smallest error values. While removing a pulse at a location j, it is made sure that y j is non-zero at that location; otherwise the magnitude of the next smallest error location may be reduced.
- m ⁇ S y pulses can be added to y.
- the modification steps can ensure that the FPC constraint is satisfied for vector y.
- the optimum gain g for vector y can be recomputed as:
- b ⁇ ⁇ ( j ) ⁇ ⁇ b ⁇ ( j ) ⁇ y ⁇ ( i ) ; j ⁇ I b , i ⁇ ⁇ 0 , ... ⁇ , m - 1 ⁇ 0 ; otherwise , ⁇ ⁇ 0 ⁇ j ⁇ L . ( 43 )
- FIG. 8 is an example illustration of a flowchart 800 outlining the operation of the coder 100 according to one embodiment.
- FIG. 8 iterates pulse repositioning until a predetermined condition is met.
- the search process may be terminated after a predetermined number of iterations have been performed.
- this method can tend to minimize the residual domain error ⁇ g ⁇ circumflex over (b) ⁇ b ⁇ 2 .
- VQ Vector Quantization
- the main parameter for the search can be the sum of pulse magnitudes m. If m ⁇ L, a maximum of m out of the L locations of the output vector ⁇ circumflex over (b) ⁇ will be non-zero. Moreover, if the length of the vector L is significantly greater than the sum of pulse magnitudes m, the VQ search technique may be performed on a “collapsed” vector b d from 810 , where b d can correspond to the largest of the m absolute values of b, such as described with respect to element 720 in FIG. 7 .
- the following iterative process can involve finding an optimum pulse configuration satisfying the FPC constraint for a given gain, and then finding the optimum gain for the optimum pulse configuration. As in the example above, this method also tends to minimize the residual domain error ⁇ g ⁇ circumflex over (b) ⁇ b ⁇ 2 .
- the initial gain g for finding the optimum vector b may be given by Eq. 36:
- an intermediate output vector y is obtained according to Eq. 37:
- y ⁇ ( n ) round ⁇ ( b d ⁇ ( n ) g ) , ⁇ 0 ⁇ n ⁇ m . ( 48 )
- the resulting vector y may or may not satisfy FPC constraint. To ensure that the FPC constraint is satisfied, at 825 the following definition is made per Eq. 38:
- the intermediate vector is modified to generate a vector satisfying the FPC constraint. If S Y ⁇ m, then S y ⁇ m pulses in Y are removed at 835 .
- the modification steps ensure that the FPC constraint is satisfied for vector y.
- the vector y may be further modified by adding or removing pulses.
- b ⁇ ⁇ ( j ) ⁇ ⁇ b ⁇ ( j ) ⁇ y ⁇ ( i ) ; j ⁇ I b , i ⁇ ⁇ 0 , ... ⁇ , m - 1 ⁇ 0 ; otherwise , ⁇ 0 ⁇ j ⁇ L . ( 55 )
- the median based VQ search can be based on a very efficient search methodology, other methods are possible. For example, in the above procedure, it may be possible to employ a brute force method for finding the largest or smallest elements of the error vector E y that may not have the same computational complexity benefits as the median based VQ search; however, the end result may be identical or nearly identical in terms of performance.
- the search methods in FIG. 7 and FIG. 8 may be combined to improve overall efficiency.
- the N different pre-quantizer candidates may be evaluated according to the following expression (which is based on Eq. 17):
- c k [i] can be substituted for c k , and the best candidate i* out of N candidates can be selected.
- I may be determined through brute force computation:
- y 2 [i] Hc k [i] and can be the i-th pre-quantizer candidate filtered though the zero state weighted synthesis filter 105 .
- the latter method may be used for complexity reasons, especially when the number of non-zero positions in the pre-quantizer candidate, c k [i] , is relatively high or when the different pre-quantizer candidates have very different pulse locations. In those cases, the efficient search techniques described in the prior art do not necessarily hold. The two methods given in Eqs. 57 and 58, however, are equivalent.
- a post-search may be conducted to refine the pulse positions, and/or the signs, so that the overall weighted error is reduced further.
- the post-search may be one described by Eq. 57.
- a new error metric ⁇ can be defined based on Eq. 17 as:
- ⁇ ( d 2 T ⁇ c k ) 2 c k T ⁇ ⁇ ⁇ ⁇ c k , ( 59 ) which can be maximized (per Eq. 17) to find a low error value.
- FIG. 9 is an example illustration of a flowchart 900 outlining the operation of the coder 100 according to one embodiment.
- the functions of flowchart 900 may be implemented within the FCB loop of FIG. 1 (i.e., fixed codebook 104 , zero state weighted synthesis H equivalent 105 , weighting block 141 , combiner 108 , error minimization block 107 , and output 126 ).
- the flowchart 900 shows one example of a post-search strategy that uses the above idea. For example, a pulse at each position n m can be removed one at a time, replaced by a single pulse at a time, over all possible positions 0 ⁇ n p ⁇ L, and evaluated for a low error value.
- the post-search strategy begins.
- the error metric ⁇ is initialized according to Eq. 59.
- the first (i.e., “outer”) loop is then initialized, which controls the pulses that are effectively removed from code-vector c k .
- the outer loop can run through n m positions from zero to L ⁇ 1 in the code-vector c k .
- n m can be set to zero.
- the method can determine whether the last position L ⁇ 1 has been processed. If it has, at 925 , the post-search can finish.
- the method can check whether or not a pulse exists in code-vector c k at position n m . If a pulse does not exist at position n m , then the position n m is incremented through 920 until a non-zero position in code-vector c k is found at 930 . If a non-zero position is found, n m can be incremented at 932 and the process can continue at 920 .
- the vector c m can be formed, which can be defined at 935 as:
- the method can use vector c m to initialize the value of the “addition vector” c save , which will be discussed next.
- the second (“inner”) loop is then started, which is used to determine if a particular pulse (defined by c m ) may be used somewhere else more effectively to reduce the overall error value.
- the pulse is added by way of vector c m .
- the outer loop can run through n p positions from zero to L ⁇ 1 in the code-vector c k .
- n p can be set to zero.
- the method can determine whether the last position L ⁇ 1 has been processed. If it has, at 950 , all positions have been exhausted, and the new best code-vector c k is updated as c k ⁇ c k ⁇ c m +c save and the method can return to 920 . If the last position L ⁇ 1 has not been processed, at 955 , the method can define the pulses c p to add to vector c m as:
- n p can be the position defined by the inner loop.
- n p can be incremented.
- ⁇ ′ ( d 2 T ⁇ c k - d 2 T ⁇ c m + d 2 T ⁇ c p ) 2 c k T ⁇ ⁇ ⁇ ⁇ c k + c m T ⁇ ⁇ ⁇ ⁇ c m - 2 ⁇ c k T ⁇ ⁇ ⁇ ⁇ c m + c p T ⁇ ⁇ ⁇ ⁇ c p - 2 ⁇ ⁇ c m T ⁇ ⁇ ⁇ ⁇ c p + 2 ⁇ c k T ⁇ ⁇ ⁇ ⁇ c p . ( 63 ) As defined for this example, since c m and c p contain only one unit magnitude pulse each, then Eq. 63 can be rewritten as:
- ⁇ ′ ( d 2 T ⁇ c k - d 2 ⁇ ( n m ) + d 2 ⁇ ( n p ) ) 2 c k T ⁇ ⁇ ⁇ ⁇ c k + ⁇ ⁇ ( n m , n m ) - 2 ⁇ c k T ⁇ ⁇ ⁇ ( n m ) + ⁇ ⁇ ( n p , n p ) - 2 ⁇ ⁇ ⁇ ( n m , n p ) + 2 ⁇ c k T ⁇ ⁇ ⁇ ( n p ) ( 64 ) where n p and n m are the positions of the single pulses within c p and c m , respectively, and where ⁇ (n p ) and ⁇ (n m ) are the respective n p and n m -th column vectors of the correlation matrix ⁇ .
- ⁇ ′ ( d 2 T ⁇ c k ⁇ Initialization - d 2 ⁇ ( n m ) ⁇ OuterLoop + d 2 ⁇ ( n p ) ⁇ InnerLoop ) 2 c k T ⁇ ⁇ ⁇ ⁇ c k ⁇ Initialization - 2 ⁇ c k T ⁇ ⁇ ⁇ ( n m ) + ⁇ ⁇ ( n m , n m ) ⁇ OuterLoop + 2 ⁇ c k T ⁇ ⁇ ⁇ ( n p ) + ⁇ ⁇ ( n p , n p ) - 2 ⁇ ⁇ ⁇ ( n m , n p ) InnerLoop .
- both the inner and outer loops still contain vector terms in the denominator.
- these terms can be pre-computed and stored in arrays, and then updated as code-vector c k evolves.
- ⁇ ′ ( d 2 T ⁇ c k ⁇ Initialization - d 2 ⁇ ( n m ) ⁇ OuterLoop + d 2 ⁇ ( n p ) ⁇ InnerLoop ) 2 c k T ⁇ ⁇ ⁇ ⁇ c k ⁇ Initialization - s ⁇ ( n m ) + ⁇ ⁇ ( n m , n m ) ⁇ OuterLoop + s ⁇ ( n p ) + ⁇ ⁇ ( n p , n p ) - 2 ⁇ ⁇ ⁇ ( n m , n p ) ⁇ InnerLoop , ( 67 ) which now reduces all inner/outer loop to scalar operations involving indexing of pre-computed vector/matrix quantities.
- FIG. 10 is an example block diagram of a fixed codebook code-vector generator 1000 , which may be implemented within the fixed codebook candidate code-vector generator 110 from FIG. 1 , according to one embodiment.
- the fixed codebook candidate code-vector generator 1000 can perform the operations of the methods disclosed above with respect to FIGS. 6 , 7 , 8 , and 9 .
- the fixed codebook candidate code-vector generator 1000 can include an inverse weighting function generator 1010 , a vector quantizer 1020 , a post search 1030 , and a codeword generator 1040 .
- the fixed codebook code-vector generator 1000 can produce a final fixed codebook code-vector c k based on a code-vector c k i * from a set of candidate code-vectors c k [i] .
- the fixed codebook code-vector generator 1000 can construct the set of candidate code-vectors c k [i] , where i can be an index for the candidate code-vectors c k [i] .
- the set of candidate code-vectors c k [i] can be based on a weighted target vector x 2 and can be based on an inverse weighting function, such as ⁇ (x 2 ,i).
- the fixed codebook code-vector generator 1000 can process the weighted target vector x 2 through an inverse weighting function ⁇ (x 2 , i) to create a residual domain target vector b.
- the inverse weighting function generator 1010 can process the weighted target vector x 2 through the inverse weighting function ⁇ (x 2 , i) to create the residual domain target vector b.
- the fixed codebook code-vector generator 1000 can obtain the inverse weighting function ⁇ (x 2 , i) based on the weighted target vector x 2 .
- the residual domain target vector b may not truly be or may not only be in the residual domain as the inverse weighting function ⁇ (x 2 , i) may include different features.
- the residual domain target vector b may be an inverse weighting result, a pitch removed residual target vector, or any other target vector that results from the inverse weighting function ⁇ (x 2 , i).
- the fixed codebook code-vector generator 1000 which may be implemented in the fixed codebook candidate code-vector generator 110 of the coder 100 , can use the vector quantizer 1020 to perform a first search process on the residual domain target vector b to obtain an initial fixed codebook code-vector c k i .
- the fixed codebook candidate code-vector c k i can have a pre-determined number of unit magnitude pulses m per FIGS. 6 and 7 .
- the fixed codebook code-vector generator 1000 can perform the first search process on the residual domain target vector b for a low residual domain error to obtain the initial fixed codebook code-vector c k i .
- the coder 100 can perform the first search process by vector quantizing the residual domain target vector b to obtain the initial fixed codebook code-vector c k i , where the initial fixed codebook code-vector c k i can include a pre-determined number m of unit magnitude pulses.
- the coder 100 can perform a first search process, or vector quantize, the residual domain target vector b according to the processes illustrated in flowcharts 600 , 700 , or 800 and according to other processes disclosed in the above embodiments.
- the fixed codebook code-vector generator 1000 can vector quantize the residual domain target vector, or otherwise search to obtain an initial fixed codebook candidate code-vector c k i *, where the quantization error can be evaluated in the residual domain.
- the initial fixed codebook candidate code-vector c k i * can include a pre-determined number of unit magnitude pulses m.
- the vector quantizer 1020 can vector quantize the residual domain target vector b to obtain the initial fixed codebook code-vector c k i *.
- the vector quantizer 1020 can use the methods illustrated in the flowcharts 600 , 700 , and 800 and other methods to vector quantize the residual domain target vector b.
- Vector quantizing can include jointly quantizing two or more elements of the residual domain target vector b to obtain the initial fixed codebook code-vector c k i .
- Vector quantization or the first search can include rounding a gain term applied to vector elements of the inverse weighting function to select a gain term such that a total number of unit amplitude pulses in the fixed codebook code-vector can equal a given number.
- Vector quantization or the first search can include performing a median search quantization including finding an optimum pulse configuration satisfying a pulse sum constraint for a given gain and finding an optimum gain for the optimum pulse configuration.
- Vector quantization or the first search can include using a factorial pulse coded codebook to determine the fixed codebook code-vector.
- Vector quantization or the first search can also include any other method of vector quantization.
- the fixed codebook code-vector generator 1000 can use the post search 1030 implementing flowchart 900 to perform a second search process over a subset of possible codebook code-vectors for a low weighted-domain error to produce a final fixed codebook code-vector c k .
- the final fixed codebook code-vector c k can have a different number of pulses than the initial fixed codebook code-vector c k i .
- the subset of possible codebook code-vectors can be based on the initial fixed codebook code-vector c k i .
- the fixed codebook code-vector generator 1000 can perform the second search process by iterating the initial fixed codebook code-vector c k i through a zero state weighted synthesis filter equivalent 105 using a fixed codebook a plurality of times and by evaluating at least one error value associated with each iteration of the initial fixed codebook code-vector c k i from the plurality of times to produce a final fixed codebook code-vector c k based on an initial fixed codebook code-vector with a low error value.
- the second search process can include using a factorial pulse coded codebook to determine the final fixed codebook code-vector c k .
- the second search process can also include the process illustrated in the flowchart 900 or can include other processes disclosed in the above embodiments.
- the fixed codebook code-vector generator 1000 can perform a post search on the fixed codebook candidate code-vector c k i to determine a final fixed codebook candidate code-vector c k .
- the vector quantizer 1020 can perform a first search process on the residual domain target vector b for low residual domain error to obtain an initial fixed codebook code-vector c k i .
- the first search process can be based on the processes illustrated in FIGS. 6-8 or based on any other search process that can obtain an initial fixed codebook code-vector.
- the post search 1030 can perform a second search process, such as the post search process of FIG.
- the post search 1030 can determine a final fixed codebook candidate code-vector c k from the second search process.
- the second search process can be based on the process illustrated in FIG. 9 or can be based on any other search process that can obtain a final fixed codebook candidate code-vector.
- the codeword generator 1040 can generate a codeword k representative of the final fixed codebook code-vector c k .
- the codeword k can be used by a decoder to generate an approximation ⁇ (n) of the input signal s(n).
- the fixed codebook code-vector generator 1000 can vector quantize the residual domain target vector b to obtain an initial fixed codebook code-vector c k i *.
- the initial fixed codebook code-vector c k i * can have a pre-determined number of unit magnitude pulses m.
- the fixed codebook code-vector generator 1000 can search a subset of possible codebook code-vectors based on the initial fixed codebook code-vector c k i * for a low weighted-domain error to produce a final fixed codebook code-vector c k .
- the final fixed codebook code-vector c k can have a different number of pulses than the initial fixed codebook code-vector c k i *.
- target vector generator 124 of FIG. 1 can produce a weighted target vector x 2 from the input signal s(n).
- the fixed codebook candidate code-vector generator 1000 can process the weighted target vector x 2 through an inverse weighting function ⁇ (x 2 ,i) to create a residual domain target vector b.
- the fixed codebook candidate code-vector generator 1000 can perform a first search process on the residual domain target vector b for a low residual domain error to obtain an initial fixed codebook code-vector c k i *.
- the fixed codebook candidate code-vector generator 1000 can perform a second search process over a subset of possible codebook code-vectors for a low weighted-domain error to produce a final fixed codebook code-vector c k i .
- the subset of possible codebook code-vectors can be based on the initial fixed codebook code-vector c k i *.
- the vector quantizer 1020 can perform the first search process according to the processes illustrated in FIGS. 6-8 and the post search 1030 can perform the second search processes according to the process illustrated in FIG. 9 .
- the fixed codebook candidate code-vector generator 1000 can process the target vector x 2 through a plurality of inverse weighting functions ⁇ (x 2 , i) to create N residual domain target vectors b.
- the fixed codebook candidate code-vector generator 1000 can vector quantize the plurality of residual domain target vectors b to obtain a plurality of initial fixed codebook code-vectors c k i *, wherein each initial fixed codebook code-vector c k i * can have a pre-determined number of unit magnitude pulses m.
- the fixed codebook candidate code-vector generator 1000 can evaluate an error value ⁇ associated with each initial fixed codebook code-vector c k i * to produce a final fixed codebook code-vector c k .
- the fixed codebook candidate code-vector generator 1000 can vector quantize the residual domain target vector b to obtain an initial fixed codebook code-vector c k i .
- the initial fixed codebook code-vector c k i can have a predetermined number of unit magnitude pulses m.
- the fixed codebook candidate code-vector generator 1000 can iterate the initial fixed codebook code-vector c k i using a fixed codebook through a zero state weighted synthesis filter a plurality of times, such as discussed with respect to FIG. 9 .
- the fixed codebook candidate code-vector generator 1000 evaluates at least one error value associated with each iteration of the initial fixed codebook code-vector c k i from the plurality of times to produce a final fixed codebook code-vector c k based on an initial fixed codebook code-vector c k i with a low error value.
- FIG. 11 is an example illustration of a flowchart 1100 outlining the operation of a coder, such as the coder 100 , according to one embodiment.
- Elements 1120 , 1130 , and 1140 of the flowchart 1100 can illustrate operations of the fixed codebook code-vector generator 1000 from FIG. 10 , which may be implemented using the fixed codebook candidate code-vector generator 110 and the FCB loop (i.e., fixed codebook 104 , zero state weighted synthesis H equivalent 105 , weighting block 141 , combiner 108 , error minimization block 107 , and output 126 ) from FIG. 1 .
- the FCB loop i.e., fixed codebook 104 , zero state weighted synthesis H equivalent 105 , weighting block 141 , combiner 108 , error minimization block 107 , and output 126
- the target vector generator 124 of the coder 100 can produce a weighted target vector x 2 from an input signal s(n).
- the fixed codebook code-vector generator 1000 within the fixed codebook candidate code-vector generator 110 of the coder 100 can process weighted the target vector x 2 through an inverse weighting function ⁇ (x 2 , i) to create a residual domain target vector b.
- the coder 100 can obtain an inverse weighting function based on the weighted target vector x 2 to process the weighted target vector through the obtained inverse weighting function to create the residual domain target vector. See FIG. 2 and accompanying text.
- the fixed codebook code-vector generator 1000 within the fixed codebook candidate code-vector generator 110 of the coder 100 can perform a first search process on the residual domain target vector b to obtain an initial fixed codebook code-vector c k i . See FIGS. 6 , 7 , and 8 and accompanying text.
- the fixed codebook candidate code-vector c k i can have a pre-determined number of unit magnitude pulses m.
- the coder 100 can perform the first search process on the residual domain target vector b for a low residual domain error to obtain the initial fixed codebook code-vector c k i .
- the coder 100 can perform the first search process by vector quantizing the residual domain target vector b to obtain the initial fixed codebook code-vector c k i , where the initial fixed codebook code-vector c k i can include a pre-determined number of unit magnitude pulses.
- the coder 100 can perform a first search process or vector quantize the residual domain target vector b according to the processes illustrated in flowcharts 600 , 700 , or 800 and according to other processes disclosed in the above embodiments.
- the first search process can include rounding a gain term applied to vector elements of the inverse weighting function to select a gain term such that a total number of unit amplitude pulses in the initial fixed codebook code-vector equals a given number.
- the first search process can include performing a median search quantization including finding an optimum pulse configuration satisfying a pulse sum constraint for a given gain and including finding an optimum gain for the optimum pulse configuration.
- the first search process can also include any other search or vector quantization process that obtains an initial fixed codebook code-vector.
- the FCB loop (i.e., fixed codebook 104 , zero state weighted synthesis H equivalent 105 , weighting block 141 , combiner 108 , error minimization block 107 , and output 126 ) of the coder 100 can perform a second search process using flowchart 900 over a subset of possible codebook code-vectors based on the initial fixed codebook code-vector c k i to look for a low weighted-domain error and produce a final fixed codebook code-vector c k .
- the final fixed codebook code-vector c k can have a different number of pulses than the initial fixed codebook code-vector c k i .
- the subset of possible codebook code-vectors can be based on the initial fixed codebook code-vector c k i .
- the coder 100 can perform the second search process by iterating the initial fixed codebook code-vector c k i through a zero state weighted synthesis filter equivalent using a fixed codebook a plurality of times and by evaluating at least one error value associated with each iteration of the initial fixed codebook code-vector c k i from the plurality of times to produce a final fixed codebook code-vector c k based on an initial fixed codebook code-vector with a low error value.
- the second search process can include using a factorial pulse coded codebook to determine the final fixed codebook code-vector c k .
- the second search process can also include the process illustrated in the flowchart 900 or can include other processes disclosed in the above embodiments.
- squared error minimization/parameter quantization block 107 of the coder 100 can generate an output 126 with a codeword k representative of the final fixed codebook code-vector c k .
- the coder 100 can output the codeword by at least one of: transmitting the codeword and storing the codeword.
- the codeword k can be used by a decoder to generate an approximation of the input signal s(n).
- the coder 100 can process, at 1120 , the target vector x 2 through a plurality of inverse weighting functions ⁇ (x 2 , i) to create a plurality of residual domain target vectors b.
- the coder 100 can perform, at 1130 , the first search process on the plurality of residual domain target vectors b to obtain a plurality of initial fixed codebook code-vectors c k i where each initial fixed codebook code-vector c k i can include a pre-determined number of unit magnitude pulses.
- the coder 100 can perform the second search process over a subset of possible codebook code-vectors for a low weighted-domain error based on an error value ⁇ associated with each initial fixed codebook code-vector of the subset of possible codebook code-vectors to produce a final fixed codebook code-vector c k .
- the subset of possible codebook code-vectors is based on the plurality of initial fixed codebook code-vectors c k i .
- the flowchart 1100 can also incorporate other features and processes described in other embodiments, such performed by the codebook candidate code-vector generator 1000 .
- relational terms such as “top,” “bottom,” “front,” “back,” “horizontal,” “vertical,” and the like may be used solely to distinguish a spatial orientation of elements relative to each other and without necessarily implying a spatial orientation relative to any other physical coordinate system.
- the terms “comprises,” “comprising,” or any other variation thereof, are intended to cover a non-exclusive inclusion, such that a process, method, article, or apparatus that comprises a list of elements does not include only those elements but may include other elements not expressly listed or inherent to such process, method, article, or apparatus.
- An element proceeded by “a,” “an,” or the like does not, without more constraints, preclude the existence of additional identical elements in the process, method, article, or apparatus that comprises the element.
- the term “another” is defined as at least a second or more.
- the terms “including,” “having,” and the like, as used herein, are defined as “comprising.”
Abstract
Description
E(z)=W(z)(S(z)(S(z)−Ŝ(z)) (1)
E(z)=S w(z)−H(z)(βC τ(z)+γC k(z)) (3)
e=s w −H(βc τ +γc k)−h zir, (4)
-
- H is the L×L zero-state weighted synthesis convolution matrix formed from an impulse response of a weighted synthesis filter h(n), such as
synthesis filters
- H is the L×L zero-state weighted synthesis convolution matrix formed from an impulse response of a weighted synthesis filter h(n), such as
-
- hzir is a L×1 zero-input response of H(z) that is due to a state from a previous speech input subframe,
- sw is the L×1 perceptually weighted input signal,
- β is the scalar adaptive codebook (ACB) gain,
- cτ is the L×1 ACB code-vector indicated by index τ,
- γ is the scalar fixed codebook (FCB) gain, and
- ck is the L×1 FCB code-vector indicated by index k.
e=x w −βHc τ −γHc k (6)
ε=∥e∥ 2 =∥x w −βHc τ −γHc k∥2 (7)
Note that ∥e∥2 may also be written as ∥e∥2=Σn=0 L-1e2(n) or ∥e∥2=eTe, where eT is the vector transpose of e, and is presumed to be a column vector.
ε=∥x w −βHc τ∥2 =x x T x w−2βx w T Hc τ+β2 c τ T H T Hc τ (8)
where τ* is an optimal ACB index parameter, that is, an ACB index parameter that minimizes the bracketed expression. Typically, τ is a parameter related to a range of expected values of the pitch lag (or fundamental frequency) of the input signal, and is constrained to a limited set of values that can be represented by a relatively small number of bits. Since xw is not dependent on τ, Equation 11 can be rewritten as follows:
and likewise, Equation 10 can be simplified to:
ε=∥2 −γHc k∥2, (15)
where γHck is a filtered and weighted version of FCB code-vector ck, that is, FCB code-vector ck filtered by zero state weighted synthesis filter Hzs(z) 1405 and then weighted based on FCB
where k* is an optimal FCB index parameter, that is, an FCB index parameter that maximizes the bracketed expression. By grouping terms that are not dependent on k, that is, by letting d2 T=x2 TH and Φ=HTH, Equation 16 can be simplified to:
in which the optimal FCB gain γ is given as:
described below, or can be other inverse weighting functions described below. Additionally, the
ε=∥x 2 −γHc k∥2, (19)
if the FCB code-vector is given as:
then the error ε can tend to zero and the input signal s(n) and a corresponding coded output signal ŝ(n) can be identical. Since this is not practical for low rate speech coding systems, only a crude approximation of Eq. 20 is typically generated. U.S. Pat. No. 5,754,976 to Adoul, hereby incorporated by reference, discloses one example of the usage of the inverse filtered target signal r=H−1x2 as a method for low bit rate pre-selection of the pulse amplitudes of the code-vector ck.
where QP{ } is a P-bit quantization operator, does not generally lead to the global minimum weighted error since the error due to QP{ } is a residual domain error. In order to achieve the lowest possible error in the weighted synthesis domain, many iterations of ck may be necessary to minimize the error ε of Eq. 19. Various embodiments of the present disclosure described below can address this problem by reducing the iterations and by reducing the residual domain error.
c k [i] =Q P{ƒ(x 2 ,i)}, 0≦i<N, (22)
where ƒ(x2,i) can be some function of the target vector, and N can be the number of pre-quantizer candidates. This expression can be a generalized form for generating a plurality of pre-quantizer candidates that can be assessed for error in the weighted domain. An example of such a function is given as:
where r=H−1x2 is the inverse filtered target signal, d2=HTx2 is the backward filtered target as calculated/defined in Eq. 17, and ai and bi are a set of respective weighting coefficients for iteration i. Here, ∥r∥ can be a norm of the residual domain vector r, such as the inverse filtered target vector r, given by ∥r∥=√{square root over (rTr)}, and likewise ∥d2∥=√{square root over (d2 Td2)}. The effect of coefficients ai and bi, can be to produce a weighted sum of the inverse and backward filtered target vectors, which can then form the set of pre-quantizer candidate vectors.
where candidates can have a linear distribution of values over a given range. As an example, if N=4, the sets of coefficients can be: ai ε{1.0, 0.667, 0.333, 0.0}, and bi ε{0.0, 0.333, 0.667, 1.0}. Another example may incorporate the results of a training algorithm, such as the Linde-Buzo-Gray (or LBG) algorithm, where many values of a and b can be evaluated offline using a training database, and then choosing a, and b, based on the statistical distributions. Such methods for training are well known in the art. Other functions can also be possible. For example, the following function may be found to be beneficial for certain classes of signals:
ƒ(x 2 ,i)=a i r+b i r lpf, (25)
where rlpf can be a low pass filtered version of r. Alternatively, the LPF characteristic may be altered as a function of i:
ƒ(x 2 ,i)=B i r, (26)
where Bi may be a class of linear phase filtering characteristics intended to shape the residual domain quantization error in a way that more closely resembles that of the error in the weighted domain. Yet another method may involve specifying a family of inverse perceptual weighting functions that may also shape the error in a way that is beneficial in shaping the residual domain error:
ƒ(x 2 ,i)=H −1 x 2, (27)
where the round( ) operator rounds the respective vector elements of gQƒ(x2,i) to the nearest integer value, where n represents the n-th element of vector ck [i], and m is the total number of unit magnitude pulses. This expression describes a process of selecting gQ such that the total number of unit amplitude pulses in ck [i] equals m.
where Φ′=Φ−yyT and where y can be a scaled backward filtered ACB excitation. Now i* may be determined through brute force computation:
where y2 [i]=Hck [i] can be the i-th pre-quantizer candidate filtered though the zero state
or other weighting described above.
where m can be the total or desired number of unit magnitude pulses, L can be the vector length, and b(n) can be the nth element of the residual domain target vector b. At 630, an iterative search process can begin by which the gain value gQ can be varied to produce a pre-quantizer candidate ck [i] that can contain the appropriate number of unit magnitude pulses m, the positions of which correspond to a low residual domain error, i.e., ∥gQck [i]−b∥2 can be a minimum. Given the initialization above, ck [i] can be generated according to:
If it is determined at 640 and 650 that the above operation results in the number of unit amplitude pulses in ck [i] being m, that is:
then at 660 the process is complete. Otherwise, the gain value gQ is appropriately altered and the process is repeated. For example, if it is determined at 650 that the result is
then gQ can be increased at 670 so that fewer unit magnitude pulses m are generated when repeating Eq. 32. Likewise, if it is determined at 640 that
then gQ can be decreased at 680 so that fewer unit magnitude pulses m are generated when repeating Eq. 32.
b d ={|b(n)|:|b(n)|≧m d ,b(n)εb} (34)
is therefore an m-dimensional vector whose elements are the m largest magnitude elements of vector b. The index and signs of components of b which form bd are stored as Ib and σb. Otherwise, the vector may simply be defined as:
b d =|b|, (35)
where the signs of b may be stored in σb.
where bd (n) can be the nth element of vector bd. At 740, to obtain the optimum vector satisfying the Factorial Pulse Coding (FPC) constraint (i.e., the sum of integral valued pulse magnitudes within a vector is a constant), for a given gain g, first an intermediate output vector y given by
is obtained. The resulting vector y may or may not satisfy the FPC constraint. At 750, to ensure that the FPC constraint is satisfied, the following definition is made:
E y =b d −gy. (39)
j={n:e y(n)≦medianl(E y ,S y −m)}, (40)
where Ey={ey(0), ey(1), . . . , ey(m−1)}. One pulse is removed from y at each of the above locations, which correspond to the locations of the Sy−m smallest error values. While removing a pulse at a location j, it is made sure that yj is non-zero at that location; otherwise the magnitude of the next smallest error location may be reduced.
j={n:e y(n)≧medianh(E y ,m−S y)}, (41)
which can correspond to the locations of the m−Sy largest error values. The modification steps can ensure that the FPC constraint is satisfied for vector y. At 780, the optimum gain g for vector y can be recomputed as:
and the
In the case where the number of pulses m is not significantly more than the vector length L, the above expression may simply be:
{circumflex over (b)}(j)=σb(j)y(j);0≦j<L (44)
medianh(E,k)=max(m d):
and
medianl(E,k)=min(m d):
where
where bb(n) is the nth element of vector bd.
The resulting vector y may or may not satisfy FPC constraint. To ensure that the FPC constraint is satisfied, at 825 the following definition is made per Eq. 38:
and the following error vector is generated of the form of Eq. 39:
E y =b d −gy (50)
j={n:e y(n)≦medianl(E y ,S y −m)}, (51)
where Ey={ey(0), ey(1), . . . , ey(m−1)}. One pulse can be removed from y at each of the above locations, which correspond to the locations of the Sy−m smallest error values. While removing a pulse at a location j, it is made sure that yj is non-zero at that location, otherwise the magnitude of the next smallest error location may be reduced. If, on the other hand, Sy<m, then m−Sy pulses can be added to y at 840. The location of these pulses can be obtained from Eq. 41 as:
j={n:e y(n)≧medianh(E y ,m−S y)}, (52)
which correspond to the locations of the m-Sy largest error values. The modification steps ensure that the FPC constraint is satisfied for vector y.
and the
j={n:e y(n)=m l}, (54)
where vector Ey is calculated in Eq. 50 and ml is the lower median calculated in Eq. 46. The vector b can be optionally expanded at 855. At 860, the intermediate output vector can then be used to form the L dimension output vector ck [i]={circumflex over (b)} by remapping y using the indexes Ib and signs σb. That is, like Eq. 43:
{circumflex over (b)}(j)=σb(j)y(j);0≦j<L. (56)
where ck [i] can be substituted for ck, and the best candidate i* out of N candidates can be selected. Alternatively, I may be determined through brute force computation:
where y2 [i]=Hck [i] and can be the i-th pre-quantizer candidate filtered though the zero state
which can be maximized (per Eq. 17) to find a low error value. During the post-search, ck can be iterated by defining a vector containing a single pulse cm that is subtracted from ck, and defining another vector cp containing a single pulse that is added back in at a different location. This can be expressed as c′k=ck−cm+cp. If this expression is plugged into Eq. 59, a second error metric ε′ can be defined as:
where sgn(ck(n)) can be the signum function (+1 or −1) of the respective vector element of code-vector ck. At 940, the method can use vector cm to initialize the value of the “addition vector” csave, which will be discussed next. The second (“inner”) loop is then started, which is used to determine if a particular pulse (defined by cm) may be used somewhere else more effectively to reduce the overall error value. As such, the pulse is added by way of vector cm. The outer loop can run through np positions from zero to L−1 in the code-vector ck. At 917, np can be set to zero. At 945, the method can determine whether the last position L−1 has been processed. If it has, at 950, all positions have been exhausted, and the new best code-vector ck is updated as ck←ck−cm+csave and the method can return to 920. If the last position L−1 has not been processed, at 955, the method can define the pulses cp to add to vector cm as:
where np can be the position defined by the inner loop. At 960, the second error metric ε′ can be calculated for the modified code-vector c′k=ck−cm+cp according to Eq. 60. At 965, if the second error metric produces a better result than the original, i.e., ε′>ε, then at 970 the new “best” error metric is saved, along with the new “best” position vector csave, such as the pulse location cp. At 975, np can be incremented.
As defined for this example, since cm and cp contain only one unit magnitude pulse each, then Eq. 63 can be rewritten as:
where np and nm are the positions of the single pulses within cp and cm, respectively, and where Φ(np) and Φ(nm) are the respective np and nm-th column vectors of the correlation matrix Φ. (Recall from the Background that Φ=HTH, which supports the zero state weighted synthesis H equivalency.) Now looking at where in the process each of the terms can be generated, the following expression, after some rearrangement of terms, shows how most of terms in the inner loop have relatively low complexity, using just a few scalar operations:
However, both the inner and outer loops still contain vector terms in the denominator. As another example, these terms can be pre-computed and stored in arrays, and then updated as code-vector ck evolves. For example, a temporary storage vector s can be defined as:
s(n)=2c k TΦ(n),0≦n<L, (66)
which can then be indexed (as a lookup table) during the inner/outer loop processing. This can then be applied to Eq. 65 to yield:
which now reduces all inner/outer loop to scalar operations involving indexing of pre-computed vector/matrix quantities.
Claims (20)
Priority Applications (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/667,001 US9263053B2 (en) | 2012-04-04 | 2012-11-02 | Method and apparatus for generating a candidate code-vector to code an informational signal |
PCT/US2013/067185 WO2014070700A1 (en) | 2012-11-02 | 2013-10-29 | Method and apparatus for generating a candidate code-vector to code an informational signal |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/439,121 US9070356B2 (en) | 2012-04-04 | 2012-04-04 | Method and apparatus for generating a candidate code-vector to code an informational signal |
US13/667,001 US9263053B2 (en) | 2012-04-04 | 2012-11-02 | Method and apparatus for generating a candidate code-vector to code an informational signal |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/439,121 Continuation US9070356B2 (en) | 2012-04-04 | 2012-04-04 | Method and apparatus for generating a candidate code-vector to code an informational signal |
Publications (2)
Publication Number | Publication Date |
---|---|
US20140129214A1 US20140129214A1 (en) | 2014-05-08 |
US9263053B2 true US9263053B2 (en) | 2016-02-16 |
Family
ID=49551821
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/667,001 Active 2033-05-16 US9263053B2 (en) | 2012-04-04 | 2012-11-02 | Method and apparatus for generating a candidate code-vector to code an informational signal |
Country Status (2)
Country | Link |
---|---|
US (1) | US9263053B2 (en) |
WO (1) | WO2014070700A1 (en) |
Cited By (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20150317362A1 (en) * | 2012-12-12 | 2015-11-05 | Nec Corporation | Database search device, database search method, and program |
Families Citing this family (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
KR101958939B1 (en) * | 2017-03-30 | 2019-03-15 | 오드컨셉 주식회사 | Method for encoding based on mixture of vector quantization and nearest neighbor search using thereof |
Citations (16)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5495555A (en) * | 1992-06-01 | 1996-02-27 | Hughes Aircraft Company | High quality low bit rate celp-based speech codec |
WO1997030525A1 (en) | 1996-02-15 | 1997-08-21 | Philips Electronics N.V. | Reduced complexity signal transmission system |
US5664055A (en) * | 1995-06-07 | 1997-09-02 | Lucent Technologies Inc. | CS-ACELP speech compression system with adaptive pitch prediction filter gain based on a measure of periodicity |
US5754976A (en) | 1990-02-23 | 1998-05-19 | Universite De Sherbrooke | Algebraic codebook with signal-selected pulse amplitude/position combinations for fast coding of speech |
US6104992A (en) * | 1998-08-24 | 2000-08-15 | Conexant Systems, Inc. | Adaptive gain reduction to produce fixed codebook target signal |
US6236960B1 (en) | 1999-08-06 | 2001-05-22 | Motorola, Inc. | Factorial packing method and apparatus for information coding |
US6493665B1 (en) * | 1998-08-24 | 2002-12-10 | Conexant Systems, Inc. | Speech classification and parameter weighting used in codebook search |
US20030097258A1 (en) * | 1998-08-24 | 2003-05-22 | Conexant System, Inc. | Low complexity random codebook structure |
US6807524B1 (en) * | 1998-10-27 | 2004-10-19 | Voiceage Corporation | Perceptual weighting device and method for efficient coding of wideband signals |
US20040260542A1 (en) * | 2000-04-24 | 2004-12-23 | Ananthapadmanabhan Arasanipalai K. | Method and apparatus for predictively quantizing voiced speech with substraction of weighted parameters of previous frames |
US7047188B2 (en) | 2002-11-08 | 2006-05-16 | Motorola, Inc. | Method and apparatus for improvement coding of the subframe gain in a speech coding system |
US7054807B2 (en) | 2002-11-08 | 2006-05-30 | Motorola, Inc. | Optimizing encoder for efficiently determining analysis-by-synthesis codebook-related parameters |
US20080294429A1 (en) * | 1998-09-18 | 2008-11-27 | Conexant Systems, Inc. | Adaptive tilt compensation for synthesized speech |
US20100280831A1 (en) * | 2007-09-11 | 2010-11-04 | Redwan Salami | Method and Device for Fast Algebraic Codebook Search in Speech and Audio Coding |
US20120290295A1 (en) * | 2011-05-11 | 2012-11-15 | Vaclav Eksler | Transform-Domain Codebook In A Celp Coder And Decoder |
EP2648184A1 (en) | 2012-04-04 | 2013-10-09 | Motorola Mobility LLC | Method and apparatus for generating a candidate code-vector to code an informational signal |
-
2012
- 2012-11-02 US US13/667,001 patent/US9263053B2/en active Active
-
2013
- 2013-10-29 WO PCT/US2013/067185 patent/WO2014070700A1/en active Application Filing
Patent Citations (22)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5754976A (en) | 1990-02-23 | 1998-05-19 | Universite De Sherbrooke | Algebraic codebook with signal-selected pulse amplitude/position combinations for fast coding of speech |
US5495555A (en) * | 1992-06-01 | 1996-02-27 | Hughes Aircraft Company | High quality low bit rate celp-based speech codec |
US5664055A (en) * | 1995-06-07 | 1997-09-02 | Lucent Technologies Inc. | CS-ACELP speech compression system with adaptive pitch prediction filter gain based on a measure of periodicity |
WO1997030525A1 (en) | 1996-02-15 | 1997-08-21 | Philips Electronics N.V. | Reduced complexity signal transmission system |
US6104992A (en) * | 1998-08-24 | 2000-08-15 | Conexant Systems, Inc. | Adaptive gain reduction to produce fixed codebook target signal |
US6493665B1 (en) * | 1998-08-24 | 2002-12-10 | Conexant Systems, Inc. | Speech classification and parameter weighting used in codebook search |
US20030097258A1 (en) * | 1998-08-24 | 2003-05-22 | Conexant System, Inc. | Low complexity random codebook structure |
US20090182558A1 (en) * | 1998-09-18 | 2009-07-16 | Minspeed Technologies, Inc. (Newport Beach, Ca) | Selection of scalar quantixation (SQ) and vector quantization (VQ) for speech coding |
US20090157395A1 (en) * | 1998-09-18 | 2009-06-18 | Minspeed Technologies, Inc. | Adaptive codebook gain control for speech coding |
US20080294429A1 (en) * | 1998-09-18 | 2008-11-27 | Conexant Systems, Inc. | Adaptive tilt compensation for synthesized speech |
US20050108007A1 (en) * | 1998-10-27 | 2005-05-19 | Voiceage Corporation | Perceptual weighting device and method for efficient coding of wideband signals |
US6807524B1 (en) * | 1998-10-27 | 2004-10-19 | Voiceage Corporation | Perceptual weighting device and method for efficient coding of wideband signals |
US6236960B1 (en) | 1999-08-06 | 2001-05-22 | Motorola, Inc. | Factorial packing method and apparatus for information coding |
US20040260542A1 (en) * | 2000-04-24 | 2004-12-23 | Ananthapadmanabhan Arasanipalai K. | Method and apparatus for predictively quantizing voiced speech with substraction of weighted parameters of previous frames |
US20080312917A1 (en) * | 2000-04-24 | 2008-12-18 | Qualcomm Incorporated | Method and apparatus for predictively quantizing voiced speech |
US8660840B2 (en) * | 2000-04-24 | 2014-02-25 | Qualcomm Incorporated | Method and apparatus for predictively quantizing voiced speech |
US7047188B2 (en) | 2002-11-08 | 2006-05-16 | Motorola, Inc. | Method and apparatus for improvement coding of the subframe gain in a speech coding system |
US7054807B2 (en) | 2002-11-08 | 2006-05-30 | Motorola, Inc. | Optimizing encoder for efficiently determining analysis-by-synthesis codebook-related parameters |
US20100280831A1 (en) * | 2007-09-11 | 2010-11-04 | Redwan Salami | Method and Device for Fast Algebraic Codebook Search in Speech and Audio Coding |
US20120290295A1 (en) * | 2011-05-11 | 2012-11-15 | Vaclav Eksler | Transform-Domain Codebook In A Celp Coder And Decoder |
EP2648184A1 (en) | 2012-04-04 | 2013-10-09 | Motorola Mobility LLC | Method and apparatus for generating a candidate code-vector to code an informational signal |
US20130268266A1 (en) | 2012-04-04 | 2013-10-10 | Motorola Mobility, Inc. | Method and Apparatus for Generating a Candidate Code-Vector to Code an Informational Signal |
Non-Patent Citations (9)
Title |
---|
C. Laflamme et al., "On Reducing Computational Complexity of Codebook Search in CELP Coder Through the Use of the Algebraic Codes", IEEE Int'l Conf. on Acoustics, Speech and Signal Processing, Apr. 3-6, 1990, 177-80. |
European Patent Office, "Extended European Search Report" for Patent Application No. 13160603.0, Jul. 25, 2013, 9 pages. |
International Telecommunication Union, "Series G: Transmission Systems and Media, Digital Systems and Networks; Digital terminal equipments-Coding of voice and audio signals; Frame error robust narrow-band and wideband embedded variable bit-rate coding of speech and audio from 8-32kkbit/s", Recommendation ITU-T G.718, Jun. 2008, 257 pages. |
James Ooi, "Application of Wavelets to Speech Coding", Massachusetts Institute of Technology, May 1993, 128 pages. |
James P. Ashley and Udar Mittal, "Method and Apparatus for Generating a Candidate Code-Vector to Code an Information Signal", U.S. Appl. No. 13/439,121, filed Apr. 4, 2012, 38 pages. |
M. Elshafei Ahmed and M. I. Al-Suwaiyel, "Fast Methods for Code Search in CELP", IEEE Transactions on Speech and Audio Processing, Jul. 1993, pp. 315-325, vol. 1 No. 3. |
Patent Cooperation Treaty, "PCT Search Report and Written Opinion of the International Searching Authority" for International Application No. PCT/US2013/067185, Dec. 20, 2013, 9 pages. |
Udar Mittal et al., "Low Complexity Factorial Pulse Coding of MDCT Coefficients Using Approximation of Combinatorial Functions", Int'l Conf. on Acoustics, Speech, and Signal Processing, Apr. 15-20, 2007, pp. 289-292. |
W. Bastiaan Kleijn et al., "Fast Methods for CELP Speech Coding Algorithm", IEEE Transactions on Acoustics, Speech, and Signal Processing, Aug. 1990, pp. 1330-1342, vol. 38 No. 8. |
Cited By (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20150317362A1 (en) * | 2012-12-12 | 2015-11-05 | Nec Corporation | Database search device, database search method, and program |
US10339140B2 (en) * | 2012-12-12 | 2019-07-02 | Nec Corporation | Database search device, database search method, and program |
Also Published As
Publication number | Publication date |
---|---|
WO2014070700A1 (en) | 2014-05-08 |
US20140129214A1 (en) | 2014-05-08 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
RU2462769C2 (en) | Method and device to code transition frames in voice signals | |
EP0422232B1 (en) | Voice encoder | |
CN102119414B (en) | Device and method for quantizing and inverse quantizing LPC filters in a super-frame | |
US20040015346A1 (en) | Vector quantizing for lpc parameters | |
AU6397094A (en) | Vector quantizer method and apparatus | |
US8712766B2 (en) | Method and system for coding an information signal using closed loop adaptive bit allocation | |
US9070356B2 (en) | Method and apparatus for generating a candidate code-vector to code an informational signal | |
WO2009090875A1 (en) | Vector quantizer, vector inverse quantizer, and methods therefor | |
US9263053B2 (en) | Method and apparatus for generating a candidate code-vector to code an informational signal | |
CN104854656A (en) | An apparatus for encoding a speech signal employing acelp in the autocorrelation domain | |
KR100651712B1 (en) | Wideband speech coder and method thereof, and Wideband speech decoder and method thereof | |
US7337110B2 (en) | Structured VSELP codebook for low complexity search | |
US20100049508A1 (en) | Audio encoding device and audio encoding method | |
JP6195138B2 (en) | Speech coding apparatus and speech coding method | |
US20100094623A1 (en) | Encoding device and encoding method | |
JPH0854898A (en) | Voice coding device | |
US7716045B2 (en) | Method for quantifying an ultra low-rate speech coder | |
Lee et al. | KLT-based adaptive entropy-constrained quantization with universal arithmetic coding | |
Sankar et al. | Scalable low bit rate celp coder based on compressive sensing and vector quantization | |
JPH02500620A (en) | coded communication system | |
Salami et al. | A fully vector quantised self-excited vocoder | |
Gouvianakis et al. | Advances in analysis by synthesis LPC speech coders | |
JP3035960B2 (en) | Voice encoding / decoding method and apparatus | |
Bouzid et al. | Channel optimized switched split vector quantization for wideband speech LSF parameters | |
JP3984021B2 (en) | Speech / acoustic signal encoding method and electronic apparatus |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: MOTOROLA MOBILITY LLC, ILLINOISFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:ASHLEY, JAMES P;MITTAL, UDAR;REEL/FRAME:029230/0377Effective date: 20121101 |
|
AS | Assignment |
Owner name: GOOGLE TECHNOLOGY HOLDINGS LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:MOTOROLA MOBILITY LLC;REEL/FRAME:034286/0001Effective date: 20141028 |
|
AS | Assignment |
Owner name: GOOGLE TECHNOLOGY HOLDINGS LLC, CALIFORNIAFree format text: CORRECTIVE ASSIGNMENT TO CORRECT THE REMOVE INCORRECT PATENT NO. 8577046 AND REPLACE WITH CORRECT PATENT NO. 8577045 PREVIOUSLY RECORDED ON REEL 034286 FRAME 0001. ASSIGNOR(S) HEREBY CONFIRMS THE ASSIGNMENT;ASSIGNOR:MOTOROLA MOBILITY LLC;REEL/FRAME:034538/0001Effective date: 20141028 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 8TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1552); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 8 |