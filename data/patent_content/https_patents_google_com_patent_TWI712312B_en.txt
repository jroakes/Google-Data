用於影像處理器之 I/O 單元
如此項技術中已知，用於執行程式碼之基本電路結構包含一執行階段及暫存器空間。該執行階段含有用於執行指令之執行單元。用於待執行之一指令之輸入運算元係自該暫存器空間提供至該執行階段。由執行階段執行一指令而產生之結果係被回寫至暫存器空間。
在一傳統處理器上執行一軟體執行緒需要透過執行階段循序執行一系列指令。最常見的是，在自一單個輸入運算元集產生一單個結果之意義上，操作係「純量的」。然而，在「向量」處理器之情況中，藉由執行階段執行一指令將自輸入運算元集之一向量產生一結果向量。
圖1展示包含耦合至一個二維移位暫存器陣列102之一執行道陣列101之一獨特影像處理器架構100的一高階視圖。此處，該執行道陣列中之各執行道可被視為含有執行藉由該處理器100支援之指令集所需之執行單元的一離散執行階段。在各項實施例中，各執行道接收一相同指令以在一相同機器循環中執行，使得該處理器作為一個二維單指令多資料(SIMD)處理器操作。
各執行道在二維移位暫存器陣列102內之一對應位置中具有其自身專屬暫存器空間。例如，邊角執行道103在邊角移位暫存器位置104中具有其自身專屬暫存器空間，邊角執行道105在邊角移位暫存器位置106中具有其自身專屬暫存器空間等。
此外，移位暫存器陣列102能夠使其內容移位，使得各執行道能夠自其自身暫存器空間直接對在一先前機器循環期間駐存於另一執行道之暫存器空間中之一值操作。例如，一+1水平移位引起各執行道之暫存器空間自其最左相鄰者之暫存器空間接收一值。由於使值在沿著一水平軸之左右兩個方向上移位及使值在沿著一垂直軸之上下兩個方向上移位之一能力，處理器能夠有效處理影像資料之模板。
此處，如此項技術中已知，一模板係用作一基本資料單元之影像表面區域之一圖塊。例如，用於一輸出影像中之一特定像素位置之一新值可被計算為該特定像素位置在其內居中之一輸入影像之一區域中之像素值的一平均值。例如，若該模板具有3像素×3像素之一維數，則該特定像素位置可對應於3×3像素陣列之中間像素且該平均值可在該3×3像素陣列內之全部九個像素內予以計算。
根據圖1之處理器100之各種操作實施例，執行道陣列101之各執行道負責計算一輸出影像中之一特定位置之一像素值。因此，繼續上文剛剛提及之3×3模板求平均值實例，在移位暫存器內之初始載入輸入像素資料及八個移位操作之一經協調移位序列之後，執行道陣列中之各執行道將計算其對應像素位置之平均值所需之全部九個像素值接收至其本端暫存器空間中。因為圖1之處理器架構尤其擅長處理影像模板，所以其亦可被稱為一模板處理器。
圖2展示具有多個模板處理器202_1至202_N之一影像處理器201之一高階視圖。取決於整個處理器201之組態，該等模板處理器202_1至202_N之特定者直接對自一外部來源提供至該影像處理器201之輸入影像資料操作，而該等模板處理器202_1至202_N之其他者可直接對藉由該等模板處理器202_1至202_N之另一者產生之輸出影像資料操作。
如圖2中所描繪，描繪自影像處理器之I/O單元207接收輸入影像資料206之一線緩衝器單元205_1。如下文更進一步詳細描述，該I/O單元207重新格式化外部提供之輸入影像資料209以產生輸入影像資料206。在各項實施例中，該影像資料209係藉由一相機提供。一旦該線緩衝器單元205_1接收輸入影像資料206，該線緩衝器單元205_1即透過網路204將該影像資料206傳遞至模板處理器202_1至202_N之一或多者以用於處理。如上文所提及，模板處理器執行程式碼且通常使影像資料在其等各自二維移位暫存器內移位以對該影像資料之模板有效操作。
正如上文所提及，影像處理器之I/O單元207負責自該影像處理器外部之一來源(例如，一記憶體，諸如一運算系統之主記憶體、一相機等)接收輸入影像資料209且將該影像資料轉發至線緩衝器，該線緩衝器將該影像資料饋送給將處理該影像資料之模板處理器。同樣地，影像處理器之I/O單元亦負責自線緩衝器205_1至205_N (其等自一模板處理器接收輸出資料)之任一者接收輸出影像資料且將該輸出影像資料轉發至一記憶體(例如，一運算系統主記憶體)、一顯示器或將接收影像處理器之輸出影像資料之其他組件。
重要的是，影像處理器之輸入影像資料209通常經格式化為一光柵掃描，而如上文詳細描述，模板處理器202_1至202_N自行對二維影像表面或「區塊」(而非光柵掃描影像資料)操作。因而，影像處理器之I/O單元207經設計以將輸入影像資料209自一光柵掃描格式重新格式化成一區塊影像格式。接著將該經區塊影像格式化之輸入影像資料206自I/O單元207發送至線緩衝器單元205_1至205_N之一或多者。
圖3a展示光柵掃描至區塊格式化之一高階視圖。此處，邊界301對應於待處理之整個輸入影像。輸入影像資料係作為(例如)對應於跨該整個輸入影像301之一相同列之一連續序列像素302_1、302_2、302_M之一光柵掃描而接收。因此，舉例而言，在藉由影像處理器接收輸入影像之第一像素列302_1之後，接收該輸入影像之第二像素列302_2等。如圖3a中所描繪(例如)以從左至右順序接收一相同列之像素。
然而，正如上文所描述，模板處理器並不以光柵序列對輸入影像資料操作。而是，模板處理器對輸入影像之二維表面區域操作。因而，在光柵掃描輸入資料可形成一個二維表面區域或區塊以藉由一模板處理器消耗之前，需要由影像處理器接收足夠量的光柵掃描輸入資料。
更明確言之，在圖3a之描繪中，假定將處理輸入影像資料之模板處理器將處理維數為M像素×M像素之區塊。在此情況中，用以形成第一M×M區塊303之足夠輸入資料僅在第M輸入光柵列之第M像素已由I/O單元接收之後存在。即，該第一區塊303僅在已充分接收前M-1個輸入光柵列之後的某個時間實現。
一旦已接收第一區塊303，即可將該第一區塊303轉發至一線緩衝器單元以藉由一模板處理器處理。參考圖3b，在已藉由I/O單元接收第M輸入光柵列302_M之接下來M個(總共2M個)像素之後，實現第二全區塊304且可將其轉發至線緩衝器單元。該程序接著重複使得經接收之光柵掃描輸入資料之各接下來M個像素完成形成可被轉發至線緩衝器單元之下一M×M表面。更明確言之，在已接收第M光柵掃描列302_M之最後區塊之後，可在接收第2M光柵掃描列期間形成下一組區塊。
返回參考圖2，在各項實施例中，I/O單元207包含一共用儲存集區(SSP) 210及用以執行上述光柵至區塊重新格式化之格式轉換邏輯(FCL) 211。如將自緊接著的論述更清楚瞭解，該共用儲存集區210係(例如)將輸入光柵像素作為許多(例如)相同大小之資料片段儲存之一記憶體電路。在各項實施例中，一片段係一或多個像素之一群組。儘管在下文描述之實施例中，片段具有相等大小，然在替代實施例中，片段可為可變大小。該格式轉換邏輯211追蹤輸入資料片段213在集區內之儲存之進展，且在認識到下一影像資料區塊已儲存於該集區中之後，自集區214讀出正確片段以形成一區塊供一模板處理器消耗。
圖4a至圖4k係關於I/O單元之重新格式化操作之一更詳細說明。圖4a展示對應於待處理之一輸入影像之一區段之一圖框401。為了舉例說明，假定待處理之該輸入影像具有16個像素之一寬度且將對該輸入影像操作之(若干)模板處理器將處理4像素×4像素之區塊影像。應注意，此等輸入影像及區塊維數僅係例示性的(此等參數之實際維數通常較大)。
圖框401內之內容具有雙重含義。根據一第一觀點，圖框401之該等內容展示共用片段集區210內之輸入像素資料之經儲存片段。根據一第二觀點，圖框401之該等內容展示藉由格式轉換邏輯211內之暫存器空間212保存之經組織指標值，其中各指標值指向其中將一片段儲存於共用儲存集區210中之在該共用儲存集區210中之一特定位置。圖框401之內容之雙重含義將自以下論述更清楚瞭解。
參考圖4a，輸入影像之第一光柵掃描列之前四個像素P1至P4之一第一片段係作為一第一片段儲存於共用儲存集區210中。格式轉換邏輯211亦將指向該第一片段儲存於共用儲存集區中之處(例如，其之記憶體位址)之一指標值PTR_1保存於其暫存器空間212中。
圖4b至圖4d展示以下時間序列，其中針對輸入影像之光柵掃描之第一列接收第二片段、第三片段及第四片段相當(worth of)的輸入像素。即，像素P5至P8對應於儲存於轉換邏輯之暫存器空間212中之藉由PTR_2識別之一位置處的一第二片段之相當像素，像素P9至P12對應於儲存於轉換邏輯之暫存器空間212中之藉由PTR_3識別之一位置處的一第三片段之相當像素，且像素P13至P16對應於儲存於轉換邏輯之暫存器空間212中之藉由PTR_4識別之一位置處的一第四片段之相當像素。
回顧輸入影像具有16像素之一列寬，應注意如圖4d之狀態，輸入影像之光柵掃描之第一全列已儲存於共用儲存集區210中。圖4e展示在已完全接收輸入影像之光柵掃描之第二列之後的共用儲存集區210及重新格式化邏輯之暫存器空間212之狀態。此處，應注意已在共用儲存集區210中消耗針對像素P17至P32之四個額外片段之相當像素。同樣地，分別指向共用儲存集區210中之此等新片段之四個新指標值PTR_5至PTR_8係保存於格式化邏輯之暫存器空間212中。
圖4f展示在已完全接收輸入影像之光柵掃描之第三列之後的共用儲存集區210及重新格式化邏輯之暫存器空間212之狀態。又，已在共用儲存集區210中消耗針對像素P33至P48之另外四個額外片段之相當像素。同樣地，分別指向共用儲存集區210中之此等新片段之四個新指標值PTR_9至PTR_12係保存於格式化邏輯之暫存器空間212中。
圖4g展示在已將輸入影像之光柵掃描之第四列之第一片段儲存於共用儲存集區210中且已更新重新格式化邏輯之暫存器空間212以包含指向此片段之一指標值PTR_13之後的共用儲存集區210及重新格式化邏輯之暫存器空間212之狀態。重要的是，在儲存輸入影像資料之第四列之第一片段的情況下，共用儲存集區210現保存可藉由一模板處理器操作之第一全區塊影像(藉由陰影區域402突顯)。
在重新格式化邏輯211認識到將指標PTR_13新增至其暫存器空間212中對應於第一區塊影像402之儲存的情況下，該重新格式化邏輯211繼續進行以自共用儲存集區210讀取指標PTR_1、PTR_5、PTR_9及PTR_13之內容。即，藉由重新格式化邏輯211自共用儲存集區210讀取圖框401之第一行(其對應於陰影區域402)之內容且將該等內容轉發至線緩衝器單元，該線緩衝器單元將該等內容饋送給將對輸入影像資料處理之一或多個模板處理器。與自儲存集區210讀取第一區塊影像之內容相應，亦將來自輸入光柵掃描之下一(第二)片段之相當影像資料(像素P53至P56)儲存於共用儲存集區210中。
圖4h展示其中第一區塊之內容適於藉由新輸入資料覆寫之系統之狀態。即，第一全區塊402之指標(指標PTR_1、PTR_5、PTR_9及PTR_13)已返回至共用儲存集區210或以其他方式被識別至該共用儲存集區210，使得該共用儲存集區瞭解到該等指標之內容已藉由重新格式化程序消耗且空閒以待覆寫。在一項實施例中，該等指標進入藉由共用儲存集區210之邏輯電路維持之一空閒列表。作為儲存輸入影像資料之一最新接收片段之程序之部分，共用儲存集區210自該空閒列表移除一指標以將該指標(及其在儲存集區中之對應記憶體位址)指派給該片段。
圖4h亦展示在儲存第四輸入光柵掃描列之第二片段的情況下，亦已接收藉由一模板處理器消耗之第二區塊(陰影區域403)。因而，自共用儲存集區210讀取片段之第二行且將對應指標返回至儲存集區之空閒列表。
圖4i展示與沿著影像之第四列接收光柵掃描資料之第三片段(此完成第三區塊影像的形成以供一模板處理器消耗)相應的所得狀態。該程序接著繼續重複，其中各下一儲存片段完成下一區塊。
圖4j展示在儲存第四光柵掃描列之第四片段之後的狀態。如圖4k中所觀察，在已消耗第四表面之後，用於下一片段(光柵掃描資料之第五列之第一片段，像素P65至P68)之指標可儲存於重新格式化邏輯之暫存器空間212之左上角區段中(類似於圖4a)且整個程序(例如)針對輸入影像之光柵掃描列5至8重複。
值得一提的是關於剛在上文參考圖4a至圖4k所描述之實例之一些觀察。首先，應注意對應於(例如)共用儲存集區內之記憶體位址之實際指標值可為隨機的或以其他方式幾乎沒有或沒有關係。因而，片段可實體上儲存於共用儲存集區210內之隨機位置中。如圖4a至圖4k中所觀察之經儲存片段之經組織配置因此為重新格式化邏輯之暫存器空間212中之指標值的組織(如與如實體上儲存於共用儲存集區210內之片段之任何組織相反)之一結果。即，辨識用於模板處理器消耗之區塊影像的能力係重新格式化邏輯之暫存器空間212內之指標值之邏輯組織而非儲存集區210中之實體位置(其中實際上儲存片段)之任何組織的一結果。此處，與此觀察一致，儲存集區之列表可基本上以隨機順序列出指標。
一第二觀察在於被視為足以用於模板處理器消耗之一區塊影像之大小可大於一模板處理器在處理該區塊內之影像資料時將利用之模板大小。例如，在脫離用於圖4a至圖4k之實例之特定維數的一更現實實施例中，執行道陣列及二維移位暫存器陣列具有16×16之維數。當二維移位暫存器陣列充分載入有像素維數16×16之一區塊影像時，執行道陣列可接著繼續進行以依以下像素維數2×2、3×3、4×4等之任一者之模板大小處理該區塊影像。此處，模板大小規定藉由二維移位暫存器執行之移位量。因此藉由重新格式化邏輯識別且經轉發以藉由一模板處理器處理之區塊，與關於用於對影像資料處理之模板大小相比更相關的是載入模板處理器之移位暫存器陣列。
另一觀察在於上文參考圖4a至圖4k所描述之實例假定藉由重新格式化邏輯自儲存集區提取之各區塊足以載入至一模板處理器以用於進一步操作。在各項實施例中，藉由重新格式化邏輯提取之各區塊可含有用於載入至一模板處理器中之多個區塊。例如，考量其之執行道陣列及二維移位暫存器陣列具有維數8×8之一模板處理器。此處，重新格式化邏輯可識別具有8列及16像素之一寬度之區塊。在此情況中，重新格式化邏輯每轉發區域轉發兩個區塊以用於模板消耗。與將處理區塊之模板處理器相關聯之一線緩衝器單元或邏輯將該區塊分成被個別載入至該模板處理器中之一對8×8區塊。因此，藉由重新格式化邏輯提取之一區塊之大小不需要與載入至一模板處理器中之一影像之區塊之維數相同。
又另一觀察在於在各項實施例中重新格式化邏輯之暫存器空間經組態以具有等於待提取之區塊影像之一高度維數。在圖4a至圖4i之實施例中，經提取之區塊影像具有四個像素之一高度維數。因而，暫存器空間212經組織以保存四列指標。相比而言，在各項實施例中，暫存器空間212經組織以具有等於藉由片段大小正規化之輸入影像資料之光柵掃描列之維數的一長度維數。在圖4a至圖4i之實施例中，片段大小係4個像素且輸入影像資料具有16個像素之一光柵掃描列維數。因而，暫存器空間212經組織以具有(16個像素/列)/(4個像素/片段) = 4個片段/列之一長度維數。
在各項實施例中，I/O單元207能夠同時支援複數個輸入影像串流。即，舉例而言，可接收一第一光柵掃描影像且將對應區塊轉發至(例如)一第一線緩衝器單元，同時可接收一第二光柵掃描影像且將對應區塊轉發至(例如)一第二線緩衝器單元。針對一特定線緩衝器單元之各此串流及對應重新格式化可被稱為一通道。因此共用儲存集區210係一「共用」集區，此係因為其之儲存資源係由藉由I/O單元207支援之該數目個即時通道(live channel)共用。即，不同通道之片段同時儲存於集區210內。
在I/O單元207經設計以同時處置多個通道的情況下，重新格式化邏輯211包含用以針對該等通道之各者追蹤其內部暫存器空間212中之指標值的邏輯電路。在各項實施例中，重新格式化邏輯211包含足以處置一最壞情況(最大數目個同時通道具有最大經支援光柵掃描列像素長度及最大經提取區塊像素高度)之暫存器空間212。此外，重新格式化邏輯211內之暫存器空間212資源可藉由該重新格式化邏輯之邏輯電路組態以實現不同數目個經同時支援之通道、不同光柵掃描列像素寬度及/或不同經提取區塊像素高度。此處，各即時通道可在重新格式化邏輯211中藉由該重新格式化邏輯211之組態暫存器空間予以定義，該組態暫存器空間針對一特定通道定義哪一線緩衝器單元將接收該通道之經提取區塊、該等經提取區塊之維數、傳入光柵掃描輸入影像串流之列像素寬度等。
另一觀察在於，在圖4a至圖4i之實例中，片段之輸入速率係比經提取區塊之輸出速率要慢。更明確言之，可在近似對應於將一片段之相當的新輸入像素值寫入至共用儲存集區210中之速率之一時間量內自共用儲存集區210讀取經提取表面區域資料之四個片段。
圖5a至圖5i係關於其中自儲存集區210讀取片段之速率近似等於將片段寫入至該儲存集區中之速率的另一情形。即，舉例而言，接收輸入資料之速率係圖4a至圖4i之實例之速率的4倍。如將自以下論述更清楚瞭解，在重新格式化邏輯之暫存器空間212內利用一雙重緩衝方法以處置較快輸入資料速率。
圖5a對應於可自經接收之輸入光柵掃描資料實現第一區塊時之圖4g之狀態。為便於製圖，在重新格式化邏輯之暫存器空間中並未展示指標值。
圖5b至圖5e展示在自共用儲存集區讀取各片段以作為一區塊影像之部分轉發的情況下，將一新片段寫入至儲存集區210中。即，來自圖5a至圖5e之各下一圖展示自第一緩衝器之第一行移除下一片段且沿著該第一緩衝器501之第四列新增下一片段。因此，當自圖5e中之該第一緩衝器501之該第一行讀取第四片段(含有像素49至52)時，需要將輸入資料之下一片段(含有像素65至68)寫入至重新格式化邏輯之指標暫存器空間212之第二緩衝器502之左上角位置中。因此，如以下圖式中將看見，待提取之接下來三個區塊在第一緩衝器501中具有其等指標，但針對後續輸入資料片段之指標值將使其等指標儲存於第二緩衝器502中。
圖5f至圖5h展示四個週期遞增下之後續系統狀態。即，圖5f展示在已自共用儲存集區讀取第一緩衝器501之第二行之四個片段(以建構待轉發至一線緩衝器單元之第二區塊影像)及已接收接下來四個輸入資料片段且已將其等指標值儲存於第二緩衝器中的四個週期之後的系統狀態。圖5g展示在已自共用儲存集區讀取第一緩衝器501中之第三行之四個片段(以建構待轉發至該線緩衝器單元之第三區塊影像)及已接收接下來四個輸入資料片段且已將其等指標值儲存於第二緩衝器502中的另外四個週期之後的系統狀態。圖5h展示在已自共用儲存集區讀取第一緩衝器501之第四行之四個片段(以建構待轉發至該線緩衝器單元之第四區塊影像)及已接收接下來四個輸入資料片段且已將其等指標值儲存於第二緩衝器502中的另外四個週期之後的系統狀態。
圖5i展示在已自共用儲存集區讀取影像資料之第五行(以建構待轉發至該線緩衝器單元之第五區塊影像)及已接收接下來四個輸入資料片段且已將其等指標值儲存於重新格式化邏輯之暫存器空間中的另外四個週期之後的系統狀態。
應注意，該第五行駐存於第二緩衝器502中而前四個行駐存於第一緩衝器501中。此外，應注意待接收之第四片段(針對像素129至132)使其指標值儲存於第一緩衝器501之左上角中。因此，繼續進展，待提取之接下來三個區塊使其等指標值儲存於第二緩衝器502中但針對新輸入資料片段之指標將儲存於第一緩衝器501中。該程序接著重複，其中在提取針對第二緩衝器502之第四行之表面影像時，達到圖5a之狀態(在有效指標集中度而非像素值方面)。
返回參考圖2，在一或多個模板處理器202_1至202_N完成其等對輸入影像資料之各自處理之後，透過網路204將輸出影像資料自該(等)模板處理器202傳遞至一或多個對應線緩衝器單元205_1至205_N。該一或多個線緩衝器單元205_1至205_N接著將該輸出影像資料轉發至影像處理器之I/O單元207。
在此情況中，將區塊自一線緩衝器單元傳遞至I/O單元207。該I/O單元接著將該等區塊寫入於共用儲存集區中。自影像處理器外部發送之輸出資料可接著作為區塊被直接讀出或以光柵掃描格式被讀出。在其中以光柵掃描格式讀出輸出資料之後者情況中，藉由一處理器完成與上文詳細論述之輸入重新格式化程序相反之區塊至光柵掃描轉換。即，一旦已將對應於一光柵掃描輸出列之全寬之連續數目個輸出區塊(逐片段)寫入至共用儲存集區中，即可按順序逐片段讀出等於該等區塊之高度之數目個列。
圖6展示藉由一I/O單元執行之一方法。該方法包含將以一光柵掃描格式接收之輸入影像資料作為片段儲存於一儲存電路內601。該方法亦包含藉由自該儲存電路讀取該等片段之特定者而將該輸入影像資料重新格式化成一區塊影像格式602。該方法亦包含運用包括一個二維執行道陣列及一個二維移位暫存器陣列之一處理器處理該經區塊影像格式化之輸入影像資料603。 影像處理器及模板處理器實施例
圖7展示用於在如上所述之硬體中實施之一影像處理器之一架構700的一實施例。該影像處理器可(例如)由一編譯器標定，該編譯器將在一模擬環境中針對一虛擬處理器寫入之程式碼轉換成實際上藉由硬體處理器執行之程式碼。如圖7中所觀察，該架構700包含透過一網路704 (例如，一晶片上網路(NOC)，包含一晶片上交換式網路、一晶片上環形網路或其他種類之網路)互連至複數個模板處理器單元702_1至702_N及對應表單產生器單元703_1至703_N之複數個線緩衝器單元701_1至701_M。在一項實施例中，任何線緩衝器單元可透過該網路704連接至任何表單產生器及對應模板處理器。
在一項實施例中，程式碼經編譯及載入至一對應模板處理器702上以執行先前由一軟體開發者定義之影像處理器操作(例如，取決於設計及實施方案，亦可將程式碼載入至該模板處理器之相關聯表單產生器703上)。在至少一些例項中，可藉由將針對一第一管線階段之一第一核心程式載入至一第一模板處理器702_1中，將針對一第二管線階段之一第二核心程式載入至一第二模板處理器702_2中等，而實現一影像處理管線，其中該第一核心執行該管線之該第一階段之功能，該第二核心執行該管線之該第二階段之功能等，且設置額外控制流方法以將輸出影像資料自該管線之一個階段傳遞至該管線之下一階段。
在其他組態中，影像處理器可被實現為具有操作相同核心程式碼之兩個或兩個以上模板處理器702_1、702_2之一平行機。例如，可藉由跨各執行相同功能之多個模板處理器散佈圖框而處理影像資料之一高度緻密及高資料速率串流。
在又其他組態中，基本上核心之任何DAG可藉由以下步驟載入至硬體處理器上：在DAG設計中，用各自模板處理器其等自身各自程式碼核心組態各自模板處理器；及將適當控制流攔截程式(hook)組態至硬體中以將來自一核心之輸出影像引導至下一核心之輸入。
作為一般流程，藉由一巨型I/O單元705接收影像資料之圖框且將該等圖框逐圖框傳遞至線緩衝器單元701之一或多者。在其中類似於上文詳細論述之I/O單元207實施該巨型I/O單元705之各項實施例中，將一個別圖框作為一系列影像資料區塊(例如，各含有該圖框之影像之一不同區段)自該巨型I/O單元705傳遞至一或多個線緩衝器單元。一特定線緩衝器單元將其影像資料圖框剖析成一較小影像資料區域(被稱為一「線群組」)，且接著透過網路704將該線群組傳遞至一特定表單產生器。一完整或「全」單線群組可(例如)用一圖框之多個連續完整列或行之資料組成(為簡潔起見本說明書將主要指連續列)。表單產生器將影像資料之線群組進一步剖析成一較小影像資料區域(被稱為一「表單」)，且將該表單提呈給其對應模板處理器。
在具有一單個輸入之一影像處理管線或一DAG流程之情況中，一般而言，輸入圖框係引導至相同線緩衝器單元701_1，該相同線緩衝器單元701_1將影像資料剖析成線群組且將該等線群組引導至表單產生器703_1，該表單產生器703_1之對應模板處理器702_1執行該管線/DAG中之第一核心之程式碼。在完成該模板處理器702_1對其處理之線群組之操作之後，表單產生器703_1將輸出線群組發送至一「下游」線緩衝器單元701_2 (在一些使用情況中，可將輸出線群組發送回至先前已發送輸入線群組之相同線緩衝器單元701_1)。
表示執行於其等自身各自其他表單產生器及模板處理器(例如，表單產生器703_2及模板處理器702_2)上之管線/DAG中之下一階段/操作之一或多個「消耗者」核心接著自下游線緩衝器單元701_2接收藉由第一模板處理器702_1產生之影像資料。以此方式，操作於一第一模板處理器上之一「生產者」核心使其輸出資料轉發至操作於一第二模板處理器上之一「消耗者」核心，其中該消耗者核心依據整體管線或DAG之設計在該生產者核心後執行下一組任務。
一模板處理器702經設計以同時對影像資料之多個重疊模板處理。該多個重疊模板及模板處理器之內部硬體處理能力有效判定一表單之大小。此處，在一模板處理器702內，若干執行道陣列聯合操作以同時處理藉由該多個重疊模板覆蓋之影像資料表面區域。
如下文將更詳細描述，在各項實施例中，將若干影像資料表單載入至模板處理器702內之一個二維暫存器陣列結構中。據信表單及二維移位暫存器陣列結構的使用藉由將大量資料移動至大量暫存器空間中作為(例如)一單個載入操作(緊接在此之後藉由一執行道陣列對該資料直接執行處理任務)而有效提供電力消耗改良。此外，使用一執行道陣列及對應暫存器陣列提供可易於程式化/組態之不同模板大小。
圖8a至圖8e以一線緩衝器單元701之剖析活動、一表單產生器單元703之較精細粒度剖析活動兩者以及耦合至該表單產生器單元703之模板處理器702之模板處理活動之一高階實施例進行繪示。
圖8a描繪影像資料801之一輸入圖框之一實施例。圖8a亦描繪一模板處理器經設計以對其操作之三個重疊模板802 (各具有3像素×3像素之一維數)之一輪廓。各模板分別針對其產生輸出影像資料之輸出像素係以純黑色突顯。為簡潔起見，該三個重疊模板802係描繪為僅在垂直方向上重疊。應該認識到，實際上一模板處理器可經設計以在垂直及水平兩個方向上具有重疊模板。
由於模板處理器內之垂直重疊模板802，如圖8a中所觀察，圖框內存在一單個模板處理器可對其操作之大量影像資料。如下文將更詳細論述，在一項實施例中，模板處理器以跨影像資料從左至右之一方式處理其等重疊模板內之資料(且接著對於下一組線以頂部至底部順序重複)。因此，在模板處理器持續進行其等操作時，純黑色輸出像素區塊之數目將水平地向右增長。如上文所論述，一線緩衝器單元701係負責剖析足以使模板處理器在擴展數目個即將來臨的循環內對其操作之來自一傳入圖框之輸入影像資料之一線群組。一線群組之一例示性描繪係繪示為一陰影區域803。在一項實施例中，線緩衝器單元701可理解用於發送一線群組至一表單產生器或自一表單產生器接收一線群組之不同動態。例如，根據一模式(被稱為「全群組」)，在一線緩衝器單元與一表單產生器之間傳遞完整全寬影像資料線。根據一第二模式(被稱為「實際上高」)，最初以全寬列之一子集傳遞一線群組。接著以較小(小於全寬)片段循序傳遞其餘列。
在輸入影像資料之線群組803已藉由線緩衝器單元定義且傳遞至表單產生器單元之情況下，該表單產生器單元將該線群組進一步剖析成更精確匹配模板處理器之硬體限制之更精細表單。更明確言之，如下文將更進一步詳細描述，在一項實施例中，各模板處理器由一個二維移位暫存器陣列組成。該二維移位暫存器陣列基本上使影像資料在一執行道陣列「下方」移位，其中該移位之型樣引起各執行道對其自身各自模板內之資料操作(即，各執行道對其自身資訊模板處理以產生針對該模板之一輸出)。在一項實施例中，表單係輸入影像資料之「填充」或以其他方式載入至二維移位暫存器陣列中之表面區域。
如下文將更詳細描述，在各項實施例中，實際上存在可在任何循環內移位之多層二維暫存器資料。為方便起見，本發明描述的大部分將僅使用術語「二維移位暫存器」及類似者來指代具有可移位之一或多個此等層之二維暫存器資料之結構。
因此，如圖8b中所觀察，表單產生器剖析來自線群組803之一初始表單804且將其提供至模板處理器(此處，該資料表單對應於一般藉由元件符號804識別之陰影區域)。如圖8c及圖8d中所觀察，模板處理器藉由在表單上方以一從左至右方式有效移動重疊模板802而對輸入影像資料之表單操作。截至圖8d，耗盡可針對其自表單內之資料計算一輸出值之像素之數目(其他像素位置可能無自表單內之資訊判定之一輸出值)。為簡潔起見，已忽略影像之邊界區域。
如圖8e中所觀察，表單產生器接著對模板處理器提供下一表單805用以繼續操作。應注意，模板在其等開始對該下一表單操作時之初始位置係自第一表單上之耗盡點(如先前圖8d中所描繪)向右之下一進程。關於新表單805，模板將簡單地在模板處理器以與第一表單之處理相同之方式對該新表單操作時持續向右移動。
應注意，歸因於模板之圍繞一輸出像素位置之邊界區域，在第一表單804之資料與第二表單805之資料之間存在一些重疊。可簡單藉由表單產生器兩次重新傳輸該重疊資料而處置該重疊。在交替實施方案中，為饋送下一表單至模板處理器，表單產生器可繼續進行以僅將新資料發送至該模板處理器且該模板處理器重新使用來自先前表單之重疊資料。
圖9a展示一模板處理器架構900之一實施例。如在圖9a中觀察，模板處理器包含一資料運算單元901、一純量處理器902及相關聯記憶體903以及一I/O單元904。資料運算單元901包含一執行道陣列905、二維移位陣列結構906及與陣列之特定列或行相關聯之分開隨機存取記憶體907(包含記憶體907-1至907-R)。
I/O單元904負責將自表單產生器接收之「輸入」資料表單載入至資料運算單元901中且將來自模板處理器之「輸出」資料表單儲存至表單產生器中。在一實施例中，將表單資料載入至資料運算單元901中需要將一所接收表單剖析成影像資料之列/行且將影像資料之列/行載入至二維移位暫存器結構906或執行道陣列之列/行之各自隨機存取記憶體907中(在下文更詳細描述)。若首先將表單載入至記憶體907中，則執行道陣列905內之個別執行道可接著在適當時將表單資料自隨機存取記憶體907載入至二維移位暫存器結構906中(例如，作為緊接在對表單之資料之操作之前的一載入指令)。在(無論直接自一表單產生器或自記憶體907)將一資料表單載入至暫存器結構906中完成之後，執行道陣列905之執行道對資料進行操作且最終將已完成資料作為一表單直接「寫回」至表單產生器或至隨機存取記憶體907中。若為後者，則I/O單元904自隨機存取記憶體907提取資料以形成一輸出表單，該輸出表單接著經轉發至表單產生器。
純量處理器902包含一程式控制器909，該程式控制器909自純量記憶體903讀取模板處理器之程式碼之指令且將指令發出至執行道陣列905中之執行道。在一實施例中，一單一相同指令經廣播至陣列905內之所有執行道以實現來自資料運算單元901之一類似SIMD行為。在一實施例中，自純量記憶體903讀取且發出至執行道陣列905之執行道之指令之指令格式包含一極長指令字組(VLIW)型格式，該格式包含每指令一個以上運算碼。在又一實施例中，VLIW格式包含引導藉由各執行道之ALU執行之一數學函數之一ALU運算碼(如下文描述，在一實施例中，其可指定一個以上傳統ALU操作)及一記憶體運算碼(其引導一特定執行道或執行道組之一記憶體操作)。
術語「執行道」係指能夠執行一指令之一組一或多個執行單元(例如，可執行一指令之邏輯電路)。然而，在各種實施例中，一執行道可包含除僅執行單元以外的更多類似處理器功能性。例如，除一或多個執行單元以外，一執行道亦可包含解碼一所接收指令之邏輯電路或(在更多類似MIMD設計之情況中)提取及解碼一指令之邏輯電路。關於類似MIMD方法，儘管已在本文中較大程度上描述一集中式程式控制方法，但可在各種替代實施例中實施一更分散式方法(例如包含陣列905之各執行道內之程式碼及一程式控制器)。
一執行道陣列905、程式控制器909及二維移位暫存器結構906之組合提供用於廣泛範圍之可程式功能之一廣泛可調適/可組態硬體平台。例如，考慮到個別執行道能夠執行廣泛範圍之功能且能夠在接近於任何輸出陣列位置處容易地存取輸入影像資料，應用軟體開發者能夠程式化具有廣泛範圍之不同功能能力以及維數(例如模板大小)之核心。
除充當用於藉由執行道陣列905操作之影像資料之一資料儲存器以外，隨機存取記憶體907亦可保持一或多個查找表。在各種實施例中，亦可在純量記憶體903內例示一或多個純量查找表。
一純量查找涉及將來自相同索引之相同查找表之相同資料值傳送至執行道陣列905內之執行道之各者。在各種實施例中，上文描述之VLIW指令格式經擴展以亦包含一純量運算碼，該純量運算碼將藉由純量處理器執行之一查找操作引導至一純量查找表中。指定與運算碼結合使用之索引可為一立即運算元或自某其他資料儲存位置提取。無論如何，在一實施例中，自純量記憶體內之一純量查找表之一查找本質上涉及在相同時脈循環期間將相同資料值傳播至執行道陣列905內之所有執行道。在下文進一步提供關於查找表之使用及操作之額外細節。
圖9b概述上文論述之(若干) VLIW指令字組實施例。如在圖9b中觀察，VLIW指令字組格式包含三個分開指令之欄位：1)一純量指令951，其藉由純量處理器執行；2)一ALU指令952，其藉由執行道陣列內之各自ALU以SIMD方式傳播及執行；及3)一記憶體指令953，其以一部分SIMD方式傳播及執行(例如，若沿著執行道陣列中之一相同列之執行道共用一相同隨機存取記憶體，則來自不同列之各者之一個執行道實際上執行指令(記憶體指令953之格式可包含識別來自各列之哪一執行道執行指令之一運算元))。
亦包含一或多個立即運算元之一欄位954。可在指令格式中識別哪一指令951、952、953使用哪一立即運算元資訊。指令951、952、953之各者亦包含其等自身各自輸入運算元及所得資訊(例如，用於ALU操作之本端暫存器及用於記憶體存取指令之一本端暫存器及一記憶體位址)。在一實施例中，在執行道陣列內之執行道執行其他指令952、953之任一者之前藉由純量處理器執行純量指令951。即，VLIW字組之執行包含執行純量指令951之一第一循環，其後接著可執行其他指令952、953之一第二循環(應注意，在各種實施例中，可平行執行指令952及953)。
在一實施例中，藉由純量處理器執行之純量指令包含發出至表單產生器以自資料運算單元之記憶體或2D移位暫存器載入表單/將表單儲存至資料運算單元之記憶體或2D移位暫存器中之命令。此處，表單產生器之操作可取決於線緩衝器單元之操作或防止表單產生器完成藉由純量處理器發出之任何命令將花費之循環數目之運行時間之前的理解之其他變量。因而，在一實施例中，任何VLIW字組(其之純量指令951對應於或另外導致一命令發出至表單產生器)亦包含其他兩個指令欄位952、953中之無操作(NOOP)指令。程式碼接著進入指令欄位952、953之NOOP指令之一迴圈直至表單產生器完成其至資料運算單元之載入/自資料運算單元之儲存。此處，在將一命令發出至表單產生器之後，純量處理器可設定表單產生器在完成命令之後重設之一互鎖暫存器之一位元。在NOOP迴圈期間，純量處理器監測互鎖暫存器之位元。當純量處理器偵測到表單產生器已完成其命令時，正常執行再次開始。
圖10展示一資料運算組件1001之一實施例。如在圖10中觀察，資料運算組件1001包含邏輯地定位於二維移位暫存器陣列結構1006「上方」之一執行道陣列1005。如上文論述，在各種實施例中，由一表單產生器提供之影像資料之一表單經載入至二維移位暫存器1006中。執行道接著對來自暫存器結構1006之表單資料進行操作。
執行道陣列1005及移位暫存器結構1006相對於彼此固定在適當位置中。然而，移位暫存器陣列1006內之資料以一戰略性且協調方式移位以導致執行道陣列中之各執行道處理資料內之一不同模板。因而，各執行道判定所產生之輸出表單中之一不同像素之輸出影像值。自圖10之架構，應明白，重疊模板不僅垂直配置而且水平配置，因為執行道陣列1005包含垂直相鄰執行道以及水平相鄰執行道。
資料運算單元1001之一些顯著架構特徵包含具有寬於執行道陣列1005之維數之移位暫存器結構1006。即，執行道陣列1005外部存在暫存器之一「光暈(halo)」1009。儘管光暈1009經展示為存在於執行道陣列之兩側上，但取決於實施方案，光暈可存在於執行道陣列1005之較少(一個)或較多(三個或四個)側上。在資料在執行道1005「下方」移位時，光暈1009用於為溢出執行道陣列1005之邊界外部之資料提供「外溢」空間。作為一簡單情況，以執行道陣列1005之右邊緣為中心之一5×5模板在模板之最左像素被處理時，將需要進一步向右之四個光暈暫存器位置。為易於繪製，當在一標稱實施例中，任一側(右側、底側)上之暫存器將具有水平連接及垂直連接兩者時，圖10將光暈之右側之暫存器展示為僅具有水平移位連接且將光暈之底側之暫存器展示為僅具有垂直移位連接。在各種實施例中，光暈區域並不包含用以執行影像處理指令之對應執行道邏輯(例如，不存在ALU)。然而，個別記憶體存取單元(M)存在於光暈區域位置之各者中，使得個別光暈暫存器位置可個別地自記憶體載入資料及將資料儲存至記憶體。
藉由耦合至陣列中之各列及/或各行或其部分之隨機存取記憶體1007 (包含記憶體1007-1至1007-R)提供額外外溢空間(例如，一隨機存取記憶體可經指派至跨越4個執行道列及2個執行道行之執行道陣列之一「區域」。為簡單起見，本申請案之其餘部分將主要參考基於列及/或行之分配方案。)此處，若一執行道之核心操作要求其處理二維移位暫存器陣列1006外部之像素值(一些影像處理常式可能要求此)，則影像資料平面能夠例如自光暈區域1009進一步外溢至隨機存取記憶體1007中。例如，考量一6×6模板，其中硬體包含在執行道陣列之右邊緣上之一執行道之右側之僅四個儲存元件之一光暈區域。在此情況中，資料將需要進一步移位至光暈1009之右邊緣之右側以完全處理模板。移位至光暈區域1009外部之資料將接著外溢至隨機存取記憶體1007。下文進一步提供圖9之隨機存取記憶體1007及模板處理器之其他應用。
圖11a至圖11k展現影像資料如上文提及般在執行道陣列「下方」之二維移位暫存器陣列內移位之方式之一工作實例。如在圖11a中觀察，在一第一陣列1107中描繪二維移位陣列之資料內容且藉由一圖框1105描繪執行道陣列。而且，簡單化地描繪執行道陣列內之兩個相鄰執行道1110。在此簡單化描繪1110中，各執行道包含可自移位暫存器接受資料、自一ALU輸出(例如，表現為跨循環之一累加器)接受資料或將輸出資料寫入至一輸出目的地中之一暫存器R1。
各執行道亦可在一本端暫存器R2中獲得二維移位陣列中其「下方」之內容。因此，R1係執行道之一實體暫存器，而R2係二維移位暫存器陣列之一實體暫存器。執行道包含可對由R1及/或R2提供之運算元進行操作之一ALU。如將在下文進一步更詳細描述，在一實施例中，實際上使用每陣列位置之多個儲存器/暫存器元件(之一「深度」)實施移位暫存器，但移位活動限於儲存元件之一個平面(例如，儲存元件之僅一個平面可在每循環移位)。圖11a至圖11k描繪如用於儲存來自各自執行道之結果X之此等較深暫存器位置之一者。為易於繪示，較深所得暫存器經繪製成並排於其對應暫存器R2而非在其對應暫存器R2下方。
圖11a至圖11k集中於兩個模板之計算，兩個模板之中心位置與在執行道陣列內描繪之該對執行道位置1111對準。為易於繪示，該對執行道1110經繪製成水平相鄰者，實際上，當根據以下實例時，其等係垂直相鄰者。
如首先在圖11a中觀察，執行道以其等中心模板位置為中心。圖11b展示藉由兩個執行道執行之目的碼。如在圖11b中觀察，兩個執行道之程式碼導致移位暫存器陣列內之資料向下移位一個位置且向右移位一個位置。此將兩個執行道對準至其等各自模板之左上角。程式碼接著導致定位於(R2中)其等各自位置中之資料經載入至R1中。
如在圖11c中觀察，程式碼接著導致該對執行道使移位暫存器陣列內之資料向左移位一個單位，此導致在各執行道之各自位置之右側之值移位至各執行道之位置中。R1中之值(先前值)接著與已移位至執行道之位置中(R2中)之新值相加。結果經寫入至R1中。如在圖11d中觀察，重複相同於上文針對圖11c描述之程序，此導致結果R1現在包含上執行道中之值A+B+C及下執行道中之F+G+H。此時，兩個執行道已處理其等各自模板之上列。應注意，外溢至執行道陣列之左側上之一光暈區域中(若一個光暈區域存在於左手側上)或至隨機存取記憶體中(若一光暈區域不存在於執行道陣列之左手側上)。
如在圖11e中觀察，程式碼接著導致移位暫存器陣列內之資料向上移位一個單位，此導致兩個執行道與其等各自模板之中間列之右邊緣對準。兩個執行道之暫存器R1當前包含模板之頂列及中間列之最右值之總和。圖11f及圖11g展現跨兩個執行道之模板之中間列向左移動之連續進展。累積加法繼續，使得在圖11g之處理結束時，兩個執行道包含其等各自模板之頂列及中間列之值之總和。
圖11h展示使各執行道與其對應模板之最下列對準之另一移位。圖11i及圖11j展示完成對兩個執行道之模板之進程之處理之連續移位。圖11k展示使各執行道與其在資料陣列中之正確位置對準且將結果寫入至其之額外移位。
在圖11a至圖11k之實例中，應注意，用於移位操作之目的碼可包含識別在(X,Y)座標中表達之移位之方向及量值之一指令格式。例如，用於向上移位一個位置之目的碼可在目的碼中表達為SHIFT 0,+1。作為另一實例，向右移位一個位置可在目的碼中表達為SHIFT +1,0。在各種實施例中，亦可在目的碼中指定具有較大量值之移位(例如SHIFT 0,+2)。此處，若2D移位暫存器硬體僅支援每循環一個位置之移位，則指令可藉由機器解釋為需要多個循環執行，或2D移位暫存器硬體可經設計以支援每循環一個以上位置之移位。下文進一步更詳細描述後者之實施例。
圖12展示用於一執行道及對應移位暫存器結構之單元胞之另一更詳細描繪(在各種實施例中，光暈區域中之暫存器不包含一對應執行道但包含一記憶體單元)。在一實施例中，藉由在執行道陣列之各節點處例示圖12中觀察之電路而實施與執行道陣列中之各位置相關聯之執行道及暫存器空間。如在圖12中觀察，單元胞包含耦合至由四個暫存器R2至R5構成之一暫存器檔案1202之一執行道1201。在任何循環期間，執行道1201可自暫存器R1至R5之任一者讀取或寫入至暫存器R1至R5之任一者。對於需要兩個輸入運算元之指令，執行道可自R1至R5之任一者擷取兩個運算元。
在一實施例中，藉由在一單一循環期間允許暫存器R2至R4之(僅)一者之任一者之內容透過輸出多工器1203移「出」至其相鄰者之暫存器檔案之一者且使暫存器R2至R4之(僅)一者之任一者之內容替換為透過輸入多工器1204自其相鄰者之一對應者移「入」之內容，使得相鄰者之間的移位在一相同方向上(例如所有執行道向左移位、所有執行道向右移位等)而實施二維移位暫存器結構。儘管一相同暫存器使其內容移出且替換為在一相同循環內移入之內容可為常見的，但多工器配置1203、1204允許一相同循環期間之一相同暫存器檔案內之不同移位源及移位目標暫存器。
如在圖12中描繪，應注意，在一移位序列期間，一執行道將使內容自其暫存器檔案1202移出至其左、右、頂部及底部相鄰者之各者。結合相同移位序列，執行道亦將使內容自其左、右、頂部及底部相鄰者之一特定者移入至其暫存器檔案中。再者，移出目標及移入源應與所有執行道之一相同移位方向一致(例如若移出係至右相鄰者，則移入應係自左相鄰者)。
儘管在一項實施例中，每循環每執行道僅允許移位一個暫存器之內容，但其他實施例可允許移入/移出一個以上暫存器之內容。例如，若在圖12中觀察之多工器電路1203、1204之一第二例項經併入至圖12之設計中，則可在一相同循環期間移出/移入兩個暫存器之內容。當然，在其中每循環僅允許移位一個暫存器之內容之實施例中，可藉由消耗更多時脈循環用於數學運算之間的移位而在數學運算之間發生自多個暫存器之移位(例如，藉由消耗數學運算之間的兩個移位操作而在數學運算之間移位兩個暫存器之內容)。
若在一移位序列期間移出一執行道之暫存器檔案之少於所有內容，則應注意，各執行道之未移出暫存器之內容保持在適當位置中(未移位)。因而，未替換為移入內容之任何未移位內容跨移位循環留存在執行道本端。在各執行道中觀察到之記憶體單元(「M」)用於自與執行道陣列內之執行道之列及/或行相關聯之隨機存取記憶體空間載入資料/將資料儲存至該隨機存取記憶體空間。此處，M單元充當一標準M單元，其中其通常用於載入/儲存無法自執行道之自身暫存器空間載入/無法儲存至執行道之自身暫存器空間之資料。在各種實施例中，M單元之主要操作係將資料自一本端暫存器寫入至記憶體中及自記憶體讀取資料且將其寫入至一本端暫存器中。
關於藉由硬體執行道1201之ALU單元支援之ISA運算碼，在各種實施例中，藉由硬體ALU支援之數學運算碼包含(例如ADD、SUB、MOV、MUL、MAD、ABS、DIV、SHL、SHR、MIN/MAX、SEL、AND、OR、XOR、NOT)。恰如上文描述，可藉由執行道1201執行記憶體存取指令以自其等相關聯隨機存取記憶體提取資料/將資料儲存至其等相關聯隨機存取記憶體。另外，硬體執行道1201支援移位操作指令(右、左、上、下)以使資料在二維移位暫存器結構內移位。如上文描述，較大程度上藉由模板處理器之純量處理器執行程式控制指令。G. 實施方案實施例
應指出，上文描述之各種影像處理器架構特徵不必限於傳統意義上之影像處理且因此可經應用至可(或可不)導致重新特性化影像處理器之其他應用。例如，若上文描述之各種影像處理器架構特徵之任一者待用於建立及/或產生及/或呈現動畫(相對於處理實際相機影像)，則影像處理器可經特性化為一圖形處理單元。另外，上文描述之影像處理器架構特徵可經應用至其他技術應用，諸如視訊處理、視覺處理、影像辨識及/或機器學習。以此方式應用，影像處理器可(例如作為一協同處理器)與一更通用處理器(例如，其係運算系統之一CPU或其之部分)整合或可為一運算系統內之一獨立處理器。
上文論述之硬體設計實施例可體現於一半導體晶片內及/或體現為以一半導體製程為最終目標之一電路設計之一描述。在後一情況中，此等電路描述可採用一(例如，VHDL或Verilog)暫存器轉移層級(RTL)電路描述、一閘極層級電路描述、一電晶體層級電路描述或遮罩描述或其等之各種組合之形式。電路描述通常體現於一電腦可讀儲存媒體(諸如一CD-ROM或其他類型之儲存技術)上。
自前述章節應認識到，如上文描述之一影像處理器可體現於一電腦系統上之硬體中(例如，作為處理來自手持裝置之相機之資料之一手持裝置之系統單晶片(SOC)之部分)。在其中影像處理器體現為一硬體電路之情況中，應注意，可自一相機直接接收藉由影像處理器處理之影像資料。此處，影像處理器可為一離散相機之部分或具有一整合相機之一運算系統之部分。在後一情況中，可自相機或自運算系統之系統記憶體直接接收影像資料(例如，相機將其影像資料發送至系統記憶體而非影像處理器)。亦應注意，在前述章節中描述之許多特徵可應用至一圖形處理器單元(其呈現動畫)。
圖13提供一運算系統之一例示性描繪。下文描述之運算系統之許多組件可應用至具有一整合相機及相關聯影像處理器之一運算系統(例如，一手持式裝置，諸如一智慧型電話或平板電腦)。一般技術者將能夠容易地區分兩者。另外，圖13之運算系統亦包含一高效能運算系統(諸如一工作站或超級電腦)之許多特徵。
如在圖13中觀察，基本運算系統可包含一中央處理單元1301 (其可包含例如安置於一多核心處理器或應用處理器上之複數個通用處理核心1315_1至1315_N及一主記憶體控制器1317)、系統記憶體1302、一顯示器1303 (例如觸控螢幕、平板)、一本端有線點對點鏈路(例如，USB)介面1304、各種網路I/O功能1305 (諸如乙太網路介面及/或蜂巢式數據機子系統)、一無線區域網路(例如，WiFi)介面1306、一無線點對點鏈路(例如，藍芽)介面1307及一全球定位系統介面1308、各種感測器1309_1至1309_N、一或多個相機1310、一電池1311、一電力管理控制單元1312、一揚聲器及麥克風1313及一音訊編碼器/解碼器1314。
一應用處理器或多核心處理器1350可包含其CPU 1301內之一或多個通用處理核心1315、一或多個圖形處理單元1316、一記憶體管理功能1317 (例如，一記憶體控制器)、一I/O控制功能1318及一影像處理單元1319。通用處理核心1315通常執行運算系統之作業系統及應用軟體。圖形處理單元1316通常執行圖形密集功能以例如產生呈現於顯示器1303上之圖形資訊。記憶體控制功能1317與系統記憶體1302介接以將資料寫入至系統記憶體1302/自系統記憶體1302讀取資料。電力管理控制單元1312通常控制系統1300之電力消耗。
可根據在上文之前述章節中詳細描述之影像處理單元實施例之任一者實施影像處理單元1319。替代地或組合地，IPU 1319可經耦合至GPU 1316及CPU 1301之任一者或兩者以作為其之一協同處理器。另外，在各種實施例中，可使用上文詳細描述之影像處理器特徵之任一者實施GPU 1316。
觸控螢幕顯示器1303、通信介面1304至1307、GPS介面1308、感測器1309、相機1310及揚聲器/麥克風編解碼器1313、1314之各者皆可被視為關於整個運算系統(亦適當地包含一整合周邊裝置(例如，一或多個相機1310))之I/O (輸入及/或輸出)之各種形式。取決於實施方案，此等I/O組件之各者可整合於應用處理器/多核心處理器1350上或可定位於晶粒之外或應用處理器/多核心處理器1350之封裝外部。
在一實施例中，一或多個相機1310包含能夠量測相機與其視場中之一物件之間的深度之一深度相機。在一應用處理器或其他處理器之一通用CPU核心(或具有用以執行程式碼之一指令執行管線之其他功能區塊)上執行之應用軟體、作業系統軟體、裝置驅動程式軟體及/或韌體可執行上文描述之功能之任一者。
本發明之實施例可包含如上文陳述之各種程序。程序可體現為機器可執行指令。指令可用於導致一通用或專用處理器執行某些程序。替代地，可藉由含有用於執行程序之硬接線及/或可程式化邏輯之特定硬體組件或藉由程式化電腦組件及客製硬體組件之任何組合執行此等程序。
本發明之元件亦可提供為用於儲存機器可執行指令之一機器可讀媒體。機器可讀媒體可包含(但不限於)軟碟、光碟、CD-ROM及磁光碟、FLASH記憶體、ROM、RAM、EPROM、EEPROM、磁卡或光學卡、傳播媒體或適於儲存電子指令之其他類型的媒體/機器可讀媒體。例如，本發明可作為一電腦程式下載，該電腦程式可藉由體現於一載波或其他傳播媒體中之資料信號經由一通信鏈路(例如，一數據機或網路連接)自一遠端電腦(例如，一伺服器)傳遞至一請求電腦(例如，一用戶端)。
在前述說明書中，已參考本發明之特定例示性實施例描述本發明。然而，將顯而易見，在不脫離如隨附發明申請專利範圍中陳述之本發明之更廣泛精神及範疇之情況下，可對其作出各種修改及改變。因此，本說明書及圖式應被視為一繪示性意義而非一限制性意義。
在下文給出一些例示性實施例。
實例1：一種影像處理器，其包括：
一儲存電路，其用以儲存自一相機以一光柵掃描格式接收之輸入影像資料之片段；
一重新格式化電路，其用以將輸入影像資料之該等片段轉換成一區塊影像格式；
一處理器，其包括一個二維執行道陣列及一個二維移位暫存器陣列，該二維移位暫存器陣列用以儲存已被格式化成該區塊影像格式之該輸入影像資料，該執行道陣列用以執行對來自該二維移位暫存器陣列之該影像資料操作之指令。
實例2：如實例1之影像處理器，其中該重新格式化電路包括用以保存指向該輸入影像資料之該等片段之指標的暫存器空間。
實例3：如實例1或2之影像處理器，其中該等指標在該暫存器空間中經組織以具有對應於該光柵掃描格式之一列寬之一第一維數及具有對應於該區塊格式之一像素高度之一第二維數。
實例4：如實例1至3中至少一項之影像處理器，其中該重新格式化電路係用以辨識該輸入影像資料之一區塊何時已儲存於該儲存電路中且引起藉由參考該暫存器空間中之該等指標而自該儲存電路讀取該儲存電路內之對應於該區塊之片段。
實例5：如實例1至4中至少一項之影像處理器，其中該重新格式化電路支援以下各項之任一者：
可組態片段大小；
可組態光柵掃描列寬大小；
可組態區塊像素高度大小。
實例6：如實例1至5中至少一項之影像處理器，其中該重新格式化電路亦用以執行輸出區塊影像至輸出影像光柵掃描轉換。
實例7：如實例1至6中至少一項之影像處理器，其中該重新格式化電路支援多個光柵掃描至區塊影像轉換通道。
實例8：如前述實例中至少一項之影像處理器，其進一步包括經組態以對該輸入影像之至少一個二維區域操作之至少一模板處理器。
實例9：如前述實例中至少一項之影像處理器，其中至少兩個模板處理器經組態以處理相同核心程式碼。
實例10：如前述實例中至少一項之影像處理器，其中至少兩個模板使影像資料特定言之垂直及/或水平重疊，且該至少一模板處理器經組態以對該等重疊模板操作。
實例11：如前述實例中至少一項之影像處理器，其中一資料運算單元包括具有比該執行道陣列寬之維數之一移位暫存器結構，特定言之在該執行道陣列外存在暫存器。
實例12：如前述實例中至少一項之影像處理器，其中一個二維移位陣列及一執行道陣列經組態以判定具有重疊模板之至少一對相鄰輸出像素值。
實例13：一種運算系統，其包括：
a)一或多個通用處理器核心；
b)一系統記憶體；
c)一記憶體控制器，其耦合至該系統記憶體；
d)一相機；
e)一影像處理器，其包括以下i)、ii)及iii)：
i)一儲存電路，其用以儲存自該相機以一光柵掃描格式接收之輸入影像資料之片段；
ii)一重新格式化電路，其用以將輸入影像資料之該等片段轉換成一區塊影像格式；
iii)一處理器，其包括一個二維執行道陣列及一個二維移位暫存器陣列，該二維移位暫存器陣列用以儲存已被格式化成該區塊影像格式之該輸入影像資料，該執行道陣列用以執行對來自該二維移位暫存器陣列之該影像資料操作之指令。
實例14：如實例13之運算系統，其中該重新格式化電路包括用以保存指向該輸入影像資料之該等片段之指標的暫存器空間。
實例15：如實例13或14之運算系統，其中該等指標在該暫存器空間中經組織以具有對應於該光柵掃描格式之一列寬之一第一維數及具有對應於該區塊格式之一像素高度之一第二維數。
實例16：如實例13至15中至少一項之運算系統，其中該重新格式化電路係用以辨識該輸入影像資料之一區塊何時已儲存於該儲存電路中且引起藉由參考該暫存器空間中之該等指標而自該儲存電路讀取該儲存電路內之對應於該區塊之片段。
實例17：如實例13至16中至少一項之運算系統，其中該重新格式化電路支援以下各項之任一者：
可組態片段大小；
可組態光柵掃描列寬大小；
可組態區塊像素高度大小。
實例18：如實例13至17中至少一項之運算系統，其中該重新格式化電路亦用以執行輸出區塊影像至輸出影像光柵掃描轉換。
實例19：如實例13至18中至少一項之運算系統，其中該重新格式化電路支援多個光柵掃描至區塊影像轉換通道。
實例20：如實例13至19中至少一項之運算系統，其進一步包括對該輸入影像之至少一個二維區域操作之至少一模板處理器。
實例21：如實例13至20中至少一項之運算系統，其中至少兩個模板處理器經組態以處理相同核心程式碼。
實例22：如實例13至21中至少一項之運算系統，其中至少兩個模板使影像資料特定言之垂直及/或水平重疊，且該至少一模板處理器經組態以對重疊模板操作。
實例23：如實例13至22中至少一項之運算系統，其中一資料運算單元包括具有比該執行道陣列寬之維數之一移位暫存器結構，特定言之在該執行道陣列外存在暫存器。
實例24：如實例13至23中至少一項之運算系統，其中一個二維移位陣列及一執行道陣列經組態以判定具有重疊模板之至少一對相鄰輸出像素值。
實例25：一種方法，其包括：
將自一相機以一光柵掃描格式接收之輸入影像資料作為片段儲存於一儲存電路內；
藉由自該儲存電路讀取該等片段之特定者而將該輸入影像資料重新格式化成一區塊影像格式；及，
運用包括一個二維執行道陣列及一個二維移位暫存器陣列之一處理器處理該經區塊影像格式化之輸入影像資料。
實例26：如實例25之方法，其進一步包括將指向該輸入影像資料之該等片段之指標保存於暫存器空間內。
實例27：如實例25或26之方法，其中該等指標在該暫存器空間中經組織以具有對應於該光柵掃描格式之一列寬之一第一維數及具有對應於該區塊格式之一像素高度之一第二維數。
實例28：如實例25至27中至少一項之方法，其中該重新格式化進一步包括辨識該輸入影像資料之一區塊何時已儲存於該儲存電路中且引起藉由參考該暫存器空間中之該等指標而自該儲存電路讀取該儲存電路內之對應於該區塊之片段。
實例29：如實例25至28中至少一項之方法，其進一步包括執行以下各項之任一者以執行該重新格式化：
組態一片段大小；
組態一光柵掃描列寬大小；
組態一區塊像素高度大小。
實例30：如實例25至29中至少一項之方法，其進一步包括將區塊輸出影像資料作為輸出片段儲存於該儲存電路中及自該儲存電路讀取該等輸出片段之特定者以形成經光柵掃描格式化之輸出影像資料。
實例31：如實例25至30中至少一項之方法，其進一步包括至少一模板處理器對該輸入影像之至少一個二維區域操作。
實例32：如實例25至31中至少一項之方法，其中至少兩個模板處理器處理相同核心程式碼。
實例33：如實例25至32中至少一項之方法，其中至少兩個模板使影像資料特定言之垂直及/或水平重疊，且該至少一模板處理器對該等重疊模板操作。
實例34：如實例25至33中至少一項之方法，其中一資料運算單元包括具有比該執行道陣列寬之維數之一移位暫存器結構，特定言之在該執行道陣列外存在暫存器。
實例35：如實例25至34中至少一項之方法，其中一個二維移位陣列及一執行道陣列經組態以判定具有重疊模板之至少一對相鄰輸出像素值。 I/O unit for image processor As known in the art, the basic circuit structure for executing program code includes an execution stage and register space. The execution stage contains execution units for executing instructions. The input operand for an instruction to be executed is provided from the register space to the execution stage. The result of executing an instruction during the execution phase is written back to the register space. To execute a software thread on a conventional processor, a series of instructions need to be executed sequentially through the execution phase. Most commonly, the operation is "scalar" in the sense that it produces a single result from a single set of input operands. However, in the case of a "vector" processor, a result vector is generated from a vector of the input operand set by executing an instruction during the execution phase. Figure 1 shows a high-level view of a unique image processor architecture 100 that includes an execution channel array 101 coupled to a two-dimensional shift register array 102. Here, each execution channel in the execution channel array can be regarded as a discrete execution stage containing execution units required to execute the instruction set supported by the processor 100. In various embodiments, each execution channel receives a same instruction to be executed in the same machine cycle, so that the processor operates as a two-dimensional single instruction multiple data (SIMD) processor. Each execution track has its own dedicated register space in a corresponding position in the two-dimensional shift register array 102. For example, the corner execution track 103 has its own dedicated register space in the corner shift register position 104, and the corner execution track 105 has its own dedicated register space in the corner shift register position 106. Space etc. In addition, the shift register array 102 can shift its contents, so that each execution track can directly register from its own register space to the register space that resides in another execution track during a previous machine cycle. One-value operation. For example, a +1 horizontal shift causes the register space of each execution channel to receive a value from the register space of its leftmost neighbor. Due to the ability to shift the value in both the left and right directions along a horizontal axis and the value in the upper and lower directions along a vertical axis, the processor can effectively process the image data template. Here, as known in this technology, a template is used as a block of the image surface area of a basic data unit. For example, a new value for a specific pixel position in an output image can be calculated as an average of the pixel values in an area of an input image in which the specific pixel position is centered. For example, if the template has a dimension of 3 pixels×3 pixels, the specific pixel position may correspond to the middle pixel of the 3×3 pixel array, and the average value may be in all nine pixels in the 3×3 pixel array Calculated within. According to various operation embodiments of the processor 100 in FIG. 1, each execution channel of the execution channel array 101 is responsible for calculating a pixel value at a specific position in an output image. Therefore, continuing the 3×3 template averaging example just mentioned above, after the initial loading of the input pixel data in the shift register and one of the eight shift operations are coordinated with the shift sequence, the track array is executed Each execution channel receives all nine pixel values required to calculate the average value of its corresponding pixel position into its local register space. Because the processor architecture of Figure 1 is particularly good at processing image templates, it can also be called a template processor. FIG. 2 shows a high-level view of an image processor 201 having a plurality of template processors 202_1 to 202_N. Depending on the configuration of the entire processor 201, specific ones of the template processors 202_1 to 202_N directly operate on the input image data provided to the image processor 201 from an external source, and the template processors 202_1 to 202_N Others can directly operate on the output image data generated by the other of the template processors 202_1 to 202_N. As depicted in FIG. 2, a line buffer unit 205_1 that receives input image data 206 from the I/O unit 207 of the image processor is depicted. As described in further detail below, the I/O unit 207 reformats the externally provided input image data 209 to generate the input image data 206. In various embodiments, the image data 209 is provided by a camera. Once the line buffer unit 205_1 receives the input image data 206, the line buffer unit 205_1 transmits the image data 206 to one or more of the template processors 202_1 to 202_N through the network 204 for processing. As mentioned above, the template processor executes the code and usually shifts the image data in their respective two-dimensional shift registers to effectively operate the template of the image data. As mentioned above, the I/O unit 207 of the image processor is responsible for receiving input image data from a source external to the image processor (for example, a memory, such as the main memory of a computing system, a camera, etc.) 209 and forward the image data to a line buffer, which feeds the image data to a template processor that will process the image data. Similarly, the I/O unit of the image processor is also responsible for receiving output image data from any one of the line buffers 205_1 to 205_N (which receive output data from a template processor) and forwarding the output image data to a memory Body (for example, the main memory of a computing system), a display, or other components that will receive the output image data of the image processor. What’s important is that the input image data 209 of the image processor is usually formatted as a raster scan, and as described in detail above, the template processors 202_1 to 202_N automatically adjust the two-dimensional image surface or "block" (not the raster scan image). Data) operation. Therefore, the I/O unit 207 of the image processor is designed to reformat the input image data 209 from a raster scan format into a block image format. Then the input image data 206 formatted by the block image is sent from the I/O unit 207 to one or more of the line buffer units 205_1 to 205_N. Figure 3a shows a high-level view of raster scan to block formatting. Here, the boundary 301 corresponds to the entire input image to be processed. The input image data is received as, for example, a raster scan corresponding to a continuous sequence of pixels 302_1, 302_2, 302_M across the same row of the entire input image 301. Therefore, for example, after the first pixel row 302_1 of the input image is received by the image processor, the second pixel row 302_2 of the input image, etc. are received. As depicted in Fig. 3a, for example, the pixels of the same column are received in order from left to right. However, as described above, the template processor does not operate on the input image data in a raster sequence. Instead, the template processor operates on the two-dimensional surface area of the input image. Therefore, before the raster scan input data can form a two-dimensional surface area or block for consumption by a template processor, the image processor needs to receive a sufficient amount of raster scan input data. More specifically, in the depiction of FIG. 3a, it is assumed that the template processor that will process the input image data will process a block with a dimension of M pixels×M pixels. In this case, enough input data to form the first M×M block 303 exists only after the Mth pixel of the Mth input raster row has been received by the I/O unit. That is, the first block 303 is only realized at a certain time after the first M-1 input raster columns have been fully received. Once the first block 303 has been received, the first block 303 can be forwarded to a line buffer unit for processing by a template processor. Referring to FIG. 3b, after the next M (total 2M) pixels of the M-th input raster column 302_M have been received by the I/O unit, the second full block 304 is realized and can be forwarded to the line buffer unit. The process is then repeated so that each of the next M pixels of the received raster scan input data is formed and can be forwarded to an M×M surface under the line buffer unit. More specifically, after the last block of the Mth raster scan row 302_M has been received, the next group of blocks can be formed during the reception of the 2M raster scan row. Referring back to FIG. 2, in various embodiments, the I/O unit 207 includes a shared storage pool (SSP) 210 and a format conversion logic (FCL) 211 for performing the raster-to-block reformatting described above. As will be more clearly understood from the discussion that follows, the shared storage pool 210, for example, stores input raster pixels as a memory circuit that stores many (for example) data fragments of the same size. In various embodiments, a segment is a group of one or more pixels. Although in the embodiments described below, the segments are of equal size, in alternative embodiments, the segments may be of variable size. The format conversion logic 211 tracks the storage progress of the input data segment 213 in the pool, and after recognizing that the next image data block has been stored in the pool, reads the correct segment from the pool 214 to form a region The block is consumed by a template processor. 4a to 4k are more detailed descriptions of one of the reformatting operations of the I/O unit. Figure 4a shows a frame 401 corresponding to a section of an input image to be processed. For illustration purposes, assume that the input image to be processed has a width of 16 pixels and the template processor(s) that will operate on the input image will process a 4 pixel×4 pixel block image. It should be noted that the dimensions of these input images and blocks are only illustrative (the actual dimensions of these parameters are usually larger). The content in frame 401 has a dual meaning. According to a first point of view, the contents of the frame 401 show the stored fragments of the input pixel data in the shared fragment pool 210. According to a second point of view, the contents of the frame 401 display the organized index values stored by the register space 212 in the format conversion logic 211, where each index value points to a segment in which a segment is stored in the shared storage pool 210 It is in a specific location in the shared storage pool 210. The dual meaning of the content of frame 401 will be more clearly understood from the following discussion. Referring to FIG. 4a, the first segment of one of the four pixels P1 to P4 before the first raster scan row of the input image is stored in the shared storage pool 210 as a first segment. The format conversion logic 211 also stores an index value PTR_1 that points to the location where the first segment is stored in the shared storage pool (for example, its memory address) in its register space 212. 4b to 4d show the following time sequence in which the first row of the raster scan for the input image receives input pixels worth of the second, third and fourth segments. That is, the pixels P5 to P8 correspond to the corresponding pixels of a second segment at a position identified by PTR_2 stored in the register space 212 of the conversion logic, and the pixels P9 to P12 correspond to the temporary memories stored in the conversion logic The corresponding pixels of a third segment at a position identified by PTR_3 in the device space 212, and pixels P13 to P16 correspond to the corresponding pixels at a position identified by PTR_4 stored in the register space 212 of the conversion logic An equivalent pixel of the fourth segment. Recalling that the input image has a column width of 16 pixels, it should be noted that the first full row of the raster scan of the input image has been stored in the shared storage pool 210 as shown in FIG. 4d. FIG. 4e shows the state of the shared storage pool 210 and the register space 212 of the reformatting logic after the second row of the raster scan of the input image has been completely received. Here, it should be noted that the corresponding pixels for the four extra segments of pixels P17 to P32 have been consumed in the shared storage pool 210. Similarly, the four new index values PTR_5 to PTR_8 respectively pointing to these new segments in the shared storage pool 210 are stored in the register space 212 of the formatting logic. FIG. 4f shows the state of the shared storage pool 210 and the register space 212 of the reformatting logic after the third row of the raster scan of the input image has been completely received. In addition, the corresponding pixels for the other four additional segments of pixels P33 to P48 have been consumed in the shared storage pool 210. Similarly, the four new index values PTR_9 to PTR_12 respectively pointing to these new segments in the shared storage pool 210 are stored in the register space 212 of the formatting logic. Figure 4g shows that the first segment in the fourth row of the raster scan of the input image has been stored in the shared storage pool 210 and the register space 212 of the reformatting logic has been updated to include an index value PTR_13 pointing to this segment The state of the subsequent shared storage pool 210 and the register space 212 of the reformatted logic. What is important is that in the case of storing the first segment of the fourth row of input image data, the shared storage pool 210 now stores the first full-block image that can be operated by a template processor (highlighted by the shaded area 402). ). When the reformatting logic 211 recognizes that the index PTR_13 is added to the storage corresponding to the first block image 402 in its register space 212, the reformatting logic 211 continues to proceed from the shared storage pool 210 Read the contents of indicators PTR_1, PTR_5, PTR_9 and PTR_13. That is, the content of the first row of the frame 401 (which corresponds to the shaded area 402) is read from the shared storage pool 210 by the reformatting logic 211 and the content is forwarded to the line buffer unit, the line buffer The unit feeds the content to one or more template processors that will process the input image data. Corresponding to the content of the first block image read from the storage pool 210, the corresponding image data (pixels P53 to P56) of a (second) segment under the input raster scan is also stored in the shared storage pool 210. Figure 4h shows the state of the system in which the content of the first block is suitable for overwriting with new input data. That is, the indicators of the first full block 402 (the indicators PTR_1, PTR_5, PTR_9, and PTR_13) have been returned to the shared storage pool 210 or have been identified to the shared storage pool 210 in other ways, so that the shared storage pool understands The contents of these indicators have been consumed by the reformatting process and are free to be overwritten. In one embodiment, the indicators enter a free list maintained by the logic circuit of the shared storage pool 210. As part of the process of storing the latest received segment of the input image data, the shared storage pool 210 removes an indicator from the free list to assign the indicator (and its corresponding memory address in the storage pool) to the segment . FIG. 4h also shows that in the case of storing the second segment of the fourth input raster scan line, the second block (shaded area 403) consumed by a template processor has also been received. Therefore, the second row of the segment is read from the shared storage pool 210 and the corresponding indicator is returned to the free list of the storage pool. Figure 4i shows the resultant state corresponding to the third segment of the raster scan data received along the fourth row of the image (which completes the formation of the third block image for consumption by a template processor). The procedure then continues to repeat, where each next storage segment completes the next block. Figure 4j shows the state after storing the fourth segment of the fourth raster scan row. As observed in Figure 4k, after the fourth surface has been consumed, the index for the next segment (the first segment of the fifth row of raster scan data, pixels P65 to P68) can be stored in the temporary storage of the reformatting logic In the upper left corner section of the device space 212 (similar to FIG. 4a) and the whole procedure (for example) is repeated for the raster scan columns 5 to 8 of the input image. It is worth mentioning some observations about the examples just described above with reference to FIGS. 4a to 4k. First, it should be noted that the actual index value corresponding to, for example, the memory address in the shared storage pool may be random or have little or no relationship in other ways. Therefore, the fragments can be physically stored in random locations in the shared storage pool 210. The organized configuration of the stored fragments as observed in FIGS. 4a to 4k is therefore the organization of the index values in the register space 212 of the reformatting logic (e.g., the same as those stored in the shared storage pool 210). The opposite of any organization of the fragment) is one result. That is, the ability to identify block images consumed by the template processor is to reformat the logical organization of the index values in the register space 212 of the logic rather than the physical location in the storage pool 210 (where the fragments are actually stored) The result of any organization. Here, consistent with this observation, the list of storage pools can basically list indicators in random order. A second observation is that the size of a block image deemed sufficient for the template processor to consume can be larger than the template size that a template processor will use when processing the image data in the block. For example, in a more realistic embodiment that deviates from the specific dimensions used in the examples of FIGS. 4a to 4k, the execution track array and the two-dimensional shift register array have dimensions of 16×16. When the two-dimensional shift register array is fully loaded with a block image of a pixel dimension of 16×16, the execution of the track array can then continue to follow the pixel dimensions of 2×2, 3×3, 4×4 The block image is processed by the template size of any one of them. Here, the template size defines the amount of shift performed by the two-dimensional shift register. Therefore, the block identified by the reformatting logic and forwarded for processing by a template processor is more related to the size of the template used for image data processing is the shift register loaded into the template processor器Array. Another observation is that the examples described above with reference to FIGS. 4a to 4k assume that each block extracted from the storage pool by reformatting logic is sufficient to be loaded into a template processor for further operations. In various embodiments, each block extracted by reformatting logic may contain multiple blocks for loading into a template processor. For example, consider that the execution channel array and the two-dimensional shift register array have a template processor with a dimension of 8×8. Here, the reformatting logic can identify blocks with a width of 8 columns and a width of 16 pixels. In this case, the reformatting logic forwards two blocks per forwarding area for template consumption. A line buffer unit or logic associated with the template processor of the processing block divides the block into a pair of 8×8 blocks that are individually loaded into the template processor. Therefore, the size of a block extracted by the reformatting logic does not need to be the same as the dimension of the block of an image loaded into a template processor. Yet another observation is that the register space of the reformatting logic in various embodiments is configured to have a height dimension equal to the block image to be extracted. In the embodiment of FIGS. 4a to 4i, the extracted block image has a height dimension of one of four pixels. Thus, the register space 212 is organized to store four columns of indicators. In contrast, in various embodiments, the register space 212 is organized to have a length dimension equal to the dimension of the raster scan line of the input image data normalized by the fragment size. In the embodiment of FIGS. 4a to 4i, the segment size is 4 pixels and the input image data has a raster scan column dimension of 16 pixels. Therefore, the register space 212 is organized to have a length dimension of (16 pixels/column)/(4 pixels/segment)=4 segments/column. In various embodiments, the I/O unit 207 can simultaneously support multiple input video streams. That is, for example, a first raster scan image can be received and the corresponding block can be forwarded to (e.g.) a first line buffer unit, while a second raster scan image can be received and the corresponding block can be forwarded to (e.g., ) A second line buffer unit. Each such stream and corresponding reformatting for a particular line buffer unit can be referred to as a channel. Therefore, the shared storage pool 210 is a "shared" pool because its storage resources are shared by the number of live channels supported by the I/O unit 207. That is, segments of different channels are stored in the pool 210 at the same time. In the case where the I/O unit 207 is designed to handle multiple channels at the same time, the reformatting logic 211 includes a logic circuit to track the index value in the internal register space 212 for each of the channels. In various embodiments, the reformatting logic 211 includes sufficient register space 212 to handle a worst-case scenario (the maximum number of simultaneous channels has the maximum supported raster scan column pixel length and the maximum extracted block pixel height). In addition, the register space 212 resources in the reformatting logic 211 can be configured by the logic circuit configuration of the reformatting logic to realize different numbers of channels supported at the same time, different raster scan column pixel widths and/or different economics. Extract the pixel height of the block. Here, each real-time channel can be defined in the reformatting logic 211 by the configuration register space of the reformatting logic 211, and the configuration register space defines which line buffer unit will be used for a specific channel Receive the extracted blocks of the channel, the dimensions of the extracted blocks, the column pixel width of the incoming raster scan input image stream, etc. Another observation is that in the examples of FIGS. 4a to 4i, the input rate of the segment is slower than the output rate of the extracted block. More specifically, the extracted surface area data can be read from the shared storage pool 210 within an amount of time approximately corresponding to the rate at which new input pixel values of a segment are written to the shared storage pool 210. Four fragments. Figures 5a to 5i relate to another situation where the rate of reading fragments from the storage pool 210 is approximately equal to the rate of writing fragments into the storage pool. That is, for example, the rate of receiving input data is 4 times the rate of the examples in FIGS. 4a to 4i. As will be more clearly understood from the following discussion, a double buffering method is used in the register space 212 of the reformatting logic to handle a faster input data rate. Figure 5a corresponds to the state of Figure 4g when the first block can be realized from the received input raster scan data. For the convenience of drawing, the index value is not displayed in the register space of the reformatting logic. 5b to 5e show that a new segment is written to the storage pool 210 when each segment is read from the shared storage pool to be forwarded as part of a block image. That is, each of the next figures from FIGS. 5a to 5e show that the next segment is removed from the first row of the first buffer and the next segment is added along the fourth column of the first buffer 501. Therefore, when reading the fourth segment (containing pixels 49 to 52) from the first row of the first buffer 501 in FIG. 5e, the next segment (containing pixels 65 to 68) of the input data needs to be written into To the upper left corner of the second buffer 502 of the pointer register space 212 of the reformatting logic. Therefore, as will be seen in the following diagram, the next three blocks to be extracted have their equivalent indicators in the first buffer 501, but the indicator values for subsequent input data fragments will have their equivalent indicators stored in the second buffer器502中. Fig. 5f to Fig. 5h show the subsequent system state under four cycle increments. That is, FIG. 5f shows that the four segments in the second row of the first buffer 501 have been read from the shared storage pool (to construct the second block image to be forwarded to the first-line buffer unit) and the next four segments have been received The state of the system after four cycles of input data fragments and their equivalent index values have been stored in the second buffer. Figure 5g shows the four segments in the third row of the first buffer 501 that have been read from the shared storage pool (to construct the third block image to be forwarded to the line buffer unit) and the next four segments have been received The state of the system after another four cycles after an input data segment and its equivalent index values have been stored in the second buffer 502. Figure 5h shows the four segments in the fourth row of the first buffer 501 that have been read from the shared storage pool (to construct the fourth block image to be forwarded to the line buffer unit) and the next four have been received The system state after the other four cycles after inputting data fragments and storing their index values in the second buffer 502. Figure 5i shows the fifth row of image data that has been read from the shared storage pool (to construct the fifth block image to be forwarded to the buffer unit of the line) and the next four input data fragments have been received and have been waited. The indicator value is stored in the register space of the reformatted logic after another four cycles of the system state. It should be noted that the fifth row resides in the second buffer 502 and the first four rows reside in the first buffer 501. In addition, it should be noted that the fourth segment to be received (for pixels 129 to 132) has its index value stored in the upper left corner of the first buffer 501. Therefore, the progress is continued, and the index values of the next three blocks to be extracted will be stored in the second buffer 502, but the indexes for the newly input data segment will be stored in the first buffer 501. The procedure then repeats, wherein when the surface image for the fourth row of the second buffer 502 is extracted, the state of FIG. 5a is reached (in terms of the effective index concentration rather than the pixel value). Referring back to FIG. 2, after one or more template processors 202_1 to 202_N complete their respective processing of the input image data, the output image data is transferred from the template processor(s) 202 to one or more via the network 204 Corresponding line buffer units 205_1 to 205_N. The one or more line buffer units 205_1 to 205_N then forward the output image data to the I/O unit 207 of the image processor. In this case, the block is transferred from the one-line buffer unit to the I/O unit 207. The I/O unit then writes these blocks into the shared storage pool. The output data sent from the outside of the image processor can be read directly as a block or in a raster scan format. In the case where the output data is read out in the raster scan format, the block-to-raster scan conversion, which is the opposite of the input reformatting procedure discussed in detail above, is completed by a processor. That is, once a continuous number of output blocks (slice by slice) corresponding to the full width of a raster scan output row have been written into the shared storage pool, the heights equal to these blocks can be read out in sequence, slice by slice The number of columns. Figure 6 shows a method performed by an I/O unit. The method includes storing input image data received in a raster scan format as fragments in a storage circuit 601. The method also includes reformatting the input image data into a block image format 602 by reading the specific ones of the segments from the storage circuit. The method also includes using a processor including a two-dimensional execution track array and a two-dimensional shift register array to process the block image formatted input image data 603. Image processor and template processor embodiment FIG . 7 shows an embodiment of an architecture 700 for implementing an image processor in the hardware described above. The image processor may, for example, be calibrated by a compiler that converts program code written for a virtual processor in a simulation environment into program code that is actually executed by the hardware processor. As seen in Figure 7, the architecture 700 includes interconnection through a network 704 (for example, a network on chip (NOC), including a switched on chip network, a ring network on chip, or other types of networks) It is connected to a plurality of template processor units 702_1 to 702_N and a plurality of line buffer units 701_1 to 701_M corresponding to the form generator units 703_1 to 703_N. In one embodiment, any line buffer unit can be connected to any form generator and corresponding template processor through the network 704. In one embodiment, the program code is compiled and loaded onto a corresponding template processor 702 to perform image processor operations previously defined by a software developer (for example, depending on the design and implementation, the program can also be The code is loaded onto the associated form generator 703 of the template processor). In at least some examples, by loading a first core program for a first pipeline stage into a first template processor 702_1, a second core program for a second pipeline stage can be loaded To a second template processor 702_2 and so on, to implement an image processing pipeline, wherein the first core performs the function of the first stage of the pipeline, the second core performs the function of the second stage of the pipeline, and so on, and Set up additional control flow methods to transfer the output image data from one stage of the pipeline to the next stage of the pipeline. In other configurations, the image processor can be implemented as a parallel machine with two or more template processors 702_1 and 702_2 operating the same core code. For example, a highly dense and high data rate stream of image data can be processed by spreading frames across multiple template processors performing the same function. In other configurations, basically any DAG of the core can be loaded onto the hardware processor by the following steps: In the DAG design, configure each template processor with its own template processor and its own code core ; And the appropriate control flow interception program (hook) is configured into the hardware to guide the output image from one core to the input of the next core. As a general procedure, a giant I/O unit 705 receives frames of image data and transfers these frames to one or more of the line buffer units 701 frame by frame. In various embodiments in which the I/O unit 207 described in detail above implements the giant I/O unit 705, a separate frame is used as a series of image data blocks (for example, each containing the frame A different section of the image) is transferred from the giant I/O unit 705 to one or more line buffer units. A specific line buffer unit parses its image data frame into a smaller image data area (referred to as a "line group"), and then transmits the line group to a specific form generator through the network 704. A complete or "full" single-line group can, for example, be composed of multiple continuous complete rows or rows of data in a frame (for brevity, this manual will mainly refer to continuous rows). The form generator further analyzes the line group of image data into a smaller image data area (called a "form"), and submits the form to its corresponding template processor. In the case of an image processing pipeline or a DAG process with a single input, generally speaking, the input frame is directed to the same line buffer unit 701_1, which parses the image data into line groups And guide the isoline group to the form generator 703_1, and the corresponding template processor 702_1 of the form generator 703_1 executes the code of the first core in the pipeline/DAG. After completing the operation of the template processor 702_1 on the line group processed by it, the form generator 703_1 sends the output line group to a "downstream" line buffer unit 701_2 (in some use cases, the output line group can be The group is sent back to the same line buffer unit 701_1 that has previously sent the input line group). Represents one or more "consumer" cores in the next stage/operation in the pipeline/DAG that executes on its own other form generators and template processors (for example, form generator 703_2 and template processor 702_2) Then, the image data generated by the first template processor 702_1 is received from the downstream line buffer unit 701_2. In this way, a "producer" core operating on a first template processor forwards its output data to a "consumer" core operating on a second template processor, where the consumer core is based on the overall The pipeline or DAG is designed to execute the next set of tasks after the producer core. A template processor 702 is designed to process multiple overlapping templates of image data at the same time. The internal hardware processing capabilities of the multiple overlapping templates and the template processor effectively determine the size of a form. Here, in a template processor 702, a number of execution track arrays are combined to simultaneously process the surface area of the image data covered by the multiple overlapping templates. As will be described in more detail below, in various embodiments, several image data sheets are loaded into a two-dimensional register array structure in the template processor 702. It is believed that the use of the form and two-dimensional shift register array structure by moving a large amount of data into a large amount of register space as (for example) a single load operation (immediately after that by an array pair The data directly performs processing tasks) and effectively provides power consumption improvements. In addition, using an array of execution channels and a corresponding register array provides different template sizes that can be easily programmed/configured. FIGS. 8a to 8e show a high-level analysis activity of a line buffer unit 701, a finer-grained analysis activity of a form generator unit 703, and a template processing activity of a template processor 702 coupled to the form generator unit 703. The examples are illustrated. FIG. 8a depicts an embodiment of an input frame of image data 801. Figure 8a also depicts an outline of three overlapping templates 802 (each having a dimension of 3 pixels x 3 pixels) on which a template processor is designed to operate. The output pixels for which each template generates output image data are highlighted in pure black. For brevity, the three overlapping templates 802 are depicted as overlapping only in the vertical direction. It should be realized that, in fact, a template processor can be designed to have overlapping templates in both vertical and horizontal directions. Due to the vertically overlapping templates 802 in the template processor, as seen in FIG. 8a, there is a large amount of image data that a single template processor can manipulate in the frame. As will be discussed in more detail below, in one embodiment, the template processor processes the data in its overlapping templates in one way across the image data from left to right (and then repeats from top to bottom for the next set of lines) ). Therefore, when the template processor continues to perform its operations, the number of pure black output pixel blocks will increase horizontally to the right. As discussed above, the one-line buffer unit 701 is responsible for parsing a line group of input image data from an incoming frame that is sufficient for the template processor to operate on an extended number of upcoming loops. An exemplary depiction of a line group is shown as a shaded area 803. In an embodiment, the line buffer unit 701 can be understood to be used for sending a line group to a form generator or receiving a line group from a form generator. For example, according to a mode (referred to as "full group"), a complete full-width image data line is transferred between a line buffer unit and a form generator. According to a second mode (referred to as "actually high"), a line group is initially delivered as a subset of the full width column. Then pass the remaining columns sequentially in smaller (less than full width) fragments. In the case that the line group 803 of the input image data has been defined by the line buffer unit and transferred to the form generator unit, the form generator unit further parses the line group into the hardware of the template processor more accurately Restricted more refined form. More specifically, as will be described in further detail below, in one embodiment, each template processor is composed of a two-dimensional shift register array. The two-dimensional shift register array basically shifts the image data "below" an array of execution tracks, where the pattern of the shift causes each execution track to operate on the data in its own template (ie, each execution The channel processes its own information template to produce an output for that template). In one embodiment, the form is "filled" or otherwise loaded into the surface area of the two-dimensional shift register array with input image data. As will be described in more detail below, in various embodiments, there are actually multiple layers of two-dimensional register data that can be shifted in any cycle. For convenience, most of the description of the present invention will only use the term "two-dimensional shift register" and the like to refer to the two-dimensional register data with one or more of these layers that can be shifted. structure. Therefore, as observed in Figure 8b, the form generator parses an initial form 804 from the line group 803 and provides it to the template processor (here, the data form corresponds to the shaded area generally identified by the symbol 804 ). As seen in FIGS. 8c and 8d, the template processor operates on the form of input image data by effectively moving the overlapping template 802 from left to right above the form. As of FIG. 8d, the number of pixels for which an output value can be calculated from the data in the sheet is exhausted (other pixel positions may not have an output value from the information in the sheet). For the sake of brevity, the border area of the image has been ignored. As observed in Figure 8e, the form generator then provides the next form 805 to the template processor to continue the operation. It should be noted that the initial position of the template when it starts to operate on the next form is a process from the depletion point on the first form (as depicted in the previous figure 8d) to the lower right. Regarding the new form 805, the template will simply continue to move to the right while the template processor operates on the new form in the same manner as the first form. It should be noted that due to the boundary area surrounding an output pixel location of the template, there is some overlap between the data of the first form 804 and the data of the second form 805. The overlap can be handled simply by retransmitting the overlap data twice by the form generator. In alternate implementations, to feed the next form to the template processor, the form generator can continue to send only new data to the template processor and the template processor reuses the overlapping data from the previous form. Figure 9a shows an embodiment of a template processor architecture 900. As observed in FIG. 9a, the template processor includes a data operation unit 901, a scalar processor 902 and associated memory 903, and an I/O unit 904. The data operation unit 901 includes an execution channel array 905, a two-dimensional shift array structure 906, and separate random access memories 907 (including memories 907-1 to 907-R) associated with specific rows or rows of the array. The I/O unit 904 is responsible for loading the "input" data form received from the form generator into the data operation unit 901 and storing the "output" data form from the template processor in the form generator. In one embodiment, loading the form data into the data arithmetic unit 901 requires parsing a received form into rows/rows of image data and loading the rows/rows of image data into a two-dimensional shift register structure 906 or the respective random access memory 907 of the row/row of the execution channel array (described in more detail below). If the form is first loaded into the memory 907, the individual execution channels in the execution channel array 905 can then load the form data from the random access memory 907 into the two-dimensional shift register structure 906 when appropriate (For example, as a load command immediately before the operation on the form data). After loading a data form into the register structure 906 (either directly from a form generator or from memory 907), the execution path of the execution path array 905 operates on the data and finally takes the completed data as a The form is directly "written back" to the form generator or to the random access memory 907. If it is the latter, the I/O unit 904 extracts data from the random access memory 907 to form an output form, which is then forwarded to the form generator. The scalar processor 902 includes a program controller 909. The program controller 909 reads the instructions of the program code of the template processor from the scalar memory 903 and sends the instructions to the execution channels in the execution channel array 905. In one embodiment, a single identical command is broadcast to all execution channels in the array 905 to achieve a SIMD-like behavior from the data operation unit 901. In one embodiment, the instruction format of the instruction read from the scalar memory 903 and issued to the execution channel of the execution channel array 905 includes a very long instruction word (VLIW) format, which includes more than one operation per instruction code. In another embodiment, the VLIW format includes an ALU operation code that guides the execution of a mathematical function by the ALU of each execution channel (as described below, in one embodiment, it can specify more than one traditional ALU operation) and a Memory operation code (which guides a specific execution channel or a memory operation in a group of execution channels). The term "execution track" refers to a group of one or more execution units capable of executing an instruction (for example, a logic circuit that can execute an instruction). However, in various embodiments, an execution track may include more similar processor functionality than just execution units. For example, in addition to one or more execution units, an execution track may also include a logic circuit that decodes a received instruction or (in more MIMD-like designs) a logic circuit that extracts and decodes an instruction. Regarding MIMD-like methods, although a centralized program control method has been described to a greater extent in this article, a more distributed method can be implemented in various alternative embodiments (for example, including the code in each execution channel of the array 905 and A program controller). The combination of an execution channel array 905, a program controller 909, and a two-dimensional shift register structure 906 provides a widely adaptable/configurable hardware platform for a wide range of programmable functions. For example, considering that individual execution channels can perform a wide range of functions and can easily access input image data close to any output array position, application software developers can program a wide range of different functional capabilities and dimensions (such as The core of template size). In addition to serving as a data storage for the image data operated by the channel array 905, the random access memory 907 can also hold one or more look-up tables. In various embodiments, one or more scalar lookup tables can also be instantiated in the scalar memory 903. A scalar search involves sending the same data value from the same lookup table of the same index to each of the execution channels in the execution channel array 905. In various embodiments, the VLIW instruction format described above is extended to also include a scalar operation code, which will be directed to a scalar lookup table by a lookup operation performed by the scalar processor. The index specified to be used in conjunction with the operation code can be an immediate operand or extracted from some other data storage location. In any case, in one embodiment, searching from one of the scalar look-up tables in the scalar memory essentially involves propagating the same data value to all the execution channels in the execution channel array 905 during the same clock cycle. Additional details on the use and operation of the lookup table are provided below. Figure 9b outlines the VLIW instruction block embodiment(s) discussed above. As observed in Figure 9b, the VLIW instruction block format includes three separate instruction fields: 1) a scalar instruction 951, which is executed by the scalar processor; 2) an ALU instruction 952, which is executed by the scalar processor The respective ALUs in the array are propagated and executed in the SIMD mode; and 3) a memory instruction 953, which is propagated and executed in a part of the SIMD mode (for example, if the execution channels along the same row in the execution channel array share the same random When accessing the memory, one execution track from each of the different rows actually executes the instruction (the format of the memory command 953 may include an operand that identifies which execution track from each row executes the instruction)). It also contains a field 954 of one or more immediate operands. Which immediate operation element information is used by which command 951, 952, 953 can be identified in the command format. Each of the commands 951, 952, and 953 also includes its own input operands and information obtained (for example, a local register for ALU operations and a local register for memory access commands and A memory address). In one embodiment, the scalar instruction 951 is executed by the scalar processor before any one of the other instructions 952, 953 in the execution channel array is executed. That is, the execution of the VLIW block includes the execution of the first cycle of one of the scalar instructions 951, followed by the second cycle of one of the other instructions 952, 953 (It should be noted that in various embodiments, the instructions 952 and 953). In one embodiment, the scalar command executed by the scalar processor includes the one issued to the form generator to load the form from the memory of the data operation unit or the 2D shift register/store the form to the data operation unit Commands in memory or 2D shift register. Here, the operation of the sheet generator may depend on the operation of the line buffer unit or other variables that prevent the sheet generator from completing the run time of the number of loops that will take any command issued by the scalar processor. Therefore, in one embodiment, any VLIW block (whose scalar command 951 corresponds to or otherwise causes a command to be issued to the form generator) also includes the no-operation (NOOP) in the other two command fields 952, 953 instruction. The program code then enters one of the NOOP commands in the command fields 952 and 953 until the form generator completes its loading to the data arithmetic unit/storing from the data arithmetic unit. Here, after sending a command to the form generator, the scalar processor can set the form generator to reset a bit of an interlock register after completing the command. During the NOOP loop, the scalar processor monitors the bits of the interlock register. When the scalar processor detects that the form generator has completed its command, normal execution begins again. FIG. 10 shows an embodiment of a data computing component 1001. As observed in FIG. 10, the data computing component 1001 includes an execution track array 1005 logically positioned "above" the two-dimensional shift register array structure 1006. As discussed above, in various embodiments, a form of image data provided by a form generator is loaded into the two-dimensional shift register 1006. The execution path then operates on the form data from the register structure 1006. The execution track array 1005 and the shift register structure 1006 are fixed in position relative to each other. However, the data in the shift register array 1006 is shifted in a strategic and coordinated manner to result in a different template in the processing data of each execution track in the execution track array. Therefore, the output image value of a different pixel in the output sheet generated by each execution track is determined. From the architecture of FIG. 10, it should be understood that the overlapping templates are not only vertically arranged but also horizontally arranged, because the execution track array 1005 includes vertically adjacent execution tracks and horizontally adjacent execution tracks. Some notable architectural features of the data arithmetic unit 1001 include a shift register structure 1006 having a dimension wider than that of the execution track array 1005. That is, there is a "halo" 1009 of one of the registers outside the execution track array 1005. Although the halo 1009 is shown as being present on both sides of the execution track array, depending on the implementation, the halo may exist on fewer (one) or more (three or four) sides of the execution track array 1005 . When the data is shifted "below" the execution track 1005, the halo 1009 is used to provide "spillover" space for the data that overflows outside the boundary of the execution track array 1005. As a simple case, when a 5×5 template centered on the right edge of the execution track array 1005 is processed at the leftmost pixel of the template, four further halo register positions to the right will be required. For ease of drawing, when in a nominal embodiment, the registers on either side (right side, bottom side) will have both horizontal and vertical connections, Figure 10 shows the registers on the right side of the halo In order to have only the horizontal shift connection and the register on the bottom side of the halo is shown as having only the vertical shift connection. In various embodiments, the halo area does not include corresponding execution logic for executing image processing instructions (for example, there is no ALU). However, individual memory access units (M) exist in each of the locations of the halo area, so that the individual locations of the halo register can individually load data from the memory and store data to the memory. Additional overflow space is provided by random access memory 1007 (including memory 1007-1 to 1007-R) coupled to each row and/or row or part of the array (for example, a random access memory can be Assigned to one of the “zones” of the execution lane array that spans 4 execution lane rows and 2 execution lane rows. For simplicity, the rest of this application will mainly refer to the allocation scheme based on rows and/or rows.) Here If the core operation of an execution channel requires it to process the pixel values outside the two-dimensional shift register array 1006 (some image processing routines may require this), the image data plane can, for example, further overflow from the halo area 1009 to random Access memory 1007. For example, consider a 6×6 template in which the hardware includes a halo area of only one of the four storage elements on the right edge of the execution channel array on the right side of the execution channel. In this case, the data will need to be shifted further to the right of the right edge of the halo 1009 to fully process the template. The data shifted outside the halo area 1009 will then overflow to the random access memory 1007. The following further provides other applications of the random access memory 1007 and template processor of FIG. 9. Figures 11a to 11k show working examples of one of the ways of shifting image data in the two-dimensional shift register array "below" the execution track array as mentioned above. As observed in FIG. 11a, the data content of the two-dimensional shift array is depicted in a first array 1107 and the execution track array is depicted by a frame 1105. Moreover, two adjacent execution lanes 1110 in the execution lane array are simply depicted. In this simplified depiction 1110, each execution track includes data that can be received from a shift register, output from an ALU (for example, represented as an accumulator across cycles), or output data is written to an output destination One of the ground registers R1. Each execution channel can also obtain the contents "below" in the two-dimensional shift array in a local register R2. Therefore, R1 is a physical register of the execution track, and R2 is a physical register of the two-dimensional shift register array. The execution path includes an ALU that can perform operations on the operands provided by R1 and/or R2. As will be described in more detail below, in one embodiment, multiple memory/register elements per array position (one of the "depth") are actually used to implement the shift register, but the shift activity is limited to One plane of the storage element (for example, only one plane of the storage element can be shifted every cycle). Figures 11a-11k depict one of these deeper register locations as used to store the result X from the respective execution channel. For ease of illustration, the deeper registers are drawn side by side with their corresponding registers R2 instead of below their corresponding registers R2. Figures 11a to 11k focus on the calculation of two templates, and the center positions of the two templates are aligned with the pair of execution track positions 1111 depicted in the execution track array. For ease of illustration, the pair of execution paths 1110 are drawn horizontally adjacent, in fact, when according to the following example, they are equal vertically adjacent. As first observed in Figure 11a, the execution path is centered on its isocentric template position. Figure 11b shows the purpose code executed by two execution channels. As observed in Figure 11b, the code of the two execution channels causes the data in the shift register array to be shifted down by one position and to the right by one position. This aligns the two execution tracks to the upper left corner of their respective templates. The code then causes the data located in their respective positions (in R2) to be loaded into R1. As observed in Figure 11c, the code then causes the pair of execution channels to shift the data in the shift register array by one unit to the left, which causes the values on the right side of the respective positions of each execution channel to be shifted to each execution The position of Tao. The value in R1 (previous value) is then added to the new value that has been shifted to the position of the execution path (in R2). The result is written into R1. As observed in Figure 11d, repeat the same procedure as described above for Figure 11c, which results in the result that R1 now contains the value A+B+C in the upper execution channel and F+G+H in the lower execution channel. At this point, the two execution channels have processed their respective templates listed above. It should be noted that overflow into a halo area on the left side of the execution channel array (if a halo area exists on the left-hand side) or into the random access memory (if a halo area does not exist in the execution channel array) On the left hand side). As observed in Figure 11e, the code then causes the data in the shift register array to shift upward by one unit, which causes the two execution tracks to align with the right edge of the middle row of their respective templates. The register R1 of the two execution paths currently contains the sum of the rightmost values of the top row and the middle row of the template. Figures 11f and 11g show the continuous progress of moving the middle column of the template across two execution paths to the left. Cumulative addition continues, so that at the end of the processing of FIG. 11g, the two execution paths contain the sum of the values of the top and middle columns of their respective templates. Figure 11h shows another shift that aligns the bottommost of each execution track with its corresponding template. Fig. 11i and Fig. 11j show the continuous shift of the process of completing the process of the template of two execution paths. Figure 11k shows the extra shift that aligns each execution track with its correct position in the data array and writes the result to it. In the examples of FIGS. 11a to 11k, it should be noted that the object code used for the shift operation may include an instruction format that identifies the direction and magnitude of the shift expressed in the (X, Y) coordinates. For example, the purpose code used to shift up one position can be expressed as SHIFT 0,+1 in the purpose code. As another example, shifting one position to the right can be expressed as SHIFT +1,0 in the destination code. In various embodiments, a shift with a larger magnitude (for example, SHIFT 0, +2) can also be specified in the destination code. Here, if the 2D shift register hardware only supports one position shift per cycle, the instruction can be interpreted by the machine as requiring multiple cycles to execute, or the 2D shift register hardware can be designed to support More than one position shift per cycle. The latter embodiment is described in further detail below. Fig. 12 shows another more detailed depiction of the cell used for an execution track and corresponding shift register structure (in various embodiments, the register in the halo area does not include a corresponding execution track but includes a memory Body unit). In one embodiment, the execution track and register space associated with each position in the execution track array are implemented by exemplifying the circuit observed in FIG. 12 at each node of the execution track array. As observed in FIG. 12, the unit cell includes an execution track 1201 coupled to a register file 1202 composed of four registers R2 to R5. During any cycle, the execution track 1201 can be read from any one of the registers R1 to R5 or written to any one of the registers R1 to R5. For instructions that require two input operands, the execution channel can retrieve two operands from any one of R1 to R5. In one embodiment, by allowing the contents of any (only) one of the registers R2 to R4 to be "out" to its neighboring register through the output multiplexer 1203 during a single cycle The contents of one of the registers R2 to R4 (only) one of the registers R2 to R4 are replaced with the contents moved "in" from one of its neighbors through the input multiplexer 1204, so that The shift between neighbors is in the same direction (for example, all execution channels are shifted to the left, all execution channels are shifted to the right, etc.) to implement a two-dimensional shift register structure. Although it is common for a same register to move its contents out and replace it with contents moved in in the same cycle, the multiplexer configurations 1203, 1204 allow different movements in one of the same register files during the same cycle. Bit source and shift target register. As depicted in FIG. 12, it should be noted that during a shift sequence, an execution track will move content from its register file 1202 to each of its left, right, top, and bottom neighbors. Combined with the same shift sequence, the execution track will also move the content from one of its left, right, top, and bottom neighbors into its register file. Furthermore, the move-out target and the move-in source should be the same shift direction as one of all execution tracks (for example, if the move-out is to the right adjacent one, then the move-in should be from the left adjacent one). Although in one embodiment, the contents of only one register is allowed to be shifted per execution track per cycle, other embodiments may allow the contents of more than one register to be shifted in/out. For example, if the second example of one of the multiplexer circuits 1203, 1204 observed in FIG. 12 is incorporated into the design of FIG. 12, the contents of the two registers can be moved out/in during the same cycle. Of course, in an embodiment in which only one register content is allowed to be shifted per cycle, multiple temporary registers can occur between mathematical operations by consuming more clock cycles for shifting between mathematical operations. Shifting of registers (for example, shifting the contents of two registers between mathematical operations by consuming two shift operations between mathematical operations). If less than all the contents of the register file of one execution track are removed during a shift sequence, it should be noted that the contents of the non-moving register of each execution track remain in place (unshifted). Therefore, any unshifted content that has not been replaced with shifted content remains at the local end of the execution track across the shift cycle. The memory unit ("M") observed in each execution channel is used to load/store data into the random access memory space associated with the row and/or row of the execution channel in the execution channel array Random access memory space. Here, the M unit serves as a standard M unit, where it is usually used to load/store data that cannot be loaded/stored into the own register space of the execution channel. In various embodiments, the main operation of the M unit is to write data from a local register to the memory and read data from the memory and write it to a local register. Regarding the ISA operation codes supported by the ALU unit of the hardware execution channel 1201, in various embodiments, the mathematical operation codes supported by the hardware ALU include (for example, ADD, SUB, MOV, MUL, MAD, ABS, DIV, SHL, SHR, MIN/MAX, SEL, AND, OR, XOR, NOT). As described above, the execution channel 1201 can execute memory access commands to retrieve data from/store data to their associated random access memory. In addition, the hardware execution channel 1201 supports shift operation instructions (right, left, up, down) to shift data in the two-dimensional shift register structure. As described above, to a large extent, the scalar processor of the template processor executes the program control instructions. G. Implementation Examples It should be pointed out that the various image processor architecture features described above are not necessarily limited to image processing in the traditional sense and therefore can be applied to other applications that may (or may not) lead to recharacterization of the image processor. For example, if any of the various image processor architecture features described above are to be used to create and/or generate and/or present animations (as opposed to processing actual camera images), the image processor can be characterized as a graphic Processing unit. In addition, the features of the image processor architecture described above can be applied to other technical applications, such as video processing, visual processing, image recognition, and/or machine learning. Applied in this way, the image processor can be integrated (for example as a co-processor) with a more general-purpose processor (for example, it is a CPU or part of a computing system) or can be an independent process within a computing system Device. The hardware design embodiments discussed above can be embodied in a semiconductor chip and/or embodied as a description of a circuit design with a semiconductor manufacturing process as the ultimate goal. In the latter case, these circuit descriptions can use a (for example, VHDL or Verilog) register transfer level (RTL) circuit description, a gate-level circuit description, a transistor-level circuit description or mask description or Various combinations of such forms. The circuit description is usually embodied on a computer-readable storage medium (such as a CD-ROM or other types of storage technology). It should be realized from the foregoing chapters that an image processor as described above can be embodied in the hardware on a computer system (for example, as a system on a chip (SOC) of a handheld device that processes data from a camera of a handheld device). section). In the case where the image processor is embodied as a hardware circuit, it should be noted that the image data processed by the image processor can be directly received from a camera. Here, the image processor can be part of a discrete camera or part of a computing system with an integrated camera. In the latter case, the image data can be directly received from the camera or the system memory of the self-computing system (for example, the camera sends its image data to the system memory instead of the image processor). It should also be noted that many of the features described in the previous section can be applied to a graphics processor unit (which presents animation). Figure 13 provides an illustrative depiction of a computing system. Many of the components of the computing system described below can be applied to a computing system with an integrated camera and associated image processor (for example, a handheld device such as a smart phone or tablet). The average technician will be able to easily distinguish the two. In addition, the computing system of FIG. 13 also includes many features of a high-performance computing system (such as a workstation or supercomputer). As observed in FIG. 13, the basic computing system may include a central processing unit 1301 (which may include, for example, a plurality of general processing cores 1315_1 to 1315_N and a main memory controller arranged on a multi-core processor or application processor 1317), system memory 1302, a display 1303 (such as touch screens, tablets), a local wired point-to-point link (such as USB) interface 1304, various network I/O functions 1305 (such as Ethernet interface And/or cellular modem subsystem), a wireless local area network (for example, WiFi) interface 1306, a wireless point-to-point link (for example, Bluetooth) interface 1307 and a global positioning system interface 1308, various sensors 1309_1 To 1309_N, one or more cameras 1310, a battery 1311, a power management control unit 1312, a speaker and microphone 1313, and an audio encoder/decoder 1314. An application processor or multi-core processor 1350 may include one or more general processing cores 1315, one or more graphics processing units 1316, and a memory management function 1317 (for example, a memory controller) in the CPU 1301. , An I/O control function 1318 and an image processing unit 1319. The general processing core 1315 usually executes the operating system and application software of the computing system. The graphics processing unit 1316 usually performs graphics intensive functions such as generating graphics information for presentation on the display 1303. The memory control function 1317 interfaces with the system memory 1302 to write data to the system memory 1302/read data from the system memory 1302. The power management control unit 1312 generally controls the power consumption of the system 1300. The image processing unit 1319 can be implemented according to any one of the image processing unit embodiments described in detail in the previous section above. Alternatively or in combination, the IPU 1319 may be coupled to either or both of the GPU 1316 and the CPU 1301 as one of the co-processors. Additionally, in various embodiments, GPU 1316 may be implemented using any of the image processor features described in detail above. Each of the touch screen display 1303, communication interfaces 1304 to 1307, GPS interface 1308, sensor 1309, camera 1310, and speaker/microphone codec 1313, 1314 can be regarded as relevant to the entire computing system (and also includes Various forms of I/O (input and/or output) of an integrated peripheral device (for example, one or more cameras 1310). Depending on the implementation, each of these I/O components can be integrated on the application processor/multi-core processor 1350 or can be located outside the die or outside the package of the application processor/multi-core processor 1350. In one embodiment, the one or more cameras 1310 include a depth camera capable of measuring the depth between the camera and an object in the field of view. Application software, operating system software, device driver software, and/or one of the general-purpose CPU cores of an application processor or other processors (or other functional blocks with an instruction execution pipeline used to execute code) The firmware can perform any of the functions described above. The embodiments of the present invention may include various procedures as stated above. The program can be embodied as machine executable instructions. Instructions can be used to cause a general or special purpose processor to execute certain programs. Alternatively, these processes can be executed by specific hardware components containing hard-wired and/or programmable logic for executing the programs, or by any combination of programmed computer components and custom hardware components. The elements of the present invention can also be provided as a machine-readable medium for storing machine-executable instructions. Machine-readable media may include (but are not limited to) floppy disks, optical disks, CD-ROM and magneto-optical disks, FLASH memory, ROM, RAM, EPROM, EEPROM, magnetic or optical cards, communication media, or other suitable for storing electronic instructions Type of media/machine-readable media. For example, the present invention can be downloaded as a computer program that can be transmitted from a remote computer via a communication link (for example, a modem or a network connection) through a data signal embodied in a carrier wave or other propagation medium (For example, a server) to a requesting computer (for example, a client). In the foregoing specification, the invention has been described with reference to specific exemplary embodiments of the invention. However, it will be obvious that various modifications and changes can be made without departing from the broader spirit and scope of the present invention as stated in the scope of the appended invention application. Therefore, the description and the drawings should be regarded as an illustrative meaning rather than a restrictive meaning. Some illustrative examples are given below. Example 1: An image processor comprising: a storage circuit for storing fragments of input image data received from a camera in a raster scan format; a reformatting circuit for storing the input image data And other fragments are converted into a block image format; a processor, which includes a two-dimensional execution track array and a two-dimensional shift register array, the two-dimensional shift register array is used to store the area that has been formatted The input image data in the block image format, and the execution track array is used to execute instructions for operating the image data from the two-dimensional shift register array. Example 2: The image processor of Example 1, wherein the reformatting circuit includes a register space for storing pointers to the segments of the input image data. Example 3: The image processor of example 1 or 2, wherein the indicators are organized in the register space to have a column width and a first dimension corresponding to the raster scan format and have a first dimension corresponding to the block The format is one pixel height and one second dimension. Example 4: The image processor of at least one of Examples 1 to 3, wherein the reformatting circuit is used to identify when a block of the input image data has been stored in the storage circuit and cause the temporary The indicators in the memory space are read from the storage circuit and the segment corresponding to the block in the storage circuit. Example 5: The image processor of at least one of Examples 1 to 4, wherein the reformatting circuit supports any of the following: configurable fragment size; configurable raster scan column width; configurable The pixel height of the block. Example 6: The image processor of at least one of Examples 1 to 5, wherein the reformatting circuit is also used to perform raster scan conversion from output block images to output images. Example 7: The image processor of at least one of Examples 1 to 6, wherein the reformatting circuit supports multiple raster scan to block image conversion channels. Example 8: The image processor of at least one of the foregoing examples, further comprising at least one template processor configured to operate on at least one two-dimensional area of the input image. Example 9: The image processor of at least one of the preceding examples, wherein at least two template processors are configured to process the same core code. Example 10: The image processor of at least one of the preceding examples, wherein at least two templates make the image data specifically overlap vertically and/or horizontally, and the at least one template processor is configured to operate on the overlapping templates . Example 11: The image processor of at least one of the foregoing examples, wherein one of the data arithmetic units includes a shift register structure having a dimension wider than the execution track array, in particular, exists outside the execution track array Scratchpad. Example 12: The image processor as in at least one of the foregoing examples, wherein a two-dimensional shift array and an execution track array are configured to determine at least a pair of adjacent output pixel values with overlapping templates. Example 13: A computing system including: a) one or more general-purpose processor cores; b) a system memory; c) a memory controller coupled to the system memory; d) a camera; e ) An image processor including the following i), ii) and iii): i) A storage circuit for storing fragments of input image data received from the camera in a raster scan format; ii) A reformatting A circuit for converting the segments of the input image data into a block image format; iii) a processor including a two-dimensional execution track array and a two-dimensional shift register array, the two-dimensional shift The register array is used to store the input image data that has been formatted into the block image format, and the execution track array is used to execute instructions for operating the image data from the two-dimensional shift register array. Example 14: The operating system of Example 13, wherein the reformatting circuit includes a register space for storing pointers to the segments of the input image data. Example 15: The computing system of example 13 or 14, wherein the indicators are organized in the register space to have a column width and a first dimension corresponding to the raster scan format and have a format corresponding to the block One pixel height and one second dimension. Example 16: The computing system of at least one of Examples 13 to 15, wherein the reformatting circuit is used to identify when a block of the input image data has been stored in the storage circuit and cause the temporary storage by referring to The indicators in the device space are read from the storage circuit and the segment corresponding to the block in the storage circuit. Example 17: A computing system such as at least one of Examples 13 to 16, wherein the reformatting circuit supports any of the following: configurable fragment size; configurable raster scan column width; configurable area The pixel height of the block. Example 18: The computing system of at least one of Examples 13 to 17, wherein the reformatting circuit is also used to perform the raster scan conversion of the output block image to the output image. Example 19: The computing system of at least one of Examples 13 to 18, wherein the reformatting circuit supports multiple raster scan to block image conversion channels. Example 20: The computing system of at least one of Examples 13 to 19, which further includes at least one template processor for operating at least one two-dimensional area of the input image. Example 21: The computing system of at least one of Examples 13 to 20, wherein at least two template processors are configured to process the same core code. Example 22: The computing system of at least one of Examples 13 to 21, wherein at least two templates make the image data specifically overlap vertically and/or horizontally, and the at least one template processor is configured to operate on the overlapping templates. Example 23: The operating system of at least one of Examples 13 to 22, wherein one of the data operating units includes a shift register structure having a dimension wider than the execution track array, in particular outside the execution track array There is a scratchpad. Example 24: The operating system as in at least one of Examples 13 to 23, wherein a two-dimensional shift array and an execution track array are configured to determine at least a pair of adjacent output pixel values with overlapping templates. Example 25: A method comprising: storing input image data received from a camera in a raster scan format as fragments in a storage circuit; and inputting the input by reading specific ones of the fragments from the storage circuit The image data is reformatted into a block image format; and, a processor including a two-dimensional execution track array and a two-dimensional shift register array is used to process the input image data formatted by the block image. Example 26: The method of Example 25, which further includes storing the pointers to the segments of the input image data in the register space. Example 27: The method of Example 25 or 26, wherein the indicators are organized in the register space to have a first dimension corresponding to a column width of the raster scan format and a first dimension corresponding to the block format One second dimension of one pixel height. Example 28: The method of at least one of Examples 25 to 27, wherein the reformatting further includes identifying when a block of the input image data has been stored in the storage circuit and caused by reference to the register space The indicators of the storage circuit are read from the storage circuit corresponding to the segment of the block. Example 29: The method of at least one of Examples 25 to 28, which further includes performing any one of the following to perform the reformatting: configuring a fragment size; configuring a raster scan column width size; configuring The pixel height of a block. Example 30: The method of at least one of Examples 25 to 29, which further includes storing the block output image data as output fragments in the storage circuit and reading specific ones of the output fragments from the storage circuit to form a Raster scan formatted output image data. Example 31: The method of at least one of Examples 25 to 30, further comprising at least one template processor operating on at least one two-dimensional area of the input image. Example 32: The method of at least one of Examples 25 to 31, wherein at least two template processors process the same core code. Example 33: The method of at least one of Examples 25 to 32, wherein at least two templates make the image data specifically overlap vertically and/or horizontally, and the at least one template processor operates on the overlapping templates. Example 34: The method of at least one of Examples 25 to 33, wherein a data arithmetic unit includes a shift register structure having a dimension wider than the execution track array, in particular, exists outside the execution track array Scratchpad. Example 35: The method of at least one of Examples 25 to 34, wherein a two-dimensional shift array and an execution track array are configured to determine at least a pair of adjacent output pixel values with overlapping templates.