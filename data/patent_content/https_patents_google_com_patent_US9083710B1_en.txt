US9083710B1 - Server load balancing using minimally disruptive hash tables - Google Patents
Server load balancing using minimally disruptive hash tables Download PDFInfo
- Publication number
- US9083710B1 US9083710B1 US13/342,493 US201213342493A US9083710B1 US 9083710 B1 US9083710 B1 US 9083710B1 US 201213342493 A US201213342493 A US 201213342493A US 9083710 B1 US9083710 B1 US 9083710B1
- Authority
- US
- United States
- Prior art keywords
- hash table
- hash
- server
- buckets
- network packet
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active, expires
Links
Images
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L67/00—Network arrangements or protocols for supporting network services or applications
- H04L67/01—Protocols
- H04L67/10—Protocols in which an application is distributed across nodes in the network
- H04L67/1001—Protocols in which an application is distributed across nodes in the network for accessing one among a plurality of replicated servers
- H04L67/1004—Server selection for load balancing
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L47/00—Traffic control in data switching networks
- H04L47/10—Flow control; Congestion control
- H04L47/12—Avoiding congestion; Recovering from congestion
- H04L47/125—Avoiding congestion; Recovering from congestion by balancing the load, e.g. traffic engineering
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L67/00—Network arrangements or protocols for supporting network services or applications
- H04L67/01—Protocols
- H04L67/10—Protocols in which an application is distributed across nodes in the network
- H04L67/1001—Protocols in which an application is distributed across nodes in the network for accessing one among a plurality of replicated servers
-
- H04L67/1002—
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L67/00—Network arrangements or protocols for supporting network services or applications
- H04L67/01—Protocols
- H04L67/10—Protocols in which an application is distributed across nodes in the network
- H04L67/1001—Protocols in which an application is distributed across nodes in the network for accessing one among a plurality of replicated servers
- H04L67/1004—Server selection for load balancing
- H04L67/1008—Server selection for load balancing based on parameters of servers, e.g. available memory or workload
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L67/00—Network arrangements or protocols for supporting network services or applications
- H04L67/01—Protocols
- H04L67/10—Protocols in which an application is distributed across nodes in the network
- H04L67/1001—Protocols in which an application is distributed across nodes in the network for accessing one among a plurality of replicated servers
- H04L67/1004—Server selection for load balancing
- H04L67/1023—Server selection for load balancing based on a hash applied to IP addresses or costs
Definitions
- the present invention relates in general to server load balancing and in particular to server load balancing using minimally disruptive hash tables.
- Server load balancing is the process of distributing network traffic among servers for processing.
- the distributed network traffic can include stateful or stateless traffic.
- Stateful network traffic can be organized into network flows, each of which typically are consistently handled by one server to avoid disruptions in service.
- Stateful network traffic can include, for example, TCP/IP traffic or traffic to a website that stores state information about a particular “session” (i.e. a webmail application). To the contrary, stateless traffic does not have to be handled consistently by one server.
- Stateless network traffic can include, for example, UDP/IP traffic or domain name system (DNS) query traffic.
- DNS domain name system
- hash tables are data structures used by computing devices to store elements of data.
- hash tables store elements in hash table buckets. Elements are stored in the hash table buckets and are accessed and inserted using a hash function.
- a hash function takes as input in one example a key associated with a particular element.
- the output of the hash function is a hash table index associated with a hash table bucket.
- the hash table index can be used to identify which hash table bucket to read an element from or insert an element into.
- One aspect of the disclosed embodiments is a method of load balancing a plurality of network packets among a plurality of servers using a minimally disruptive hash table.
- the method includes identifying a plurality of elements, each element corresponding to at least one of the plurality of servers, inserting at least two of the identified plurality of elements into the minimally disruptive hash table so that at least some of the hash table buckets each include one of the plurality of elements, receiving one of the plurality of network packets, determining a hash table index for the received network packet using a hash function, identifying an element stored in a hash table bucket corresponding to the hash table index, and transmitting the received network packet to a server corresponding to the identified element.
- the computing system includes at least one memory and at least one processor.
- the processor is configured to execute instructions stored in the at least one memory to identify a plurality of elements, each element corresponding to at least one of the plurality of servers, insert at least two of the identified plurality of elements into the minimally disruptive hash table so that at least some of the hash table buckets each include one of the plurality of elements, receive one of the plurality of network packets, determine a hash table index for the received network packet using a hash function, identify an element stored in a hash table bucket corresponding to the hash table index, and transmit the received network packet to a server corresponding to the identified element.
- Another aspect of the disclosed embodiments is a computer-readable medium having computer-executable instructions for performing a method of load balancing a plurality of network packets among a plurality of servers using a minimally disruptive hash table, wherein the instructions include identifying a plurality of elements, each element corresponding to at least one of the plurality of servers, inserting at least two of the identified plurality of elements into the minimally disruptive hash table so that at least some of the hash table buckets each include one of the plurality of elements, receiving one of the plurality of network packets, determining a hash table index for the received network packet using a hash function, identifying an element stored in a hash table bucket corresponding to the hash table index, and transmitting the received network packet to a server corresponding to the identified element.
- FIG. 1 is a diagram of a computing scheme according to embodiments of the disclosed subject matter
- FIGS. 2A and 2B are block diagrams of one exemplary hash table that requires refactoring when elements are added or removed;
- FIGS. 3A and 3B are block diagrams of one exemplary minimally disruptive hash table that does not require refactoring when elements are added or removed according to embodiments of the disclosed subject matter;
- FIG. 4 is a flowchart of a technique of searching for an element in a minimally disruptive hash table according to embodiments of the disclosed subject matter
- FIG. 5 is a flowchart of one exemplary technique of adding an element to a minimally disruptive hash table according to embodiments of the disclosed subject matter
- FIG. 6 is a flowchart of another exemplary technique of adding an element to a minimally disruptive hash table according to embodiments of the disclosed subject matter
- FIG. 7 is a flowchart of one exemplary technique of removing an element from a minimally disruptive hash table according to embodiments of the disclosed subject matter
- FIG. 8 is a flowchart of another exemplary technique of removing an element from a minimally disruptive hash table according to embodiments of the disclosed subject matter
- FIG. 9 is a flowchart of a technique of adding a server to a server load balancing hash table according to embodiments of the disclosed subject matter.
- FIG. 10 is a flowchart of a technique of removing a server from a server load balancing hash table according to embodiments of the disclosed subject matter.
- FIG. 11 is a block diagram of an exemplary minimally disruptive hash table used for server load balancing according to embodiments of the disclosed subject matter.
- Server load balancing for stateful network traffic can be controlled using a type of session state table.
- a session state table includes an entry for each network flow including identifying information of the network flow and a server to which that network flow is directed.
- a load balancer device can perform a lookup in the session state table for each network packet received to determine the appropriate destination server for that packet.
- session state tables can consume a large amount of memory. For example, a session state table capable of storing four million IPv4 sessions would require at least 120 MB of memory.
- session state tables can increase latency, because a search for an entry associated each network packet received and transmitted must be performed. If, for example, the session state table includes four million entries, this search can be quite expensive in time and resources.
- session state tables are prone to denial of service attacks. For example, a session state table can be filled with “garbage” packet flows that fill up the session state table to capacity (e.g. TCP SYN attacks).
- TCP SYN attacks e.g. TCP SYN attacks
- Described herein are techniques for server load balancing that maintain the state of most packet flows without requiring use of a session state table.
- the disclosed techniques are generally stateless while maintaining stateful network traffic.
- These techniques make use of a minimally disruptive hash table.
- the minimally disruptive hash table maps received network packets to one or more destination servers.
- Minimally disruptive hash tables minimize disruptions of key value (i.e. network packet and/or packet flow identifier) to element (i.e. server) associations when elements are added to and deleted from the hash table.
- Minimally disruptive hash tables are described in additional detail later.
- a minimally disruptive hash table for load balancing can improve at least some of the potential disadvantages of session state tables described above.
- the hash table load balancing techniques require less memory, since the hash table need only include entries corresponding to each server, instead of entries capable of uniquely identifying each session. For example, a hash table containing ten thousand server entries could utilize as little as 200 KB of memory.
- the use of hash tables can improve latency, since hash tables have the property of constant time searches.
- hash tables do not store the state of any packet flows, they are immune to typical denial of service attacks. The above attributes of using hash tables can contribute to reduced power consumption, reduced physical footprint, reduced cost, and/or improved reliability.
- Server indirection tables and multiple hash functions can also be used to optimize operation of these load balancing techniques.
- the techniques described herein can be combined with the use of session state tables. For example, load balancing can be performed using a minimally disruptive hash table until a new server is added to the hash table that disrupts a small number of packet flows. Instead of allowing the small number of packet flows to be disrupted, those packet flows can be added to a session state table. These packet flows will be load balanced using the session state table instead of the hash table. As these packet flows are stopped, the session state table can be automatically shrunk over time as new packet flows are handled using the hash table.
- the load balancer device can be configured to use either the hash table techniques or session state table techniques based on the type of network packet and/or packet flow.
- the load balancer device can be configured to use session state techniques to load balance a network application having high sensitivity to session state (i.e. voice over internet protocol (VoIP) services), whereas all other network traffic is load balanced using minimally disruptive hash table techniques.
- VoIP voice over internet protocol
- FIG. 1 is a diagram of a computing scheme 10 according to embodiments of the disclosed subject matter.
- An exemplary load balancer device 12 can be, for example, a computer having an internal configuration of hardware including a processor such as a central processing unit (CPU) 14 and a memory 16 .
- CPU 14 can be a controller for controlling the operations of computing device 12 .
- the CPU 14 is connected to memory 16 by, for example, a memory bus.
- Memory 16 can include random access memory (RAM) or any other suitable memory device.
- RAM random access memory
- Memory 16 can store data and program instructions which are used by the CPU 14 .
- Load balancer device 12 can take the form of any suitable computing device, such as network routers or switches. Other suitable implementations of load balancer device 12 are possible.
- Load balancer device 12 can be connected to an external network 18 .
- Load balancer device 12 can be configured to receive network traffic from external network 18 .
- the received network traffic can be processed using at least some of the techniques described herein and then transmitted to a server in server group 20 , such as servers 22 a - c .
- servers 22 a - c can include CPU 24 a - c and memory 26 a - c . Additional servers can be included in server group 20 .
- load balancer device 12 receives all network traffic destined for any server in server group 20 .
- load balancer device 12 can encapsulate that network packet into a container packet and forward the container packet to the identified server.
- the container packet can include a header having one or more addresses of the identified server that enables transmission of the network packet to the identified server while keeping the network packet intact.
- computing device is understood to include any combination or implementation of computing devices, computing device groups, or any other configuration of computing devices.
- Other implementations of the computing scheme 10 are possible, and components can be added, removed, modified, or replaced in various implementations.
- load balancer device 12 is implemented using multiple interconnected computing devices.
- FIG. 1 depicts that processors 14 , 24 a - c and memory 16 , 26 a - c are integrated into single units, this depiction is exemplary only.
- the operations of load balancer device 12 and/or servers 22 a - c can be distributed across multiple processors on the same machine or different machines or across a network such as a local area network, wide area network or the Internet and the terms “load balancer” and “server” can encompass such multi-machine systems.
- Memories 16 , 26 a - c can also be integral units (such as the RAM within a computer) or can be distributed across multiple machines such as a network-based memory or memory in multiple machines performing the operations of load balancer device 12 and/or servers 22 a - c.
- FIGS. 2-8 are related to the minimally disruptive hash tables used for the server load balancing techniques described herein.
- Hash tables have various uses in computing systems.
- a hash table is utilized to associate a key value to an element stored in a hash bucket in the hash table. For example, this association can be used in networking routers and switches for routing packets in a network. In many such applications, it is desirable for a particular key to remain associated with the same element after the initial association.
- a hash function is used.
- the hash function is configured to have a number of output values equal to the number of hash buckets included in the hash table so that any possible key value can be associated with a hash bucket using the hash function.
- the hash table is refactored (i.e. the number of hash buckets change)
- a significant number of associations between hash buckets and key values will change. The change is because the hash function will have to be adjusted so that the total possible outputs of the hash function will be equal to the new number of hash buckets in the hash table.
- a minimally disruptive hash table where changing a number of elements stored within the hash table does not require refactoring the hash table.
- a minimally disruptive hash table is created with a number of hash buckets greater than or equal to a maximum expected count of elements to be stored in the hash table over period in which the hash table is used. The maximum expected count can be application dependent and, for example, can be determined automatically when the hash table is created or can be pre-determined.
- Elements added to the hash table are distributed throughout the available hash buckets. The distribution of elements within the hash table can be equally or unequally weighted. For example, if equally weighted, each element will be targeted to occupy an equal number of hash buckets. As another example, if unequally weighted, each element can have an associated weight that controls a number of hash buckets that each element is targeted to occupy.
- FIGS. 2A and 2B are block diagrams of one exemplary hash table that requires refactoring when elements are added or removed according to embodiments of the disclosed subject matter.
- ECMP IP routing can be used to select a network path for each packet sent through a device by selecting adjacent network connections (i.e. adjacency) to transmit each packet through.
- Network packets are typically associated with a packet flow, which is, for example, a sequence of packets sent from a source application to a destination application.
- each packet flow it is desirable for the transmission of each packet flow to be maintained on a consistent network path to avoid reordering of packets within the packet flow. For example, the performance of some applications and protocols (such as TCP) can be degraded when packets in a flow are reordered.
- a hash table 30 a is shown having two hash buckets.
- the hash buckets include elements associated with “Adjacency 1 ” and “Adjacency 2 .”
- the hash buckets of hash table 30 a are accessed by way of hash table indexes 32 a .
- hash table indexes 32 a include “Hash table index 0 ” and “Hash table index 1 ” which are each associated with one of the hash buckets.
- a hash function 34 a is used to convert a key value 36 to one of the hash table indexes 32 a .
- the key value 36 is a destination IP address of a packet to be routed using ECMP.
- other key values may be used, such as a combination of source and destination IP addresses.
- Routing table 38 a contains exemplary key values, hash table indexes 32 a , and hash bucket elements from hash table 30 a associated with the hash table indexes 32 a based on hash function 34 a .
- key (destination IP) 10.1.0.1 is associated with hash table index 0 and hash bucket (adjacency) 1
- key (destination IP) 10.1.0.2 is associated with hash table index 1 and hash bucket (adjacency) 2 .
- the remaining keys similarly alternate association with the two hash buckets.
- Hash table 30 b is shown having four hash buckets.
- Hash table 30 b is an example of hash table 30 a being refactored (i.e. resized) from two hash buckets to four hash buckets. This can be done, for example, when a number of adjacencies changes.
- hash table indexes 32 b include in addition to 32 a a “Hash table index 2 ” and “Hash table index 3 .”
- Hash table indexes 32 b are each associated with one of the hash buckets.
- a hash function 34 b is used to convert a key value 36 to one of the hash table indexes 32 b .
- Hash function 34 b can be a modification of hash function 34 a configured to produce four output values (hash table indexes) instead of two output values (hash table indexes).
- Routing table 38 b contains exemplary key values, hash table indexes 32 b , and hash bucket elements from hash table 30 b associated with the hash table indexes 32 b based on hash function 34 b .
- key (destination IP) 10.1.0.1 is now associated with hash table index 1 and hash bucket (adjacency) 2
- key (destination IP) 10.1.0.2 is associated with hash table index 2 and hash bucket (adjacency) 3 .
- the remaining keys alternate association with the four hash buckets now included in hash table 30 b.
- routing table 38 b the adjacency associated with each key (destination IP) has changed because of the refactoring of the hash table.
- destination IP destination IP
- the associations that are maintained (if any) will depend on numerous implementation specific factors, including the size of the hash table, number of hash buckets added or deleted, and the hash function utilized. For example, a hash function having a poor output distribution over the hash buckets may retain more associations than another hash function having a good output distribution.
- FIGS. 3A and 3B are block diagrams of one exemplary minimally disruptive hash table that does not require refactoring when elements are added or removed according to embodiments of the disclosed subject matter. Similar to FIGS. 2A and 2B , FIGS. 3A and 3B depict a hash table usable for ECMP IP routing. However, unlike FIGS. 2A and 2B , FIGS. 3A and 3B illustrate the use of a minimally disruptive hash table to avoid unnecessary changes in the associations between keys and hash buckets when adding or removing elements from the hash table.
- a minimally disruptive hash table 50 a is shown having eight hash buckets.
- the hash buckets include two distinct elements associated with “Adjacency 1 ” and “Adjacency 2 .” The two distinct elements are distributed throughout the hash buckets.
- the hash buckets of minimally disruptive hash table 50 a are accessed by way of hash table indexes 52 .
- hash table indexes 52 include indexes from 0 to 7 which are each associated with one of the hash buckets.
- a hash function 54 is used to convert a key value 56 to one of the hash table indexes 52 .
- the key value 56 is a destination IP address of a packet to be routed using ECMP.
- other key values may be used, such as a combination of source and destination IP addresses.
- hash table 50 a The distinct elements included in hash table 50 a are distributed throughout the table using techniques such as those described later with respect to FIGS. 5-8 .
- the “Adjacency 1 ” element is stored in hash buckets associated with hash table indexes 0 and 5 - 7 .
- the “Adjacency 2 ” element is stored in hash buckets associated with hash table indexes 1 - 4 .
- Routing table 58 a contains exemplary key values, hash table indexes 52 , and hash bucket elements from hash table 50 a associated with the hash table indexes 52 based on hash function 54 .
- key (destination IP) 10.1.0.1 is associated with hash table index 0 and hash bucket 0 (adjacency 1 )
- key (destination IP) 10.1.0.2 is associated with hash table index 1 and hash bucket 1 (adjacency 2 ).
- the remaining keys are similarly associated with one of the eight hash buckets and one of the two adjacencies.
- a minimally disruptive hash table 50 b is shown having eight hash buckets, similar to minimally disruptive hash table 50 a .
- Hash table 50 b is an illustrative example of adding an element to hash table 50 a without refactoring hash table 50 a . Techniques for adding an element to a minimally disruptive hash table are described further with respect to FIGS. 5-6 .
- hash table indexes 52 include indexes from 0 to 7 which are each associated with one of the hash buckets.
- a hash function 54 is used to convert a key value 56 to one of the hash table indexes 52 .
- hash table 50 a The distinct elements included in hash table 50 a are distributed throughout the table using techniques such as those described later with respect to FIGS. 5-8 .
- the “Adjacency 1 ” element is stored in hash buckets associated with hash table indexes 0 and 6 - 7 .
- the “Adjacency 2 ” element is stored in hash buckets associated with hash table indexes 1 - 3 .
- the new “Adjacency 3 ” element is stored in hash buckets associated with hash table indexes 4 and 5 .
- Routing table 58 b contains exemplary key values, hash table indexes 52 , and hash bucket elements from hash table 50 a associated with the hash table indexes 52 based on hash function 54 .
- key (destination IP) 10.1.0.1 is still associated with hash table index 0 and hash bucket 0 (adjacency 1 )
- key (destination IP) 10.1.0.2 is still associated with hash table index 1 and hash bucket 1 (adjacency 2 ).
- the only key to element associations that are changed are those associated with hash table indexes 4 and 5 . The remaining key to element associations are maintained.
- the number of key to element associations impacted by a change to a minimally disruptive hash table can be expressed mathematically.
- a number of hash buckets x changed when adding y elements can be expressed using formula 1:
- FIG. 4 is a flowchart of a technique of searching for an element in a minimally disruptive hash table according to embodiments of the disclosed subject matter.
- a key value is identified for the hash table lookup.
- the key value can be any value associated with a packet or other piece of data to be associated with an element stored in a minimally disruptive hash table.
- One exemplary key value is an IP address.
- other values and combinations of values can be used for the key value.
- a hash for the key value is determined at stage 74 .
- the hash can be determined using a hash function, such as hash function 54 described earlier. After the hash is determined, it is used to lookup an element from the hash table at stage 76 .
- FIG. 5 is a flowchart of one exemplary technique 90 of adding an element to a minimally disruptive hash table according to embodiments of the disclosed subject matter.
- a key value associated with a new element E n to be inserted is identified. Similar to the search techniques described above, the key value can be any value associated with the new element E n or any combination of values.
- the key value for an adjacency could be the index number of that adjacency (i.e. 1 or 2).
- Hash I n is determined at stage 94 for the identified key value.
- Hash I n can be determined using any hash function.
- variables needed for technique 90 are initialized.
- the variable STORED_COUNT can be initialized to zero.
- the variable STORED_COUNT represents a total count of hash table indexes associated with hash buckets in which the new element E n is inserted.
- an original element E o is read from the hash table from hash table index I n .
- element E c is read from the hash table from hash table index I n .
- E o is maintained throughout technique 90 as an indication of the first element replaced in the hash table.
- E c is updated in each iteration of technique 90 as E n is inserted in hash buckets of the hash table and as I n is incremented.
- E c is tested to see if it is NULL (or has a similar property, such as being empty). If E c is NULL, control passes to stage 108 , which is described later. If E c is not NULL, control passes to stage 104 , where STORED_COUNT is compared to a threshold. The threshold controls how many hash buckets into which the new element E n is inserted.
- the threshold can be determined in a number of different ways.
- the threshold can be calculated so that each element in the hash table preferably occupies an equal number of hash buckets.
- the threshold T E i for an element E i can be determined by dividing the total number of hash buckets in the hash table (N) by the number of elements stored in the hash table (e).
- the threshold can be determined using a weight w i . With a weight, each element can be targeted to occupy a different proportion of the hash buckets of the hash table.
- the threshold can be calculated as follows:
- T E i ⁇ w i ⁇ w , i ⁇ ( N ⁇ % ⁇ e ) w i ⁇ w + 1 , i ⁇ ( N ⁇ % ⁇ e ) ; wherein ⁇ ( 2 ) ⁇ w is the sum of the weights of all of the elements stored in the hash table.
- E o and E c are compared at stage 106 . If E o and E c are the same element, control passes to stage 108 .
- E n is stored in the hash table at hash table index I n .
- I n is incremented. Incrementing can mean any change in I n that points the incremented I n to the next hash bucket in the hash table.
- the incrementing can include a modulus operation that loops the value I n back to the first hash table index of the hash table once the last hash bucket of the hash table is reached.
- STORED_COUNT is incremented at stage 112 . Control then passes back to stage 100 .
- Technique 90 completes when the STORED_COUNT is greater than the threshold at stage 106 or if E o and E c are not the same element at stage 108 .
- FIG. 6 is a flowchart of another exemplary technique 120 of adding an element to a minimally disruptive hash table according to embodiments of the disclosed subject matter.
- the hash table is checked to see if it is empty. If it is empty, control passes to stage 124 , where a new element E n is inserted into all hash buckets of the hash table. Technique 120 is then completed.
- the key value can be any value associated with the new element E n or any combination of values.
- the key value for an adjacency could be the index number of that adjacency (i.e. 1 or 2).
- variables needed for technique 90 are initialized.
- the variable STORED_COUNT can be initialized to zero.
- the variable STORED_COUNT tracks the number of hash buckets in which the new element E n is inserted.
- STORED_COUNT is compared to a threshold at stage 130 .
- the threshold controls how many hash buckets into which the new element E n is inserted. The threshold can be determined as previously described with respect to technique 90 .
- stage 132 If the STORED_COUNT is less than the threshold, control passes to stage 132 , where a hash I n is determined for a (key value, STORED_COUNT) tuple. STORED_COUNT is added to the input of the hash function in order to distribute entries of the new element E n throughout the hash table.
- E n is stored in a hash bucket of the hash table associated with hash table index I n .
- stage 136 STORED_COUNT is incremented. Then, control returns to stage 130 . With respect to stage 130 , once the STORED_COUNT is greater than the threshold, technique 120 completes.
- Techniques 90 and 120 as described and shown are only two possible implementations of adding elements to a minimally disruptive hash table. Other techniques are possible, including those that add, remove, modify, or replace stages of techniques 90 and 120 .
- stage 106 of technique 90 can be omitted.
- stages 122 and 124 of technique 120 can be omitted.
- FIG. 7 is a flowchart of one exemplary technique 150 of removing an element from a minimally disruptive hash table according to embodiments of the disclosed subject matter.
- Technique 150 generally can be used with a hash table that uses technique 90 for adding elements.
- a key value associated with the old element E o to be removed is identified. Similar to the techniques described above, the key value can be any value associated with the old element E o or any combination of values.
- the key value for an adjacency could be the index number of that adjacency (i.e. 1 or 2).
- a hash I o is determined at stage 154 for the identified key value.
- Hash I o can be determined using any hash function.
- I o is compared to zero. If I o is not zero, control passes to stage 158 , where replacement element E r is read from the hash bucket corresponding to hash table index I o ⁇ 1. Otherwise, if I o is zero, control passes to stage 160 , where replacement element E r is read from the hash bucket corresponding to hash table index N ⁇ 1. In other words, the replacement element E r corresponds to the element stored before the element to be removed E o in the hash table.
- E r is compared to E o . If they are equal, E r is set to NULL (or other indication of an empty value) at stage 164 . If they are not equal control passes directly to stage 166 .
- current element E c is read from the hash bucket corresponding to hash table index I o .
- E c is compared to E o . If they are equal, control passes to stage 170 , where E r is stored in the hash table in the hash bucket corresponding to hash table index I o .
- hash table index I o is incremented. As described above with respect to I n , the incrementing of I o can include a modulus operation so that when I o reaches the end of the hash table, the next value of I o will correspond to the beginning of the hash table.
- Control then passes back to stage 166 .
- Stages 166 through 172 are performed iteratively until E c does not equal E o at stage 168 , at which point technique 150 completes.
- FIG. 8 is a flowchart of another exemplary technique 180 of removing an element from a minimally disruptive hash table according to embodiments of the disclosed subject matter.
- Technique 180 generally can be used with a hash table that uses technique 120 for adding elements.
- variables needed for technique 90 are initialized.
- the variable DELETE_COUNT can be initialized to zero.
- the variable DELETE_COUNT tracks the number of hash buckets from which the old element E o is removed.
- a key value associated with the old element E o to be removed is identified. Similar to the techniques described above, the key value can be any value associated with the new element E o or any combination of values.
- the key value for an adjacency could be the index number of that adjacency (i.e. 1 or 2).
- STORED_COUNT is compared to DELETE_COUNT.
- STORED_COUNT can be an input to technique 180 and is an indication of a number of hash buckets in which E o is stored.
- STORED_COUNT can be determined from values stored in memory that indicate a number of hash buckets that each element of the hash table occupies. For example, the values stored in memory can be updated on each add and remove operation on the hash table.
- the STORED_COUNT of an element can be determined on demand when a remove operation is to be performed.
- stage 188 If STORED_COUNT is not equal to DELETE_COUNT, control passes to stage 188 .
- a hash I o is determined for a (key value, DELETE_COUNT) tuple. DELETE_COUNT is added to the input of the hash function in order to find the entries of the element E o that were stored throughout the hash table when E o was added to the hash table (for example, by use of technique 90 ).
- stage 190 current element E c is read from the hash bucket associated with hash table index I o .
- E c is compared to E o . If E c is equal to E o , control passes to stage 194 . Otherwise, stage 194 is skipped and control passes to stage 196 .
- replacement element E r is stored in the hash table in a hash bucket associated with index I o .
- Replacement element E r can be an input to technique 180 .
- the replacement element E r can be selected based on a loading of the hash table.
- loading means a comparison between a number of hash table buckets in which a given element is stored in the hash table as compared to an ideal number of buckets that the given element would ideally be stored in based on a total number of hash table buckets and the weight associated with the given element.
- DELETE_COUNT is incremented. Control then returns to stage 186 . Technique 180 continues until STORED_COUNT is equal to DELETE_COUNT at stage 186 , at which point technique 180 completes.
- Exemplary hash functions usable within the techniques herein can include primitive polynomials such as cyclic redundancy check (CRC) functions or cryptographic functions such as MD5 functions.
- Specific functions include but are not limited to modulo, pseudo modulo, XOR, folded XOR, CRC4, CRC8, CRC16, CRC24, CRC32, MD5, Elliptic Curve Signing, SHA1, and SHA256.
- Suitable hash functions include those providing good distribution across all of the hash table buckets, those having uncorrelated distributions, fast execution times, and small memory requirements. However, any hash function can be utilized.
- a transformed hash function can be used to reduce the number of hash table buckets actually stored in memory.
- a hash table can be created with 2 32 (4,294,967,295) hash table buckets.
- Such a hash table could utilize a CRC32 (32 bit CRC) hash function to generate hash table indexes associated with the hash table buckets. If only a relatively small number of elements are to be stored in the hash table at a given time, it can be advantageous to store only a portion of the hash table buckets in physical memory in order to improve processing efficiency and to reduce memory utilization.
- the hash function can be transformed so that the range of the hash function output is reduced to cover only a portion of the hash table buckets.
- the output of the hash function can be truncated.
- the output function can be truncated to 8 bits.
- the most significant 24 bits of the hash function output are set to zero (discarded). In this case only 2 8 hash table buckets would be stored in memory.
- the hash table still logically has 2 32 hash table buckets, just 2 24 of those hash table buckets would not be stored in memory and the key values that would normally be associated with those non-stored hash table buckets instead are associated with (redirected to) stored hash table buckets.
- the transformation is changed so that the range of the transformed hash function output is increased.
- the change in transformation maintains the association between key values and stored elements.
- the truncation of the output function could be changed to 9 bits instead of 8 bits. In this case, 2 9 hash table buckets would be now stored in memory.
- the additional hash table buckets stored in memory are interleaved with the previously stored hash table buckets, with each additional hash table bucket being associated with one previously stored hash table bucket.
- the additional hash table buckets are initialized with an element by copying the element stored in the previously stored hash table bucket associated with each additional hash table bucket. Accordingly, the change in the number of hash table buckets stored in memory does not affect the key value to element associations of the hash table.
- FIGS. 9-11 are related to server load balancing using minimally disruptive hash tables as described previously.
- the server load balancing hash table described below is an implementation of a minimally disruptive hash table.
- FIG. 9 is a flowchart of a technique 210 of adding a server to a server load balancing hash table according to embodiments of the disclosed subject matter.
- an external identifier of a server S to be inserted into the server load balancing hash table is identified.
- the external identifier can be any identifier that enables identification of and/or access to the server S n .
- the external identifier can be a network address (e.g. IP address) or a network name (e.g. DNS computer name).
- S n is a replacement server or an additional server to be added to the server load balancing hash table. This determination can be made based on an input to technique 210 . If the server S n is not a replacement, control passes to stage 216 , where a new indirection identifier is determined for S n .
- the indirection identifier is related to a server indirection table used to map the external identifiers of servers into the server load balancing hash table. For example, each entry in the server indirection table can include an external identifier of a server and an indirection identifier of the server. The indirection identifier is used in the server load balancing hash table.
- the indirection identifier of S n is inserted into the server load balancing hash table using an insertion technique.
- technique 90 or technique 120 can be utilized.
- Other similar techniques can also be utilized.
- S n is associated with the indirection identifier of S r by replacing S r in the server indirection table.
- the replacement server can be a hot-spare server.
- replacing a server does not require any changes to the server load balancing hash table since only the indirection identifier is reallocated to the new server.
- technique 210 completes.
- server indirection table can be omitted and additional and replacement servers can be inserted directly into the server load balancing hash table.
- stage 218 and its associated insert technique can be modified to distribute any disruption caused by the insertion over time. For example, if S n is to be inserted with a target weight w, S n can first be inserted using an initial weight, such as w/10. Additional insertions using a fraction of weight w can be performed over a period of time until the total insertions equal the target weight w that is desired. Such a phased-in process can distribute any disruption seen to network flows distributed out over time. This process can also be utilized in conjunction with a temporary session state table as described earlier.
- FIG. 10 is a flowchart of a technique 240 of removing a server from a server load balancing hash table according to embodiments of the disclosed subject matter.
- an external identifier of a server S o to be deleted is identified.
- the external identifier can be supplied as input to technique 240 .
- an indirection identifier is determined for the server S o .
- the indirection identifier can be determined by a lookup of the external identifier in the server indirection table.
- stage 246 it is determined whether S o is to be replaced or simply removed from the server load balancing hash table. If S o is to be removed, control passes to stage 248 , where the indirection identifier is deleted (removed) from the server load balancing hash table using a deletion (removal) technique. For example, technique 150 or technique 180 can be utilized. Other similar techniques can also be utilized. Once the indirection identifier of S o is removed, technique 240 completes.
- S r is associated with the indirection identifier of S o by replacing S o in the server indirection table.
- replacing a server does not require any changes to the server load balancing hash table since only the indirection identifier is reallocated to the replacement server.
- technique 250 completes.
- the server indirection table can be omitted and if a server is replaced instead of removed, an identifier of the replacement server can be inserted directly into the server load balancing hash table.
- FIG. 11 is a block diagram of an exemplary server load balancing hash table 270 used for server load balancing according to embodiments of the disclosed subject matter.
- server load balancing hash table 270 is an implementation of a minimally disruptive hash table.
- Server load balancing hash table 270 as shown utilizes techniques similar to technique 90 and 150 .
- Server load balancing hash table 270 includes a number of hash table buckets that store indirection identifiers of a number of servers.
- a first hash table bucket 272 includes an indirection identifier associated with a server “S 2 .”
- First hash table bucket 272 is the first bucket storing an indirection identifier associated with server “S 2 ” and is followed by a number of intermediate hash table buckets 274 and a last hash table bucket 276 also storing the indirection identifier of server “S 2 .”
- Indirection identifiers associated with servers are added to and removed from server load balancing hash table 270 using hash function 2 as shown by operation 278 .
- Hash function 2 is used to identify a hash table index of the server load balancing hash table 270 where indirection identifiers are to be added or removed.
- an addition 279 for a new indirection identifier (e.g. “S 9 ”) can be performed using technique 210 and technique 90 .
- first hash table bucket 280 , intermediate hash table buckets 282 , and last hash table bucket 284 all include indirection identifier “S 8 ” before addition 279 is completed. After addition 279 is completed, at least some of the intermediate hash table buckets 282 and the last hash table bucket 284 will include new indirection identifier “S 9 .”
- Incoming network traffic can be assigned to servers using operation 286 which is a search operation using hash function 1 .
- Operation 286 can take as input, for example, Key 1 288 and Key 2 292 .
- Key 1 288 and Key 2 292 can each be, for example, a tuple of data representing an incoming network packet. In one example, a tuple including the source IP address, destination IP address, protocol type, source port, and destination port is used.
- the values used for the key typically will have the characteristic of maintaining their values over all network packets within a network flow.
- the hash functions used for operation 278 and operation 286 can be different.
- the hash function selected for each can be varied due to the different inputs to operation 278 and operation 286 and/or to tailor the properties of the hash function to optimize each of operation 278 and operation 286 . In some circumstances a same or similar hash function can be used.
- Search 290 uses a hash of Key 1 288 to identify an indirection identifier (element) stored in a hash table bucket.
- the indirection identifier is “S 2 .”
- the indirection identifier “S 2 ” can be looked up in the indirection table to obtain an external identifier for the server associated with indirection identifier “S 2 ” so that the network packet can be forwarded and/or routed to that server.
- search 294 uses a hash of Key 2 290 to also identify an indirection identifier stored in a hash table bucket.
- the indirection identifier is “S 8 ” before addition 279 and “S 9 ” after addition 279 .
- the indirection identifier “S 8 ” or “S 9 ” can be looked up in the indirection table to obtain an external identifier for the server associated with the retrieved indirection identifier so that the network packet can be forwarded to the appropriate server.
- Search 294 illustrates a use-case where an addition of a server to hash table 270 results in a disassociation between a key (i.e. Key 2 290 ) and its associated server.
- any disassociations are limited to the hash tables in which the new server is added (e.g. the cross-hatched hash table buckets 282 , 284 ). Such disassociations can be avoided or lessened by the use of temporary session state table(s) as described earlier.
- load balancing device 12 and/or servers 22 a - c can be realized in hardware including, for example, computers, IP cores, application-specific integrated circuits (ASICs), programmable logic arrays, optical processors, programmable logic controllers, microcode, firmware, microcontrollers, computing devices, microprocessors, digital signal processors or any other suitable circuit.
- ASICs application-specific integrated circuits
- processors should be understood as encompassing any the foregoing hardware, either singly or in combination.
- signal and “data” are used interchangeably.
- portions of load balancing device 12 and/or servers 22 a - c do not necessarily have to be implemented in the same manner.
- load balancing device 12 and/or servers 22 a - c can be implemented using a general purpose computer/processor with a computer program that, when executed, carries out any of the respective techniques, algorithms and/or instructions described herein.
- a special purpose computer/processor can be utilized which can contain specialized hardware for carrying out any of the techniques, algorithms, or instructions described herein.
- Implementations or portions of implementations of the above disclosures can take the form of a computer program product accessible from, for example, a computer-usable or computer-readable medium.
- a computer-usable or computer-readable medium can be any device that can, for example, tangibly contain, store, communicate, or transport a program or data structure for use by or in connection with any processor.
- the medium can be, for example, an electronic, magnetic, optical, electromagnetic, or a semiconductor device. Other suitable mediums are also available.
- Such computer-usable or computer-readable media can be referred to as non-transitory memory or media, and may include RAM or other volatile memory or storage devices that may change over time.
Abstract
Description
e is a number of elements stored in the hash table before adding the y new elements;
% is the modulo operator; and
N is a total number of hash buckets in the hash table.
Σw is the sum of the weights of all of the elements stored in the hash table.
Claims (20)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/342,493 US9083710B1 (en) | 2012-01-03 | 2012-01-03 | Server load balancing using minimally disruptive hash tables |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/342,493 US9083710B1 (en) | 2012-01-03 | 2012-01-03 | Server load balancing using minimally disruptive hash tables |
Publications (1)
Publication Number | Publication Date |
---|---|
US9083710B1 true US9083710B1 (en) | 2015-07-14 |
Family
ID=53506882
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/342,493 Active 2033-02-07 US9083710B1 (en) | 2012-01-03 | 2012-01-03 | Server load balancing using minimally disruptive hash tables |
Country Status (1)
Country | Link |
---|---|
US (1) | US9083710B1 (en) |
Cited By (23)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20140310391A1 (en) * | 2013-04-16 | 2014-10-16 | Amazon Technologies, Inc. | Multipath routing in a distributed load balancer |
US20160182378A1 (en) * | 2014-12-18 | 2016-06-23 | Telefonaktiebolaget L M Ericsson (Publ) | Method and system for load balancing in a software-defined networking (sdn) system upon server reconfiguration |
US9571400B1 (en) * | 2014-02-25 | 2017-02-14 | Google Inc. | Weighted load balancing in a multistage network using hierarchical ECMP |
US9935831B1 (en) * | 2014-06-03 | 2018-04-03 | Big Switch Networks, Inc. | Systems and methods for controlling network switches using a switch modeling interface at a controller |
CN108667730A (en) * | 2018-04-17 | 2018-10-16 | 东软集团股份有限公司 | Message forwarding method, device, storage medium based on load balancing and equipment |
US20190179851A1 (en) * | 2009-05-29 | 2019-06-13 | Inscape Data Inc. | Systems and methods for addressing a media database using distance associative hashing |
US20190199789A1 (en) * | 2017-12-22 | 2019-06-27 | At&T Intellectual Property I, L.P. | Distributed Stateful Load Balancer |
CN109981476A (en) * | 2017-12-27 | 2019-07-05 | 华为技术有限公司 | A kind of load-balancing method and device |
US10348603B1 (en) * | 2016-06-27 | 2019-07-09 | Amazon Technologies, Inc. | Adaptive forwarding tables |
WO2020180436A1 (en) * | 2019-03-06 | 2020-09-10 | Arista Networks, Inc. | Implementing history-based connection-server affinity on a network load balancer |
US10892991B2 (en) | 2019-03-06 | 2021-01-12 | Arista Networks, Inc. | Resilient hashing with multiple hashes |
US10917346B2 (en) | 2019-03-06 | 2021-02-09 | Arista Networks, Inc. | Resilient hashing with compression |
US11019137B2 (en) * | 2019-03-06 | 2021-05-25 | Arista Networks, Inc. | Implementing history-based connection-server affinity on a network load balancer |
US11272248B2 (en) | 2009-05-29 | 2022-03-08 | Inscape Data, Inc. | Methods for identifying video segments and displaying contextually targeted content on a connected television |
US11283697B1 (en) | 2015-03-24 | 2022-03-22 | Vmware, Inc. | Scalable real time metrics management |
US11290358B2 (en) * | 2019-05-30 | 2022-03-29 | Vmware, Inc. | Partitioning health monitoring in a global server load balancing system |
US11411825B2 (en) | 2015-08-25 | 2022-08-09 | Vmware, Inc. | In intelligent autoscale of services |
US11659255B2 (en) | 2015-07-16 | 2023-05-23 | Inscape Data, Inc. | Detection of common media segments |
US11711554B2 (en) | 2015-01-30 | 2023-07-25 | Inscape Data, Inc. | Methods for identifying video segments and displaying option to view from an alternative source and/or on an alternative device |
US11736372B2 (en) | 2018-10-26 | 2023-08-22 | Vmware, Inc. | Collecting samples hierarchically in a datacenter |
US11792155B2 (en) | 2021-06-14 | 2023-10-17 | Vmware, Inc. | Method and apparatus for enhanced client persistence in multi-site GSLB deployments |
US11811861B2 (en) | 2021-05-17 | 2023-11-07 | Vmware, Inc. | Dynamically updating load balancing criteria |
US11971919B2 (en) | 2015-07-16 | 2024-04-30 | Inscape Data, Inc. | Systems and methods for partitioning search indexes for improved efficiency in identifying media segments |
Citations (14)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20020026560A1 (en) * | 1998-10-09 | 2002-02-28 | Kevin Michael Jordan | Load balancing cooperating cache servers by shifting forwarded request |
US20030195919A1 (en) * | 2002-03-26 | 2003-10-16 | Tatsuya Watanuki | Packet distributing system and method for distributing access packets to a plurality of server apparatuses |
US20030217096A1 (en) * | 2001-12-14 | 2003-11-20 | Mckelvie Samuel J. | Agent based application using data synchronization |
US20040197079A1 (en) * | 2001-11-05 | 2004-10-07 | Nokia Corporation | Method and a system for stateless load sharing for a server cluster in an IP-based telecommunications network |
US6980550B1 (en) * | 2001-01-16 | 2005-12-27 | Extreme Networks, Inc | Method and apparatus for server load balancing |
US20060075489A1 (en) | 2004-09-30 | 2006-04-06 | Lucent Technologies, Inc. | Streaming algorithms for robust, real-time detection of DDoS attacks |
US20080021908A1 (en) | 2006-07-20 | 2008-01-24 | Barrett Alan Trask | Synchronization and dynamic resizing of a segmented linear hash table |
US7340532B2 (en) * | 2000-03-10 | 2008-03-04 | Akamai Technologies, Inc. | Load balancing array packet routing system |
US20080263316A1 (en) | 2006-06-19 | 2008-10-23 | International Business Machines Corporation | Splash Tables: An Efficient Hash Scheme for Processors |
US7610485B1 (en) | 2003-08-06 | 2009-10-27 | Cisco Technology, Inc. | System for providing secure multi-cast broadcasts over a network |
US20100322250A1 (en) * | 2009-06-22 | 2010-12-23 | Anil Shetty | Systems and methods for distributed hash table in a multi-core system |
US20110283082A1 (en) | 2010-05-13 | 2011-11-17 | International Business Machines Corporation | Scalable, Concurrent Resizing Of Hash Tables |
US20120143876A1 (en) | 2010-12-01 | 2012-06-07 | Cisco Technology, Inc. | Method and Apparatus for Efficiently Organizing Hierarchical QoS Policies |
US8248928B1 (en) * | 2007-10-09 | 2012-08-21 | Foundry Networks, Llc | Monitoring server load balancing |
-
2012
- 2012-01-03 US US13/342,493 patent/US9083710B1/en active Active
Patent Citations (17)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20020026560A1 (en) * | 1998-10-09 | 2002-02-28 | Kevin Michael Jordan | Load balancing cooperating cache servers by shifting forwarded request |
US6438652B1 (en) * | 1998-10-09 | 2002-08-20 | International Business Machines Corporation | Load balancing cooperating cache servers by shifting forwarded request |
US20100251008A1 (en) * | 2000-03-10 | 2010-09-30 | Eric Sven-Johan Swildens | Decrypting Load Balancing Array System |
US7340532B2 (en) * | 2000-03-10 | 2008-03-04 | Akamai Technologies, Inc. | Load balancing array packet routing system |
US7734814B2 (en) * | 2000-03-10 | 2010-06-08 | Akamai Technologies, Inc. | Decrypting load balancing array system |
US6980550B1 (en) * | 2001-01-16 | 2005-12-27 | Extreme Networks, Inc | Method and apparatus for server load balancing |
US20040197079A1 (en) * | 2001-11-05 | 2004-10-07 | Nokia Corporation | Method and a system for stateless load sharing for a server cluster in an IP-based telecommunications network |
US20030217096A1 (en) * | 2001-12-14 | 2003-11-20 | Mckelvie Samuel J. | Agent based application using data synchronization |
US20030195919A1 (en) * | 2002-03-26 | 2003-10-16 | Tatsuya Watanuki | Packet distributing system and method for distributing access packets to a plurality of server apparatuses |
US7610485B1 (en) | 2003-08-06 | 2009-10-27 | Cisco Technology, Inc. | System for providing secure multi-cast broadcasts over a network |
US20060075489A1 (en) | 2004-09-30 | 2006-04-06 | Lucent Technologies, Inc. | Streaming algorithms for robust, real-time detection of DDoS attacks |
US20080263316A1 (en) | 2006-06-19 | 2008-10-23 | International Business Machines Corporation | Splash Tables: An Efficient Hash Scheme for Processors |
US20080021908A1 (en) | 2006-07-20 | 2008-01-24 | Barrett Alan Trask | Synchronization and dynamic resizing of a segmented linear hash table |
US8248928B1 (en) * | 2007-10-09 | 2012-08-21 | Foundry Networks, Llc | Monitoring server load balancing |
US20100322250A1 (en) * | 2009-06-22 | 2010-12-23 | Anil Shetty | Systems and methods for distributed hash table in a multi-core system |
US20110283082A1 (en) | 2010-05-13 | 2011-11-17 | International Business Machines Corporation | Scalable, Concurrent Resizing Of Hash Tables |
US20120143876A1 (en) | 2010-12-01 | 2012-06-07 | Cisco Technology, Inc. | Method and Apparatus for Efficiently Organizing Hierarchical QoS Policies |
Non-Patent Citations (5)
Title |
---|
Cryptographic hash function-Wikipedia. http://en.wikipedia.org/wiki/Cryptographic-hash-function; dated Jan. 3, 2012. |
Hash function-Wikipedia. http://en.wikipedia.org/wiki/Hash-function; dated Jan. 3, 2012. |
Notice of Allowance dated May 9, 2013, issued in U.S. Appl. No. 13/342,503, filed Jan. 3, 2012 (16 pp). |
Office Action dated Dec. 17, 2012, issued in U.S. Appl. No. 13/342,503, filed Jan. 3, 2012 (26 pp). |
Pending U.S Pat. Appl. No. 13/342,503, filed Jan. 3, 2012. |
Cited By (36)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US11080331B2 (en) * | 2009-05-29 | 2021-08-03 | Inscape Data, Inc. | Systems and methods for addressing a media database using distance associative hashing |
US20190179851A1 (en) * | 2009-05-29 | 2019-06-13 | Inscape Data Inc. | Systems and methods for addressing a media database using distance associative hashing |
US11272248B2 (en) | 2009-05-29 | 2022-03-08 | Inscape Data, Inc. | Methods for identifying video segments and displaying contextually targeted content on a connected television |
US10038626B2 (en) * | 2013-04-16 | 2018-07-31 | Amazon Technologies, Inc. | Multipath routing in a distributed load balancer |
US10999184B2 (en) | 2013-04-16 | 2021-05-04 | Amazon Technologies, Inc. | Health checking in a distributed load balancer |
US20140310391A1 (en) * | 2013-04-16 | 2014-10-16 | Amazon Technologies, Inc. | Multipath routing in a distributed load balancer |
US9716658B1 (en) | 2014-02-25 | 2017-07-25 | Google Inc. | Weighted load balancing in a multistage network using heirachical ECMP |
US9571400B1 (en) * | 2014-02-25 | 2017-02-14 | Google Inc. | Weighted load balancing in a multistage network using hierarchical ECMP |
US9935831B1 (en) * | 2014-06-03 | 2018-04-03 | Big Switch Networks, Inc. | Systems and methods for controlling network switches using a switch modeling interface at a controller |
US9813344B2 (en) * | 2014-12-18 | 2017-11-07 | Telefonaktiebolaget Lm Ericsson (Publ) | Method and system for load balancing in a software-defined networking (SDN) system upon server reconfiguration |
US20160182378A1 (en) * | 2014-12-18 | 2016-06-23 | Telefonaktiebolaget L M Ericsson (Publ) | Method and system for load balancing in a software-defined networking (sdn) system upon server reconfiguration |
US9497123B2 (en) * | 2014-12-18 | 2016-11-15 | Telefonaktiebolaget L M Ericsson (Publ) | Method and system for load balancing in a software-defined networking (SDN) system upon server reconfiguration |
US20170026294A1 (en) * | 2014-12-18 | 2017-01-26 | Telefonaktiebolaget Lm Ericsson (Publ) | Method and system for load balancing in a software-defined networking (sdn) system upon server reconfiguration |
US11711554B2 (en) | 2015-01-30 | 2023-07-25 | Inscape Data, Inc. | Methods for identifying video segments and displaying option to view from an alternative source and/or on an alternative device |
US11283697B1 (en) | 2015-03-24 | 2022-03-22 | Vmware, Inc. | Scalable real time metrics management |
US11659255B2 (en) | 2015-07-16 | 2023-05-23 | Inscape Data, Inc. | Detection of common media segments |
US11971919B2 (en) | 2015-07-16 | 2024-04-30 | Inscape Data, Inc. | Systems and methods for partitioning search indexes for improved efficiency in identifying media segments |
US11411825B2 (en) | 2015-08-25 | 2022-08-09 | Vmware, Inc. | In intelligent autoscale of services |
US10348603B1 (en) * | 2016-06-27 | 2019-07-09 | Amazon Technologies, Inc. | Adaptive forwarding tables |
US10616321B2 (en) * | 2017-12-22 | 2020-04-07 | At&T Intellectual Property I, L.P. | Distributed stateful load balancer |
US20190199789A1 (en) * | 2017-12-22 | 2019-06-27 | At&T Intellectual Property I, L.P. | Distributed Stateful Load Balancer |
CN109981476A (en) * | 2017-12-27 | 2019-07-05 | 华为技术有限公司 | A kind of load-balancing method and device |
CN109981476B (en) * | 2017-12-27 | 2021-12-21 | 华为技术有限公司 | Load balancing method and device |
CN108667730B (en) * | 2018-04-17 | 2021-02-12 | 东软集团股份有限公司 | Message forwarding method, device, storage medium and equipment based on load balancing |
CN108667730A (en) * | 2018-04-17 | 2018-10-16 | 东软集团股份有限公司 | Message forwarding method, device, storage medium based on load balancing and equipment |
US11736372B2 (en) | 2018-10-26 | 2023-08-22 | Vmware, Inc. | Collecting samples hierarchically in a datacenter |
US11019137B2 (en) * | 2019-03-06 | 2021-05-25 | Arista Networks, Inc. | Implementing history-based connection-server affinity on a network load balancer |
US10917346B2 (en) | 2019-03-06 | 2021-02-09 | Arista Networks, Inc. | Resilient hashing with compression |
US10892991B2 (en) | 2019-03-06 | 2021-01-12 | Arista Networks, Inc. | Resilient hashing with multiple hashes |
WO2020180436A1 (en) * | 2019-03-06 | 2020-09-10 | Arista Networks, Inc. | Implementing history-based connection-server affinity on a network load balancer |
US11290358B2 (en) * | 2019-05-30 | 2022-03-29 | Vmware, Inc. | Partitioning health monitoring in a global server load balancing system |
US11582120B2 (en) | 2019-05-30 | 2023-02-14 | Vmware, Inc. | Partitioning health monitoring in a global server load balancing system |
US11909612B2 (en) | 2019-05-30 | 2024-02-20 | VMware LLC | Partitioning health monitoring in a global server load balancing system |
US11811861B2 (en) | 2021-05-17 | 2023-11-07 | Vmware, Inc. | Dynamically updating load balancing criteria |
US11792155B2 (en) | 2021-06-14 | 2023-10-17 | Vmware, Inc. | Method and apparatus for enhanced client persistence in multi-site GSLB deployments |
US11799824B2 (en) | 2021-06-14 | 2023-10-24 | Vmware, Inc. | Method and apparatus for enhanced client persistence in multi-site GSLB deployments |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9083710B1 (en) | Server load balancing using minimally disruptive hash tables | |
US9602428B2 (en) | Method and apparatus for locality sensitive hash-based load balancing | |
US11902153B1 (en) | Compressed routing header | |
US6909713B2 (en) | Hash-based data frame distribution for web switches | |
US7443841B2 (en) | Longest prefix matching (LPM) using a fixed comparison hash table | |
US10348646B2 (en) | Two-stage port-channel resolution in a multistage fabric switch | |
US8767757B1 (en) | Packet forwarding system and method using patricia trie configured hardware | |
EP2869515A1 (en) | System and method for minimum path mtu discovery in content centric networks | |
US9608913B1 (en) | Weighted load balancing in a multistage network | |
US20160255000A1 (en) | System and method for bgp sflow export | |
US11019137B2 (en) | Implementing history-based connection-server affinity on a network load balancer | |
CN113132249A (en) | Load balancing method and equipment | |
US10917346B2 (en) | Resilient hashing with compression | |
US10594629B2 (en) | Load balancing on multi-chip network switch without full bi-section bandwidth | |
Pao et al. | Efficient hardware architecture for fast IP address lookup | |
US9729446B1 (en) | Protocol-independent packet routing | |
US9391896B2 (en) | System and method for packet forwarding using a conjunctive normal form strategy in a content-centric network | |
US20150049764A1 (en) | Distributed Storage System, Control Apparatus, Client Terminal, Load Balancing Method and Program | |
US10892991B2 (en) | Resilient hashing with multiple hashes | |
Ghali et al. | Network names in content-centric networking | |
US8595239B1 (en) | Minimally disruptive hash table | |
US7353331B2 (en) | Hole-filling content addressable memory (HCAM) | |
CN111294285B (en) | Network data distribution method and load balancer | |
US9497285B1 (en) | Connection bucketing in mirroring asymmetric clustered multiprocessor systems | |
CN114911728A (en) | Data searching method and device and integrated circuit |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:YADAV, NAVINDRA;REEL/FRAME:027509/0887Effective date: 20120102 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044334/0466Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 8TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1552); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 8 |