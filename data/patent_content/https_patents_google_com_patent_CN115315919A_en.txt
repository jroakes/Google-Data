CN115315919A - Privacy preserving measures using secure multi-party computing - Google Patents
Privacy preserving measures using secure multi-party computing Download PDFInfo
- Publication number
- CN115315919A CN115315919A CN202280003163.8A CN202280003163A CN115315919A CN 115315919 A CN115315919 A CN 115315919A CN 202280003163 A CN202280003163 A CN 202280003163A CN 115315919 A CN115315919 A CN 115315919A
- Authority
- CN
- China
- Prior art keywords
- selection
- mpc
- component
- value
- digital
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000000034 method Methods 0.000 claims abstract description 361
- 230000008569 process Effects 0.000 claims abstract description 339
- 238000003860 storage Methods 0.000 claims description 26
- 238000004590 computer program Methods 0.000 claims description 13
- 238000001914 filtration Methods 0.000 claims description 3
- 238000010926 purge Methods 0.000 claims description 3
- 101100346189 Caenorhabditis elegans mpc-1 gene Proteins 0.000 description 261
- 101710165595 Mitochondrial pyruvate carrier 2 Proteins 0.000 description 239
- 102100025031 Mitochondrial pyruvate carrier 2 Human genes 0.000 description 239
- 101710101698 Probable mitochondrial pyruvate carrier 2 Proteins 0.000 description 239
- 239000013598 vector Substances 0.000 description 68
- 230000000875 corresponding effect Effects 0.000 description 47
- 230000004044 response Effects 0.000 description 31
- 238000012545 processing Methods 0.000 description 27
- 230000006870 function Effects 0.000 description 25
- 101100346198 Caenorhabditis elegans mpc-2 gene Proteins 0.000 description 24
- 238000009826 distribution Methods 0.000 description 24
- 241000544061 Cuculus canorus Species 0.000 description 23
- 239000000047 product Substances 0.000 description 20
- 238000010586 diagram Methods 0.000 description 17
- 238000004364 calculation method Methods 0.000 description 16
- 230000001186 cumulative effect Effects 0.000 description 15
- 230000000694 effects Effects 0.000 description 15
- 230000003993 interaction Effects 0.000 description 13
- 230000001143 conditioned effect Effects 0.000 description 12
- 238000004891 communication Methods 0.000 description 11
- 230000008901 benefit Effects 0.000 description 8
- 238000004422 calculation algorithm Methods 0.000 description 8
- 238000012360 testing method Methods 0.000 description 8
- 230000002776 aggregation Effects 0.000 description 7
- 238000004220 aggregation Methods 0.000 description 7
- 239000000654 additive Substances 0.000 description 6
- 230000000996 additive effect Effects 0.000 description 6
- 235000019800 disodium phosphate Nutrition 0.000 description 6
- 238000013515 script Methods 0.000 description 6
- 238000012546 transfer Methods 0.000 description 5
- 238000006243 chemical reaction Methods 0.000 description 4
- 230000002829 reductive effect Effects 0.000 description 4
- 239000000470 constituent Substances 0.000 description 3
- 230000000873 masking effect Effects 0.000 description 3
- 230000003287 optical effect Effects 0.000 description 3
- 238000012856 packing Methods 0.000 description 3
- 230000000644 propagated effect Effects 0.000 description 3
- 230000001105 regulatory effect Effects 0.000 description 3
- 238000009877 rendering Methods 0.000 description 3
- 238000007792 addition Methods 0.000 description 2
- 230000009286 beneficial effect Effects 0.000 description 2
- 230000005540 biological transmission Effects 0.000 description 2
- 238000004140 cleaning Methods 0.000 description 2
- 238000010413 gardening Methods 0.000 description 2
- 230000000670 limiting effect Effects 0.000 description 2
- 239000000203 mixture Substances 0.000 description 2
- 238000010295 mobile communication Methods 0.000 description 2
- 230000009467 reduction Effects 0.000 description 2
- 238000000926 separation method Methods 0.000 description 2
- 239000013589 supplement Substances 0.000 description 2
- 239000002699 waste material Substances 0.000 description 2
- 238000013528 artificial neural network Methods 0.000 description 1
- 230000000903 blocking effect Effects 0.000 description 1
- 230000003139 buffering effect Effects 0.000 description 1
- 239000002131 composite material Substances 0.000 description 1
- 230000002596 correlated effect Effects 0.000 description 1
- 230000003247 decreasing effect Effects 0.000 description 1
- 230000001934 delay Effects 0.000 description 1
- 238000013461 design Methods 0.000 description 1
- 230000007717 exclusion Effects 0.000 description 1
- 239000011521 glass Substances 0.000 description 1
- 230000002452 interceptive effect Effects 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 238000007726 management method Methods 0.000 description 1
- 230000036961 partial effect Effects 0.000 description 1
- 238000012797 qualification Methods 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 230000001953 sensory effect Effects 0.000 description 1
- 230000003068 static effect Effects 0.000 description 1
- 239000000758 substrate Substances 0.000 description 1
- 230000001960 triggered effect Effects 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Images
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/008—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols involving homomorphic encryption
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols
- H04L9/08—Key distribution or management, e.g. generation, sharing or updating, of cryptographic keys or passwords
- H04L9/0816—Key establishment, i.e. cryptographic processes or cryptographic protocols whereby a shared secret becomes available to two or more parties, for subsequent use
- H04L9/085—Secret sharing or secret splitting, e.g. threshold schemes
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/62—Protecting access to data via a platform, e.g. using keys or access control rules
- G06F21/6218—Protecting access to data via a platform, e.g. using keys or access control rules to a system of files or objects, e.g. local or distributed file system or database
- G06F21/6245—Protecting personal data, e.g. for financial or medical purposes
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/50—Monitoring users, programs or devices to maintain the integrity of platforms, e.g. of processors, firmware or operating systems
- G06F21/57—Certifying or maintaining trusted computer platforms, e.g. secure boots or power-downs, version controls, system software checks, secure updates or assessing vulnerabilities
- G06F21/577—Assessing vulnerabilities and evaluating computer system security
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/602—Providing cryptographic facilities or services
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/60—Protecting data
- G06F21/606—Protecting data by securing the transmission between two devices or processes
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION
- H04L2209/00—Additional information or applications relating to cryptographic mechanisms or cryptographic arrangements for secret or secure communication H04L9/00
- H04L2209/46—Secure multiparty computation, e.g. millionaire problem
Abstract
This document relates to the use of a secure MPC to select digital components in a manner that protects the privacy of the user and the data security of each party involved in the selection process. In one aspect, a method includes performing, by a first server of a secure MPC system in cooperation with one or more second servers of the secure MPC system, a selection process to select a digital part based in part on a selection value for each digital part in the selection process. This includes determining a first secret share of the winner parameter for each digit component in the selection process. The first server determines, for each given numerical component in the selection process and in cooperation with the second server(s), the highest other selection value corresponding to a different numerical component different from the given numerical component.
Description
Technical Field
This specification relates to cryptography and data security.
Background
Secure multi-party computing (MPC) is a family of cryptographic protocols that prevents access to data by distributing computations among multiple parties, such that no one party has access to the other party's data or intermediate computed values, and the output is only released to a designated party. MPC computing systems typically perform computations using secret sharing or other encrypted forms of data and perform secure exchanges of information between parties.
Disclosure of Invention
In general, one innovative aspect of the subject matter described in this specification can be embodied in methods that include performing, by a first server of a secure multi-party computing (MPC) system in cooperation with one or more second servers, a selection process to select a digital component based in part on a selection value for each digital component in the selection process, the performing including determining a first secret share of a winner parameter for each digital component in the selection process; determining, for each given numerical component in the selection process and in cooperation with the one or more second servers, a highest other selection value corresponding to a different numerical component different from the given numerical component, the determining for each given numerical component comprising: determining a first secret share of a highest selection value of the selection values of the digital components in the selection process; determining a first secret share of a second highest selection value of the selection values of the digital components in the selection process; for each given digital component in the selection process, determining a first secret share of a highest other selection value based at least in part on the first secret share of the highest selection value, the first secret share of a second highest selection value, and the first secret share of the winner parameter of the given digital component; and providing the highest selected value for each given numerical component to the owner of the given numerical component. Other implementations of this aspect include corresponding apparatus, systems, and computer programs, encoded on computer storage devices, configured to perform the various aspects of the methods.
These and other implementations can each optionally include one or more of the following features. In some aspects, determining the first secret share of the highest other selection value for the particular digital component includes determining, in cooperation with one or more second servers, a first secret share of a sum of a first product and a second product, wherein the first product is a product of a winner parameter of the particular digital component and a second highest selection value of the selection values in the selection process, and the second product is a product of a difference between (i) a value of the winner parameter of the particular digital component and (ii) a highest selection value of the selection values of the digital component in the selection process.
In some aspects, the selection process includes selecting at least one of a plurality of priority levels for the digital components in the process, or one or more boosted digital components having boosted selection values. Some aspects include performing, by a first server in cooperation with one or more second servers, a counterfactual selection process to select a second numeric component based in part on a selection value of each numeric component in the selection process, wherein the counterfactual selection process selects the second numeric component using an unequalized selection value and independent of a priority level, determining a first clearing value of the selection process, determining a second clearing value of the counterfactual selection process, and determining a difference between the first clearing value and the second clearing value.
Some aspects include filtering one or more numerical components from the selection process based on a selection value lower limit. The lower selection value limit can represent the minimum selection value that satisfies the digital component with the condition for selection. Determining the first secret share of the highest other selected value of the particular digital component can include determining the first secret share of the highest other selected value of the particular digital component based on a lower selection value bound. In more detail, the selection value lower limit can be used to filter numerical components having a selection value less than the selection value lower limit. Those digital components filtered from the set of digital components may correspond to unnecessary and/or irrelevant digital components (because they have a selected value below a lower limit). Thus, filtering unnecessary digital components in this manner can reduce network bandwidth usage and computing resource usage, thereby making the overall content selection process more efficient.
The subject matter described in this specification can be implemented in particular embodiments to realize one or more of the following advantages. Secure MPC processes performed by two or more MPC servers operated by different parties are used to select digital components based on user information sharing, ensuring that the MPC servers or other parties cannot access the user information in clear without unauthorized collusion between the MPC servers. In this way, user data privacy is protected as long as at least one MPC server is honest.
In the digital part selection process, the MPC server can select from eligible digital parts that satisfy one or more qualifying conditions while preventing parties from accessing user information in the clear. Qualification conditions can include limitations and guidance on how or how frequently the digital components are distributed, as well as other factors. These conditions can include user group membership, frequency control, muting (e.g., user blocking), k-anonymity and/or regulation (pacing) to prevent accurate delivery to users, and budget restrictions.
Since the selection of digital components is an online process that typically occurs while content is being loaded at the client device, it is important that the process be completed quickly, e.g., within a few milliseconds. The techniques described in this document increase the speed of selecting digital components by reducing the size of data transmitted between a client device and an MPC cluster, by reducing the computational resources required by the MPC cluster, and by reducing the number of round trip communications/computations performed by the servers of the MPC cluster and the size of data transmitted between the servers. The reduction in data size between the client device and the server also reduces network bandwidth consumption and battery consumption of the client device, for example, if the client device is a mobile device that operates using battery power.
The client devices of the users can generate probabilistic data structures, e.g., cuckoo filters or Bloom filters, to the servers of the MPC cluster that represent groups of users that include the users as members and can provide the probabilistic data structures, or data representing the probabilistic data structures. Using the probabilistic data structure in this manner protects user privacy and maintains data security by preventing access to group memberships for the user, and reduces the size of information provided to the MPC cluster because the probabilistic data structure is a compact representation of the data set. Data representing the probabilistic data structure can be generated and sent to the MPC server such that any party that only receives partial data cannot access the user group membership of the user without having other parts or collaborating with other MPC servers, e.g., using a secure MPC process. The reduction in data size reduces the amount of bandwidth consumed by transferring information, reduces latency in transferring information, and reduces the processing power required to transfer information and associated battery power of battery-operated devices (e.g., mobile devices).
The MPC cluster can transmit a secret share of the results that identify the MPC cluster using the selected digital components of the secure MPC process selection. By sending a secret share of the results only for selected digital components, rather than sending information for all or a large set of digital components, latency and consumed bandwidth, processing power and battery power in transmitting and receiving the results is similarly reduced. This also reduces the potential leakage of confidential information for content platforms submitting select values of digital components to the MPC cluster by limiting the number of digital components providing information to client devices.
Reducing latency in the presentation of content also reduces the number of errors that occur at the user device while waiting for such content to arrive. Since content typically needs to be provided in milliseconds and provided to mobile devices connected over a wireless network, reducing latency in selecting and providing content is critical to prevent errors and reduce user frustration.
The secure MPC techniques described in this document are flexible and support different types of selection processes and/or additional selection process features, such as lower bounds, levels, and/or upgrades. The secure MPC techniques described in this document support this feature while still preserving user privacy and data security. When the hierarchy is used, it is possible to perform a plurality of selection processes in parallel to reduce a time delay in selecting the digital component, or to perform a plurality of selection processes in sequence to reduce unnecessary calculations. In more detail, using the rankings and performing the selection process in parallel across each ranking can improve the speed at which the entire digital content selection process is performed. In contrast, performing the selection process sequentially from the highest priority level to the lowest priority level can avoid unnecessary calculations, for example if the numerical components to be selected are contained in a higher level. Metrics that can be used to improve the efficiency of the digital component selection process can be aggregated and reported to the appropriate parties in a manner that protects the privacy of the user.
The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.
Drawings
Fig. 1 is a block diagram of an environment in which an MPC cluster performs a secure MPC process to select digital components for distribution to client devices.
FIG. 2 illustrates an example data flow within the environment of FIG. 1.
FIG. 3 is a diagram of an example process for selecting digital components for distribution to a client device.
FIG. 4 is a diagram of an example process for selecting digital components for distribution to a client device.
FIG. 5 is a diagram of an example process for selecting digital components for distribution to a client device.
FIG. 6 is a diagram of an example process for determining the highest other selection value of a numeric component in a numeric component selection process.
FIG. 7 is a flow chart of an example process for determining a difference between a first selection value of a real digital part selection process and a counter-fact digital part selection process.
FIG. 8 is a flow diagram of an example process for determining whether a user is a member of a user group using a Bloom filter sent with secret sharing.
FIG. 9 is a block diagram of an example MPC computing system.
FIG. 10 is a block diagram of an example computer system.
Like reference numbers and designations in the various drawings indicate like elements.
Detailed Description
In general, this document describes systems and techniques for selecting digital components using a secure MPC in a manner that protects user privacy and protects the data security of each party involved in the selection process. Enhancements to the selection process support multiple variations of the digital component selection process, provide flexibility for content publishers and content selection platforms that manage digital components, while maintaining user privacy and data security. For example, the MPC cluster described in this document is capable of performing a secure numeric component selection process including a ranking, a selection value boosting, a first value selection process, a second value selection process, and/or a combination of one or more of these variations. The techniques described in this document allow for such flexibility, privacy protection, and data security while still providing the digital components within a short period of time, e.g., within milliseconds after receiving a request, and while minimizing the size of data sent to and from the client device displaying the digital components.
The MPC cluster can also generate information, e.g., metrics, based on the selection process that can be used to further enhance the completion of the future digital component selection process. This information can be generated using the secure MPC such that user data and data of publishers and/or content platforms are inaccessible without unauthorized collusion between servers and/or other parties of the MPC cluster. The information can be reported to the appropriate parties in encrypted form, e.g., shared as a secret, so that only the recipient can access the information in clear. To protect user privacy, in some implementations, the intended recipient can access the information in clear text with different privacy noises applied and/or in an aggregated form. Plaintext is text that is not computationally tagged, specially formatted, or written in code or data (including binary files) in a form that can be viewed or used without a key or other decryption device or other decryption process.
In this document, some of the calculations performed by the MPC cluster on secret sharing are shown as products or sums of secret sharing values. To increase the speed at which these calculations are performed, the multiplication can be performed in secret sharing using an AND operation, such as a bitwise-AND, AND the addition can be performed in secret sharing using an XOR operation, such as a bitwise-XOR operation. In some cases, when a plaintext integer is multiplied by a secret share that represents a 0 or 1 in Z2 (i.e., the two shares modulo 2 add to 0 or 1), no multiplication or bitwise-AND is required. Instead, each computing system can evaluate its share, returning the integer if the share is 1, and 0 if the share is 0.
Fig. 1 is a block diagram of an environment 100 in which an MPC cluster 130 performs a secure MPC process to select digital components for distribution to client devices 110. The MPC cluster 130 also generates information for the completed digital component selection process and provides this information to the appropriate party.
The example environment 100 includes a data communication network 105, such as a Local Area Network (LAN), a Wide Area Network (WAN), the internet, a mobile network, or a combination thereof. The network 105 connects client devices 110, secure MPC cluster 130, publishers 140, websites 142, and content platforms, e.g., supply Side Platform (SSP) 170 and Demand Side Platform (DSP) 150. The example environment 100 can include many different client devices 110, secure MPC clusters 130, publishers 140, web sites 142, DSPs 150, and SSPs 170.
The website 142 includes one or more electronic resources 145. The resource 145 can be associated with a domain name and hosted by one or more servers. An example website is a collection of web pages formatted in hypertext markup language (HTML) that can contain text, images, multimedia content, and programming elements, such as scripts. Each website 142 is maintained by a content publisher 140, which content publisher 140 is an entity that controls, manages, and/or owns the website 142.
The resource 145 is any data that can be provided by the publisher 140 over the network 105 and that can be associated with a resource address. Resources include HTML pages, word processing documents, and Portable Document Format (PDF) documents, images, videos, and feeds, to name a few. The resources 145 can include content such as words, phrases, pictures, etc., and can include embedded information (e.g., meta information and hyperlinks) and/or embedded instructions, such as scripts.
The client device 110 is an electronic device capable of communicating over the network 105. Example client devices 110 include personal computers, mobile communication devices, such as smart phones, and other devices 105 capable of sending and receiving data over a network. Client devices 110 can also include digital assistant devices that accept audio input through a microphone and output audio output through a speaker. When the digital assistant detects a "hot word" or "hot phrase" that activates the microphone to accept audio input, the digital assistant can enter a listening mode (e.g., is ready to accept audio input). The digital assistant device can also include a camera and/or a display to capture images and visually present information. The digital assistant can be implemented in different forms of hardware devices, including wearable devices (e.g., watches or glasses), smartphones, speaker devices, tablet devices, or other hardware devices. The client device 110 can also include a digital media device, such as a streaming device that plugs into a television or other display to stream video to the television, a gaming system, or a virtual reality system.
The client device 110 typically includes an application 112, such as a web browser and/or a native application, to facilitate sending and receiving data over the network 105. A native application is an application developed for a particular platform or a particular device, for example, a mobile device having a particular operating system. The publisher 140 can develop and provide, e.g., downloadable, local applications to the client device 110. The web browser can request the resource 145 from a web server hosting the publisher's 140 website 142, for example, in response to a user of the client device 110 typing in a resource address of the resource 145 in an address bar of the web browser or selecting a link referencing the resource address. Similarly, the local application can request application content from a publisher's remote server.
Some resources, application pages, or other application content can include a numeric component slot for displaying a numeric component having a resource 145 or application page. The phrase "digital component" as used throughout this document refers to discrete units of digital content or digital information (e.g., video clips, audio clips, multimedia clips, images, text, or other units of content). The digital component can be electronically stored in physical memory as a single file or collection of files, and the digital component can be in the form of a video file, audio file, multimedia file, image file, or text file, and include advertising information such that the advertisement is a digital component. For example, the digital components may be content intended to supplement a web page, application content (e.g., an application page), or other resources displayed by the application 112. More specifically, the digital components may include digital content that is related to the resource content, e.g., the digital components may be related to the same subject matter as the web page content or related to a related subject matter. Thus, the provision of digital components can supplement and generally enhance web page or application content.
When application 112 loads a resource (or application content) that includes one or more slots for a digital component, application 112 can request the digital component for each slot. In some implementations, the digital part slots can include code, e.g., one or more scripts, that, when processed by the application 112, cause the application 112 to request the digital parts for display to a user of the client device 110. As described below, application 112 can request digital components from MPC cluster 130 and/or one or more SSPs 170.
Some publishers 140 use SSPs 170 to manage the process of obtaining digital components for their digital component slots of resources 145 and/or applications 112. The SSP170 is a technical platform implemented in hardware and/or software that automates the process of obtaining digital components of resources and/or applications. Each publisher 140 can have a corresponding SSP170 or SSPs 170. Some publishers 140 may use the same SSP 170.
The digital part provider 160 can create (or otherwise publish) digital parts that are displayed in the publisher's resources 145 and the digital part slots of the application 112. For example, digital part provider 160 can create a content that includes information related to digital part provider 160. In a particular example, the digital component of the product manufacturer can include content related to the product.
In some cases, it may be beneficial for a user to receive digital components related to web pages, application pages, or other electronic resources that the user has previously accessed and/or interacted with. To distribute such digital components to users, users can be assigned to groups of users, e.g., user interest groups of users interested in the same or similar subject matter, groups of similar users, or other group types involving similar user data. A user can be assigned to a group of users when the user accesses a particular resource or performs a particular operation on a resource (e.g., interacts with a particular item displayed on a web page or adds an item to a virtual shopping cart). The user group can be generated and updated by the digital component provider 160. That is, each digital component provider 160 is capable of assigning users to their group of users when the users access electronic resources of the digital component provider 160. User groups can also be created and/or updated by the content platform, e.g., by DSP150 and/or SSP 170.
To protect user privacy, the user's group membership can be maintained at the user's client device 110, e.g., by one of the applications 112, the operating system of the client device 110, or another trusted program, rather than by a digital component provider, content platform, or other party. In a particular example, a trusted program (e.g., a web browser or operating system) can maintain a list of user group identifiers ("user group list") for users using a web browser or another application (e.g., for users logged into the browser, application, or client device 110). The user group list can include a user group identifier for each user group, including users that are members. The digital component provider 160 or the content platform that creates the user group can specify the user group identifier for their user group. The user group identifier of the user group can be a description of the group (e.g. a gardening group) or a code representing the group (e.g. a non-descriptive alphanumeric sequence). The user group list of the user can be stored in a secure store at the client device 110 and/or can be encrypted at the time of storage to prevent others from accessing the list.
When the application 112 displays a resource (e.g., a web page), application content, or digital component associated with the digital component provider 160, the resource, application content, or digital component can request that the application 112 add one or more user group identifiers to the user group list. In response, the application 112 can add the one or more user group identifiers to the user group list and securely store the user group list. For example, a web page that a user selects to view more information about a particular item can add the user to a group of users related to the particular item.
In some implementations, the MPC cluster 130 can use the user group membership of the user to select digital components that may be of interest to the user or that may be beneficial to the user/user device in another way. For example, such digital components or other content may include data that improves the user experience, improves the operation of the user device, or benefits the user or client device 110 in some other manner. However, the user group identifier of the user group list of the user can be provided and used to select the digital components in a way that prevents the computing systems MPC 1 and MPC2 of the MPC cluster 130 from accessing the user group identifier of the user in clear text, thereby protecting user privacy when using the user group membership data to select the digital components. The MPC cluster 130 can also use other conditions to select the digital components as described in more detail below.
The secure MPC cluster 130 includes two computing systems MPC 1 and MPC2 that perform secure MPC processes to select digital components for distribution to a user's client devices based on the user's group membership, but do not access group membership or other user information, or signals derived from such user information, in clear text. Although the example MPC cluster 130 includes two computing systems, more computing systems can be used as long as MPC cluster 130 includes more than one computing system. For example, the MPC cluster 130 can include three computing systems, four computing systems, or other suitable number of computing systems. Using more computing systems in the MPC cluster 130 can provide greater security, but can also increase the complexity of the MPC process. Each computing system can be a server or other suitable type of computer. An example architecture of an MPC computing system is shown in fig. 9.
Each computing system MPC 1 and MPC2 is capable of storing a digital component (e.g., creation of a digital component), a selected value of a digital component, and other information of a digital component. For example, computing systems MPC 1 and MPC2 may be capable of buffering selection values previously received from SSP170 and/or DSP150 as part of a previous digital component selection process, or these selection values may be otherwise provided to computing systems MPC 1 and MPC2, e.g., provided in advance for use in the digital component selection process. In this manner, MPC cluster 130 is able to use the selection values to select digital components for distribution to client devices 110 in response to future digital component requests received from client devices 110. The digital components for which selection values and other information are stored by the MPC cluster 130 for use in the digital component selection process can be referred to in this document as stored digital components. However, the digital components themselves are not necessarily stored by the MPC cluster 130. Instead, the MPC cluster 130 can store data for each stored digital component, e.g., code that references a network location from which the digital component can be downloaded. In some implementations, the digital components themselves are stored by the MPC cluster 130 and returned directly to the application 112. Such an implementation reduces the need for the application 112 to obtain the digital components and/or other information for the digital components, and also reduces requests that may consume the battery and bandwidth of the device and may leak additional signals that host the digital components themselves to track the server of the device.
For each stored digital component, each computing system MPC 1 and MPC2 is capable of storing a selection value or value vector that can be used by the computing systems MPC 1 and MPC2 to determine a selection value for the digital component. Each computing system MPC 1 and MPC2 is also capable of storing condition data for each digital component, which condition data defines the condition(s) that the digital component must satisfy to be a eligible candidate for the given digital component selection process. The stored digital components can have zero or more corresponding conditions.
One example condition is that the user to which the selected digital component is to be provided is a member of a user group corresponding to the stored digital component. This condition can be referred to as a user group membership condition. In this example, computing systems MPC 1 and MPC2 are capable of storing, for a stored digital component, one or more sets of user group identifiers corresponding to the digital component. These subscriber group identifiers identify the subscriber groups for which the stored digital components can be provided. That is, the stored numeric components are only candidates for a numeric component selection process that is performed to select numeric components to provide to a user who is a member of at least one user group identified by one or more sets of user group identifiers of the stored numeric components.
Another example condition of a stored numeric component is a frequency ceiling condition that indicates a maximum number of times a numeric component or a particular category of numeric components can only be provided to the same user for a given duration. Another example condition of a digital part is a masked digital part condition indicating that the digital part has been masked by a user, e.g., muted. For these example conditions, computing systems MPC 1 and MPC2 are capable of receiving, for each of a plurality of users, a probabilistic data structure from the store, e.g., a cuckoo filter or a Bloom filter, that represents a numerical component that cannot be provided to the user. For example, the probabilistic data structure can represent universal identifiers for numeric components that are either masked directly by the user or masked due to the frequency with which the numeric components are displayed to the user too quickly during a given duration.
In some implementations, identifiers of masked numerical components can be included in the same probabilistic data structure as the user group identifiers and queried using different hash functions. However, the target false positive rate of the masked numerical components can be lower than the false positive rate of the user group identifier. Thus, fewer hash functions can be used to generate and query the Bloom filter of the masked digital component as compared to the subscriber group identifier. In order to reduce the data size of the Bloom filter of the masked digital component, the subscriber group identifier can be represented by a Bloom filter different from the masked digital component. This reduces the latency of sending the Bloom filter over the network, reduces the bandwidth consumption of the sending Bloom filter, and reduces the battery power usage of the sending Bloom filter.
Another example condition of the stored digital components is an adjustment condition that adjusts distribution of the digital components over a duration of time. Computing systems MPC 1 and MPC2 are capable of storing data indicating the total number of times a digital component can be provided for a duration of time and/or the maximum budget for the digital component for the duration of time. The computing systems MPC 1 and MPC2 can use this information to adjust the frequency with which the digital components can be candidates for the digital component selection process based on this condition (e.g., all conditions for the digital components must be met in order for the digital components to be candidates). In some implementations, computing systems MPC 1 and MPC2 can implement a feedback controller, e.g., a proportional-integral-derivative (PID) controller, that uses secret sharing to adjust stored digital components with adjustment conditions.
In this example, the computing systems MPC 1 and MPC2 are capable of storing set points for PID controllers of digital components and maintaining measured variables for PID controllers of digital components. In general, a PID controller is a feedback controller that uses an error value, which is the difference between a target set point and a measured variable, to determine an output that drives the measured variable toward the set point. In the context of regulating the distribution of digital components to client devices, the set point for an activity (campaigns) can be a presentation rate, an interaction rate, a conversion rate, and/or a resource consumption rate (e.g., a budget payout rate). Similarly, the measured variable can be a presentation rate, an interaction rate, a conversion rate, and/or a resource consumption rate for a given duration. The computing systems MPC 1 and MPC2 are also capable of storing tuning parameters for each PID controller. The set points, measured variables and tuning parameters can be stored in secret shares (each computing system MPC 1 and MPC2 stores a corresponding share of each parameter) or in clear text form, depending on the target privacy/data security.
Another example condition is a k-anonymous condition. The k-anonymity condition can include a k-anonymity rule that requires that the number component conform to (or be selected to be) distributed to at least k users for a given duration. The concept of k-anonymity ensures that data of a particular user cannot be distinguished from data of a threshold number k of other users. The system can enforce k-anonymity rules, for example, by ensuring that particular digital components are distributed to client devices 110 in response to requests for one or more digital components, and that the same digital components may have or have been displayed to a set of at least k users or by at least k applications 112 within a particular time period. In some implementations, each of the k applications 112 to which a digital component may have been or be distributed must be for a different user. In this example, computing systems MPC 1 and MPC2 are capable of storing a value k for a digital component and maintaining a number of users to which the digital component may have been distributed.
Determining the number of users who may have displayed a numerical component can include performing a de-facto numerical component selection process in parallel with each actual numerical component selection process. In this counter-fact number component selection process, if a number component satisfies all conditions except the k-anonymity condition, all of the number components can be candidates. If a digital component is selected for at least k users or applications 112 in the de-facto digital component selection process, the digital component will have been displayed to k users if not for the k-anonymous condition. Once this occurs, the digital components that satisfy the k-anonymity condition can be included in the actual digital component selection process (assuming that other conditions of the digital components are satisfied, if any), with no digital components having conditions that do not satisfy the k-anonymity condition.
In some implementations, each computing system MPC 1 and MPC2 stores information for the digital components in a data structure that maps the digital components and their respective information to a set of contextual signals. For example, each digital component can conform to a condition for display in a presentation environment having resources and/or applications that include a set of contextual signals. The context signals can include, for example, a topic of the resource, keywords found in the resource, a resource locator of the resource, a geographic location of the client device 110, a spoken language setting of the application 112, a number of numerical component slots of the resource, a type of numerical component slot, and/or other suitable context signals. In addition, the digital component can have a plurality of corresponding selection values, one for each set of context signals. The use of such data structures enables computing systems MPC 1 and MPC2 to identify digital components that meet the digital component selection process conditions. Computing systems MPC 1 and MPC2 can then use these conditions to identify, from these eligible digital components, digital components that are candidates for actual eligibility for selection in the digital component selection process. The set of context signals used to determine whether a digital component is eligible can be in the form of a lookup key that enables computing systems MPC 1 and MPC2 to use the context signals requested by the digital component to lookup the eligible digital component.
When the digital component is associated with a corresponding subscriber group identifier identifying a subscriber group that meets the conditions of the digital component, a look-up table (LUT) can be used to store the information. The use of a LUT can provide some performance advantages, but other suitable data structures can also be used. The LUT maps a context signal or a lookup key derived from a context signal to a set of digital components such that the set of digital components is eligible for display and/or the selection value or vector is eligible subject to other conditions described in this document. In this way, computing systems MPC 1 and MPC2 are able to store multiple selection values for each digital component, e.g. one for each set of context signals.
In some implementations, the lookup key is a hash-based message authentication code (HMAC) of the context signal. For example, the lookup key can be an HMAC (URL, HMAC (language, location)), where the parameter URL is a URL of a resource for which the numeric component and the selection value are eligible, the parameter language is a spoken language specified for the application 112, the numeric component and the selection value are eligible, and the parameter location is a geographic location for which the numeric component and the selection value are eligible. If the context signal of the digital component request matches these parameters, the digital component and the selection value mapped to the lookup key are in accordance with the conditions of the digital component selection process that selects the digital component in response to the request. Other contextual signals may be used in addition to or in place of URLs, locations, and languages.
To reduce the amount of bandwidth and the amount of latency consumed by transmitting the digital component request over network 105, application 112 can use the same HMAC calculation to look up the key, rather than sending context signals to computing systems MPC 1 and MPC 2. This also reduces the amount of battery consumed by client device 110 and the amount of data received by each computing system MP1 and MPC 2.
In some implementations, for example, a two-phase LUT table is used when the number component is conditioned on user group membership of the user. The first stage can be keyed by a Request Key (UG _ Request _ Key). The UG _ Request _ Key can be a lookup Key in the form of a composite message based on a set of context signals, e.g., a set of context signals of a digital component Request (e.g., URL, location, language, etc.), or a set of context signals of a digital component that meets distribution criteria. That is, the first stage LUT can be keyed based on the set of context signals. The Key of the first stage can be a hash of UG _ Request _ Key, e.g., using a hash function such as SHA 256. The key can be truncated to a specified number of bits, such as 16 bytes, or other suitable number of bits. The value of each Key UG _ Request _ Key in the first stage LUT can indicate a row of the second stage LUT that includes data of a digital component that qualifies as a digital component Request that includes a context signal of the UG _ Request _ Key. The first stage LUT representation is shown in table 1 below, for example.
Secret key | Value of |
SHA256(UG_Request_Key) | Rows … |
… | Row … |
TABLE 1
The second stage LUT can be keyed based on a combination of the subscriber group Request Key UG _ Request _ Key and the subscriber group identifier in the first stage LUT. In some implementations, the second stage LUT can be an array or other suitable data structure. Each row in the second stage LUT can be used for a particular selection value (or vector of values) for a particular digital component. For example, DSP150 can submit different selection values for the same numeric component, where each selection value is for a different set of context signals and/or a different user group identifier. Thus, the selection value of a digital component can vary based on the context and the user group membership of the user for whom the digital component selection process is being performed.
DSP150 or digital component provider 160 can associate, e.g., link or map, the digital components to groups of users to which DSP150 or digital component provider desires the digital components to be displayed. For example, DSP150 may wish to display digital components related to fly fishing to males who have shown an interest in fly fishing. In this example, DSP150 can provide data to MPC cluster 130 indicating that the numeric components correspond to a user group identifier for a group of users, including males who have shown an interest in fly fishing.
In some implementations, in the second stage LUTThe Key of the row of (1) can be a hash or code generated based on a combination of the user group Request Key UG _ Request _ Key and the user group identifier of the numeric component of the row. For example, the key can be a combined HMAC, which can be represented as an HMAC SHA256 (UG _ Request _ Key, UG _ id). The user group identifier ug id can be based on a combination of an internal user group identifier of the user group and the domain of the user group owner (e.g. the domain of the DSP, SSP or the digital component provider owning the user group). For example, the user group identifier ug _ id can be a digital digest of the eTLD +1 of the owner's domain and an internal user group identifier of the owner's user group. Tld + 1 is the valid top level field (tld) plus one level more than the common suffix. One example, eTLD +1 is "example.com," where ". Com" is the top-level domain. The ug id can be truncated to 16 bytes or other appropriate data size.
Continuing with the previous fly fishing example, the second phase lookup Key of a row of numerical component information to be displayed to users in a male fly fishing group can be a combination of the user group Request Key UG _ Request _ Key and the user group identifier UG _ id of the male fly fishing group. Since the digital components can be presented in different contexts, the second stage lookup table can include a plurality of rows of the digital components that are associated with the user group identifier UG _ id of the male fishing group, each row having a different user group Request Key UG _ Request _ Key and a different value.
The values of each row of the second stage LUT can be a selection value (or vector of values) of the digital components and other data of the digital components, e.g., metadata identifying the digital components or a network location from which the digital components can be downloaded, etc. In some implementations, the row can contain the digital component itself ready for rendering by the application 112, e.g., in a web package format.
The value can be a digital component information element dc _ information _ element, which can be a byte array with a selection value and metadata. The byte array can have a particular format that applications 112 or trusted programs of client devices 110 and computing systems MPC 1 and MPC2 can parse to obtain selection values and metadata. In some implementations, the digital component information element can include the digital component itself. An example of the second stage LUT is shown in table 2 below. When a vector is used to determine the selection value, the selection value can be replaced with the vector in table 2.
TABLE 2
The second stage LUT maps the selection value to a specific numeric component, to a specific subscriber group identifier UG _ id and to a specific set of context signals defined by the first stage lookup Key UG _ Request _ Key. By doing so, the second stage LUT indicates the particular context of the digital component slot for which the selected value of the digital component meets the condition. This allows DSP150 or digital component provider 160 to specify different selection values for the same digital component for different contexts defined by context signals and user group membership. When a numeric component request is received, which indicates that the user to whom the numeric component is to be displayed is a member of a particular user group identified by a particular user group identifier ug id, and the numeric component is to be displayed in a particular context defined by the context signal of the first stage lookup key, any numeric component in the second stage LUT having a selection value matching the user group identifier and the matching first stage lookup key is a candidate to be selected for distribution in response to the request.
In addition to the description throughout this document, a user may be provided with controls (e.g., user interface elements with which the user may interact) allowing the user to make selections as to whether and when the systems, programs, or features described herein may be able to collect user information (e.g., information about the user's social network, social actions or activities, profession, the user's preferences, or the user's current location), and whether the user is sent content from or in communication with a server. In addition, certain data may be processed in one or more ways before it is stored or used, so that the personal identity information is deleted. For example, the user's identity may be processed such that no personal identity information of the user can be determined, or the user's geographic location may be generalized where location information is obtained (e.g., at the city, zip code, or state level) such that no specific location of the user can be determined. Thus, the user may control which information about the user is collected, how the information is used, and which information is provided to the user.
FIG. 2 illustrates an example data flow within the environment 100 of FIG. 1. The description includes two types of selection values: selection values conditioned on sensitive user information, such as user group membership or other business sensitive information, or changes in the values thereof, can allow a lawbreaker to infer parameters of the sensitive information, or "conditional selection values"; and a selection value that is not conditioned on sensitive information, or an "unconditional selection value". To protect user privacy, the "conditional selection value" condition is evaluated within MPC cluster 130 rather than within SSP170 or DSP150 to determine whether the "conditional selection value" is a candidate for the content selection process.
This architecture allows the MPC cluster 130 to protect user privacy and business confidential information and prove its trustworthiness to application providers, e.g., the provider of the application 112. In this example, the MPC cluster 130 relies on a secure 2-party computing (2 PC) architecture that applies cryptographic techniques to ensure that there is no leakage of confidential user data or business confidential information if at least one of the two computing systems of the MPC cluster 130 is honest. If the MPC cluster 130 includes more than two computing systems, the current MPC protocol can be extended or other MPC protocols can be used.
The MPC cluster 130 runs a secure 2PC protocol to evaluate and apply conditions to select candidate numeric components, performs a selection process to select numeric components based on the selection values, and receives presentation notifications to update the parameters on which those conditions depend. All of these processes can be done using secret sharing techniques. The protocol is described in detail with reference to fig. 3.
In phase a, the application 112 sends a request for digital components to the MPC cluster 130, e.g., in cooperation with a trigger element from a content platform such as the SSP 170. The application 112 can include multiple requests for digital components that are combined into one combined request to obtain multiple digital components. The MPC cluster 130 can then serve each of the combined requests independently or make one or more selection decisions in its entirety. In this example, the request is for a single digital component and includes a request for a digital component selected based on the sensitive information or a digital component selected without using the sensitive information. The MPC cluster 130 can respond to the request by selecting a particular digital component corresponding to a particular selection value from a set of selection values, each of which is mapped to a respective particular digital component. These selection values can be selection values that were previously cached or otherwise stored at MPC cluster 130 and/or selection values generated by a platform such as DSP150 or SSP170, just-in-time (JIT) selection values. The JIT select values are generated directly in response to the need and improve efficiency and reduce waste because the select values are only generated when the digital components are needed. For example, a JIT selection value can be generated when a numeric component slot becomes available, as indicated by receiving a request for a numeric component. Thus, the MPC cluster 130 can select one digital part from a set of digital parts that includes the stored digital part whose information is stored at the MPC cluster 130 and the digital part for which the JIT selection value is received for the current digital part request.
In some implementations, two or more vectors can be used to determine the selection values of the digital components. The MPC cluster 130 can store, for the digital components, a first vector of values that can be used to determine select values for the digital components. The first vector of values can be specific to one or more user groups, for example, can be used to determine a selection value for a digital component when the digital component is selected for a user that is a member of the one or more user groups. Thus, the first value vector can also be referred to as a user group based vector. The user group-based vector can include a plurality of elements spanning two or more dimensions, and each element can represent a particular feature of the digital composition presentation opportunity. For example, the user group-based value vector can include a geographic location or region, a spoken language, an age or age range, a particular URL of a web page or other electronic resource, an element of a particular product or service, whether the numeric component slot is above or below the top screen, a type of numeric component slot, a size of the numeric component slot, a number of numeric component slots on the electronic resource, a time of day, a network asset identifier, and/or other suitable characteristics of a numeric component presentation opportunity. In some implementations, such as implementations employing neural networks, the user group-based value vector can be an embedding of the user group in some abstract vector space.
The value of each element can reflect the amount by which the selected value of the numeric component is to be increased or decreased based on the current numeric component presentation opportunity with the feature corresponding to that element. For example, if the DSP150 wants to display the numeric components to a user in atlanta, rather than a user in dallas, the value of the atlanta element can be a positive value greater than a value of 1, and the value of the dallas element can be a positive value less than 1, such as 0, or a negative value. As described in more detail below, the values of the user group-based vector can be part of a vector dot product calculation that is used to determine the selection values of the digital components.
The request contains information used in the digital component selection process, including information that can be sensitive, such as a user group identifier of the user group to which the application 112 is mapped or otherwise associated, and insensitive information, such as contextual signals from the application 112 regarding the context in which the digital component is to be presented and/or displayed. As described in further detail below, the design of system 110 improves protection against user data that may be sensitive or confidential.
For example, the trigger element can be a tag that detects whether a numeric component slot exists within an internet location accessed by the application 112. The trigger element can, for example, be placed at an internet location and can notify the application 112 that there is a number component slot for which a number component should be requested.
In phase B, MPC cluster 130 transmits digital component requests based on insensitive information, such as context signals, to SSP 170. This request is referred to as a "context request". The context request can contain various context signals and non-sensitive user information collected directly by the internet location (e.g., content publisher) that triggered the request for the digital component. For example, the contextual signals can include analytics data, language settings, and other data that help a publisher of content provide a good user experience. However, the context request provided to the SSP170 does not include sensitive information, such as a user group identifier.
In phase C, SSP170 forwards the context request to one or more DSPs 150. In this particular example, SSP170 forwards the context request to a single DSP150 for simplicity. For example, SSP170 can forward the context request to DSP 150. In this example, DSP150 has digital components and selection values mapped to those digital components, or is able to determine the selection values of the digital components using context signals.
In stage D, the one or more DSPs 150 return a selection value in response to the context request. For example, DSP150 returns one or more selection values mapped to the digital components in response to the context request. DSP150 can return any number of selection values in response to a context request. In some implementations, DSP150 can additionally return a selection value in response to a request for a digital component based on sensitive information, such as user group information. These selection values are "conditional selection values" because they are conditioned on sensitive information, and thus are conditioned on the MPC cluster 130 receiving the request including sensitive information that matches the sensitive information for which the selection value is conditioned. For each selection value provided by DSP150, DSP150 includes information such as a time-to-live (TTL) parameter, i.e., the maximum time span over which MPC cluster 130 can buffer the selection value. This TTL parameter enables MPC cluster 130 to buffer select values received from DSP 150. In some implementations, without the TTL parameter, MPC cluster 130 does not buffer the received selection values, but instead discards the selection values after use in the selection process already in the process, e.g., in the selection process corresponding to the digital component requests transmitted in stages A, B and C.
When the vector is used to determine the selection value, the DSP150 can generate and return a second vector of values. DSP150 can generate a second vector of values based on the context signals requested by the digital components transmitted in phases B and C. This second vector can be referred to as a context vector. The context vector can include the same elements of the same features corresponding to the user group-based vector. However, DSP150 is able to determine the value of the context vector of the current digital component request based on the context signal of the digital component request. Instead, the values of the user group-based vector of DSP150 are stored as MPC cluster 130 and determined in advance, e.g., based on the user group(s) corresponding to the user group-based vector.
For each DSP150 that provides a context vector, mpc cluster 130 can determine a selection value for each stored digital component by determining the dot product of the user group-based vector and the context vector provided by DSP 150. If DSP150 has multiple user-group based vectors stored by MPC cluster 130, e.g., each vector for a different digital component, MPC cluster 130 determines the dot product of the context vector and the user-group based vector for each user-group based vector.
In some implementations, the third vector can be used based on a user profile of the user for whom the digital component request was submitted. This vector can have the same dimensions and characteristics as the other vectors, but its value is based on the user profile of the user.
For example, the value of the location element of austin in the user profile vector can have a positive value if the user is in austin, or a negative or 0 value if the user is not in austin; the value of the same location element in the context vector can have a positive value if the publisher content currently displayed to the user is highly correlated with austin; usage-based of digital components if the digital components are related to AustinThe value of the same position element in the vector of the user group is positive. To calculate the dot product of three vectors, the calculation systems MPC 1 and MPC2 first perform an element-by-element multiplication between the corresponding elements, one each of the three vectors, and then add the results. For example, assume that the three vectors are V 1 ＝{v 1,1 ...v 1,n }、V 2 ＝{v 2,1 ...v 2,n H and V 3 ＝{v 3,1 ...v 3,n Is the dot product of the three vectors
In stage E, SSP170 applies the content selection rule to the digital component corresponding to the conditional selection value. As described above, these conditions can be based on user group identifiers, frequency control, masked (e.g., muted) digital components, adjustments, and/or k-anonymity.
SSP170 also applies selection value rules to determine, for example, how a selection value affects a post-release value for a particular content provider. The post-publication value can indicate, for example, a number of digital components provided to the publisher 140 for displaying the resource or application content having the publisher 140. SSP170 then performs a selection process to determine a top unconditional selection value, which is the unconditional selection value that yields the highest post-issue value. Unconditional selection values are not conditional on sensitive information and therefore content selection rules, such as budget and regulatory rules, advertiser and numeric component exclusions, can be applied by SSP170 rather than by MPC cluster 130. SSP170 then forwards to MPC cluster 130 the following values as JIT selection values: all selection values (selection values with TTL values) for caching and post-publication values that are not less than the top unconditional selection value are enabled in the MPC cluster 130.
In phase F, the MPC cluster 130 updates its cache with the JIT select value of the received cache-enabled (i.e., with the TTL value). In addition, the MPC cluster 130 applies selection rules, such as user group membership rules, frequency control, tuning rules, and rules to prevent accurate placement of all selection values received in stage E and previously cached selection values for a particular user to select valid candidates for the selection process. These rules can include restrictions and guidance on how or how frequently the digital components are distributed, as well as other factors. These rules include frequency control, muting, resource exhaustion, and regulatory constraints. In some implementations, JIT numeric components with conditions evaluated by the MPC cluster 130 can be ignored for the current numeric component selection process. For example, ignoring these digital components in the current selection process can provide performance benefits, such as reduced selection and latency of providing the digital components. The MPC cluster 130 then runs the final selection process among all eligible candidates, selects a winning selection value, and then returns data of the numerical components mapped to the winning selection value to the application 112 in response to the numerical component request.
In phase G, the numerical components mapped to the winning selection values are presented by the application 112. The application 112 then provides a presentation notification to the MPC cluster 130. The exposure notification includes data that allows the MPC cluster 130 to update information related to the updated parameters, which allows the MPC cluster 130 to enforce selection rules on future, e.g., digital component requests received in subsequent occurrences of phase a. In some implementations, the application 112 may send the presentation notification G to the MPC cluster 130 by piggybacking on top of future component requests a to reduce the number of network communications and battery/bandwidth consumption of the mobile devices, as well as the processing/computing cost of the MPC cluster 130.
FIG. 3 is a swim lane diagram of an example process 300 for selecting digital components for distribution to a client device. The operations of process 300 can be implemented, for example, by client devices 110, computing systems MPC 1 and MPC2 of MPC cluster 130, and DSP 150. The operations of process 300 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 300. Although the process 300 and the following other processes are described in terms of two computing system MPC clusters 130, MPC clusters having more than two computing systems can also be used to perform similar processes. Additionally, the operations of process 300 can be implemented by SSP 170.
The example process 300 can include changes such as a rank, a boost, a first value selection process (e.g., a first price auction), a second value selection process (e.g., a second price auction), and a reserve price. Each of these variations is described with reference to fig. 3 to 5.
Generally, boosting is the amount by which the selected values of the digital components are adjusted. For example, the content publisher can instruct the SSP170 to specify an amount "x" of boost to a particular DSP150 when selecting a digital component to display with one of the publisher's resources 145 or application content. If the DSP150 submits the selection value "y," the selection value used in the digital composition part selection process will be x + y. However, if a digital component is selected, then only the DSP150 is required to provide an amount of no more than y during the first or second selection of values. In process 300, MPC cluster 130 can apply a boost to the selection value based on information provided by SSP 170. For example, each SSP170 can provide information that maps boosts to DSP150 and publisher 140 pairs. That is, the information can indicate that the selection value of a particular DSP should be boosted by a particular amount for use in a digital part selection process that selects digital parts to be displayed together with the content of a particular publisher. In some implementations, the SSP/publisher can support finer-grained level promotion. For example, for each lookup key (e.g., for each context signal set), the SSP/issuer can specify the promotion.
SSP170 can instruct secure MPC cluster 130 to divide DSPs 150 into multiple classes with different priorities. In the number component selection process, instead of selecting a number component corresponding to the highest selection value among all candidate number components, a number component having the highest selection value in the highest priority ranking is selected. To illustrate, consider an example in which there are two levels, a highest level and a lowest level. If one or more candidate numeric components exist in the highest ranking, the candidate numeric component having the highest selection value in the highest ranking is selected even if the selection value of the candidate numeric component in the lowest ranking is higher than the selection values of all candidate numeric components in the highest ranking.
The main difference between the first value selection process and the second value selection process is the amount of clearance of the selected digital component. The clearing amount is the amount that DSP150 needs to provide to publisher 140 and/or SSP170 for displaying the digital components. The same numerical components will be selected using both processes. In a first value selection process, the DSP150 would be required to provide the publisher 140 and/or SSP170 with an amount equal to the selection value submitted by the DSP 150. In the second value selection process, the DSP150 will need to provide an amount based on the second highest selection value. If the grade is used with a second selected value process, the second highest value will be the second highest value in the same grade as the selected numerical component. If no such candidate number component exists in the same rank, the second highest value can be the minimum value of the number component selection process.
The lower selection value limit can indicate that the publisher 140 is willing to accept the minimum selection value for displaying the numeric component. The publisher 140 can specify a lower selection value limit for: for the various DSPs 150, for each category of digital components (e.g., a lower limit specifying a lower selection value for automobile-related digital components, and a lower selection value for gardening-related digital components), for each digital component provider 160, for each brand, for each page on the publisher site, for each digital component slot, for groups of digital component slots, and/or for other types of digital component groups. In some implementations, SSP170 can preset a lower limit on behalf of publisher 140 or for each digital component request of phase a, for example.
The DSP150 provides the MPC cluster 130 with selection values and additional information (e.g., selection criteria, such as conditions) for the digital components (302). In some implementations, DSP150 provides the selection values and additional information to MPC cluster 130 via an SSP (not shown in fig. 3 for simplicity). For example, DSP150 can provide a selection value and additional information in response to a digital component request and designate the digital component corresponding to the selection value as the stored digital component that should be stored at MPC cluster 130.
The additional information for the digital component can include a context selection signal that indicates a context that the digital component is eligible for, e.g., a location of client device 110, a spoken language selected for application 112, a URL of a resource that enables presentation of the digital component, and/or a URL that excludes resources that cannot be presented with the digital component. Such additional information of the numeric component can also identify the numeric component, e.g., using a unique identifier, a field from which the numeric component can be obtained, and/or other suitable data of the numeric component. This additional information can be included as metadata of the digital component.
In some implementations, the MPC cluster 130 caches or otherwise stores selection values, selection criteria, and other information for the digital components requested to be provided to the MPC cluster 130. In this example, the context signal and the selection value of the digital component can include the context signal included in the digital component request. As described above, the selection values and metadata can be stored in a two-stage LUT.
In some implementations, DSP150 can provide a user group-based vector of values for the digital components rather than providing statically selected values for the digital components. In such an example, a user group-based value vector can be stored instead of selecting a value.
The client device 110 identifies a set of subscriber group identifiers (306). The set of user group identifiers can be user group identifiers of user groups that include the user as a member. For example, the set of subscriber group identifiers can be subscriber group identifiers in a subscriber group list. The application 112 rendering the content or trusted program can identify the set of user group identifiers, for example, by accessing a securely stored list of user groups from the client device 110.
The client device 110 generates a probabilistic data structure (308). To securely and efficiently generate digital component requests based on sensitive information, the application 112 can use a probabilistic data structure, such as a cuckoo filter or a Bloom filter. In this example, the probabilistic data structure is a cuckoo filter. An example of using a Bloom filter is described with reference to FIG. 8. Generally, a cuckoo filter includes an array of buckets, where each bucket is capable of holding b fingerprints. A fingerprint of an item is a bit string derived from a hash of the item. The cuckoo filter uses n hash functions, which allow one item to be placed in any b positions in n different buckets. Typically, cuckoo filters are identified by the number of fingerprints in each bucket and the number of buckets. For example, a (2,4) cuckoo filter has 2 buckets, each bucket in the cuckoo array capable of storing up to 4 fingerprints. Thus, the total capacity of the cuckoo filter is 2x4 or 8 fingerprints.
Depending on the configuration of the cuckoo filter, items can be inserted into N possible locations in the cuckoo filterFor example, N =2. The application 112 uses N pseudo-random functions (PRFs) parameterized by the user group identifier or an identifier from the masked set of identifiers and either of two random variables generated by the application 112 to determine all possible locations where an item is inserted. For example, assume that the two random variables generated by the application 112 are rand _ var1a and rand _ var1b. In some implementations, the application 112 and MPC cluster 130 agree on a PRF in advance, where PRF (x, y) e [0,2 k -1]Where k is the number of bits in each entry in one bucket in the cuckoo filter.
Each position of the cuckoo filter can be occupied by a user group identifier or a mask identifier, or empty. The mask identifier is an identifier of the digital component that the application 112 is masking, e.g., based on frequency control or user selection. The application 112 can generate a cuckoo filter table whose elements are PRF (ug _ id, rand _ var1 a), PRF (blocked _ uid, rand _ var1 b), and 0, where ug _ id is an identifier of the user group generated by applying HMAC on the tag of the user group based on the domain of the content provider, blocked _ uid is an identifier in the masked identifier set, and 0 represents an empty item. The process is repeated for all subscriber group identifiers. In some implementations, the same probabilistic data structure, e.g., a cuckoo filter or a Bloom filter, can store the subscriber group identifier and the mask identifier. In other implementations, the subscriber group identifier and the mask identifier are stored in a dedicated probability data structure.
The application 112 can generate the vector B based on a cuckoo filter table generated for the user group identifier and/or the mask identifier. Each value B in the vector B i Can be represented as B i ＝(A i PRF (rand _ var2, i)) mod p where a is the cuckoo filter table and i is the index of the vector B and the cuckoo filter table a. When the application 112 initiates a request for a digit component of a digit component slot, the application 112 transmits rand _ var1a, rand _ var1b and rand _ var2 as parameters of the request to the computing system MPC 1. The application 112 also transmits the vectors B, rand _ var1a and rand _ var1b as requested parameters to the computing system MPC 2.PRF (rand _ var2, i) and Bi are Ai in Z p Are shared in secret, which are held by computing systems MPC 1 and MPC2, respectively. Because neither computing system MPC 1 or MPC2 has simultaneous access to both secret shares, neither computing system can recreate the cuckoo filter table, thereby protecting user privacy.
The client device 110 transmits a digital component request including parameters for a cuckoo filter to the MPC cluster 130 (310). For example, the client device 110 can transmit a digital component request comprising rand _ var1a, rand _ var1b and rand _ var2 to the computing system MPC 1. The client device 110 is also able to transmit to the computing system MPC 2a digital component request comprising the vectors B, rand _ var1a and rand _ var1b. The two digital component requests can also include context signals, such as a URL of the electronic resource, a number of digital component slots of the resource, a geographic location of the client device 110, and/or other suitable context signals, such as a lookup key, that can be used to select the digital component.
SSP170 transmits the context number component request to one or more DSPs 150 (314). Each DSP150 is capable of responding to requests with one or more conditionally selected values for the digital components and/or one or more unconditionally selected values for the digital components. For each digital component, the response can include data identifying the digital component, a selection value for the digital component, and metadata (or other additional information) for the digital component. For example, the response can include a digital component information element dc _ information _ element for each digital component. Each DSP150 is capable of selecting one or more digital components to include in the digital component selection process based on the context signals and determining or identifying a selection value for each selected digital component. In some implementations, DSP150 can generate a context vector for each of the one or more digital components based on the context signals.
Each DSP150 can transmit its response to the SSP170 (316). SSP170 can transmit the response to MPC cluster 130 (318). In some implementations, SSP170 can apply one or more lower bounds to the digital component selection process prior to transmitting the response to MPC cluster 130. SSP170 can apply the lower limit(s) based on the issuer 140 of the electronic resource of the selected digital component. As described above, the publisher 140 can specify a lower limit for the DSP150, a category of digital components, a digital component provider 160, a brand, and/or other types of digital component groups.
The SSP170 can identify the lower bounds specified by the publisher 140 and apply them to the selection values received from the DSP 150. If the selection value is less than the corresponding lower limit, SSP170 can remove the selection value from the digital component selection process, for example, by not providing the selection value to MPC cluster 130. For example, assume that publisher 140 specifies a lower limit of five units for a given digital component provider 160. If DSP150 provides a four unit selection value for a digital part of a given digital part provider 160, SSP170 can filter the selection value from the digital part selection process.
As described above, DSP150 is capable of providing select values for stored digital components to be stored for future use in digital component processing. If these selection values do not meet the corresponding lower limit(s), the digital components and their associated selection values are not stored at MPC cluster 130 because SSP170 does not forward them to MPC cluster 130.
In some implementations, MPC cluster 130 enforces a lower bound instead of SSP170, or MPC cluster 130 enforces a lower bound in addition to SSP 170. When using vectors to determine selection values, the MPC cluster 130 calculates the dot product of the vectors, and the MPC cluster 130 can enforce a lower bound on these selection values. The MPC cluster 130 can also enforce a lower bound on static selection values, e.g., instead of SSP 170.
The MPC cluster 130 executes the secure MPC process to select the digital components to provide for display at the client device 110 (320). The selection can include identifying a set of digital components and their corresponding selection values that are eligible for the digital component selection process based on the context signal, e.g., using a lookup key, such as the first stage lookup key described above with reference to fig. 1. This can also include identifying candidate numeric components from the set of numeric components that are candidates for selection. The candidate number components can include unconditional number components for which the DSP150 provides a selection value and conditional number components that satisfy each condition of the number components. Only when all the conditions of the numerical component are satisfied, the conditional numerical component is considered as a candidate for the numerical component selection process.
The MPC cluster 130 can also consider any ranking or boosting of the digital components in selecting the digital components. As described above, the publisher 140 can establish ratings and/or promotions for the DSP150 and/or the digital component provider 160. When the publisher 140 for which the digital part is selected has established a promotion, the MPC cluster 130 (or SSP 170) can adjust the selection values for the digital parts of the DSP150 and/or digital part provider 160 using the corresponding promotion specified by the publisher 140. If a vector is used to determine the selection value, the MPC cluster 130 can adjust the selection value after it is determined by the point at which the vector is calculated.
When using ranks, the MPC cluster 130 can perform a selection process for each rank, e.g., sequentially or in parallel from highest priority to lowest priority. The MPC cluster 130 can select the number component having the highest selection value in the highest priority ranking that includes at least one candidate number component. For example, if none of the numeric components in the highest priority level are candidates, e.g., all of their conditions are met for inclusion in the numeric component selection process, the MPC cluster 130 selects a candidate from the second highest priority level that includes the candidate.
The MPC cluster 130 can perform each level of the selection process in parallel to increase the speed at which the selection process is performed. In this way, if there are no candidates in the highest priority level, the MPC cluster 130 has already begun and may have completed the selection process for each other level, so that the final digital component can be selected.
The MPC cluster 130 can perform the selection process sequentially from the highest priority level to the lowest priority level. If speed is less critical, this can reduce the computational waste performed for lower priority levels if the higher priority level includes candidate digit components. An example process for selecting digital components using a secure MPC process is shown in FIG. 4 and described below.
The MPC cluster 130 transmits 322 the secret share of the selection result to the client device 110. In some implementations, the MPC cluster 130 can also send a selection process identifier for the numeric component selection process to the client device 110. The selection process identifier is capable of uniquely identifying the digital component selection process for which the selection result was generated. For example, computing systems MPC 1 and MPC2 can each generate a respective selection process identifier SPID for each digital component request for which computing systems MPC 1 and MPC2 perform a selection process to generate a selection result to provide to client device 110. In some implementations, the selection process identifier SPID can be a random number (nonce) or an opaque alphanumeric or numeric sequence.
The MPC cluster 130 can also store data for selection values that are part of the selection process keyed or otherwise linked to the SPID by the SPID. For example, computing system MPC 1 can store a table or other data structure that includes data for selection values with SPIDs generated for the selection process based on the SPIDs generated by computing system MPC 1 1 The key of (2). Similarly, computing system MPC2 can store a table or other data structure that includes data for the selection values with SPIDs generated for the selection process based on the basis of the values generated by computing system MPC2 2 The key of (2). This enables the MPC cluster 130 to update the process variables of the feedback controllers based on the data received from the client devices 110.
The selection result can be in the form of a byte array that includes information about the selected digital component. For example, the selection result can be a byte array that includes values of the digital components in the second LUT, e.g., selection values of the digital components and metadata of the digital components. Computing systems MPC 1 and MPC2 are able to use a secure MPC process to determine a secret sharing of the selection results, as described in more detail below. Computing system MPC 1 is capable of transmitting a first secret share of the selection result to client device 110, and computing system MPC2 is capable of sending a second secret share of the selection result to client device 110. To prevent computing systems MPC 1 and MPC2 from knowing the selected digital components, computing systems MPC 1 and MPC2 can be prevented from sharing the secret of their selection results with each other.
In some implementations, the client device 110 can request the digital components based on user group membership from the MPC cluster 130. Client device 110 can also request digital components based on context signals from SSP 170. These context signals can include the same context signals described above, as well as optionally additional context signals, such as a number of digital component slots of a resource, a type of digital component slot, a type and/or format of digital components that can be displayed with a resource, and so forth. SSP170 can select one or more digital components based on the context signal and the selection value of the digital component and provide the one or more selected digital components (or data identifying the digital components) and the selection value of the digital component to client device 110. The client device 110 can then select a digital part for display with the resource from the set of digital parts that includes the digital part of the selection result received from the MPC cluster 130 and the digital part(s) selected by the SSP 170. If the resource includes multiple digital component slots, client device 110 can request the corresponding digital components for each slot from MPC cluster 130 and SSP 170.
The client device 110 can transmit one or more event notifications to the MPC cluster 130 (328). For example, assuming that the digital component of the selection result received from the MPC cluster 130 is displayed by the application 112 of the client device 110, the application 112 can transmit a presentation notification of the digital component in response to displaying the digital component. In another example, the application 112 can transmit a user interaction notification in response to detecting a user interaction, e.g., a selection/click of a numeric component.
For user interaction notifications, the application 112 can generate a secret share of the clicked parameter clicked, which is a Boolean parameter that can have a value of 1 if the user interacts with the numeric component or a value of 0 if the user does not interact with the numeric component for a specified duration after the numeric component is displayed. Thus, in this example, either value indicates that a numeric component is displayed, but a value of 1 can indicate that a user is interacting with the numeric component. Application 112 can send a first notification to computer system MPC 1 that includes the SPID received from computer system MPC 1 1 Shared with first secret of clicked parameter [ clicked 1 ]. Similarly, application 112 can send a second notification to computer system MPC2 that includes the SPID received from computer system MPC2 2 And a second secret sharing of the clicked parameter [ clicked 2 ]. In another example, the notification can separately indicate whether the numeric component is displayed at the client device 110, e.g., using secret sharing similar to the clicked parameter.
Presentation and user interaction notifications enable the MPC cluster 130 to update the process variables of the feedback controllers used to regulate the distribution of the digital components. For example, if the process variable is a show rate, the MPC cluster 130 can use the show notification to update the show count for the digital components (or activities that include the digital components). If the process variable is a user interaction rate, the MPC cluster 130 is able to use the clicked on parameter to update the number of user interactions of the digital components (or activities that include the digital components). In a specific example, computing system MPC 1 is capable of using SPIDs 1 To obtain stored data for the selection process and the computing system MPC2 is able to use the SPID 2 To obtain stored data for the selection process. The MPC cluster 130 can then perform a secure MPC process to update the active process variables (e.g., exposure rates, interaction rates, conversion rates, and/or resource consumption rates) of the digital components displayed by the applications 112. Similarly, the MPC cluster 130 can use the notification to update the count used to determine whether the digital components satisfy the k-anonymity condition.
FIG. 4 is a swim lane diagram of an example process 400 for selecting digital components for distribution to a client device. The operations of process 400 can be implemented, for example, by computing systems MPC 1 and MPC2 of MPC cluster 130. The operations of process 400 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 400.
The process 400 can be used for a first value selection process, a second value selection process, and/or a selection process that includes a boost and/or a lower bound. Each of these variations is described below. Another example process 500 illustrated in fig. 5 can be used to include a rank selection process. The process 500 can also support a first value selection process, a second value selection process, a boost, and/or a lower limit.
The selection values can include stored selection values for the digital components for which data is stored by each of the computing systems MPC 1 and MPC2, as well as JIT selection values received from the SSP170 for the digital component selection process. For the case where a vector is used to determine the selection value, each computing system MPC 1 and MPC2 is capable of determining the selection value by determining the dot product of the vector of digital components. Computing systems MPC 1 and MPC2 may also be capable of applying any promotion to the digital components for which the publisher 140 or SSP170 has established a promotion and/or enforcing any lower bound established by the publisher 140 or SSP 170.
In an implementation using a two-stage LUT, the computing system MPC 1 is able to identify a eligible digital component using the first-stage lookup key of the digital component request. The computing system MPC 1 is capable of accessing the first stage LUT and using the first stage lookup key to identify rows of the second stage LUT that include information of digital components that meet the conditions for display, e.g., digital components for which a selection value has been received for the set of context signals represented by the first stage lookup key. For example, as described above, each row of the second stage LUT includes information for the digital component and the second stage lookup key based on the context signal set. Thus, the computing system MPC 1 is able to use the first stage lookup key to identify rows of the second stage LUT having a set of context signals that match the set of context signals defined by the first stage lookup key received in the digital component request. The rows include information of numeric components that are eligible for display or have eligible selection values for a context defined by a first-phase lookup key received in a request for a numeric component.
Computing system MPC2 identifies eligible digital components (406). Computing system MPC2 is capable of identifying eligible digital components for digital component requests received from client devices 110. Computing system MPC2 can identify eligible digital components in a similar manner as computing system MPC 1. In implementations where the MPC cluster 130 enforces the lower limit, each MPC computing system MPC 1 and MPC2 is sufficiently young to filter out from the eligible digital components any eligible digital components that have a selected value for their corresponding lower limit that is not satisfied, e.g., is not satisfied or is exceeded.
For each eligible digital component, computing systems MPC 1 and MPC2 determine whether the digital component and its selection value are candidates to be selected for distribution to client device 110 in response to the digital component request (408). If the numeric component is a qualified numeric component, then the candidate numeric component is a qualified numeric component that satisfies all one or more conditions of the numeric component. Each unconditional numeric component that is eligible based on context is also a candidate numeric component. Computing systems MPC 1 and MPC2 are able to determine candidate digital components using a secure MPC process such that neither computing system MPC 1 or MPC2 is able to identify the candidate digital components in clear text.
For user group membership conditions, the computing systems MPC 1 and MPC2 are able to calculate a user group membership condition parameter ug check for each eligible digital component "i i To the corresponding secret sharing. User group membership condition parameter ug check maintained by computing system MPC 1 i Can be represented as [ ug check ] i,1 ]User group membership condition parameter ug check maintained by computing system MPC2 i Can be represented as [ ug check ] i,2 ]. Brackets are used to indicate secret sharing of parameters.
For implementations that use cuckoo filters to represent user group membership for a user, computing system MPC 1 and computing system MPC2 cooperate to compute [ ug check ] according to the following relation 1 i,1 ]：。
In relation 1, Π represents multiplication of a plurality of terms. Here, ug _ id (x) is a function for retrieving the user group identifier ug _ id associated with the selection value x, { F 1 ,…F N Is a set of hash functions to compute a possible index of the entries in the cuckoo filter table a, and rand val1a is a random value received in the numeric component request. [ M ] A x,1 ]Is an array [ M 1 ]The xth element of (1). = equality test between secret sharing of a plaintext integer and a secret integer. The result of = is a secret share of 0 (not equal) or 1 (equal) secret integer. Here, [ M ] i,1 ]Value of = [ PRF (rand _ val2a, i) ] 1 ]。
Similarly, computing system MPC2 cooperates with computing system MPC2 to compute [ ug check ] according to the following relation 2 i,2 ]：。
Here, [ M ] i，2 ]Value of (1 = B) i 。
For digital components conditioned on the user group membership of the user for whom the digital component was selected, the computing systems MPC 1 and MPC2 are capable of computing a user group membership condition parameter ug check i Secret sharing of [ ug _ check ] i,1 ]And [ ug_check i,2 ]. The combination of the two secret shares can be a boolean value that indicates whether the user is a member of the group of users corresponding to the digital component. For example, a value of 1 can indicate that the user is a member, and a value of 0 can indicate that the user is not a member. For digital components that are not conditioned on user group membership of the user, computing systems MPC 1 and MPC2 can use secret sharing ug check i,1 ]And [ ug _ check i,2 ]Such that the combination has a value (e.g., 1) indicating that the user is a member of the user group corresponding to the numeric component.
In implementations that use Bloom filters to represent user group memberships for a user, computing systems MPC 1 and MPC2 are capable of querying the Bloom filters, as described with reference to fig. 8. As a result, the computing system MPC 1 has, for each hash function of the Bloom filter, a first secret share [ ug _ check ] of the user group membership condition parameter i,1 ]. Similarly, for each hash function of the Bloom filter, computing system MPC2 has a second secret share of the user group membership condition parameter ug check i,2 ]. For digital components that satisfy the user group membership condition, the user group membership condition parameter for each hash value of the Bloom filter, ug check i It will need to have a boolean value true or 1. The secret sharing of each hash value can be included in the final calculation of the secret sharing of the candidate parameters of the digital component.
The computing systems MPC 1 and MPC2 are further capable of cooperatively computing masked digital component parameter block _ check conditioned on frequency control or muting for each digital component i i Corresponding secret sharing [ blocked _ check ] i,1 ]And [ blocked _ check ] i,2 ]. The combination of the two secret shares can be a boolean value that indicates whether the digital component satisfies a masked digital component condition based on frequency control (e.g., the number of times the digital component is provided to the user during the duration of time does not exceed a threshold number of times) and/or whether the user chooses not to display the digital component to the user. For example, a Boolean value true or a value of 1 can indicate that it can be based on theseThe factors display the numeric component to the user, and a boolean value false or value 0 can indicate that the numeric component cannot be displayed to the user based on these factors.
To determine a secret share of masked digital component parameters, computing systems MPC 1 and MPC2 can use a share, e.g., an array, of Bloom filters representing identifiers of masked digital components. Application 112 can generate Bloom filters representing identifiers of masked digital components and send data representing the Bloom filters to computing systems MPC 1 and MPC2 as described with reference to fig. 8. Computing systems MPC 1 and MPC2 may then query the Bloom filters using an array representing the Bloom filters to obtain the secret share [ blocked _ check ] i,1 ]And [ blocked _ check ] i,2 ]As described with reference to fig. 8.
To enforce resource exhaustion (e.g., budgeting) and tuning rules, computing systems MPCs 1 and MPCs 2 can randomly mask digital components from participating in the digital component selection process using probabilities determined using feedback controllers and resource exhaustion conditions. If the activity including the numerical component does not have any additional resources, the probability is set to 1. Otherwise, if the activity is ahead of hand-overBy arranging, then the probability is set high (e.g., above 0 and close to 1), so that computing systems MPC 1 and MPC2 are more likely to mask digital components from the digital component selection process, e.g., by computing secret sharing [ sharing _ check ] i,1 ]And [ packing _ check ] i,2 ]So that the control checking parameter paging _ check is adjusted i Has a value of 0. If the activity falls behind the delivery schedule, the probability is lower.
For each digital component request and each digital component, the computing systems MPC 1 and MPC2 compute uniformly distributed [0, max range]The secret number in (1). If the random number is less than or equal to the tuning selector parameter, tuning _ selector, then the computing systems MPC 1 and MPC2 shield the digital components to participate in the digital component selection process, e.g., by computing a secret share [ tuning _ check ] i,1 ]And [ packing _ check ] i,2 ]So that the control checking parameter paging _ check is adjusted i Has a value of 0.
To protect the user privacy and confidential information of the participants in the digital component selection process, both the random number and the tuning selector parameters are in additive secret sharing. The comparison between the two secret shares can be performed using a garbled circuit protocol. By limiting both secret shares to six or seven bits, the comparison protocol may make one or two rounds of communication between computing systems MPC 1 and MPC 2.
To determine the tuning selector parameters for an activity, the computing system can calculate the amount of resources used per activity as resources _ used _ boosting = ∑ (cleaning _ value x is _ dc _ the _ winner), where the sum is across all digital component selection processes, including the digital components of the activity, the parameter cleaning _ value is the purge value of the digital component selection process, and is _ dc _ the _ winner is the winner parameter of the digital component in the digital component selection process. This calculation can be performed in a secret sharing such that each computing system MPC 1 and MPC2 holds a secret sharing of the amount of resources used. Computing systems MP1 and MPC2 can then calculate the resource exhaustion parameter resources _ exhausted for an activity by determining whether the amount of resource used, i.e. resources _ used _ campaigns, is greater than the total amount of resources assigned for the activity in the secret share.
pacing_selector＝resources_exhausted×maximumrange+(1-resources_exhausted)×output，
Wherein the parameter output is an output of the feedback controller. The calculation can use one RPC between the computing systems MPC 1 and MPC2 to calculate the multiplication in the secret sharing. However, the calculations can be performed periodically offline to prevent any additional delays.
The computing systems MPC 1 and MPC2 are also able to cooperate to compute the k-anonymity check parameter kanonym check for each digital component i that has to satisfy the k-anonymity condition i Of (Kanonymity _ check) i,1 ]And [ kanonymitty _ check ] i,2 ]This can apply to all digital components in some implementations. The combination of the two secret shares can be a boolean value that indicates whether the numeric component satisfies the k-anonymity condition. For example, a value of 1 can indicate that the digital component satisfies k-anonymity, and a value of 0 can indicate that the digital component does not satisfy k-anonymity and that a process mask should be selected from the digital component.
For each condition of each condition digital component (e.g., a digital component having at least one condition), each computing system MPC 1 and MPC2 is capable of storing a corresponding secret share of parameters for each condition of the digital component. Thus, as long as at least one MPC computing system is honest, neither computing system MPC 1 nor MPC2 has knowledge of the parameter values in clear text. Each digital component can be conditioned on zero or more conditions. For a given digital component selection process, some digital components can have different conditions and/or a different number of conditions than other digital components.
Although some example conditions are provided above, other conditions can be used. Typically, the computing systems MPC 1 and MPC2 are able to compute a secret share of the condition parameters using a secure MPC process. The criteria and techniques for determining the condition parameters can vary. In some implementations, a secret sharing of condition parameters can be received from another computing system, e.g., such that computing systems MPC 1 and MPC2 do not calculate the condition parameters.
is_dc_a_candidate i ＝ug_check i AND blocked_check i AND pacing_check i AND kanonymity_check i
since the value of each condition parameter is in secret sharing, computing systems MPC 1 and MPC2 can cooperate in a secure MPC process using round-trip Remote Process Calls (RPCs) to determine a corresponding secret sharing [ is _ dc _ a _ secret ] of a candidate parameter of a digital component i using secret sharing of the condition parameter i,1 ]And [ is _ dc _ a _ candidate i,2 ]. Any suitable secret sharing algorithm for determining a logical sum (AND) operation can be used to determine the secret sharing [ is _ dc _ a _ candidate ] of the candidate parameter of the digital component i i,1 ]And [ is _ dc _ a _ candidate i,2 ]. The computing systems MPC 1 and MPC2 are able to determine the secret sharing of the candidate parameters using only the secret sharing of the condition parameters for those conditions. As the secure MPC process ends, the computing system MPC 1 holds a first secret share [ is _ dc _ a _ candidate ] of the candidate parameters for each conditional digit component i,1 ]The computing system MPC2 holds a second secret share [ is _ dc _ a _ candidate ] of the candidate parameters for each conditional digit component i,2 ]。
In some implementations, computing systems MPC 1 and MPC2 evaluate relation 3 for each digital component using a garbled circuit protocol. In this example, one of computing systems MPC 1 or MPC2 is capable of building a garbled circuit. For this example, assume that computing system MPC 1 is constructed with a garbled circuit. Computing system MPC 1 knows its own secret share and also knows only one possible bit pattern that computing system MPC2 must hold in order for the candidate parameters for the digital components to become the future, or 1. With this property, the computing system MPC 1 only needs up to 50 gates to build the scrambled circuit, for example, if there are a total of about 50 boolean parameters in relation 3.
In relation 3, there is only one user group membership condition parameter ug check i . However, if a Bloom filter is used to represent a user's user group membership, then the relation 3 can include a respective user group membership condition parameter ug check for each hash function of the Bloom filter i . Similarly, if a Bloom filter is used to represent a masked digital component, then relation 3 would include the Bloom filterThe respective masked digital component parameter blocked _ check of each hash function of the hash function i . In relation 3, paging _ check i It is only present when the owner of the digital component enables the adjustment check.
The computing system MPC 1 determines the order of the digital components based on the selection values (410). Similarly, computing system MPC2 determines the order of the digital components based on the selection values (412). The two sequences should be identical because the inputs to the ranking process are identical on both computing systems MPC 1 and MPC 2. Each computing system MPC 1 and MPC2 is capable of determining the order of the digital components. Each order can include the candidate number component and other number components evaluated for eligibility in step 408. For example, the order can include all available digital components that are available for the digital component selection process, all eligible digital components of the digital component selection process (e.g., eligible based on context signals), or all digital components in the second stage LUT if one digital component is used. The order can be from the numerical component having the highest selection value to the numerical component having the lowest selection value. In some implementations, the selection value for the order can be, for example, a value to be provided to the publisher 140 of the resource with which the selected digital component is to be displayed after any sharing with the DSP150 and/or SSP170, plus any applicable boost.
Since the selection values are in clear text, the computing systems MPC 1 and MPC2 do not have to perform any round-trip calculations to determine the order of the digital components. Instead, each computing system MPC 1 and MPC2 is capable of independently ranking the selection values. If the selection values are stored as secret shares at each of the computing systems MPC 1 and MPC2, where each of the computing systems MPC 1 and MPC2 has a respective secret share for each selection value, then the computing systems MPC 1 and MPC2 can perform a secure MPC process using round-trip computations to order the selection values. If there is a tie between two or more selection values, the computing systems MPC 1 and MPC2 can use other metadata of the numerical components corresponding to these selection values to definitively break the tie.
TABLE 3
In some implementations, the cumulative value for a given numeric component represents the total number of candidate numeric components from the top of the order to the given numeric component, which is included if the given numeric component is a candidate. In this example, the fourth column would indicate whether the accumulated value is equal to 1 instead of 0. For the sake of brevity, the remaining discussion will pertain to the first example, where the cumulative value of a given numerical component represents the total number of candidate numerical components from the top of the order to the given numerical component, but excludes the given numerical component even if the given numerical component is a candidate.
Conceptually, in table 3, the cumulative value (acc) for each digital component having the candidate parameter is _ dc _ a _ candidate equal to 1 increases as it progresses from the top of the order to the bottom of the order. As described below, the calculation of the accumulated value acc is performed in secret sharing. For example, since the candidate parameter is _ dc _ a _ candidate of the highest selection value is equal to 0, the cumulative value acc of the digital component having the highest selection value is 0. Since the candidate parameter is _ dc _ a _ candidate of the second high-digit component is equal to 1, but none of the selection values above the second high-digit component has the candidate parameter is _ dc _ a _ candidate equal to 1, the accumulated value acc of the second high-digit component is also 0. Moving down in order, the candidate parameter is _ dc _ a _ candidate based on the second highest selected value has a value of 1, and thus the accumulated value acc of the candidate parameter is _ dc _ a _ candidate of the third highest selected digit component is incremented to a value of 1. Since the candidate parameter is _ dc _ a _ candidate of the third highest numerical component is 0, the accumulated value acc of the fourth numerical component is not incremented and has a value of 0 as the third highest numerical component.
Using table 3, the computing systems MPC 1 and MPC2 will select for distribution to the client device 110 the digital components corresponding to the selection values for which the overall candidate parameter is _ dc _ a _ candidate has a value of 1 and the cumulative value acc has a value of 0, as shown in the fourth column of table 3. This means that the candidate parameter is _ dc _ a _ candidate has a value of 1, corresponding to the numerical component of the highest ranking selection value. Since the candidate parameter is _ dc _ a _ candidate is in the secret sharing of the computing systems MPC 1 and MPC2 to maintain user privacy and ensure that user data is not leaked, the computing systems MPC 1 and MPC2 determine the secret sharing of the accumulated value acc of each digital component and use round-trip computation to determine which digital component has an accumulated value acc equal to 0 and a candidate parameter is _ dc _ a _ candidate equal to 1.
In some implementations, depending on the secret sharing algorithm, computing systems MPC 1 and MPC2 are able to independently determine the secret sharing of the accumulated value acc of each digital component without any round-trip computation. For example, for each digital component i, the computing system MPC 1 can determine the first share of the accumulated value acc [ acc ] by traversing all digital components in order from highest to lowest and summing the candidate parameters is _ dc _ a _ candidate of the digital components along the way i,1 ]As described above with reference to table 3. Similarly, for each digital component i, the computing system MPC2 can determine a second share [ acc ] of the accumulated value acc by traversing all digital components in order from highest to lowest and summing the candidate parameters is _ dc _ a _ candidate of the digital components along the way i,2 ]。
The computing systems MPC 1 and MPC2 are capable of participating in multiple rounds of computation, e.g., multiple RPCs, as part of a secure MPC process to compute the equality operation acc with secret sharing with respect to each digital component i i =0. The equality operation is used to determine the accumulated value acc of the digital component i i Has a value of 0. At the end of the process, the computing system MPC 1 has a result acc for each digital component i i =0, and the computing system MPC2 has a result acc for each digital component i =0 further secret sharing.
In some implementations, computing systems MPC 1 and MPC2 are capable of executing a secret sharing multiplication protocol to calculate, for each selected value, a winner parameter is _ dc _ the _ winner in terms of secret sharing i ＝＝(is_dc_a_candidate i ×(acc i = 0)). This can include one RPC to multiple two-secret sharing between computing systems MPC 1 and MPC 2. At the end of the MPC process, the computing system MPC 1 has the result is _ dc _ the _ winner i A secret sharing ofDenoted as [ is _ dc _ the _ winner [ ] i,1 ]＝[is_dc_a_candidate i,1 ]x([acc i,1 ]= 1). Similarly, computing system MPC2 has a result is _ dc _ the _ winner i Is denoted as [ is _ dc _ the _ winner [ ] i,2 ]＝[is_dc_a_candidate sv,2 ]x([acc i,2 ]= 0). Note that for all digital components, at most one digital component has a winner parameter is _ dc _ the _ winner equal to 1 i This is the digital component selected for distribution to the client device 110. All other digital components will equal 0.
For the first value selection process, computing systems MPC 1 and MPC2 can perform a similar process to determine the winner parameter is _ dc _ the _ winner of each digital component i i . For example, computing systems MPC 1 and MPC2 can perform a secret sharing equality test to determine a first selection value parameter maybe _ first _ sv i ＝(acc i = 0) secret sharing. First selection value parameter maybe _ first _ sv of digital component i i Can be a boolean value that indicates whether the selected value of the numeric component is likely to be the highest of the candidate numeric components. Only if the numerical component corresponding to the selection value is actually a candidate numerical component will the selection value be the highest selection value among the candidate numerical components. Thus, the first selection value parameter maybe _ first _ sv of the digital component i i Indicating whether a numeric component will have the highest selection value if it is actually a candidate numeric component. At the end of this equality test, the computing system MPC 1 has the first selection-value parameter maybe _ first _ sv for the digital component i i Is shared with the first secret [ maybe _ first _ sv i,1 ]And the computing system MPC2 has a first selection value parameter maybe _ first _ sv of the digital component i i Second secret share of [ maybe _ first _ sv ] i,2 ]。
The computing systems MPC 1 and MPC2 can then calculate the winner parameter for secret sharing is _ dc _ the _ winner for each digital component i using the following relation 4 i ：
is_dc_the_winner i ＝＝((is_dc_a_candidate i ＝TRUE)AND(maybe_first_sv i ＝TRUE))
Conceptually, the computing systems MPC 1 and MPC2 can calculate the selection result parameter "result" using the following relation 5:
that is, computing systems MPC 1 and MPC2 are capable of determining the winner parameter is _ dc _ the _ winner across all digital components i And a digital component information element dc _ information _ element i The sum of the products of (a). In this example, if there are no candidate digital components, the selection result will have a value of 0, or will have a value of the digital component information element dc _ information _ element equal to the selected digital component having the winner parameter is _ dc _ the _ winner equal to 1 i . In another example, the digital component information element dc _ information _ element can be replaced with a selection value of the digital component in relation 5. In this example, if there are no candidate digital components, the selection result will have a value of 0, or will have a value equal to the selection value of the selected digital component having the winner parameter is _ dc _ the _ winner equal to 1 i 。
To perform calculations in secret sharing, the computing system MPC 1 obtains all digital components and uses the digital component information elements dc _ information _ element of the digital components i Which can be in plaintext form, multiplied by the winner parameter of the digital component is _ dc _ the _ winner i,1 ]Is shared with the first secret. Computing system MPC 1 can then determine the sum of these products and return the sum to the client device 110 that submitted the digital component request. That is, computing system MPC 1 is able to determine the resulting first secret share [ result ] using the following relation 6 1 ]The sum of (1):
computing system MPC2 can perform a similar calculation to determine a second secret share of results [ result ] using the following relation 7 2 ]：
The computing system MPC 1 will select the result [ ] 1 ]Is sent to the client device 110 (422). Similarly, computing system MPC2 will select the result [ result ] 2 ]To the client device 110 (424). Application 112 may then share [ result ] using the two secrets 1 ]And [ result 2 ]The selection result is reconstructed in the clear, e.g. by determining the sum of the secret sharing if an additive secret sharing algorithm is employed. If the selection result has a value of 0, the MPC cluster 130 does not identify the digital components for distribution to the client devices 110. Otherwise, the selection result has a value equal to the digital component information element dc _ information _ element. The application 112 can parse the digital component information element dc _ information _ element to obtain a selection value and metadata of the digital component. As described above, application 112 can then display the digital components or perform a selection process using the digital components and other digital components received from SSP 170.
In some implementations, the mask is used to transmit the selected digital components to client device 110 to prevent computing system MPC 1 or MPC2 from being able to access the selected digital components in clear text and to reduce the latency of transmitting the digital components to client device 110. In this example, the application 112 can select a random number for each numeric component request and send the random number with the numeric component request. Application 112 can send the random number to one of computing systems MPC 1 or MPC 2. For the purposes of the example, it is assumed that the random number is sent to the computing system MPC 2.
Both the application 112 and the computing system MPC2 are able to independently compute a mask of the same size as the largest digital component created with the same algorithm and the same input. For example, the ith bit of the mask can be represented as a PRF (nonce, i), where the PRF represents a pseudo-random function. Both the application 112 and the computing system MPC2 are able to keep the random number and the mask strictly secret to the computing system MPC 1.
To send the selected digital components to the application 112, the computing system MPC2 can send [ result ] to the application 112 2 ]The bitwise-XOR mask is sent to computing system MPC 1. Computing system MPC 1 will then [ result [ < u > then > 1 ]bitwise-XOR ([ result) 2 ]bitwise-XOR mask) is sent to application 112 as a result of the selection, e.g., as a response to the request for the digit component.
For the second value selection process, the computing systems MPC 1 and MPC2 are capable of calculating a second selection value parameter maybe _ second _ sv for each digital component i Is shared. The second selection value parameter of the digital component i can be a Boolean valueWhich indicates whether the selection value of the numeric component is likely to be the second highest selection value in the candidate numeric component. Only if the digit constituent corresponding to the selection value is actually a candidate digit constituent will the selection value be the second highest selection value in the candidate digit constituent. Thus, the second selection value parameter maybe _ second _ sv of the numeric component i i Indicating whether the numeric component will have the second highest selection value if it is actually a candidate numeric component. Computing systems MPC 1 and MPC2 are capable of performing a secret sharing equality test to determine a second selection value parameter, maybe _ second _ sv i ＝(acc i = 1) secret sharing.
At the end of this equality test, the computing system MPC 1 has the second selection-value parameter maybe _ second _ sv of the digital component i i Is shared with the first secret [ maybe _ second _ sv i,1 ]The computing system MPC2 has the second selection-value parameter maybe _ second _ sv of the digital component i i Second secret share [ maybe _ second _ sv i,2 ]。
Conceptually, computing systems MPC 1 and MPC2 are able to compute the second highest choice value among the candidates using the following relation 8:
in relation 8, the parameter "selectionvalue i "is a selection value (with an arbitrary lift) of the numeral component i, and the parameter" second _ selection _ value "is a candidate numeral componentThe value of the second highest selection value is sorted out. Using the relation, the second selection value is a selection value for a numeric component that is a candidate and has a second selection value parameter with a boolean value of true. The boolean value in this relation can be considered as a value of 1 (true) or 0 (false).
In secret sharing, computing systems MPC 1 and MPC2 compute is _ dc _ a _ candidate i AND maybe_second_sv i The result shared with the secret and denoted as Z 2 Two additions in space share secrets (e.g., add then modulo 2). In addition, the selection value is in plaintext form. Relation 8 is able to perform a bitwise-logical AND operation between each bit in the selection values in the plaintext representation AND the is _ dc _ a _ candidate held by each of the computing systems MPC 1 AND MPC2 i AND maybe_second_sv i The 1-bit secret sharing of the result of (a) instead of multiplication is simplified. In addition, the summation can be replaced with a bitwise-XOR operation.
FIG. 5 is a swim lane diagram of an example process 500 for selecting digital components for distribution to a client device. The operations of the process 500 can be implemented, for example, by the computing systems MPC 1 and MPC2 of the MPC cluster 130. The operations of process 500 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 500. As described above, the process 500 can be used for a selection process that includes a hierarchy.
The computing system MPC 1 sorts the numeric components grouped into ranks by a selection value (514). The selection values can be sorted first by rank priority and then by selection values within the same rank. Similarly, computing system MPC2 orders the numeric components grouped into ranks by selection values (516). For each level, these steps 514 and 516 are similar to steps 410 and 412 of process 400 illustrated in FIG. 4. However, the order includes only the numerical components included in the hierarchy.
In some implementations, depending on the secret sharing algorithm, computing systems MPC 1 and MPC2 are able to independently determine the secret sharing of the accumulated value acc of each digital component without any round-trip computation. For example, for each digital component i, computing system MPC 1 can determine a first share [ acc ] of the accumulated value acc by traversing all digital components in the hierarchy in order from highest to lowest and summing the candidate parameters is _ dc _ a _ candidate of the digital components along the way i,1 ]As described above with reference to table 3. Similarly, for each numerical component i, computing system MPC2 can determine a second share of the accumulated value acc [ acc ac ] by traversing all numerical components in the hierarchy in order from highest to lowest and summing the candidate parameters is _ dc _ a _ candidate of the numerical components along the way i,2 ]。
The computing systems MPC 1 and MPC2 are capable of participating in multiple rounds of computation, e.g., multiple RPCs, as part of a secure MPC process to compute the equality operation acc with secret sharing with respect to each digital component i i =0. The equality operation is used to determine the accumulated value acc of the digital component i i Whether or not to have a value of 0. At the end of this process, the computing system MPC 1 has a result acc for each digital component i in the hierarchy i =0, and the computing system MPC2 has a result acc for each digital component in the hierarchy i =0.
In a second value selection process including a ranking, the selection value of the numeric component is conditioned to provide a second selection value for the selection process only if the numeric component is at the same ranking as the selected numeric component. To determine this second selection value, the computing systems MPC 1 and MPC2 are able to calculate a winning rank parameter maybe _ winning _ tier for each rank t t The winning rank parameter indicates whether the rank t includes a numeric component selected for distribution to the client device 110. Conceptually, computing systems MPC 1 and MPC2 can calculate the winning rank parameter maybe _ winning _ tier for each rank t using the following relationship 9 t ：
In relation 9, the parameter "T" represents all levels having higher priority than the level T. Thus, the winning rank parameter of the rank maybe _ winning _ tier t Indicating whether any higher priority levels include candidate digit components. If not, the rank t is a winning rank if it includes at least one candidate number component.
An equality test between the sum and 0 values can also be calculated using the RPC between the computing systems MPC 1 and MPC 2. Multiple RPCs for various computations may be grouped together to form a smaller number of RPCs to reduce latency and network bandwidth consumption between computing systems MPC 1 and MPC 2.
The computing systems MPC 1 and MPC2 can then be based on the candidate parameter is _ dc _ a _ candidate of a given digital component i Second selection value parameter maybe _ second _ sv of digital component i (which can be calculated as described above with reference to fig. 4), and a winning rank parameter maybe _ winning _ tier comprising the rank t of a given numerical component t Determines whether the second selection value is set by the selection value of the given numerical component. For example, is _ dc _ a _ candidate when a digital component is given i AND maybe_second_sv i AND maybe_winning_tier t With a boolean value true or 1, the second selection value is set by the selection value of the given numerical component.
DSP150 and digital component provider 160 can generally benefit from knowing the highest other selection values of the digital component process so that they can optimize or improve the selection values they provide for the digital components in a similar selection process. For example, a DSP150 whose digital component is selected may benefit from knowing how much higher its selected value is than the second highest value. Similarly, a DSP150 whose digital components are not selected may benefit from knowing how much higher the selection value will need to be in order for the digital components to be selected. When DSP150 and/or digital component provider 160 provide selection values based on this information, DSP150 is more likely to achieve its goals, for example, to avoid wasting due to selection values being too high, or to avoid losing digital component presentation opportunities due to low selection values.
For a DSP150 or digital component provider 160 whose digital component is selected, the highest other selection value is the second highest selection value. For all others, the highest other selection value is the highest selection value. This is the same for both the first value selection process and the second value selection process.
FIG. 6 is a diagram of an example process 600 for determining the highest other selection value for a numeric component in a numeric component selection process. The operations of the process 600 can be implemented, for example, by the computing systems MPC 1 and MPC2 of the MPC cluster 130. The operations of process 600 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 600.
first selection value＝∑(selection_value i x(is_dc_a_candidate i AND maybe_first_sv i ))
the sum can span all of the digital components included in the digital component selection process. Selection value (selection _ value) of each digital component i i ) Can be in the clear. As described above, the computing systems MPC 1 and MPC2 are capable of calculating the candidate parameter is _ dc _ a _ candidate i And a first selection value parameter maybe _ first _ sv i Is shared. The computing system MPC 1 is capable ofStoring a candidate parameter is _ dc _ a _ candidate for each digital component i i Is _ dc _ a _ candidate i,1 ]And a first selection value parameter maybe _ first _ sv i First share of [ maybe _ first _ sv ] i,1 ]. Similarly, the computing system MPC2 can store the candidate parameter is _ dc _ a _ candidate for each digital component i i Second share [ is _ dc _ a _ candidate [ ] i,2 ]And a first selection value parameter maybe _ first _ sv i Second share of [ maybe _ first _ sv i,2 ]。
second selection value＝∑(selection_value i x(is_dc_a_candidate i AND maybe_second_sv i ))
the sum can span all of the digital components included in the digital component selection process. As described above, the computing systems MPC 1 and MPC2 are capable of calculating the candidate parameter is _ dc _ a _ candidate i And a second selection value parameter maybe _ second _ sv i Is shared. The computing system MPC 1 is capable of storing a second selection value parameter maybe _ second _ sv for each digital component i i First share of [ maybe _ second _ sv i,1 ]. Similarly, the computing system MPC2 can store the second selection value parameter maybe _ second _ sv for each digital component i i Second share of [ maybe _ second _ sv i,2 ]。
In the relations 10 and 11, the Boolean value true and false can be considered as 1 and 0, respectively. In secret sharing, computing systems MPC 1 AND MPC2 compute the results of AND operations of relations 10 AND 11 with secret sharing (e.g., using RPCs between the computing systems) AND represent the results as Z 2 Two additive secrets in space are shared (e.g., then add modulo 2). Thus, each computing system is capable of storing a secret share of the first selection value and the second selection value. For example, the computing system MPC 1 can store a first share of a first selected value and a first share of a second selected value. Similarly, computing system MPC2 can store a second share of the first selected value and a second share of the second selected value. The sum of the two shares of the first selected value (e.g., then add modulo 2) is equal to the first selected value, and the sum of the two shares of the second selected value (e.g., then add modulo 2) is equal to the second selected value.
Relations 10 and 11 can be obtained by selecting the value (selection _ value) i ) AND the 1-bit secret sharing of the result of the AND operation between the candidate parameter AND the first selection value parameter (or the second selection value parameter) held by each of the computing systems MPC 1 AND MPC2 is replaced by a bitwise-AND operation for simplification. In addition, the summation of relations 10 and 11 can be replaced with a bitwise-XOR operation.
For each numerical component, the computing systems MPC 1 and MPC2 calculate the highest other selection value (608). The computing systems MPC 1 and MPC2 are able to compute the highest other selected values of the digital components using a two-step process in secret sharing. The computing systems MPC 1 and MPC2 are able to calculate the winner parameter is _ dc _ the _ winner of the digital component i i . The computing systems MPC 1 and MPC2 are able to use the candidate parameter is _ dc _ a _ candidate i And a first selection value parameter maybe _ first _ sv i To calculate the winner parameter is _ dc _ the _ winner i E.g. is _ dc _ the _ winner i ＝is_dc_a_candidate i AND maybe_first_sv i 。
The computing systems MPC 1 and MPC2 can then calculate the Highest Other Selection Value (HOSV) of the digital component i using the following relation 12 i )：。
HOSV i ＝(is_dc_the_weinner i ×second selection value)+((1-is_dc_the_winner i )×first selection value)
Because the winner parameter, the first selection value, and the second selection value are held by the computing systems MPC 1 and MPC2 in a secret sharing, the computing systems MPC 1 and MPC2 cooperatively use the RPC between the two computing systems MPC 1 and MPC2 to determine the highest other selection value MPC 2.
At the end of the process, the computing system MPC 1 stores the first share [ HOSV ] of the highest other selected value of the digital component i i,1 ]And computing system MPC2 stores a second share [ HOSV ] of the highest other selected value of the digital component i i,2 ]。
The recipients of the two secret shares can combine these shares to derive the highest other selection value for the digital component during the digital component selection process. For example, if an additive secret sharing algorithm is used, the receiver can derive the highest other choice value by adding the two shares.
In some implementations, to improve performance, computing systems MPC 1 and MPC2 can asynchronously calculate the highest other selection values after providing the selection results of the digital component selection process to client device 110. This reduces the time delay for transmitting and displaying the digital components. In some implementations, when the load on computing systems MPC 1 and MPC2 is below the baseline load, computing systems MPC 1 and MPC2 are able to calculate the highest other selection value.
For a selection process that includes a lower limit on the selected value, additional steps can be taken to accurately calculate the highest other selected value. The computing systems MPC 1 and MPC2 are capable of calculating the highest other selection values as described with reference to fig. 6. The computing systems MPC 1 and MPC2 can then adjust the highest other selected value to take into account the lower limit, e.g. such that no selected value is smaller than the applicable lower limit.
Let H denote the highest other selection value calculated and F denote the lower limit applicable. The final highest other selected value would be (H > F). Times.H + (1-H > F, which corresponds to F + (H > F). Times.H-F.
To protect user privacy, H is a form of secret sharing. Each computing system MPC 1 and MPC2 respectively holds a secret share [ H ] 1 ]And [ H 2 ]One of them. The computing system MPC 1 is able to compute the first share of the final highest other selected value of the secret shares using the following relation 13:
[HOSV 1 ]＝F+([H 1 ]>F)×([H 1 ]-F)
similarly, computing system MPC2 can compute a second share of the final highest other selected value in the secret shares using the following relation 14:
[HOSV 2 ]＝F+([H 2 ]>F)×([H 2 ]-F)
this process of calculating the highest other selection value for the numerical component process including the lower bound can employ three or more rounds of RPC for comparison testing and one round of multiplication.
When ranking and/or boosting is used in the selection of the number components, the first selection value, e.g., the selection value of the selected number component, may be lower than the highest selection value in the candidate number components. For example, if a candidate number component in the highest priority ranking has a lower selection value than a candidate number component in a lower priority ranking, a candidate number component in a higher priority ranking may be selected despite its lower selection value. Similarly, the digital components may receive an elevation that causes the selection value used in the digital component selection value to be higher than the un-elevated (or lower elevated) digital component, such that the publisher receives less than if the un-elevated digital component were selected. The MPC cluster 130 can determine the difference between these two values so that the publisher can analyze the opportunity cost associated with the ranking and/or promotion.
FIG. 7 is a flow diagram of an example process 700 for determining a difference between a first selection value of a real digital part selection process and a counter-fact digital part selection process. The operations of the process 700 can be implemented, for example, by the computing systems MPC 1 and MPC2 of the MPC cluster 130. The operations of process 700 can also be implemented as instructions stored on one or more computer-readable media, which can be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 700.
For the second value selection process, the clearing value will be based on the second highest selection value following the selection value of the selected digital component. If the grade is used with a second selected value process, the second highest value will be the second highest value in the same grade as the selected numerical component. If no such candidate number component exists in the same rank, the second highest value can be the minimum value of the number component selection process.
The aggregation server can aggregate the differences reported for each publisher and provide data, for example, in the form of an interactive user interface that indicates a level of usage and/or a cost of opportunity for promotion. In some implementations, computing systems MPC 1 or MPC2 may also be capable of providing the selection results to the aggregation server for each real digital component selection process. In this manner, the aggregation server is able to aggregate the opportunity cost for each DSP150 and/or digital component provider 160.
To reduce latency in providing selected digital components of the actual digital component selection process to the client device 110, some or all of steps 704-712 of process 700 can be performed asynchronously, e.g., after providing the selection results to the client device 110.
FIG. 8 is a flow diagram of an example process 800 for determining whether a user is a member of a user group using a Bloom filter sent with secret sharing. The operations of the process 800 can be implemented, for example, by the computing systems MPC 1 and MPC2 of the application 112 and MPC cluster 130 of fig. 1 running on the client device 110. The operations of process 800 can also be implemented as instructions stored on one or more computer-readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of process 800.
Sending data representing the membership of a user group using a Bloom filter can reduce the amount of data sent and protect user privacy because the data identifying the user group of the user is not sent in clear text. To prevent computing systems MPC 1 and MPC2 from being able to access the user's group membership in clear text, application 112 can send a respective share, e.g., a secret share of Bloom filters, to each computing system 112 instead of sending a complete Bloom filter to each computing system MPC 1 and MPC 2. However, this can require sending data equivalent to sending two Bloom filters, one each to computing systems MPC 1 and MPC 2. To prevent this and further reduce the amount of data sent from the client device 110 over the network 105 to the computing systems MPC 1 and MPC2, the application 112 can send a first array generated using the random number and the original Bloom filter created by the application 112 to one of the computing systems, e.g., computing system MPC 1, and simply send the random number to the other computing system MPC 2. In this manner, only one array is sent from the client device 110. Since the random number can be small, e.g., 16 bytes, this greatly reduces the amount of data sent from the client device 110, which reduces bandwidth consumption, latency, and battery consumption of the client device 110.
Although process 800 is described with respect to a Bloom filter representing a user's membership in a user group, a similar process can be used to generate a Bloom filter to represent masked digital components and to query whether the digital components are masked. In this example, the Bloom filter would represent an identifier of the masked numeric component, rather than an identifier of the user group.
The configuration of Bloom filters can be adapted to be transmitted and/or processed by computing systems MPC 1 and MPC 2. The parameters of the Bloom filter include the number of user groups that can be represented by the Bloom filter, the expected false positive rate of the Bloom filter, the number of hash functions used to generate the Bloom filter and test whether an element is included in the Bloom filter, and the size of the Bloom filter.
By reducing the number of hash functions, the computational burden on computing systems MPC 1 and MPC2 is reduced when querying whether a user is a member of a user group. However, this can increase the false alarm rate if the size of the Bloom filter remains the same. If there is a target false positive rate, reducing the hash function may result in a larger Bloom filter size, which can increase the amount of bandwidth consumed. Thus, the parameters of the Bloom filter can be selected using a trade-off between bandwidth/battery consumption and the computational burden on the computing systems MPC 1 and MPC 2.
The application 112 and the computing systems MPC 1 and MPC2 can agree on a pseudo-random function (PRF) in advance. The PRF can take two parameters and generate a PRF number in {0,1} (including the boundary).
The application 112 computes a first array A using the Bloom filter and the random number 1 (806). The application 112 can compute the first array A using the agreed upon PRF 1 . For example, the application 112 can calculate the first array A using the following relation 15 1 ：
A 1 [i]＝A[i]XOR PRF(nonce,i)
In relation 15, the XOR operation is a bitwise-XOR operation.
The computing system MPC2 computes the second array A2 using the random numbers (812). The computing system MPC2 is able to compute the second array A2 using the random numbers and the PRF. For example, computing system MPC2 can compute second array A2 using the following relationship 16:
A 2 [i]＝PRF(nonce,i)
Since neither computing system MPC 1 nor MPC2 has access to the full Bloom filter (instead, each has only the secret sharing of the Bloom filter), the computing systems MPC 1 and MPC2 are able to determine from the subscriber group identifier by using cryptographic protocols whether the user is a member of the subscriber group identifier. Some example encryption protocols that can be used include garbled circuits and the Goldreich-Micali-Wigderson (GMW) protocol.
In either algorithm, the input to the algorithm is (conceptually) a secret sharing of the Bloom filter, i.e. the first array A 1 And a second group A 2 . The output is a secret share of the boolean message set, one for each digital component, i.e. whether the user is a member of the user group associated with the corresponding digital component.
In the GMW protocol, one of the MPC computing systems, e.g., the computing system MPC 1, creates a truth table, one for each possible bit pattern shared by the secrets owned by the computing system MPC 2. The computing system MPC 1, for example, randomly selects its own secret share for the result and based on the secret share of its own result, computes the secret share of each row of the computing system MPC2 and possibly the secret share of the computing system MPC2 corresponding to that row. After the truth table was constructed, computing system MPC2 obtained one and only one row from the table based on its own secret sharing using the forgetting transfer protocol. In this protocol, one computing system transmits one of a plurality of pieces of information to another computing system, but does not know which, if any, of the pieces of information has been transmitted. This forgetting transfer protocol ensures that the process does not reveal any information to any party.
The result of querying the Bloom filter for a given subscriber group identifier is a secret sharing of the subscriber group membership condition parameters of each hash function. Secret sharing of user group membership condition parameters can be used in the digital component selection process to determine whether a digital component corresponding to a user group is a candidate for the digital component selection process. For example, if 10 hash functions are used, computing system MPC 1 will have 10 first secret shares of the user group membership condition parameters for each user group identifier. Similarly, for each user group identifier, computing system MPC2 will share 10 second secrets with the user group membership condition parameters.
If the Bloom filter represents an identifier of a masked numerical component, then computing systems MPC 1 and MPC2 are able to reconstruct the second tuple and query the Bloom filter in a similar manner. The result of querying the Bloom filter for a given numeric component is a masking condition parameter for each hash function. Secret sharing of the masking condition parameters can be used in the digital component selection process to determine whether the digital component is a candidate for the digital component selection process.
FIG. 9 is a block diagram of an example MPC computing system 900. Any of the MPC computing systems described in this document can be implemented using MPC computing system 900. Alternatively, the MPC computing system can be implemented as one or more servers. However, the architecture and configuration of MPC computing system 900 provides a number of performance improvements over the use of a generic server arrangement.
The MPC computing system 900 includes a load balancer 910, a service pool 920 and a log processor pool 940. Computing system 900 also generates, updates, and otherwise maintains logs 930 and snapshots 950.
In some implementations, MPC computing system 900 is deployed in various geographic regions to reduce latency in selecting and providing digital components to client devices 110. For example, an MPC cluster having two or more MPC computing systems 900 can be deployed in each zone of a set of zones. If each MPC cluster includes two MPC computing systems, e.g., MPC 1 and MPC2, each region can include a pair of MPC computing systems 900 operated by different parties. Each MPC 1 instance across all zones is operable by a first party and each MPC2 instance across all zones is operable by a second party different from the first party.
An MPC cluster in an area can perform a digital component selection process for digital component requests generated by client devices 110 in that area. For example, the instructions sent to the digital component slots (e.g., tags) of the client devices 110 in a particular area can include a reference to the network location of the MPC computing system 900 in the particular area. In this manner, application 112 sends digital component requests and notifications to MPC computing system 900 in the appropriate area. In another example, domain Name Service (DNS) or load balancer 910 selects MPC computing system 900 that is closest in physical distance to client device 110.
In some implementations, the log processor pool 940 is enabled only in the appropriate subset of regions for creating and publishing snapshots to the MPC computing system 900 in other regions. For example, in each zone there can be a first MPC computing system MPC 1 operated by a first party. A subset of these first MPC computing systems is able to create snapshots for all of the first MPC computing systems and publish the snapshots to other first MPC computing systems. Similarly, there can be a second MPC computing system MPC2 operated by a second party in each region. A subset of these second MPC computing systems are capable of creating snapshots for all of the second MPC computing systems and publishing the snapshots to other second MPC computing systems. It is important that the first MPC computing system does not share logs or snapshots with the second MPC computing system, and vice versa, to protect user privacy. However, the first computing system and the second computing system do perform the secure MPC process to process the data in the log because at least some of the data is sensitive and/or confidential and should not be accessed in clear text by either computing system. To do so efficiently and without increasing latency or bandwidth consumption, the subset of the first MPC computing system and the subset of the second MPC computing system can be in the same region.
The load balancer 910 receives requests from applications 112 running on the client device 110. These requests, which can be in the form of HTTP requests in some examples, can include numeric component requests and notifications. The notification can include a presentation notification that notifies MPC computing system 900 to show the digital component at client device 110 and optionally whether the user interacted with the digital component. The presentation notification can also include additional information, such as a selection process identifier that identifies the digital component selection process in which the displayed digital component is displayed. For k-anonymous conditions, the presentation notice can also include data identifying the winner of the actual digital part process and the winner of the counterfactual selection process, so that the MPC computing system 900 can update the presentation count for each digital part.
The load balancer 910 can assign requests to processors of the service pool 920 in a manner that balances the load among the processors in the service pool 920. For example, the load balancer 910 can alternate between processors to or monitor the load of each processor and assign requests according to the current load.
Service pool 920 includes multiple processors, each of which can be implemented as, for example, one or more microprocessors, one or more server-class computers, and/or one or more application-specific integrated circuits (ASICs). The processors of the service pool process incoming requests, which are typically latency sensitive. For example, the processor of the service pool 920 can cooperate with a processor of another MPC computing system 900 to perform a digital component selection process. The processors of the service pool 920 can also update the log 930 and/or the received notifications based on the completed numerical component processes.
The processor of the service pool 920 is able to maintain a current database of digital components for storage. The database can include current values of parameters and/or conditions of the numerical components. For example, for each stored digital component, the database can include selection value(s) or vector(s), secret sharing of parameters of at least some conditions, e.g., for conditions that can be computed offline, e.g., k-anonymity and regulation, residual budget, number of impressions (e.g., for k-anonymity conditions), and/or other data for the digital component in the digital component selection process described in this document.
In some implementations, the database of the service pool is a snapshot. For example, each snapshot can have a version identifier that identifies the snapshot version. Both MPC systems should operate using the same version of the snapshot.
The logs 930 can include multiple types of logs that store various information related to the digital components stored by the MPC cluster. For example, log 930 can include a log for storing numeric components and their corresponding data, e.g., selection values, vectors of selection values, lookup keys, corresponding user group identifier(s), conditions, and/or other suitable information.
Log 930 can include a log of completed digital component requests for information. Such a log can include a selection process identifier for each numeric component selection process, a clearance value for the numeric component selection process, and parameters for each numeric component included in the numeric component selection process. These parameters can include, for example, secret sharing of candidate parameters of the numeric component, winning parameters, selection values, and/or cumulative values.
The log 930 can include a log of parameters for determining whether the condition of the digital component is satisfied. For example, for each digital component, such a log can include the number of impressions, the number of selections, the number of conversions, the total budget, the remaining budget, and/or the number of times the digital component may have been presented (e.g., the number of times it was selected during the counterfactual selection of k-anonymity). To protect user privacy and confidentiality of sensitive user data, in some implementations, log 930 contains a secret share of the above information.
Log processor pool 940 can include a processor (e.g., a microprocessor, server, or ASIC) that processes log 930 and generates snapshot 950 based on the log. Each snapshot includes updates to a database maintained by a processor of the service pool 920. For example, if a digital component is selected and shown at the client device 110, the snapshot can include an updated residual budget for the digital component and an exposed number of the updated digital component. The log processor pool 940 can generate a snapshot based on the update data in the log 930 and publish the snapshot to the processors of the service pool 920. The processors of the log processor pool 900 are also able to publish snapshots to other MPC computing systems operated by the same party, for example, if the log processor pool 940 is enabled only at some MPC computing systems 900.
To reduce latency in responding to requests, the processors of service pool 920 are able to process requests immediately after they are received. Time insensitive processes can be handled by the processors of the log processor pool 940. For example, the service pool 920 can perform any processes on the critical path for selecting and providing digital components to the client device 110. The log processor pool 940 can perform any processes that are not on the critical path. However, updating the database should occur quickly to ensure that the numerical components are selected using the most up-to-date information. Thus, the use of different sets of processors provided by the architecture shown in FIG. 9 enables the digital component selection process and updates to the database to be performed very quickly.
FIG. 10 is a block diagram of an example computer system 1000 that can be used to perform the operations described above. The system 1000 includes a processor 1010, a memory 1020, a storage device 1030, and an input/output device 1040. Each of the components 1010, 1020, 1030, and 1040 can be interconnected, for example, using a system bus 1050. Processor 1010 is capable of processing instructions for execution within system 1000. In some implementations, the processor 1010 is a single-threaded processor. In another implementation, the processor 1010 is a multi-threaded processor. The processor 1010 is capable of processing instructions stored in the memory 1020 or on the storage device 1030.
The storage device 1030 is capable of providing mass storage for the system 1000. In some implementations, the storage device 1030 is a computer-readable medium. In various different implementations, the storage 1030 can include, for example, a hard disk device, an optical disk device, a storage device shared by multiple computing devices over a network (e.g., a cloud storage device), or some other mass storage device.
Input/output device 1040 provides input/output operations for system 1000. In some implementations, the input/output devices 1040 can include one or more of a network interface device, such as an ethernet card, a serial communication device, such as a usb (r) and RS-232 port, and/or a wireless interface device, such as a usb (r) and 802.11 card. In another implementation, the input/output devices can include driver devices, such as keyboards, printers, and display devices, that are configured to receive input data and transmit output data to the external devices 1060. However, other implementations can also be used, such as mobile computing devices, mobile communication devices, set-top box television client devices, and so forth.
Although an example processing system has been described in fig. 10, implementations of the subject matter and the functional operations described in this specification can be implemented in other types of digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.
Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on a computer storage medium (or media) for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by the data processing apparatus. The computer storage medium can be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Further, while the computer storage medium is not a propagated signal, the computer storage medium can be a source or destination of computer program instructions encoded in an artificially generated propagated signal. The computer storage media can also be or include one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).
The operations described in this specification can be implemented as operations performed by data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.
The term "data processing apparatus" encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or a combination of multiple or more. The apparatus can comprise special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment are capable of implementing a variety of different computing model infrastructures, such as Web services, distributed computing and grid computing infrastructures.
A computer program (also known as a program, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with the instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such a device. Moreover, the computer can be embedded in another device, e.g., a mobile telephone, a Personal Digital Assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a Universal Serial Bus (USB) flash drive), to name a few. Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and storage devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other types of devices can also be used to provide for interaction with a user; for example, feedback provided to the user can be any form of sensory feedback, such as visual feedback, auditory feedback, or tactile feedback; input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, computers can interact with users by sending and receiving documents to and from devices used by the users; for example, by sending a Web page to a Web browser on the user's client device in response to a request received from the Web browser.
Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described is this specification, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network ("LAN") and a wide area network ("WAN"), an internetwork (e.g., the internet), and a peer-to-peer network (e.g., an ad hoc peer-to-peer network).
The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, the server transmits data (e.g., HTML pages) to the client device (e.g., for displaying data to and receiving user input from a user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) can be received at the server from the client device.
While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any invention or of what may be claimed, but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination of a subcombination or variation.
Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In some cases, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated in one software product or packaged into multiple software products.
Thus, particular embodiments of the present subject matter have been described. Other embodiments are within the scope of the following claims. In some cases the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In some implementations, multitasking and parallel processing may be advantageous.
Claims (10)
1. A computer-implemented method, comprising:
performing, by a first server of a secure multi-party computing MPC system in cooperation with one or more second servers of the secure MPC system, a selection process to select a digital component based in part on a selection value of each digital component in the selection process, the performing comprising determining a first secret share of a winner parameter for each digital component in the selection process;
determining, for each given numerical component in the selection process and in cooperation with the one or more second servers, a highest other selection value corresponding to a different numerical component different from the given numerical component, the determining for each given numerical component comprising:
determining a first secret share of a highest selection value of the selection values of the digital components in the selection process;
determining a first secret share of a second highest selection value of the selection values of the digital components in the selection process;
for each given digital component in the selection process, determining a first secret share of the highest other selection value based at least in part on the first secret share of the highest selection value, the first secret share of the second highest selection value, and the first secret share of the winner parameter of the given digital component; and
providing the highest selection value for each given numerical component to an owner of the given numerical component.
2. The computer-implemented method of claim 1, wherein determining the first secret share of the highest other selection value of a particular digital component comprises determining, in cooperation with the one or more second servers, a first secret share of a sum of a first product and a second product, wherein the first product is a product of the winner parameter of the particular digital component and a second highest selection value of the selection values in the selection process, and the second product is a difference between a product of (i) a value of the winner parameter of the particular digital component and (ii) the highest selection value of the selection values of the digital components in the selection process.
3. The computer-implemented method of any of the preceding claims, wherein the selection process comprises at least one of a plurality of priority levels of the digital components in the selection process, or one or more boosted digital components having boosted selection values.
4. The computer-implemented method of claim 3, further comprising:
performing, by the first server in cooperation with the one or more second servers, a counterfactual selection process to select a second numeric component based in part on the selection value of each numeric component in the selection process, wherein the counterfactual selection process uses an un-promoted selection value and selects the second numeric component independently of the priority level;
determining a first purge value for the selection process;
determining a second clear value for the counterfactual selection process; and
determining a difference between the first clearance value and the second clearance value.
5. The computer-implemented method of any of the preceding claims, further comprising filtering one or more numerical components from the selection process based on a selection value lower bound.
6. The computer-implemented method of claim 5, wherein the selection value lower bound represents a minimum selection value that qualifies a numerical component for selection.
7. The computer-implemented method of claim 5, wherein determining the first secret share of the highest other selected value of a particular digital component comprises determining the first secret share of the highest other selected value of the particular digital component based on the selected value lower bound.
8. A system, comprising:
one or more processors; and
one or more storage devices storing instructions that, when executed by the one or more processors, cause the one or more processors to perform the method of any of the preceding claims.
9. A computer-readable storage medium carrying instructions that, when executed by one or more processors, cause the one or more processors to perform the method of any one of claims 1-7.
10. A computer program product comprising instructions which, when executed by a computer, cause the computer to perform the steps of the method according to any one of claims 1 to 7.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
IL281329A IL281329A (en) | 2021-03-08 | 2021-03-08 | Privacy preserving measurements using secure multi-party computation |
IL281329 | 2021-03-08 | ||
PCT/US2022/019169 WO2022192146A1 (en) | 2021-03-08 | 2022-03-07 | Privacy preserving measurements using secure multi-party computation |
Publications (1)
Publication Number | Publication Date |
---|---|
CN115315919A true CN115315919A (en) | 2022-11-08 |
Family
ID=80937046
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
CN202280003163.8A Pending CN115315919A (en) | 2021-03-08 | 2022-03-07 | Privacy preserving measures using secure multi-party computing |
Country Status (7)
Country | Link |
---|---|
US (1) | US20240022392A1 (en) |
EP (1) | EP4101121A1 (en) |
JP (1) | JP7425222B2 (en) |
KR (1) | KR20220144388A (en) |
CN (1) | CN115315919A (en) |
IL (1) | IL281329A (en) |
WO (1) | WO2022192146A1 (en) |
Family Cites Families (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8793256B2 (en) | 2008-03-26 | 2014-07-29 | Tout Industries, Inc. | Method and apparatus for selecting related content for display in conjunction with a media |
US10540158B2 (en) | 2016-07-18 | 2020-01-21 | Google Llc | Post-install application interaction |
US10289748B2 (en) | 2016-10-14 | 2019-05-14 | Google Llc | Optimizing transmission of digital components |
-
2021
- 2021-03-08 IL IL281329A patent/IL281329A/en unknown
-
2022
- 2022-03-07 CN CN202280003163.8A patent/CN115315919A/en active Pending
- 2022-03-07 KR KR1020227032467A patent/KR20220144388A/en unknown
- 2022-03-07 JP JP2022556203A patent/JP7425222B2/en active Active
- 2022-03-07 US US17/801,326 patent/US20240022392A1/en active Pending
- 2022-03-07 WO PCT/US2022/019169 patent/WO2022192146A1/en active Application Filing
- 2022-03-07 EP EP22712717.2A patent/EP4101121A1/en active Pending
Also Published As
Publication number | Publication date |
---|---|
US20240022392A1 (en) | 2024-01-18 |
IL281329A (en) | 2022-10-01 |
JP7425222B2 (en) | 2024-01-30 |
KR20220144388A (en) | 2022-10-26 |
EP4101121A1 (en) | 2022-12-14 |
WO2022192146A1 (en) | 2022-09-15 |
JP2023524366A (en) | 2023-06-12 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
JP2023067928A (en) | Using secure multi-party computation to improve content selection process integrity | |
JP7471425B2 (en) | Feedback Controller Using Secret Sharing | |
JP2023532834A (en) | Using secure multi-party computation and probabilistic data structures to protect access to information | |
KR20230048126A (en) | Cryptographic Security Control Using Secure Multiparty Operations | |
EP4081971B1 (en) | Using secure mpc and vector computations to protect access to information in content distribution | |
JP7471450B2 (en) | Improving the performance of secure multiparty computation | |
CN115315919A (en) | Privacy preserving measures using secure multi-party computing | |
JP7440667B2 (en) | Flexible content selection process using secure multiparty calculations | |
JP7457813B2 (en) | Privacy-preserving techniques for content selection and delivery | |
WO2024030200A1 (en) | Single request architecture for increasing efficiency of secure multi-party computations |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
SE01 | Entry into force of request for substantive examination |