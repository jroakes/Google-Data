US6917934B2 - Search engine for large database search using hash pointers - Google Patents
Search engine for large database search using hash pointers Download PDFInfo
- Publication number
- US6917934B2 US6917934B2 US10/065,261 US6526102A US6917934B2 US 6917934 B2 US6917934 B2 US 6917934B2 US 6526102 A US6526102 A US 6526102A US 6917934 B2 US6917934 B2 US 6917934B2
- Authority
- US
- United States
- Prior art keywords
- hash
- search
- value
- memory
- cam
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/90—Details of database functions independent of the retrieved data types
- G06F16/903—Querying
- G06F16/90335—Query processing
- G06F16/90339—Query processing by using parallel associative memories or content-addressable memories
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99932—Access augmentation or optimizing
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99933—Query processing, i.e. searching
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99933—Query processing, i.e. searching
- Y10S707/99934—Query formulation, input preparation, or translation
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99933—Query processing, i.e. searching
- Y10S707/99935—Query augmenting and refining, e.g. inexact access
Definitions
- the present invention relates generally to static information storage and retrieval systems, and more particularly to architectures for searching large databases of stored data using hash algorithms.
- FIG. 1 is a block diagram depicting a search engine 10 using conventional hash-based database searching.
- a controller 12 includes a hash function 14 which can receive 128-bit input search values and generate 20-bit hash value which is used as an index to address a memory 16 .
- the memory 16 needs to be able to store a database having two million entries. This is depicted here as a base region 16 a and a conflicts region 16 b in the memory 16 , a total of two regions for a 2-way-set-associative hash.
- a 21-bit wide address bus 18 is therefore needed to communicate between the controller 12 and the memory 16 (20-bits to address the first one million entries in the base region 16 a, and one additional bit to address the second million entries, in the conflicts region 16 b used to support the one set of potential collision cases).
- the entries in the memory 16 each require 160 bits, 32 bits for an associate value which is the desired result of the search and 128 bits for the input search value which is intended to produce that particular result.
- the above illustrates a key point in hash-based database searching—both the associate content value and a stored instance of the search value which produces it must be stored in the memory 16 and returned to the controller 12 , here via a 160-bit result bus 20 , for the controller 12 to perform a comparison to determine if a hash collision has occurred.
- the controller 12 can only do this if it has both the input and stored search values. If these are the same in a search result obtained from the base region 16 a, the associate value in the search result is valid and the controller 12 can carry on with using it. If these values are different, however, a hash collision has occurred. Then the controller 12 accesses the memory 16 a second time, using the 21 st bit to address an entry stored in the conflicts region 16 b.
- the controller 12 can again carry on. If these are still different, however, another hash collision has occurred and using only a 2-way-set-associative hash and a two million entry database is not adequate for the task at hand.
- a good hash algorithm is one that produces very few collisions. However, it usually cannot be known how many collisions will actually occur, because the pattern of the input search data is typically not known in advance. If there is more than one collision for a given number, a 2-way-set-associative hash will not be able to handle it. In order to support the database with more confidence, 4-way or more set-associative approach should then be used. When such is used, more memory must be provided.
- the size of the memory depends on two things: the number of entries being supported and the number of ways of set-associativity employed. For example, to support n entries using 4-way-set-associativity, the memory size has to have 4n entries. For one million entries this means that the memory must be four million entries “deep,” even though only one million of entries will ever potentially be used, i.e., less than 25% of the memory is utilized.
- the number of ways of set-associativity also dictates that more clock cycles will potentially be needed for a search.
- it will take a maximum of two memory read operations (instead of one) to perform a database search, since one collision may happen during the search.
- it may take up to m memory read operations to perform a database search.
- hash-based database searching has substantial disadvantages when one considers the large amount of memory needed and the limited speed of searching possible. For discussion, these can be termed the memory size issue and the search speed issue, and both increase linearly when hash-based searching is used.
- the memory size issue is largely a matter of cost, and thus may be easily solved if cost is not a serious problem.
- the search speed issue is more difficult, however, and it may make hash-based searching impractical in many applications.
- FIG. 2 is a basic block diagram depicting a search engine 50 using conventional CAM-based database searching.
- a controller 52 provides a 128-bit input search value to a CAM 54 that will search its own database (of one million entries) and provide a 20-bit index value to a memory 56 , where up to one million 32-bit associate content values may be stored.
- CAM 54 Although other types of memory can theoretically be used in place of the CAM 54 , content addressable memory, or associative memory as it is also widely known, is particularly useful. When provided an input search value, a content addressable memory will very rapidly provide as its output the address within it of any match (multiple matches should not occur here unless the CAM 54 is improperly programmed). This index, perhaps with appropriate translation by a suitable logic circuit, can then be used as an address into the memory 56 .
- the controller 52 here provides the input search value to the CAM 54 via a 128-bit wide search data bus 58 ; the CAM 54 provides the address index value to the memory 56 via a 20-bit wide address bus 60 , and the memory 56 provides the search result to the controller 52 via a 32-bit wide result bus 62 . Since the CAM 54 always provides, if anything, a unique address in the memory 56 , only one read operation is required.
- Yet another object of the invention is to provide database search engines which employ hash-based techniques yet are less restricted by hash collisions.
- one preferred embodiment of the present invention is a database search engine including a controller having a hash function able to receive an input search value and create hash addresses which are smaller than the input search value.
- a hash pointer unit stores pointer values, which are addressed based on the hash addresses.
- a memory stores a database of search results, wherein the respective search results are addressed based on said pointer values.
- An address bus connects the controller to the hash pointer unit and communicates the hash addresses from the controller to the hash pointer unit.
- a pointer bus connects the hash pointer unit to the memory and communicates the pointer value from the hash pointer unit to the memory.
- a result bus connects the memory to the controller and communicates the search results from the memory to the controller.
- An advantage of the present invention is that it provides a direct and very substantial cost savings over hash-based prior art approaches due to improved memory utilization.
- TABLE 1 summarizes differences between the prior art hash-based and CAM-based approaches and a variation of the embodiment of the present invention depicted in FIG. 8 ;
- TABLE 2 summarizes inputs and stored values in an example described for the embodiment of the present invention depicted in FIG. 6 and the process for that embodiment depicted in FIG. 7 ;
- TABLE 3 provides a comparison of two different implementations of a one million entry 8-way-set-assoicative hash-based system, wherein one uses a typical prior art hash-based approach and the other uses the H-CAM with the indirect hash pointer and a cascading mechanism of the present invention.
- FIG. 1 (background art) is a block diagram depicting a simple hash-based database searching example
- FIG. 2 (background art) is a block diagram depicting a simple CAM-based database searching example
- FIG. 3 is a block diagram depicting a search engine according to a hash pointer based embodiment of the present invention
- FIG. 4 is a block diagram depicting a search engine according to a single-level hash-CAM based embodiment according to the invention
- FIG. 5 is a block diagram depicting a search engine according to a quad-level hash-CAM based embodiment of the invention
- FIG. 6 is a block diagram depicting a search engine used in an example of a multi-leveled architecture embodiment of the invention, simplified for use in a detailed example;
- FIG. 7 is a flow chart depicting a process suitable for use with the H-CAM element of the embodiment of the invention shown in FIG. 6. ;
- FIG. 8 is a block diagram depicting a search engine according to an alternate embodiment of the invention, including a H-CAM element having a comparison section;
- FIGS. 9 a-b show possible sub-architectures for parts of the H-CAM element of the embodiment shown in FIG. 8 , wherein FIG. 9 a is a block diagram depicting an architecture for first a logic unit and FIG. 9 b is a block diagram depicting an architecture for a search data storage;
- FIG. 10 is a block diagram depicting a search engine according to an alternate embodiment of the invention, including a H-RAM element;
- FIGS. 11 a-b show possible sub-architectures for parts of the H-RAM element of the embodiment shown in FIG. 10 , wherein FIG. 11 a is a block diagram depicting an architecture for a first logic unit and FIG. 11 b is a block diagram depicting an architecture for a search data storage;
- FIG. 12 is a block diagram depicting a search engine incorporating many of the principals discussed for other embodiments.
- FIG. 13 is a block diagram depicting a search engine having the ability to scale for use in large systems by cascading multiple H-CAM elements;.
- FIG. 14 is a block diagram depicting a search engine having the ability to scale for use in large systems by cascading multiple H-RAM elements.
- FIG. 15 is a block diagram depicting a search engine having the ability to scale for use in large systems by cascading multiple CAM, H-CAM and H-RAM elements.
- a preferred embodiment of the present invention is a system for large database searches which marries both hash-based and CAM-based advantages without the respective disadvantages.
- preferred embodiments of the invention are depicted by the general reference characters 100 , 200 , 300 , 400 , 500 , 600 , 700 , 800 , 900 , 1000 , and 1100 .
- FIG. 3 is a block diagram depicting a search engine 100 according to one preferred embodiment of the present invention.
- the particularly novel aspect in this embodiment is the use of a hash pointer unit 110 , which is interposed between a controller 112 and a memory 114 .
- the controller 112 uses 128-bit wide input search values to search a database of up to one million entries of 32-bit associate content value stored in the memory 114 .
- the controller 112 includes a hash function 116 that generates hash addresses (which potentially may be hash collisions).
- the controller 112 may be substantially the same as the conventional controller 12 discussed with FIG. 1 (background art).
- FIG. 1 background art
- FIG. 1 sees the scheme used in FIG. 1 , however, lets use 4-way set-associativity here. Accordingly, using four way access to up to one million addresses, a 22-bit address bus 118 is needed to connect the controller 112 to the hash pointer unit 110 .
- the hash pointer unit 110 includes a 4M ⁇ 20 memory which may contain programmable unique “pointers” to the one million potential entries in the memory 114 .
- the hash pointer unit 110 is 4M deep to handle 4-way associativity to one million potential entries, but it need be only 20-bits wide to provide pointers able to access the actual one million potential entries in the memory 114 .
- a 20-bit wide pointer bus 120 can therefore be used to connect the hash pointer unit 110 to the memory 114 .
- the memory 114 accordingly needs to include entries 160-bits wide (128+32). Individual such entries, or search results are then provided to the controller 112 via a 160-bit wide result bus 122 .
- the operation here is similar to that of the prior art search engine 10 in FIG. 1 , except that the stored search values and associate content values are accessed “indirectly” through the pointer values stored in the hash pointer unit 110 .
- a 128-bit input search value is used by the hash function 116 to generate a 20-bit hash output, which the controller 112 combines with an offset value to create a 22-bit hash address.
- the controller 112 may do this by prefixing a 2-bit offset value to the hash value.
- a “00” prefix can represent that the hash output maps to the first “way” in the 4-way set-association used here, a “01” can represent the second way, and so fourth.
- “00” may be prefixed to the hash value. If the search result this produces has a stored search value that matches the original input search value, there has been no hash collision. In contrast, if these values do not match, a hash collision has occurred.
- “01” may be prefixed to the (same) hash value, creating a new hash address, and the hash pointer produced by the hash pointer unit 110 in response to this may similarly be used to retrieve a different search result. This can continue, handling up to four 128-bit input search values that the hash function maps to the same hash value in this embodiment.
- the search speed issue (as termed in the Background Art section) is not changed.
- the memory size issue is greatly changed.
- a 4M ⁇ 160 memory would be required using a prior art 4-way set-associative hash-based approach
- the inventive search engine 100 here requires only a 1M ⁇ 160 memory and a 4M ⁇ 20 memory—a substantial overall savings.
- FIG. 4 is a block diagram depicting a search engine 200 according to another preferred embodiment of the present invention.
- the particularly novel aspect of this embodiment is a single level H-CAM 210 .
- the single level nature of the H-CAM 210 should not be confused with the set-associative nature of a hash approach. That is, the “level” and “way” are different concepts.
- the H-CAM 210 in the example here is 1-way-set-associative, but that is coincidental with the use here of only a single level.
- the search engine 200 further includes a controller 212 and a memory 214 , which both may be substantially conventional.
- the controller 212 may be an application specific integrated circuit (ASIC) and the memory 214 may be an external random access memory (RAM).
- ASIC application specific integrated circuit
- RAM external random access memory
- the controller 212 communicates an input search value to the H-CAM 210 , via a search data bus 216 , and the H-CAM 210 then communicates an address value to the memory 214 , via an address bus 218 . Responsive to the address value, a result value is communicated back from the memory 214 to the controller 212 , via a result bus 220 .
- the architecture of the H-CAM 210 includes a hash unit 222 , a CAM unit 224 , and a logic unit 226 .
- the input search value is provided, via a first path 228 a, to both the hash unit 222 and the CAM unit 224 .
- the hash unit 222 then provides a hash output on a second path 228 b, and the CAM unit 224 may (if it finds a match) provide a CAM output on a third path 228 c (the address within it of such a match).
- the logic unit 226 receives the CAM and hash outputs, via the paths 228 b-c, and selects one for use as the address value, which it then provides to the memory 214 via the address bus 218 (effectively a last path 228 d ).
- the search engine 200 will also use 128-bit wide input search values, to search a database of up to one million entries of 32-bit associate values.
- the search data bus 216 is 128 bits wide
- the address bus 218 is 21 bits wide
- the result bus 220 is 160 bits wide.
- the hash unit 222 employs a hash algorithm to map each 128-bit wide input search value to a “narrow” 20-bit wide hash output value. Each input search value received by the hash unit 222 causes it to provide a respective hash output to the logic unit 226 .
- the hash output will depend on the hash algorithm actually used.
- the CAM unit 224 in this example is a 100K ⁇ 128 content addressable memory. If an input search value is received in the CAM unit 224 that matches a stored comparison value (a 128-bit wide copy of a previous search value that caused a hash collision), the address of that match is provided by the CAM unit 224 , as a CAM output, to the logic unit 226 . In contrast, however, if an input search value is received which does not match any comparison value, no CAM output is provided.
- a stored comparison value a 128-bit wide copy of a previous search value that caused a hash collision
- the logic unit 226 here operates in a straight forward manner.
- a CAM output has higher priority than a hash output. If the logic unit 226 receives only a hash output, that becomes the basis of the address value. If it receives both a hash output and a CAM output, the CAM output becomes the basis of the address value. This is so because the presence of a CAM output indicates that there is an already known and cataloged hash collision case. Using the hash output for the address value here would cause that collision to occur. Alternately, using the CAM output for the address value instead will avoid that collision. If the logic unit 226 receives only a CAM output it can go ahead and use that as the basis for the address value. However, it may be desirable to treat this as an error condition in many embodiments, since a proper hash algorithm should always produce a hash output.
- the logic unit 226 also translates the hash or CAM output into an address value that appropriately maps to the memory 214 .
- the hash output may (naturally or by translation) map to the low-order one million addresses in the memory 214 . If the CAM output also maps to the low-order one-hundred thousand addresses in the memory, it needs to be translated to instead map to high-order addresses in the memory 214 .
- the memory 214 here includes a base region 214 a for storing search results that are accessed based on the hash outputs, and a conflicts region 214 b for storing search results that are accessed based on the CAM outputs.
- the search results in the base region 214 a need to include a 128-bit wide stored search value and a 32-bit associate value, for reasons discussed presently. It then follows, because every possible hash output (defined by a 20-bit index value) must map to a search result, that the base region 214 a in the example here needs to have a size of at least 1M ⁇ 160.
- the search results stored in the conflicts region 214 b of the memory 214 do not have to include any stored search values.
- the CAM unit 224 already includes full 128-bit wide copies of these same search values it uses to index into the conflicts region 214 b, and storing any stored search values in the conflicts region 214 b is unnecessary and wasteful.
- the conflicts region 214 b here can therefore simply contain the 32-bit associate values, and thus need only be 100K ⁇ 32 in size.
- the address bus 218 , memory 214 , and result bus 220 are stylistically shown in FIG. 4 in a manner to emphasize that the base region 214 a and the conflicts region 214 b may be different in size, and that they may even be distinct physical devices.
- the result bus 220 needs to be 160 bits wide to carry either size of result value, but a 128-bit field can be empty whenever a result value is taken from the conflicts region 214 b.
- the controller 212 receives a result value from the memory 214 , and it may check for a new hash collision.
- the controller 212 can easily determine if the result value includes a stored search value. If not, the result value will have come from the conflicts region 214 b and the 32-bit associate value in the present result value can be used with confidence that it is uniquely associated with the original input search value. In contrast, for a non-empty stored search value, the result value will have come from the base region 214 a in the memory 214 and a hash collision is still a possibility that needs to be dealt with. The controller 212 can then compare the non-empty stored search value with the original input search value.
- the search engine 200 can simply carry on and use the 32-bit associate value in the present result value with confidence. However, if these values differ, a new hash collision has occurred and the associate value received as part of the result value should not be used.
- the search engine 200 specifically the CAM unit 224 and the conflicts region 214 b of the memory 214 , may be programmed to avoid it in the future. Theoretically, the search engine 200 here can handle hash collisions up to 100,001 deep in a worst case situation, since the conflicts region 214 b has 100K locations to map collisions to after a first entry in the base region 214 a has been used.
- FIG. 5 is a block diagram depicting a search engine 300 according to another preferred embodiment of the present invention.
- the particularly novel aspect in this embodiment is a quad-level H-CAM 310 .
- a controller 312 and a memory 314 are also provided.
- the controller 312 here communicates an input search value to the H-CAM 310 , via a search data bus 316 , and the H-CAM 310 then communicates an address value to the memory 314 , via an address bus 318 . Responsive to the address value, a search result is then communicated back from the memory 314 to the controller 312 via a result bus 320 .
- the architecture of the H-CAM 310 includes a number of paired hash units (hash units 322 a-d ) and CAM units (CAM units 324 a-d ), and a single logic unit 326 .
- the input search value is provided to the hash unit 322 a and its paired CAM unit 324 a, via a path 328 a.
- the hash unit 322 a then provides a first hash output on a path 328 b, which conveys it to the next hash unit 322 a where a second hash output is provided on a path 328 c, and so forth until a last, fourth hash output is provided on a path 328 e.
- the CAM unit 324 a provides a first CAM output on a path 328 i, a second CAM output is provided on a path 328 h, and so forth until a last, fourth CAM output is provided on a path 328 f.
- a single final hash output on a path 328 e and multiple CAM outputs on paths 328 f-i, and all of these paths 328 e-i lead to the logic unit 326 .
- the logic unit 326 selects a value from those it receives to use as the address value, and provides it to the memory 314 via the address bus 318 .
- the path 328 a is 128 bits wide, as it is essentially the same as the search data bus 316 ; the path 328 b is desirably smaller, say, 64 bits wide; the path 328 c is desirably still smaller, say, 48 bits wide; the path 328 d is desirably yet smaller, say, 32 bits wide; and the paths 328 e-i are all smaller, specifically all 20 bits wide, as one of their contents is ultimately sent via the 21-bit wide address bus 318 (effectively a last path 328 j ).
- the purpose of the multiple hash units 322 a-d here is to reduce the input data space, hence the hash outputs should each desirably be smaller than the prior input.
- the multiple CAM units 324 a-d store entries known to cause hash collisions at the respectively paired hash units 322 a-d.
- the underlying rationale of this multi-level architecture is that when a given number of hash collisions are expected a corresponding number of CAM entries will be needed. So, based on probability and knowing that the width of the CAMs shrink at successive levels, using multiple levels of CAM in this manner should reduce the total amount of CAM require to provide for the expected number of hash collisions. Nevertheless, the actual number of hash collisions still depends on the particular pattern of input data encountered.
- the logic unit 326 outputs an address value based on a highest priority scheme.
- the earlier CAM stages have higher priority over later stages, and ultimately over the hash output.
- the CAM output of the first CAM unit 324 a has higher priority than the CAM output of the second CAM unit 324 b, and so forth, ending here with the CAM output of the fourth CAM unit 324 d having priority over the hash output of the fourth hash unit 322 d.
- the logic unit 326 may also, if necessary, translate the outputs to an address value that appropriately maps to the memory 314 .
- the memory 314 has a base region 314 a, a first conflicts region 314 b, a second conflicts region 314 c, a third conflicts region 314 d, and a fourth conflicts region 314 e.
- the fourth conflicts region 314 e does not need to include room for stored search values, since the first CAM unit 324 a contains a copy of the search value and will always match uniquely.
- the hash output of the fourth hash unit 322 d becomes the basis for address values that map to the base region 314 a; the CAM output of the fourth CAM unit 324 d becomes the basis for address index values that map to the first conflicts region 314 b; the CAM output of the third CAM unit 324 c becomes the basis for address index values that map to the second conflicts region 314 c; and so forth.
- the conflicts regions 314 b-e thus each store data to handle correspondingly higher level collision cases.
- FIG. 6 is a block diagram depicting a search engine 400 according to the present invention, now used in detailed example.
- a two-level H-CAM 410 is provided, along with a controller 412 , memory 414 , search data bus 416 , address bus 418 , and result bus 420 .
- a programming unit 430 is also shown here (and many embodiments of the invention will include programming capability, but is not described in particular detail since its task can be performed in various ways and using various architectures that are all substantially conventional or which should be readily apparent to those skilled in the art in view of the following discussion.
- the result bus 420 also differs from the result bus 220 ( FIG. 4 ) in that it is bi-directional, and the memory 414 here accordingly accommodates that.
- Some variations of the programming unit 430 may employ these when programming the memory 414 .
- the architecture of the H-CAM 410 here includes a two hash units (hash units 422 a-b ) and two CAM units (CAM units 424 a-b ), and a logic unit 426 .
- a path 428 a connects the search data bus 416 to the first hash unit 422 a and the first CAM unit 424 a;
- a path 428 b connects the first hash unit 422 a to the second hash unit 422 b and the second CAM unit 424 b;
- a path 428 c connects the second hash unit 422 b to the logic unit 426 ;
- a path 428 d connects the second CAM unit 424 b to the logic unit 426 ;
- a path 428 e connects the first CAM unit 424 a to the logic unit 426 .
- the memory 414 includes a base region 414 a, a first conflicts region 414 b, and a second conflicts region 414 c. These might, for instance, respectively be 1M ⁇ 160, 200K ⁇ 160, and 100K ⁇ 32 in size.
- FIG. 7 is a flow chart depicting a process 500 suitable for use with the H-CAM 410 of FIG. 6 .
- the process 500 starts with a step 510 , where the two CAM units 424 a-b and the memory 414 are empty.
- a step 512 an input search value is provided by the controller 412 to the H-CAM 410 .
- the input search value is received by and processed by the first hash unit 422 a to generate a first hash output.
- the input search value is also received by and processed by the first CAM unit 424 a to create a first CAM output (but only if there is a match).
- the first hash output is received by and processed by the second hash unit 422 b to generate a second hash output.
- the first hash output is also received by and processed by the second CAM unit 424 b to create a second CAM output (but, again, only if there is a match).
- the H-CAM 410 has internally produced a final (second) hash output, and possibly also either or both of first and second CAM outputs.
- these outputs are received by and prioritized by the logic unit 426 .
- the first CAM output receives the highest priority; if it is present it is used for the address value.
- the second CAM output receives the next priority; if it is present and the first CAM output is not, the second CAM output is used for the address value.
- the (final) second hash output receives the lowest priority; if it is present and the neither of the CAM outputs is, the second hash output is used for the address value.
- the logic unit 426 also translates the respective output used so that the address value maps to a corresponding area in the memory 414 .
- a hit was detected in the first CAM unit 424 a. If so, in a step 526 the first CAM output is used to access the memory 414 and the controller 412 will receive a search result (typically only an associate value) stored in the second conflicts region 414 c. Since the contents of the second conflicts region 414 c are always uniquely associated with possible input search values, the process 500 is essentially finished for the present input search value, and the search engine 400 can carry on with whatever further operations on the search result are desired.
- a search result typically only an associate value
- a hit was not detected in the first CAM unit 424 a, in a step 528 it is determined whether a hit was detected in the second CAM unit 424 b. If so, in a step 530 the first CAM output is used to access the memory 414 and the controller 412 receives a search result stored in the first conflicts region 414 b.
- a step 532 it is determined whether the stored search value in the returned search result is the same as the original input search value. If so, in a step 534 the process 500 is essentially finished for the present input search value, and the search engine 400 can carry on with whatever further operations on the search result are desired.
- the first CAM unit 424 a can be programmed with the input search value and the second conflicts region 414 c can be programmed with an associate value for this (all under direction of the programming unit 430 ).
- the process 500 is essentially finished for the present input search value.
- step 538 the second hash output is used to access the memory 414 and the controller 412 will receive a search result stored in the base region 414 a.
- a step 540 the search result is examined to see if it contains any value. If so, there again still remains a possibility that the second hash output is a new hash collision, and in a step 542 the returned search result is compared with the original input search value.
- a step 544 it is determined whether these values are the same. If this is also so, in a step 546 the process 500 is essentially finished for the present input search value, and the search engine 400 can carry on with whatever further operations on the search result are desired.
- the second CAM unit 424 b can be programmed with the first hash output and the first conflicts region 414 b can be programmed with a search result (stored search value and associate value, all under direction of the programming unit 430 ).
- the process 500 is then essentially finished for the present input search value.
- step 540 a search result based on the input search value and an associate value for it may be programmed into the base region 414 a of the memory 414 , under direction of the programming unit 430 .
- the process 500 is then essentially finished for the present input search value.
- the input search values are six-digits long and the associate values are two-digits long (base 10 numbers are also used here to facilitate understanding).
- the search data bus 416 and the path 428 a are six-digit buses, the path 428 b is a four-digit bus, and the paths 428 c-e are all two-digit buses.
- the address bus 418 is a three-digit bus because it must carry the two-digit content of the second hash output when there are no hash collisions in the H-CAM 410 , and also carry three digits otherwise (discussed presently).
- the format 000:000000,00 can be used to reference the memory 414 , wherein the three digits to the left of the colon represent an address index value, the six digits between the colon and comma represent a stored search value, and the two digits to the right of the comma represent an associate value.
- the contents of the first CAM unit 424 a can be represented using the format 000:000000, wherein the three digits to the left of the colon represent an address index value and the six digits to the right of the colon represent a comparison value equaling an input search value known to produce a collision in the first hash unit 422 a. That is, the 6-digit comparison value is what is compared for a match and the 3-digit address value is associatively “stored” with it (typically in CAM, where this address is simply based on the storage location of the comparison value), to be used to avoid the hash collision by accessing an alternate location in the memory 414 (i.e., in the second conflicts region 414 c ).
- the contents of the second CAM unit 424 b can be represented using the format 000:0000, wherein the three digits to the left of the colon represent an address value and the four digits to the right of the colon represent a comparison value for a hash output known to produce a collision in the second hash unit 422 b. That is, the 4-digit comparison value is what is compared for a match here and the 3-digit address value is associatively stored with it, to be used to avoid the hash collision here by accessing an alternate location in the memory 414 (i.e., in the first conflicts region 414 b ).
- step 510 the CAM units 424 a-b and the memory 414 have nothing stored in them. Typically all the values will be zero, but other conventions can be used. This state is represented in row 1 of TABLE 2.
- a first search value is then entered, say, 324238 (step 512 ).
- the first hash unit 422 a generates a first hash output, say, 7783 (step 514 ). With nothing stored yet in the first CAM unit 424 a, it will not provide any first CAM output (step 516 ).
- the second hash unit 422 b will generate a second hash result, say, 63 (step 518 ). With nothing stored yet in the second CAM unit 424 b, it will not provide any second CAM output (step 520 ).
- the logic unit 426 therefore simply picks the second hash output, 63 (step 522 ). Using this address value, the memory 414 provides the content of address 63 , which is nothing so far (step 538 ). This state is represented in row 2 of TABLE 2.
- the controller 412 will determine that the first search value (324238) has no entry yet in the memory 414 (step 540 ). One is therefore created in the base region 414 a using the search value and an associate value for it, say, 17. This entry is programmed into the memory 414 at address 63 (step 550 ), since that is what the hash units 422 a-b here map the search value of 324238 to, and address 63 is presently available. This state is represented in row 3 of TABLE 2.
- a second search value is entered, say, 578901.
- the first hash unit 422 a will generate a first hash result, say, 6311.
- the second hash unit 422 b will generate a second hash result, say, 63 again.
- the logic unit 426 picks the second hash output, 63 .
- the memory 414 uses this address value to provide the content of address 63 , which is 324238, 17. This state is represented in row 4 of TABLE 2.
- the controller 212 now determines that: the search value (578901) has a corresponding entry in the memory 414 ; a hash collision has occurred because the search field in the search result is different than the input search value used (324238 ⁇ 578901)(step 542 ); and that this is a first level hash collision.
- An entry in the second CAM unit 424 b is therefore created (step 548 ) using the first hash output (6311) and an available address for an entry in a conflicts region (here the first conflicts region 414 b ) of the memory 414 , say, address 200 .
- a new entry is also created in the memory 414 , at address 100 in the first conflicts region 414 b based on the search value (578901) and an associate value provided for it, say, 23. This state is represented in row 5 of TABLE 2.
- a third search value is entered, say, 322413.
- the first hash unit 422 a will generate a first hash output, say, 6311 again, which forces the second hash unit 422 b to generate 63 as the second hash output.
- the first CAM unit 424 a has no match for 322413, so there is no first CAM output.
- the second CAM unit 424 b has a match for 6311, so it provides the associatively stored address index 100 as the second CAM output (step 520 ).
- the logic unit 426 evaluates its inputs and then picks the second CAM output, 100 . Using this as the address value, the memory 414 provides the content of address 100 , which is 578901, 23.
- the controller 412 now determines that: the search value (322413) has a corresponding entry in the memory 414 ; a hash collision has occurred because the search field in the search result is different than the input search value used (324238 ⁇ 322413); this is not a first level hash collision; and that this is a second level hash collision.
- An entry in the first CAM unit 424 a is therefore created (step 536 ) using the search value (322413) and an available address for an entry in the conflicts region (here the second conflicts region 414 c ) of the memory 414 , say, address 200 .
- a new entry is also created in the memory 414 , at address 200 in the second conflicts region 314 c and based on the search value (322413) and an associate value provided for it, say, 86.
- No search value is required in the second conflicts region 414 c the memory 414 because the first CAM unit 424 a already contains it and it will always map uniquely (a dash represents this in TABLE 2). This state is represented in row 7 of TABLE 2.
- a fourth search value is entered, say, 578901 again.
- the first hash unit 422 a generates a first hash output of 6311, which forces the second hash unit 422 b to generate 63 as the second hash output.
- the first CAM unit 424 a has no a match for 578901, so there is no first CAM output.
- the second CAM unit 424 b has a match for 6311, so the second CAM output is the associatively stored address index 100 .
- the logic unit 426 evaluates its inputs and then picks the second CAM result, 100 . Using this address value, the memory 414 provides the content of address 100 , which is 578901, 23.
- This state is represented in row 8 of TABLE 2.
- a fifth search value is entered, say, 322413 again.
- the first hash unit 422 a will generate a first hash output of 6311, which forces the second hash unit 422 b to generate 63 as the second hash output.
- the first CAM unit 424 a has a match for 322413, so the first CAM output is the associatively stored address index 200 .
- the second CAM unit 424 b also has a match for 6311, so the second CAM output is the associatively stored address index 100 .
- the logic unit 426 evaluates its inputs and then picks the first CAM result, 200 (since a first CAM output gets highest priority). Using this as the address value, the memory 414 provides the content of address 200 , which is-, 86 (recall that there are no stored search values in the highest order conflicts region).
- This state is represented in row 9 of TABLE 2.
- a sixth search value is entered, say, 324238 again.
- the first hash unit 422 a will generate a first hash output of 7783 again, which forces the second hash unit 422 b to generate 63 again as the second hash output.
- the first CAM unit 424 a has no match for 324238, so there is no first CAM output.
- the second CAM unit 424 b has no match for 7783, so there also is no second CAM output.
- the logic unit 426 evaluates its inputs and then picks the second hash output, 63 . Using this as the address value, the memory 414 provides the content of address 63 , which is 324238, 17.
- This state is represented in row 10 of TABLE 2.
- FIG. 8 is a block diagram depicting a search engine 600 according to another preferred embodiment of the present invention.
- the particularly novel aspect here is a single level H-CAM 610 which employs a variation of the hash pointer ( FIG. 3 ) to perform internal comparisons for detecting hash collisions.
- the H-CAM 610 works with a controller 612 and a memory 614 . These may be substantially conventional, but are both different in some regards from the controller 212 and memory 214 (FIG. 4 ).
- the controller 612 does not need to receive any stored search values back for performing comparisons against original input search values (reducing its pin-count and footprint), and the memory 614 does not need to store the search values (reducing its size).
- the H-CAM 610 includes a hash unit 622 , a CAM unit 624 , a first logic unit 640 , and a comparison section 652 .
- the salient difference is the comparison section 652 , which includes a search data storage 654 , a comparator 656 , and a second logic unit 658 .
- FIG. 9 a is a block diagram depicting one architecture for the first logic unit 640 , wherein it receives the hash output, the CAM output, and also a CAM hit signal (the mere presence of a CAM output denotes a hit, of course, but using a separate signal provides some speed and logic design benefits).
- the first logic unit 640 connects to the search data storage 654 and provides it with a hash address based on the hash output.
- FIG. 9 b is a block diagram depicting an architecture for the search data storage 654 , wherein it is broken into two memory blocks: a hash pointer memory 660 and a search data memory 662 .
- the hash pointer memory 660 works much like the hash pointer unit 110 discussed with reference to FIG. 3 .
- the hash pointer memory 660 here receives the hash address and provides a pointer value. It thus has a size based on the number of ways of set-associativity used.
- the pointer value is then used as an address input to the search data memory 662 , which here contains the stored search values that are used to compare with the original input search values to detect hash collisions.
- the hash pointer memory 660 typically will be much deeper (m>n in FIG. 9 b) than the search data memory 662 , because its purpose is to increase the utilization of the search data memory 662 . Most of the hash pointer memory 660 will be empty but that is acceptable, since it is used to reduce the collision probability in the search data memory 662 . With a proper memory depth ratio between the hash pointer memory 660 and the search data memory 662 , the amount of the search data memory 662 required can be reduced.
- the comparison section 652 provides the pointer value to the first logic unit 640 and it is what is ultimately used in this embodiment to access the base region of the memory 614 .
- the second logic unit 658 passes the pointer value of a search to the first logic unit 640 (the mere presence of a value denotes a hit but using a separate signal, as is depicted, provides some speed and design benefits).
- the first logic unit 640 can provide four hash addresses to the comparison section 652 and it will provide up to one pointer value back.
- the controller 612 can then also be signaled, via a hit line 664 , that the search result on the result bus 620 is a valid one.
- FIG. 8 it also summarizes the difference between the prior art hash-based and CAM-based approaches and a simple embodiment of the invention depicted in FIG. 8 , and FIGS. 9 a-b.
- the specifications are essentially the same as for the prior art examples, except that a size of 128 ⁇ 100K is chosen for the CAM unit 624 based on an assumption that not more than 10% of the total database size need be devoted to handling hash collisions.
- the H-CAM 610 has the same speed as the prior art CAM-based approach.
- the H-CAM 610 is shown having roughly the same cost and power consumption as the prior art hash-based approach, but this is somewhat misleading.
- the H-CAM 610 here employs only 2-way set-associativity. If a higher degree of multi-way set-associativity is used additional cost and power savings can be had, providing the present invention with even greater advantage over the hash-based and CAM-based prior art.
- the memory 614 needs to be 1M ⁇ 32 in size, to handle only the one million desired entries (100% utilization is possible because using the pointer values are used).
- the CAM unit 624 can be small, say, only 32K ⁇ 128 in size. It should particularly be noted that increasing the degree of multi-way set-associativity in this manner permits the CAM unit 624 to become decreasingly small, almost trivially small. This is very beneficial if actual content associative type memory is used (typically necessary where high speed is desired). Such true CAM requires more die area and consumes more power than most other types of memory, and usually is much more expensive. Reducing the amount of CAM used is therefore desirable.
- the hash pointer memory 660 needs to be 4M ⁇ 20 and the search data memory 662 needs to be 1M ⁇ 128.
- the hash addresses need to be 22-bits wide, to address the four million locations in the hash pointer memory 660 .
- the pointer values are 20-bits wide, since they only need to address the entries (associate content) in the memory 614 and to also address the one million entries (stored search values) in the search data memory 662 .
- the total memory required in the example above is equivalent to 4M ⁇ 61(1M ⁇ 32+32K ⁇ 128+4M ⁇ 20+1M ⁇ 128), which is a marked reduction from the 4M ⁇ 160 a conventional 4-way set associative approach would require.
- comparison section 652 There are many different ways to implement the comparison section 652 , and the architecture of these (and the hash algorithm) play an important role in overall efficiency. If designed correctly, this approach is able to reduce the total amount of memory (CAM and other) required. As can be seen in TABLE 1, this can produce a substantial cost savings. Basically, two things can be improved. The first is the handling of hash collisions by using a multi-way set associative hash, and the other is to reduce the depth of the search data storage 654 , because the search values are usually very wide.
- FIG. 10 is a block diagram depicting a search engine 700 according to another preferred embodiment of the present invention.
- the particularly novel aspect here is a H-RAM 710 which also employs a variation of the hash pointer ( FIG. 3 ) to perform internal comparisons for detecting hash collisions.
- the H-RAM 710 works with a controller 712 and a memory 714 . As was the case for the H-CAM 610 of FIG. 8 , these may be substantially conventional.
- the controller 712 here also does not need to receive any stored search values back for performing comparisons (reducing its pin-count and footprint), and the memory 714 here also does not need to store the search values (reducing its size).
- the architecture of the H-RAM 710 is notable in that it does not employ a CAM.
- the underlying rationale here is that if a sufficiently high degree of multi-way set associativity is provided, CAM is not needed to address hash collisions.
- the H-RAM 710 includes a hash unit 722 , a first logic unit 740 , and a comparison section 752 .
- the comparison section 752 includes a search data storage 754 , a comparator 756 , and a second logic unit 758 .
- FIG. 11 a is a block diagram depicting one possible internal architecture for the first logic unit 740
- FIG. 11 b is a block diagram depicting one possible internal architecture for the search data storage 754 .
- the first logic unit 740 here is simpler than the first logic unit 640 and in FIG. 9 a. It converts the (n-bit) hash output into (m-bit) hash addresses, and it performs any desired translation of the (n-bit) indirect hash pointer into the address value for use with the memory 714 .
- the search data storage 754 and the search data storage 654 may be essentially the same.
- FIG. 12 is a block diagram depicting a search engine 800 according to another preferred embodiment of the present invention, an embodiment incorporating many of the principals so far discussed into a H-CAM 810 .
- a controller 812 and memory 814 are present again and key points to note are in the architecture of the H-CAM 810 .
- the H-CAM 810 here includes hash blocks 862 , a CAM block 864 , a comparison section 866 , and a main logic unit 868 .
- the hash blocks 862 each include a paired input logic sub-unit 870 and hash unit 872 .
- the CAM block 864 includes an input logic sub-unit 874 , a number of CAM units 876 (typically equal in number to the hash blocks 862 ), and an output logic sub-unit 878 .
- the comparison section 866 includes a search data storage 880 , a comparator 882 , and an output logic sub-unit 884 .
- the input logic sub-units 870 of the hash blocks 862 route data off of a common input path 886 into the individual hash block 862 or onward to the CAM block 864 , or route the output data from a prior hash block 862 in similar manner.
- the input logic sub-unit 874 of the CAM block 864 routes data into the CAM units 876
- the output logic sub-unit 878 combines and routes data from the CAM units 876 .
- the output logic sub-unit 884 of the comparison section 866 combines and routes data from the comparison section 866 .
- the data received from the last hash block 862 , the output logic sub-unit 878 of the CAM block 864 , and the output logic sub-unit 884 of the comparison section 866 is used by the main logic unit 868 , which outputs information to the comparison section 866 , to the memory 814 , and to the controller 812 , via a hit line 888 .
- the H-CAM 810 can be user configured to work as a 4-level unit, much in the manner described for the H-CAM 310 in FIG. 5 ; or it can be configured to work as a 2-level unit, much in the manner described for the H-CAM 410 in FIG. 6 ; or it can be configured to work as a 1-level unit, much in the manner described for the H-CAM 210 in FIG. 4 . In particular, it can be configured to work as a 1-level unit similar to the H-CAM 610 and which operates on very large data.
- the hash blocks 862 can be configured to each handle part of a wide input on the common input path 886 , in parallel, or they can be operated in serial fashion as has essentially been described elsewhere herein.
- the CAM block 864 can handle either case, with its input logic sub-unit 874 and its output logic sub-unit 878 configurable to use the CAM units 876 as one effective large CAM or as smaller amounts of CAM.
- the comparison section 866 and its output logic sub-unit 884 are similarly configurable to work with the configuration of the other components.
- FIG. 13 is a block diagram depicting a search engine 900 according to another preferred embodiment of the present invention, an embodiment employing the ability to scale for large needs by cascading multiple H-CAMs 910 to form a bigger overall system. If the internal architecture of the H-CAMs 910 generally resembles that of the H-CAMs 210 , 310 , 410 , and an expansion bus 922 is added, a controller 912 , memory 914 , search data bus 916 , address bus 918 , and result bus 920 may be used which are essentially similar to those used there with.
- the controller 912 , memory 914 , result bus 920 , and a hit line 924 may be used which are essentially similar to those used there with.
- the memory 914 may accordingly store the search data values and the associate content values or just the associate content values.
- the search engine 900 can support very large database searching without using large amounts of memory to accommodate possible hash collisions, yet it can achieve the same search performance as prior art CAM-based approaches without the attendant high cost and power consumption. Although this approach cannot guarantee a specific capacity to avoid hash collisions, similar to prior art hash-based approaches, with the proper hash algorithm and number of ways of set-associativity this variation of the invention can nonetheless achieve very high utilization. This coincides well with a key goal of the present invention, to increase the degree or number of ways of set-associativity without increasing the memory speed or the bandwidth requirement.
- H-CAM supports an n-way-set-associative hash
- the entire system would be able to support (n ⁇ number of H-CAM)-way-set associative hash.
- Multiple H-CAMs such as the H-CAM 610 shown in FIG. 8 , can be cascaded together, such as through the expansion bus 922 as shown in FIG. 13 .
- the system can employ a 10-way-set-associative hash and the hash pointer memory and the search data memory within each H-CAM need to only support two reads per input search value, instead of the ten that would be needed in a typical prior art 10-way-set-associative hash approach.
- TABLE 3 provides a comparison of two different implementations of a one million entry 8-way-set-assoicative hash-based system.
- Each H-CAM will have 256K entries in the search data memory and 512K pointers in the hash pointer memory. Further assuming each search data entry is 128-bits wide, it can be seen that the inventive approach uses only about one-sixth of the memory and requires only one-fourth of the memory bandwidth.
- FIG. 14 is a block diagram depicting a search engine 1000 according to another preferred embodiment of the present invention, an embodiment employing the ability to scale for large needs by cascading multiple H-RAMs 1010 .
- the search engine 1000 here much resembles the search engine 900 of FIG. 13 , a controller 1012 , memory 1014 , search data bus 1016 , address bus 1018 , and result bus 1020 are provided, and an expansion bus 1022 is used to interconnect the H-RAMs 1010 .
- FIG. 15 is a block diagram depicting a search engine 1100 according to another preferred embodiment of the present invention, an embodiment employing the ability to scale for large needs by cascading multiple of CAMs 1110 a, H-CAMs 1110 b, and H-RAMs 1110 c, with a controller 1112 , memory 1114 , search data bus 1116 , address bus 1118 , and result bus 1120 and all interconnected by an expansion bus 1122 .
- the search engine 1100 thus is particularly powerful and configurable to various applications, including searching very large and highly specialized databases.
- FIG. 4 depicted a single level H-CAM variation
- FIG. 5 depicted a multi level H-CAM variation. Both of these examples use 1-way set-associativity, for simplicity, but using multi-way set-associativity is a straight forward extension.
- FIG. 6 covered programming, which is essentially also straight forward and possible with generally conventional techniques, and FIG. 6 and the flow chart of FIG. 7 were used in a detailed example.
- FIGS. 8 and 9 a-b A novel “local” comparison approach for moving the task of comparison into the H-CAM was discussed (see e.g., FIGS. 8 and 9 a-b ), employing a variation of the hash pointer approach (FIG. 3 ). As is the case with just the hash pointer approach, this local comparison approach provides particular benefit when used with multi-way set-associativity.
- FIGS. 10 and 11 a-b A novel H-RAM approach was then discussed, one which uses a variation of the local comparison approach (see e.g., FIGS. 10 and 11 a-b ). Enhancing the multi level H-CAM by using internal routing logics was also discussed, with optional local comparison included (see e.g., FIG. 12 ). Finally, cascading multiple H-CAMs, cascading multiple H-RAMs, and cascading multiple CAMs, H-CAMs, and H-RAMs together in combination were shown (FIGS. 13 - 15 ).
- the present search engines 100 , 200 , 300 , 400 , 600 , 700 , 800 , 900 , 1000 , 1100 , and the individual H-CAMs 210 , 310 , 410 , 610 , and 810 and the individual H-RAM 710 are well suited for application in the searching of databases of associate content.
- the search engines, H-CAMs, and H-RAM can search large databases, particularly when variations such as the configurable embodiment depicted in FIG. 12 or the cascade able embodiments depicted in FIGS. 13-15 are used.
- the invention can substantially reduce the memory needed for database storage.
- the embodiment depicted in FIG. 3 shows how the invention permits memory size to not be based on the degree of multi-way set-associativity used.
- the embodiments depicted in FIGS. 4-6 show how database memory may also be reduced by not storing instances of the search values in a highest level conflicts region in the main memory, and the embodiments depicted in FIGS. 8-12 show how database memory may be reduced to store only associate content, and then with a very high degree of utilization.
- the invention can also substantially reduce the time needed for conducting database searches. While the embodiments depicted in FIGS. 3-6 show that the invention can at least equal the search speed of hash-based prior art approaches, the more sophisticated embodiments depicted in FIGS. 8-11 show how the invention can better the search speed of hash-based prior art approaches and approach the speed of CAM-based prior art approaches.
- the invention can also substantially reduce the overall search engine and database storage system cost. This is achieved directly by increasing memory utilization, and thus reducing the need for memory. Cost reduction is also further achieved indirectly, by reducing bus widths, pin counts, circuit foot print, power consumption (and dissipating heat), etc.
- FIG. 1 FIG. 2 FIG. 3
- ASIC output pins 21 128 128 ASIC input pins 160 32 32 RAM size (est. cost) 2M ⁇ 160 ($800) 1M ⁇ 32 ($80) 1M ⁇ ($80) CAM size (est. cost) — 1M ⁇ 128 ($3200) 100K ⁇ 128 ($320)
- Hash Pointer RAM — — 2M ⁇ 20 ($100) size (est. cost)
- Hash 1 output Hash 2 output (6-digit (4-digit 2-digit CAM 1 CAM 2 Memory wide) wide) wide) content content content 1 — — — — — — 2 324238 7783 63 — — 3 — — — — — — — — — 63: 324238, 17 4 578901 6311 63 — — 63: 324238, 17 5 — — — — 100.6311 63: 324238, 17 100: 578901, 23 6 322413 6311 63 — 100.6311 63: 324238, 17 100: 578901, 23 7 — — — 200.322413 100:6311 63: 324238, 17 100: 578901, 23 200: —, 86 8 578901 6311 63 200.322413 100.6311 63: 324238, 17 100: 578901, 23 200: —, 86 9 322413 6311
- H-CAM Memory size Search Data memory 8 million entries 1 million entries Hash Pointer memory none 2M pointers Total (Mbit) 1024 164 Memory bandwidth Reads/search 8 2 per H-CAM
Abstract
Description
TABLE 1 | ||||
Hash-based approach | CAM-based | H-CAM-based approach | ||
(2-way-set-associative) | approch | (2-way-set-associative) | ||
|
|
FIG. 3 | ||
ASIC output pins | 21 | 128 | 128 |
ASIC input pins | 160 | 32 | 32 |
RAM size (est. cost) | 2M × 160 ($800) | 1M × 32 ($80) | 1M × ($80) |
CAM size (est. cost) | — | 1M × 128 ($3200) | 100K × 128 ($320) |
Hash Pointer RAM | — | — | 2M × 20 ($100) |
size (est. cost) | |||
Search Data RAM | — | — | 1M × 128 ($320) |
size (est. cost) | |||
Database size | Depends | 1M | Depends |
(entries) supported | |||
|
2 reads per | 1 read per | 1 read per |
RAM read | search | search | search |
Estimated cost | $800 | $3200 | $820 |
Estimated Power | 20 W | 162 W | 28.5 W |
consumption | |||
TABLE 2 | ||||||||
| Hash | 1 | Hash | 2 output | ||||
(6-digit | (4-digit | 2- | CAM | 1 | |
Memory | ||
wide) | wide) | wide) | | content | content | |||
1 | — | — | — | — | — | — |
2 | 324238 | 7783 | 63 | — | — | — |
3 | — | — | — | — | — | 63: 324238, 17 |
4 | 578901 | 6311 | 63 | — | — | 63: 324238, 17 |
5 | — | — | — | — | 100.6311 | 63: 324238, 17 |
100: 578901, 23 | ||||||
6 | 322413 | 6311 | 63 | — | 100.6311 | 63: 324238, 17 |
100: 578901, 23 | ||||||
7 | — | — | — | 200.322413 | 100:6311 | 63: 324238, 17 |
100: 578901, 23 | ||||||
200: —, 86 | ||||||
8 | 578901 | 6311 | 63 | 200.322413 | 100.6311 | 63: 324238, 17 |
100: 578901, 23 | ||||||
200: —, 86 | ||||||
9 | 322413 | 6311 | 63 | 200.322413 | 100.6311 | 63: 324238,17 |
100: 578901, 23 | ||||||
200: —, 86 | ||||||
10 | 324238 | 7783 | 63 | 200.322413 | 100.6311 | 63: 324238,17 |
100: 578901, 23 | ||||||
200: —, 86 | ||||||
TABLE 3 | ||
Memory Size and Bandwidth requirement | Old method (FIG. 1) | H-CAM (FIG. 11) |
Memory size | Search Data memory | 8 million |
1 million entries |
Hash Pointer memory | none | 2M pointers | |
Total (Mbit) | 1024 | 164 | |
Memory bandwidth | Reads/search | 8 | 2 per H-CAM |
Claims (11)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/065,261 US6917934B2 (en) | 2001-08-09 | 2002-09-30 | Search engine for large database search using hash pointers |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/927,599 US6889225B2 (en) | 2001-08-09 | 2001-08-09 | Large database search using content addressable memory and hash |
US10/065,261 US6917934B2 (en) | 2001-08-09 | 2002-09-30 | Search engine for large database search using hash pointers |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/927,599 Continuation US6889225B2 (en) | 2001-08-09 | 2001-08-09 | Large database search using content addressable memory and hash |
Publications (2)
Publication Number | Publication Date |
---|---|
US20030033293A1 US20030033293A1 (en) | 2003-02-13 |
US6917934B2 true US6917934B2 (en) | 2005-07-12 |
Family
ID=25454967
Family Applications (3)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/927,599 Expired - Fee Related US6889225B2 (en) | 2001-08-09 | 2001-08-09 | Large database search using content addressable memory and hash |
US10/065,267 Expired - Fee Related US7107258B2 (en) | 2001-08-09 | 2002-09-30 | Search engine for large database search using CAM and hash |
US10/065,261 Expired - Lifetime US6917934B2 (en) | 2001-08-09 | 2002-09-30 | Search engine for large database search using hash pointers |
Family Applications Before (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US09/927,599 Expired - Fee Related US6889225B2 (en) | 2001-08-09 | 2001-08-09 | Large database search using content addressable memory and hash |
US10/065,267 Expired - Fee Related US7107258B2 (en) | 2001-08-09 | 2002-09-30 | Search engine for large database search using CAM and hash |
Country Status (1)
Country | Link |
---|---|
US (3) | US6889225B2 (en) |
Cited By (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20040139063A1 (en) * | 2003-01-14 | 2004-07-15 | Reuven Moskovich | Pipelined binary search machine |
US20060098675A1 (en) * | 2004-11-05 | 2006-05-11 | Michitaka Okuno | Traffic control method for network equipment |
US20090292721A1 (en) * | 2008-05-21 | 2009-11-26 | Soeren Laursen | System and Method for Application of Hash Function in Telecommunication and Networking |
Families Citing this family (103)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6889225B2 (en) * | 2001-08-09 | 2005-05-03 | Integrated Silicon Solution, Inc. | Large database search using content addressable memory and hash |
WO2003017136A1 (en) * | 2001-08-16 | 2003-02-27 | Etagon Israel Ltd. | Using associative memory to perform database operations |
US20030071837A1 (en) * | 2001-08-30 | 2003-04-17 | Intel Corporation | System and method for explaining search logic and results |
US6697276B1 (en) * | 2002-02-01 | 2004-02-24 | Netlogic Microsystems, Inc. | Content addressable memory device |
US7171439B2 (en) * | 2002-06-14 | 2007-01-30 | Integrated Device Technology, Inc. | Use of hashed content addressable memory (CAM) to accelerate content-aware searches |
US7136960B2 (en) * | 2002-06-14 | 2006-11-14 | Integrated Device Technology, Inc. | Hardware hashing of an input of a content addressable memory (CAM) to emulate a wider CAM |
JP4050559B2 (en) * | 2002-06-28 | 2008-02-20 | 富士通株式会社 | Content search processing program, recording medium recording content search processing program, and operator inquiry processing system |
US7313667B1 (en) * | 2002-08-05 | 2007-12-25 | Cisco Technology, Inc. | Methods and apparatus for mapping fields of entries into new values and combining these mapped values into mapped entries for use in lookup operations such as for packet processing |
US20040054867A1 (en) | 2002-09-13 | 2004-03-18 | Paulus Stravers | Translation lookaside buffer |
US7003625B2 (en) * | 2002-12-19 | 2006-02-21 | Mosaid Technologies, Inc. | Searching small entities in a wide CAM |
US7054995B2 (en) * | 2003-04-23 | 2006-05-30 | Integrated Silicon Solution, Inc. | Dynamic linking of banks in configurable content addressable memory systems |
US20050004937A1 (en) * | 2003-05-12 | 2005-01-06 | Colarik Andrew Michael | Integrity mechanism for file transfer in communications networks |
US7185172B1 (en) * | 2003-10-31 | 2007-02-27 | Integrated Device Technology, Inc. | CAM-based search engine devices having index translation capability |
US9229646B2 (en) * | 2004-02-26 | 2016-01-05 | Emc Corporation | Methods and apparatus for increasing data storage capacity |
US7290084B2 (en) * | 2004-11-02 | 2007-10-30 | Integrated Device Technology, Inc. | Fast collision detection for a hashed content addressable memory (CAM) using a random access memory |
JP4082614B2 (en) * | 2004-11-12 | 2008-04-30 | インターナショナル・ビジネス・マシーンズ・コーポレーション | Database management system, database management method, and program |
US20060155915A1 (en) * | 2004-12-30 | 2006-07-13 | Pereira Jose P | Database query processor |
US7613669B2 (en) * | 2005-08-19 | 2009-11-03 | Electronics And Telecommunications Research Institute | Method and apparatus for storing pattern matching data and pattern matching method using the same |
US8572697B2 (en) * | 2011-11-18 | 2013-10-29 | Blackridge Technology Holdings, Inc. | Method for statistical object identification |
JP3894335B1 (en) * | 2005-10-04 | 2007-03-22 | インターナショナル・ビジネス・マシーンズ・コーポレーション | Apparatus and method for determining database consistency |
US7526530B2 (en) * | 2006-05-05 | 2009-04-28 | Adobe Systems Incorporated | System and method for cacheing web files |
US8826023B1 (en) * | 2006-06-30 | 2014-09-02 | Symantec Operating Corporation | System and method for securing access to hash-based storage systems |
US20080052270A1 (en) * | 2006-08-23 | 2008-02-28 | Telefonaktiebolaget Lm Ericsson (Publ) | Hash table structure and search method |
GB0620043D0 (en) * | 2006-10-10 | 2006-11-22 | Univ Belfast | Improvements relating to the detection of malicious content in date |
JP4148529B2 (en) * | 2006-12-28 | 2008-09-10 | インターナショナル・ビジネス・マシーンズ・コーポレーション | System, method and program for checking index consistency in a database |
US8447911B2 (en) * | 2007-07-05 | 2013-05-21 | Board Of Regents, University Of Texas System | Unordered load/store queue |
US8838558B2 (en) * | 2007-08-08 | 2014-09-16 | Hewlett-Packard Development Company, L.P. | Hash lookup table method and apparatus |
US8335780B2 (en) * | 2008-03-11 | 2012-12-18 | James Madison Kelley | Scalable high speed relational processor for databases and networks |
US8114117B2 (en) * | 2008-09-30 | 2012-02-14 | Tyco Healthcare Group Lp | Compression device with wear area |
US10262136B1 (en) * | 2008-08-04 | 2019-04-16 | Zscaler, Inc. | Cloud-based malware detection |
US7796541B1 (en) | 2008-09-30 | 2010-09-14 | Juniper Networks, Inc. | Methods and apparatus for range matching during packet classification based on a linked-node structure |
US8675648B1 (en) | 2008-09-30 | 2014-03-18 | Juniper Networks, Inc. | Methods and apparatus for compression in packet classification |
US8798057B1 (en) | 2008-09-30 | 2014-08-05 | Juniper Networks, Inc. | Methods and apparatus to implement except condition during data packet classification |
US8804950B1 (en) | 2008-09-30 | 2014-08-12 | Juniper Networks, Inc. | Methods and apparatus for producing a hash value based on a hash function |
US7961734B2 (en) * | 2008-09-30 | 2011-06-14 | Juniper Networks, Inc. | Methods and apparatus related to packet classification associated with a multi-stage switch |
US7738454B1 (en) | 2008-09-30 | 2010-06-15 | Juniper Networks, Inc. | Methods and apparatus related to packet classification based on range values |
US7835357B2 (en) * | 2008-09-30 | 2010-11-16 | Juniper Networks, Inc. | Methods and apparatus for packet classification based on policy vectors |
US7889741B1 (en) | 2008-12-31 | 2011-02-15 | Juniper Networks, Inc. | Methods and apparatus for packet classification based on multiple conditions |
US8111697B1 (en) | 2008-12-31 | 2012-02-07 | Juniper Networks, Inc. | Methods and apparatus for packet classification based on multiple conditions |
US8488588B1 (en) | 2008-12-31 | 2013-07-16 | Juniper Networks, Inc. | Methods and apparatus for indexing set bit values in a long vector associated with a switch fabric |
US8195873B2 (en) * | 2009-02-06 | 2012-06-05 | Hillel Gazit | Ternary content-addressable memory |
US8473657B2 (en) * | 2009-03-23 | 2013-06-25 | Lsi Corporation | High speed packet FIFO output buffers for switch fabric with speedup |
US8638805B2 (en) | 2010-05-18 | 2014-01-28 | Lsi Corporation | Packet draining from a scheduling hierarchy in a traffic manager of a network processor |
US8869151B2 (en) | 2010-05-18 | 2014-10-21 | Lsi Corporation | Packet draining from a scheduling hierarchy in a traffic manager of a network processor |
US8910168B2 (en) | 2009-04-27 | 2014-12-09 | Lsi Corporation | Task backpressure and deletion in a multi-flow network processor architecture |
US8949582B2 (en) | 2009-04-27 | 2015-02-03 | Lsi Corporation | Changing a flow identifier of a packet in a multi-thread, multi-flow network processor |
US8910171B2 (en) * | 2009-04-27 | 2014-12-09 | Lsi Corporation | Thread synchronization in a multi-thread network communications processor architecture |
US8565250B2 (en) | 2010-05-18 | 2013-10-22 | Lsi Corporation | Multithreaded, superscalar scheduling in a traffic manager of a network processor |
US8677075B2 (en) | 2010-05-18 | 2014-03-18 | Lsi Corporation | Memory manager for a network communications processor architecture |
US8949578B2 (en) | 2009-04-27 | 2015-02-03 | Lsi Corporation | Sharing of internal pipeline resources of a network processor with external devices |
US8869150B2 (en) | 2010-05-18 | 2014-10-21 | Lsi Corporation | Local messaging in a scheduling hierarchy in a traffic manager of a network processor |
US8683221B2 (en) | 2010-05-18 | 2014-03-25 | Lsi Corporation | Configurable memory encryption with constant pipeline delay in a multi-core processor |
US8874878B2 (en) | 2010-05-18 | 2014-10-28 | Lsi Corporation | Thread synchronization in a multi-thread, multi-flow network communications processor architecture |
US8489791B2 (en) | 2010-03-12 | 2013-07-16 | Lsi Corporation | Processor bus bridge security feature for network processors or the like |
US8848723B2 (en) | 2010-05-18 | 2014-09-30 | Lsi Corporation | Scheduling hierarchy in a traffic manager of a network processor |
US8843682B2 (en) | 2010-05-18 | 2014-09-23 | Lsi Corporation | Hybrid address mutex mechanism for memory accesses in a network processor |
US8943507B2 (en) * | 2009-04-27 | 2015-01-27 | Deepak Mital | Packet assembly module for multi-core, multi-thread network processors |
US8837501B2 (en) | 2010-05-18 | 2014-09-16 | Lsi Corporation | Shared task parameters in a scheduler of a network processor |
US8321385B2 (en) * | 2010-03-12 | 2012-11-27 | Lsi Corporation | Hash processing in a network communications processor architecture |
US9081742B2 (en) * | 2009-04-27 | 2015-07-14 | Intel Corporation | Network communications processor architecture |
US8615013B2 (en) | 2010-05-18 | 2013-12-24 | Agere Systems Llc | Packet scheduling with guaranteed minimum rate in a traffic manager of a network processor |
US9160684B2 (en) | 2009-04-27 | 2015-10-13 | Intel Corporation | Dynamic updating of scheduling hierarchy in a traffic manager of a network processor |
US9461930B2 (en) | 2009-04-27 | 2016-10-04 | Intel Corporation | Modifying data streams without reordering in a multi-thread, multi-flow network processor |
US8499137B2 (en) * | 2010-03-12 | 2013-07-30 | Lsi Corporation | Memory manager for a network communications processor architecture |
US8868889B2 (en) * | 2010-03-12 | 2014-10-21 | Lsi Corporation | Instruction breakpoints in a multi-core, multi-thread network communications processor architecture |
US8515965B2 (en) | 2010-05-18 | 2013-08-20 | Lsi Corporation | Concurrent linked-list traversal for real-time hash processing in multi-core, multi-thread network processors |
US8869156B2 (en) | 2010-05-18 | 2014-10-21 | Lsi Corporation | Speculative task reading in a traffic manager of a network processor |
US8705531B2 (en) | 2010-05-18 | 2014-04-22 | Lsi Corporation | Multicast address learning in an input/output adapter of a network processor |
US9183145B2 (en) | 2009-04-27 | 2015-11-10 | Intel Corporation | Data caching in a network communications processor architecture |
US9218290B2 (en) | 2009-04-27 | 2015-12-22 | Intel Corporation | Data caching in a network communications processor architecture |
US8576862B2 (en) | 2010-05-18 | 2013-11-05 | Lsi Corporation | Root scheduling algorithm in a network processor |
US9152564B2 (en) | 2010-05-18 | 2015-10-06 | Intel Corporation | Early cache eviction in a multi-flow network processor architecture |
US8547878B2 (en) | 2010-05-18 | 2013-10-01 | Lsi Corporation | Modularized scheduling engine for traffic management in a network processor |
US8873550B2 (en) | 2010-05-18 | 2014-10-28 | Lsi Corporation | Task queuing in a multi-flow network processor architecture |
US8761204B2 (en) | 2010-05-18 | 2014-06-24 | Lsi Corporation | Packet assembly module for multi-core, multi-thread network processors |
US8537832B2 (en) * | 2010-03-12 | 2013-09-17 | Lsi Corporation | Exception detection and thread rescheduling in a multi-core, multi-thread network processor |
US8539199B2 (en) * | 2010-03-12 | 2013-09-17 | Lsi Corporation | Hash processing in a network communications processor architecture |
US9727508B2 (en) | 2009-04-27 | 2017-08-08 | Intel Corporation | Address learning and aging for network bridging in a network processor |
US8917738B2 (en) | 2009-04-27 | 2014-12-23 | Lsi Corporation | Multicasting traffic manager in a network communications processor architecture |
US8935483B2 (en) * | 2009-04-27 | 2015-01-13 | Lsi Corporation | Concurrent, coherent cache access for multiple threads in a multi-core, multi-thread network processor |
US8505013B2 (en) * | 2010-03-12 | 2013-08-06 | Lsi Corporation | Reducing data read latency in a network communications processor architecture |
US8619787B2 (en) | 2010-05-18 | 2013-12-31 | Lsi Corporation | Byte-accurate scheduling in a network processor |
US8949500B2 (en) | 2011-08-08 | 2015-02-03 | Lsi Corporation | Non-blocking processor bus bridge for network processors or the like |
US9444757B2 (en) | 2009-04-27 | 2016-09-13 | Intel Corporation | Dynamic configuration of processing modules in a network communications processor architecture |
US8514874B2 (en) * | 2010-03-12 | 2013-08-20 | Lsi Corporation | Thread synchronization in a multi-thread network communications processor architecture |
US9300597B2 (en) | 2009-04-27 | 2016-03-29 | Intel Corporation | Statistics module for network processors in virtual local area networks |
US9280609B2 (en) * | 2009-09-08 | 2016-03-08 | Brocade Communications Systems, Inc. | Exact match lookup scheme |
US8953603B2 (en) * | 2009-10-28 | 2015-02-10 | Juniper Networks, Inc. | Methods and apparatus related to a distributed switch fabric |
DE112010004565B4 (en) | 2009-12-25 | 2021-07-01 | International Business Machines Corporation | System, method and program for checking the consistency of pointers in a hierarchical database |
US9755947B2 (en) | 2010-05-18 | 2017-09-05 | Intel Corporation | Hierarchical self-organizing classification processing in a network switch |
US9485200B2 (en) | 2010-05-18 | 2016-11-01 | Intel Corporation | Network switch with external buffering via looparound path |
US9282060B2 (en) | 2010-12-15 | 2016-03-08 | Juniper Networks, Inc. | Methods and apparatus for dynamic resource management within a distributed control plane of a switch |
US9065761B2 (en) | 2011-07-25 | 2015-06-23 | Intel Corporation | Packet reassembly processing |
US9230548B2 (en) * | 2012-06-06 | 2016-01-05 | Cypress Semiconductor Corporation | Hybrid hashing scheme for active HMMS |
EP2933732A4 (en) * | 2012-12-12 | 2016-07-27 | Nec Corp | Database search device, database search method, and program |
US9244857B2 (en) * | 2013-10-31 | 2016-01-26 | Oracle International Corporation | Systems and methods for implementing low-latency lookup circuits using multiple hash functions |
US9865350B2 (en) * | 2014-08-21 | 2018-01-09 | Meiji University | Content addressable memory, an index generator, and a registered information update method |
US9973499B2 (en) * | 2016-01-26 | 2018-05-15 | Blackridge Technology Holdings, Inc. | Method for statistical object indentification |
CN107770076B (en) * | 2016-08-23 | 2020-12-04 | 中兴通讯股份有限公司 | Hash collision processing method and device and switching equipment |
US10503763B2 (en) * | 2016-11-15 | 2019-12-10 | Facebook, Inc. | Methods and systems for executing functions in a text field |
US11836126B2 (en) * | 2018-12-17 | 2023-12-05 | Dassault Systemes Americas Corp. | Method and system for indicating data index integrity |
US20200374231A1 (en) * | 2019-05-21 | 2020-11-26 | F5 Networks, Inc. | Managing network traffic flows |
US11119999B2 (en) | 2019-07-24 | 2021-09-14 | Sap Se | Zero-overhead hash filters |
Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6434662B1 (en) * | 1999-11-02 | 2002-08-13 | Juniper Networks, Inc. | System and method for searching an associative memory utilizing first and second hash functions |
Family Cites Families (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JPS61210477A (en) * | 1984-05-25 | 1986-09-18 | Hitachi Ltd | Vector type association memory system |
JP2668438B2 (en) * | 1989-04-21 | 1997-10-27 | 三菱電機株式会社 | Data retrieval device |
US5404553A (en) * | 1991-01-09 | 1995-04-04 | Mitsubishi Denki Kabushiki Kaisha | Microprocessor and data flow microprocessor having vector operation function |
US5390359A (en) * | 1992-03-20 | 1995-02-14 | International Business Machines Corporation | Storing and retrieving records in a computer system |
EP0594196B1 (en) * | 1992-10-22 | 1999-03-31 | Cabletron Systems, Inc. | Address lookup in packet data communications link, using hashing and content-addressable memory |
AUPO194696A0 (en) * | 1996-08-28 | 1996-09-19 | Canon Information Systems Research Australia Pty Ltd | A method of efficiently updating hashed page tables |
US6343289B1 (en) * | 1997-10-31 | 2002-01-29 | Nortel Networks Limited | Efficient search and organization of a forwarding database or the like |
US6665297B1 (en) * | 1999-12-09 | 2003-12-16 | Mayan Networks Corporation | Network routing table |
US6889225B2 (en) * | 2001-08-09 | 2005-05-03 | Integrated Silicon Solution, Inc. | Large database search using content addressable memory and hash |
-
2001
- 2001-08-09 US US09/927,599 patent/US6889225B2/en not_active Expired - Fee Related
-
2002
- 2002-09-30 US US10/065,267 patent/US7107258B2/en not_active Expired - Fee Related
- 2002-09-30 US US10/065,261 patent/US6917934B2/en not_active Expired - Lifetime
Patent Citations (1)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6434662B1 (en) * | 1999-11-02 | 2002-08-13 | Juniper Networks, Inc. | System and method for searching an associative memory utilizing first and second hash functions |
Cited By (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20040139063A1 (en) * | 2003-01-14 | 2004-07-15 | Reuven Moskovich | Pipelined binary search machine |
US20060098675A1 (en) * | 2004-11-05 | 2006-05-11 | Michitaka Okuno | Traffic control method for network equipment |
US7656887B2 (en) * | 2004-11-05 | 2010-02-02 | Hitachi, Ltd. | Traffic control method for network equipment |
US20090292721A1 (en) * | 2008-05-21 | 2009-11-26 | Soeren Laursen | System and Method for Application of Hash Function in Telecommunication and Networking |
US7984028B2 (en) | 2008-05-21 | 2011-07-19 | Applied Micro Circuits Corporation | System and method for application of hash function in telecommunication and networking |
Also Published As
Publication number | Publication date |
---|---|
US20030033276A1 (en) | 2003-02-13 |
US20030037055A1 (en) | 2003-02-20 |
US7107258B2 (en) | 2006-09-12 |
US6889225B2 (en) | 2005-05-03 |
US20030033293A1 (en) | 2003-02-13 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US6917934B2 (en) | Search engine for large database search using hash pointers | |
US5276741A (en) | Fuzzy string matcher | |
US6430527B1 (en) | Prefix search circuitry and method | |
US6434144B1 (en) | Multi-level table lookup | |
US6389507B1 (en) | Memory device search system and method | |
TWI287723B (en) | Method and data structure for a low memory overhead database | |
CN100440169C (en) | Memory and power efficient mechanism for fast table lookup | |
US6502163B1 (en) | Method and apparatus for ordering entries in a ternary content addressable memory | |
CN101510839B (en) | Method and apparatus for storing sparse and dense subtrees in a longest prefix match lookup table | |
US6522632B1 (en) | Apparatus and method for efficient prefix search | |
CN1307561C (en) | Multi-level cache having overlapping congruence groups of associativity sets in different cache levels | |
US7194574B2 (en) | Searching small entities in a wide CAM | |
CN101141389B (en) | Reinforcement multidigit Trie tree searching method and apparatus | |
US20050044134A1 (en) | High-performance hashing system | |
US20030093616A1 (en) | Low power, hash-content addressable memory architecture | |
US7013367B2 (en) | Caching associative memory using non-overlapping data | |
US20020138648A1 (en) | Hash compensation architecture and method for network address lookup | |
US20040139274A1 (en) | Virtual content addressable memory with high speed key insertion and deletion and pipelined key search | |
JP2003256265A (en) | Search memory, controller for memory search, and memory search method | |
US6925524B2 (en) | Associated content storage system | |
US7243187B2 (en) | Data retrieval device | |
US7181568B2 (en) | Content addressable memory to identify subtag matches | |
EP1173852A1 (en) | Memory with call out function | |
KR20020074780A (en) | Method of Constructing the Pipe-Lined Content Addressable Memory for High Speed Lookup of Longest Prefix Matching Algorithm in Internet Protocol Address Lookup | |
US6839825B1 (en) | Method and apparatus for logically expanding the width of memory |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTEGRATED SILICON SOLUTION, INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:CHENG, PAUL;CHOW, NELSON L.;CHIEN, FANGLI;REEL/FRAME:013135/0493Effective date: 20020926 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
FEPP | Fee payment procedure |
Free format text: PAT HOLDER NO LONGER CLAIMS SMALL ENTITY STATUS, ENTITY STATUS SET TO UNDISCOUNTED (ORIGINAL EVENT CODE: STOL); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
AS | Assignment |
Owner name: INTEGRATED SILICON SOLUTIONS, INC., CALIFORNIAFree format text: CHANGE OF ADDRESS;ASSIGNOR:INTEGRATED SILICON SOLUTIONS, INC.;REEL/FRAME:021165/0802Effective date: 20080626 |
|
AS | Assignment |
Owner name: MOSAID TECHNOLOGIES INCORPORATED, CANADAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTEGRATED SILICON SOLUTION, INC.;REEL/FRAME:021890/0760Effective date: 20080611 |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
AS | Assignment |
Owner name: MOSAID TECHNOLOGIES INCORPORATED, CANADAFree format text: CHANGE OF ADDRESS OF ASSIGNEE;ASSIGNOR:MOSAID TECHNOLOGIES INCORPORATED;REEL/FRAME:022542/0876Effective date: 20090209Owner name: MOSAID TECHNOLOGIES INCORPORATED,CANADAFree format text: CHANGE OF ADDRESS OF ASSIGNEE;ASSIGNOR:MOSAID TECHNOLOGIES INCORPORATED;REEL/FRAME:022542/0876Effective date: 20090209 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:MOSAID TECHNOLOGIES INC.;REEL/FRAME:026933/0942Effective date: 20110909 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
FPAY | Fee payment |
Year of fee payment: 12 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |