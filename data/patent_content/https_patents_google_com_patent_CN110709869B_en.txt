CN110709869B - Suggested items for use with embedded applications in chat conversations - Google Patents
Suggested items for use with embedded applications in chat conversations Download PDFInfo
- Publication number
- CN110709869B CN110709869B CN201880019817.XA CN201880019817A CN110709869B CN 110709869 B CN110709869 B CN 110709869B CN 201880019817 A CN201880019817 A CN 201880019817A CN 110709869 B CN110709869 B CN 110709869B
- Authority
- CN
- China
- Prior art keywords
- user
- embedded
- application
- chat
- interface
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
- 230000004044 response Effects 0.000 claims abstract description 386
- 238000000034 method Methods 0.000 claims abstract description 225
- 230000009471 action Effects 0.000 claims description 116
- 230000008859 change Effects 0.000 claims description 81
- 238000004891 communication Methods 0.000 claims description 65
- 230000015654 memory Effects 0.000 claims description 46
- 238000006243 chemical reaction Methods 0.000 claims description 13
- 238000001514 detection method Methods 0.000 claims description 8
- 238000010801 machine learning Methods 0.000 description 91
- 238000012549 training Methods 0.000 description 67
- 238000005304 joining Methods 0.000 description 44
- 238000012545 processing Methods 0.000 description 39
- 230000006870 function Effects 0.000 description 36
- 230000000694 effects Effects 0.000 description 34
- 230000003993 interaction Effects 0.000 description 33
- 230000002452 interceptive effect Effects 0.000 description 30
- 238000003860 storage Methods 0.000 description 27
- 230000000007 visual effect Effects 0.000 description 27
- 230000008569 process Effects 0.000 description 23
- 230000001360 synchronised effect Effects 0.000 description 22
- 230000001960 triggered effect Effects 0.000 description 12
- 230000008901 benefit Effects 0.000 description 11
- 238000004458 analytical method Methods 0.000 description 10
- 235000013361 beverage Nutrition 0.000 description 9
- 239000008186 active pharmaceutical agent Substances 0.000 description 8
- 230000002829 reductive effect Effects 0.000 description 8
- 238000013528 artificial neural network Methods 0.000 description 7
- 230000005540 biological transmission Effects 0.000 description 7
- 238000010586 diagram Methods 0.000 description 7
- 230000033001 locomotion Effects 0.000 description 7
- 238000013475 authorization Methods 0.000 description 6
- 238000004590 computer program Methods 0.000 description 6
- 230000000977 initiatory effect Effects 0.000 description 6
- 238000011093 media selection Methods 0.000 description 6
- 238000013519 translation Methods 0.000 description 6
- 239000003086 colorant Substances 0.000 description 5
- 230000008451 emotion Effects 0.000 description 5
- 238000005516 engineering process Methods 0.000 description 5
- 230000006855 networking Effects 0.000 description 5
- 230000003213 activating effect Effects 0.000 description 4
- 238000003066 decision tree Methods 0.000 description 4
- 235000013305 food Nutrition 0.000 description 4
- 238000012986 modification Methods 0.000 description 4
- 230000004048 modification Effects 0.000 description 4
- 230000008520 organization Effects 0.000 description 4
- 238000013515 script Methods 0.000 description 4
- 238000012546 transfer Methods 0.000 description 4
- 241000282326 Felis catus Species 0.000 description 3
- 230000004913 activation Effects 0.000 description 3
- 230000009118 appropriate response Effects 0.000 description 3
- 230000003190 augmentative effect Effects 0.000 description 3
- 239000003795 chemical substances by application Substances 0.000 description 3
- 230000002996 emotional effect Effects 0.000 description 3
- 239000000835 fiber Substances 0.000 description 3
- 230000007246 mechanism Effects 0.000 description 3
- 230000003287 optical effect Effects 0.000 description 3
- 230000006403 short-term memory Effects 0.000 description 3
- 241001465754 Metazoa Species 0.000 description 2
- CDBYLPFSWZWCQE-UHFFFAOYSA-L Sodium Carbonate Chemical compound [Na+].[Na+].[O-]C([O-])=O CDBYLPFSWZWCQE-UHFFFAOYSA-L 0.000 description 2
- 230000003139 buffering effect Effects 0.000 description 2
- 230000000295 complement effect Effects 0.000 description 2
- 238000012790 confirmation Methods 0.000 description 2
- 238000013136 deep learning model Methods 0.000 description 2
- 230000002349 favourable effect Effects 0.000 description 2
- 230000010006 flight Effects 0.000 description 2
- 239000011521 glass Substances 0.000 description 2
- 238000010191 image analysis Methods 0.000 description 2
- 230000010354 integration Effects 0.000 description 2
- 230000014759 maintenance of location Effects 0.000 description 2
- 238000002360 preparation method Methods 0.000 description 2
- 230000009467 reduction Effects 0.000 description 2
- 239000004065 semiconductor Substances 0.000 description 2
- 239000007787 solid Substances 0.000 description 2
- 241000269417 Bufo Species 0.000 description 1
- 244000035744 Hura crepitans Species 0.000 description 1
- 206010049155 Visual brightness Diseases 0.000 description 1
- 238000013459 approach Methods 0.000 description 1
- 238000010420 art technique Methods 0.000 description 1
- 239000012752 auxiliary agent Substances 0.000 description 1
- 238000007664 blowing Methods 0.000 description 1
- 238000004422 calculation algorithm Methods 0.000 description 1
- 230000010267 cellular communication Effects 0.000 description 1
- 239000002131 composite material Substances 0.000 description 1
- 230000006835 compression Effects 0.000 description 1
- 238000007906 compression Methods 0.000 description 1
- 238000004883 computer application Methods 0.000 description 1
- 238000010276 construction Methods 0.000 description 1
- 238000013527 convolutional neural network Methods 0.000 description 1
- 230000003247 decreasing effect Effects 0.000 description 1
- 238000012217 deletion Methods 0.000 description 1
- 230000037430 deletion Effects 0.000 description 1
- 238000002059 diagnostic imaging Methods 0.000 description 1
- 230000007613 environmental effect Effects 0.000 description 1
- 238000011156 evaluation Methods 0.000 description 1
- 230000003203 everyday effect Effects 0.000 description 1
- 230000001815 facial effect Effects 0.000 description 1
- 239000012634 fragment Substances 0.000 description 1
- 238000003384 imaging method Methods 0.000 description 1
- 239000004615 ingredient Substances 0.000 description 1
- 238000009434 installation Methods 0.000 description 1
- 230000000670 limiting effect Effects 0.000 description 1
- 238000007477 logistic regression Methods 0.000 description 1
- 230000007774 longterm Effects 0.000 description 1
- 238000007726 management method Methods 0.000 description 1
- 238000004519 manufacturing process Methods 0.000 description 1
- 239000011159 matrix material Substances 0.000 description 1
- 235000012054 meals Nutrition 0.000 description 1
- 238000003058 natural language processing Methods 0.000 description 1
- 230000001537 neural effect Effects 0.000 description 1
- 230000007935 neutral effect Effects 0.000 description 1
- 238000010422 painting Methods 0.000 description 1
- 230000036961 partial effect Effects 0.000 description 1
- 238000005192 partition Methods 0.000 description 1
- 230000002085 persistent effect Effects 0.000 description 1
- 238000003825 pressing Methods 0.000 description 1
- 230000002250 progressing effect Effects 0.000 description 1
- 238000012552 review Methods 0.000 description 1
- 238000012706 support-vector machine Methods 0.000 description 1
- 230000029305 taxis Effects 0.000 description 1
- 238000012360 testing method Methods 0.000 description 1
- 230000007704 transition Effects 0.000 description 1
- 239000013598 vector Substances 0.000 description 1
- 238000012800 visualization Methods 0.000 description 1
Abstract
Embodiments relate to suggested items for use with embedded applications in chat conversations. In some embodiments, a method includes causing a chat interface to be displayed by a first user device, the chat interface generated by a messaging application. The chat interface is configured to display messages in the chat conversation provided by user devices participating in the chat conversation over the network. The embedded interface is associated with the chat interface and is displayed by an embedded application associated with the messaging application. The occurrence of a suggested event associated with the embedded application is determined based on received data indicating that a particular event occurred at one or more other user devices participating in the chat conversation. And acquiring a suggestion response item according to the suggestion event, and displaying the suggestion response item by the first user equipment.
Description
Technical Field
The present disclosure relates to the field of communication technology, and in particular to suggested items for use with embedded applications in chat conversations.
Cross Reference to Related Applications
The present application claims priority from U.S. patent application No.15/624,638, entitled "suggested items for use with embedded applications in chat conversations," filed on 6/15 of 2017, the entire contents of which are incorporated herein by reference.
Technical Field
The popularity and convenience of digital mobile devices and the widespread use of network communications have made communication between user devices ubiquitous. For example, users typically use their devices to send electronic messages to other users as text messages, chat messages, emails, and the like. For example, in a chat conversation between user devices, a user publishes text, images, and other types of content data to a chat interface, and the published data is displayed in the chat interface displayed on other user devices participating in the chat conversation.
The background description provided herein is for the purpose of generally presenting the context of the disclosure. Work of the presently named inventors, to the extent it is described in this background section, as well as aspects of the description that may not qualify as prior art at the time of filing, are neither expressly nor impliedly admitted as prior art against the present disclosure.
Disclosure of Invention
Embodiments of the present application relate to embedded programs and interfaces for chat conversations. In some embodiments, a computer-implemented method for providing suggested items includes causing a chat interface to be displayed by a first user device, wherein the chat interface is generated by a messaging application, and wherein the chat interface is configured to display one or more messages in a chat conversation. One or more messages are provided by a plurality of user devices that are participating in a chat conversation over a network. The method causes an embedded interface to be displayed in association with a chat interface, wherein the embedded interface is provided by a first embedded application that is at least partially running on a first user device in association with a messaging application. The method determines that the suggested event has occurred in association based on received data indicating that a particular event occurred in one or more of a plurality of user devices participating in the chat conversation, wherein the one or more of the plurality of user devices are different from the first user device. The method obtains one or more suggested response items based on the suggested event and causes the one or more suggested response items to be displayed by the first user device.
Various embodiments and examples of methods are described. For example, in some embodiments, the particular event includes user input received by an associated chat interface of one or more of the plurality of user devices, user input received by an associated embedded interface of one or more of the plurality of user devices, and/or an embedded application event occurring in an associated embedded application running on one or more of the plurality of user devices. In some embodiments, the received data indicating that a particular event has occurred indicates at least one of: the method comprises the steps of implementing a predefined goal in a game of one or more of the plurality of user devices, receiving user input received by the user device engaged in a chat conversation, wherein the user input is provided in a different embedded interface displayed on the received user device, and/or launching an embedded application from a particular user device of the plurality of user devices, in a type of content feature displayed in a media item played by the one or more of the plurality of user devices. In some embodiments, the particular event includes one or more messages entered into the chat conversation by respective users of one or more of the plurality of user devices, wherein the suggested event is determined based on detection of at least one of one or more predefined topics, words, and/or phrases in the one or more messages.
In some embodiments, obtaining one or more suggested response items based on the suggested event includes determining at least one of the one or more suggested response items based on at least one of: one or more predefined associations of at least one suggested response item with suggested events; a model trained with the specific suggested event and a response input responsive to the specific suggested event; and one or more of a plurality of rules and targets for use in a game provided by the embedded application. In some embodiments, the method further comprises: receiving user input indicating a user selection of a suggestion response item from the selection of one or more suggestion response items; and outputting a selected message in the chat conversation, the selected message being associated with the selected suggested response item.
In some embodiments, the method further comprises: receiving user input indicating selection of a suggestion response item from the selection of one or more suggestion response items; and providing, in response to user input, one or more commands associated with the selected suggested response item, wherein the one or more commands include at least one of: at least one first command provided to the first embedded application; at least one second command provided to the messaging application; and/or at least one third command provided to the first user device to cause display of output information from a different application running on the first user device, wherein the output information includes information received from a server device in communication with the first user device.
In some embodiments, the method further comprises: receiving user input indicating selection of a suggestion response item from the selection of one or more suggestion response items; and providing, in response to user input, one or more commands associated with the selected suggested response item, wherein the one or more commands include at least one of: a first command to add a first set of one or more other users to the chat conversation in response to determining that the second content item is the same as the first content item output in the embedded interface of the embedded application on the first user device, wherein the second content item is displayed on the first set of one or more user devices not participating in the chat conversation; and/or a second command to add a second set of one or more other users to the chat conversation in response to determining that the second set of one or more other users has entered user comments associated with a fourth content item that is the same as the third content item output in the embedded interface on the first user device, wherein the fourth content item is displayed on a second set of one or more user devices that are not engaged in the chat conversation.
In some examples, the one or more suggested response items may include one or more text messages indicating a user's reaction to the suggested event. The method may further include indicating a user input of a selection of the selected suggestion response item from the one or more suggestion response items and providing a command to the first embedded application in response to the user input, wherein the command is associated with the selected suggestion response item. In some examples, the command to the first embedded application includes at least one of: a first command to perform an action in a game implemented by the first embedded application, a second command to change a playback position when media data is played back by the first embedded application, and/or a third command to change a shared object provided by the first embedded application. In other examples, the one or more suggestion response items include one or more suggestion commands for the first embedded application and one or more suggestion messages to be output to a chat conversation in the chat interface, wherein the one or more suggestion commands are visually distinguished from the one or more suggestion messages when displayed in the chat interface. In some embodiments, the one or more suggested response items are determined by at least one of the first embedded application, the messaging application, and/or a remote server in communication with the messaging application over a network.
In a further example, the first embedded application is a media player application that causes playback of video data to be displayed in an embedded interface, wherein the embedded interface is configured to receive input from a user that controls playback of the displayed video data, and wherein at least one of the one or more suggestion response items comprises one or more suggestion playback commands operable to adjust playback of the displayed video data. In a further example, the first embedded application is a gaming application that causes game data to be displayed in an embedded interface, wherein the embedded interface is configured to receive input from a user that changes one or more states of the gaming application, and wherein at least one of the one or more advice response items comprises one or more advice commands operable to modify the at least one state of the gaming application. In a further example, the first embedded application is a shared document application that causes a shared document to be displayed in an embedded interface, wherein the embedded interface is configured to receive input from a user that changes one or more items of the shared document, and wherein at least one of the one or more suggestion response items comprises one or more suggestion commands operable to modify the shared document.
In some embodiments, the embedded interface may be output on a subset of the plurality of user devices participating in the chat conversation, wherein the subset includes user devices that have received a second user input in the associated chat interface, the second user input causing the user devices to join the embedded session initiated by the first embedded application. The first embedded application may display output data generated by the first embedded application and/or received from a server connected to the first user device over a network.
In some embodiments, a system includes a memory and at least one processor configured to access the memory and configured to perform operations comprising: a chat interface is caused to be displayed by the first user device, wherein the chat interface is generated by the messaging application. The chat interface is configured to display one or more messages in the chat conversation, wherein the one or more messages are provided by a plurality of user devices participating in the chat conversation over the network. The operations include causing an embedded interface to be displayed in association with a chat interface, wherein the embedded interface is provided by a first embedded application running in association with a messaging application, and the first embedded application is at least partially running on a first user device. The operations include determining that the suggested event has occurred in association with use of the first embedded application based on at least one of: user input received by the embedded interface, and/or event information from the first embedded application indicating that a suggested event has occurred in the first embedded application. The operations include obtaining one or more suggested response items responsive to the suggested event, and causing the one or more suggested response items to be displayed by the first user device.
Various embodiments and examples of systems are described. For example, in some embodiments, one or more suggested response items may each be selectable by a first user of the first user device to cause the messaging application to provide an associated command to change one or more states of the first embedded application and/or to cause associated messages to be displayed in the chat conversation by a plurality of user devices participating in the chat conversation. In some embodiments, determining that the suggested event has occurred is based on determining that a second user device of the plurality of user devices has launched a second embedded application corresponding to the first embedded application to join an embedded session provided for the first embedded application.
In some embodiments, a non-transitory computer readable medium has stored thereon software instructions that, when executed by a processor, cause the processor to perform operations. The operations include determining that the suggestion event has occurred in association with use of at least one of a plurality of corresponding embedded applications running at least in part on the associated user device, wherein each embedded application is running in association with a messaging application running on the associated user device. Each message application is configured to cause an associated chat interface to be displayed by an associated user device, wherein the associated chat interface is configured to display one or more messages in a chat conversation and the associated user device participates in the chat conversation over a network. The operations include obtaining one or more suggested response items responsive to a suggested event; and causing display of one or more suggested response items by at least one of the associated user devices.
In some embodiments of the computer-readable medium, the one or more suggested response items may each be selectable by user input from a corresponding user of the at least one associated user device to provide an associated command to change one or more states of the plurality of respective embedded applications and/or to cause an associated message to be displayed in the chat conversation by the associated user device participating in the chat conversation. In some embodiments, the one or more states are one or more second states, and determining that the suggested event has occurred is based on at least one of: user input received by at least one of the respective embedded applications and/or user input received by at least one of the messaging applications that changes one or more first states of the respective embedded applications.
Drawings
FIG. 1 is a block diagram of an example system and network environment that may be used with one or more embodiments described herein;
FIG. 2 is a flow chart illustrating an example method for providing an application embedded in a chat conversation, in accordance with some embodiments of the application;
FIG. 3 is a flow chart illustrating an example method of enabling a user to join an embedded session according to some embodiments of the application;
FIG. 4 is a flowchart illustrating an example method by which a first device processes an event that a second device has joined an embedded session, according to some embodiments of the application;
FIG. 5 is a flowchart illustrating an example method of providing output of a media item using an embedded application associated with a messaging application, according to some embodiments of the application;
FIG. 6 is a flowchart illustrating another example method for providing output of an embedded application associated with a messaging application, according to some embodiments of the application;
FIG. 7 is a flowchart illustrating an example method for providing suggested response items associated with an embedded application in a chat conversation, in accordance with some embodiments of the application;
8A-8E are graphical representations of example user interfaces displayed by a user device, according to some embodiments of the application;
9A-9C are graphical representations of additional example user interfaces displayed by a user device, according to some embodiments of the application;
FIGS. 10A-10D are graphical representations of additional example user interfaces displayed by a user device, according to some embodiments of the application;
FIG. 11 is a schematic diagram of an example sequence including launching an embedded application and a user joining an embedded session; and
FIG. 12 is a block diagram of an example device that may be used in one or more embodiments described herein.
Detailed Description
One or more embodiments described herein relate to embedded programs and interfaces for chat conversations. In various embodiments, the first embedded application may be launched and displayed on the first user device by user input in a first chat interface provided by the first messaging application. The first chat interface is configured to receive user input from a first user and to display messages received from one or more other user devices participating in a chat conversation over a network and associated with respective chat users. Other user devices may connect to the embedded session associated with the embedded application, where users of the other devices are designated as member users.
For example, in some embodiments, a notification may be provided on other chat devices in the chat conversation indicating that the embedded session is active. Chat users of other chat devices may provide input to their user devices (e.g., select a join control displayed in the chat interface of their devices) to join their devices into an embedded session and become member devices. Chat identifications of chat users may be provided to and used in the embedded application.
The first embedded application may cause the embedded interface to be displayed by a user device associated with the chat interface, e.g., within or near the chat interface as part of the chat interface, etc. The embedded interface may receive user input from a user associated with the user device, for example, by selecting displayed interface elements, a keyboard, other input devices, etc., and provide the input to the first embedded application. The first embedded application may also be in communication with the first messaging application and the chat interface, for example, receiving data from the chat message and outputting the chat message displayed in the chat interface and/or the chat conversation. The first embedded application may communicate with other member devices that have joined the embedded session, e.g., through a first messaging application, where the other devices may be associated with respective embedded applications and messaging applications. The first embedded application may be in communication with the first messaging application and one or more servers in communication with the first messaging application. Indications of the occurrence of events in an embedded application or other connected device (e.g., server) may be displayed in a chat interface (e.g., in a chat conversation such that they are visible to chat users) and/or in an embedded interface.
Various types of embedded applications may be used, such as an embedded media player application that plays media items (video, images, audio clips, etc.), an embedded game application to output game data, an embedded application to output content documents (e.g., item lists, spreadsheets, etc.), an embedded application to create and output bookings or travel routes, and the like. In some embodiments, the embedded application may be downloaded and run on the first user device when the embedded application is selected to be launched in the chat interface. In some embodiments, the embedded application may be a standard, stand-alone application that may be configured or whose output is processed to provide the displayed output in an embedded manner, e.g., display the output in an embedded interface associated with the chat interface of the messaging application.
Various other features are described. For example, in some embodiments, the suggestion response items may be generated or obtained by a messaging application or an embedded application and displayed in a chat interface or an embedded interface. When selected by user input, some suggestion response items may provide one or more suggestion commands to an embedded application, a messaging application, or a first user device. When selected by user input, some of the suggestion response items can provide one or more suggestion messages to the chat interface, e.g., one or more suggestion messages to the chat conversation. The suggestion response items may be determined based on suggestion events occurring in the embedded application, the messaging application, and/or other connected devices, thereby providing the user with relevant suggestion input options.
In various embodiments, the features may include member users assigned respective user states (e.g., user roles) in the embedded session, e.g., control users for playback of media items, player roles or observer roles in the game, etc. In some examples, the embedded application may receive user comments in the embedded interface during a first playback of the media item and may display those user comments for chat users participating in the chat conversation at the first playback in the embedded interface during a second, later playback of the media item. The output data displayed by the embedded application may be synchronized between the member devices of a particular embedded session. For example, the adjusted playback position by user input on one member device causes the other member device to adjust the playback position in the associated embedded interface. A bots (bots) may be provided in the chat interface and may interface with the embedded application, e.g., launch the embedded application to process content items selected by user input, etc.
One or more features described herein enable a user to interact with an embedded application in an environment of chat conversations in which multiple user devices are engaged. In addition, multiple chat users may interact in an embedded application. Features allow chat users to share application functionality and output in a chat conversation without having to exit the chat interface to display an interface for a separate application. Thus, chat messages can be entered and displayed in the chat interface while simultaneously displaying output from the embedded application, which allows chat users to feel connected in simultaneous use of the application. These features allow for a grouped, shared expressed experience between chat users in an embedded session using an embedded application. In some examples, in an embedded conversation session where media items such as videos are played, features enable chat users to watch the videos together and comment on the videos in the chat conversation. If a first chat user is currently watching video, a second chat user in the conversation has the option to watch video with the first chat user, similar to sitting on a sofa with a similar physical environment to watch television. In such a sharing experience, both users may control playback, control a playlist of media items to view, talk about features and events in the video, and/or publish favorites to the video source.
Communication between the embedded application and the chat interface allows for attractive and efficient integration of chat and application functionality. For example, the embedded application may send an event or notification to the messaging application, and the messaging application may display the event or notification in a chat conversation and chat interface of the chat user so as to be visible to chat users that are not currently participating in the embedded session. This may increase the user's engagement, retention, and awareness of the occurrence of the embedded session and events in the embedded session. Similarly, chat messages entered into the chat interface and chat conversation may be entered into the embedded application, allowing the embedded application to respond to commands and messages from the chat interface and chat conversation.
With such embedded applications associated with the chat interface, chat users are allowed to interact with each other and with the embedded applications with reduced user input and reduced interaction time when using the chat interface and applications, thus reducing consumption of device resources that would otherwise be required to process, display and receive user input in an application separate from the messaging application. For example, the disclosed features reduce consumption of device resources required to enable and process communications between multiple users using chat interfaces and application functions simultaneously (e.g., reduce switching displays of different interfaces for different applications on a user device, reduce copying and pasting data displayed in one application to another application or interface, reduce repeated input of commands or data to an application, etc.). In addition, embedded applications can be seamlessly downloaded and installed on the user device based on selections within the chat interface, reducing system resources required to present additional download and installation interfaces. In addition, the embedded application may be of small data size, e.g., one or more functions of the associated messaging application, such as communication and network functions, chat interface functions, etc., may be used, and thus the functions themselves may be omitted. This allows particular application functions (e.g., playing media items, providing games or shared lists, etc.) to be implemented in smaller applications that consume less bandwidth and memory resources than each independently running application that includes a complete set of functions. In some embodiments, standard APIs may be used between the messaging application and the embedded application, allowing a wide variety of embedded applications to be provided by many different providers.
A technical effect of one or more of the described embodiments is thus to provide chat communications between user devices in a device-implemented conversation along with features from display and interaction of applications with less computing time and resources spent obtaining results. For example, a technical effect of the described techniques and features is that functionality is to reduce consumption of system processing resources for providing chat communications and application functionality as compared to systems that do not provide one or more of the described techniques and features, such as systems that use prior art techniques that display application output in a separate application that is not associated with chat interface communications, where additional computing resources are needed to run the separate application and to enable a user to switch between the application and chat conversation, to provide additional input to the application, and so forth. In another example, a technical effect of the described techniques and features is a reduction in consumption of system processing resources used by systems that do not provide one or more of the described techniques or features, e.g., systems that use only bots in a chat interface to provide application functionality and interactions with chat users, because such bots may present output in the chat interface that confuses multiple chat users participating in and providing messages in a chat conversation, resulting in inefficient use of system resources (e.g., repeated viewing, scrolling, and input of commands from users to display previously output messages, and output provided by the bots, etc.). Thus, the technical effect of the described techniques and features is a reduction in consumption of system processing resources for receiving input from multiple users, as compared to systems that do not provide one or more of the described techniques or features.
In some embodiments, the suggestion response items may be automatically provided in response to suggestion events occurring in an embedded application, messaging application, or other device. The advice response item is appropriate as a command or message and is related to the advice event. For example, suggesting a message item may cause an appropriate message to be displayed in a chat conversation as a response to a particular event occurring in an embedded application or other program (e.g., based on an event entered by a user from another user, or an event in the played content data) as if the user were creating the message. The advice command item may cause the advice related commands to be sent to the embedded application or other application/device in response to an event in the embedded application or other program, e.g., a command to alter media playback in response to detecting a feature in a media item being played, a command to execute a game action in response to detecting an opponent's action in a game, etc. These suggested items provide users with more flexible options in determining their response to an event in the application, and may provide options for users who are unable to adequately respond to an event in the application. For example, at various times during a message conversation, a user may not be able to provide sufficient attention and/or concentration to respond to an event with an associated command or message, and/or may not be able to provide detailed user input to a user device to create such an associated command or message. In some examples, the user may be engaged in an activity or in an environment where it is not possible or more difficult for the user to provide an appropriate response.
One or more features described herein advantageously provide a user with an automatically selectable suggested response item message in response to a particular event in an embedded application or messaging application. The suggested response item is related to an event detected on the device. Selecting such suggested items allows a user to simply and quickly respond to events to compose a response on a device with reduced user input and reduced time, thereby reducing the consumption of device resources required to display a large number of possible responses and/or reducing the consumption of device resources required to implement and process additional input from the user to compose a response, search, edit or complete a response, and/or otherwise participate in a conversation held by an electronic device. A technical effect of one or more of the described embodiments is thus to enable creation and transmission of responses in a device-implemented dialog with less computational time and resources spent obtaining results. For example, the described techniques and features have the technical effect of reducing the consumption of system processing resources for displaying, creating and sending message responses and command responses as compared to systems that do not provide one or more of the described techniques and features, e.g., systems using prior art systems in which additional computing resources are required to receive input from a user for specifying, selecting, editing or creating responses to be transmitted by the user.
The described techniques provide additional advantages. In some examples, user status or roles may be effectively automatically assigned based on information passed between the messaging application and the embedded application without receiving additional user input. In some examples, user commands and comments may be sent to the server and server events may be received and presented by an embedded application on the user device without the user having to access the server by exiting the chat interface and running a separate application on the user device. The bot may be used in conjunction with an embedded application, for example, to search for content items to be played by the embedded application without the user spending system resources performing manual searches, selecting, and launching the application. In other examples, user comments associated with content items previously played in the embedded application that were previously entered by the user may be stored. If playback occurs in the same chat conversation (or chat user group), the stored comment may be displayed in association with playback of the later content item, thereby freeing the chat user from reentering comments during the later playback and reducing the cost of system resources. Synchronization techniques allow playback of content items on user devices of an embedded session to be automatically synchronized and able to accept input from multiple users. These techniques allow chat users to share experiences in a chat conversation without requiring the users to use additional system resources to run separate applications or manually indicate playback positions to each other.
Some embodiments discussed herein may provide one or more opportunities for a user to control whether to collect information, store personal information, use personal information, and how to collect, store, and use information about the user in situations where personal information about the user may be collected or used (e.g., user data, information about the user's social network, user location and time of the user at the location, user biometric information, user activity, and demographic information). That is, the systems and methods discussed herein collect, store, and/or use personal information of a user, particularly upon receipt of explicit authorization from an associated user. For example, a user is provided with control over whether a program or feature gathers user information about that particular user or other users associated with the program or feature. Each user whose personal information is to be collected is presented with one or more options to allow control of the collection of information related to that user to provide permissions or authorizations as to whether information is to be collected and as to which portions of the information are to be collected. For example, one or more such control options may be provided to the user over a communications network. In addition, certain data may be processed in one or more ways prior to storage or use to remove personally identifiable information. As one example, the identity of the user may be processed such that personally identifiable information cannot be determined. As another example, the geographic location of a user may be generalized to a larger region such that the particular location of the user cannot be determined.
An image as referred to herein is a digital image having pixels with one or more pixel values (e.g., color values, luminance values, etc.). The image may be a still image or a single image, or may be an image comprised in a series of images, such as frames in a video sequence of video frames, or images in a different type of image sequence or image animation. The video includes a sequence of multiple images. For example, the embodiments described herein may be used with single images or still images (e.g., photographs, emoticons, or other images), video or animated images (e.g., movies or other animated images including motion, decals (sticker) including animation and audio, etc.). The text referred to herein may include alphanumeric characters, emoticons, symbols, or other characters.
FIG. 1 illustrates a block diagram of an example environment 100 for providing messaging services implementing an embedded application as described herein. In some embodiments, an automatic assistance agent, such as a robot program, may be provided. The exemplary environment 100 includes a message server 101, one or more client devices 115a, 115n, a server 135, an embedded application server 150, a session server 152, a content server 154, a suggestion server 156, and a network 140. The users 125a-125n can be associated with respective client devices 115a, 115 n. The server 135 may be a third party server, for example, controlled by a party other than the party providing the message service. In various embodiments, server 135 may implement a bot service as described in further detail below. In some embodiments, environment 100 may not include one or more servers or devices shown in fig. 1, or may include other servers or devices not shown in fig. 1. In fig. 1 and the remaining figures, letters following a reference numeral, such as "115a", denote references to elements having that particular reference numeral. Reference numerals in the text that do not have subsequent letters, such as "115", represent general references to the implementation of elements with such reference numerals.
In the illustrated embodiment, message server 101, client device 115, server 135, and servers 150-156 are communicatively coupled via network 140. In various embodiments, network 140 may be of a conventional type, wired or wireless, and may have many different configurations, including a star configuration, a token ring configuration, or other configurations. Further, network 140 may include a local area network (Local Area Network, LAN), a wide area network (Wide Area Network, WAN) (e.g., the internet), and/or other interconnecting data paths through which multiple devices may communicate. In some embodiments, network 140 may be a peer-to-peer network between user devices and/or between other devices, e.g., using peer-to-peer data exchange techniques to enable offline communication (and use of embedded applications as described below). The network communications may include websockets that allow for communication of bi-directional, full duplex messages between devices, such as client (user) devices and servers, using an appropriate communication protocol. The network 140 may also be coupled to or comprise a portion of a telecommunications network for transmitting data in a variety of different communication protocols. In some embodiments, network 140 includes a network for sending and receiving data via Short message service (Short MESSAGING SERVICE, SMS), multimedia message service (Multimedia MESSAGING SERVICE, MMS), hypertext transfer protocol (Hypertext Transfer Protocol, HTTP), direct data connection, email, and the likeCommunication network,/>Or a cellular communication network. In other examples, sound waves may be used in network 140 for data and status exchange between devices. Although FIG. 1 shows one network 140 coupled to client device 115, message server 101, server 135, and servers 150-156, in practice one or more networks 140 may be coupled to these entities.
Message server 101 may include a processor, memory, and network communication capabilities. In some embodiments, message server 101 is a hardware server. In some embodiments, message server 101 may be embedded in a virtualized environment, for example, message server 101 may be a virtual machine running on a hardware server that may include one or more other virtual machines. Message server 101 is communicatively coupled to network 140 via signal line 102. The signal line 102 may be a wired connection, such as Ethernet, coaxial cable, fiber optic cable, etc., or a wireless connection, such as Wi-Fi, bluetooth, or other wireless technology. In some embodiments, message server 101 sends data to and receives data from one or more of client devices 115a-115n, server 135, one or more of servers 150-156, and bot 113 over network 140. In some embodiments, the message server 101 may include a message application 103a that provides client functionality to enable a user (e.g., any of the users 125) to exchange messages with other users and/or with a bot. The messaging application 103a may be a server application, a server module of a client-server application, or a distributed application (e.g., with corresponding client messaging application 103b on one or more client devices 115).
The message server 101 may also include a database 199 that may store messages exchanged via the message server 101, group data indicating, for example, which users are in which message groups (e.g., chat conversations) and which content data (video data, images, audio data with group preferences, game data, content documents, etc.) are associated with which message groups, data and/or configuration of one or more bots, information provided by the content classifier 130, and user data associated with one or more users 125, all explicit permissions from the respective users to store such data. In some embodiments, message server 101 may include one or more auxiliary agents, such as bots 107a and 111. In other embodiments, the secondary agent may be implemented on the client devices 115a-n and not on the message server 101.
In some embodiments, message server 101, message application 103, and/or an embedded application running in association with the message application may provide messages in one message group (e.g., chat conversation), and/or may send messages to one or more other message groups (chat conversations) implemented by message server 101 (or other message servers).
Message application 103a may be code and routines operable by a processor to enable message exchange between user 125 and one or more bots 105, 107a, 107b, 109a, 109b, 111, and 113. In some embodiments, the message Application 103a may be implemented using hardware including a Field-programmable gate array (Field-programmable GATE ARRAY, FPGA) or an Application-SPECIFIC INTEGRATED Circuit (ASIC). In some embodiments, messaging application 103a may be implemented using a combination of hardware and software.
In various embodiments, database 199 may store messages exchanged between one or more client devices 115 when respective users associated with client devices 115 provide consent to message storage. In some embodiments, database 199 may store messages exchanged between one or more client devices 115 and one or more bots implemented on different devices, e.g., other client devices, message server 101 and server 135, etc., when respective users associated with client devices 115 provide consent to storing the messages. In embodiments where one or more users do not provide permission, then messages received and sent by those users are not stored.
In some embodiments, the message may be encrypted, for example, so that only the sender and recipient of the message may view the encrypted message. Some embodiments may store encrypted data generated from a user, e.g., user-generated content data such as messages, comments, recorded user actions, etc. The user-generated content data may be encrypted locally on the user device (e.g., in the local run of the embedded application) and the server system (e.g., for messages transmitted for the shared embedded application and embedded session). In some embodiments, the message is stored. In some embodiments, database 199 may further store data and/or configuration of one or more robot programs (e.g., robot program 107a, robot program 111, etc.). In some embodiments, when a user 125 provides consent for storing user data (e.g., social network data, contact information, images, etc.), database 199 may also store user data associated with the corresponding user 125 that provided the consent.
In some embodiments, message server 101 and message application 103 may be implemented on one or more chat devices (e.g., user devices) participating in a chat conversation as described herein.
In some embodiments, the messaging application 103a/103b may provide a user interface that enables the user 125 to create a new bot. In these embodiments, the messaging application 103a/103b may include functionality that enables user-created bots to be included in chat conversations between users of the messaging application 103a/103 b.
Servers 150-156 may include one or more processors, memory, and network communication capabilities. In some embodiments, the server is a hardware server. Signal lines 160, 162, 164, and 166 connect servers 150, 152, 154, and 156, respectively, to network 140, and may be wired connections, such as ethernet, coaxial cable, fiber optic cable, etc., or wireless connections, such as Wi-Fi, bluetooth, or other wireless technology. In some embodiments, servers 150-156 send data to and receive data from one or more of message server 101 and client devices 115a-115n via network 140. Although servers 150-156 are shown as separate servers, one or more of servers 150-156 could be combined and/or included in one or more other components of environment 100, such as message server 101, client device 115a, server 135, etc. Any or all of servers 150-156 may be managed by the same party managing message server 101, or may be managed by a third party. In some embodiments, when a server communicates with a particular device over network 140, servers 101, 135, and 150-156 may be considered remote servers with respect to the particular device. Similarly, in some embodiments, if communicating with a particular device over network 140, client device 115 may be considered to be remote from the particular device. In various embodiments, the functionality of any of servers 101, 135, and 150-156 may be implemented on one or more client devices 115.
The embedded application server 150 is communicatively coupled to the network 140 via a signal line 160 and serves the embedded application as described herein, which is requested by the device to be installed on the device. For example, the user device may request that the embedded application be downloaded as a background process of the operating system or messaging application, and the embedded application server 150 sends data to the client device to run the embedded application on the client device. In some embodiments, the embedded application server 150 may run the embedded application in whole or in part, and may send output data from the embedded application to the client device for display by one or more client devices.
Session server 152 is communicatively coupled to network 140 via signal line 162 and may be used in some embodiments to process and coordinate data sent to/from a plurality of client devices participating in an embedded session that connects a plurality of embedded applications (e.g., shared embedded applications) running on client devices connected to network 140. For example, session server 152 may be used to manage embedded sessions, including, for example, one or more of the following: synchronizing the state of the embedded applications in the embedded session, determining and distributing events on the corresponding embedded applications running on the session server, etc. In some embodiments, the session server may determine one or more events of the embedded session, one or more of which may occur on the session server or on other servers in communication with the session server. For example, the event may include the server receiving user selections, comments, or ratings associated with content items that the server serves to the user device, and these content items may be played in the embedded session so that the event may be communicated to the embedded session. In some embodiments, session server 152 may be included in message server 101 or other servers of environment 100 or the same as message server 101 or other servers of environment 100.
The content server 154 is communicatively coupled to the network 140 via a signal line 164 and may be used to transmit content data to one or more devices connected to the network 140. For example, the content data may be data provided for output by an embedded application that displays an embedded interface on a client device as described herein. The content data may include video data, image data, audio data, document data, web page data, game data, bot data or information, map data or other geographic information, and the like. The content data may be included in different content items (media items), e.g., video or movies, images, games, documents, web pages, etc.
Suggestion server 156 is communicatively coupled to network 140 via signal line 166 and may be used to determine and provide suggestion response items to reply to messaging applications and/or embedded applications for display and user selection at the client device. For example, a messaging application running at the client device 115 may send descriptive information to the suggestion server 156, and in response to the descriptive information, the suggestion server 156 may query a database, knowledge graph, and/or other data resource to determine one or more suggestion response items (also referred to herein as "suggestion items," "suggestion input items," or "suggestion input items"). As described with reference to fig. 7, these suggested items may be suggested commands and suggested messages. In some embodiments, the functionality of suggestion server 156 may be included in a messaging application and/or an embedded application.
In some embodiments, suggestion server 156 and/or other components of environment 100 may use machine learning, e.g., using a machine learning model that utilizes machine learning to determine suggested items. For example, in a training phase, a suggestion server (or other component) may be trained using training data (e.g., message training data) for actual or generated messages in a message application context (context), and then suggestion items for new messages or other data that it receives may be determined in an inference phase. For example, the machine learning model may be trained using synthetic data, which is data automatically generated by a computer, for example, without using user information. In some embodiments, the machine learning model may be trained based on sample data (e.g., sample message data) for which permissions to train using the user data have been explicitly obtained from the user providing the message data. For example, the sample data may include a received message and a transmitted response to the received message. Based on the sample data, the model may predict a message response to the received message, which may then be provided as a suggested item. In some embodiments, suggestion server 156 (or other component) may use one or more of a deep learning model, a logistic regression model, a long term short term memory (Long Short Term Memory, LSTM) network, a supervised or unsupervised model, or the like. Some embodiments may also detect image features in an image or video and determine suggested items (e.g., message responses) based on the image features. For example, image features may include people (without determining the identity of a person), animals, objects (e.g., articles, vehicles, etc.), specific monuments, landscape features (e.g., foliage, mountains, lakes, sky, clouds, sunrise or sunset, buildings, bridges, etc.), weather, and the like. Image features may be detected using various image recognition and detection techniques (e.g., machine learning based on training images, comparison with reference features in reference images, etc.).
In some embodiments, one or more of servers 150-156 hosts a robot program. The bot may be a computer program that performs certain functions to provide advice, such as booking the bot, automatically replying to the bot to generate reply message text, scheduling the bot to automatically schedule calendars, etc. Servers 150-156 may provide or reference one or more bots as their outputs to messaging application 103. For example, the code of the robot program may be incorporated into the messaging application 103, or the messaging application 103 may send the request to the robot program implemented at the servers 150-156. In some embodiments, message application 103 may act as an intermediary between user 125 and servers 150-156 by providing bot commands to servers 150-156 and receiving output (e.g., embedded application data, session data, content data, suggested items, etc.) based on the bot commands.
In some embodiments, one or more of the servers 150-156 (e.g., the content server 154 and/or the suggestion server 156) may maintain an electronic encyclopedia, a knowledge graph, one or more databases, social networking applications (e.g., social graph, dating social network, business social network, etc.), websites of places or locations (e.g., restaurants, auto dealers, etc.), map applications (e.g., websites for providing directions), and the like. For example, content server 154 may receive a request for information from messaging application 103, perform a search, and provide the information in the request. In some embodiments, content server 154 may include a classifier of a particular type of content in an image and may determine whether any particular class is detected in the content (e.g., pixels) of the image. In some examples, the message application 103 may request driving directions or estimated times of arrival from a map application accessed by the content server 154.
In some embodiments, if the user agrees to use such data, one or more of the servers 150-156 (e.g., content server 154) may provide profile information or profile images of the user to the messaging application 103, which the messaging application 103 may use to identify people in the images that have corresponding social network profiles. In another example, if user consent to the provided user data has been obtained, the content server 154 may provide information to the message application 103 regarding the entities identified in the messages used by the message application 10. For example, the content server 154 may include or access an electronic encyclopedia that provides information about landmarks identified in the image, an electronic shopping website that provides information for purchasing entities identified in the message, an electronic calendar application that provides travel from users identified in the message with user consent, a map application that provides location information about nearby entities in the accessible message, a website for restaurants that provide dishes mentioned in the message, and so forth. In some embodiments, the content server 154 may communicate with the suggestion server 156 to obtain information. The content server 154 may provide the requested information to the suggestion server 156.
In some embodiments, one or more servers 150-156 may receive information from one or more messaging applications 103, e.g., to update databases used or maintained by these modules. For example, where content server 154 maintains a website about a restaurant, message application 103 may provide content server 154 with updated information about the restaurant, such as a favorite dish of the user at the restaurant.
Server 135 may include a processor, memory, and network communication capabilities. In some embodiments, server 135 is a hardware server. Server 135 is communicatively coupled to network 140 via signal line 128. The signal line 128 may be a wired connection, such as Ethernet, coaxial cable, fiber optic cable, etc., or a wireless connection, such as Wi-Fi, bluetooth, or other wireless technology. In some embodiments, server 135 transmits data to and receives data from one or more of message server 101 and client device 115 via network 140. Although server 135 is shown as one server, various embodiments may include one or more servers 135. The server 135 may implement one or more robot programs (e.g., robot program 109a and robot program 113) as server applications or server modules.
In various embodiments, server 135 may be part of the same entity that manages message server 101, e.g., a provider of a message service. In some embodiments, the server 135 may be a third party server, e.g., may be controlled by an entity different from the entity providing the messaging application 103a/103 b.
In some embodiments, server 135 provides or hosts the robot program. The bot is an automated service implemented on one or more computers, with the user interacting primarily through text, e.g., via messaging applications 103a/103 b. The robot program is described in more detail below.
The client device 115 may be a computing device including memory and a hardware processor, such as a camera, notebook computer, tablet computer, mobile phone, wearable device, mobile email device, portable game player, portable music player, reader device, head mounted display, or other electronic device capable of wireless access to the network 140.
In the illustrated embodiment, client device 115a is coupled to network 140 via signal line 108 and client device 115n is coupled to network 140 via signal line 110. The signal lines 108 and 110 may be wired connections, such as Ethernet, or wireless connections, such as Wi-Fi, bluetooth, or other wireless technologies. The client devices 115a, 115n are accessed by users 125a, 125n, respectively. As an example, the client devices 115a, 115n in fig. 1 are used. Although fig. 1 shows two client devices 115a and 115n, the present disclosure is also applicable to a system architecture having one or more client devices 115.
In some embodiments, the client device 115 may be a wearable device worn by the user 125. For example, the client device 115 may be included as part of a clip (e.g., a wristband), part of jewelry, or part of a pair of eyeglasses. In another example, the client device 115 may be a smart watch. In various embodiments, the user 125 may view the message from the message application 103a/103b on a display of the device, may access the message via a speaker of the device or other output device, etc. For example, the user 125 may view the message on a display of a smart watch or smart bracelet. In another example, the user 125 may access the message via headphones (not shown) coupled to the client device 115 or a portion of the client device 115, speakers of the client device 115, haptic feedback elements of the client device 115, and the like.
In some embodiments, the message application 103b is stored on the client device 115 a. In some embodiments, the message application 103b (e.g., thin client application, client module, etc.) may be a client application stored on the client device 115a with a corresponding message application 103a (e.g., server application, server module, etc.) stored on the message server 101. For example, the message application 103b may transmit a message created by the user 125a on the client device 115a to the message application 103a stored on the message server 101.
In some embodiments, the message application 103a may be a stand-alone application stored on the message server 101. The user 125a may access the messaging application 103a via a web page using a browser or other software on the client device 115 a. In some embodiments, the messaging application 103b implemented on the client device 115a may include the same or similar modules as included on the messaging server 101. In some embodiments, the messaging application 103b may be implemented as a stand-alone client application, for example, in a peer-to-peer or other configuration in which one or more client devices 115 include functionality to effect exchange of messages with other client devices 115. In these embodiments, message server 101 may include limited or no message functionality (e.g., client authentication, backup, etc.). In some embodiments, message server 101 may implement one or more robot programs, e.g., robot program 107a and robot program 111.
In various embodiments, the message application 103 may include one or more embedded applications 117 associated with the message application 103 and running in dependence upon the message application 103. The embedded application 117 may interact with the chat interface of the messaging application and provide one or more self embedded interfaces. Examples of various features of embedded applications are described herein.
In some embodiments, the message application 103a/103b may provide one or more suggestion items, such as suggestion commands, messages, or responses, to the user 125 via a user interface (e.g., as buttons or other user interface elements). The suggested items may enable the user to quickly respond to the message when the user selects the suggested items, for example, by selecting the corresponding user interface element on a touch screen or through other input device. Suggesting items may enable faster interactions, for example, by reducing or eliminating the need for a user to enter a response. The suggested items may enable a user to quickly and easily respond to a message or provide a command, for example, when the client device lacks text input functionality (e.g., a smart watch that does not include a keyboard or microphone). In some embodiments, the suggested responses may be generated using a predictive model, such as a machine learning model trained to generate responses. The suggested items are described in more detail below with reference to fig. 7.
Fig. 2 is a flow chart illustrating an example method 200 for providing a program embedded in a chat conversation, in accordance with some embodiments. In some embodiments, for example, the method 200 may be implemented on, for example, a server system (e.g., the message server 101 shown in fig. 1). In some embodiments, some or all of the method 200 may be implemented on a system, such as one or more client devices 115 as shown in fig. 1, and/or on both a server system and one or more client systems. In the described examples, the implementation system includes one or more processors or processing circuits, and one or more storage devices, such as a database or other accessible storage. In some embodiments, different components of one or more servers and/or clients may perform different blocks or other portions of method 200.
In block 202, it is checked whether user consent (e.g., user permissions) has been obtained to use the user data in the implementation of method 200. For example, the user data may include messages sent or received by the user, e.g., using the messaging application 103, user preferences, user biometric information, user characteristics (identification, name, age, gender, occupation, etc.), information about the user's social network and contacts, social and other types of actions and activities, content, ratings, and opinion created or submitted by the user, the user's current location, historical user data, images generated, received and/or accessed by the user, videos viewed or shared by the user, and so forth. In some embodiments, one or more blocks of the methods described herein may use such user data.
If user consent has been obtained from the relevant user whose user data is available for use in method 200, then in block 204, the blocks of determining the method herein may be implemented with possible use of the user data, as described for those blocks, and the method continues to block 208. If user consent has not been obtained, then in block 206 it is determined that the block will be implemented without using user data, and the method continues to block 208. In some embodiments, if user permissions have not been obtained, the block is implemented without using user data and with synthetic data and/or data that is commonly or publicly accessible and available.
Embodiments described herein may provide an embedded application that runs in association with a messaging application that provides chat conversations in a chat interface. The messaging application may be messaging application 103 as described above and may run wholly or partially on a user device (e.g., a client device or other device) or may run wholly or partially on a server (e.g., messaging server 101) and provide data to the user device for display on the user device.
In some examples, the message application 103 may be an instant messaging application, a social networking application, an email application, a multimedia messaging application, or the like. For example, if the messaging application is an instant messaging application, the message may be received as part of an instant messaging communication between a particular user 125a and one or more other users 125 of the participating devices, e.g., in a messaging session (e.g., chat, group, or chat conversation) with two or more participants, etc. Chat or chat conversations are message sessions in which a plurality of participating users communicate messages (e.g., including various types of content data) with one another. In some embodiments, a user may send a message to other users by entering the message into a chat conversation implemented by a messaging application. In some embodiments, a user may send a message to a particular other user by sending a telephone number (e.g., when the messaging application 103 is operating via SMS, or another messaging application that utilizes a telephone number) or selecting a receiving user from a contact list (e.g., when the messaging application 103 is operating via rich communication service (Rich Communications Services, RCS) or another chat interface). In some embodiments, the messaging application 103 may provide real-time communications between participating devices, such as audio (voice) calls and/or video calls, where real-time audio data and/or video data is captured at one or more of the participating devices (e.g., using a camera and microphone) and sent to and output on chat interfaces (and speakers) of other devices participating in a chat conversation (e.g., a teleconference).
The messaging application 103 may display a chat interface that displays messages for chat conversations, e.g., messages sent by users of user devices, as well as messages received by user devices from other devices. As referred to herein, a chat interface has a displayed user interface component (e.g., including displayed interface elements) and has a data receiving and exchanging component that performs the receipt, sending and receiving of user input, displaying of messages, and the like.
In the embodiments described herein, one or more embedded applications may be run in association with a messaging application. An embedded application here refers to a message embedded or chat embedded program, e.g. a program that runs in association with or in the context of a running message application and that depends on the running message application. For example, if the messaging application is providing output (e.g., a chat interface) on the device, the embedded application is code (e.g., script) that can run on the device, and if the messaging application exits and no longer provides output on the device, the embedded application exits (e.g., no longer runs on the device). For example, in some embodiments, the embedded application may receive input provided to or in the embedded interface, e.g., selection of a user interface element, text, or other display object in the embedded interface, a gesture of an input device (such as a tap, a depiction of a shape, a curve, or a line, etc. on a touch-sensitive input surface of a touch screen, touchpad, etc.), and/or other user input received by the embedded interface via the touch screen or other input device. As referred to herein, an embedded interface includes displayed components, which may include user interface components (e.g., displayed user interface elements), displayed output data including content data, such as media item content data, game data, document data, user comments, messages, and the like. The embedded interface also includes a data receiving component that performs the receipt of user input at the user device, e.g., via a touch screen, keyboard, or other input device of the user. In some embodiments, the embedded interface is displayed in association with a chat interface. For example, the embedded interface may be displayed as part of the chat interface, e.g., within a border or display area of the chat interface, partially overlaying the chat interface, or adjacent to the chat interface. In some embodiments, at least a portion of the chat interface is visible and the embedded interface is visible on the display.
In some embodiments, the embedded application may receive input provided in an associated chat interface in an associated chat conversation, for example, as a selection of a text command or chat interface element. In some embodiments, the embedded application provides output in an embedded interface and/or may provide output in a chat interface, for example, providing output as text to a chat conversation displayed in the chat interface or providing other chat interface output. For example, the output of the embedded application to the embedded interface may be referred to as embedded output data and may include data generated by the embedded application and/or data received by the embedded application from one or more other sources (e.g., the sources include different applications running on the first device, one or more servers connected over a network, one or more chat devices in a chat conversation of the associated message application, etc.) via the associated message application. Data sent from the embedded application to other applications and/or other devices may be provided from the embedded application to the messaging application, which then passes the data (or processed data form) to other programs or devices. Similarly, data received at the user device from other programs or devices to be provided to the embedded application running for the user device may be received by the messaging application and provided from the messaging application to the embedded application.
Some examples of embedded applications are described throughout the specification. In some example embodiments, the embedded application may be code that runs within a sandbox display process to display application data and the embedded interface, for example, within a display area of the chat interface or with other visual association with the chat interface. For example, in some embodiments, the embedded application may implement a web interface view to provide an embedded interface within the chat interface, where the view may display data from the web page and/or implement code running in connection with the web page (Javascript, CSS, HTML, etc.). In some embodiments, the embedded application may be provided by a third party, e.g., a party other than the party providing the associated messaging application and/or other components in communication with the embedded application. In some embodiments, buffering may be provided when switching from the display of one embedded application to a different embedded application (e.g., double buffering techniques). For example, when a first embedded (or other) application and embedded interface are displayed and used in the foreground, the embedded application code and/or output data of a second embedded application, not shown, may be downloaded, installed and/or loaded into memory for display in the background of the device's operating system. The displayed first embedded interface may be exchanged with the second embedded interface through the displayed animation and user interface switching. In some examples, the load indicator may be displayed when the code is downloaded in the background and/or installed on the user device when the embedded application is being downloaded.
In some examples, the embedded application may communicate and interface with a framework implemented by the messaging application using an application program interface (Application Program Interface, API) that provides a set of predefined protocols and other tools that enable communication. For example, an API may be used to communicate specific data from devices (e.g., member devices) participating in an embedded session, where the data connects and synchronizes embedded applications (e.g., shared embedded applications) of the embedded devices. In some embodiments, the messaging application framework may provide a set of APIs to provide embedded application developers with the ability to enable interactions between chat conversations, devices, embedded sessions, and embedded applications.
In some example embodiments, if a member user exits an embedded application, the embedded application may remain running in the background of the member user's member device (e.g., in the background of the member device's messaging application or operating system) for a period of time (e.g., 20 seconds, 1 minute, etc.). This may be performed, for example, in the case of a user switching back to using the embedded application shortly after interacting with the chat interface. In some examples, a user may open an embedded gaming application, move to a game input, close the embedded gaming application and embedded interface (such that they run in the background), send or attach a file to a chat conversation in response to another user's request, and immediately re-open the embedded gaming application and embedded interface to switch them to the foreground. If the chat session ends, for example, if the user closes the messaging application, or in some embodiments, the user switches to a different chat session, the embedded application running in the background may be terminated. Similarly, if the user closes or exits the messaging application, the messaging application may be sent to the background of the user device for a particular period of time and the active embedded application may be suspended during this period. The user may switch to use another application and then resume use of the embedded application when the messaging application is selected to run in the foreground. Thus, the embedded application may be tied to the life cycle of the chat conversation.
In various embodiments, one or more users may be a bot. For example, in some embodiments, the chat user or member user referred to herein may be a bot. In this case, the "user device" associated with the "chat user" (bot) may be a server device providing the bot. In some examples, the robot program may be an auxiliary robot program, a shopping robot program, a search robot program, or the like. In some embodiments, the robot may be an automated agent implemented in software and/or hardware. In some embodiments, the robot may represent or associate a camera (e.g., security camera, webcam, surveillance camera, etc.), an appliance (e.g., smart refrigerator, alarm device, industrial device, etc.), an imaging device (e.g., microscope, medical imaging device, etc.), and send one or more images through the messaging application 103. In an embodiment comprising one or more users as the robot program, consent is obtained from the owner or operator of the robot program to the message generated using the robot program. In some embodiments, the consent may be specified as a configuration parameter for the bot, camera, appliance, etc., and provided to the messaging application 103 when the bot interacts with the messaging application 103.
In block 208, the first message application is caused to display a first chat interface on the first user device. The chat interface is a user interface configured to receive information and output information related to one or more chat conversations that the first device may participate in. For example, in response to user input from a first user using or otherwise associated with the first device or other input, a chat interface may be displayed on a display device of the first device, such as a display screen. In some embodiments, the first message application runs on the first device, while in other embodiments, the first message application may run partially or entirely on a different device (e.g., a message server) connected to the first device via a network, and may send data to the first device for display by the first device.
The first user and the first device may join one or more chat conversations using the chat interface. For example, user input from a user of a first device may initiate a new chat conversation with one or more other users using the user device and/or join an existing chat conversation with one or more other users and devices via a network. Each chat session includes a set of chat users (and their associated user devices) that participate in that particular chat session. In some embodiments, a user may simultaneously engage in multiple different chat conversations. In some embodiments, each chat user is associated with a respective chat identification in the chat conversation. Chat identification may refer to a visual representation of a user in a chat interface (e.g., depiction of a user's head, user name, user picture, etc.). Chat identifications include text, images, or multimedia data (e.g., user photos, user icons, user names, animations depicting chat users, etc.) that effectively depict chat users. Chat identification may also or alternatively refer to a user identifier (e.g., identification (ID) data, ID number, etc.). The chat identification includes a unique identifier of the chat user in the context of the messaging application. For example, the unique identifier may be a user name. In another example, the unique identifier may be an identifier of a database of chat users (e.g., a primary key of a database table storing user identifications). In providing chat identifications to embedded applications, a database identifier or user name may be provided.
In some embodiments, a chat conversation may be considered a chat group of users, and may have persistent presence, whether or not its users are currently participating in the chat conversation, or whether or not they are currently logged in or using the user device. For example, if all chat users exit a chat conversation, the messaging application may store a conversation Identifier (ID) of the chat conversation along with the chat identification and user identification, and may resume the chat conversation when one or more chat users log in or resume the conversation using the chat interface. Some embodiments of a messaging application may assign and store a conversation ID that identifies a particular chat conversation, and store an identification of an associated current chat user (and/or chat device) in association with the conversation ID. In some embodiments, new users may be added to the chat conversation and one or more users may be removed from the chat conversation.
The chat interface may display information for each chat conversation in which the first user is engaged, including messages received by the first device from other chat devices and chat users engaged in the chat conversation, as well as information related to chat user status, options for message functions, events occurring in the chat conversation, and so forth. The chat interface may include interface features that allow a user of or associated with the first device (e.g., the first user) to provide user input, including interface elements that implement such features. For example, a user may compose a message on a first device and enter the message into a chat conversation. In some examples, the user may provide user input to the chat interface via a touch screen, physical buttons or keyboard, voice input, or other types of input.
In block 210, input is received by a first device that selects a first embedded application to launch (e.g., open or execute the embedded application on the first device) and share with a chat user. The input may be user input received locally at the first device from the first user. In some examples, a menu or other set of options listing available embedded applications may be displayed (or otherwise presented or output) by the first device, and the user input may select the first embedded application from the options. The first embedded application is associated with a particular chat conversation currently active in the messaging application. For example, in some embodiments, one or more options to select and open a first embedded application may be displayed or otherwise implemented in a chat interface that displays a particular chat conversation, and selection of such options causes the first embedded application to run in association with the chat conversation. In some additional examples, the user input may include one or more text commands entered in the chat interface, just as a portion of a composed message, where the text commands are received as commands to select the first embedded application to launch. In some examples, text beginning with a particular grammatical character or other predefined format may indicate such a command.
In some embodiments, the input selecting the first embedded application to open may also specify that the first embedded application is to be shared with one or more other chat users and user devices participating in the associated chat conversation. The sharing selection allows for creation of an embedded session between the first device and one or more other devices running a local version of the embedded application and participating in the chat conversation (see block 214 below). In some embodiments, the first embedded application may alternatively be selected to be open and not shared with other chat users, which would result in the first embedded application being run without the embedded session being initiated and without the other device receiving data related to the first embedded application. In some embodiments, the selection to launch the embedded application results in the shared embedded session being launched automatically (or based on stored user preference data). In some embodiments, the embedded application (e.g., in an embedded interface as in block 212 below) does not output a display until at least one other chat user has joined an embedded session associated with the first embedded application.
In block 212, the first embedded application is downloaded over a network and/or run on the first device and the embedded interface is displayed in association with the chat interface. For example, the first embedded application may be downloaded in response to the selection received in block 210. In some embodiments, the first embedded application may be downloaded from a server system hosting the embedded application (e.g., embedded application server 150). In some embodiments, the downloading of the first embedded application may occur in the background of the operating environment of the first device, for example, as a background process of the message application and/or the operating system of the first device. This allows programs and features (e.g., chat interfaces of message applications) to run on the first device, provide output, and/or be used by the first user during download. After (and/or during) the download of the first embedded application, it may be run by the first device. In some embodiments, after the first embedded application has been downloaded, it may remain stored in the local non-volatile memory of the first user device so that upon subsequent startup of the first embedded application, it may be retrieved from the local memory rather than downloaded (e.g., unless the first embedded application has an update available). In some embodiments, one or more portions or components of the first embedded application may be run by one or more other devices (e.g., one or more server systems) in communication with the first device. The embedded application code may be provided (e.g., transmitted) exclusively to those devices of the user who have granted the system access to the user data. In some embodiments, because the embedded application is downloaded at startup, region and/or time sensitive embedded applications may be provided from the embedded application server in a particular download, e.g., dedicated to the current holiday or calendar event, geographic region, etc. Access to the specialized embedded application may be restricted based on the particular geographic region, language, and/or other characteristics or limitations of the user device and the user receiving the download.
In some embodiments, the first embedded application causes the embedded interface to be displayed by the first device. The embedded interface is a user interface of the embedded application that allows user input to be received in the embedded interface to be provided to the first embedded application and allows output from the first embedded application to be displayed by the first device. In some embodiments, information from the first embedded application and to be output to other devices over the network may be provided from the embedded application to the messaging application, and the messaging application may send information from the first device to the other devices over the network.
In some examples, the embedded interface may be displayed in association with a chat interface on a display device of the first device such that at least a portion of the chat interface is visible, e.g., one or more chat messages (e.g., newly entered chat messages) in the chat interface remain visible during display of the embedded interface. In some embodiments, for example, the embedded interface may be displayed as part of (e.g., within a display area or boundary of) the chat interface, partially overlaying the chat interface, or adjacent to the chat interface. For example, the embedded interface may include an embedded view displayed within the chat interface. In some examples, the embedded view may be part of a chat interface dedicated to displaying output data of a running embedded application (e.g., a first embedded application) and/or dedicated to receiving input to a running embedded application (e.g., a first embedded application). In some examples, the embedded view may be a rectangular or other shaped window or other portion of the display screen.
In various embodiments, the embedded interface may be displayed based on the orientation of the user device, e.g., rotation of the user device to landscape mode causes the embedded interface to expand to a full screen display, e.g., to allow a more immersive gaming experience, more screen space for editing tasks, etc. In some embodiments, if the embedded interface is in a full screen mode (rather than a partial screen mode) that provides a full screen display, chat messages entered by chat users in a chat conversation may be displayed within the full screen embedded interface, for example, as notifications (if the first user has selected such chat messages to be displayed in this manner). In some embodiments, the suggestion response (described with respect to fig. 7) may also be displayed within a full screen embedded interface.
In some embodiments, the size and/or shape of the embedded interface may be based on the type of the first user device, and/or the type of information displayed in the embedded interface by the first embedded application. In some examples, if the first user device is a mobile device or other device type having a small display area (e.g., a display screen), the size of the embedded interface may be made to occupy a particular percentage of the display area and allow at least one chat message to be displayed in the chat interface. For device types with larger display areas (e.g., desktop computers, larger tablet devices, etc.), the embedded interface may be displayed to occupy a smaller percentage of the display area, allowing for a larger area for chat messages. In some embodiments, in response to user input selecting a displayed control, the embedded interface may be maximized to occupy the entire display area. In additional examples, if the embedded application is a media player application displaying a particular type of content data, such as movie data and image data, (or a gaming application displaying a particular type of game, such as with a graphical environment), the size of the embedded interface may be set larger to view the content data, while if the embedded application displays a content data type, such as a text item list or output audio from audio data, the size of the embedded interface may be set smaller. In some embodiments, the embedded interface may be displayed as a three-dimensional (3D) display through a display screen, virtual reality display device, or the like, or may be displayed within an augmented reality display device, or the like.
In some embodiments, the set parameters may be entered into the embedded application by the first user prior to launching the embedded session and prior to sharing the embedded application with other chat users. For example, the first user may create a new game instance of the embedded game application and set game parameters, select player names, game board sizes, player colors, number of players allowed to join the particular session, and so forth. In a further example, the user may use the embedded application to search video in the media item menu online for play, select travel destinations, flights, hotels, etc. before sharing the selected option, pre-select shopping items (clothing, furniture) before soliciting opinion/vote of other member users, etc.
In block 214, a shared embedded session is initiated. An embedded session is a specified event that is dedicated to shared use of an embedded application by a particular set of chat devices participating in the embedded session and chat conversation over a network, e.g., shared communication of information between the particular chat device and the shared embedded application. In some embodiments, each chat device of the embedded session runs, at least in part, an instance of the shared embedded application (e.g., a corresponding embedded application). The associated chat device group and the chat user group using the associated chat device share user interactions with the embedded application and output of the embedded application. For example, one or more states of respective embedded applications running on user devices of a chat user group are synchronized. In some embodiments, the embedded session includes only one or more chat devices from the chat conversation with which the first embedded application is associated, e.g., the chat conversation of the first embedded application is opened in block 210. Chat users that have joined an embedded session are "member users" and their chat devices are "member devices" that are a subset of the chat devices that participate in the embedded session. In some embodiments, an embedded session may be associated with a particular embedded session Identifier (ID) that is associated with an identifier of an associated chat conversation. The session ID may be associated with the current user member of the embedded session. For example, the user of the first device may be added to a list of session users of the embedded session, the list listing members of the embedded session. The first device and/or session server may store and update such a list of session users.
In some embodiments, the embedded session may be managed by a server, such as (embedded) session server 152, which may be a server system that receives data from one or more member devices participating in the embedded session, synchronizes the state of embedded applications on the member devices, and outputs the data to the one or more member devices. In this example, in response to receiving the input in block 210 and/or in response to running the first embedded application in block 212, the first device (e.g., the first messaging application) may send data to the session server, where the data indicates to the session server that the first embedded application has been launched. In some embodiments, the session server may initiate an embedded session in response to receiving such data, and may run an application capable of performing some of the processing (e.g., storing objects, executing processing, etc.) of the embedded session. In some embodiments, one or more client devices (e.g., a first device of an embedded application that initiates an embedded session) may manage the embedded session, and/or member devices may communicate messages between each other without server processing. For example, data may be sent from each member device to a message router that forwards the data to other member devices without affecting the processing of the embedded session.
In block 216, notification information indicating the activation of the embedded session is transmitted to other devices of the chat conversation. In some embodiments, notification information may be transmitted over a network from a session server to other devices that are engaged in a chat conversation ("chat devices"), e.g., to all chat devices. In some embodiments, the notification information is generated at the session server (or at the first messaging application) and sent to other chat devices via the session server. The notification information may include an identification of the embedded session and an identification of the chat conversation, as well as a list of identifications of session users that are current members of the embedded session (in this example, the first user).
In block 218, the chat user is enabled to join and/or leave the embedded session, and the chat device may be notified of such joining and leaving events. For example, the first device may transmit the joining information to one or more other user devices participating in the chat conversation (e.g., may be included in the notification of block 216, or may be transmitted separately from the notification, in some embodiments). The joining information can cause display of interface elements at other chat devices that can accept user input at each chat device. In response to receiving user input at an interface element on a particular chat device, the particular device is designated as a member device of the embedded conversation. In some example embodiments, the chat user is able to join the embedded session as a member user by selecting a displayed "join" button presented on the chat user's user device. In some embodiments, for example, in response to a notification of box 216 displayed on the chat user's device, the chat user may enter a command to join the embedded session. Some examples of devices joining an embedded session are described below with reference to fig. 3 and 4.
The member user may leave the embedded session by exiting or closing the embedded application and/or by exiting or closing the message application. In some embodiments, exiting or closing the messaging application and/or the embedded application does not cause the user to lose membership in the embedded application or embedded session. In such embodiments, the user is still a member of the embedded application and is simply indicated as offline, for example, in a chat interface or embedded interface displayed on other member devices. In an example of such an embodiment, a user may leave an embedded session (discontinue embedded application membership) by leaving a chat conversation associated with the embedded application. In some examples, a notification is sent to the chat device indicating that the user has joined or left the embedded session and an identification of the user (or user device). The notification may be sent to a chat device that may or may not be a member device of the embedded session. In some embodiments, in response to a member user of the embedded session leaving the session, a notification is sent only to the member user's device.
Each member device that has joined the embedded session downloads and/or runs a respective embedded application (corresponding to the first embedded application and the embedded session) that provides a respective embedded interface associated with a respective chat interface displayed on a respective particular user device. The embedded applications of the member devices communicate with each other in an embedded session over a network.
In block 220, a first embedded application running on a first device operates to receive input, update state, and provide output. For example, the input received by the first embedded application may include user input provided from a user of the first device. In some examples, user input may be received in a displayed embedded interface, e.g., to select an element displayed within the embedded interface, specify direction data with a controller or gesture, specify text data, etc. In additional examples, user input may be received in a chat interface, for example, a text command entered as a message or selection of an interface element in the chat interface. Input received in the chat interface may be processed and/or passed from the messaging application to the embedded application. In some embodiments, the embedded application may access chat conversation information (e.g., user name or chat identification, user icon, etc.) and/or access user profile information (user name, profile picture, chat ambiguity ID), which may allow for a personalized experience. In some embodiments, the embedded application cannot access the chat stream (e.g., chat messages entered in the chat conversation). In other embodiments, the embedded application can have full access to the chat stream, and/or the embedded application can request higher-level access to chat inputs (allowed by the user), and/or can be provided with a summary of chat messages entered by the chat user in the chat conversation via the messaging application. In additional examples, the embedded application may read the entered chat message directly from a chat conversation database associated with the chat conversation (e.g., stored on a user device or server), and/or may receive the chat message and other user input in the chat interface through a server or bot. The user input may be touch screen input, text input provided from a displayed keyboard or physical keyboard, commands provided from voice input, or other types of input.
In addition, the first embedded application may receive input (data) including event information received from member devices of the embedded session over the network. For example, the event information may include user input provided by other member users to an associated embedded interface displayed on their devices through an embedded application running on their devices and corresponding to the first embedded application. The user input and/or other data (e.g., an update or state of the embedded application based on the user input) may be sent to the first user device over the network.
In addition, the input may include event information indicating one or more events and/or application states occurring in one or more corresponding embedded applications running on one or more other member devices (and/or session servers), and the event information may be sent to the first user device over the network. For example, the event information may describe events that occur within a corresponding embedded application running on a particular device based on user input received by the embedded application, and the information is sent to other member devices to synchronize the embedded applications of the embedded session. In some embodiments, event information from other member devices may be communicated by a server system (e.g., message server, session server, etc.) to the first embedded application. In some embodiments, the input is received by a first messaging application of the first device, the first messaging application providing information to the first embedded application.
Further, the first embedded application may receive content data from one or more other devices (e.g., member devices, server systems, etc.) over the network. For example, if the first embedded application is a video playback application, it may receive a video data stream from a content server over a network and display the video data in an embedded interface. If the first embedded application is a game, it may receive game data from other member devices and/or a game server and display the game data in an embedded interface. If the first embedded application displays a shared content document (e.g., item or event list, text document, etc.), travel itinerary, or other information, it may receive content data for these items from other member devices and/or server systems and display the content data in an embedded interface. In some embodiments, the content data is received by a first messaging application of the first device, the first messaging application providing the content data to the first embedded application.
In some examples, the first embedded application is updated based on the input. For example, the first embedded application may receive data based on input data received from, for example, a first user and/or one or more member devices (and/or server systems) that change one or more states of the embedded application. In some examples of changing states, playback of a media item may be updated to a different point in the media item (e.g., a different point in time in the video), a game may be updated to one or more different game states (e.g., a game state indicating a different location of a game block (GAME PIECE) or player character in a game environment, a game state indicating a winning, losing, or player's score change, etc.), a shared list may be updated to add, remove, or alter one or more items on the list, a reservation of a theater seat may be entered, a change time or place, or removed, etc. Similarly, the input may include event information describing events of the embedded session (e.g., events in a corresponding embedded application of the member device or in a server providing data in the embedded session), such as events occurring in a game based on user input (e.g., game events determined by game code running on a different member device or server). The event information may cause the first embedded application to update its state to synchronize with the embedded session, e.g., with one or more corresponding embedded applications. In some embodiments, other embedded applications of other member devices may be similarly updated based on input and event information received at the respective member devices.
The output provided by the embedded application is based on the received input and/or events occurring in the embedded application. For example, the output may include output data displayed in an embedded interface. For example, the embedded interface may display interface elements, controls, and other features provided by the embedded application. In another example, the embedded application may cause data to be displayed in an embedded interface to provide a graphical game environment, a three-dimensional (3-D) environment, etc. (e.g., display on a display screen, display through a virtual reality and/or augmented reality display device, etc.). In some embodiments, the output may include data received by the first embedded application and the first device from different devices, e.g., content data received from a server such as content server 154 or from a member device of the embedded session.
In some embodiments, the output data displayed by the embedded interface may be customized for the particular user of the device displaying the output data. For example, the first user may have stored user preferences indicating the location, size, shape, etc. of the embedded interface on the display, as well as color mechanisms of the user preferences or other visual characteristics of the output data displayed in the embedded interface. In some examples, the first user may have stored user preferences specific to a particular embedded application, e.g., preferences indicating user status or role of user preferences in a specified embedded application, interface element layout for user preferences of a particular type of embedded application, etc. For example, such preferences may be provided from the messaging application to and implemented by the embedded application.
In some examples, the output provided from the first embedded application may include a visual update to an embedded interface (e.g., an embedded view) displayed by the first device. For example, media data (e.g., image or video data) playable at a new point in time may be displayed based on the update to the point in time, one or more changes to the displayed game may be displayed, changes to content documents (lists, files, charts, etc.) may be displayed, and so forth.
In further examples, the first embedded application may process content data from the chat conversation (e.g., parse and/or otherwise process chat messages provided by the messaging application) to present output data in the embedded interface, and/or the embedded interface itself, which is contextually related to one or more topics mentioned in the associated chat conversation. For example, a chat message in a conversation may already include an indication of a particular media item to play, and that media item may be automatically selected and played by the embedded application. In another example, the chat message may indicate that the user desires to play on a particular side or team in the game, and the user may be automatically assigned to the team by the embedded application. Multiple visual appearances (e.g., colors, visual styles, etc.) of the embedded interface, and/or different available selections or controls displayed in the embedded interface may be provided in different versions of the embedded interface. For example, the embedded interface may be displayed in different versions for different member devices based on user status or roles of the user, types of media items played (e.g., video and images), and so forth.
In additional examples, the embedded application may aggregate conversations and automatically store important information that may be displayed later. For example, instead of (or in addition to) displaying a record of many chat messages to read, a user may open an "overview" embedded application, and the embedded application may display an overview of messages entered by chat users of conversations over a period of time specified by the user and/or over a period of time that the user is offline.
In additional examples, the embedded application may be a "lightweight" (e.g., feature reduced or reduced functionality) version of the complete application running on the user device or on a different device. A lightweight version is a version of a complete application that requires less storage space, runs memory, etc., can run without launching the complete application, and can have a subset (e.g., less than a complete set) of features and/or functions of the complete application. In some examples, the full game application may be installed on a different device of the first user (e.g., a desktop computer or a notebook computer), and a lightweight version of the game application may be run as an embedded application on the user device. Such a lightweight gaming application may allow a first user to provide user input in an embedded interface to change game settings or game data associated with the first user or an account of the first user used in the full gaming application. Such changes may include managing game resources used by the first user in the full game application, e.g., organizing an inventory of game items, purchasing or selling items within a game, assigning scores to specific game capabilities of the first user's account, changing preferences or display settings, performing simple game actions, etc. Changes made by the user using the lightweight application are saved into the complete gaming application, e.g., in a user account at the server, and accessed by the complete gaming application when the complete application is running, and may be synchronized with the server, for example. Similarly, changes may be made using a lightweight version for a media item player program, a graphical editing program, a word processor, or other application. In some embodiments, for example, when the first user is not online, other member users in the embedded session may share the lightweight application to adjust the data and settings of their complete application and/or change the data and settings of the first user. In some examples, a lightweight version of an embedded application may provide a shared second screen experience on a user device for applications running on different devices.
In some embodiments, the embedded application may trigger the launching and running of an external application, such as a different embedded application or other application external to the messaging application on the first user device or other device in communication with the first user device. For example, the external application may be a complete application corresponding to a lightweight version implemented by an embedded application similar to that described above. In some examples, the embedded application may launch an external application to complete the processing of the task (e.g., determine the result of the transaction, provide a rendered display bitmap, etc.). In some embodiments, the embedded application may provide optional data (e.g., words, links, buttons, etc.) to be displayed in the chat interface and chat conversation. For example, the embedded application may provide the selectable data to the messaging application, and the messaging application may display the selectable data in the chat interface and chat conversation. The selectable content may be selected by user input, e.g., clickable through a touch screen or other input device. When selected by user input, the selectable data may cause a command to be sent to the operating system of the device to launch and run the external application (e.g., on the user device), wherein other applications may be identified in the selectable data or may be associated with the selectable data (e.g., a default application associated with a type of selectable data).
In a further example, when an external application as described above is launched, associated data such as parameters, configuration settings, and/or arguments may be passed to the external application to present particular data from the external application. In some examples, the embedded application may generate a map icon associated with the particular address and the icon is displayed in the chat interface. When an icon is selected by user input, a map application is launched and a map including the location of the selected associated address is displayed in the view. In additional examples, the external shopping application may be launched by selecting an item description sent by the embedded application to the chat interface, and the checkout shopping display of the external shopping application may include information of the user automatically populated into a field of the shopping display. In a further example, the user uses the shared embedded reservation application to select a hotel location and room, and a control displayed in the chat interface or embedded interface (e.g., a "reserve hotel room" button) opens an external full reservation application on the user device. The complete reservation application displays a reservation interface that is automatically populated with reservation information from the embedded application, and the user can select a "pay" button in the reservation interface to provide payment to the hotel for the reservation.
In some embodiments, the first embedded application may detect one or more external applications installed on the first user device and modify content data displayed on the first user device by the one or more external applications. For example, the embedded application may be a lightweight version (e.g., a lightweight application) of a full version (external) application (full application). For example, if a lightweight application on a first user device detects that a corresponding complete application is installed on the first user device, the lightweight application may implement special functions (e.g., additional control, display data, etc.) in the complete application by communicating with the complete application, e.g., via a messaging application. In some embodiments, a complementary relationship may be provided between a full application and a lightweight application (embedded application). In some examples, the full application may communicate data in the background (e.g., not displayed by the first user device) such that the lightweight application may communicate directly with the full application in the background to access or exchange data. The communication may trigger displayed data and options in the lightweight application and/or the full application, e.g., without requiring additional authentication between the lightweight application and the authentication server. For example, a login process on a full subscription application may be triggered by a corresponding lightweight application using a full application account registered by a user within the full application on the user device, and without requiring the user to re-authenticate in the lightweight application to perform the subscription.
In some embodiments, the output from the first embedded application may include data provided to the chat interface of the first device and/or to the chat conversation, e.g., data displayed on the chat interface of the chat devices participating in the chat conversation. For example, the first embedded application can provide data to a first messaging application that outputs data in a chat interface and/or to other chat devices. In some examples, the embedded application may send data describing the event or notification to the messaging application (and/or the messaging application may receive data describing the event and notification from other devices), and the messaging application may display the data describing the event or notification in a chat conversation to increase user engagement, retention, and awareness of the occurrence and events in the embedded session. For example, the output to the chat interface may be set to text or other types of chat messages (or images, video, audio, etc.). The output to the chat conversation may be transmitted to all chat devices so that it is displayed in the chat interface of all user devices participating in the chat conversation. In some embodiments, the output to the chat conversation may be transmitted to a subset of the participating chat devices to display the output. For example, the output may be provided in a chat conversation and visible to the member user or a particular chat user selected or designated by the first user. In some embodiments, such data output to the chat interface and chat conversation may be shared external to the messaging application, e.g., to other applications running on the first user device. In some examples, such data that is shared outside of the messaging application, when selected by the user or handled by a different application, may cause the messaging application to open or move to the foreground on the user device and may cause the embedded application to run and the user to join the embedded session.
In some examples, the notification output to the chat conversation may include a description of events occurring in the embedded session related to user actions, content data, in-game events, etc., provided by the embedded application in the session. For example, such notifications may include "user 1 and user 2 are watching party scene movie time adventure" (triggered by the scene being played), "user 1 reacquires the lead score in the bufo game-! "(triggered by the game event), or" user 2 has just subscribed to Jubilee's concert ticket-! "(triggered by the user subscribing to these items in the embedded application). In some embodiments, the notification may include text, images, video, audio output, movies, or other types of content data. In some embodiments, these descriptions of the events may be displayed on an interactive card (INTERACTIVE CARDS) as described below, which may allow chat users to provide input to notifications/cards to join an embedded session or to provide input to an embedded application. In further examples, the embedded application may access a list of chat users (e.g., fuzzy chat IDs) in the chat conversation and may issue an invitation to the chat conversation to join the non-member chat user in the embedded session, e.g., where the non-member chat user may select the invitation to join their device in the embedded session.
In some examples, the embedded application (e.g., under the approval of the user, as described below) may send chat messages to the chat conversation on behalf of the user. In some embodiments, such messages may be attributed to the embedded application rather than the chat identity of the user, e.g., the embedded application may assume its own chat identity as the originator of its chat message. Such chat messages may include expression packages, text, images, video or other types of content data resulting from the user performing edits in the embedded application, web page content fragments edited by the user in the embedded application, and so forth. In some examples, the attribute or name of the embedded application displayed in the chat interface of the other chat device may be selected by user input and, if selected, cause the embedded application to open to edit the same shared content data or edit another content data item.
The embedded interface may present displayed options to modify, set, or implement additional functionality for the chat conversation. For example, the features may include an automatic reply feature (selecting a random suggested reply or automatically answering a question with a previous reply from the first user to a previous similar question), examining or replacing a particular word before the word is sent to a chat conversation or received for display on the first device, etc. For example, the embedded application may use an API to modify the user's chat conversation experience. Thus, in some embodiments, the embedded application provides a visual interface that enables modified settings and/or provided features within the messaging application (e.g., providing messaging application features instead of-or in addition to-providing shared content data for chat users).
In additional examples, the notification (or other data) output to the chat conversation may include a message based on the chat message entered by the chat user. For example, the first embedded application may examine a list of chat messages entered by the user in the chat conversation, determine the use of slang and appropriate vocabulary in the chat messages (e.g., by consulting a stored dictionary using a machine learning model trained in slang and vocabulary, etc.), and output a rating in the notification indicating the score of the user's writing in the chat. The embedded application may determine and indicate in the notification, for example, how often the user uses the particular word in the chat message, or the challenge to the user to use the particular word (and may verify in a later notification that the user used the particular word). In some embodiments, the notification output to the chat conversation may include a message from one or more member users in the embedded session to a different member user as an indication of an event occurring in the embedded session, such as an invitation, a challenge to other users ("defeat my score," "guess my painting," "i build a tower, attempt to destroy it"), or a flash/complaint message or notification (e.g., one player killed another player's role, one player complained of another player stolen their pet, etc.).
In some additional examples, an embedded application having access to the chat conversation message stream may provide information related to the chat conversation, such as a high level overview of the conversation, a list of records or content data shared by the chat user in the chat conversation, a display (e.g., fixed) control or other option in the chat interface or embedded interface that allows the user to select collected topics, information or shared content data from the chat conversation for later storage, storage on the user's favorites list, and so forth. For example, an embedded application (e.g., a particular "profiler" type embedded application) may detect topics shared in a chat conversation and provide prompts, summaries, and/or actions related to those topics. In some examples, user 1 tells user 2, "do not forget the date of birth of Kenny" and the embedded application automatically adds a calendar event to the calendars of user 1 and user 2 stored on their user devices at startup or displays a suggested command or notification that causes the embedded application to add a calendar event when the user selects the command or notification. In another example, user 3 enters a message in the chat conversation that includes the address or location of the restaurant for the next week's party dinner, and the embedded application automatically fixes (persists) or otherwise stores the location as an overview in the chat interface so that the first user does not have to view and scroll through the old chat message after one week to find the location. For example, the summary may include descriptive and identifying information (e.g., time, location, name, telephone number, address, etc.) entered into the chat conversation, and/or may include messages (e.g., user endorsement, exclamation messages, etc.) that received a reaction from other chat users in the chat conversation. In another example, user 1 shares images captured from recent corporate journeys in a chat conversation, and the embedded application automatically (with user consent) uploads the images to a shared group album "Las Vigas corporate journeys" that is shared with all chat users (e.g., stored on a server over a network). In some embodiments, if the embedded application does not have the ability to perform such actions based on chat conversation content data, it may trigger the launch and execution of a different embedded application (or other application) that has the ability and performs the actions. In some embodiments, one or more such actions of the embedded application may be presented as a suggestion command and/or a suggestion message that may be selected by the first user to implement the selected command, as described herein.
In some embodiments, notification of chat conversations may be provided in response to one or more particular events or types of events (e.g., server events) that have occurred on a server in communication with a messaging application and/or an embedded application over a network, such as events processed in a server application running on the server. The server may send the server event information to one or more member devices such that the message application displays the server event information in a chat conversation. In some examples, the server may manage second content data of other network users, where the second content data is the same as or related to first content data (e.g., media item data, game data, etc.) provided by the server to the embedded application on the first user device. For example, the server may send the second content data over the network to one or more other users accessing the content data via other embedded applications and/or other mechanisms (e.g., websites, dedicated viewing applications on the user devices, etc.) on other user devices (e.g., user devices not participating in the chat conversation). The server may detect whether the second content data is the same as or similar to the first content data provided to the embedded application (e.g., the same title of the media item, game, etc.). Further, the server may detect a user action associated with the first content data and the second content data, which may qualify as a server event. For example, the server may detect that the second content data has received a plurality of favorable user ratings from other users, e.g., a threshold number of favorable ratings exceeded. This may be predefined as a server event that causes the server to send server event information (e.g., "the movie has received 100 tens of thousands of endorsements |") to the first embedded application for display in the embedded interface and/or to the messaging application for display in the chat interface.
In some embodiments, if user consent has been obtained, the output provided from the embedded application may include input information based on user input received in the embedded interface from the first user, where the messaging application sends the input information to the server over the network, e.g., for display at other user devices, etc. The messaging application may also or alternatively determine and send input information to the server (if user consent has been obtained), wherein the input information is based on user input received in a chat interface external to the embedded interface. For example, the user input may be a chat message, user comment, or rating, etc., associated with a content item (e.g., a media item or game) played in the embedded session. In some embodiments, these comments or ratings may be received by the server and associated with the content items provided to the device by the server. The server may provide comments or ratings to user devices accessing the content items on the server. For example, other user devices not participating in the chat conversation may access the content item on the server, e.g., via a different embedded session or other application. Such other user devices may also access comments or ratings provided by the first user. For example, user input such as user comments or ratings may be sent to other user devices and displayed in an embedded interface or other application on the other user devices.
In some embodiments, if user consent has been obtained, the input information sent to the server may include information indicating that a particular content item has been played in the embedded application on the first device. The server may update a stored history of user selections of content items based on the input information, wherein the history is associated with a first user of the first device. The stored history may also indicate user selections of content items stored by the server and viewed in other applications used by the first user. In some embodiments, the server may use the stored history to determine suggested content items to the user that are related (e.g., in terms of type, other user's views, etc.) to content items previously accessed by the first user on the server. In some embodiments, such server suggested content items may be displayed in a chat interface and/or by an embedded application playing the type of content item.
Furthermore, if new conditions are triggered, the embedded application, the robot program (see description of robot program below), or the server-generated information may be updated by the embedded application, the robot program, or the server. In an example, user 1 uses an embedded media player application to share video in an embedded session in a chat conversation. User 2 opens a corresponding embedded media player application on his or her device and reviews or evaluates the video. The embedded application, bot, or server may update the shared video and update the notification describing the video displayed in the chat conversation to reflect and propagate new information to the chat user (e.g., display an indication that the video now has +1 user approval, +1 user comment). In some embodiments, an updateable "interactive card" for an embedded session is shared in a chat conversation, which may be controlled by a server, a bot, or an embedded application.
In some embodiments, when output data from the first embedded application is output to the chat conversation and/or server for display, a prompt is displayed (e.g., with a user selectable option) to allow the first user to select whether to allow the output of data in the chat conversation. For example, if the user agrees, the prompt may display a message to be sent to the chat conversation or server. In some embodiments, prompts may be displayed to the chat conversation for a particular type of output data (e.g., a particular type of message with predefined keywords indicating a particular type of event, output data as a response to a particular type of action or command provided by a member user to the embedded application, etc.) and not for other types. The prompts may be displayed for a particular type of embedded application and not for other types. In some embodiments, the first user may have stored accessible user preferences that are accessed to determine conditions under which to display the prompt. For example, the user preference may indicate that the prompt should require user consent to send output from the game-type embedded application to the chat conversation and not provide a prompt for the media player-type application or other type of application.
The output may also include data transmitted over a network (e.g., through an associated messaging application and/or server system) to a corresponding embedded application running on the other member device. For example, the transmitted data may include user input received by the first embedded application from the first user (or data derived therefrom), e.g., selecting an element or changing state in the first embedded application. Similar to the above, the transmitted data may include event information indicative of one or more events occurring in the first embedded application (e.g., based on user input from the first user, program events running based on code and specific conditions, or other events occurring locally to the first embedded application). The data may be provided to a first messaging application that may transmit the data (or processed data form) to other devices over a network. For example, the data may be sent to a message router (e.g., a session server as described above) that may send the data to other member devices, and/or the data may be sent directly to one or more member devices. Other member devices may receive and use user input and/or event information to update the state of the respective embedded applications to synchronize with the first embedded application.
In some examples, the output from the embedded application may include event data indicating one or more particular events (or event types) that have occurred in the embedded session. Event data may be provided from the embedded application to the messaging application, which may generate notifications based on the event data and cause the notifications to be displayed in a chat interface and sent over a network for display in a chat conversation (e.g., chat interface) of the member device and/or the chat device. For example, an event may have occurred in the first embedded application. In various examples, an event in the embedded session may have occurred in response to a first user input from a first user and other user inputs received from one or more member users of the embedded session. In some examples, the event type may be changing the playback position of the media item, or starting or stopping playback of the media item in an embedded media player application; achieving a goal, ending a particular phase or portion of a game or game duration, or other game event in a game provided by an embedded game application; modifying content documents in the embedded list application (e.g., items in the shared list); booking seats by an embedded booking application, etc. In some embodiments, the event in the embedded session may have occurred on a server (e.g., session server) that manages the embedded session, which provides event data to a messaging application that may generate notifications for display in the chat conversation. The types of events on such a server may include receiving input data at the server from other users outside of the chat conversation over a network, availability of new content items related to content items played in the embedded conversation (e.g., new media items having the same artist, author, actor, production company, genre, etc. as the media items played, or if one or more member users have provided consent, the new content items are known to be on a favorites list of one or more member users), disconnection of one or more member users from the server, etc.
In some examples, the embedded application may output control information (e.g., via a messaging application) to an external application running on the first user device (or launched) or on a different device in communication with the first user device over a network. In some examples, the embedded application may output control information to an application controlling a home appliance, vehicle functions (locking/unlocking a door, changing a thermostat, etc.), or other type of device. Such control information may be output, for example, in response to selection of a control (e.g., button, control pad, etc.) displayed in the embedded interface, or automatically in response to a chat message entered by the first user (e.g., "open my front door," resulting in outputting control information to unlock a door of the user's housing) or based on a chat message entered by the chat user in a chat conversation (e.g., discussing a message to enter a car, resulting in the embedded application sending a control signal to unlock a door of the car). In another example, in response to receiving input from the first user and/or other chat users in an embedded interface or chat conversation, the embedded application may send application data to affect the game state of the console/desktop game. For example, a chat user may select a control in the embedded interface to send data to a server where the data is read by a game application on a different game device to change game resources (as described above), or to start a game on a game device, perform a game action in a game, and so forth. In another example, the embedded application may automatically send information to the game that causes the chat user's game character to form a group in the game based on chat messages (e.g., "let us join the game") from the chat user in the chat conversation. The chat conversation provided on the chat device may act as a chat interface between players of the game running on the gaming device. In some embodiments, the control information may be presented in the chat interface as suggested commands for the external application, which may be sent to the external application in response to a selection entered by the user, as described below.
In further examples, the embedded application may provide data to the messaging application to permanently or temporarily modify the visual representation of the first user in the chat conversation. For example, the user status or role may be displayed next to each message or user name (e.g., "user 1-player") or next to a title assigned by the embedded application (e.g., "user 1-conqueror" of the game). In additional examples, a filter may be applied to modify the user profile image appearing in the chat interface and/or modify the chat message entered by the first user (e.g., highlighted with color, border, frame, decal, etc.). Such modifications may be provided when the first user participates in the embedded session and/or as rewards for achievement in the embedded application. Rewards include unlocking other embedded applications for use by all chat users. The integration between messaging applications and embedded applications through the disclosed APIs may allow such functionality.
Some embedded applications may change the keyboard layout displayed in the chat interface, buttons displayed, or other displayed controls (or controls provided by the operating system or other interface displayed by the user device) based on the type of embedded application and/or in response to events in the embedded application or chat conversation. For example, the keyboard layout displayed in the chat interface may be changed to match a game controller dedicated to a particular embedded game application. In another example, an event such as achieving a goal in a game or being defeated in a game may cause one or more displayed buttons to be added to or removed from the chat interface according to increasing or decreasing user options in the game. In another example, when a user enters a text query to perform a search for an item (e.g., a product), as more characters are entered, the embedded application may cause additional suggested characters for the query that do not match any search results to be removed from the display or displayed with less visibility (e.g., grayed out) than the matching characters.
In additional examples, various types of embedded applications may be run in association with a messaging application. For example, the embedded media player application may receive user input from a member in an associated embedded interface and/or chat interface. The input may select a playback function for a media item, such as video, image, audio data, document, etc., and the output from the embedded application may provide playback of the media item. The embedded gaming application may receive user input from a member user that may change the game state, and the output of the application may include visual, audible, and tactile outputs indicative of the game environment and game state. The embedded shared document application may receive user input from the member user that may change the shared content document (e.g., a list or other document), and the output of the embedded application may display the updated content document. The embedded travel itinerary application may receive user input from a member user that may select travel destinations, routes, times, and other travel related preferences, and the output of the embedded application may include displaying available travel routes, options to select a particular route, time, and travel methods entered by the user, etc. The embedded reservation application may display selectable options that allow member users to reserve hotels, restaurants, movies, meetings, rides, parks, entertainment shows, and other future event locations or seats. For example, such an embedded application may receive user input from a member user specifying a time, location, and event of a reservation location (e.g., including user selection of a seat, table, or other location in a graphical display), and the embedded application may output suggested events and dates/times, an indication of successful or refusal of the reservation, and so forth. In some embodiments, various types of embedded applications (e.g., having different functions or purposes) may be combined into a single embedded application.
In block 222, it is determined whether the first messaging application has exited at the first device. For example, user input received by the first device may close the messaging application. If the first messaging application has been exited, then in block 224 the chat interface is removed from the display of the first device, including removing the embedded interface. In some embodiments, the embedded application is also removed from the memory of the first device. In addition, information may be sent to a device managing the embedded session, such as a session server, to indicate that the first device has exited the embedded session. In some embodiments, the management device (e.g., session server) updates the session user list to remove the first user and provide the update to other member devices of the embedded session.
If the messaging application has not been exited, then a check is made in block 226 as to whether the first embedded application has been closed at the first device. For example, a user input may be received at a first device from a first user that selects a displayed element in a chat interface or an embedded interface to close an embedded application. If the first embedded application has been closed, then in block 228 the embedded interface is removed from the display of the first device. In some examples, removal of the embedded interface allows the chat interface to occupy the area previously occupied by the embedded interface. In addition, information may be sent to a device (e.g., a session server) that manages the embedded session to indicate that the first device has exited the embedded session, similar to that described with respect to block 224.
In block 230, in some embodiments, if such a condition exists, an indication is displayed in the chat interface indicating that the embedded application is being used by one or more other member devices. For example, the indication may be an icon or other element displayed in the chat interface as the embedded application continues to be used in the embedded session where the first user exits. In some embodiments, the indication may be selected by user input to cause the first user and the first device to rejoin the embedded session of the embedded application, e.g., to rerun the embedded application from code stored in memory of the first device, and/or to download and run the embedded application. Some embodiments may remove the displayed indication if all users have exited the embedded application, and/or if no member users interacted with the embedded session or embedded application after a threshold period of time (e.g., provided input).
In some embodiments, multiple embedded applications may be running simultaneously, and the first user device may display multiple embedded interfaces (e.g., similar to the embedded interfaces described above) in association with the chat interface. In some examples, multiple embedded applications may be running simultaneously on the first user device. In some embodiments, multiple embedded applications may communicate data with each other. For example, one embedded application may send a command to another embedded application to cause the other embedded application to update one or more states, remove or add member users, and so on.
In some embodiments, the messaging application may manage the conversation "money". This may be virtual currency, which may be generated by the embedded application, earned by chat users, and exchanged with other chat users within the embedded application and/or within the messaging application. In some examples, a user may receive tokens or "coins" when a particular task or goal in an embedded application is performed (e.g., completing a goal in a game, editing a video or image for a threshold amount of time or number of editing operations, playing a media item for a threshold amount of time, editing a share list, completing a travel reservation, etc.). In various embodiments, the user may spend the money to obtain rewards, such as the ability to change the visual characteristics of the chat interface, select new options, or use other characteristics of the chat interface. In additional examples, the currency can be spent to enable use (e.g., unlock access) of visual text characters, icons, or images (e.g., "decals") that can be inserted into the chat conversation, enable use of particular conversation features (e.g., alter message text fonts, add color or title to chat logos, use particular images or avatars in chat conversations, etc.), enable use of particular embedded applications, and the like. In some embodiments, currency may be used to unlock or improve features in the embedded application (e.g., use of a particular avatar or character in a game, access to particular media items at discounts to currency, use of different display appearances of the embedded interface, etc.). In another example, a user may send a particular amount of money to a different chat user, or may transfer (or copy) the rewards or access rights acquired to a different chat user in exchange for a lot of money. In some embodiments, the currency may be converted to real currency, allowing person-to-person payments (e.g., splitting a bill at a restaurant, or small debt settlement).
FIG. 3 illustrates a flowchart of an example method 300 of enabling a user to join an embedded session, according to some embodiments. In some examples, method 300 may be included in block 218 of fig. 2. In some embodiments, the method 300 may be implemented, for example, on a server system (e.g., the message server 101 as shown in fig. 1). In some embodiments, some or all of the method 300 may be implemented on a system, such as one or more client devices 115 shown in fig. 1, and/or on both a server system and one or more client systems. In the described examples, the implementation system includes one or more processors or processing circuits, and one or more storage devices, such as a database or other accessible memory. In some embodiments, different components of one or more servers and/or clients may perform different blocks or other portions of method 300.
In some embodiments, the method 300 may be implemented on a different user device (e.g., a second user device) than the method 200 of fig. 2. For example, the second device may communicate with the first device of fig. 2 over a network. The second device is participating in a chat conversation and the embedded session has been initiated by a chat user of a different device participating in the chat conversation. In the example of fig. 3, as described with reference to fig. 2, an embedded session is initiated in association with a first embedded application of a first device, and a second device participates in the same chat conversation that the first user and the first device are participating in.
In block 302, it is checked whether user consent (e.g., user permissions) has been obtained to use the user data in the implementation of method 300. For example, the user data may include messages sent or received by the user, e.g., using the messaging application 103, user preferences, user biometric information, user characteristics (identification, name, age, gender, occupation, etc.), information about the user's social network and contacts, social and other types of actions and activities, content created or submitted by the user, ratings and opinion, the user's current location, historical user data, images generated, received and/or accessed by the user, videos viewed or shared by the user, and so forth. In some embodiments, one or more blocks of the methods described herein may use such user data.
If user consent has been obtained from the relevant user that user data may be used in method 300, then in block 304, the blocks of determining the method herein may be implemented with the ability to use user data, as described for these blocks, and the method continues to block 308. If no user consent is obtained, then in block 306 it is determined that the block is to be implemented without using user data, and the method continues to block 308. In some embodiments, if user consent is not obtained, the block is implemented without using user data and utilizing synthesized data and/or data that is commonly or publicly accessible and publicly available.
In block 308, an indication (e.g., notification) is received at a second messaging application of a second device that an embedded session of the embedded application is active. In some examples, the indication may be data indicating that a particular embedded application has been launched and that an associated embedded session has been launched. In some embodiments, the indication may include an identification of a chat user from a chat conversation that initiated the embedded session. In some embodiments, the indicated data may have been sent by the session server, for example, after the embedded session is initiated.
In some embodiments, an identification (e.g., user ID) of the chat user (e.g., that has joined the embedded session) that is the current member of the embedded session is included in the received indication. For example, a list of session users described with reference to fig. 1 may be provided in the indication. Or may indicate the current number of member users without indicating the identity of the member users. In some embodiments, the received indication may include additional information. For example, the information may include an amount of time since the embedded session was initiated, one or more current states of the embedded application in the embedded session, and/or other information related to the embedded session. In some examples, the additional information may include the name of the media item currently being played, in a queue to be played, or otherwise processed for the embedded session, the number of current items of the shared list (or other shared document data) being edited in the embedded session, the status of one or more member users with respect to the embedded session (e.g., identifying the user as a controller, player, observer, etc., and/or identifying the user currently editing a document or winning a game implemented in the embedded session, etc.), the list of objects implemented in the embedded session so far (e.g., completing the playing of the video, completed game goals, the list being finalized, etc.), a particular request from one or more current member users of the session to join the embedded session to additional user members, etc. In some embodiments, the additional information may include messages from one or more member users in the embedded session to a second user or other member users as an indication of events occurring in the embedded session, such as invitations, challenges to other users ("defeat my score", "guess my drawing", "i built a tower in an attempt to destroy it"), notifications of blowing or complaints (e.g., players killed other players' roles, players complained of other players stolen their pets, etc.). In some embodiments, the second device may receive an update to the information at a later time, e.g., an update to the current number of member users, the current state of the embedded application, etc.
In block 310, the second message application causes the second device to display (or other type of presentation or output) the notification and join options. The notification may include one or more information items received in block 308, e.g., descriptive information about the active embedded session indicated in block 308. For example, such information items may include names or identifiers used by the embedded application in the embedded session, shared content data (e.g., media items played, content documents edited, etc.), current member users that have joined the embedded session, status of one or more member users with respect to the embedded session, current status of participating in the embedded application, messages from the member users, and/or other information received in the indication of block 308. In additional examples, the information in the notification may refer to content data or status of the embedded application (playback position of media item, high score in game, game status information) or content data of the chat conversation (as allowed by user privacy control). Further, the notification information may include an embedded application download size and application description, an indication that user permissions are requested for using the user data and the type of data (e.g., user data) that the embedded application will access, a list of users that have joined the embedded session, and so on. In some embodiments, the displayed notification may take the form of an "interactive card" as described herein.
The join option is a selectable option that, if selected through user input, allows the second user to join the active embedded session. In some embodiments, the join option may be an interface element displayed in a chat interface of the messaging application in which data of the chat conversation is being displayed. For example, the join option may be displayed as a selectable control (e.g., button) in a notification displayed in the chat interface.
In some embodiments, if one or more conditions are met, the join option may be displayed, or may be highlighted (e.g., in a bright color, flashing, etc.) or otherwise emphasized in the display. For example, the condition may be specified in a stored user preference of the second user. Such conditions may include, for example, the embedded session being of a specified type or being associated with a specified embedded application, one or more specified users being current member users of the session, a specified user state (e.g., user role) being still available to the second user (e.g., not yet assigned to other member users) in the embedded session, the embedded session not being activated for a specified period of time (e.g., a period of time after the first user in fig. 2 has launched the embedded application), the output of sequential media items (e.g., video or audio data) being played in the embedded session not progressing to a specified percentage of the total play time or other conditions.
In some embodiments, in addition to joining the embedded session, the joining option may include one or more additional options displayed (e.g., user interface elements displayed that correspond to the additional options). For example, the additional options may include an option to select a command or request for one or more particular user states (e.g., user roles) that the second user may be or will be assigned to in the embedded session. The user state or role may be selected by the second user from a set of predefined user states or roles. The user state may define one or more functions of the embedded application that can be activated by a user engaged in the embedded session and/or may define the ability of the user to modify data and/or state of the embedded application and the embedded session. Examples of user states or roles may include controllers (e.g., users that are able to modify data such as content documents (e.g., lists), or control playback of media items), players in a game (e.g., can be winners or losers in a game), observers of application events (e.g., view playback of displayed media items or play of a game and cannot affect media item playback or input game actions), referees in a game (e.g., arbitrate game rules, initiate next round play in a game, etc.), administrators (e.g., initiate and stop output or processing of an embedded application such as a media item playback or game, allocate or divide resources for players in a game, etc.), leaders of teams of multiple users in a game, user states or roles that allow users to modify operations of an embedded application (e.g., specify rules or conditions for a game, control playback or other output of media data, etc.), etc. Some user states or roles may be constrained or restricted, e.g., only qualified users may be assigned these roles (e.g., if a maximum number has been reached, the maximum number of players in the game may limit additional users to be assigned player roles), while other states or roles may be unrestricted (e.g., observers of the game). In some embodiments, the join option may include a request for permission from the user for the embedded application to use a particular type of user data associated with the second user.
In block 312, user input is received by the second device and the second messaging application, the user input instructing the second user and the second device to join the embedded session. For example, the user input may be a selective user input that selects a displayed join option (as described in block 310) via a touch screen or other input device, the user input may input text or menu commands, or the like. In some embodiments, the second user and the second user device may join the embedded session without explicitly receiving user input instructing to do so. For example, one or more conditions may be specified in the stored user preferences of the second user, and if the one or more conditions are met, the one or more conditions may instruct automatic joining of the embedded session. For example, the conditions may include one or more of the conditions described above for block 310.
In some embodiments, the second messaging application may receive user input specifying additional input related to the second user joining the embedded session. For example, the user input may select a state of the second user in the embedded session. In some examples, as described above, the user input may select or specify a user state (e.g., role) in the embedded session to assign to (or be requested by) the second user. In other embodiments, the user state or role may be selected by the second user through the second embedded application or through the session server after joining the embedded session. In some embodiments, the user input may include other designations or selections, such as a time at which the user wishes to exit the embedded session, a selection of an icon, avatar, image, or other data associated with the user that is a member of the embedded session, or the like. In some embodiments, the user status or other designation may be selected by user input from a menu or other list of options displayed in the chat interface.
In some embodiments, the second user and/or one or more other chat users may automatically join the active embedded session, or may be automatically provided with customized options (e.g., in block 310) to join the active embedded session. In some examples, such chat users may be detected as being interested in the embedded application based on their input messages in the chat conversation. In an example, three chat users enter chat messages into a chat conversation that describes a vacation to a particular geographic location (e.g., hawaii). One of the chat users issues a command in the chat interface to launch an embedded travel itinerary application, and the other two users automatically join the associated embedded session, or are provided with notifications indicating that the embedded session is relevant to the travel destination they are discussing (e.g., hawaii) based on a messaging application or other device that resolves the users' message inputs in the chat conversation (e.g., resolves location names, etc.).
In block 314, a second embedded application is downloaded and/or run for the second device in response to user input joining the activated embedded session of the joining block 312, and the embedded session is notified of the joining event. For example, similar to that described in fig. 1, the second device may send a request to a server system hosting the embedded application and download the second embedded application that is capable of being downloaded from the server system hosting the embedded application. The downloading of the second embedded application may occur in the background of the operating environment of the first device, e.g., similar to that described above. After (and/or during) the download of the second embedded application, it may be run on the second device. In some embodiments, one or more portions or components of the second embedded application may be run by one or more other devices (e.g., one or more server systems) in communication with the second device. In some embodiments, the second embedded application corresponds to the first embedded application and the embedded applications running on other member devices of the embedded session. For example, the second embedded application may include the same code (or substantially the same code) as the first embedded application of fig. 1.
The second messaging application may send notification information to the embedded session indicating that the second user has selected to join the embedded session. For example, the notification information may be sent to a session server that communicates the join event to other member devices (including the first device) by sending the notification information (or information derived therefrom) to those member devices. In some embodiments, the session server may update the session user list of the embedded session stored by the session server, e.g., add the second user to its session user list. Some embodiments may send notification information directly to one or more other member devices of the embedded session. In some embodiments, the second device sends a request to join the embedded session, and the session server (or the embedded device) may send a response back to the second device that causes the second device to connect to the embedded session (and/or initiate execution of the second embedded application on the second device if the second embedded application is not already executing).
In block 316, the second messaging application provides the user information to a second embedded application on the second device. In some embodiments, the second embedded application may request such user information. For example, the user information may include member updates, such as updates of members in an embedded session. In some examples, the user information may include a user identification of the member users of the embedded session, which may be, for example, chat identifications of the users and user devices participating in the chat conversation. In this example, a chat identification of the first user, as well as chat identifications of any other member users, may be provided. The second message application may provide the user identification, e.g., the user identification received by the second message application in block 308 and/or the user identification has been previously received from a message server for a chat conversation conducted by the second message application.
In some embodiments, the second messaging application may provide the second embedded application with user information for a particular user (e.g., the first user) if the second messaging application has acquired consent of the second user. For example, in some embodiments, such consent may be included in the user information provided for the chat conversation. If the user's consent is not obtained, no user information is provided to the second embedded application.
In some embodiments, the second messaging application may anonymize the user information (e.g., anonymize or obscure one or more user identifications) prior to providing the user identification to the second embedded application such that the user information does not describe or can not be associated with (or only partially describe or partially associate with) the particular user. In some examples, if the chat identification is a user name, a "virtual" or "temporary" name may be assigned for use by the embedded application and in the embedded session. For example, the chat identification of the first user may be changed to a universal identifier or a name such as "user 1", "friend 1", the first user's initials, the first user's name (FIRST NAME), etc. For example, a name such as "John Doe" may be replaced with a temporary name (e.g., "Kenny"). The anonymous user information may be provided to the second embedded application as one or more user identities.
In some embodiments, the second messaging application also provides additional user information, such as a user status or role to be assigned to the second user in the embedded session. In some embodiments or situations, the state or role may have been selected by the second user, for example, in an embedded interface or chat interface. The second embedded application may update its output based on the added second user. For example, the user identification of the second user may be added to a list of users displayed in the embedded interface.
In some embodiments, the user state or role is determined by the messaging application (or embedded application) based on chat messages provided by the second user in the chat conversation (and, for example, the user state or role need not be selected by the second user). For example, if the second user previously entered a chat message called "I want to play white" in a chat session that initiated the embedded chess game application, the message application may detect the message, determine its meaning (e.g., by comparison with keywords or key phrases and/or using machine learning techniques), and automatically assign the second user to the user character of the chess player after the second user joins the embedded chess game session. The messaging application may provide the user status to the embedded application to assign a second user control white chess in the game.
In some embodiments, a particular user role in the embedded session may not be available to a member user (e.g., a second user) added to the embedded session. For example, the user information may indicate that the second user has selected to be a player character in the embedded gaming application, where such player character allows the user to affect the game state in the game (e.g., enter game actions to affect the game state). If the number of player characters in the application is limited (e.g., the chess game application is limited to two players), for example if the second user is joining an active embedded session in which other member users have previously joined the embedded session and occupied all available player characters, there may be no player character positions available to the second user. If such an unavailability occurs, the second embedded application may determine a different user state (e.g., player character) for the second user and may notify the messaging application of the different user state. For example, a second user may be assigned an observer role, where the second user cannot enter actions to change a particular state of an embedded application or session. In some examples, an observer player of the embedded gaming application may be allowed to display the game state on their device, but not utilize user input to affect the game state. The viewer role of the media player or shared content document may be allowed to view the media items or lists without affecting the media playback or list items.
In some embodiments, if the selected persona of the second user is not available, the second user may be provided with a menu of available personas in the embedded session, and the second user may provide user input to select one or more of the available personas. In some embodiments, if a user role becomes available during an embedded session (e.g., a member user exits the embedded session or changes roles within the embedded session, such as from a player to a watcher), a member user that is not assigned the requested user role may be provided with such a newly available user role. In some embodiments, a particular user role may be removed or changed during an embedded session determined by the embedded application. For example, after the game has ended or after a particular round or phase of the game has ended, the player character may change to an observer character. During the embedded session, member users having the ability to perform such changes or authorizations in the embedded session may also change or reassign the user roles. In some embodiments, one or more of the various changes in user roles during the embedded session may be indicated in the data provided by the embedded application to the messaging application, and these changes may be indicated by the messaging application in the chat conversation of the chat interface (e.g., output as a textual description by all chat users or by only member users' devices).
In some embodiments, an indication that the second user has been assigned a different (newly assigned) user status, an indication that the user status or role has been removed or added to the embedded session, and/or an indication of any other change in the user status of the member users in the embedded session is output to a chat interface displayed on the chat device that is engaged in the chat conversation, or displayed on the member devices of the member users of the embedded session.
In one example, a first user initiates an embedded chess game application, and the first and second users agree that the second user will start a game as a player controlling a white chess via chat messages entered in a chat conversation. The message application parses the chat message to determine that the first user is assigned a player character to perform black chess and provides the user status to the embedded chess game application to begin playing with white chess controlled by the second user. Then, a third user (another member user) joins the embedded chess session, and the message application (or embedded chess application) automatically assigns the user roles of the watcher to the third user in the embedded session, since only two player roles are provided for the game session and these roles are occupied by the first user and the second user.
In some embodiments, if the participating users have provided user consent, the user information may include other information related to the member users of the session. For example, if the chat user (including the member user) has provided consent to obtain such geographic information (e.g., geographic coordinates determined by GPS or other location sensors of the member device, tags of geographic areas or regions, etc.), the geographic location of the device used by the member user may be obtained, for example, from the chat conversation via a second messaging application. In an example using the embedded travel itinerary application described above for three chat users, based on the user's chat message, the message application may specify to the embedded application that the travel context is "vacation in hawaii in 6 months" and that the respective geographic locations of the three chat user devices are specified so that the embedded application may determine a travel itinerary (e.g., travel route, airline flight, scheduled access, etc.) to a destination location based on the user's device location. In some embodiments, the location information may designate the location as a related category, such as "home" or "work" of the user. In some embodiments, the user information may include a local time (based on a local time zone) for each member user. For example, the embedded travel itinerary application may similarly use the local time to determine the travel itinerary for each user. In some examples, the embedded application may use the member user's location and/or time information to determine output information displayed in the embedded interface, e.g., travel itineraries, event subscriptions, written language of text output (e.g., subtitles, messages, etc.), regional customization of output, time-based notifications, and so forth. In various examples, accessing the location of the member user (via user consent) may enable the embedded application to use the shared location to provide output to a group of member users waiting for other member users at the restaurant, for example, as a status update for the member user's location, to provide the user's location in a race and fitness challenge, and/or to provide the child user's location for viewing by parent users of those children.
In some embodiments, the user information may include a current or network available data bandwidth of one or more of the member devices used by the member user, e.g., bandwidth, hysteresis, or other network connection characteristics of each member device to a session server implementing the embedded session and/or one or more member devices implementing the embedded session. In some examples, the embedded application may use the bandwidth information to cause a modification to the transmission of the input data received at the first user device and the first embedded application over the network. For example, the modified transmission may include different amounts of data to be transmitted to the first user device over the network, resulting in different data transmission rates to the first user device over the network, and/or resulting in compression of data (e.g., content data streams from a content server) transmitted from other devices to the first user device. In some examples, the embedded application may use bandwidth information to assign a particular user state (e.g., role) to a particular member user in the embedded session. For example, a high bandwidth (e.g., exceeding a threshold) may be suitable for characters that require data to be sent from the user device to other devices (e.g., a particular player user in a real-time game), while in a particular gaming application, a lower bandwidth may be more suitable for an observer player.
If consent by the associated chat user to access and use such data has been obtained, the other user information provided to the second embedded application may include other information including social networking information (e.g., posts posted to social networking services, ratings, comments, etc.), the history of the member's use of the embedded application (e.g., particular media items previously viewed in the embedded application, games previously played by the member user, and roles assigned to the member user in those games, win/lose records of the member user in previous games, dates and times of use of the previous embedded application, etc.).
In block 318, synchronization information may be received at the second device (e.g., from the session server and/or other member devices such as the first device) and the second embedded application is synchronized with the embedded session. In some embodiments, in block 308, synchronization information may be received along with an indication of the embedded session. For example, the synchronization information may include one or more states of respective embedded applications running on member devices of the embedded session, reference time information from the session server, and so forth. In some embodiments, synchronization information may be provided from a session server or other device capable of providing synchronization information to all member devices of an embedded session to enable embedded applications to synchronize with each other. In some examples, the session server receives updates to the embedded applications of the member devices based on user input (e.g., user playback commands for media items, game actions, modification of shared content documents, travel, etc.) or application events at those member devices (e.g., expiration of a timer, start of playing new media items in a queue, occurrence of game events, etc.), and sends synchronization information to other member devices. In some embodiments, the member devices may update a global synchronization value or timer stored on an accessible device such as a server to maintain synchronization with each other, an example of which is described with reference to fig. 5.
In some examples, the synchronization information may include a point in time (or a change in point in time) of a video or audio data segment currently being played in the embedded session, a change in state of a game being played in the embedded session, an update to a shared content document in the embedded session, and so forth. In another example, the synchronization information may include clock information of other member devices that may be used for synchronization of timing events in the embedded session. For example, the creation of enemies or treasures in a game may be synchronized among all member devices at a particular time, or member user inputs may be registered at (or relative to) a particular time to have an impact in the game. The synchronization time at which registration status occurs or changes in the embedded session may allow the recorded version of the embedded session to be played back later accurately by different member users. The precise timing event between the member devices also allows for competition between users (e.g., to determine which member user is the first player in the game to collect or select a particular item in the game environment).
In some embodiments, a leader device may be selected among the member devices (e.g., randomly, or based on network characteristics, e.g., a device with the lowest delay to a server handling synchronization of user devices, etc.) to allow synchronization of real-time events and outputs between embedded applications in an embedded session. For example, the leader device may be an authority to verify and propagate state changes to other member devices, e.g., instead of using a server system for such tasks. If the leader device is offline, the online member device selects a new leader device and when the previous leader device is online again, it is treated as a regular (non-leader) device because its leader state is revoked. Such a configuration of leader devices may allow multiple devices over a network to share an experience without using server-side synchronization and permissions.
In block 320, an embedded interface of the second embedded application is caused to be displayed by the second device. For example, similar to the above, an embedded interface may be displayed in association with the chat interface of the second messaging application. The embedded interface is a user interface of the second embedded application and allows output from the second embedded application to be displayed by the second device (e.g., in an embedded view of the embedded interface) and allows user input to be entered in the embedded interface and thereby provided to the second embedded application.
The embedded interface displays output from a second embedded application that is synchronized with other embedded applications of the member devices in the embedded session. For example, if a media item is being played in an embedded session, media items played by corresponding embedded applications on other member devices are also played by a second embedded application, synchronized with the member devices. Thus, if the second user has joined an embedded session in which the media item has been previously played for a period of time and is currently midway through its duration, the second embedded application plays the media item starting from the midway point. For example, the synchronization may provide the second user with an experience of sharing media items and other outputs of the embedded application with other member users.
In an example using an embedded travel itinerary application, the embedded application may provide an embedded interface that displays information about flights of the aircraft on a specified date from the geographic location of the member user's device to the travel destination. In some embodiments, customized airline flight information may be displayed for each member user in an embedded interface, where each embedded interface displays only the airline flight information at the location of the user viewing the information in the embedded interface.
In block 322, an indication is sent over the network that the second user has joined the embedded session. For example, the second messaging application may send an indication of the join event to the session server, and the session server may send the indication of the join event to the member device (rather than to the chat device that is not the member device). For example, the session server may send an indication to the first device, as described below with reference to fig. 4. In some embodiments, the second messaging application may send the indication directly to the member device.
During the embedded session, the second device may receive user input from the second user to the embedded application via the embedded interface and/or user input from the second user to the messaging application via the chat interface, as described herein. Input may also be received from other member devices, e.g., via a session server, and/or from one or more servers (e.g., synchronization and other updates to embedded applications from the session server, content data from a content server, etc.). The output may be displayed in an embedded interface and/or a chat interface.
If a user state (e.g., role) has been assigned to the second user within the embedded application and the embedded session, the embedded application may enable the second user to activate one or more functions of the embedded application associated with the assigned user state. For example, in an embedded gaming application, a user assigned a player character may be enabled to perform a game action with user input to affect the status of the game. The user assigned the observer role may be enabled to provide input to perform a viewing function in the game, e.g., such that different player scores, attributes, etc., are displayed with user input, but without affecting the game state. The user assigned the administrator character or referee character may be enabled to initiate a game, assign player users to different teams, judge a game, etc., without affecting the game state. In some embodiments, the member users may be assigned roles of passive observers or active observers. For example, the active observer state may allow a user to modify a state in the embedded application (e.g., game state, playback position of a media item, etc.), or modify some type of state (e.g., direct some type of game object, add comments but not change playback position, etc.), while the passive observer is prevented from modifying any such state. In some examples, the single-player game may allow the first user to become the principal angle of movement, facing obstacles, etc. in the gaming environment. Other member users may be assigned passive observer roles by default, or one or more passive observer users may choose to be assigned active observer roles, allowing them to affect the game state, e.g., instruct an enemy in the game to attack or assist the first player's role, directly assist the first player's role, click on the first player's role to slow down, etc.
In additional examples, a particular graphical interface of an embedded interface may be displayed on a member device based on a role that has been assigned to a user of that member device, while other member devices of an embedded session may display other graphical interfaces based on different roles (or lack of roles) of their member users. For example, different controls and functions may be displayed for different roles in different graphical interfaces. In some examples, only certain features of the embedded application may be accessible to a particular role. In an example of an embedded reservation application (e.g., similar to that described above), a first user launches the embedded reservation application and thus has a "subscriber" status (e.g., pays a reservation fee for reserving hotel rooms) that allows the user to complete the reservation. The first user selects subscription information such as destination and itinerary, and the embedded application shares the selected subscription information with the remaining member devices (e.g., devices including the second user) for display in the embedded interface of its embedded subscription application. The second user assists the first user in selecting a hotel room to subscribe by selecting or changing subscription information, which is synchronized on all member devices. In this example, only the first user device of the member device displays a "pay" button in its embedded interface because the first user has set up the embedded application/embedded session and has a subscription status. When the pay button is selected by user input, the data is caused to be sent to the server to complete the subscription.
In various embodiments, the "interactive card" may be displayed in a chat interface of a chat device of a chat conversation, such as a second user device. The interactive card may be a displayed information area or window that displays information and controls related to the event (user input options), output data (e.g., content data), and input from the member user provided in the embedded session of the chat conversation. The information may include text, images, video, audio output, movies, or other types of content data (e.g., captured and stored images of the output displayed in the embedded interface). In some embodiments, the interactive card may be displayed in a chat interface of the chat device, whether or not the chat device is a member device of the embedded conversation.
The interactive card may also include one or more displayed input controls that may be selected by user input to cause the associated action to be performed by the embedded application. When a control is selected by user input, parameters or parameters of the selected control and/or interactive card are provided to the embedded application, and the embedded application performs the relevant action. In some examples, the notification indicating the initiation of the embedded session as displayed in block 310 may be an interactive card displaying the above information that includes a join option (for non-member users) that, if selected, causes the user device to run the embedded application and join the embedded session. In some embodiments, one or more actions are run in the embedded application in response to the user joining the embedded session, as described above. In another example, the interactive card may include a displayed control that, when selected by user input, causes the embedded application to begin playing the media item, trigger an in-game action (e.g., accept a challenge by a different user, unlock the in-game item, etc.), and/or other actions. The embedded application may display a request in the interactive card to perform an associated action for confirmation from the user. In some embodiments, the information and options in the interactive card may be continually updated based on current inputs received from the member users (and/or chat users), current outputs provided by the embedded application, and current processing/status of the embedded application.
In some examples, the media item is being played in an embedded session of the media player embedded application and the interactive card is displayed in a chat interface of a chat device related to the playing of the media item. Information and options may be updated continuously based on the chat user's playback and comments to the media item for the chat conversation. For example, the interactive card may display an identification of each media item being played or queued for playback. The information and options in the interaction card may be continually updated based on the chat user's playback and comments on the media item for the chat conversation. For example, the card may display one or more of the following features: an identification (or number) of chat users who have viewed the media item (if consent has been obtained from those users), an identification (or number) of chat users who have reviewed the media item (if consent has been obtained from those users, as in block 518 below), a display option for commenting on the media item of the member device (e.g., as in block 518), and a display option that causes the card to be permanently displayed on the user device, for example, as a reminder to the user to play the media item. If multiple interactive cards are permanent, a carousel display of cards may be displayed that may be scrolled or rotated to view the multiple cards, e.g., one at a time. Such that the media item is played or reviewed in the chat conversation (e.g., as in block 518), the corresponding interactive card stored on each chat device is updated, which may be displayed in the chat interface of each chat device of the chat conversation. The interactive card indicates the chat user's most recent play and comment on the media item. In some embodiments, selecting the comment option of the interactive card by user input may cause an input field to be displayed, allowing the user to input comments to be displayed in the embedded interface during current and later playback of the media item (e.g., as in block 518), and/or comments to be displayed in the chat interface of the chat conversation during current and later playback of the media item.
In some embodiments, interactive cards associated with other types of embedded applications may be displayed in a chat interface. For example, if user consent has been obtained, the embedded gaming application and session may cause an interactive card to be displayed that indicates one or more of the following: the number of players and observers in the game, the identity of the member user, the current score of the player, the game object implemented, one or more images showing a screenshot of a game event or object or portion thereof, display options to enter comments or ratings for the game or particular player of the game (e.g., to display in a chat interface and/or in an embedded interface of the member device), display options to cause the card to be persistently displayed on the user device, e.g., as a reminder to the user to join an embedded session, etc. Similar information and display options may be displayed in the interactive card for providing embedded sessions for content documents, travel itineraries, bookings, shopping, etc.
In some embodiments, the second user exiting the embedded session may be implemented similar to joining the embedded session. For example, the second messaging application receives an indication that the second user is exiting the embedded session, such as by exiting the second embedded application, by exiting the chat conversation, or by exiting the second messaging application. The second messaging application sends information (e.g., via a server) to the other member device indicating that the second user is exiting so that other (corresponding) embedded applications running for the other member device can update their status (e.g., remove the user identification of the second user from their embedded interface, remove the second user as a participant in an embedded session, etc.).
Fig. 4 is a flow chart illustrating an example method 400 in which the first device of fig. 2 processes an event that a second device has joined an embedded session. In this example, method 400 illustrates blocks performed at a first device in response to a second user joining an embedded session as described with reference to fig. 3.
In block 402, it is checked whether user consent (e.g., user permissions) to use user data in the implementation of method 400 has been obtained. For example, the user data may include messages sent or received by the user, e.g., using the messaging application 103, user preferences, user biometric information, user characteristics (identification, name, age, gender, occupation, etc.), information about the user's social network and contacts, social and other types of actions and activities, content, ratings, comments created or submitted by the user, the user's current location, historical user data, images generated, received and/or accessed by the user, videos viewed or shared by the user, and so forth. In some embodiments, one or more blocks of the methods described herein may use such user data.
If user consent has been obtained from the relevant user whose user data was available in method 400, then in block 404 it is determined that the blocks of the method herein can be implemented with the possible use of user data as described for those blocks, and the method continues to block 408. If no user consent is obtained, then in block 406 it is determined that the block is to be implemented without using user data, and the method continues to block 408. In some embodiments, if user consent is not obtained, the block is implemented without using user data and utilizing synthesized data and/or data that is commonly or publicly accessible and publicly available.
In block 408, an indication is received at the first device over the network indicating that the second user and the second device have connected to (joined) the embedded session. For example, the indication may indicate that the second device has downloaded and/or is running a corresponding embedded application (or is processing) for the embedded session, e.g., as in block 314 of fig. 3, and/or that the embedded application has been synchronized (or is synchronizing) with the embedded session, e.g., as in block 318 of fig. 3. For example, the indication may include or be derived from notification information as described in block 314 of FIG. 3. In some embodiments, the first messaging application may receive an indication, which in some embodiments may include notification information, as described. The indication may include information indicating a joining event, a user identification of the second user, and any other options selected by or provided to the second user (e.g., user status in the embedded application, etc.). In some embodiments, the first messaging application previously acquired user identification information for the chat conversation of the second user, e.g., to display the user identification of the second user in a chat interface of the first device. In some embodiments, the indication is received from a server system, e.g., a session server that receives notification information from the second device in block 314 of FIG. 3. In some embodiments, the indication (e.g., peer-to-peer configuration) is received at the first device directly from the second device.
In block 410, the first messaging application provides a data update to the first embedded application, wherein the update indicates that the second user joined the embedded session. The embedded application designates the second user as a member user of the embedded session. For example, the update may include user information (e.g., a user identification of the second user) and an indication to add the second user as a participant in the embedded session. In some embodiments, the first messaging application has obtained the user identification of the second user and other user information in the chat conversation. In some examples, the user identification may be a chat identification of a second user participating in the chat conversation.
If the first messaging application has obtained consent to do so from the second user, the first messaging application may provide user information for the particular user (e.g., the second user) to the first embedded application. For example, in some embodiments, such consent may be included in the user information provided for the chat conversation. If no consent is obtained from the second user, no user information is provided to the first embedded application. In some embodiments, the first messaging application (or server application) may anonymize or partially anonymize the user information such that the information does not describe the second user, nor is associated with (or only partially describes or only partially associates with) the second user. For example, the second user chat identifier may be changed to a common name or placeholder name, such as "user 1", "friend 1", the first letter of the second user, the name of the second user, and so forth. In additional examples, the user identification may be the real name of the second user name, the user name previously registered in the messaging application, the user name previously registered in the contact list, or other data stored on and retrieved from the second user device (if consent has been obtained from the second user), the user name previously registered in the embedded application, the placeholder name, and the like. This information may be provided to and/or determined by the embedded application as a user identification for the embedded session. In some examples, the application may select a user name to display to other member users in one or more particular contexts of the embedded application and the embedded session, where different user names may be displayed in different contexts. For example, the context may include a name used in the messaging application and chat interface, a name attached to a message of a second user composed in the messaging application, a name used in the embedded application and its content data, a name attachable to a chat message or a system message generated by the embedded application, and so forth.
In some embodiments, if consent to use such information has been obtained from the second user, the user information may include a user status (e.g., role) selected by or provided to the second user, a geographic location of the second device, and/or other information related to the second user. The first embedded application may update its processing based on the addition of the second user, e.g., displaying the user identification of the second user in the embedded interface, checking input from the second user, etc. In some embodiments, the first messaging application also designates the second user as a member user of the embedded session, e.g., updates its own list of session users of the embedded session to add the second user identification.
In block 412, the first embedded application (and/or the first messaging application) may determine one or more user states of the second user. In some embodiments, for example, in block 410, a user status may be determined based on user information received from the first messaging application. For example, the user information may include a user status of the second user in the embedded session. The user state may have been selected by the second user and the information indicating the selection may have been provided to the first embedded application by the first messaging application. For example, the second user may have selected a user role of "watcher" of the gaming embedded application, and the first embedded application assigns the role to the second user.
In some embodiments, the first embedded application (and/or a corresponding embedded application running on the other member device) may generate a user state or role. In some embodiments, a server (e.g., a session server) may generate a user state or role and provide the determined user state to the first messaging application and the first embedded application. In some examples, the user state may be assigned based at least in part on one or more current states of the first embedded application and/or the embedded session. For example, if one or more characters are available for allocation to a joining user, a second user (joining user) may be automatically allocated to the available characters (e.g., players in the game). If the embedded session does not have any available selection roles, the second user may be assigned to another (e.g., default) role. For example, if the second user selects an assigned player character but no player character is available, the second user may be assigned an observer character. In some embodiments, for example, if privacy and security measures are performed on these states and data, the particular states and/or data from previous embedded sessions in which the particular user has participated may be stored (e.g., on a server), such as user states and roles assigned to the particular user in the previous embedded session using the same embedded application. In such embodiments, if second user consent has been obtained for use of such user data, the use history of the second user's embedded application may be used to determine the user state or role of the second user. For example, if the second user is a referee character in a threshold number of previous embedded sessions using the embedded application, the character may be automatically assigned to the second user. In some embodiments, a prompt may be sent to the second device (e.g., by the member device and/or session server) to allow the second user to accept or reject a particular user state or role that has been automatically assigned to the second user in the embedded session.
In some embodiments, other user states and roles may be determined for users in the embedded session. For example, if a user initiates an embedded session (e.g., a first user), the user may be assigned a "controller" or "leader" role, where the controller is the only user that is able to modify data processed in the embedded session (e.g., change a playback point in a media item, change data in a shared content document, etc.). In some examples, similar to the embedded session, a player in a game in which the second user is an embedded application may be assigned an obstacle or advantage based on the history of the second user in a previous game.
In some embodiments, the user status may be determined based on messages and other user inputs provided in the chat conversation from which the embedded session was initiated. For example, the message application may parse the text message of the second user (or a text message derived from the second user's voice input) to match predefined words or phrases, and/or use other language processing techniques to determine the semantic meaning of the user input to the chat conversation. For example, the second user may have previously entered "let us play-! "or" I would watch your two ", indicating that the second user would like to play a player role or an observer role, respectively, in the launched embedded application game. The second user may enter "i will give you the place in the video," indicating that the second user should be assigned a controller role that can control the playback position in the video played in the embedded session.
In some embodiments, a member user assigned a particular state or role in an embedded session may have a changed state or role and/or may choose to change his or her state or role to a different state or role while continuing to be a member user. For example, a user assigned a player character in an embedded session may automatically become an observer user based on certain conditions, such as the user's player character having been eliminated in the game, becoming a "ghost" that can only be observed and moved in the game environment but not acted upon to change objects in the environment, or such as in a 2-player game, where the player is offline for longer than a threshold period of time and loses player status, while the online observer user is automatically assigned a player character by the embedded application. In another example, in a round-based game where player users are active only during their rounds, players may automatically become observer players when their rounds are currently inactive. In other examples, predefined additional user states or roles may become permanently or temporarily available in the embedded session, and/or existing user states or roles may become permanently or temporarily unavailable in the embedded session during the embedded session. For example, such user state or role changes may occur based on: a change in the number of member users currently in the embedded session, the length of time the session has been active, the member user indicating that he or she is doing an external task such as answering a phone, a particular event occurring in the embedded application (game event, completion of a shared list, etc.), etc.
In some additional example embodiments, a lobby (lobby) may be provided in the embedded application and embedded interface, for example, listing the display area of member users that have not yet had an assigned role. For example, such users may wait for an assigned user state or character in a game, e.g., wait for the game to end, wait for a player user to change to a non-player character, etc. In some examples, a subset of member users may be associated with a sub-session within an embedded session, where the subset of users interact via an embedded application within the sub-session and other member users have different or no interaction capabilities. For example, an embedded session may include multiple sub-sessions, each associated with a different subset of member users. In some examples, each sub-session may be a particular game within a tournament structure running throughout the embedded session, where each game runs simultaneously and the winners of each game play each other in the new game. In some examples, two or more users in a lobby may be associated with each other and/or assigned a particular role in a sub-session (e.g., personal game) initiated in an embedded session. Team-based embodiments may also be provided in which users joining an embedded session are assigned to existing teams in a particular game, and each team has multiple players. In some examples, the embedded session may provide multiple games running in parallel, a single game having two players and N observers, a single game having two teams and each team having N players, etc. In some embodiments, multiple such sub-sessions may be implemented as separate concurrent embedded sessions, each provided by a single embedded application.
In block 414, the first embedded application updates its output in the embedded interface based on the addition of the second user. For example, the second user identifier may be displayed in an embedded interface, along with a second user status (user role, etc.).
In block 416, the first embedded application provides the determined user status information to the first messaging application. For example, if the first embedded application determines user role and/or other user status information, it is provided to the first messaging application. In some embodiments, the first messaging application may update a list of conversations for the user, output user status information in a chat interface, and the like.
In some embodiments, the second user exiting the embedded session may be implemented similar to joining the embedded session. For example, the first device may receive an indication over the network that the second user is exiting the embedded session (e.g., by exiting the second embedded application, by exiting the chat conversation, or by exiting the second messaging application). The first messaging application sends information to the first embedded application indicating that the second user is exiting so that the first embedded application can update its status (e.g., remove the user identification of the second user from the embedded interface and no longer expect input from the second user).
In some embodiments, the user device may cache the state of the embedded application to enable an offline mode, wherein the user device (and/or messaging application) is no longer visible to other user devices and server devices over the network. When the user device (and/or message application) comes back online, the cache state of the embedded application may be used to synchronize the embedded application with other member devices and corresponding embedded applications and provide merge/conflict resolution. In some examples, the embedded application may first write any state changes to storage on the user device before the user device loses network connectivity. When the user device is online, the local state is always synchronized with the server global state stored on the server, where the global state is shared by instances of the embedded application running on member devices in the same chat session. Upon loss of network connection, the local state may be accessed and written by the embedded application on the user device, but no client-to-server synchronization occurs. Once the network connection is restored to the user device, the local state is synchronized with the global state (e.g., pulling changes on the server side and pushing changes on the client side) and merging occurs, if necessary, using conflict resolution (e.g., using last-write-wins) policy or other merging policy). This provides limited offline support, for example, it provides protection against short-term network outages common between mobile devices during cell tower handoffs or environmental changes (such as entering the ground, etc.). If the user goes offline for a longer period of time, the local state on the user device may deviate significantly from the server global state.
FIG. 5 is a flow diagram illustrating an example method 500 of providing output of a media item using an embedded application associated with a messaging application. In some examples, method 500 may be implemented similar to one or more blocks of fig. 2, in which an embedded application is launched from a chat conversation and data is processed in an embedded session involving a chat user.
In block 502, it is checked whether user consent (e.g., user permissions) has been obtained to use the user data in the implementation of method 500. For example, the user data may include messages sent or received by the user, e.g., using the messaging application 103, user preferences, user biometric information, user characteristics (identification, name, age, gender, occupation, etc.), information about the user's social network and contacts, social and other types of actions and activities, content, ratings, opinion created or submitted by the user, the user's current location, historical user data, images generated, received and/or accessed by the user, videos viewed or shared by the user, and so forth. In some embodiments, one or more blocks of the methods described herein may use such user data.
If user consent has been obtained from the relevant user whose user data was available in method 500, then in block 504, the blocks of determining the method herein may be implemented where possible using user data as described for those blocks, and the method continues to block 508. If no user consent is obtained, then in block 506 it is determined that the block is to be implemented without using user data, and the method continues to block 508. In some embodiments, if user consent is not obtained, the block is implemented without using user data and utilizing synthesized data and/or data that is commonly or publicly accessible and publicly available.
In block 508, a chat user selection of a media item is obtained, the selection instructing playback (e.g., output) of the media item by the user device. Chat users participate in a chat conversation with one or more other chat users using devices connected to the user devices and to each other over a network, wherein the chat conversation is displayed in a chat interface by devices similar to the first and second users and the first and second devices described above. The media items may be selected in any of a variety of ways. For example, the identifiers of the media items may be entered by text, voice input, selection of a display element, or items from a display menu, etc. In some embodiments, media items are selected from within the chat interface, e.g., through text commands, interface elements displayed in the chat interface, etc. In some embodiments, user input may also explicitly indicate sharing of media items with a chat conversation by selecting or entering a sharing option (e.g., interface element, text command or parameter, etc.). Sharing the media item may include making the media item available for playback on other devices by providing an embedded session to other chat users of the chat conversation. When a media item output is selected, some embodiments may automatically provide the media item in an embedded session in a chat conversation. In some embodiments, as described in block 510, after the embedded media player application is launched, a media item may be selected within the embedded interface. In some embodiments, a robotic program may be used to select media items, some examples of which are described below. The method continues to block 510.
In block 510, an embedded media player application is run (e.g., launched) in response to the selection of the media item. The embedded media player application is configured to output the selected media item. In some examples, the embedded media player application is downloaded from a server to the user device similar to that described above and runs at least partially on the user device. In some embodiments, the embedded media player application may run on a device that communicates, in part or in whole, with a user device, such as a server, and provide data for display on the user device (e.g., data describing the embedded interface). The embedded media player application causes an associated embedded interface to be displayed on the user device in association with the chat interface (e.g., similar to that described above) such that one or more chat messages in the chat interface can be displayed during display of the embedded interface. In some embodiments, the embedded media player application may be launched in response to user input instructing the embedded application to run without specifying the media item to be played. For example, the media item may then be selected by user input provided to the embedded interface, e.g., after the user input browses a displayed menu of available media items in the embedded interface, etc. The method continues to block 512.
In block 512, other chat users are enabled to join or leave an embedded session that is initiated in association with the start of an embedded media player application, where the embedded session may include playback of a media item. For example, a notification may be sent to a chat device that is engaged in a chat conversation, and one or more chat users may join the embedded session as member users, similar to that described above with respect to fig. 2-4. The method continues to block 514.
In block 514, playback of the selected media item is performed in an embedded interface provided by the embedded media player application on a display of the user device. For example, after the media item is selected in block 510, playback is initiated at the beginning of the content data sequence of the media item (e.g., the first frame of the video data segment and/or the first portion of the audio segment). In some examples, playback may include displaying frames of video data and/or corresponding audio data in an embedded interface as audio output from a speaker of the user device. In some examples, playback may include playing a track of video and/or audio, and playback location may refer to data currently displayed or output at a current point in the track. In some further examples, for example, in a 3D environment displaying a virtual reality environment or other display, playback may have a playback position that references the direction and/or orientation of a view point (or other reference view) displayed in the 3D environment in addition to or instead of a point in time. In some cases, media item content data may be retrieved from local storage of the user device (e.g., memory and other storage included in the user device). In some cases, the media item content data may be received over a network, for example, as a data stream from another device, such as content server 154, a different member device, or the like. In some embodiments, playback of the video media item may default to mute audio and display a talking subtitle (e.g., subtitle data is included in the received video data), where the user may choose to effect audio output of the video data.
Playback of the media item occurs on other member devices of the embedded session. In some embodiments, a server (e.g., a session server or content server) may manage playback of media items in an embedded session. In some embodiments, the content server may stream content data to a session server or other server that manages embedded sessions and sends separate content data streams to each member device. For example, the session server may send any commands received from the member devices to the content server, or may process the commands into specific commands for the content server. In some embodiments, the content server may cause content data to flow independently to each member device of the embedded session, and may receive commands based on user input from one or more member devices. Changes made to playback based on the command may be provided in all streams to the member device (e.g., in subsequent blocks of method 500).
Playback is synchronized between member devices. In some embodiments, synchronization may be managed by one or more servers. For example, a content server providing media items as data streams to each member device may synchronize each data stream using synchronization data (e.g., reference locations) such that playback on each member device is synchronized. In some embodiments, the session server may store a reference location (or other synchronization data), such as a reference frame or time location within the media item data sequence, that may be accessed by the member device and/or sent by the session server to the member device. For example, playback of media data on each member device may be set to a frame (or point in time) equal to the reference location. In some embodiments, synchronization may be managed by one or more member devices. For example, one of the member devices (e.g., the user device) may be a reference device that sends synchronization data (e.g., a reference location) to the other member device that indicates a current location in the media data being played on the user device. Other member devices may adjust playback of media items on these devices to synchronize with the reference location of the reference device.
In some examples, a shared playback timer may be used that may be stored and accessed on a database of devices accessible to all member devices (e.g., a session server, a content server, or one of the member devices). For example, a single reference value may serve as an authoritative playback location (e.g., a global playback location) to which all member devices should be synchronized. In some embodiments, a tolerance (e.g., a threshold amount of time) between the global playback position and the playback position on the member device may be allowed, e.g., plus or minus 5 seconds. If the play position of the member device is at a time greater than the tolerance amount, the play position is updated to a global play position.
In some embodiments, multiple or all member devices may update the shared timer (global playback position) in an average manner. For example, during playback, each member device attempts to synchronize with the server every second (or other unit of time), which is a "synchronization point. At each synchronization point, each member device attempts to increase the global playback position. In some examples, the increase may be determined using the following formula:
Where g is the global playback position and g' is the incremental global playback position. For example, the device previous playback position is at the previous synchronization point, and the total number of member devices is the number of member devices in the embedded media session (e.g., if all member devices are capable of updating the global playback position). Thus, each device updates the global playback position by a small amount based on the increase in playback position of the device from its last synchronization point divided by the number of member devices. If the difference between the increased playback position g 'and the [ device current playback position ] is greater than the tolerance value, the device maintains or changes the playback position to g (and does not submit g'). Otherwise, the device submits g' to the database. The method continues to block 516.
In block 516, user input is received from a member user in the embedded interface. For example, user input may be received from a user of a member device that initiated the embedded session in block 508, or user input may be received from a different member user of a different member device. User input may be received in the embedded interface, for example, selection of a displayed interface element, such as a button, icon, slider control, or the like. In some cases, user input may be received or partially received in a chat interface. For example, user input may select an option to directly input user comments onto the displayed media item, and further user input may then input user comments in the chat interface, e.g., as text, emoticons, ratings symbols, etc. The method continues to block 518.
In block 518, it is checked whether the received user input is a user comment associated with the played media item. For example, such associated user comments are entered in the embedded interface such that the user comments are displayed during the display of the media item. For example, user comments may be displayed during playback for a predefined amount of time after being entered. In some examples, user comments may be superimposed on the display of video data or otherwise displayed in an embedded interface. In some embodiments, as described above, the content of the user comment may be entered in the chat interface and then displayed in the embedded interface. For example, user input may select an option in the embedded interface to enter a comment, which is then entered through the chat interface. In some embodiments, the user input may also select or point to a particular location in the display area of the embedded interface where the user comment is displayed, such as a location in a display window or in a view of the media item. For example, the location may be specified as coordinates of the location of a comment in a displayed view of a video, image, or other media item. In a further example, the user may toggle (e.g., click) or continuously select one or more of a plurality of controls (e.g., emoticons buttons) associated with the user's emotion or emotion displayed in the chat interface or embedded interface. When the control is selected by the user or until the user again toggles (e.g., clicks on) the control, the selection causes an associated image or icon (e.g., emoticon) to be displayed in the embedded interface (as described below), the associated image or icon (e.g., emoticon) representing the emotion of the user at that time in response to playback of the media item.
If the user input is a user comment, then in block 520 the user comment is stored in association with an identification of the associated portion of the media item that was displayed when the comment was input and/or displayed. In some embodiments, the identification of the associated portion includes an identification of the media item (e.g., title, identification value, etc. of the media item). For example, the identification of the associated portion of the media item may indicate the context of the media item that the user reviewed. In some examples, if a user comment is entered 1 minute after starting playback of a 5 minute video clip, the associated portion of the media item is the content data of the media item at the 1 minute point in time of the video clip (e.g., a threshold amount of data before and/or after the 1 minute point in time). In some examples, the portion may be identified by a point in time, for example, indicating where the portion begins or indicating a middle point of the portion. In some embodiments, the identification may include a duration of the portion. In some embodiments, an identification of the user providing the comment (e.g., an identification of the user displayed in the embedded session, or a chat identification in the chat conversation) may be stored. In some embodiments, an indication of the location of the user comment relative to the display area of the media item may be stored in association with the user comment. For example, coordinates referencing an area of a displayed embedded interface window, or an area of a media display window in the embedded interface, may indicate to a user where to locate a user comment. The method continues to block 522.
In block 522, an identification of the associated chat conversation is stored in association with the user comment. This allows, for example, user comments (and other user comments entered and stored for an embedded application associated with a chat conversation) to be retrieved and displayed during playback of media items for users of the same chat conversation later (e.g., member users from the same group of chat users participating in the chat conversation when the user comments were entered). For future playback of media items in an embedded interface associated with a different, second chat conversation, user comments will not be retrieved and will not be displayed. For example, the second chat conversation may have its own set of associated user comments displayed during playback of the media item that are input to an embedded media player application associated with the second chat conversation. In some embodiments, user comments are not retrieved and displayed for embedded playback of media items later in other chat conversations or by other users.
In block 524, the user comment is displayed in the embedded interface of the member device that received the user comment and the user comment is sent to the other member device during the current playback (e.g., via a messaging application on the user device) such that the user comment is displayed in the embedded interface of the other member device. In some examples, the user comment is displayed for a predetermined period of time during playback of the media item before being removed from display of the embedded interface. The time period may be determined based on user preferences, settings of the embedded session, and the like. In some embodiments, in response to a user selection of an associated control (e.g., toggling or continuously pressing a display control as described above), user comments are displayed and removed from the display when the user stops selecting the control or toggles the control again. The method may continue to block 512 to enable the user to join or leave the embedded session and perform playback of the media item in block 514.
If it is determined in block 518 that the user input is not a user comment, the method continues to block 526 where it is checked whether the user input is a selection of a search point in the media item. In some examples, the user may select the search point on a graphical progress bar or timeline displayed in the embedded interface that represents the entire play length of the media item. In other embodiments, the search point may be selected in other ways, such as by receiving input specifying a particular time along the timeline, by receiving a selection of a fast forward or rewind control that selects to move playback forward or backward along the timeline, and so forth.
If the user input is a selection of a search point, then in block 528 the playback position of the media item is updated to the search point. For example, in some cases where the search point has moved the playback position from a position prior to the playback position, playback of the media item may be interrupted from its previous position and continued at the updated search point. The method continues to block 530.
In block 530, the search point information is sent to synchronize playback of the device. For example, information describing the search point, such as a time value or other value of the adjusted search point, may be sent to other member devices (e.g., via a messaging application) to synchronize playback of media items on those devices with playback on member devices that received updated search points from the user. In some embodiments using a shared timer and/or global playback position as described above, the member device overwrites the value of global playback position (g) with the new value of playback position at the search point. The method may then continue to block 512 to enable the user to join or leave the embedded session and perform playback of the media item in block 514.
If it is determined in block 526 that the user input did not select a search point, the method continues to block 532 where one or more device or application functions may be performed based on the received user input, if applicable. In some cases, the method may continue to block 512. In some embodiments, in response to playback of the later media item, the method continues to block 534.
In block 534, during later playback of the media item in the same (e.g., ongoing) chat conversation, the associated user comment stored in association with the media item and the chat conversation is displayed. During later playback, the associated user comment may be displayed in the embedded interface. For example, in some embodiments, if the media item receives one or more user comments stored in association with the media item in blocks 518 through 524, the associated user comment may be displayed in connection with later playback of the associated portion of the media item by the chat user. In some examples, if a media item is played in an embedded interface in a chat conversation (e.g., a chat user having the same conversation ID, or having the same participation as when the comment was originally entered, or having a subset of the original chat user) and a portion of the media item associated with one or more user comments is displayed, the associated user comment is retrieved from storage and displayed in the embedded interface with the associated media item portion. In some examples, if the interface locations of the user comments have been stored, the associated user comments may be displayed at the same location in the embedded interface where they were entered, e.g., at the same coordinates in the playback window. In some examples, the associated user comment may be removed from the embedded interface after a predetermined duration or amount of media item data has been played. In some embodiments, user comments may also or alternatively be displayed in the chat conversation of the chat interface during later playback, for example, as chat messages. In some embodiments, the user comment may be displayed as a list below or beside the display of the media item during playback, or may be accessed through a control on the playback interface in the embedded interface (e.g., switching between a comment view and a playback view).
In a further example, as described above, when a user continuously selects or switches controls, user comments may have been stored in association with the playback period of the media item, and these user comments may represent the user's emotion and ideas (e.g., by emoticons, images, etc.) during playback of the respective portion of the media item. Utilizing a plurality of such user comments stored from inputs from a plurality of users previously viewing the media item allows for synchronization of ideas and emotional states of member users viewing and commenting on the media item simultaneously. The user's comments on the corresponding portion of the media item may be displayed as a mark or icon on a time bar or as an overlay on the display of the media item (e.g., displayed through a video frame), where the user's comments may be displayed in their entirety upon selection of the associated mark or icon. Such user comments may register the user's ideas and emotional state changes during replay (later playback) of the media item by the same or different users within the same chat conversation.
In some embodiments, a save feature may be provided to allow a user to save a played media item for later playback. This is useful for media items (e.g., movies or television programs) of relatively long duration that would not normally be viewed in a chat conversation. In some examples, a user may be allowed access to a repository of associated unplayed media items through provided user input, e.g., a repository stored on a user device and/or server (e.g., a session server or message server), which allows the user to play media items at a desired time, play all in a row, etc. For example, the saved media items may have been previously played by other chat users and the users have not participated in those embedded sessions.
In some examples, each media item played in the embedded session (e.g., initiated by a different chat user) may be associated with a display option (e.g., UI element) in the chat interface and/or the embedded interface to save the media item for later playback. For example, the option may be displayed in association with a notification received by the user device indicating that the embedded session is active (and may also include a join option), as described with reference to fig. 2-3. The option may also or alternatively be displayed within the embedded interface, for example, adjacent to or otherwise associated with a displayed list of identifications of media items that are and will be played in the embedded application. Selection of an option by user input causes the media item to be stored in a queue associated with the selected user. In some examples, the media items may be stored in different chat conversations in which the user and a particular bot are engaged. In some embodiments, the user may request that all media items initiated by other chat users in an embedded conversation in the chat conversation be automatically saved. Any media items stored in the queue may be later selected and played in an embedded session of an embedded media player application that is launched to play the media items. In some embodiments, the embedded interface and/or chat interface may receive comments from the user during later playback, wherein the comments are displayed in the embedded interface and/or a chat conversation sent and provided to the initially played media item. In some examples, when a media item is selected from the queue for later playback, a comment control is displayed to enable a comment to the selected media item to be entered by the user. In some embodiments, selection of the comment control may display an initial chat conversation in which media item links are inserted as messages and enable a user to compose comment messages in the chat conversation. In some embodiments, the link to the saved or played media item may be displayed as a selectable message in the chat conversation (e.g., an image of a video with play button, or a text message) such that selection of the message by the chat user causes the media player embedded application to be launched and the selected media item to be played. Some embodiments may provide similar save features for other types of content data output in other types of embedded applications, such as game data displayed over time (e.g., to record a particular play of a game), document data, travel itinerary, etc.
In various example embodiments that may use the above features, a selection of a media item is received in a first chat conversation that includes a plurality of participants. For example, a chat conversation may be conducted on a plurality of user devices connected through a network. The media items may be provided by a user device and/or a server connected to one or more user devices via a network. Playback of the media item is initiated in the first chat conversation such that the media item is displayed by the user device of the participant. A comment is received from the first participant, the comment being associated with the media item and with a particular portion of the media item. The comment is stored and, after storing the comment, the user device of the second participant is detected to display a particular portion of the media item. In response to detecting that the user device of the second participant is displaying the particular portion, the comment is caused to be displayed by the user device of the second participant.
Features for these embodiments additionally include displaying, by a user device of the second participant, the comment in response to determining that the second participant is a participant of the first chat conversation in which the first participant is participating at the time the comment was received. Storing the comment may include storing identification information associated with the comment, wherein the identification information includes an identification of the first chat conversation. In some examples, the identification information may also include an identification of the media item, as well as an identification of a particular portion of the media item. The comments may include ratings and/or user comments. In some examples, playback of media items in a first chat session is synchronized between user devices of participants, for example, by providing a reference number accessible to the user devices over a network, wherein each user device attempts to synchronize with the reference number at regular intervals.
In a further example, initiating playback may be performed on a first user device of the user devices, and a notification may be provided to one or more other user devices that playback of the media item has been initiated by the first user device. The other user devices send data (and/or requests) to join the playback and the other user devices are added to the embedded session that includes the first client device. In response to adding the user device, playback of the media item is synchronized on the other user device to a current playback position on the first client device. In another example, initiating playback of the media item includes displaying data of the media item in association with a chat conversation provided by the messaging application in an embedded interface displayed on each user device. The embedded interface is provided by an embedded application running in association with the messaging application.
In some example embodiments, a selection of a media item is received at a first client device from a first participant of participants in a chat conversation. A first command is sent to one or more client devices associated with the participant to initiate playback of the media item. User input is received indicating a search point in a media item on a second client device from a second participant. In response to user input, a second command is sent to one or more client devices associated with the plurality of participants to update playback of the media item to the search point.
For example, the media item may be a first media item. An input selecting a second media item may be received from a second participant and the second media item may be added to a playlist queue indicating a playback order of the first media item and the second media item. Synchronization of playback of the media item may be performed for the first client device and the one or more client devices, including updating a global value indicating a playback location. In some embodiments, a notification is provided to one or more client devices associated with a plurality of participants that playback of a media item has been initiated, an indication is received that the one or more client devices are to join the playback, an indication is added to an embedded session that includes a first client device, and an indication is synchronized, on the one or more client devices, of playback of the media item to a current playback position on the first client device in response to the one or more client devices being added to the session. In some examples, initiating playback of the media item in the first chat conversation includes displaying data of the media item in association with the chat conversation provided by the messaging application in an embedded interface displayed on each user device.
FIG. 6 is a flow chart illustrating another example method 600 of providing output of an embedded application in association with a messaging application. In some examples, method 600 may be implemented similar to one or more blocks of fig. 2, where an embedded application is launched from a chat conversation and data is processed in an embedded session involving a chat user.
In block 602, it is checked whether user consent (e.g., user permissions) has been obtained to use the user data in the implementation of method 600. For example, the user data may include messages sent or received by the user, e.g., using the messaging application 103, user preferences, user biometric information, user characteristics (identification, name, age, gender, occupation, etc.), information about the user's social network and contacts, social and other types of actions and activities, content, ratings, opinion created or submitted by the user, the user's current location, historical user data, images generated, received and/or accessed by the user, videos viewed or shared by the user, and so forth. In some embodiments, one or more blocks of the methods described herein may use such user data.
If user consent has been obtained from the relevant user whose user data was available in method 600, then in block 604, the block of determining the method here may be implemented where user data is likely to be used, and the method continues to block 608. If no user consent is obtained, then in block 606 it is determined that the block is to be implemented without using user data, and the method continues to block 608. In some embodiments, if user consent is not obtained, the block is implemented without using user data and utilizing synthesized data and/or data that is commonly or publicly accessible and publicly available.
In block 608, the embedded application has been launched and run to provide a display output in an embedded interface on a user device associated with a messaging application that provides a chat conversation, wherein the user device is one of a plurality of member devices participating in the chat conversation that have joined an embedded session associated with an embedded gaming application, similar to that described above with respect to fig. 2-4. The method continues to block 610.
In block 610, it is determined whether local input has been received to an embedded application running on a user device. For example, the local input may include user input received from a user of a user device on which the embedded application is running. If a local input has been received, the method continues to block 612 where one or more states of the embedded application are updated based on the local input. For example, the local input may include one or more commands to the embedded application that cause one or more application states to be changed. In this example, the application state may include a state updated in all embedded applications of the member devices of the embedded session. For example, in a gaming application, the update may be a game state, e.g., a change in the location of one or more displayed game objects, a change in a score, etc. In a media player application, an update may be to play a playback characteristic of a media item, e.g., change playback position, stop, pause, rewind, fast forward, etc. In some cases, the state updated at the user device may not be updated at the other member devices, e.g., if the view on each member device is independently controlled by the user of that device in that particular embedded application, the changes in the environment view (e.g., game environment) displayed in the embedded interface may not be updated at the other member devices. The method continues to block 614.
In block 614, if the update status is of a type that is updated between member devices, the update status is sent to other member devices of the embedded session. For example, the embedded application may provide data describing the update status to the messaging application, and the messaging application may transmit the data to other member devices of the embedded session. The method continues to block 616.
If no local input is received in block 610, or after block 614, the method continues to block 616 where it is determined whether input (e.g., remote input) has been received from one or more other member devices of the embedded session over the network. If such input has been received, the method continues to block 618 where the application state is updated based on the input. For example, the input may indicate an updated application state of a corresponding embedded application on a different member device and update the application state of the embedded device on the user device to synchronize with other member devices. The method continues to block 620.
If no input is received in block 616 or after block 618, the method continues to block 620 where it is determined whether one or more message conditions have occurred in the embedded application or the message application for one or more non-user application objects provided in the application environment. For example, the application environment may be a gaming environment and the one or more non-user application objects may represent, for example, characters or entities in the gaming environment that are not controlled by any player user in the embedded session, e.g., non-player gaming entities with which a player user of the game may interact in the gaming environment. In another example, an application object (game object) may include a non-player game character of a player user playing with or against a player user of a game, such as a simulated opponent or team member. In another example, the application environment may be a media player environment that displays media items, and the non-user application object may be a character in the displayed content data (e.g., a character in a movie or image). In some examples, the application object may be a hypothetical character or persona employed by the bot and displayed as a character.
Non-user application objects may be enabled to output messages. For example, if the application object is a character, the message may be consistent with the actions or roles of the character in the embedded application and session. In some embodiments, a plurality of different application objects may be implemented in an embedded session that may output different types of messages.
One or more message conditions may be predefined and stored and may be checked during the running of the embedded application. If a message condition occurs, the message condition may cause the associated application object to output a chat message. For example, a particular application object may be associated with one or more message conditions such that if one or more message conditions occur (or if any of the one or more message conditions occur), the associated application object is designated to output a predefined message or message to the chat conversation that is determined based on the current application state, the current member user, and the like. Various message conditions and/or message condition types may be defined to trigger the output of a message by one or more associated non-user application objects. Message conditions may include, for example, events that occur in the application environment that affect the application object (e.g., player-controlled objects conflict with the application object, a user entering a request for an application role, etc.). Message conditions may include, for example, one or more member users joining or exiting an embedded session. Message conditions may include, for example, user actions against or helping a particular role in the application environment.
In some embodiments, the message condition may include entering a particular chat message or a particular type of chat message in a chat conversation by a member user. For example, an incoming chat message may refer to an application object. In some examples, if a player user in a game session enters a message in a chat conversation, such as "let us follow the left enemy," the message may be parsed and analyzed by a message application (or embedded application, other application, or server) and determined to reference a particular game object. This may satisfy a message condition associated with the game object that is triggered when the player message references the game object. If a message condition does not occur, the method may continue to block 608.
If it is determined in block 620 that a message condition has occurred, the method continues to block 622 where an object identification of an application object associated with the message condition is provided from the embedded application to the message application. For example, the object identification may be a tag that provides the name of the application object displayed by the embedded application and the session, or may be another type of identifier of the application object. Additionally, in some embodiments, message data associated with the application object and the message condition may be provided from the embedded application to the message application in block 620. The message data may be text or other forms of messages (e.g., images, symbols, audio messages, etc.) or may be an indication of a message (e.g., a flag or value indicating a particular message or message type). In some embodiments, the embedded application may provide the message application with message conditions that are detected to have occurred. The method continues to block 624.
In block 624, the messaging application assigns chat identifications to each application object. In some examples, the chat identification is a chat name provided by the embedded gaming application, or the messaging application may assign a chat name to the application object based on data received from the embedded application. In some embodiments, the message application may determine a message for the application object based on message data provided by the embedded application. For example, the message application may receive a value from the embedded application corresponding to a particular text message in a lookup table or other data structure. In some embodiments, the message application may receive one or more message conditions that are detected to have occurred in the embedded application and determine an associated message based on the message conditions. In some examples, the messaging application may send data describing the message conditions that occurred to a server, which may determine a message for the application object and send the determined message to the messaging application. The method continues to block 626.
In block 626, a message associated with each chat identification determined for the application object is output in a chat interface in the chat conversation. Each chat identity represents an associated application object that provides messages to chat users (e.g., member-only users in some embodiments) in a chat conversation. This allows the member devices of the embedded session to display messages in their chat interfaces and allows the member users to view the messages. In some embodiments, the messaging application may output messages in the chat interface of one or more particular member devices, rather than messages in the chat interfaces of other member devices, e.g., messages directly output in the chat interface of one or more particular member devices. For example, if a particular application object is providing a message to a subset of member users due to interaction with users in the application environment (e.g., through user-controlled application objects or through direct input from the member users), the message may be sent to and displayed by member devices of the subset of users.
The outgoing message may take various forms and may be based on the message conditions and a set of stored messages associated with the application object. For example, if one or more member users joining an embedded gaming session satisfy the message condition and the associated game object is a player-enemy game object (e.g., character), then the output message for that game object may be "another victim-! ". Similar message conditions may be associated with player-friendly game objects (e.g., characters) that may provide messages such as "welcome, user". In another example, in response to a new user joining the embedded session meeting the message condition, the associated application object (e.g., character) may provide assistance to the new user by sending one or more messages including prompts or tips for the application user (e.g., how to play the game) that are only displayed in the chat interface of the new player. In another example, if the message condition is satisfied by an event in the embedded application occurring on the application object, the associated message may include a description of the state of the application object (e.g., say "I need your owner's help" or "care, I's more powerful" game role). In another example, if the message condition is met by a user action against a non-user application character, the non-user character may provide a message such as cynicism (e.g., in a game, "your effort is useless"). In another example, if the message condition is satisfied by a user action that helps a non-user application object (e.g., a character), the application object may provide a message thanking the user (e.g., "very need your help"). In another example, the message condition may be satisfied by input of a particular user chat message from a member user in a chat conversation, where the chat message references a game object (e.g., "let us follow the enemy on the left"). In response to meeting the message condition, the related message output by the chat identifier representing the game object may include text such as "you will find me a valuable opponent". In some embodiments, such messages may include images, emoticons, or other types of data.
Providing examples of suggested items associated with embedded applications
FIG. 7 is a flow chart illustrating an example method 700 for providing suggested response items associated with an embedded application in a chat conversation.
Suggested response items (also referred to herein as "suggested items") may be generated and provided in chat interfaces and/or embedded interfaces for user selection in various contexts. The suggested response items may be generated and automatically provided to the user via consent of the user and one or more other users transmitting and/or receiving images.
The suggested response items may be determined based on one or more techniques that may provide relevant results to a set of data. In some embodiments, the suggested response items may be determined based on the association of stored, predefined suggested response items (e.g., in a lookup table or database) with specific suggested events and/or specific types of suggested events that have occurred, as described below. The suggestion response items may be or include one or more different content data types including text, images, animated images (e.g., movie drawings), audio clips, video, other types of documents (e.g., spreadsheets, tables, etc.), and the like. The suggestion response items may also include or be presented as interactive cards. In some embodiments, the suggested response items may include additional (e.g., lightweight) embedded applications that perform one or more actions or provide output, as described below. Many of these types and features and suggested responses may be presented in menus (e.g., drop down menus, carousel selection menus, etc.).
In some examples, one or various machine learning techniques may be used to determine the suggested response items. In some examples, the message application 103a/103b may implement machine learning or interface with a machine learning application (e.g., a deep learning model), which may enhance user interaction with the message application 103. For example, suggestion server 156 may utilize machine learning to provide suggestions for messaging applications. In some embodiments, machine learning may be implemented on one or more other components of environment 100, and for example, suggestion server 156 is not used.
Before receiving a suggestion event for which a suggestion response item is to be generated, a machine learning model may be created based on the training data such that upon receiving an indication of the suggestion event, the suggestion response item may be generated using an existing model. The machine learning model may be trained using synthetic data or test data (e.g., data automatically generated by a computer) without using user information. The synthesized data may be based on simulated events occurring in the embedded applications and embedded sessions, as well as response commands and messages, with no human user as a participant. In some embodiments, the machine learning model may be trained using sample data or training data, such as commands and messages actually provided by users agreeing to provide such data for training purposes in response to embedded applications and session events. The training data is processed prior to use to remove the user identifier and other user-related information. In some embodiments, the machine learning model may be trained based on sample data for which permissions to train with user data have been explicitly obtained from the user. After training the machine learning model, the newly occurring data set may be input into the model, and the model may provide suggested items based on its training of the sample data. Based on the sample data, the machine learning model can predict messages and commands for events occurring in the embedded session, which can then be provided as suggested response items. For example, user interaction is enhanced by reducing the burden on the user to determine commands to apply events or compose messages, by providing for selection of response items tailored based on the event that occurs and the user's context. Some examples of machine learning applications and machine learning features are described below with reference to fig. 12.
In some examples, the suggested response items may be customized based on previous activities of the user, such as earlier messages provided in a conversation, messages in a different conversation, earlier commands provided by the user to an embedded application or a different embedded application, and so forth, when the user provides consent. For example, such activities may be used to determine appropriate suggested items for a user, such as interesting messages or commands, formal messages, etc., based on the user's interaction style. In another example, when the user specifies one or more user-preferred languages and/or locales, the message application 103a/103b may generate suggested items in the user's preferred language. In various examples, the suggested items may be text messages, images, multimedia, coded commands, and the like.
In some embodiments, machine learning may be implemented on one or more components of environment 100, e.g., suggestion server 156, message server 101, client device 115, one or both of message server 101 and client device 115, and so forth. In some embodiments, a simple machine learning model may be implemented on the client device 115 (e.g., to allow the model to be manipulated in memory, storage, and to handle constraints of the client device), and a complex machine learning model may be implemented on the message server 101, the suggestion server 156, and/or a different server. If the user does not agree to use the machine learning techniques, then these techniques are not implemented. In some embodiments, the user may optionally provide consent for machine learning to be implemented only on the client device 115. In these embodiments, machine learning may be implemented on client device 115 such that user information for updates to the machine learning model or use of the machine learning model is stored or used locally and is not shared to other devices, such as message server 101, server 135 and servers 150-156, or other client devices 115.
For users who provide consent to receive suggestions, the suggestions may be provided by the messaging application 103, e.g., based on machine learning techniques. For example, the suggestions may include suggestions of content (e.g., movies, books, etc.), suggestions of schedules (e.g., available time on a user's calendar), suggestions of events/venues (e.g., restaurants, concerts, etc.), and the like. In some embodiments, if a user engaged in a chat conversation via his device agrees to use the conversation data, the suggestion may include a suggested message response to a message entered by the other chat user based on the conversation content. For example, if a first of the two users agrees to a suggestion based on conversational content, a message "do you want to eat? What are Italy? "may suggest a response to the second user, e.g." @ assistant lunch, italy, 2-person table ". In this example, the suggested response includes the robot program (identified by the symbol @ and the robot program processing aid). If the second user selects this response, the assistant bot is added to the chat conversation and a message is sent to the bot. The response from the robot program may then be displayed in a dialog and either of the two users may send further messages to the robot program. In this example, the assistant bot is not provided access to the content of the chat conversation and suggested items are generated by the messaging application.
In some embodiments, the content of the suggested items may be customized based on whether the bot is already present in the chat conversation or can be incorporated into the chat conversation. For example, if it is determined that the travel bot may be incorporated into a messaging application, the suggested message response to the question regarding the fare of the air ticket to France may be "let us ask the travel bot-! "
In various embodiments, the suggestion (e.g., a suggestion message as described herein) may include one or more of the following: text (e.g., "superb |"), emoticons (e.g., smiley face, drowsy face, etc.), images (e.g., photos from a user photo library), text with user data generated based on the template inserted into fields of the template (e.g., "her number is < phone number >", where the field "phone number" is filled in based on user data if the user provides access to user data), links (e.g., uniform resource locators), messaging stickers, etc. In some embodiments, the advice message may be formatted and/or designed, e.g., using color, font, layout, etc. For example, a suggestion message that includes a movie recommendation may include descriptive text about the movie, images from the movie, and links to purchase tickets. In different embodiments, the suggestion message may be presented as different types of user interface elements, such as text boxes, interactive cards, and the like.
In various embodiments, the user is provided with control over whether they receive suggested items, what types of suggested items they receive, how frequently items are suggested, and so forth. For example, the user may refuse to receive the suggested items entirely, or may select a particular type of suggested item, or may receive the suggested item only during certain periods of the day. In another example, the user may choose to receive a personalized advice item. In this example, machine learning may be used to provide suggested items based on user preferences regarding the use of their data and the use of machine learning techniques.
In block 702, it is checked whether user consent (e.g., user permissions) has been obtained to use the user data in the implementation of method 700. For example, the user data may include messages sent or received by the user, e.g., using the messaging application 103, user preferences, user biometric information, user characteristics (identification, name, age, gender, occupation, etc.), information about the user's social network and contacts, social and other types of actions and activities, content, ratings, opinion created or submitted by the user, the user's current location, historical user data, images generated, received and/or accessed by the user, videos viewed or shared by the user, and so forth. In some embodiments, one or more blocks of the methods described herein may use such user data.
If user consent has been obtained from the relevant user whose user data was available in method 700, then in block 704, the block of determining the method herein may be implemented where possible using the user data, and the method continues to block 708. If no user consent is obtained, then in block 706 it is determined that the block is to be implemented without using user data, and the method continues to block 708. In some embodiments, if user consent is not obtained, the block is implemented without using user data and utilizing synthesized data and/or data that is commonly or publicly accessible and publicly available.
In block 708, a (first) embedded application is run for a first user device associated with a (first) message application providing a (first) chat conversation, wherein the first user device is one of a plurality of user devices participating in the chat conversation and having joined an embedded conversation created in association with the chat conversation, similar to that described above with respect to fig. 2-4. The user device is a member device running a corresponding embedded application as described above.
In block 710, a determination is made as to whether a suggested event has occurred, e.g., an event that may cause one or more suggested response items to be generated as described in FIG. 7. In some embodiments, the suggested event may include an event that occurred in association with the embedded application. Such suggested events may occur in an embedded application of the embedded session, in a messaging application, in a server used in the embedded session, and/or in a different application in communication with the embedded session, in a member device or chat device. Suggested events may include receipt of user input at a device, state changes in a program, data communication between devices, connection of a user device to an embedded session or device over a network, receipt or transmission of data at a device (e.g., between programs, over a network, etc.), detection of content characteristics in media data or other data, detection of a particular topic in a chat message, one or more of these events occurring at a previous time (e.g., indicated in historical data), and so forth. For example, in some embodiments, the occurrence of a suggested event in a messaging application (e.g., a chat conversation) may be checked, such as a chat user entering or exiting a chat conversation, specific detected content in a chat message entered into the chat conversation by the user, and so forth. Other examples are described herein. The suggestion event trigger generates one or more suggestion response items that may be presented on a member device (or chat device) in a chat conversation or chat interface and selectable for use by a user of the device, as described below.
In various embodiments, the embedded application and/or the messaging application may determine whether an event qualifies as a suggested event. In some embodiments, the suggested event may be any one of a number of predefined types of events in embedded applications, messaging applications, and/or other applications and devices that have been designated such that a suggested event that suggests a responsive item is generated for the user.
In some embodiments, suggested events may be determined based on one or more particular events occurring at one or more chat devices participating in a chat conversation. For example, such specific events may include user input received by the chat interface and/or embedded interface of the first user device and/or other member devices or chat devices. In some examples, such specific events may be chat user actions and/or member user actions performed in the embedded application based on user input received from an associated chat user and/or member user through one or more member devices. For example, receiving data indicative of and/or identifying a particular event over a network, a first user device (e.g., a first messaging application) may receive an indication of the occurrence of the particular event at other devices (e.g., member devices, chat devices, and/or other devices).
For example, the suggested event may be a user joining or leaving the embedded session based on user input at a member device or chat device, or a different action based on user input and one or more states affecting the embedded session (e.g., one or more states affecting a corresponding embedded application running on the member device of the embedded session). The suggested event may be an embedded application selected by the user in the chat interface and/or an embedded application initiated by the member user. The suggested event may be an action performed by the member user in the embedded application (e.g., starting playback of a media item, performing a game action, adding or modifying a displayed, shared object, e.g., document object, game object, etc., provided in the embedded application and displayed in the embedded interface). The suggested event may be a current display (e.g., in an embedded interface) of a particular user comment (e.g., as described with reference to fig. 5) previously added to the media item by the member user. The suggested event may be a change to an item or element in the shared content document based on local (first user device) or remote (other member/chat device) user input, or an edit to other shared data in an embedded application of the embedded session. The suggested event may be a member user's selection or confirmation of a particular travel itinerary in an embedded travel itinerary application.
In some embodiments, the suggested event may be determined based on one or more particular events, which are embedded application events that occur at one or more member devices (e.g., within one or more embedded applications of an embedded session). In some embodiments, some types of embedded application events are based on user input, and some types of embedded application events are not based on user input. In some examples, the suggested event may be based on an embedded application event, such as playing particular content data (e.g., media item data) in an embedded application. For example, the particular content data may be one or more content features (or types of content features) detected in visual content (e.g., images or video) or audio content (e.g., audio clips of data) of the media item being played using one or more image recognition and/or voice/audio recognition techniques. For example, the content features may include visual content features (e.g., facial, landscape features, monuments, objects, etc., if user consent has been obtained) and audio content features (e.g., sound, specific sound effects, etc.). The content features may include geographic locations, for example, provided as metadata with content items such as video, images, audio clips, games, and the like. The advice event may be the achievement (or lack of achievement) of a particular goal or score in the embedded gaming application, or the achievement of a score difference between a first player and a next player in the game that is greater than a predetermined threshold. The advice event may be an opportunity for the player to make a particular action or move in the embedded gaming application (e.g., a gaming application waiting for a player action to advance the game state, triggered by a different member user having performed a game action, or triggered by time, a non-player event in the game, etc.).
In some embodiments, the suggested event may be a particular type of embedded application event. For example, a user member event may include a chat user starting a new embedded session (e.g., by launching an embedded application at a chat device), the chat user joining an active embedded session, a member user exiting an active embedded session, or the last member user of an embedded session exiting an embedded session and/or otherwise ending an embedded session. Some specified embedded application events may include start or end events (e.g., a member user wins a game (such that the game is completed)), creation or deletion of a content document, start or end of a new video in a media player application, etc. The synchronization event may include an event that provides data to the member device to synchronize the embedded application on the member device (e.g., input user action changes game state, changes state of playback position of media items played in the media player application, changes items on the shared list, etc.). A suggested event may be defined as the occurrence of one or more embedded application events of this defined type.
In some embodiments, event information may be sent between applications and/or between chat devices to indicate that a particular event (and/or suggested event) has occurred. For example, when a particular event that has occurred in an embedded application occurs, event information may be passed from the embedded application to a messaging application associated therewith. In some embodiments or situations, the particular event has occurred in the embedded application, and the event information may indicate the occurrence of the particular event and/or may identify the particular event or type of event. For example, the event information may indicate the type of the particular event (e.g., game action has been performed in the particular game, playback of the media item has been paused or changed to a different playback position, etc.), data associated with the particular event (e.g., time of occurrence of the event, type of feature displayed in the media item that was detected as playing of the event, etc.), the condition of the particular event (e.g., which member users caused the event or have a character, status, or score affected by the event, etc.). Such specific events may include any event described herein, e.g., embedded application events, message application events, server events, etc.
In some embodiments, event information may be sent over a network from one device to another, e.g., from a member device (or chat device) to a server device, from a server device to one or more member devices (or chat devices), etc. For example, the embedded event information may be from an embedded application that indicates an event that occurs in the embedded application, the server event information may be from a server that indicates an event that occurs at a server, and so on. In some examples, a messaging application on a member device may receive event information from a different device indicating that a particular event occurred on the different device. In some embodiments or situations, the messaging application may determine whether the event indicated by the received event information is a suggested event. In some implementations or situations, the messaging application may communicate event information to an embedded application running in association with the messaging application, where the embedded application determines whether the event indicated by the event information is a suggested event (and may communicate any generated suggested events back to the messaging application).
In some embodiments, the event information received by the messaging application may indicate that the particular event is a suggested event. For example, the source of the event information may have determined that a particular event qualifies as a suggested event. In some embodiments, the event information may indicate a particular event, and the messaging application may determine whether the particular event qualifies as a suggested event. In some embodiments, the message application may use such event information to obtain suggested items, e.g., to determine one or more suggested items itself and/or to send event information (or a request derived from event information) to a different program or device to determine suggested items that may be sent back to the message application.
In some embodiments, the suggested event may be a specific event in or provided to the messaging application. For example, a user entering (e.g., logging in, going online) or exiting a chat conversation may be a suggested event. One or more specific chat messages (or a specific group or sequence of chat messages) entered by a member user in a chat conversation may be considered suggested events. For example, the chat message may be parsed and one or more predetermined topics, words, or keywords, and/or phrases may be detected to determine suggested events (e.g., "go to eat", "let us invite user 4", "let us watch movie a", specific names, addresses, locations, etc.). In some embodiments, the machine learning model may be trained with synthetic or actual training data during a training phase, and during an inference phase used in method 700, may be used to process a set of chat messages to predict whether a suggested event has occurred. For example, the model may predict whether the user is likely to initiate or provide any particular user action (e.g., commands or further messages) based on the content of a set of chat messages, and if the commands are within a threshold of probability of occurrence, the input of the set of chat messages (e.g., the input of the last chat message of the set) may be considered a suggested event.
In some embodiments, the suggested event may be a specific event in or provided to the messaging application that changes one or more states of the embedded application running on the first device (e.g., which in turn results in a change in one or more states of the corresponding embedded application running on the other member device). For example, user input provided to the messaging application through the chat interface may direct commands to the embedded application (e.g., change the play status of a media item played, perform a game action, etc., based on text commands entered as chat messages in the chat interface). In some embodiments, input in the chat interface that is not a direct command to the embedded application may change one or more states of the embedded application. For example, selection of the embedded application option may be performed through a menu or interface element displayed in a chat interface external to the embedded interface. In further examples, chat messages entered in the chat interface may be parsed by the running embedded application, and the embedded application may be caused to change one or more of its states to determine or process data, display particular output data, and/or retrieve data from storage, different devices, web sites, etc., as in the examples described herein.
In some embodiments, the suggested event may be a particular event that occurs within a different chat conversation provided by a messaging application that provides the first chat conversation. For example, the particular event may be a user message entered in a different chat conversation, the particular content of the user message matching a predefined word or phrase (or other matching based on machine learning techniques), the user joining or exiting a different chat conversation, and so forth. In some examples, chat users of different chat conversations may input messages indicating an interest in joining the first chat conversation, and the messages may be detected as suggestion events to generate suggestion commands (e.g., commands to add users of different chat conversations to the first chat conversation and/or embed a conversation) or suggestion messages (e.g., messages output in different chat conversations that welcome other users, invite users of different chat conversations to the first chat conversation, etc.).
In some embodiments, the suggested event may be a specific event that is a user action (e.g., an input command) instructing the system to generate one or more suggested response items for the user. For example, the user may select an interface element in an embedded interface or chat interface, which is a command to generate one or more generic advice messages or advice commands. In some examples, such advice messages may include comments about the embedded application or comments about one or more member users, or such advice commands may include commands to exit the embedded session, discard the game, or the like.
In some embodiments, the suggested event may be based on data received from a different application running on the user device than the messaging application and the embedded application, where the data indicates that a particular event occurred in the different application. For example, the video conferencing application may send an indication (e.g., data) to the messaging application indicating that the video conference has ended, that a particular user has joined or exited the video conference, and so on. In some embodiments, the suggested event may be a particular event that has occurred on a server or other device (e.g., in an application running on the server or other device), other device communicating with the user device over a network and, for example, providing data for use in an embedded session. For example, the particular event may include user input (e.g., comments or ratings of stored media items) obtained by the server from other user devices not participating in the chat conversation, e.g., a user request for second content data that is the same as the first content data that the server is providing to the embedded session, a user comment or rating of the second content data being sent to other user devices, etc.
Suggested events may include specific events occurring on the server, e.g., game events in a game (such as changes in game state, etc.) that are run by the server and streamed to the member device over the network, specific types of content features displayed in media items streamed from the server, etc. to the member device. The messaging application may receive server event information from the server indicating or describing a particular server event that has occurred, which may qualify as a suggested event for the messaging application or the embedded application.
If user consent has been obtained, the suggested event may include a particular event that occurred at a previous time. For example, with user consent, the occurrence of one or more particular events described herein (e.g., descriptions of device communications, content of chat messages, etc.) may be indicated or described in data stored on one or more devices, and the devices may search for such previous particular events in the data.
In block 712, it is determined whether the detected suggested event is an event associated with (and/or has a type associated with) one or more suggested commands of the embedded application. For example, some types of suggestion events may cause generation of suggestion response items that are suggestion commands for an embedded application.
The suggested commands for the embedded application may be, for example, commands to modify one or more states of the embedded application. For example, the suggested command may be a suggested playback command to set a playback position or change a current playback position to a new playback position of a media item being played in the embedded application. In further examples, the advice command may be a command to modify a game state in the embedded game application, e.g., to perform a particular game action, such as moving a game piece or character, changing a game display viewpoint, selecting a game object, and so forth. The suggestion command may be a specific item or element that adds, modifies, or removes a shared content document (e.g., a shared list) provided in the embedded application. The types of advice events that can provide advice commands can include, for example, one or more member users joining or exiting an embedded session, actions taken by a player in a game embedded application, game states in which a game is waiting for actions or movements of a player, events in which a player or object of a player is interacting with a different player or object of a player (e.g., attacks or conflicts between objects, provision or request of assistance from one player to another, etc.), changes in visual or audio content of a detected media item (e.g., changes from a scene with a slow moving object to a scene with a moving object that exceeds a threshold moving speed, changes from a talk scene to an action scene, changes in audio output from a lower volume or constant sound to a higher volume that exceeds a threshold or a rapidly changing sound that exceeds a threshold frequency, etc.), changes performed by different member users on a shared content document (e.g., advice that prompts the user to additionally change or change back to the performed changes), changes in playback position of a played media item, etc.
If the detected suggested event is of a type that provides one or more suggested commands for the embedded application, the method continues to block 714 where the one or more suggested commands are obtained and based at least in part on the suggested event. In some embodiments, the suggestion command may be based on other factors in addition to or instead of the suggestion event, such as one or more current states of the embedded application and/or the messaging application (e.g., a current time position of playback of the media item, a current game score, a current number or identification of member users and/or chat users, a time of day, etc.). In some examples, the one or more suggested response items may be determined by the embedded application and/or the chat application based on the suggested event. In some embodiments, the user may be provided with an option (e.g., a displayed interface element) that causes the suggested response item to be disabled (e.g., not generated and/or not displayed).
In some embodiments, the suggested commands may be determined based on an association of stored, predefined suggested commands with specific suggested events and/or specific types of suggested event types. For example, in a lookup table or database, for example, one or more specific types of suggested events may be associated with one or more specific commands, such that the associated commands are retrieved based on the detected suggested events.
In some embodiments, the embedded application may implement a recommendation engine (e.g., based on rules, other rule sets, decision trees, etc., for determining results in the embedded application) to determine the suggested response items. In one example, the suggestion response items may be determined based on a decision tree (or other decision construction), where the state of one or more conditions at the nodes of the tree determines a path through the tree to determine the suggestion items as a final result, where the conditions may include suggestion events and other conditions. In another example, when the embedded application is a rule-based game (e.g., chess, poker, etc.), the suggested response items may be determined based on rules and/or goals of the game. For example, the advice response item may be a move in the game (e.g., bg7, which indicates a move to board position g 7). For example, a rule set or decision tree may determine movement based on a predefined winning probability. In another example, when the user allows analysis of the user data, the advice response item may be based on the user's previously accepted advice (e.g., the user typically moves d4 to open a chess game, which indicates to move a stroke to position d 4).
In some embodiments, the suggested response items may be determined based on user profile data, such as user preferences or default values specified directly by user input and/or inferred based on previous user actions, when the user allows use of the user profile data. For example, if the embedded application is a shopping application (e.g., travel application, e-commerce application, etc.) and the suggested event is that the user has navigated to a "purchase" user interface, the suggested response item may include "pay with credit card," "pay with bank account," "pay with cash," etc., based on the user's profile. Similarly, if user consent has been obtained, other user profile data, such as the user's contact information (e.g., address, telephone number, email, etc.), may be included in the suggestion response item. In some embodiments, for example, when the embedded application is a "quiz" application, the embedded application may provide a suggested response item as a plurality of choices for answering quiz questions.
In some embodiments, the suggested commands may be determined using a training model for the embedded applications and/or machine learning techniques as described herein. For example, the advice commands may be the result of an inference phase of a machine learning model in which the model has been previously trained with specific advice events and specific types of advice events as training data, and specific commands entered by the user in response to those advice events, such that the model may generate possible or relevant advice commands in the inference phase based on the newly occurring advice events. In some embodiments, the suggested response items may be determined by a machine learning application that is trained to provide response items for a particular embedded application. In some examples, a machine learning model for suggesting responses may be trained to identify various game actions that may be performed in a particular embedded application, where the machine learning model may provide suggestion commands in the embedded application that trigger responsive actions in the embedded application, such as "build tower," "move stroke to space D1," "play this video next," and so forth.
In various embodiments, the suggested events may be analyzed to determine one or more suggested commands (or other responsive items). In some embodiments, analysis of the suggested events may include looking up a rule set or decision tree of the suggested events. In some embodiments, analysis of the suggested event may include determining a state of the embedded application (e.g., a level of progress in the game, user settings related to assistance during the game, etc.) to determine a context of the suggested event.
In some example embodiments, the embedded application is playing the media item and may provide suggestion commands to modify the playing of the media item. For example, if the suggestion event is a chat user joining an embedded session viewing a media item, the suggestion command may be to resume playback from the beginning of the media item (e.g., starting a video or audio clip from the beginning of the clip), which may allow a new member user to view the media item from the beginning. In some embodiments, in response to the media item being at the current playback point that is a threshold period of time after the start, such a "resume" suggestion command may be generated such that if the play location has played for a period of time exceeding the threshold period of time (e.g., because an existing member user may not wish to resume a media item that has been played for a long time), such a "resume" suggestion command is not generated. In another example, if the suggested event is a particular type of scene or sequence that has been detected to have occurred in the media item (e.g., a detected action scene or sequence), the suggested command may include rewinding the playback position for a particular amount of time to replay the detected scene or sequence from the beginning of the scene. Another example suggestion command may cause the embedded application to display a prompt or input field to allow a user to enter a user comment, which is then displayed (e.g., superimposed) on the display scene of the media item being played (as described with reference to fig. 5). In another example, if the suggested event is a change in the playback position of the media item by another member user, the suggested command may be to undo or resume the change in the playback position to a position maintained prior to the change. In another example, if the suggested event is a change in playback position, the suggested command may include one or more further changes in playback position to the nearest scene transition (in one direction or in either direction), chapter division, section division, or other mark division in the media file (e.g., commands such as "adjust to nearest previous chapter title. In another example, if the suggested event is a change in the volume of audio output by the media item (e.g., a change to a threshold amount, or to a volume level above a threshold level), the suggested command may be to increase or decrease the volume.
In some illustrative embodiments, the embedded application provides a game, and the advice command may be directed to the game. For example, if the advice event is a game action of a second player of the game, the advice command for the first player may cause one or more possible actions to be entered into the game in response to the game action, e.g., as determined by a game algorithm that may evaluate the game strategy and actions. In some examples, if the advice event is a movement of a game piece by an opponent player, the advice command may include various possible responsive movements of the user's piece in the game (e.g., in an asynchronous or round-robin game). In another example, if the advice event is an intrusion of an enemy game piece into the user's play area, the advice command may include a command to move the piece to intercept the intruder, secure the intrusion location with the player's piece at the intrusion location, and so on. In another example, if the advice event is another player joining the game, the advice command may include requesting that the new player join a team of users in the game and requesting that the different players compose a team to combat the new player. In another example, if the advice event is a member user exiting the game (or changing the player character to an observer character in the game), the advice command may be a request to pause the game until an alternate player joins the game. In another example, if the advice event is that the score (or other game goal) of the user differs from the score or goal of the other player (e.g., is behind or is ahead) by a threshold amount, the advice command may include sending a prompt to the other player or requesting the other player to provide a prompt to the user, asking the other player to hinder or support himself in the game, restarting the game, and so forth.
In some example embodiments, the embedded application provides a shared object, e.g., a game object in a game, a shared content document such as a list or other project document, and so forth. The suggestion command may be a command to change or affect the shared object, e.g., edit, remove, etc., change one or more characteristics thereof (e.g., type, color, size or dimension, etc.). For example, if the suggestion event is to launch a shared list in an embedded application, the suggestion command may be to add, delete, or change an item on the list. In another example, if the suggestion event is the addition of an item to the shared list by a different member user, the suggestion command may be to highlight or otherwise visually indicate the added item in the embedded interface. In some embodiments, the highlighted command may be accompanied by suggested text that may be output in an embedded interface or chat interface, e.g., "do we need this item? Or me suggests to remove this "(e.g., advice messages as described below). In another example, if the suggested event is a remove item, the suggested command may include outputting text in an embedded interface (or chat interface), e.g., "why it is to be removed? "in another example, in response to a suggestion event that a user highlights a particular item, the suggestion command may include moving the suggestion item within the list one, two or more positions, up or down, to start or end, etc.
In additional examples that may be applied to many types of embedded applications, if the suggestion event is a member user joining an embedded session, the suggestion command may instruct control of a specified function of the embedded application to be assigned to the new member user if a user state (e.g., user role) has been assigned to the new member user in the embedded application that allows such control assignment. For example, the suggestion command may be to allow a new user to change the playback position of media items played in the embedded application, change the status of items on the shared list, and so on. In some embodiments, the suggestion command may be to remove such control capability from the specified user (if the command user is able to do so), for example, if the message application (or other program or device) detects abuse or inappropriate language in a message from the specified user in the chat conversation.
If user consent has been obtained, the suggestion command may also or alternatively be based on a history of previous actions and/or messages performed by the user in the same or similar type of embedded application and/or for the same or similar type of output data (e.g., media items, games, etc.). For example, if the user has previously rewound or skipped playback of a particular scene or a particular type of scene in the video, a suggestion command may be generated that causes the playback position of the currently playing media item to be rewound or moved in the same manner.
The suggestion command may also or alternatively be based on member user input in the (first) chat conversation, as displayed in the chat interface of the message application. In various embodiments, the user input may be considered part of the detected suggested event or may be considered external to (e.g., complementary to) the detected suggested event. For example, a suggestion command may be generated based on chat messages referring to such activities (e.g., "let us watch movie 2," "let us play chess," or "we need shopping list," etc.) to initiate an embedded session involving an embedded application that implements a media player, game, content document, or other function. In another example, if the member user has sent a message in the chat conversation indicating a desired user role (e.g., "I will play" indicating a player role, or "I only want to watch" indicating an observer role), a suggestion command may be generated to assign a user state or role to a particular member user in the embedded conversation. In another example, if one or more member users enter a message in a chat conversation, such as "let us skip this scene" or "let us watch car chase together," a suggestion command may be generated that moves the playback position of the played media item across the current scene or to a particular subsequent scene.
In some embodiments, user data may be used to determine suggestion commands and/or suggestion messages if consent to use such user data has been obtained from a user associated with or associated with such user data. For example, the current geographic location of the member user or chat user (or their device) may be obtained by the messaging application and/or provided to the embedded application for use in determining the suggestion response items. For example, the suggestion command may reference the current geographic location of the user (via user consent), e.g., to instruct the embedded travel itinerary application to provide itineraries based on the current user location. Other types of user data may cause suggested items to be generated if user consent has been obtained. In additional examples, user data such as a list of applications installed on the device (e.g., applications external to the messaging application) may be used to generate the suggested items. For example, a suggestion message may be generated that recommends one or more applications for use by other chat users in a chat conversation.
In additional examples, user data received by the user device, such as SMS messages and telephone calls, may be used to generate suggestion commands to forward or annotate the message. For example, a message application intercepts an SMS message that has been received and may generate forwarding or annotation capabilities, e.g., a suggestion command and/or suggestion message for sharing the SMS message with a chat conversation, a suggestion command for annotating an SMS image with another message (e.g., chat message, email message, etc.) and sending it to another user, etc. In another example, when a user is actively entering a message in a chat conversation, the messaging application may detect that a telephone call is being received, and the embedded application may generate a suggestion message (e.g., "i am answering a call, coming back") to the chat conversation. User data, such as fitness tracker information, may be used to provide advice messages that challenge other chat users in a chat conversation to perform fitness exercises. User data such as the current system audio volume/mute state on a user device may be used to provide a suggestion command to automatically adjust the media playback volume/on-off state prior to or during playback of a media item. User data such as browsing history may be used to generate suggestion commands to display shopping suggestions for the user, for example, in a browser-embedded application. User data such as user account information (e.g., login/password) for a particular system or website may be used to provide suggested commands to access those systems in the embedded application. User data such as users that have recently been added to the contact list (e.g., user data added within a threshold time from the current time) may be used to provide suggestion commands to add one or more of these users to the chat conversation, or to provide suggestion commands to invite one or more of these users to join a particular embedded session in which the user is participating.
In some embodiments, the suggestion command may be an embedded application such that the embedded application controls an external application running on the first user device or on a different device in communication with the first user device over a network. Some examples of such control are described herein.
Some suggested event types may result in generation of suggested commands from blocks 714-718 and suggested messages from blocks 722-724. In some embodiments, the suggestion command items that provide the suggestion commands may be visually distinguished from the suggestion message items that provide the suggestion messages to be output in the chat interface. For example, different colors or highlighting may be used for these types of suggested response items to help the user distinguish between the different types of suggested response items.
In some embodiments, a plurality of suggested commands may be generated and ranked based on one or more predefined criteria. For example, the ranking score of the suggested command may be based on a likelihood of selecting the suggested command in response to a detected suggested event, e.g., as indicated by a machine learning model and its training based on synthetic or actual data of previous commands provided in response to previous suggested events. In some embodiments, suggested responses may be provided with a confidence rating or ranking that indicates a likelihood that the user will select the suggested response. For example, if consent of such a user has been obtained, such a confidence rating may be based on previous selections of suggested responses provided by the user (or users) to the same or similar suggested events. In some embodiments using a machine learning model, the suggested responses may have a ranking indicating which responses are most likely to be selected, as determined by model-based training. A particular number of top ranked suggestion commands may be selected for output on the user device. In some embodiments, the suggested responses may be displayed in the order of their rank or confidence rating. In an example, a suggested response with a high confidence rating (e.g., exceeding a threshold rating, or within a threshold number of highest ratings) may be selected by user input as a command or message to trigger an action in an associated embedded application. In some embodiments, after generating the high confidence suggestion response and before selection by the user input, the associated embedded application may be preloaded (e.g., downloaded in the background and stored in local storage) to the user device and its code initiated. This allows the output from the embedded application to be displayed on the user device immediately after the user input selects the high confidence suggestion response. For suggested responses of lower confidence (e.g., below a threshold), preloading of such embedded applications may be omitted because they are less likely to be selected.
In some embodiments, multiple embedded applications may be running for the first user device at the same time as described above, and the one or more suggested commands may be provided to multiple or different running embedded applications.
In some embodiments, one or more of the suggested commands may be commands for a message application. For example, the suggestion commands may include commands for a messaging application to add one or more particular chat users to the embedded session, where the particular chat users are specified in the suggestion commands. Such suggestion commands may be generated, for example, based on suggestion events that have occurred detected by a messaging application (or embedded application) based on one or more chat messages entered by the first user and/or other member users of the member session (e.g., "let us ask Kenny if he wants to join," etc.) or one or more chat messages entered by chat users of non-member users (e.g., "perhaps we should join the movie"). The suggestion commands may be presented to the member users, and/or chat users that are not member users. In some embodiments, to determine such suggested events, specific chat usernames, member usernames, names of content data, general words related to embedded conversations (e.g., "movies," "games," etc.), and other words may be detected in the chat message in combination with predefined keywords and key phrases, and/or by machine learning techniques to parse and analyze the chat message. In some embodiments, the suggested event may also or alternatively be that the message application detects that a content item (e.g., a played media item, game, content document, etc.) provided in an embedded session (a first embedded session) is the same content item that was provided to other chat users in a second embedded session concurrently with the display of content data in the first embedded session. This may cause the messaging application to generate a suggestion command to add the member user of the second embedded session to the first embedded session. User comments of chat users associated with the content item outside the embedded session may also be the basis for suggested events, similar to that described below.
In some embodiments, the suggestion commands for the message application may include commands to add the user to the chat conversation of block 708 (e.g., the first chat conversation), or to add the user to the first chat conversation and the embedded conversation of block 708. For example, the suggestion command may instruct the addition of an external user that is not currently engaged in the first chat conversation. Such commands, when executed, cause the external user's device to join the chat conversation. In some examples, the external user may engage in a different chat conversation provided by the first messaging application or provided by a different messaging application in communication with the first messaging application. In some cases, one or more member users of the first embedded session may participate in different chat conversations while participating in the first embedded session and the first chat conversation, and suggestion commands may be provided to such member users (e.g., in blocks 716 and 718) to add one or more external users from the different chat conversations. Such suggestion commands may be generated, for example, based on detection of suggestion events that have occurred by a messaging application (or embedded application) based on one or more chat messages entered by one or more chat users of a first chat conversation (similar to that described above) and/or by one or more external users of a different chat conversation.
In some embodiments, the suggested event may also or alternatively be the message application detecting that the content item (e.g., a played media item, a game, a content document, etc.) provided in the embedded session is the same as an external content item that is provided to the external user at the same time. This causes the messaging application to suggest that an external user be added to the first chat conversation. In some embodiments, the suggestion command may be to add an external user to the first embedded session. In some examples, the suggestion event may be triggered if the current playback position of the content item output by the embedded application is within a threshold amount (of time, data, etc.) of the current playback position of the external content item output to the external user. In some embodiments, the suggested event may also or alternatively be that the messaging application detects that one or more user comments have been entered by one or more external users associated with an external content item output to an external user, and that the external content item is the same as the content item output by the embedded application. In some examples, the suggestion event may be a particular type of user comment that detects an external user, e.g., a user's approval rating for content data, a reference to one or more member users of the first embedded session, etc., such user comment may cause the messaging application to generate a suggestion command to add such external user (as a member user) to the first embedded session and/or (as a chat user) to the first chat conversation.
In some embodiments, if user consent from the relevant user has been obtained, user data may be used to determine a suggestion event that causes a suggestion command to be generated for a message application (or other application) to add one or more users (e.g., chat users or external users) to an embedded session or chat conversation as described above. For example, user data (e.g., accessible database data or contact list data) may indicate particular users having one or more particular social relationships with one or more member users (or chat users), and such particular users may be selected to be included in the suggestion command to add those users to the embedded conversation or chat session. For example, such specific social relationships may include users in a contact list of member/chat users, users in a user group created by member/chat users (e.g., a social network user group), users separated from member/chat users to a specific degree, and so forth.
In some embodiments, the one or more suggested commands may be commands to perform one or more tasks external to the messaging application to the first user device. For example, the tasks may include opening and executing an application external to the messaging application on the first user device and/or controlling an external application running on a remote device in communication with the first user device. For example, such applications may include web browser applications, communication applications, calendar applications, word processing applications, specific applications accessing specific internet services, and the like. If the external application is running on the first user device, it may provide a display output on the first user device. The display output may include, for example, information received from a server device in communication with the first user device. In some examples, the suggestion command may include a command to open a web browser application, display a user interface of the web browser application on the first user device, instruct the web browser application to access a web page at the particular link, and display web page content of the particular link in the user interface of the web browser. May include using an appropriate communication protocol (e.g., websockets). The particular link may be a link determined based on the suggested event. In another example, the open application may be a shopping application that outputs data received from a server indicating items or services to purchase and that provides one or more controls that can accept user input to purchase the items or services, where the items or services are related to suggested events.
In some examples, the command may instruct an application to be opened or launched on the first user device to display information related to one or more content features included in a content item displayed in an embedded interface on the first user device. For example, the suggestion command to open or run the application may be generated based on the output data of the embedded conversation by the messaging application (or the embedded application) and/or based on suggestion events that have occurred detected by one or more chat messages entered by one or more chat users of the first chat conversation, similar to that described above. In some examples, if user consent has been obtained, content features including visual features (e.g., faces, animals, landscape features, objects, etc., using image recognition techniques), audio features (voice, sound types, etc., using audio recognition techniques) or themes (e.g., presented themes, geographic locations of images, or scenes in video, etc.) may be detected by the system in the output data of the embedded application and similar content features may be searched over the network on accessible sites and databases. For example, if the chat message from the member user includes "i like the suit she is wearing" and the embedded application is displaying output data depicting a video or image of the person with the suit, then such a combination of chat messages related to the visual features displayed in the embedded application output may be suggested events. This enables a messaging application or embedded application to search for similar coat items in an accessible web page or shopping site over a network, for example, by using image searching or text labels determined from one or more image recognition techniques. One or more network sites with matching items may be included in one or more suggestion commands. For example, a suggestion command may be generated for one or more member users, wherein the suggestion command (if selected) instructs the first user device to open a browser application displaying one of the matched coat items. In some examples, the suggested commands may be displayed as a textual description of the actions they command, e.g., "display a website showing the jacket.
In other examples, when the embedded application displays a person acting as a lecture, a suggested event may be detected, where the identity of the person may be determined (e.g., by detecting the captions of the speaker in metadata of the output data), etc., and items related to the speaker may be searched for and found among content items accessible over a network. In one example, a book written by a speaker is found on a website. A suggestion command may be generated for one or more member users, wherein the suggestion command (if selected) instructs the first user device to open a shopping application that displays a description of the book with selectable options (e.g., display elements) to purchase the book by the user.
In additional examples, the suggested commands may be determined based on one or more images, video, audio data clips, or other types of content data. For example, a plurality of images (e.g., representations of media items, items to purchase, etc.) may be displayed in an embedded application, and the suggestion command may be to select one or more images, where the suggestion command is determined based on a previous image selected by the user. In another example, the suggestion command may be to select a particular color of the clothing item from a list of multiple colors of the clothing item, where the suggestion is based on previous user selections (e.g., the user previously selected the particular color more frequently than the other colors).
In additional examples, the suggestion event may be a user joining a chat conversation, triggering a generate suggestion command in the joining user's chat interface to initiate a "find embedded application" (agreed to by the chat user) that stores and displays in the chat interface or embedded interface a history of actions taken and/or content output by the chat user in the embedded conversation prior to joining the user joining the chat conversation. For example, the history may include an identification of other embedded applications that have been previously used in the chat conversation (including a currently ongoing, ongoing shared list of embedded sessions, etc.). In some embodiments, the embedded application may display, for each of these other embedded applications, an initiate/join control to launch the associated other embedded application to allow the joining user to restart the previous embedded session, join/continue the previous embedded session if the previous embedded session is ongoing, and so on. This may allow the new user to discover and learn about the activities that have been performed by the user group in the chat session before the new user joins the chat session.
In additional examples, the suggestion event may be an external application (e.g., running on the first user device or the remote device) sending data to the messaging application when the chat conversation is active (e.g., the data may be indicative of an occurrence of an event in a communication application, calendar application, etc.), and a suggestion item may be displayed in the chat interface that provides a suggestion command or suggestion message (see below) based on the data (e.g., a suggestion command to save the data indicative of the event in storage for later viewing by the user, and/or a suggestion message that describes the event in text form, which may be selected for output in the chat conversation). The suggestion event can be a user changing the group information of the chat conversation (e.g., visual background (wallpaper) displayed in the chat interface, chat conversation name or group name, group icon, etc.), and this can trigger a suggestion command to launch an image editing embedded application that provides control to the chat user to create a new wallpaper, for example, by editing an image in a shared editing interface with other chat members.
In some embodiments, instead of or in addition to suggesting commands, recommendations may be generated in block 714. For example, such a recommendation may be described as a particular action suggested by the user, but if the user selects the recommendation, a command is not initiated that causes the action to be performed. Thus, if the user chooses to follow the recommendation, the user will manually perform the recommended action.
In some embodiments, as in the example of fig. 7, the suggestion command may be determined by and displayed by the embedded application, for example, in an embedded interface, and/or provided to the messaging application for display in a chat interface. In some embodiments, other components of the system may determine the suggested commands. For example, the messaging application may determine the suggested commands based on events in, for example, a chat interface and/or based on event information from an embedded application. In some embodiments, a server (e.g., a message server, suggestion server, etc.) may be provided with event information and may determine suggestion commands. For example, the messaging application may send descriptive information to the server indicating the suggested event, and the server may determine one or more suggested commands provided back to the messaging application.
In some embodiments, for example, when the embedded application does not include a suggestion feature, the message application may provide a suggestion response item. For example, if the embedded application is an image viewer application, the message application may provide suggestion commands to enhance the image, download the image, run an image search for the image, and so on. In some embodiments, the suggestion command may be provided by both the embedded application and the chat application. The method continues to block 716.
In block 716, the one or more suggestion commands determined in block 714 are provided from the embedded application to the messaging application on the first user device (if the embedded application generates the suggestion commands). In some embodiments, instead of or in addition to sending the suggested commands to the cancellation application, the embedded application may send data to the messaging application from which the messaging application may determine one or more suggested commands. For example, the embedded application may send data describing the suggested event (e.g., an indication of a user action in the embedded application, a game score, an indication of success or failure to achieve a game goal, etc.), and/or may send data providing context for the suggested event (e.g., video data, audio data, a game status, a portion of a share list, etc.). In some embodiments, the message application may determine the suggestion command from the data and/or may send the data to a suggestion engine (e.g., suggestion server 156) to determine the suggestion command based on the data and send the suggestion command back to the message application. The method continues to block 718.
In block 718, the message application outputs the suggested commands in the chat interface (and/or the embedded application outputs the suggested commands in the embedded interface) for selection, causing the first device to display the suggested commands. In some embodiments, the advice commands may each be displayed as a description of the action instructed by the advice command (e.g., "skip this scene," "move forward stroke 3," "add user 4 to this movie session," "display an option to purchase a jacket," etc.). For example, the suggestion command may be displayed in a list of chat interfaces as an optional message from a bot or the like. The user may select an individual suggestion command, for example, through touch screen input or other user input. In some embodiments, the suggestion commands may be displayed in the chat interface as interface elements, for example, as buttons, drop-down menus, and the like. Some embodiments may display the suggestion command in a permanent area of the chat interface such that the command does not scroll out of the display when additional chat messages are displayed in the chat interface. In some embodiments, the suggested commands are not displayed to other chat users of the chat conversation and member users of the embedded conversation, e.g., the commands are specific to a first user of the first device. In some embodiments, one or more suggestion commands may be displayed to all chat devices or member devices in a chat conversation, or one or more suggestion commands may be displayed to a subset of chat devices or member devices found to be related to the suggestion commands. In some embodiments, if one user selects a suggestion command, the command is removed from the suggestion list of the chat interface of all chat devices.
In some embodiments, the suggestion command may have a limited display time before being automatically removed from the chat interface by the messaging application. For example, a predefined time limit may be used such that the advice command is removed after the time limit expires. In some embodiments, the suggested commands may be removed based on one or more conditions being met. For example, if a suggested event or application state is such that a particular suggested command is determined and displayed, and the suggested event or application state is no longer relevant, pending or valid, those particular suggested commands may be removed from the chat interface. In some examples, if the advice commands present an action in the game that is responsive to the action of another player, and the user performed a different action, those advice commands are no longer relevant and may be removed. In another example, if an event in a played media item is no longer displayed, for example, after a predefined amount of time, a suggestion command to react to the event may be removed. In some examples, the embedded application may notify the message application of new events and status and/or when the suggested event is no longer valid or pending, so that the message application may determine when to remove the suggested command from the display. The method continues to block 720 as described below.
If it is determined in block 712 that the suggested event type does not provide a suggested command, or after block 718, the method continues to block 720 where it is determined whether the detected suggested event is an event associated with (e.g., has an event type of) one or more suggested messages of the chat conversation. For example, some types of suggestion events may provide suggestion response items that include suggestion messages to be output in a chat conversation. The suggested message may be, for example, a text message displayed in a chat interface as if the user had been selected to input the message as a chat conversation message. In some embodiments, the suggested event types that may provide the suggested message may include one or more types of suggested events that may provide suggested commands as described above. In some examples, suggested event types that may provide suggested messages may include event examples described above for suggested commands. In some embodiments, some types of advice events may be specified to provide one or more advice messages, and not one or more advice commands, and vice versa.
If the detected suggested event is of a type that provides one or more suggested messages for the chat conversation, the method continues to block 722 where, based on the suggested event and/or other conditions, the one or more suggested messages are obtained. For example, similar to that described for the advice command (e.g., block 714), the message application may determine one or more advice messages, and/or may send descriptive data to an advice server (or other server) or the like that determines the one or more advice messages and sends the one or more advice messages back to the message application. In some embodiments, the embedded application may determine one or more suggested messages.
In some embodiments, the advice message may be determined based on a stored and predefined association of the advice message with a particular advice event and/or a particular type of advice event, the advice message may be determined using a recommendation engine, the advice message may be determined using training models and machine learning techniques, and/or other techniques and features similar to those described herein for the advice command (e.g., as described for block 714).
In some examples, the advice message may be a description of an advice event that caused the advice message, or a description of an action that caused the advice event. For example, if the first user performs an action in the embedded application that is detected as a suggested event (e.g., a game action in a game, setting a playback position in a media player application, etc.), the embedded application may provide a suggested message describing the operation (or provide an indication of the event to a messaging application that provides the suggested message). For example, the advice message may describe the action performed by the user as "user 1 skipped the current scene" or "user 1 moved the horse". If the first user selects a suggested message (e.g., in block 730 below), the suggested message is output to the chat conversation, e.g., for sharing user actions with the embedded conversation and/or the chat conversation.
In some embodiments, if the suggestion event is a user action that instructs the system to generate one or more message suggestions about the embedded application and/or embedded session, various suggestion messages describing the embedded application and/or embedded session may be generated, for example, outside the context of a particular user action or a particular type of suggestion event. For example, the advice message may include general comments about the embedded application, such as "this game is very bar-! "OR" watch this movie-! "etc. These general messages may also be generated in response to other types of suggested events.
In some examples, the advice message may indicate or describe a user's reaction to the advice event. In some embodiments, such suggested messages may be displayed as chat messages in a chat conversation when selected by a user. Such a suggested message may be, for example, a text message. In some examples, the suggested message describing the user reaction may be determined as a stored predefined message associated with a particular topic, word, or phrase occurring as a basis for the suggested event, or associated with a particular action for detecting the suggested event. In some embodiments, a machine learning model may be used that is trained based on synthetic or actual training data, such as predefined synthetic or previous actual messages provided by a user in response to the same predefined or previous suggested event as the detected suggested event (e.g., the same type of user action, chat input, event, etc., detected as the previous suggested event).
In some example embodiments in which the embedded application is playing a media item, the suggestion message may be determined based on the suggestion event. For example, if the suggested event is that a chat user named user 2 joins an embedded session to view media items, the suggested message may be "welcome user 2-! ". In another example, if the suggestion event is a particular detected type of visual or audio feature detected in the media item being played or a particular detected type of scene or sequence (e.g., a detected action scene or sequence), the suggestion message may include exclamation or observations related to the detected type of feature or scene, such as "Java, tencel-! "or" lovely baby ". Such message suggestions may be determined, for example, based on predefined associations between messages and content features and scenes, and/or using machine learning models trained with synthetic or actual data, where the synthetic or actual data includes previous content features and previous user comments or responses to reactions to these features. In another example, if the suggested event is a change in playback position or output characteristics (e.g., audio volume or visual brightness or contrast) of the media item caused by another member user, the suggested message may be a reaction to the change, such as "good, I tired of" or "etc., I want to see that-! ". In another example, the messaging application may have received a server event from a server, as described above. In one example, the media item played in the embedded session is a video created by a first member user, user 1, the media item is available for viewing by the user from the server, and the server event indicates that a threshold number of user endorsements for the media item have been received by the server. The advice message of the member users other than the first member user may be "congratulatory, user 1" or the like praise to the first member user.
In some example embodiments in which the embedded application provides a game, the advice message may be determined based on advice events related to the game event. For example, if the advice event is a game action of a different player of the game, the advice message may be one or more possible or predefined reaction messages to the game action (e.g., a selection in a quiz game providing a selection of multiple answers), such as "very stick movement-! "OR" very bar answer-! ". In another example, if the advice event is an intrusion of an enemy game piece into the user's game area, the advice message may include information such as "hey, not follow me" or "you will remote-! "reaction. In another example, if the advice event is that the user's score becomes different (e.g., lag or lead) than the score or goal of other players by a threshold amount or more, the advice message may include the player's exaggeration or bemoan, e.g., "your will never catch me". In another example, if the advice event is another player joining the game, the advice message may include a message requesting the new player to join a team of users in the game, and/or a message requesting the different player to form a team against the new player. In another example, if the advice event is that the member user exits the game (or has changed from a player character to an observer character in the game), the advice message may be "thank you for playing the game". Such suggested messages may be determined similarly as described above.
In some example embodiments where the embedded application provides a shared content document (e.g., a shared list) of items, the suggestion command may be determined based on suggestion events related to the list or document. For example, if the suggested event is the addition of an item (e.g., "steak") to a list of foods by a different member user, the suggested message may include a message asking for the item or requesting the removal of the item from the list, e.g., "do we need steak? "or" I propose to remove steaks. "in some embodiments, the advice message may be associated with a highlighted command to highlight the item, as described above. In another example, if the suggested event is a remove item, the suggested message may include outputting text in a chat interface, e.g., "why is you removing this item? "such a advice message may be similarly determined as described above.
In some example embodiments in which the embedded application provides travel itineraries, if the suggested event is an output of a plurality of travel itineraries to be selected from, the suggested message may include a description of the itinerary, a request from other chat users for comments or suggestions as to which itinerary to select, and so forth.
In another example, which may be applied to many types of embedded applications, if the suggestion event is that a member user joins an embedded session, the suggestion message may be to ask the new member user if he or she wants to control a function of the embedded application (if the first user has been assigned a user state or role in the embedded application that allows such control assignment). In some embodiments, the advice message may be a message that requires the member user to cease using the abused or inappropriate language if the message application (or other program or device) has detected the abused or inappropriate language in a message from a designated user in the chat conversation.
In an additional example, the advice event may be the user device receiving a telephone call while the user is engaged in a chat conversation, and the advice message may be "wait for me to answer the phone of my boss" for display in the chat conversation. The suggested event may be the user device receiving a Short message service (Short MESSAGE SERVICE, SMS) message when the user participates in the chat conversation, and the suggested message may include content for an SMS message displayed in the chat conversation. The advice event may be that the user device is offline and the advice message may include "sorry partner, my cell phone lost connection for a while". During display of video in an embedded session, the suggested event may be, for example, the user device alternating between online/offline states a threshold number of times within a threshold period of time, and the suggested message may include: "sorry partners, my connection is very unstable, i will watch the video later. The "advice event may be that the chat user exits the chat session (e.g. detected as a server event), and this may trigger generation of advice messages to all other (remaining) chat users, wherein the advice messages are related to the user exiting the chat session. (e.g., "do we should stop the movie.
If user consent has been obtained, the suggestion message may also or alternatively be based on a history of previous messages and/or actions performed by the user in the embedded session that relate to the same or similar type of embedded application and/or the same or similar type of content item (e.g., media item, game, etc.). For example, if the user previously reacted to a change in playback position of a particular scene or type of scene in the video by sending a "please change it back" message, similar advice messages may be generated in response to the occurrence of similar advice events, wherein the advice messages provide similar reactions.
The suggested messages may also or alternatively be based on member user input in the chat conversation, as displayed in the chat interface of the message application. For example, if during a game a member user enters a message in a chat conversation saying "help me achieve this goal," a advice message of "do nothing" or "me cannot help you" may be generated. In another example, if during playback of a media item in an embedded interface, a member user enters "what time should me start? By "a suggestion message may be generated indicating various times, such as different chapter titles (e.g.," go to 28: 30-visit "), or if the user priority history can be accessed with the user's consent, the suggestion message may indicate a time or location of a scene that is known to be liked by the user.
Some suggestion messages may be associated with one or more suggestion commands determined in block 714. If the user selects a suggested command, a suggested message associated with the command may be output in the chat interface when the command is provided to the embedded application. In some embodiments, such advice messages may relate to associated advice commands, e.g., emphasizing or interpreting the provided commands. For example, if a advice command is selected to take an action responsive to a previous action by a different player in the game, one or more associated advice messages may be determined that may accompany the advice command to emphasize it, such as "meet the trick-! "and" I have not been defeated yet. "in another example, if a suggestion command is selected to change the playback position of a media item to a new scene, the associated suggestion message may interpret the change in playback (e.g.," i are skipping the scene "or" i feel tired of the scene "). Some embodiments may similarly display one or more advice commands in response to selection of the advice message. In another example, if there is a discussion or a dispute between chat users in a chat conversation, one or more chat users may be presented with suggestion commands for the embedded application to generate a visualization of the discussion, e.g., using other types of content data. For example, the embedded application may use the user profile picture to generate an animation map or other animation data having a visual representation of the discussion. An edit option may be presented (e.g., to a user selecting a suggestion command) that allows the user to edit the animation data. The embedded application may generate a suggestion message that, if selected by the user, causes the animation data to be displayed as a chat message in a chat conversation.
Some suggested event types may result in generation of suggested commands from blocks 714-718 and suggested messages from blocks 722-724. In some embodiments, the suggestion commands for the embedded application may be visually distinguished from the suggestion messages when displayed in the chat interface. In some examples, the advice command may be displayed using a common first visual feature, and the advice message may be displayed using a common second visual feature that is different from the first visual feature. For example, a particular color, font, highlighting (e.g., bold text), or other visual feature may be applied to the suggestion command, and a different color, font, highlighting, or other visual feature may be applied to the suggestion message.
In some embodiments, multiple suggestion messages may be generated and ranked based on one or more predefined criteria, similar to the suggestion commands described above. A particular number of top ranked suggestion messages may be selected for output on the user device. The method continues to block 724.
In block 724, the one or more suggested messages obtained in block 722 are output by the message application in the chat interface and/or the embedded interface. For example, the suggestion message may be displayed in a list of chat interfaces and may be selected by the user, similar to that described above for the suggestion command. Some embodiments may display the suggested message in a permanent area of the chat interface such that the suggested message does not scroll out of the display when additional chat messages are displayed in the chat interface.
In some embodiments, the advice message may have a limited display time before being automatically removed from the chat interface by the message application, similar to that described above for advice commands. For example, the advice message may be removed after expiration of the time limit and/or based on meeting one or more conditions. For example, if a suggested event or application state is such that a particular suggested message is determined and displayed and the suggested event or application state is no longer relevant, open, or valid, then those particular suggested messages may be removed from the chat interface. In some examples, if the advice messages are responsive to a particular action performed by a different user in the embedded application, and the different user performed a different action, those advice messages may no longer be relevant and may be removed. In some examples, the embedded application may notify the message application of new events and status and/or when the suggested event is no longer valid or pending, such that the message application may determine when to remove the suggested message from the display. The method continues to block 726, described below.
If it is determined in block 720 that the suggested event type does not provide a suggested message, or after block 724, the method continues to block 726 where a determination is made in block 726 as to whether a selection of one or more suggested command items is received in the chat interface. For example, a selection may be received based on user input provided by a user in a chat interface to select a displayed suggestion command item. In some embodiments, the embedded interface may display suggested items in the embedded interface where they are used for selection in response to user input, as described above with respect to block 718.
In some embodiments, the plurality of suggested command items may be selected by user input. In some examples, as described above, a selection for a suggested command item may be received, which causes a list of suggested message items associated with the suggested command item to be displayed. The user may then select one (or more) associated suggested message items. In some embodiments, a selection for a suggested message item may be received, which causes a list of suggested command items associated with the suggested message item to be displayed. The user may then select one (or more) associated suggested command items.
If it is determined in block 726 that a selection of one or more suggested command items is received, the method continues to block 728 where the message application provides one or more selected commands associated with the selected command items to the embedded application. In some cases, one or more selected commands associated with the selected command items are provided to the messaging application and/or the first user device as described above in lieu of or in addition to the commands provided to the embedded application. In some embodiments, multiple commands are associated with a single selected suggested command item. The provided command is implemented by the embedded application, the messaging application and/or the first user device. For example, the command may cause a change in the state of the embedded application (e.g., change the playback position of the media item, change the position or state of a user-controlled game piece, change the shared document, etc.). In some embodiments, the change in state is sent or indicated to one or more servers and/or other member devices over a network, as described herein, to allow synchronization of embedded application states in the embedded session. The method continues to block 730.
If it is determined in block 726 that a selection of one or more suggested command items has not been received, or after block 728, the method continues to block 730 where a determination is made as to whether a selection of one or more suggested message items has been received in the chat interface. For example, a selection may be received based on user input provided by a user in a chat interface to select a displayed suggested message item. In some embodiments, the plurality of suggested message items may be selected by user input. Some embodiments may select one or more suggested message items associated with one or more suggested command items, as described above.
If it is determined in block 730 that a selection of one or more suggested message items is received, the method continues to block 732 where the message application outputs a selected message corresponding to the selected message item into a chat conversation of the chat interface. In some embodiments, multiple messages may correspond to a single message item. In some examples, the selected message may be displayed in a chat interface of a (first) device that receives the user's selection of the message item, and the selected message may be transmitted over a network to chat devices that are engaged in the chat conversation and displayed in the chat interface of those devices. In some embodiments, the selected message may be transmitted to a particular subset of chat devices for display in their associated chat interfaces, e.g., to member devices in the same embedded session as the first device, to devices of a particular chat user based on user selection or preference, to devices of a particular user state or role in the embedded session, to devices in the same team or team of parties in the game of the embedded session, etc.
In some embodiments, the number of suggested messages output in a chat conversation may be limited, for example, to reduce the impact of many chat message crowding at the chat interface. For example, the message application may apply the maximum number of selected suggested messages that may be output to the chat conversation for a particular period of time, or may apply a minimum amount of time between the output of consecutive selected suggested messages from a particular member user or from all chat users. Thus, if the selected suggested message does not meet the output condition, the message is not output to the chat conversation in block 732.
If it is determined in block 730 that a selection of one or more suggested message items has not been received, or after block 732, the method may continue to block 708 to continue running the embedded application.
In some embodiments, a particular embedded application may be opened (e.g., minimized in a corner) to continuously parse and/or otherwise process chat messages in a chat conversation and provide suggestion commands and/or messages based on the chat messages. For example, the embedded application may present a suggestion message based on the content of the chat conversation, which may be a topic, video, image, movie, audio data segment, and so forth. This may help the user publish content related to the chat conversation. In some embodiments, the suggestion events may be continuously detected based on the current chat message entered by the chat user in the chat conversation, and new suggestion commands and/or messages may be continuously provided in the chat interface and/or embedded interface for user selection.
In some embodiments, a suggestion response may be determined based on the suggestion event and presented to a plurality of member users (and/or chat users), e.g., displayed on each member device or chat device (or selected member devices or chat devices). In some examples, the suggestion response may be the same suggestion command and/or suggestion message provided on each of the plurality of member devices, or a different suggestion response may be provided to each of the two or more member devices. In some examples, the member devices of users 1,2, and 3 receive chat messages from user 4 of the chat conversation, and each member device (or members devices) of users 1,2, and 3 may present a different set of suggested responses (e.g., each set has at least one response that is different from one or more other sets). Each set of suggestion responses may be based on the context of the member device presenting the set, e.g., based on associated chat messages entered by the associated user in a chat conversation, the history of chat messages of the associated user (if user consent has been obtained), and/or other factors described herein. In some examples, the set of suggested responses may be based on one or more particular embedded applications that the associated user is always using. For example, if user 4 enters a chat message, "we need to purchase a beverage for a party in the evening," and if user 2 is a common user of a shared list embedded application, user 2's user device may provide (when selected) a suggestion command to add the item "purchase beverage" to the shopping list in the application. The select suggestion command may cause the sharing list embedded application to open and may cause the item "buy beverage" to automatically enter the sharing list of the sharing list embedded application. However, user 3 is not a common user to share the list embedded application (e.g., the application is not used more than a threshold number of times in a particular amount of time), and the user device of user 3 does not display the suggestion command in this example. The user device of the user 3, e.g. a messaging application, may display different advice commands for different embedded applications frequently used by the user 3, e.g. a map application displaying the geographical location of the business where the beverage is purchased. In another example, the device of user 3 may provide the same suggested message as the previous message previously entered or selected by user 3 in response to a similar chat message (e.g., a previous chat message having one or more of the same words, the same semantic meaning, etc.) displayed in the chat conversation (or alternatively, in any chat conversation) on a previous occasion.
In some embodiments, a relevant suggestion response may be determined that is relevant to one or more particular content items provided in the embedded interface. For example, if a member user is using (or has previously used) a shared list embedded application to generate a first list for travel preparation and a second list for a meeting organization, the suggestion response may refer to one of these lists without referring to the other list, e.g., based on the content of the chat message and/or one or more other suggestion events. In some examples, in response to a chat message such as "do not forget to purchase a beverage for tonight," the machine learning model and/or knowledge graph may determine that the "tonight" and "purchase beverage" refer to a "party" that the chat member is organizing, and provide (when selected) a suggested response that adds the item "purchase beverage" to a corresponding second list for the party organization. In response to a chat message such as "do you have subscribed to the ticket for our travel," the machine learning and knowledge graph can determine "ticket" and "travel" reference travel and provide (when selected) a suggestion response that adds the item "subscribe ticket" to the corresponding first list for travel preparation.
In some embodiments, the suggestion response, when selected, may trigger display of an identification of a plurality of associated embedded applications, e.g., to allow a user to select a desired embedded application to run or receive data based on the suggestion response, thereby reducing ambiguity. In some embodiments, when the suggestion response is selected by the user, the suggestion response may cause a display of a request regarding which embedded application should be triggered by selecting the suggestion response. In some cases, a plurality of possible embedded applications appropriate for the selected suggested response may be displayed, and the user input may indicate the embedded application to be run. For example, if the selected suggestion response adds an item to a shared list and two different available embedded applications provide such a list, then the identity of the two embedded applications may be displayed and the user may select one of the embedded applications for use.
In some embodiments, the suggestion response may be displayed within the embedded interface and receive a selection from the user input when displayed in the embedded interface (e.g., via a touch input on a touch screen or via a user-controlled cursor located in the embedded interface). For example, the suggestion response may be displayed in response to occurrence of a suggestion event in the embedded application. In some examples, the advice event in the game may be a user player causing an avatar or game piece of an opponent player to be defeated or removed, and a first advice message set (e.g., a message to exaggerate movement) may be displayed on a member device of the winning player, and a second advice message set (e.g., a message to complain of failure) may be displayed on a member device of the losing player. When such a suggested message is selected by a user input, a chat message indicating desired content is caused to be provided in the chat conversation. In another example, the advice event is a notification that the second user in the first user device's embedded application and embedded interface has joined the game, and when the advice response is selected, the advice response causes the comma or challenge to be output to the second player's user device ("we Let's go, user 2", "i am to defeat you" in this game, etc.) and/or all member devices (or alternatively all chat devices).
In some embodiments, an embedded application (e.g., script) may be attached to (associated with) the suggestion response by, for example, being directly encoded in the data of the suggestion response or in a user selectable link (or other displayed selectable control) included in the suggestion response. For example, a small embedded application of several hundred kilobytes may be so attached. When the user selects the suggestion response, the opening of additional embedded applications (after decoding) is triggered, e.g., instead of downloading the embedded applications from a source (e.g., embedded application server 150) over a network. In some cases, this functionality may eliminate or reduce additional download time of the embedded application data and may provide for immediate running and display of the embedded interface. In some embodiments, the additional embedded application may be a lightweight version and may be run in addition to downloading a more complete version of the embedded application triggered in the background of the device, which may replace the lightweight version on the device after the download occurs.
In some embodiments, additional embedded applications may run in the background of the device's operating system (or other software environment) (e.g., in a "headless mode") that does not cause the embedded interface or other output to be displayed by the embedded application. For example, additional embedded applications may generate suggested responses that are displayed in the chat interface. Additional embedded applications may provide instant extensions and capabilities to the messaging application, which may be created in-time during a chat conversation, for example, based on messages of the chat conversation and/or associated suggested responses selected by the user. The messaging application may use the APIs and functions of the additional embedded applications without downloading and running the embedded applications, e.g., displaying their own respective versions of the associated embedded interfaces.
In some embodiments, the additional embedded application may be associated with or attached to a chat conversation for which the additional embedded application is running, e.g., continuously associated with the chat conversation. For example, additional embedded applications may act as extensions to the chat conversation, e.g., when the chat conversation is opened and/or displayed on the device, the embedded applications run in the background. Such additional embedded applications may process chat messages entered into a chat conversation and perform actions in response to the chat messages, such as providing automatic replies to certain types of chat messages, automatically translating chat messages into different languages, providing always-on location sharing (indicating the current geographic location of the user device) when the message application is open (with user consent), adding displayed graphical interface elements to the chat interface, and the like. In some examples, chat messages of a chat conversation may be automatically translated into and displayed as messages in different languages, for example, by using an additional embedded translation application as an extension of the message application. The extended embedded application may enhance the camera application or the image selector application, for example, to modify media items such as images prior to sharing the media items with other devices in the chat conversation or through a different embedded application. In further examples, the extended embedded application may anonymize a chat conversation or a particular user in the chat conversation (e.g., change a user identifier of a displayed chat user), reorder the display of chat messages in the conversation (e.g., by topic, by grouping messages by thread that includes a continuous reply to an original chat message, etc.), so that functionality in the chat interface may be accessed by user input (e.g., a display control that fixedly persists media items or chat messages posted in the chat conversation in a display area of the chat interface, or a control that appends comments to media messages stored in a shared database, for example).
In some embodiments, additional embedded applications provide for one-time running of chat conversations (e.g., to modify and re-share images entered into the chat conversation), or one-time translation of chat messages. In some embodiments, such embedded application extensions and/or disposable scripts may be downloaded from a server, or may be directly attached to a user-selectable chat message or suggestion response (link) (e.g., encoded script as a parameter (e.g., uniform resource locator (Uniform Resource Locator, URL)) provided as a web address).
In a similar manner, additional embedded applications (e.g., small applications using hundreds of KB of memory) may be encoded in the data of a selectable link in a chat message or in the data of an interactive card displayed in a chat interface or chat conversation, and may be run upon selection of the chat message link or a control in the interactive card.
In some embodiments, the suggestion response may be generated based on suggestion events that occur at an external device or program that is outside of the messaging application and chat conversation, e.g., as described above, and the suggestion response may provide commands and/or messages for output to the external device or program. For example, the embedded application may communicate with an online game (e.g., a game running on a server), and commands entered into the embedded application may affect the state of the game, e.g., being communicated to the game server. If an event occurs in the game that can be responded to by the first user providing input to the embedded application, the suggested response may include an action to provide input to the embedded application that will result in a responsive user action in the online game.
In some embodiments, if consent for this by the applicable user has been obtained, a suggested response may be generated based on specific events and/or suggested events that occurred in the past. For example, previous events may be indicated or described in stored historical data. In some examples, a log of previous chat messages entered in a previous chat conversation between two users may be used to determine a message to be included as a new suggestion response for a current chat conversation that includes the same two users. The suggestion response may be based on a previous history describing the performance of a particular user in the embedded gaming application, such as previous goals or scores obtained by the user in the game. For example, the advice message "you do better than before-! ". The recorded prior interactions between users in the embedded application may also be used to generate a suggestion response if user consent has been obtained. For example, previous user interactions in the gaming application may be used to generate new suggested game actions that were successful in the previous game, and/or to generate suggested messages (e.g., "I do better this time"), or previous contributions of the user to the shared document application may be used to generate suggested commands that add the same contributions to the new shared document. In another example, if it is determined that the user has previously added a list item to a first shared list in the embedded list application, as described in the stored history data, a suggestion command may be generated for the user with respect to a newly created second shared list (e.g., having the same or similar tag or title as the first list). For example, when a suggestion command is selected, the suggestion command adds the same list item to a second list, where the second list has been determined to have the same tag (e.g., a "shopping list") as the first list.
In some embodiments, the number of suggested responses displayed may be limited, for example, by combining multiple suggested responses into a single suggested response displayed. For example, a single suggestion response, when selected, may result in multiple actions or inputs to one or more applications (embedded applications, messaging applications, servers, etc.). In some examples, the suggested event is entering a chat message "don't forget the birthday of Timmy on friday" by a different chat user in the chat conversation. The determined suggested response to this chat message may include a suggested message "do not worry" (chat message), a suggested command to add ' Timmy ' to the calendar of the first user, a suggested command to set an alarm clock or reminder on the first device to activate at Timmy's birthday, and a suggested command to add item ' Timmy's birthday purchase gift "to the shopping list in the list-embedded application. These three suggested commands trigger actions in the embedded application and/or the robot program. However, these three advice commands may occupy a large amount of screen space and thus may be combined into a displayed merged advice command, such as "set reminder for the birth date of Timmy". "when selected by user input, the merge suggestion command will cause a selection menu to be displayed that includes three individual suggestion commands. Any or all of these individual suggestion commands may be selected by user input.
In some embodiments, the suggested response items determined for the first chat conversation may provide commands or messages to a different, second chat conversation (e.g., implemented by a messaging application (or a different application)) when selected by user input. A user may participate in multiple chat conversations in parallel, and a suggestion response selected in one chat conversation may trigger an action in a different chat conversation. For example, in a first chat session between user 1 and user 2, user 1 enters a chat message "user 2, without forgetting Timmy's birthday gift. "this message may be a suggestion event that causes a suggestion response (command) to be generated on the user 2's device. When the user inputs select this suggested response, the item "buy gift for Timmy" is added to the list of birthdays that have been created in the embedded application in the second chat session in which user 2 participated. In another example, user 1 and user 2 enter chat messages in a first chat conversation regarding a game that user 1 is playing in a second set of conversations, and generate a suggestion response that, when selected by user 1, causes a particular chat message (or other displayed prompt) to be output in the first chat conversation. For example, a particular chat message may invite user 2 to join a game in a first chat session or cause an interactive card including a displayed join control to be displayed on user 2's device.
In some embodiments, the suggestion response may be customized based on the embedded application that has been run at least once by the first device. In some embodiments, the suggestion response may be customized for the chat conversation based on an embedded application that is run at least once by the first device in the same chat conversation. In some embodiments, the suggestion response may be customized based on an embedded application that has been run at least once by the devices of one or more member users, or in some embodiments by the devices of one or more chat users. For example, if the embedded application has been previously run by the device, a command or message to the embedded application may be provided on the device as a suggestion response (in response to the suggestion event). In some examples, if the first device has previously run the shared list embedded application, when the chat user enters a chat message in a chat conversation that includes particular items (e.g., words, images, or other content data) related to the event organization or recommendation, a suggestion response may be generated on the first device that is a command to add those particular items to an existing list or a new list in the shared list embedded application. In some examples, member devices that have not previously run the shared list embedded application will not display suggested responses related to the shared list embedded application. In some embodiments, a suggestion command or message may be provided on one, some, or all member devices (or chat devices) if any member devices (or chat devices) have previously run an embedded application.
In some embodiments, one or more suggested response items may be generated based on one or more robot program calls or request information accessible from a device providing the suggested response items. For example, if a suggested item generation component (e.g., a suggestion server or other component of the system) determines that an appropriate suggested item is to be specific information related to the content of a media item being played, a robot program that can obtain the information may be determined, and commands and/or requests to the robot program may be generated as suggested items.
In some embodiments, if the selected suggested response item is a command or request for a bot, the bot may be added to the chat conversation and the requested information is retrieved and displayed in the chat interface, and the user may send further messages to the bot.
In various example embodiments using the above features, a chat interface as generated by the messaging application as described above may be displayed by the first user device. The chat interface is configured to display one or more messages provided in a chat conversation configured to display messages provided by user devices participating in the chat conversation over a network. The embedded interface is provided by the first embedded application and displayed in the chat interface. For example, a determination is made that a suggested event has occurred in association with a first embedded application (or message application) based on received data indicating that a particular event occurred at one or more of a plurality of user devices participating in a chat conversation, wherein the one or more of the plurality of user devices are different from the first user device. The first user device (e.g., a message application) obtains one or more suggested response items based on the suggested event and displays the suggested response items by the first user device.
For example, the particular event may include user input received by an associated chat interface of one or more of the plurality of user devices, user input received by an associated embedded interface of one or more of the plurality of user devices, an embedded application event occurring in an associated embedded application running on one or more of the plurality of user devices, and the like. The received data may indicate a type of content feature displayed in a media item played by the first embedded application, achievement of a predetermined goal in a game of the first embedded application, user input received by a receiving user device engaged in a chat conversation, launching of the embedded application from a particular user device of the plurality of user devices, and so forth. The received data may include chat messages. The suggested event may be based on, for example, user input received in the chat interface and/or the embedded interface, and/or event information indicating that a particular event occurred in the first embedded application (and/or that a particular event occurred in a corresponding embedded application running on a different chat device) based on an indication from the first embedded application. The one or more suggested response items may be determined by an embedded application, a messaging application, and/or a remote server in communication with the messaging application over a network. In some examples, the embedded interface may be output on a subset of user devices participating in the chat conversation, where the user devices receive a user selection to join an embedded session involving the first embedded application. The first embedded application may display embedded output data generated by the first embedded application and/or received from a server over a network.
Features for such embodiments may include receiving user input selecting a selected suggestion response item from the suggestion response items, outputting a chat message associated with the selected suggestion response item in a chat conversation of a chat interface of the first user device, e.g., such that the chat message is displayed by one or more other user devices of the user devices participating in the chat conversation. For example, the suggestion response items may include one or more chat messages indicating a user's reaction to the suggestion event and/or may include one or more commands provided to the embedded application and/or the messaging application. In some examples, the command to the embedded application may include a command to perform an action in a game implemented by the embedded application, a command to change a playback position when the embedded application plays media data, and/or a command to change a shared object provided by the embedded application. In some examples, the suggestion response items that provide the suggestion commands are visually distinguished from the suggestion response items that provide the suggestion messages when displayed in the chat interface.
In a further example, the first embedded application may be a media player application that causes video data (or other content data) to be displayed in an embedded interface displayed by a subset of user devices participating in the chat conversation, wherein the embedded interface is configured to receive user input that controls playback of the video data, and the suggestion response items may include one or more suggestion playback commands operable to adjust playback of the video data. In another example, the first embedded application may be a gaming application that causes game data to be displayed in an embedded interface displayed by a subset of user devices participating in the chat conversation, wherein the embedded interface is configured to receive user input that changes one or more states of the gaming application, and the suggestion response items may include one or more suggestion commands operable to modify at least one state of the gaming application. In another example, the first embedded application may be a shared document application that causes a shared content document (e.g., a list of items) to be displayed in an embedded interface displayed by a subset of user devices participating in the chat conversation, wherein the embedded interface is configured to receive user input that changes one or more items in the shared document, and the suggestion response items include one or more suggestion commands operable to modify the shared document.
In further examples, the server device may receive a join indication (or request) over the network from a chat device that has launched an embedded application associated with an existing embedded session. The join indication is sent by the server device over the network to other chat devices (member devices) in the embedded session to synchronize the join device with the member devices of the embedded session.
The methods, blocks, and operations described herein may, where appropriate, be performed in a different order than shown or described, and/or concurrently with other blocks or operations (partially or fully). Some blocks or operations may be performed on one portion of data and later, for example, performed again on another portion of data. Not all illustrated blocks and operations may be required to be performed in the various embodiments. In some embodiments, blocks and operations may be performed multiple times in a method, in a different order, and/or at different times.
In some embodiments, some or all of the methods may be implemented on a system, such as one or more client devices. In some embodiments, one or more of the methods described herein may be implemented, for example, on a server system and/or on both a server system and a client system. In some embodiments, different components of one or more servers and/or clients may perform different blocks, operations, or other portions of the method.
In various embodiments, a messaging application, an embedded application running in association with a messaging application, and/or a server in communication with a messaging application may perform one or more blocks of the described methods.
8A-8E are graphical representations of example user interfaces displayed by a user device (e.g., a client device). In these examples, the messaging application is used for chat conversations between users, and the embedded media player application is used in association with the messaging application.
In fig. 8A, an example of a first chat interface 800 of a first messaging application is displayed on a first user device operated by a first user (e.g., "Sarah c"). In this example, a chat conversation "HanginOut" has been initiated that includes participation of the first user and the first device, as well as participation of one or more other users and user devices. Chat messages from chat users to chat conversations may be entered at the respective user devices, sent to the first user device if applicable, and displayed by the messaging application in the chat interface. For example, a chat message from the first user may be entered in the input field 802 of the chat interface 800 (e.g., via an input device such as a physical keyboard, a displayed touch screen keyboard, voice input, etc.). Chat messages may be displayed in message display area 804 of chat interface 800.
In this example, the first user has entered a command in the input field 802, where the received command is displayed in the chat interface as message 806 after being entered. This command specifies that an embedded interface is to be displayed in association with the chat conversation. In this example, the embedded interface is provided by an embedded application, which is a video player "vidplay" running on the first device. The command also specifies the media item that is played with the video player application, i.e., video clip "MusicVidA". The command also has a "share" parameter so that the play of the video is shared as an embedded session in the chat conversation. In some embodiments, a media player application may be selected to display an embedded interface without sharing its output in an embedded session associated with a chat conversation. In some embodiments, instead of entering the commands shown, the first user may select to play the media item by browsing through a menu that displays the media items and selecting the desired media item, or selecting the media item in a different manner. In some embodiments, the first user may execute the embedded application without selecting a media item and then select the media item using a menu of the embedded application (e.g., in an embedded interface).
Responsive to command 806, response message 808 can be displayed by the bot or messaging application in the chat interface, for example, as if the bot or messaging application were a chat user. Response message 808 indicates that the selected embedded video player application is running. In some cases or embodiments, selection of the embedded application (and/or media item) causes the embedded application to be downloaded to the first device in the background, for example, from an embedded application server connected to the first device over a network.
The embedded application runs on the first device and displays an embedded interface 810. In this example, the embedded interface 810 is displayed within the chat interface 800, for example, within the message display area 804 of the chat interface. In some embodiments, the embedded interface 810 is displayed based on data received by the first device over a network, for example, from an embedded application running at least in part on a remote session server or other device connected over the network. In this example, the embedded interface 810 is displayed such that the message display area 804 is at least partially displayed, e.g., allowing one or more chat messages in the message display area 804 to be displayed simultaneously with the embedded interface 810.
The embedded interface 810 includes a display area 812 for displaying content data (e.g., video data, image data, etc.) of the media item, a search control 814 that allows the first user to provide user input to change the playback position of the media item along a timeline (e.g., move the control to the left or right), and a full screen control 816 that allows user input to zoom in the embedded interface 810 to the entire screen (or other display area) of the first device. A user identifier 818 may be displayed to indicate which user in the chat initiated the embedded session associated with interface 810. The user identifier 818 is shown as identifying an image, but may also or alternatively be text (e.g., name), or the like. The list 820 may show the media items currently being played in the display area 812 as well as other media items queued for play after the media item is completed. The close control 822 allows user input to close the embedded interface 810 and close the embedded application, e.g., such that it is no longer running on the first device.
In some embodiments, one or more embedded application indicators 824 may be displayed in the chat interface to indicate which embedded sessions are currently active. Some embodiments may also display an indicator in the chat interface to indicate an update to the embedded session since the first user was last a member user of the embedded session (e.g., user input to the corresponding embedded interface). For example, such an indicator may be an indicator 826 displayed in association (e.g., adjacent or overlapping) with the embedded application indicator 824.
In fig. 8B, an example of a second chat interface 840 of a second messaging application is displayed on a second user device operated by a second user (e.g., "Emily d."). In this example, the second user is a participant of a chat conversation "HanginOut" that includes the first user and the first device as described in fig. 8A. The chat message may be entered by the second user in chat interface 840, for example, via input field 842 and an input device (e.g., an on-screen keyboard, etc.). In this example, the second user has entered a message 844 into the chat conversation that is displayed in a display area 848 of the chat interface 840. In response to message 844, the first user has entered message 846 into the chat conversation as displayed in display area 848 of chat interface 840.
In addition, an embedded conversation notification 850 is displayed in chat interface 840. Notification 850 indicates that the embedded session is active, in this example, it utilizes an embedded video player application that is run by the first user in fig. 8A. After the second device receives information from the session server or the chat device that has been initiated and is an active embedded session, a notification 850 may be displayed in the chat interface 840. Notification 850 is displayed below display area 848 in chat interface 840 in this example, or may be displayed in other areas of chat interface 840 (or outside chat interface 840) in other embodiments.
In this example, notification 850 includes a flag 852 (e.g., an icon or symbol) of an embedded video player application that is run by the first user in fig. 8A to initiate the associated shared embedded session. The notification 850 also includes the name 854 of the media item that was played in the embedded session. Notification 850 also includes a list 856 of chat users that have joined the embedded session (e.g., that are currently member users of the embedded session). Notification 850 also includes a join control 858 that may accept user input to cause the second user and the second device to join the embedded session (if selected). Notification 850 also includes a close control 860 that can receive user input to cause notification 850 to be removed from chat interface 840.
In fig. 8C, chat interface 840 of fig. 8B is shown with an example update after the second user has selected to join the embedded session indicated in notification 850 of fig. 8B. For example, the second user may have selected the join control 858 of FIG. 8B. In fig. 8C, an embedded interface 870 has been displayed in chat interface 840. For example, the embedded interface 870 may be provided by a second embedded application that has been downloaded (and in some cases run) by the second device in response to the second user joining the embedded session. In other embodiments, the embedded interface 870 is displayed based on data received over a network, for example, from an embedded application running at least in part on a session server or other device. The second embedded application corresponds to the video player application that provides the embedded interface 870 on the first device of fig. 8A. In this example, the embedded interface 870 is displayed such that the message display area 848 is at least partially displayed, e.g., allowing one or more chat messages in the message display area 848 to be displayed during display of the embedded interface 870.
After the second user and the second device have joined the embedded session, the playback location of the media item displayed in the embedded interface 870 is synchronized with the current playback location of the embedded session (e.g., as shown by the embedded interface 810 of the first device in fig. 8A). Thus, the second user begins viewing the played media item at a playback position after the media item begins and shares a viewing experience with other member users of the embedded session. The embedded interface 870 includes features similar to the embedded interface 810, such as a display area 872, a search control 874 that allows a second user to provide user input to change the playback position of a media item along a timeline, a full screen control 876, a user identifier 878 that indicates the user that initiated the embedded session associated with the interface 870, and a close control 882. List 880 shows the media item 884 currently playing in the display area 872 and the identifiers of the users instructed to play the media item 884. In this example, the list 880 also includes a second media item 886 that is queued to play after the media item 884 has completed playing, and includes an identifier indicating the user playing the media item 886.
In this example, the second user has been permitted to control playback functions in the embedded session, and the second user can manipulate the search control 874 to change the current playback position of the media item to a position that is either before or after the current position, for example. Such changes are applied to all embedded interfaces displayed by the member devices of the embedded session such that media item viewing is synchronized between the member devices. In other situations or embodiments, the second user may not be provided with permissions or privileges (e.g., from the first user activating the embedded session) and will not be able to adjust the playback position of the media item.
In fig. 8D, the chat interface 840 of fig. 8C is shown with an example update after the second user has selected to enter a new message in the chat conversation of the chat interface. For example, the second user may have selected the input field 842 of the chat interface 840 during playback of a media item in the embedded interface 870. In some embodiments, this can cause the displayed keyboard 890 to be displayed in or near the chat interface 840 (e.g., such that at least a portion of the message display area 848 is still displayed), which can be used to enter a new message, such as text 892. When text 892 is entered (e.g., via the enter control in keyboard 890), text 892 may be displayed as chat message 894. Some embodiments may provide message suggestions 896 as a response to the last chat message 846, any of which may be selected by user input to provide a chat message having the selected message suggestion 896 to the chat conversation in message display area 848.
In some embodiments, the size of the embedded interface 870 may be adjusted to allow display space for both the keyboard 890 and chat messages of a chat conversation. In this example, the size of the embedded interface 870 has been reduced as shown. Chat message 846 and new chat message 894 may be displayed with embedded interface 870.
In fig. 8E, a chat interface 840 is shown similar to fig. 8C, with example user comments displayed in the embedded interface 870 and associated with the played media item. At the current playback position of the media item displayed in the embedded interface 870, a user comment 897 is displayed. In various embodiments, the displayed user comment 897 may include a comment and an identification of the user who entered the comment.
In some embodiments or situations, the information of the user comment 897 is entered by a member user currently viewing a media item in the embedded session. For example, user comment 897 may be displayed at a user-directed location in a display area of the embedded interface, displayed for a predetermined amount of time, and then removed from the display. In some cases, user comment 897 may have been previously entered by a chat user when the chat user views the same media item on a previous occasion while participating in a chat conversation (e.g., may be an ongoing chat group). For example, the media item may have been played by a chat user in a previous embedded session in a chat conversation, the chat user entering user comments at a particular playback location and position in the display area. User comments are stored in association with chat conversations, media items, and play locations. When a media item is displayed in the current embedded session, user comment 897 is displayed when the playback position is at (or near, e.g., within a threshold time) the same position at which the user comment was previously entered.
In some embodiments, one or more suggestion response items 898 can be displayed in chat interface 840 and/or embedded interface 870. In this example, the suggestion response item 898 is displayed in response to a detected suggestion event, which is a display of user comments 897 in the embedded interface. In this example, the suggestion command has been determined by the embedded application (e.g., generated by a machine learning model or other technique) and provided to the messaging application for display in chat interface 840. If the suggestion command is executed, the suggestion command will cause the embedded application to skip video playback of the media item to the next user comment stored for the played video. If the user selects the suggested command, the command is sent to the embedded application and playback in the embedded interface 870 is changed to the playback position of the next user comment. Suggested messages are also determined in this example as a reaction to user comments 897 determined by the system (e.g., based on a machine learning model that provides training data for sample user messages that are similar comments). Other suggested messages may be determined in response to any member user action in the embedded session, one or more chat messages in the chat interface, and/or the like. If the user selects a suggested message, the message is displayed as a chat message in chat interface 840 (e.g., in message display area 848). In some embodiments, the selected suggestion message may be added to the media item as a user comment similar to user comment 897. For example, the selected message may be located within the embedded interface 870 and/or a display area 872 adjacent (e.g., below) the existing user comment 897 as a default location. In some embodiments, suggestion response items such as suggestion commands and/or suggestion messages may be displayed in association with a displayed keyboard or other input control, e.g., similar to message suggestion 896 shown in fig. 8D.
Fig. 9A-9C are graphical representations of additional example user interfaces displayed by a user device. In these examples, the messaging application is used for conversations between users, and the embedded gaming application is used in association with the messaging application.
In fig. 9A, an example of a first chat interface 900 of a first message application is displayed on a first user device operated by a first user (e.g., "Sarah c"). In this example, a chat conversation "HanginOut" including participation of the first user and the first device has been initiated, similar to that described with respect to fig. 8A. Chat messages from the first user may be entered in an input field 902 of the chat interface 900 (e.g., using an input device or keyboard similar to the keyboard 890 above), and chat messages may be displayed in a message display area 904 of the chat interface 900.
In this example, the first user previously entered a command in the input field 902, and after being entered, the received command is displayed in the chat interface as message 906. This command specifies an embedded interface to be displayed in association with the chat conversation. In this example, the embedded interface is provided by an embedded application, which is the game "toad", which in some embodiments may be running on the first device. The command also has a "share" parameter to enable the game to be shared as an embedded session in the chat conversation. In some embodiments, the gaming application may be selected to display the embedded interface without sharing its output in an embedded session associated with the chat conversation. In other embodiments, the first user may choose to launch the embedded game application by selecting the embedded game application from a menu, list, or the like.
Responsive to command 906, response message 908 can be displayed by the bot or messaging application in the chat interface, for example, as if the bot or messaging application were a chat user. Response message 908 indicates that the selected embedded gaming application is being run. In some cases or embodiments, the selection of the embedded gaming application causes the embedded gaming application to be downloaded to the first device in the background, for example, from an embedded application server connected to the first device over a network.
After the embedded application (or a portion thereof) has been stored on the first device, the embedded application runs and displays the embedded interface 910. In this example, the embedded interface 910 is displayed within the chat interface 900, e.g., within the message display area 904 of the chat interface, such that a portion of the message display area 904 remains displayed. In some embodiments, the embedded interface 910 is displayed based on data received by the first device over a network, for example, from an embedded application running on a remote session server or other device connected over the network.
The embedded interface 910 includes a display area 912 for displaying game output. In this example, display area 912 may accept user input, e.g., selection of a location within the display area as a command or action in a game. The full screen control 914 allows the user input to zoom in the embedded interface 910 to the entire screen (or other display area) of the first device. A user identifier 916 may be displayed to indicate the first user as a chat interface for the player of the game. In some embodiments, the game score 918 may be displayed alongside the user identifier 916 (or otherwise associated with the user identifier 916) to indicate the current score of the identified user. The close control 920 allows user input to close the embedded interface 910 and close the embedded gaming application, e.g., such that it is no longer running on the first device.
In some embodiments, one or more embedded application indicators 924 may be displayed in the chat interface to indicate which embedded sessions are currently active, similar to that described above.
In fig. 9B, an example of a second chat interface 940 of a second messaging application is displayed on a second user device operated by a second user (e.g., "Emily d."). In this example, the second user is a participant comprising a chat conversation "HanginOut" with the first user as described with respect to fig. 9A. The chat message may be entered by the second user in chat interface 940, for example, via input field 942. In this example, the second user has entered a message 944 into the chat conversation that is displayed in a message display area 948 of the chat interface 940. In response, the first user has entered a message 946 into the chat conversation, as displayed in the display area 948 of the chat interface 940.
An embedded conversation notification 950 is displayed in the chat interface 940. Notification 950 indicates that the embedded session has been initiated and/or is active, in this example, utilizing an embedded gaming application run by the first user in fig. 9A. After the second device receives information from the session server or chat device that the embedded session has been initiated and is active, a notification 950 may be displayed in the chat interface 940. In various embodiments, notification 950 may be displayed in display area 948 or other areas of chat interface 940, or outside chat interface 940.
In this example, notification 950 includes a logo 952 (e.g., an icon or symbol) of an embedded game application that is run by the first user in fig. 9A to initiate an associated shared embedded session. Notification 950 also includes a list 956 of chat users that have joined the embedded session (e.g., that are currently member users of the embedded session). Notification 950 also includes a join control 958 that may accept user input to cause the second user and the second device to join the embedded session (if selected). Notification 950 also includes a close control 960 that can accept user input to cause notification 950 to be removed from chat interface 940.
In fig. 9C, after the second user has selected to join the embedded session indicated in notification 950 of fig. 9B (e.g., by selecting join control 958), chat interface 940 of fig. 9B is shown with an example update. In fig. 9C, an embedded interface 970 is displayed in chat interface 940 such that a portion of message display area 948 (and one or more chat messages) remains displayed. For example, the embedded interface 970 may be provided by an embedded gaming application that has been downloaded (and in some cases run) by the second device in response to the second user joining the embedded session. In other embodiments, the embedded interface 970 is displayed based on data received over a network, for example, from an embedded application running on a session server or other device. The embedded gaming application corresponds to the embedded gaming application that provides the embedded interface 910 on the first device of fig. 9A.
After the second user and the second device have joined the embedded session, the game state of the embedded interface 970 is synchronized with the current game state of the embedded session implemented on the corresponding embedded gaming application. In some embodiments, the session server or other server may synchronize the game state on the member device during the game by continuously receiving the game state from the member device and sending a synchronization update to the member device. Some embodiments may provide peer-to-peer synchronization between member devices.
The embedded interface 970 includes features similar to the embedded interface 910 of fig. 9A, including a display area 972 that displays the output of the game and that can accept user input. Full screen control 974 allows user input to zoom in embedded interface 970 onto the entire screen (or other display area) of the first device. The close control 976 allows the user input to close the embedded interface 970 and close the embedded gaming application, e.g., such that it is no longer running on the second device. A user identifier 978 may be displayed to indicate a second user of chat interface 940 that is a player of the game. In some embodiments, the game score 980 may be displayed alongside the user identifier 978 to indicate the current score of the user. In this example, other user identifiers 982 and associated game scores 984 are displayed to indicate other player users participating in the embedded game session and their current scores in the shared game. In some embodiments, member users having an observer or referee character in the game may be visually distinguished from users having player characters in the display.
In some embodiments, the game provided in the embedded session may be a real-time game in which a player user may provide user input (e.g., game actions) to the game at any time to change the game state, and the embedded game application may continuously provide output in real-time, e.g., based on its own events and/or in response to user input. Some embodiments may provide for an embedded gaming application that is asynchronous or round-robin, for example, where a game waits for input from one player (or multiple players) to change game state and/or output, and the game waits for next input from the same player or a different player, etc. The game output is displayed in an embedded interface of the observer user, where the input that the observer user can provide to the game is more limited, e.g., does not affect the game state.
The output from the game may be displayed in the embedded interface 970 and/or as a message displayed in the message display area 948 of the chat interface 940. For example, messages from game objects may be displayed as chat messages in message display area 948, as described above with reference to FIG. 6.
In some embodiments, one or more embedded application indicators 986 may be displayed in the chat interface to indicate which embedded sessions are currently active, similar to that described above.
Fig. 10A-10D are graphical representations of additional example user interfaces displayed by a user device. In these examples, the messaging application is used for chat conversations between users, and the embedded application is used to provide shared content documents in the form of a shared item list.
In fig. 10A, an example of a chat interface 1000 for a message application is displayed on a first user device operated by a first user (e.g., "Emily d."). In this example, a chat conversation "HanginOut" has been initiated that includes participation of the first user and the first device, similar to that described with respect to fig. 8A and 9A. A chat message from the first user may be entered in the input field 1002 of the chat interface 1000 and the chat message may be displayed in the message display area 1004 of the chat interface 1000.
In this example, several chat users have entered messages in the chat conversation, as indicated by message 1006 entered from three chat users different from the first user and displayed in display area 1004. Chat message 1008 has been entered by the first user and displayed in the chat interface in display area 1004. In this example, chat messages from other users are identified by graphical user identifiers and chat messages entered by the first user are displayed in right-justification on the display screen.
An embedded conversation notification 1020 may be displayed in the chat interface 1000. Notification 1020 indicates that the embedded session is active, similar to notifications 858 and 958 described above with respect to fig. 8 and 9. In this example, after the user "Pamela" has initiated the embedded session by selecting the embedded list application to run and selecting to share the list provided by the embedded list application, a notification 1020 is displayed. After the first device receives information from the session server or chat device that the embedded session has been initiated and is active, a notification 1020 may be displayed in the chat interface 1000. The notification 1020 may be displayed in the display area 1004 or in other areas of the chat interface 1000 or outside of various embodiments of the chat interface 1000.
In this example, notification 1020 includes an indication 1024 (e.g., an icon or symbol) that identifies the embedded list application used in the embedded session. The notification 1020 also includes the current number 1026 of user response items in the list provided in the embedded session. Notification 1020 also includes a list 1028 of chat users that have joined the embedded session (e.g., are currently member users of the embedded session). The notification 1020 also includes a join control 1030 that, if selected, allows the first user to join the embedded session, and a close control 1032 that, if selected, causes the notification 1020 to be removed from the chat interface 1000.
In some embodiments, such as the example of fig. 10A, a notification 1022 may be displayed in the chat interface (e.g., in the display area 1004) to indicate that the user has initiated the embedded session. The notification 1022 may include a description of the data provided in the embedded session contributed or selected by the member user, such as the number of items in the list in this example.
In fig. 10B, the chat interface 1000 of fig. 10A is shown with an example update after the first user has selected to join the embedded session indicated in the notification 1020 of fig. 10A. For example, the first user may have selected the join control 1030 of FIG. 10A. In fig. 10B, embedded interface 1040 has been displayed in chat interface 1000 such that a portion of message display area 1004 (and one or more chat messages) remains displayed. For example, the embedded interface 1040 may be provided by an embedded application that has been downloaded (and in some cases) and run by the first device in response to the first user joining the embedded session, similar to that described above. In other embodiments, the embedded interface 1040 is displayed based on data received over a network, such as from an embedded application running on a session server or on other devices. The embedded application is the same list application that was launched by the user Pamela to create the embedded session indicated in notification 1020 of fig. 10A.
In this example, the embedded interface 1040 includes a shared list name 1042, where the default is based on the chat conversation name. The embedded interface 1040 displays the items 1044 in a list, wherein the items 1044 may be selected by member user input to indicate that the items have been completed or are no longer relevant. An add control 1046 allows the user to input adding new items to the list and enter text to name the new items. Completed items 1048 may be displayed with visual indications that they have been selected by user input to be deemed completed or implemented. A close control 1050 may also be provided. Other features such as a list of member users that indicate or have contributed to a list of particular items may be displayed in various embodiments.
The list of items displayed in embedded interface 1040 is synchronized with the embedded interfaces of all member devices such that each member device displays the same item and item status in the list. In some embodiments, the watcher status may be assigned to one or more member users, for example by the member user initiating the embedded session, where the watcher user cannot modify the list.
In fig. 10C, the chat interface 1000 of fig. 10B is shown with an example update after the first user has selected to enter a new message in the chat conversation of the chat interface. For example, the first user may have selected the input field 1002 of the chat interface 1000. In some embodiments, this can cause the displayed keyboard 1060 to be displayed in or near the chat interface 1000, which can be used to enter new messages. Some embodiments may provide message suggestions 1062 as optional elements in response to or in association with one or more chat messages, such as last chat message 1064. Similar to fig. 8D, as shown in the example of fig. 10C, some embodiments can resize (e.g., reduce the size of) the embedded interface 1040 to allow display space in the display area 1004 of the chat interface 1000 for both the keyboard 1060 and chat messages of the chat conversation such that the keyboard 1060, the embedded interface 1040, and a portion of the display area 1004 are displayed simultaneously.
In fig. 10D, the chat interface 1000 of fig. 10B is shown with an example update after the first user has selected to provide input to the embedded interface and the embedded application. For example, the first user may have selected the add control 1046 of the embedded interface 1040 of fig. 10B, such as using a touch screen input or input from another pointing input device, or may have selected a different option in the embedded interface that may accept text input from a keyboard. In other cases, the user may have selected a control in the embedded interface. In some embodiments, this user input to the embedded interface can cause a displayed keyboard 1070 to be displayed in or near the chat interface 1000, wherein the keyboard 1070 can be used to input text (including characters, emoticons, symbols, etc.). For example, a first user may enter a text name or phrase for an item added to the list using keyboard 1070.
Some embodiments may provide one or more suggestions 1072 as suggestion inputs for the embedded interface, e.g., based on interface elements selected by user inputs in the embedded interface and/or based on events of the embedded application. In this example, the suggestion 1072 is determined based on selection of the add control 1046. For example, the embedded application (and/or the messaging application or suggestion server, after sending the list items) may examine the existing list items to determine suggested new list items that are related to the existing items. For example, a stored knowledge base or database (e.g., a hierarchical graph of related concepts) may be examined to find words related to the words in the list.
In some embodiments, as shown in fig. 10D, when keyboard 1070 is displayed to allow input to embedded interface 1040, embedded interface 1040 may remain the normal size as shown (or may be displayed in a larger size than small-sized embedded interface 1040 in fig. 10C). When keyboard 1070 is displayed to enable input to embedded interface 1040, display area 1004 displaying chat messages may be removed from chat interface 1000, as shown.
Some embodiments may display a keyboard similar to keyboard 1070 for input to the embedded interface and/or may display suggestions similar to suggestions 1072 to be input to the embedded interface for other types of embedded applications, such as media players, games, document processing applications, etc., as described herein with respect to other embodiments.
Examples of robot program embodiments
The bot is an automated service implemented on one or more computers with which the user interacts, mainly through text, for example via the messaging application 103a/103 b. The bot may be implemented by a bot provider so that the bot may interact with users of various messaging applications. In some embodiments, the provider of the messaging application 103a/103b may also provide one or more bots. In some embodiments, the bots provided by the providers of the messaging applications 103a/103b may be configured such that the bots may be included in other messaging applications, for example, messaging applications provided by other providers. In some embodiments, one or more bots may be provided by, generated by, and/or included in an embedded application.
The robot program may provide several advantages over other modes. For example, the bot may allow a user to try new services (e.g., taxi booking services, restaurant booking services, etc.) without installing an application or accessing a website on the client device. Further, the user may interact with the bot through text, which requires minimal or no learning compared to learning to use a website, software application, telephone call, such as an interactive voice response (INTERACTIVE VOICE RESPONSE, IVR) service, or other means of interaction with the service. Incorporating the bot in a messaging service or application may also allow a user to cooperate with other users to accomplish various tasks within the messaging service, such as travel planning, shopping, scheduling events, obtaining information, etc., and eliminate cumbersome operations to accomplish tasks, such as switching between various applications (e.g., taxi booking applications, restaurant booking applications, calendar applications, etc.) or websites.
The bot may be implemented as a computer program or application (e.g., a software application) configured to interact with one or more users (e.g., any of the users 125 a-n) via the messaging application 103a/103b to provide information in the messaging application 103 or to perform specific actions. As one example, the information retrieval bot may search for information on the internet and present the most relevant search results within the messaging application. As another example, the travel bot may have the capability to schedule travel via the messaging application 103, for example, by enabling purchase of travel and hotel tickets within the messaging application, making hotel reservations within the messaging application, making rental car reservations in the messaging application, and the like. As another example, the taxi bot may have the ability to call a taxi, for example, to the location of the user (obtained by the taxi bot from the client device 115 when the user 125 allows access to location information), without having to invoke or call a separate taxi booking application. As another example, a trainer/coaching bot may coach a user on some topic within a messaging application to instruct the user, for example, by asking questions that may be present in the examination and providing feedback as to whether the user's response is correct or incorrect. As another example, the game robot program may play a game within the messaging application with the user's counterpart or the same party. As another example, the business robot program may provide services from a particular merchant, for example, by retrieving product information from a merchant's catalog and enabling purchases through a messaging application. As another example, the engagement robot may engage a remote device or vehicle such that a user of the messaging application may chat with the remote device or vehicle, retrieve information from the remote device or vehicle, and/or provide instructions to the remote device or vehicle.
The capabilities of the robot program may include understanding and running on the user's intent. The intent of the user may be understood by analyzing and understanding the user's dialog and its context. The bot may also understand changes in the context of the dialog or changes in the emotion and/or intent of the user based on the dialog evolving over time. For example, if user A suggests that the meeting drinks, but if user B states that he does not like coffee, the bot may assign a negative emotional score to user B for coffee and may not suggest a coffee shop for the meeting.
Implementing a bot that can communicate with a user of the messaging application 103a/103b can provide a number of advantages. Traditionally, users may utilize software applications or websites to perform activities such as paying bills, ordering food, booking tickets, and the like. The problem with this implementation is that in order to perform multiple activities, the user needs to install or use multiple software applications and websites. For example, a user may have to install different software applications to pay utility bills (e.g., from a utility company), purchase movie tickets (e.g., from a ticketing service provider's ticket reservation application, make a restaurant reservation (e.g., from a corresponding restaurant), or may need to access a corresponding website for each event.
Thus, an advantage of one or more of the described embodiments is that a single application enables a user to perform activities involving interactions with any number of parties without the need to access a separate website or install and run a software application, which has the technical effect of reducing the consumption of memory, storage and processing resources on the client device. An advantage of the described embodiments is that the dialog interface makes it easier and faster for the user to accomplish such activities, e.g. without learning a complex user interface, which has the technical effect of reducing the consumption of computing resources. Another advantage of the described embodiments is that implementing a bot may enable various participating entities to provide user interaction at a lower cost, which has the technical effect of reducing the need for computing resources deployed to enable user interaction (such as toll-free numbers implemented using one or more communication servers, websites hosted on one or more web servers, customer support email hosted on an email server, etc.). Another technical effect of the described features is to reduce the problem of consumption of system processing and transmission resources for accomplishing user tasks across a communication network.
Although some examples herein describe interactions between a bot and one or more users, various types of interactions are possible, such as one-to-one interactions between the bot and the user 125, one-to-many interactions between the bot and two or more users (e.g., in a group message session), many-to-one interactions between multiple bots and users, and many-to-many interactions between multiple bots and multiple users. Further, in some embodiments, the robot program may also be configured to interact with another robot program (e.g., robot program 107a/107b, 109a/109b, 111, 113, etc.) via the messaging application 103, via direct communication between the robot programs, or a combination thereof. For example, a restaurant reservation robot may interact with a particular restaurant's robot to reserve a table.
In some embodiments, the bot may use a conversational interface (such as a chat interface) to conversationally interact with the user using natural language. In some embodiments, the bot may use a template-based format to create sentences that interact with the user, for example, in response to a request for a restaurant address, using a template such as "restaurant R is located at L". In some cases, the user may be enabled to select a bot interaction format, e.g., whether the bot interacts with the user using natural language, whether the bot uses template-based interactions, etc.
In the case of a robot program interacting in a dialogue using natural language, the content and/or style of the robot program's interaction may dynamically change based on one or more of the following: the content of the dialog determined using natural language processing, the identity of the user in the dialog, and one or more dialog contexts (e.g., historical information regarding interactions of the user, connections between users in the social graph-based dialog), external conditions (e.g., weather, traffic), schedules of the user, related contexts associated with the user, etc. In these cases, the content and style of the robot program's interactions varies based only on these factors that the user participating in the conversation has provided consent.
As one example, if it is determined that the user of the conversation is using a formal language (e.g., no or minimal slang or emoticons), the bot may also interact within the conversation using the formal language, and vice versa. As another example, if a user in a conversation (based on a current and/or past conversation) is determined to be a heavy user of an emoticon, the bot may also interact with the user using one or more emoticons. As another example, if it is determined that two users in a conversation are remotely connected in a social graph (e.g., having two or more intermediate nodes between them representing friends, such as friends that they are friends), the bot may use a more formal language in the conversation. In the event that the user participating in the conversation does not agree that the bot utilizes factors such as the user's social graph, schedule, location, or other context associated with the user, the content and style of the bot's interactions may be a default style, such as a neutral style that does not require the use of these factors.
Further, in some embodiments, one or more bots may include functionality to engage in a back and forth conversation with a user. For example, if a user requests information about a movie, e.g., by entering "@ moviebot you can recommend a movie? "robot program" moviebot "may respond" do you want to see comedy? The user may then respond, e.g. "no", and the robot program may respond "well, with a good evaluation of the science fiction movies named space and planet. Do i have to give you a reservation? "then, the user may indicate" yes, i may go after 6 pm. Please check if Steve can join. Once the user agrees to the bot to access information about his contacts and once the friend Steve agrees to receive messages from the bot, the bot may send a message to the user's friend Steve and perform further actions at the appropriate time to schedule movie tickets.
In some embodiments, a user engaged in a chat conversation may be enabled to invoke a particular bot or to perform a particular task, such as by typing a bot name or bot handle (e.g., taxi, @ taxibot, @ movie, etc.), by using voice commands (e.g., "call bankbot," etc.), by activating a user interface element (e.g., a button or other element that identifies the bot name or handle), etc. Once the bot is invoked, the user 125 may send a message to the bot via the messaging application 103a/103b in a manner similar to sending messages to other users 125. For example, to order a taxi, the user may type "@ taxibot to call me a taxi"; to book a hotel, the user may enter "@ hotelbot a chinese restaurant book 4 people table near me.
In some embodiments, the bot may automatically suggest information or actions within the chat conversation without being specifically invoked. That is, the user may not need to specifically invoke the robot program. In these embodiments, the bot may rely on analysis and understanding of chat conversations on a continuous time basis or at discrete points in time. Analysis of chat conversations may be used to understand specific user needs and identify when assistance should be suggested by the bot. As one example, if it is determined that a user needs information (e.g., based on a user asking a question to another user, based on multiple users indicating that they do not have certain information), the bot may search for certain information and suggest an answer. As another example, if it is determined that multiple users are indicating an interest in eating a chinese meal, the bot may automatically suggest a collection of chinese restaurants near the user, including optional information such as location, ratings, and links to restaurant websites.
In some embodiments, rather than automatically invoking the bot or waiting for the user to explicitly invoke the bot, one or more users in a message session may be automatically advised to invoke one or more bots. In these embodiments, chat conversations may be analyzed on a continuous time basis or at discrete points in time, and analysis of the conversations may be used to understand specific user needs and identify when a bot should be suggested within the conversation.
In embodiments where the bot may automatically suggest information or actions within a chat conversation without being specifically invoked, for example, such functionality may be disabled if one or more users participating in the chat conversation do not provide consent to the bot to perform analysis of the user's conversation. Further, such functionality may also be temporarily disabled based on user input. For example, when the user indicates that the chat conversation is private, analysis of the context of the conversation is suspended until the user provides input for activating the bot. Further, the participants in the chat conversation may be provided with an indication that the analysis functionality is disabled, for example, using a user interface element.
In various embodiments, the robot program may be implemented in various configurations. For example, as shown in FIG. 1, the robot program 105 is implemented on a client device 115 a. In this example, the robot program may be a module in a software application local to the client device 115 a. For example, if the user has installed a taxi calling application on client device 115a, the bot functionality may be incorporated as a module into the taxi calling application. In this example, the user may invoke the taxi robot program, for example, by sending a message "@ taxibot to me call for a taxi. The messaging application 103b may automatically cause the robotic program module in the car-rental call application to be initiated. In this way, the bot may be implemented locally on the client device so that the user may engage in a conversation with the bot via the messaging application 103.
In another example shown in fig. 1, the robot program 107a is shown implemented on the client device 115a, while the robot program 107b is shown implemented on the message server 101. In this example, the robot program may be implemented, for example, as a client-server computer program, as part of the robot program functions provided by each of the robot program 107a (server module) and the robot program 107b (client module). For example, if the bot is a scheduling bot with a handle @ calendar, the user 125a may schedule the reminder by typing "@ calendar to remind me to receive clothing at night", which may be handled by the bot 107b (client module). Continuing with this example, if the user 125a tells the bot "check if Jim is available at 4, the bot 107a (server module) can contact the user Jim (or Jim's scheduling bot) to exchange messages and provide a response to the user 125 a.
In another example, the robot program 109a (server module) is implemented on the server 135 and the robot program 109b (client module) is implemented on the client device 115. In this example, the robot program functions are provided by modules implemented on the client device 115 and the server. In some embodiments, the bot may be implemented as a distributed application, e.g., with modules distributed across multiple client devices and servers (e.g., client device 115, server 135, message server 101, etc.). In some embodiments, the robot program may be implemented as a server application, e.g., robot program 111 implemented on message server 101 and robot program 113 implemented on server 135.
Different embodiments, such as client only, server only, client-server, distributed, etc., may provide different advantages. For example, client-only embodiments allow for providing the bot functionality locally, e.g., without network access, which may be advantageous in certain situations, e.g., when the user is outside of the network coverage area or in any area with low or limited network bandwidth. Embodiments including one or more servers (such as server-only, client-server, or distributed configurations) may allow certain functions, e.g., financial transactions, ticket reservations, etc., that may not be provided locally on a client device.
Although fig. 1 shows a different bot than messaging application 103, in some embodiments, one or more bots may be implemented as part of messaging application 103. In embodiments where the bot is implemented as part of the messaging application 103, the user permissions are obtained prior to implementation of the bot. For example, in the case of a bot implemented as part of the messaging application 103a/103b, the messaging application 103a/103b may provide a bot that may perform certain activities, such as a translation bot that translates messages to and from, a scheduling bot that schedules events on a user's calendar, and so forth. In this example, the translation robot program is activated only via the user's specific permissions. If the user does not provide consent, the bot within the messaging application 103a/103b is not implemented (e.g., disabled, removed, etc.). If the user provides consent, the bot or messaging application 103a/103b may have limited access to messages exchanged between users via the messaging application 103a/103b to provide specific functionality, such as translation, scheduling, etc.
In some embodiments, a third party, different from the provider of the messaging application 103a/103b and the user 125, may provide a bot that may communicate with the user 125 via the messaging application 103a/103b for a particular purpose. For example, a taxi service provider may provide a taxi robot program, a ticketing service may provide a robot program that may subscribe to event tickets, a banking robot program may provide the ability to conduct financial transactions, and so forth.
When the bot is implemented via the messaging application 103, the bot is allowed to communicate with the user only when authorized by a particular user. For example, if the user invokes the robot program, the robot program may reply, for example, based on the action of the user invoking the robot program. In another example, a user may indicate a particular robot program or a particular type of robot program that may contact the user. For example, the user may allow the travel robot to communicate with her, but not provide authorization for the shopping robot. In this example, the messaging application 103a/103b may allow the travel bot to exchange messages with the user, but filter or reject messages from the shopping bot.
Further, to provide some functionality (e.g., order taxis, make airline reservations, contact friends, etc.), the bot may request that the user allow the bot to access user data, such as location, payment information, contact lists, etc. In this case, the user is presented with the option of allowing or denying access to the robot program. If the user refuses access, the bot may respond via a message (e.g. "sorry, i cannot book you for taxi"). Further, the user may provide access to the information on a limited basis (e.g., the user may only allow the taxi robot program to access the current location when a particular call of the robot program is otherwise not allowed). In various embodiments, a user may control the type, amount, and granularity of information that a robot program may access, and be provided with the ability to change such permissions at any time (e.g., via a user interface). In some embodiments, user data may be processed to, for example, remove personally identifiable information, limit information to specific data elements, etc., before such data may be accessed by the robotic program. Further, the user may control the use of user data through the messaging application 103a/103b and one or more bots. For example, a user may specify that a bot offering the ability to conduct a financial transaction requires user authorization before the transaction is completed, e.g., the bot may send the message "movie space and initial ticket $ 12 for each person. Do i continue to subscribe? The optimal price for the "or" shirt is $ 125, including freight. Do i deduct money from the credit card with tail number 1234? "and the like.
In some embodiments, the one or more suggested response items generated by the above-described system may be messages for invoking or commanding the robot program, e.g., requesting information from the robot program. For example, the system may determine whether the received image includes information to be provided by the bot and/or content that is facilitated by one or more functions. In some examples, a first user in a conversation may send a text message to a second user, saying "where is guessed? The first user then sends the image to the second user's device. The system may determine that the phrase including the word "guess" indicates that the suggested response may be a request to find information related to the image content. (other words may also indicate such requests as "where", "what", etc.) in response, the system may generate a suggested response, which is a request or command to the appropriate robot program that may provide the relevant information. For example, the suggested response may be a name requesting that the map bot provide the location depicted in the image (e.g., where the bot may determine such information using web search, map and atlas, geographic location metadata of the received image, etc.). In some embodiments, training message data (if user consent has been obtained) may be used to determine the appropriate type of bot for the particular type of image content detected in the image (e.g., using one or more image detection or recognition techniques if user consent has been obtained), and/or a rule-based grammar may determine which types of bots to invoke in the suggestion response based on the type of image content and/or concepts detected in the image content.
In some embodiments, if a suggestion item associated with the bot is displayed for the user as a possible response and the user selects the suggestion, the bot may be added to the chat conversation and messaging interface, for example, as represented by the bot name. The bot may determine and output the requested information in a conversation, for example, as messages to the first and second users in the chat interface.
In another example, a first user inputs an image depicting text as a foreign language to a second user to a chat conversation or embedded application. The system may determine that the appropriate suggested item is text in the request language bot translation image and output the translated text in a chat interface or embedded interface.
In another example, the first user enters an image depicting the food item into the chat conversation. The system may determine that the appropriate suggested response is to request the robotic program to examine one or more accessible data sources (e.g., on the internet) to determine the ingredients and/or calories normally or specifically included in the food item and output that information in a message conversation interface.
Embodiments described herein relate generally to messaging applications. Some embodiments may automatically (e.g., without user intervention) analyze image content and/or user information of one or more chat conversations to automatically provide suggested items to a user within a messaging application. In some examples, the user may select an auto-suggest item to respond in an embedded application or a messaging application, and/or the auto-suggest item may be automatically provided as one or more appropriate responses on behalf of the user. In some other examples, the suggestion may automatically incorporate specific non-message functions into the message application.
Suggested items may be provided based on any type of media content received in a chat conversation. For example, such media content may include stickers (e.g., in chat applications), animated images (e.g., movies, GIF images, etc.), and videos. Further, various types of items may be suggested. For example, the advice message may include one or more of an image, a sticker, an animated image (e.g., an shadow map, a GIF image, etc.), and a video. To provide these suggestions, concepts of different types of responses may be utilized, concepts identified in the received item (e.g., text, images, video, decals, animated images, etc.) may be compared, and an appropriate response selected. In various embodiments where the user provides consent, the type of suggested item may be selected or prioritized based on context, e.g., a decal may be provided as suggested item for a particular action in the game, a second video may be provided as suggested item for playing the video, etc.
Some embodiments enable messaging with human users and/or chat bots. In some embodiments, the auto-suggest items may be customized based on whether the chat bot is engaged in a chat conversation. In some examples, a first set of auto-suggest items may be provided if a chat bot is not present in the message conversation, and a second set of auto-suggest items may be provided if a chat bot is present in the chat conversation, wherein the first and second sets of suggest items are at least partially different. For example, these embodiments may employ dialog rules that are followed by the chat bot and suggest items to the user based on the rules. This may alleviate challenges that users may encounter when communicating with chat bots in languages and formats that are easily understood by chat bots.
Some embodiments may include determining one or more trend responses based on other messages in at least one of an area, market, and country associated with the user's location (e.g., messages including popular message content sent by many different users). The one or more determined suggested items may include one or more trend responses. In some embodiments, a user context, e.g., geographic location, holiday, or event, etc., may be used to generate and determine one or more suggested items for presentation.
In some embodiments, determining one or more suggested response items may be based on developing a personalized model for the user using machine learning. Determining suggested items may be based on the user's preferences and/or the user's previous actions in the communication (if the user has been obtained to agree to use such actions and data). For example, the user preferences may include a whitelist indicating specific words that may be included and/or a blacklist indicating specific words that cannot be included in the message suggestion. If user consent has been obtained, the suggested items may be generated or modified based on one or more of punctuation usage, emoji usage, or other content provided by the user on previous occasions.
The machine learning model for providing suggested items may be implemented by the client device 115 and/or the server (e.g., message server 101 and/or servers 150-156). In some embodiments, the chat conversation may be encrypted such that only client devices of participants in the chat conversation may access conversation content. In these embodiments, the model implemented by the respective client device may be used to provide the suggested response items, and the model implemented by the server is not used. The model implemented by the client device may also be used, for example, when the user does not provide consent to the use of the model implemented by the server. In some embodiments, the client-implemented model may be based on or derived from a server-implemented model. In some embodiments, for example, when a client device lacks the ability to implement a client model, a server model may be used and the client model may not be used. In some embodiments, a combination of client and server models may be used.
Although the examples described in this document utilize concepts shown in english, the suggestions may be provided in any language, such as a language of a region or other geography configured for the client device 115, a language selected based on user preferences, and so forth. In some embodiments, where the user provides consent to the analysis of the context of the chat conversation, the language used in the various conversations involving the user (e.g., in the most recent message) may be detected and message suggestions may be provided in that language.
Further examples of robot programs and embedded applications
In some embodiments, the bot as described above may be used in conjunction with the use of an embedded application in one or more chat conversations implemented on a user device.
In some bot embodiments, a user may participate in a chat session with the bot, and no other human user is involved in the chat session. For example, the assistant robot program may be provided by a local program running on the user device, or by a server (e.g., a server application). In some examples, in response to a user entering a bot command (e.g., a command chat message) in a first chat conversation, selecting a bot activation control in the chat interface, a new bot chat conversation including the user and one or more bots may be opened. In a bot chat session, a user may input information (e.g., questions, commands, statements) as messages that may be processed by the bot, and the bot may send commands or data to the embedded application based on those messages. For example, the bot may launch an appropriate embedded application associated with the chat interface based on commands in the chat interface from a user to the bot to join a particular embedded session, play media items, play games, create a share list, and so forth. In some embodiments, the bot may determine and present the suggested response items described herein, e.g., upon providing a command to the bot from a user input in a chat interface, and, e.g., concurrent with the execution of an embedded application and an embedded session associated with the suggested response items. In some embodiments, the bot may receive information about events occurring in the embedded application and may generate and cause the display of an interactive card describing the events in the embedded session, as described herein.
In some examples, in a chat conversation with a bot having media player functionality, a user may enter a question in the chat interface or conversation, and the bot may launch a media player embedded application that plays a particular media item in an embedded interface displayed in association with the bot chat conversation or in association with a different chat conversation (e.g., a chat conversation that includes other human chat users). For example, if played in association with a different chat conversation, the bot chat conversation may be hidden from display and the different chat conversation may be displayed in a chat interface, with the embedded interface displayed in association with the chat interface.
In examples where the embedded application may play the media item, the media player bot may be invoked by the user in a chat session, for example, as described in embodiments herein. For example, the bot may be invoked by entering a command in a chat interface similar to a chat message and including a command syntax (e.g., a symbol before the command), or by entering a different type of selection (e.g., selecting a displayed interface element). The media player bot may support queries from the user related to media items played or playable by the embedded application.
In some embodiments, the media player bot may be used to search for stored media items or other types of content items that have been saved in an accessible store by the user and/or other chat users, and/or have links to content items published in the chat conversation. In some examples, a query for the bot may be entered as a chat message to the chat interface. For example, the search query may be provided as "@ mediaplay cat video" to cause the media player bot to search for cat video in the stored collection of media items. A particular title of the media item may also be queried. In some embodiments, a dialogue search may be provided. For example, a search query may be entered as "display the most recent album of Gameshow to me" or "play the most popular Gameshow videos" or "show me five videos you recommend to me" or "send me a new cat video every day". In some embodiments, the recommended media items may be provided by a content server that may track previous user views and preferences (with user consent) and rank the media items for the user.
Some embodiments may provide one or more bots to receive user input forming a search query for searching for other data items or content items to be used in an embedded application. For example, such items may include items to be added to a shared list, times in a particular time zone to be used in a travel itinerary, names of restaurants for reservation, and so forth. The bot may search for such items on a database, server or user device and other resources accessible through the network. Items found by the bot in response to the search query may be presented in the chat interface for selection by the user, or may be automatically provided by the bot to an associated embedded application (and in some embodiments, the bot may launch the embedded application if the embedded application is not already running). Items provided to the embedded application may be displayed in the embedded interface, if appropriate.
In some embodiments, as described above, playback of a media item in an embedded session may be saved later for a particular user to enable the user to play the media item at a later time (e.g., in a new embedded session). In some embodiments, if consent has been obtained from the chat user, the media items so saved may include a game or other user and a record of the application activity/event that occurred with the chat user in one or more embedded sessions (e.g., captured video data, screen captured images, etc.).
In some embodiments, media items may be saved for the user in a dedicated separate chat session. For example, a user may provide user input in a chat conversation to save a particular media item. In response, a second chat conversation associated with the user is identified, and the bot is associated with the media item. Media items are inserted into the second chat session and previously saved media items are also listed in the second chat session. The messaging application may receive input associated with the media item from the user, for example, to play the selected media item. In response, the first chat conversation is updated by playing the selected media item using the embedded application.
In some additional examples, a save control may be provided in a notification indicating that the media player embedded session is active, or in association with a media item link displayed in the chat conversation. For example, if the user receives a notification that the media player embedded session is active (or sees a link to a media item in the chat interface), the user may select the save control. The selection may cause a second chat session (e.g., a media selection chat session) to be displayed in which only the user and the bot are participating. Links to media items in the embedded session may be displayed in the media selection chat session. In addition, any saved media items from a previous embedded session may be included in the media selection chat session as a previous message. Thus, the user may open a media selection chat session to select and play saved media items associated with the user. In some embodiments, options may be provided to automatically insert a user's media items into a media selection chat conversation, for example, to allow viewing and playing of the media items from a single collection.
In some embodiments, the system (e.g., a bot) provides for selection of additional media items in the chat interface that are determined to be similar to the media items shared in the embedded session. For example, additional media items may have the same genre, be authored by the same artist, or have the same artist as the lead actor, etc.
In some embodiments, a sharing option may be provided that, if selected, causes media items played in the embedded interface to be shared to a different chat conversation, or to a new chat conversation created for the selected sharing action. For example, to cause the sharing option to be displayed, the user may touch the embedded interface that plays the media item for more than a threshold amount of time to cause the sharing option to be displayed, or may select a particular display interface element.
In some embodiments, the user may select a comment control to enable entry of comments to a chat conversation associated with an embedded session in which the media item is played. In some embodiments, links for playing media items are posted in a chat conversation, followed by user comments entered by the user. If the comment control is selected when viewing a saved media item that is seen in a different chat session (e.g., a media selection chat session as described above), the selected comment control may cause the original chat session to be opened and displayed, allowing the person to comment in the original chat session in which the media item was played in the embedded session.
In some embodiments, the suggested responses as described herein may be used with a robot program. For example, selecting the suggestion response may trigger a bot associated with the suggestion response to perform one or more actions in an embedded application, messaging application, or other program or device. In some examples, the bot may perform actions on the embedded application content without opening the embedded application. For example, the embedded application may allow a user to provide commands to the embedded application in a chat interface (e.g., by providing commands to the bot) and allow the user to visually interact with the embedded application via the embedded interface. In some examples where the embedded application has or communicates with a server component (e.g., a game whose game state is managed by the server), commanding the bot to perform actions in the embedded application and the embedded interface via chat messages also causes actions to be performed in the embedded interface displayed by other member devices. In another example, the shared list embedded application causes list data to be stored on the server. The first user opens the shared list embedded application and adds or removes items to or from the list. The devices of the other users may display a suggestion response to add the item to the list via a bot command to the embedded application using the chat interface. For example, the advice response may be in response to a chat message such as "do not forget to purchase beverage for the party" (e.g., "add 'buy beverage" advice response to the' tonight 'list), or in response to a chat message such as "i just purchased soda for the tonight party" (e.g., "remove' buy soda from 'tonight' list"). In some embodiments, when these example suggestion responses are selected by the associated user, the bot may be invoked to send commands to the embedded application and, for example, will not provide commands to the embedded interface. In some embodiments, providing a robotic interface (via a chat interface) in addition to an embedded interface has the advantage that no visual interface needs to be displayed on the device, thus saving device processing, memory and screen space resources, and enabling fast user interaction with content data managed by the embedded application.
FIG. 11 is a schematic diagram of an example sequence including launching of an embedded application and a user joining an embedded session, in accordance with some embodiments. In this example, a first user 1102 ("user 1") is operating a first user device running a message application 1104, the message application 1104 displaying a first chat interface. A second user 1106 ("user 2") is operating a second user device running a second messaging application 1108, the second messaging application 1108 displaying a second chat interface. Chat conversations in which users 1102 and 1106 (and their devices) are participating are provided over a network between message applications 1104 and 1108, wherein the users enter messages displayed by the participating user devices in their respective chat interfaces.
At 1110, the user 1102 selects to open the embedded application 1114 by providing user input to the message application 1104. At 1114, the first messaging application 1104 launches the selected embedded application 1112. In some embodiments, first embedded application 1112 is downloaded from a server, such as embedded application server 150 (not shown). At 1116, the launched first embedded application 1112 causes the embedded interface to be displayed by the first user device, e.g., in, adjacent to, or otherwise associated with the first chat interface, and viewed by the first user 1102.
In addition to starting the embedded application, at 1118, the first messaging application sends information over the network indicating a start event (or a first user's join event) based on the start of the first embedded application 1112. In this example, the event at 1118 is sent to message router 1120. In various examples, message router 1120 may be session server 152 (e.g., included in message server 101) or other server. In some embodiments the embedded session may be created at the message router in response to the initiation event, or the embedded session may be created by the first user device, etc. Message router 1120 sends 1118 a join event to a second message application 1108 operating on a second user device. At 1122, the second message application 1108 causes the second user device to display, for example in a second chat interface, a notification to be viewed by the second user indicating that the first user 1102 has initiated the embedded session. In this example, the notification includes a displayed join option (e.g., interface element) for the second user to select to join the embedded session.
At 1124, the second user 1106 selects the displayed join option to join the embedded session, where the selection is provided to the second messaging application 1108. In response to the join selection, at 1126, the second message application 1108 causes a second embedded application 1128 to be launched (e.g., downloaded in some embodiments) on the second user device. At 1130, the second embedded application causes a second embedded interface to be displayed on the second user device. In addition to launching the second embedded application, at 1132, in response to the join selection at 1124, the second messaging application 1108 sends information to the embedded session over the network indicating the second user's join event. In this example, join event 1132 is sent to message router 1120.
Message router 1120 sends join event 1132 to first message application 1104 on the first user device over the network. In response, at 1122, the first message application 1104 sends a member update to the first embedded application 1112 for the second user joining the embedded session. For example, the member update may include data indicating that the second user has joined, chat identification of the second user, selected user status of the second user, and the like, as described herein. In response to the member update, the first embedded application 1112 updates the display of the first embedded interface at 1136 as viewed by the first user 1102. For example, a chat identification (or other user identification) of the second user may be displayed in the embedded interface.
In various example embodiments of systems, methods, and non-transitory computer readable media having stored software instructions, an embedded application is provided in association with a messaging application. A first embedded application running at least in part on the first user device may be launched in association with a first chat interface displayed by the first messaging application. The first chat interface is configured to receive a first user input from a first user and to display messages originating from one or more other user devices participating in the chat conversation over the network. One or more other user devices are associated with one or more chat users, the chat users being associated with respective chat identifications. An indication is received over the network indicating that one or more particular ones of the other user devices have connected to an embedded session associated with the first embedded application. In response to the indication, one or more chat identifications are provided from the first messaging application to a first embedded application associated with one or more particular chat users of the particular user device. The particular chat user is designated as one or more member users of the embedded session and the first embedded application is updated based on data received from at least one particular user device of the embedded session.
In a further example, the first embedded application receives a first user input from a first user of an embedded interface displayed as part of the first chat interface, and the first user input includes a selection of an interface element in the embedded interface. The first embedded application is updated in response to the first user input. In some examples, each particular user device of the embedded session runs a respective embedded application that provides a respective embedded interface associated with a respective chat interface displayed on the respective particular user device, and updates the first embedded application based on data received from at least one particular user device of the embedded session. The data may include other user input received by at least one respective embedded interface from at least one of the one or more member users of the embedded session. Output data may be obtained from the first embedded application for display in the first chat interface and, in response to receiving the output data, a prompt is displayed by the first user device, the prompt including a user-selectable control to agree to display the output data in the chat interface. The one or more chat identifications may be anonymized prior to providing the one or more chat identifications to the first embedded application to create an anonymous chat identification such that the anonymous chat identification is provided to the first embedded application.
In a further example, the information is transmitted to other user devices participating in the chat conversation, which causes the other user devices to display interface elements that are receptive to the selective user input at each of the other user devices, and in response to receiving the selective user input at the interface element on the particular user device, the particular user device is designated as a member device of the embedded conversation. One or more characteristics of one or more particular user devices may be determined and provided to the first embedded application, wherein the characteristics include a geographic location of at least one particular user device, a local time of at least one particular user device, and/or an available data bandwidth of at least one particular user device on the network, wherein the characteristics are used by the first embedded application to determine output information to be displayed by the particular user device, and/or to cause a modification of transmission of input data from one or more other devices to the first user device over the network. An indication may be received from a server managing the embedded session, and an update to the first embedded application may be received from the server, wherein the update is based on other user inputs from a particular chat user, other user inputs provided to the server.
In a further example, a notification is output for display in a respective chat interface of one or more other user devices, wherein the notification indicates that the particular user device is a member device of the embedded session. In some embodiments, the notification is output to the chat conversation in response to one or more specific types of events occurring in the embedded session, including events occurring in the first embedded application, and including starting playback of the media item, stopping playback of the media item, changes in playback of the media item based on the first user input and/or other user input, game events occurring in a game of the embedded session, updates to the game based on the first user input and/or other user input, and/or updates to the shared content document based on the first user input and/or other user input. In some embodiments, in response to receiving server event information indicating that one or more events have occurred on the server and providing the server event information to the first embedded application for display on the first user device, a notification is output to the chat conversation.
In a further example, the suggested event in the embedded session is determined based on receiving a second user input received from a first user in the first chat interface, embedded event information from the first embedded application, and/or server event information from a server coupled to the network, obtaining one or more suggested response items based on the suggested event, and causing the first user device to display the one or more suggested response items. For example, a third user input indicating the selected suggestion response item may be received such that a chat message associated with the selected suggestion response item in a first chat interface displayed on the first user device and on other user devices participating in the first user device is output. In another example, the third user input selects the selected suggestion response item and provides one or more commands associated with the selected suggestion response item. In various examples, the commands may include at least one first command provided to the first embedded application, at least one second command provided to the first messaging application, and/or at least one third command provided to the first user device to cause output information of a different application running on the first user device to be displayed. The output information may include information received from a server device in communication with the first user device. In a further example, the command may include a first command to add a first set of one or more other users to the embedded session in response to determining that the second content item is the same as the first content item being output in an embedded interface of the embedded application on the first user device, wherein the second content item is displayed on the first set of one or more user devices not participating in the chat conversation. The commands may include a second command to add a second set of one or more other users to the embedded session in response to determining that the second set of one or more other users has entered user comments associated with a fourth content item that is the same as the third content item being output in the embedded interface on the first user device, wherein the fourth content item is displayed on a second set of one or more user devices that are not engaged in the chat conversation.
In a further example, content data may be received at the message application from a server application running at the server device over a network and provided to the embedded application such that output information is displayed by the embedded application for an embedded session in an embedded interface displayed on the first user device and one or more particular user devices. Event information is received over a network indicating suggested events occurring at the server application, wherein the suggested events are based on input received by the server application through one or more network users other than the one or more chat users. One or more suggested response items responsive to the suggested event are obtained and the suggested response items are displayed in a first chat interface on the first user device. The suggested response item may be selected by user input to cause the message to be displayed in a chat interface and/or to send a command to one of the embedded application and the messaging application.
In a further example, selection input is received from one or more particular chat users prior to designating the one or more particular chat users as one or more member users of the embedded conversation, the selection input selecting one or more associated user roles for the embedded conversation. An associated user role is selected from a plurality of predefined user roles. In response to receiving the selection input, each of the one or more particular chat users can be assigned a respective associated user role selected by the particular chat user in the embedded session. Each particular chat user is capable of activating one or more functions of the embedded application associated with the corresponding associated user role selected by the particular chat user. The first messaging application outputs an indication of the associated user role and the particular chat user to the other user device for display.
In a further example, the first user device joins a chat conversation provided at least in part by a first messaging application running at least in part on the first user device, and the first chat interface is configured to receive first user input from the first user and display messages originating from one or more other chat users of one or more other chat devices participating in the chat conversation over the network. Each chat user is associated with a chat identifier displayed in the first chat interface. A second user input of the first chat interface is received from the first user and, in response to the second user input, a first embedded application is launched in association with the first chat interface. The first embedded application provides output information in an embedded interface displayed by the first user device such that at least a portion of the first chat interface is visible. A chat identification associated with a first user is provided from a first messaging application to a first embedded application, wherein the first user is designated as a member user of an embedded session associated with the first embedded application, and the first embedded application is updated based on a third user input received from the first user to the embedded interface. In some examples, the other chat users include a bot running on at least one of the first user device and a server device connected to the first user device over a network. Based on a fourth user input received from the first user in the first chat interface, the bot causes content data to be displayed in the embedded interface.
In a further example, a first user input of a first embedded interface displayed in association with a first chat interface is received from a first user through a first embedded application running in association with a first messaging application on a first user device. The first user input is received by the first embedded application, the first chat interface is displayed by a first messaging application running at least partially on the first user device, and the first chat interface is configured to receive second user input from the first user and display messages received over the network from one or more other user devices participating in the chat conversation. Each other user device is associated with a respective chat user, each chat user being associated with a chat identifier displayed in the first chat interface. Other user inputs are received from one or more member users of one or more member devices of the one or more other user devices, wherein the member devices are included in an embedded session associated with the first embedded application. Based on the first user input and based on other user inputs, one or more states of the embedded application are updated, wherein updating includes assigning each member user a respective user state. Information indicative of the respective user status of the member users is provided to the first messaging application for display by other user devices participating in the chat conversation.
FIG. 12 is a block diagram of an example device 1200 that may be used to implement one or more features described herein. In one example, device 1200 may be used to implement a client device, such as any of client devices 115 shown in fig. 1. Or device 1200 may implement a server device, such as message server 101 and/or other servers of fig. 1. Device 1200 may be any suitable computer system, server, or other electronic or hardware device as described above.
One or more of the methods described herein may be run in a standalone program, which may be run on any type of computing device, which may be a program running on a web browser, a mobile application ("app") running on a mobile computing device (e.g., a cell phone, a smartphone, a tablet, a wearable device (watch, armband, jewelry, headwear, virtual reality goggles or glasses, augmented reality goggles or glasses, etc.), a notebook, etc. In one example, a client/server architecture may be used, for example, a mobile computing device (as a client device) to send user input data to a server device and to receive final output data from the server for output (e.g., for display). In another example, all of the computations may be performed within a mobile application (and/or other applications) on the mobile computing device. In another example, the computation may be split between the mobile computing device and one or more server devices.
In some embodiments, device 1200 includes a processor 1202, memory 1204, and an input/output (I/O) interface 1206. The processor 1202 may be one or more processors and/or processing circuits that execute program code and control the basic operations of the device 1200. A "processor" includes any suitable hardware and/or system, mechanism, or component that processes data, signals, or other information. The processor may include a system with a general purpose central processing unit (Central Processing Unit, CPU), multiple processing units, special purpose circuits to implement functions, or other systems. The processing need not be limited to a particular geographic location, or have time constraints. For example, a processor may perform its functions "in real time", "offline", in "batch mode", etc. Portions of the processing may be performed by different (or the same) processing systems at different times and at different locations. The computer may be any processor in communication with the memory.
Memory 1204 is typically provided in device 1200 for access by processor 1202 and may be any suitable processor-readable storage medium, such as random access Memory (Random Access Memory, RAM), read-only Memory (ROM), electrically erasable Read-only Memory (ELECTRICAL ERASABLE READ-only Memory, EEPROM), flash Memory, etc., adapted to store instructions for execution by processor and that are provided separately from processor 1202 and/or integrated with processor 1202. The memory 1204 may store software run by the processor 1202 on the server device 1200, including an operating system 1208, messaging applications 1210, and other applications (or engines 1212), such as a data display engine, a network hosting engine (web hosting engine), an image display engine, a notification engine, a social networking engine, and the like. In some embodiments, the message application 1210 may include instructions that enable the processor 1202 to perform some or all of the functions of the methods described herein, e.g., fig. 2-7. For example, message application 1210 may communicate with other applications and devices as described herein. In some embodiments, the message application 1210 may include or be associated with one or more embedded applications 1216, which may provide features as described herein, and may communicate with the message application 1210 to send and receive information from other applications 1212 and devices connected via a network. In some embodiments, message application 1210 may include one or more modules, such as user interaction module 1218 that manages chat interfaces and/or other user interfaces, and/or these modules may be implemented in other applications or devices in communication with device 1200. The user interaction module 1218 and/or one or more other applications 1212 can provide a displayed user interface to display selectable options or controls, for example, in response to user input, as well as data based on the selected options.
Other applications 1212 may include, for example, image editing applications, media display applications, communication applications, web hosting engines or applications, and the like. One or more of the methods disclosed herein may operate in several environments and platforms, for example, as stand-alone computer programs that may run on any type of computing device, as a web application with web pages, as a mobile application ("app") running on a mobile computing device, and so on.
In various embodiments, other applications 1212 may include a machine learning application 1230, which may be used in the various embodiments described herein. For example, the machine learning application 1230 may utilize a Bayesian (Bayesian) classifier, support vector machines, neural networks, or other learning techniques. In some embodiments, the machine learning application 1230 may include a training model, an inference engine, and data. In some embodiments, the data may include training data, e.g., data used to generate a training model. For example, the training data may include any type of data, such as text, images, audio, video, and the like. The training data may be obtained from any source, such as, for example, a data store specially marked for training, data providing permission to use as training data, and the like. In embodiments where one or more users are allowed to train a training model using their respective user data, the training data may include such user data. In embodiments where users allow access to their respective user data, the data may include allowed data such as images (e.g., photographs or other user-generated images), communications (e.g., emails; chat data such as text messages, voice, video, etc.), documents (e.g., spreadsheets, text documents, presentations, etc.).
In some embodiments, the data may include collected data, such as map data, image data (e.g., satellite images, overhead images, etc.), game data, and the like. In some embodiments, the training data may include synthetic data generated for training purposes, such as data that is not based on user input or activity in the context being trained, e.g., data generated from simulated conversations, computer generated images, etc. In some embodiments, the machine learning application 1230 does not include data. For example, in these embodiments, the training model may be generated, for example, on a different device and provided as part of the machine learning application 1230. In various embodiments, the training model may be provided as a data file containing model structures or forms and associated weights. The inference engine may read the data file of the training model and implement a neural network with node connections, layers, and weights based on the model structure or form specified in the training model.
The machine learning application 1230 also includes a training model. In some embodiments, the training model may include one or more model forms or structures. For example, the model form or structure may include any type of neural network, such as a linear network, a deep neural network implementing multiple layers (e.g., a "hidden layer" between an input layer and an output layer, each layer being a linear network), a convolutional neural network (e.g., a network that segments or partitions input data into multiple portions or tiles (tiles), processes each tile separately using one or more neural network layers, and aggregates results from the processing of each tile), a sequence-to-sequence neural network (e.g., a network that takes sequence data as input, such as words in sentences (e.g., in chat messages), frames in video, etc., and produces a sequence of results as output), and so forth. The model form or structure may specify the connections between the various nodes and the organization of the nodes to the layers. For example, a node of a first layer (e.g., an input layer) may receive data as input data or application data. For example, when using a training model for image analysis, such data may include, for example, one or more pixels per node. The subsequent middle tier may receive as input the output of the nodes of the previous tier in accordance with the connectivity specified in the model form or structure. These layers may also be referred to as hidden layers. The last layer (e.g., output layer) produces the output of the machine learning application 1230. For example, depending on the particular training model, the output may be a set of labels for the image, a representation of the image that allows the image to be compared to other images (e.g., feature vectors for the image), an output sentence that is responsive to the input sentence, one or more categories of input data, and so forth. In some embodiments, the model form or structure also specifies the number and/or type of nodes in each layer.
In various embodiments, the training model may include a plurality of nodes arranged in layers according to a model structure or form. In some embodiments, a node may be a compute node without memory, e.g., configured to process an input of a unit to produce an output of a unit. The computation performed by the node may include, for example, multiplying each of a plurality of node inputs by a weight, obtaining a weighted sum, and adjusting the weighted sum with a bias or intercept value (INTERCEPT VALUE) to produce a node output. In some embodiments, the computation performed by the node may further include applying a ladder/activation function to the adjusted weighted sum. In some embodiments, the step/activate function may be a nonlinear function. In various embodiments, such computation may include operations such as matrix multiplication. In some embodiments, for example, the computation of multiple nodes may be performed in parallel using multiple processor cores of a multi-core processor, a separate processing unit using a GPU, or dedicated neural circuitry. In some embodiments, the node may include memory, for example, may be capable of storing and using one or more earlier inputs in processing subsequent inputs. For example, the node with Memory may include a Long Short-term Memory (LSTM) node. LSTM nodes may use memory to maintain a "state" that allows the node to behave as a finite state machine (FINITE STATE MACHINE, FSM). Models with such nodes may be used to process sequence data, such as words in sentences or paragraphs, frames in video, speech or other audio, and so forth.
In some embodiments, the training model may include embeddings or weights for individual nodes. For example, a model may be initialized to a plurality of nodes organized into layers specified by the model form or structure. At initialization, a corresponding weight may be applied to the connections between each pair of nodes connected in a model form, e.g., nodes in successive layers of a neural network. For example, the corresponding weights may be randomly assigned or initialized to default values. The model may then be trained, for example, using the data described above, to produce results.
For example, training may include applying supervised learning techniques. In supervised learning, training data may include a plurality of inputs (e.g., a set of images) and a corresponding expected output for each input (e.g., one or more labels for each image). The value of the weight is automatically adjusted based on a comparison of the model's output to the expected output, e.g., in a manner that increases the probability that the model will produce the expected output when similar inputs are provided.
In some embodiments, training may include applying unsupervised learning techniques. In unsupervised learning, only input data may be provided and a model may be trained to distinguish the data, e.g., to cluster the input data into groups, where each group includes input data that are similar in some way. For example, the model may be trained to distinguish images such that the model distinguishes abstract images (e.g., composite images, artificial images, etc.) from natural images (e.g., photographs).
In another example, a model trained using unsupervised learning may cluster words based on the use of words in an input sentence. In some embodiments, unsupervised learning may be used to generate a knowledge representation, which may be used by the machine learning application 1230, for example. In various embodiments, the training model includes a set of weights or embeddings corresponding to the model structure. In embodiments where data is omitted, the machine learning application 1230 may include a training model based on prior training, for example, by a developer of the machine learning application 1230, by a third party, or the like. In some embodiments, the training model may include a fixed set of weights, e.g., downloaded from a server that provides the weights.
The machine learning application 1230 also includes an inference engine. The inference engine is configured to apply a training model to data (such as application data) to provide inferences. In some embodiments, the inference engine may include software code to be run by the processor 1202. In some embodiments, the inference engine may specify a circuit configuration (e.g., for a programmable processor, for a Field Programmable Gate Array (FPGA), etc.) that enables the processor 1202 to apply the training model. In some embodiments, the inference engine may include software instructions, hardware instructions, or a combination. In some embodiments, the inference engine may provide an application programming interface (Application Programming Interface, API) that may be used by the operating system 1208 and/or other applications 1212 to invoke the inference engine, for example, to apply a training model to application data to generate inferences.
The machine learning application 1230 may provide several technical advantages. For example, when generating a training model based on unsupervised learning, the training model may be applied by an inference engine to generate a knowledge representation (e.g., a digital representation) from input data, such as application data. For example, a training model for image analysis may produce a representation of an image having a smaller data size (e.g., 1 KB) than the input image (e.g., 10 MB). In some embodiments, such representations may help reduce processing costs (e.g., computational costs, memory usage, etc.) of generating output (e.g., tags, classifications, sentences describing images, etc.). In some embodiments, such representations may be provided as inputs to different machine learning applications that produce outputs from the outputs of the inference engine. In some embodiments, the knowledge representation generated by the machine learning application 1230 may be provided to a different device for further processing, e.g., over a network. In such embodiments, providing a knowledge representation rather than an image may provide technical advantages, such as enabling faster data transfer at reduced costs. In another example, a model trained to cluster documents may generate document clusters from input documents. Document clustering may be suitable for further processing (e.g., determining whether a document is related to a topic, determining a classification category of a document, etc.) without accessing the original document, thus saving computational costs.
In some embodiments, the machine learning application 1230 may be implemented in an offline manner. In these embodiments, a training model may be generated in a first stage and provided as part of the machine learning application 1230. In some embodiments, the machine learning application 1230 may be implemented in an online manner. For example, in such embodiments, an application (e.g., operating system 1208, one or more other applications 1212) invoking the machine learning application 1230 may utilize the reasoning generated by the machine learning application 1230, e.g., to provide reasoning to the user, and may generate a system log (e.g., which is an action taken by the user based on the reasoning if allowed by the user, or which is the result of further processing if used as input to further processing). The system log may be generated periodically, e.g., hourly, monthly, quarterly, etc., and may be used to update the training model, e.g., update the embedding of the training model, if permitted by the user.
In some embodiments, the machine learning application 1230 may be implemented in a manner that can accommodate the particular configuration of the device 1200 on which the machine learning application 1230 is running. For example, the machine learning application 1230 may determine a computational graph that utilizes available computational resources, such as the processor 1202. For example, if the machine learning application 1230 is implemented as a distributed application across multiple devices, the machine learning application 1230 may determine the computations to be performed on the individual devices in a manner that optimizes the computations. In another example, the machine learning application 1230 may determine that the processor 1202 includes a GPU having a particular number (e.g., 1000) of GPU cores and implement the inference engine accordingly (e.g., as 1000 separate processes or threads).
In some embodiments, the machine learning application 1230 may implement the ensemble of training models. For example, the training model may include a plurality of training models, each adapted to the same input data. In these embodiments, the machine learning application 1230 may select a particular training model based on, for example, available computing resources, success rates of previous inferences, and the like. In some embodiments, the machine learning application 1230 may run an inference engine such that multiple training models are applied. In these embodiments, the machine learning application 1230 may combine the outputs from the various models of the application, for example, using voting techniques that score the various outputs of each training model of the application, or by selecting one or more particular outputs. Further, in these embodiments, the machine learning application may apply a time threshold (e.g., 0.5 ms) to each training model of the application and utilize only those individual outputs that are available within the time threshold. The output that was not received within the time threshold may not be utilized (e.g., discarded). Such an approach may be appropriate, for example, when the machine learning application 1230 is invoked, for example, by the operating system 1208 or one or more applications 1212, the time limit is specified.
In different embodiments, the machine learning application 1230 may generate different types of output. For example, the machine learning application 1230 may provide representations or clusters (e.g., digital representations of input data), tags (e.g., for input data including images, documents, etc.), phrases or sentences (e.g., describing images or videos, suitable for use as responses to input sentences, etc.), images (e.g., generated by the machine learning application 1230 in response to input), audio or video (e.g., in response to input video, the machine learning application 1230 may generate output video with particular application effects, e.g., when training a training model using training data from a comic book or particular artist, etc., the output video is presented in the style of the comic book or particular artist). In some embodiments, the machine learning application 1230 may generate output based on a format specified by a calling application, such as the operating system 1208 or one or more applications 1212. In some embodiments, the calling application may be another machine learning application. For example, such a configuration may be used for a generated countermeasure network in which output from the machine learning application 1230 is used to train invoking the machine learning application and vice versa.
Any software in the memory 1204 may alternatively be stored on any other suitable storage location or computer readable medium. In addition, the memory 1204 (and/or other connected storage devices) may store one or more messages, one or more classification criteria, electronic encyclopedias, dictionaries, message data, grammars, user preferences, and/or other instructions and data used in the features described herein. Memory 1204 and any other type of storage (magnetic disk, optical disk, magnetic tape, or other tangible medium) may be considered a "storage" or "storage device.
The I/O interface 1206 may provide functionality to interface the server device 1200 with other systems and devices. The interface device may be included as part of the device 1200 or may be separate from and in communication with the device 1200. For example, network communication devices, storage devices (e.g., memory and/or database 106), and input/output devices may communicate over I/O interface 1206. In some embodiments, the I/O interface may be connected to interface devices such as input devices (keyboard, pointing device, touch screen, microphone, camera, scanner, sensor, etc.) and/or output devices (display device, speaker device, printer, motor, etc.).
Some examples of engaged devices that may be connected to the I/O interface 1206 may include one or more display devices 1220 that may be used to display content (e.g., images, video), and/or a user interface to output applications as described herein. The display device 1220 may be connected to the device 1200 via a local connection (e.g., a display bus) and/or via a network connection, and may be any suitable display device. Display device 1220 may include any suitable display device, such as an LCD, LED or plasma display screen, CRT, television, monitor, touch screen, 3D display screen, or other visual display device. For example, the display device 1220 may be a flat display screen provided on a mobile device, a plurality of display screens provided in a goggle device, or a monitor screen for a computer device.
The I/O interface 1206 may be coupled to other input and output devices. Some examples include one or more cameras that may capture images. Some embodiments may provide a microphone for capturing sound (e.g., as part of capturing an image, voice commands, etc.), an audio speaker device for outputting sound, or other input and output devices.
For ease of illustration, FIG. 12 shows one block for each of the processor 1202, the memory 1204, the I/O interface 1206, and shows software blocks 1208, 1210, and 1212. These blocks may represent one or more processors or processing circuits, operating systems, memory, I/O interfaces, applications, and/or software modules. In other embodiments, device 1200 may not have all of the components shown and/or may have other elements including other types of elements in place of or in addition to those shown herein. Although some components are described as performing the blocks and operations as described in some embodiments herein, any suitable component or combination of components of environment 100, device 1200, a similar system, or any suitable processor associated with such a system may perform the described blocks and operations.
The methods described herein may be implemented by computer program instructions or code that may run on a computer. For example, the code may be implemented by one or more digital processors (e.g., microprocessors or other processing circuits) and may be stored on a computer program product comprising a non-transitory computer readable medium (e.g., a storage medium), such as magnetic, optical, electromagnetic, or semiconductor storage media including semiconductor or solid state memory, tape, removable computer diskette, random Access Memory (RAM), read-only memory (ROM), flash memory, rigid magnetic disk, optical disk, solid state memory drive, and the like. The program instructions may also be embodied in or provided as electronic signals, for example, in the form of Software as a service (SaaS) transmitted from a server (e.g., a distributed system and/or cloud computing system). Alternatively, one or more of the methods may be implemented in hardware (logic gates, etc.) or a combination of hardware and software. Example hardware may be a programmable processor (e.g., a Field Programmable Gate Array (FPGA), a complex programmable logic device), a general purpose processor, a graphics processor, an Application Specific Integrated Circuit (ASIC), etc. One or more methods may be performed as part or component of an application running on a system or as an application or software running with other applications and operating systems.
Although described with respect to particular embodiments, these particular embodiments are merely illustrative and not limiting. The concepts illustrated in the examples may be applied to other examples and embodiments.
Some embodiments discussed herein may provide a user with one or more opportunities to control whether personal information is collected, whether personal information is stored, whether personal information is used, and how information about the user is collected, stored, and used in the context of collecting or using personal information about the user (e.g., user data, information about the user's social network, the user's location and time, the user's biometric information, the user's activities, and demographic information). That is, the systems and methods discussed herein collect, store, and/or use user personal information, particularly upon receipt of explicit authorization from an associated user. In addition, certain data may be processed in one or more ways prior to storage or use to remove personally identifiable information. In some embodiments, the identity of the user may be processed so that personally identifiable information cannot be determined. As another example, the geographic location of a user may be generalized to a larger region such that the user's particular location cannot be determined.
Note that the functional blocks, operations, features, methods, devices, and systems described in this disclosure may be integrated or separated into different combinations of systems, devices, and functional blocks as known to those of skill in the art. The routines of the particular embodiments may be implemented using any suitable programming language and programming techniques. Different programming techniques may be employed, such as, for example, a program or object-oriented. The routines may run on a single processing device or multiple processors. Although steps, operations, or computations may be presented in a specific order, the order may be changed in different specific embodiments. In some embodiments, a plurality of steps or operations shown in sequence in the present specification may be performed simultaneously.
Some examples are described below.
Example 1: a computer-implemented method of providing suggested items, the computer-implemented method comprising: causing a chat interface to be displayed by the first user device, wherein the chat interface is generated by the message application, and wherein the chat interface is configured to display one or more messages in the chat conversation, wherein the one or more messages are provided by a plurality of user devices that are participating in the chat conversation over the network; causing an embedded interface to be displayed in association with the chat interface, wherein the embedded interface is provided by a first embedded application that is at least partially running on the first user device in association with the messaging application; determining that a suggested event has occurred in association with the first embedded application based on received data indicating that a particular event has occurred in one or more of a plurality of user devices participating in the chat conversation, wherein the one or more of the plurality of user devices are different from the first user device; obtaining one or more suggestion response items based on the suggestion event; and causing one or more suggested response items to be displayed by the first user device.
Example 2: the computer-implemented method of example 1, wherein the particular event comprises at least one of: user input received by an associated chat interface of one or more of the plurality of user devices; user input received by an associated embedded interface of one or more of the plurality of user devices; and/or embedded application events occurring in associated embedded applications running on one or more of the plurality of user devices.
Example 3: the computer-implemented method of example 1 or 2, wherein the received data indicating that a particular event has occurred indicates at least one of: the type of content feature displayed in the media item played by one or more of the plurality of user devices; implementing a predefined goal in a game of one or more of the plurality of user devices; user input received by a receiving user device engaged in a chat conversation, wherein the user input is received in a different embedded interface displayed on the receiving user device; and/or launching an embedded application from a particular user device of the plurality of user devices.
Example 4: the computer-implemented method of at least one of the foregoing examples, wherein the particular event comprises one or more messages entered into the chat conversation by respective users of one or more of the plurality of user devices, wherein the suggested event is determined based on detection of at least one of one or more predefined topics, words, and/or phrases in the one or more messages.
Example 5: the computer-implemented method of at least one of the foregoing examples, wherein the suggested event comprises at least one of: receiving user input at a device, a state change in a program, communication of data between devices, connection of a user device to an embedded session or device over a network, receiving or transmitting data between programs or over a network on one user device, detecting content characteristics or other data in media data, detecting a particular topic in a chat message, and/or one or more of these events occurring at a previous time as indicated in historical data.
Example 6: the computer-implemented method of at least one of the foregoing examples, wherein obtaining one or more suggested response items based on the suggested event comprises determining at least one of the one or more suggested response items based on at least one of: one or more predefined associations of at least one suggested response item with suggested events; a model trained with the specific suggested event and a response input responsive to the specific suggested event; and/or one or more of a plurality of rules and targets for use in games provided by the embedded application.
Example 7: the computer-implemented method of at least one of the foregoing examples further comprising: receiving user input indicating a user selection of a suggestion response item from the selection of one or more suggestion response items; and outputting a selected message in the chat conversation, the selected message being associated with the selected suggested response item.
Example 8: the computer-implemented method of at least one of the foregoing examples, wherein the one or more suggestion response items include one or more text messages indicating a user's reaction to a suggestion event.
Example 9: the computer-implemented method of at least one of the foregoing examples further comprising: receiving user input indicating selection of a suggestion response item from the selection of one or more suggestion response items; and providing a command to the first embedded application in response to the user input, wherein the command is associated with the selected suggestion response item, wherein the command causes a state change of the first embedded application, wherein the change of state is indicated to one or more other user devices of the plurality of user devices participating in the chat conversation.
Example 10: the computer-implemented method of example 9, wherein the command to the first embedded application comprises at least one of: a first command for performing an action in a game implemented by the first embedded application; a second command for changing a playback position in playback of the media data by the first embedded application; and/or a third command to change the shared object provided by the first embedded application.
Example 11: the computer-implemented method of at least one of the foregoing examples further comprising: receiving user input indicating selection of a suggestion response item from the selection of one or more suggestion response items; and providing, in response to user input, one or more commands associated with the selected suggested response item, wherein the one or more commands include at least one of: at least one first command provided to the first embedded application; at least one second command provided to the messaging application; and/or at least one third command provided to the first user device to cause display of output information from a different application running on the first user device, wherein the output information includes information received from a server device in communication with the first user device.
Example 12: the computer-implemented method of at least one of the foregoing examples further comprising: receiving user input indicating selection of a suggestion response item from the selection of one or more suggestion response items; and providing, in response to user input, one or more commands associated with the selected suggested response item, wherein the one or more commands include at least one of: a first command to add a first set of one or more other users to the chat conversation in response to determining that the second content item is the same as the first content item output in the embedded interface of the embedded application on the first user device, wherein the second content item is displayed on the first set of one or more user devices not participating in the chat conversation; and/or a second command to add a second set of one or more other users to the chat conversation in response to determining that the second set of one or more other users has entered user comments associated with a fourth content item that is the same as the third content item output in the embedded interface on the first user device, wherein the fourth content item is displayed on a second set of one or more user devices that are not engaged in the chat conversation.
Example 13: the computer-implemented method of at least one of the foregoing examples, wherein the one or more suggestion response items include one or more suggestion commands for the first embedded application and one or more suggestion messages for a chat conversation to be output into the chat interface, wherein the one or more suggestion commands are visually distinguished from the one or more suggestion messages when the one or more suggestion commands are displayed in the chat interface.
Example 14: the computer-implemented method of at least one of the foregoing examples, wherein the one or more suggested response items are determined by at least one of: a first embedded application; a message application; a remote server in communication with the messaging application over a network.
Example 15: the computer-implemented method of at least one of the foregoing examples, wherein the first embedded application is a media player application that causes playback of video data to be displayed in an embedded interface, wherein the embedded interface is configured to receive input from a user that controls playback of the displayed video data, and wherein at least one of the one or more suggestion response items comprises one or more suggestion playback commands operable to adjust playback of the displayed video data.
Example 16: the computer-implemented method of at least one of the foregoing examples, wherein the first embedded application is a gaming application that causes game data to be displayed in an embedded interface, wherein the embedded interface is configured to receive input from a user that changes one or more states of the gaming application, and wherein at least one of the one or more advice response items comprises one or more advice commands operable to modify the at least one state of the gaming application.
Example 17: the computer-implemented method of at least one of the foregoing examples, wherein the first embedded application is a shared document application that causes a shared document to be displayed in an embedded interface, wherein the embedded interface is configured to receive input from a user that changes one or more items of the shared document, and wherein at least one of the one or more suggestion response items comprises one or more suggestion commands operable to modify the shared document.
Example 18: the computer-implemented method of at least one of the foregoing examples, wherein the embedded interface is output on a subset of the plurality of user devices participating in the chat conversation, wherein the subset includes user devices that have received a second user input in the associated chat interface, the second user input causing the user devices to join the embedded session initiated by the first embedded application.
Example 19: the computer-implemented method of at least one of the foregoing examples, wherein the first embedded application displays output data, the output data being at least one of: generated by the first embedded application and/or received from a server connected to the first user device over a network.
Example 20: a system, comprising: a memory; and at least one processor configured to access the memory and configured to perform operations comprising: causing a chat interface to be displayed by the first user device, wherein the chat interface is generated by the message application, and wherein the chat interface is configured to display one or more messages in the chat conversation, wherein the one or more messages are provided by a plurality of user device networks participating in the chat conversation over the network; causing an embedded interface to be displayed in association with the chat interface, wherein the embedded interface is provided by a first embedded application running in association with the messaging application, wherein the first embedded application is at least partially running on the first user device; determining that the suggested event has occurred in association with use of the first embedded application based on at least one of: user input received by the embedded interface, and/or event information from the first embedded application indicating that a suggested event has occurred in the first embedded application; obtaining one or more suggested response items responsive to the suggested event; and causing one or more suggested response items to be displayed by the first user device.
Example 21: the system of example 20, wherein the one or more suggested response items are each selectable by a first user of the first user device to cause the message application to at least one of: providing associated commands to change one or more states of the first embedded application; and/or cause associated messages to be displayed in the chat conversation by the plurality of user devices participating in the chat conversation.
Example 22: the system of example 20 or 21, wherein determining that the suggested event has occurred is based on determining that a second user device of the plurality of user devices has launched a second embedded application corresponding to the first embedded application to join an embedded session provided for the first embedded application.
Example 23: a non-transitory computer readable medium having stored thereon software instructions that, when executed by a processor, cause the processor to perform operations comprising: determining that the suggested event has occurred in association with use of at least one of a plurality of corresponding embedded applications running at least in part on the associated user device, wherein each embedded application is running in association with a messaging application running on the associated user device, wherein each messaging application is configured to cause an associated chat interface to be displayed by the associated user device, wherein the associated chat interface is configured to display one or more messages in a chat conversation, wherein the associated user device is participating in the chat conversation over a network; obtaining one or more suggested response items responsive to the suggested event; and causing display of one or more suggested response items by at least one of the associated user devices.
Example 24: the non-transitory computer-readable medium of example 23, wherein the one or more suggested response items are each selectable by user input from a corresponding user of the at least one associated user device to achieve at least one of: providing an associated command to change one or more states of a plurality of respective embedded applications; and/or cause the associated message to be displayed in the chat conversation by the associated user device participating in the chat conversation.
Example 25: the non-transitory computer-readable medium of example 23 or 24, wherein the one or more states are one or more second states, and wherein determining that the suggested event has occurred is based on at least one of: user input received by at least one of the respective embedded applications and/or user input received by at least one of the messaging applications that changes one or more first states of the respective embedded applications.
Claims (18)
1. A computer-implemented method of providing suggested items, the computer-implemented method comprising:
causing a chat interface to be displayed by a first user device, wherein the chat interface is generated by a messaging application, and wherein the chat interface is configured to display one or more messages in a chat conversation, wherein the one or more messages are provided by a plurality of user devices that are participating in the chat conversation over a network;
Causing an embedded interface to be displayed in association with the chat interface, wherein the embedded interface is provided by a first embedded application that runs at least partially on the first user device in association with the messaging application;
determining that a suggested event has occurred in association with the first embedded application based on received data indicating that a particular event has occurred at one or more of the plurality of user devices participating in the chat conversation, wherein the one or more user devices are different from the first user device;
Based on the suggested event, obtaining one or more suggested response items;
causing the one or more suggested response items to be displayed by the first user device;
receiving user input indicating selection of a suggestion response item from the selection of the one or more suggestion response items; and
Providing a command to the first embedded application in response to the user input, wherein the command is associated with the selected suggestion response item, wherein the command causes a state change of the first embedded application, wherein the state change is indicated to one or more other user devices of the plurality of user devices participating in the chat conversation,
Wherein the command to the first embedded application includes at least one of:
a first command to perform an action in a game implemented by the first embedded application;
A second command to change a playback position in playback of media data by the first embedded application; or alternatively
A third command that changes a shared object provided by the first embedded application.
2. The computer-implemented method of claim 1, wherein the particular event comprises at least one of:
User input received by an associated chat interface of the one or more user devices;
user input received by an associated embedded interface of the one or more user devices; or alternatively
An embedded application event occurring in an associated embedded application running on the one or more user devices.
3. The computer-implemented method of claim 1, wherein the received data indicating that the particular event has occurred indicates at least one of:
The type of content features displayed in the media items played by the one or more user devices;
Implementing a predefined goal in a game of the one or more user devices;
User input received by a receiving user device engaged in the chat conversation, wherein the user input is received in a different embedded interface displayed on the one or more user devices; or alternatively
The embedded application is launched from a particular user device of the plurality of user devices.
4. The computer-implemented method of claim 1, wherein the particular event comprises one or more messages entered into the chat conversation by respective users of the one or more user devices, wherein the suggested event is determined based on detection of at least one of one or more predefined topics, words, or phrases in the one or more messages.
5. The computer-implemented method of claim 1, wherein obtaining one or more suggested response items based on the suggested event comprises determining at least one of the one or more suggested response items based on at least one of:
one or more predefined associations of the at least one suggested response item with the suggested event;
a model trained with a particular suggested event and a response input responsive to the particular suggested event; or alternatively
One or more of a plurality of rules or targets for use in a game provided by the embedded application.
6. The computer-implemented method of claim 1, further comprising:
a selected message is output in the chat conversation, the selected message being associated with the selected suggestion response item.
7. The computer-implemented method of claim 1, wherein the one or more suggestion response items include one or more text messages indicating a user's reaction to the suggestion event.
8. The computer-implemented method of claim 1, wherein the one or more suggestion response items include one or more suggestion commands for the first embedded application and one or more suggestion messages of the chat conversation to be output into the chat interface, wherein the one or more suggestion commands are visually distinguished from the one or more suggestion messages when the one or more suggestion commands are displayed in the chat interface.
9. The computer-implemented method of claim 1, wherein the one or more suggested response items are determined by at least one of:
the first embedded application;
The message application;
A remote server in communication with the messaging application over the network.
10. The computer-implemented method of claim 1, wherein the first embedded application is a media player application that causes playback of video data to be displayed in the embedded interface, wherein the embedded interface is configured to receive input from a user that controls the playback of the displayed video data, and wherein at least one of the one or more suggestion response items comprises one or more suggestion playback commands operable to adjust the playback of the displayed video data.
11. The computer-implemented method of claim 1, wherein the first embedded application is a gaming application that causes game data to be displayed in the embedded interface, wherein the embedded interface is configured to receive input from a user that changes one or more states of the gaming application, and wherein at least one of the one or more suggestion response items comprises one or more suggestion commands operable to modify at least one state of the gaming application.
12. The computer-implemented method of claim 1, wherein the first embedded application is a shared document application that causes a shared document to be displayed in the embedded interface, wherein the embedded interface is configured to receive input from a user that changes one or more items of the shared document, and wherein at least one of the one or more suggestion response items comprises one or more suggestion commands operable to modify the shared document.
13. The computer-implemented method of claim 1, wherein the embedded interface is output on a subset of the plurality of user devices participating in the chat conversation, wherein the subset includes user devices that have received a second user input in the associated chat interface that causes the user devices to join an embedded session initiated by the first embedded application.
14. The computer-implemented method of claim 1, wherein the first embedded application displays output data, the output data being at least one of: generated by the first embedded application or received from a server connected to the first user device via the network.
15. A system for providing suggested items, the system comprising:
A memory; and
At least one processor configured to access the memory and configured to perform operations comprising:
causing a chat interface to be displayed by a first user device, wherein the chat interface is generated by a messaging application, and wherein the chat interface is configured to display one or more messages in a chat conversation, wherein the one or more messages are provided by a plurality of user devices participating in the chat conversation over a network;
causing an embedded interface to be displayed in association with the chat interface, wherein the embedded interface is provided by a first embedded application running in association with the messaging application, wherein the first embedded application is at least partially running on the first user device;
Determining that a suggested event has occurred in association with use of the first embedded application based on at least one of: user input received by the embedded interface, or event information from the first embedded application indicating that the suggested event has occurred in the first embedded application;
Obtaining one or more suggested response items responsive to the suggested event; and
Causing the one or more suggested response items to be displayed by the first user device, wherein the one or more suggested response items are each selectable by a first user of the first user device to cause the messaging application to perform at least one of: providing associated commands to change one or more states of the first embedded application; or alternatively
Causing associated messages to be displayed in the chat conversation by the plurality of user devices participating in the chat conversation.
16. The system of claim 15, wherein the operation of determining that the suggested event has occurred is based on a determination that a second user device of the plurality of user devices has launched a second embedded application corresponding to the first embedded application to join an embedded session provided for the first embedded application.
17. A non-transitory computer readable medium having stored thereon software instructions that, when executed by a processor, cause the processor to perform operations comprising:
Determining that a suggestion event has occurred in association with use of at least one of a plurality of corresponding embedded applications running at least in part on an associated user device, wherein each embedded application is running in association with a messaging application running on the associated user device, wherein each messaging application is configured to cause an associated chat interface to be displayed by the associated user device, wherein the associated chat interface is configured to display one or more messages in a chat conversation, wherein the associated user device is participating in the chat conversation over a network;
Obtaining one or more suggested response items responsive to the suggested event; and
Causing the one or more suggested response items to be displayed by at least one of the associated user devices, wherein the one or more suggested response items are each selectable by user input from a respective user of the at least one associated user device to perform at least one of:
providing associated commands to change one or more states of the plurality of corresponding embedded applications; or alternatively
In response to the user input, causing an associated message to be displayed in the chat conversation by the associated user device participating in the chat conversation.
18. The non-transitory computer-readable medium of claim 17, wherein the one or more states are one or more second states, and wherein determining that a suggested event has occurred is based on at least one of:
User input received by at least one of the corresponding embedded applications or user input received by at least one of the messaging applications that changes one or more first states of the corresponding embedded application.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US15/624,638 | 2017-06-15 | ||
US15/624,638 US10348658B2 (en) | 2017-06-15 | 2017-06-15 | Suggested items for use with embedded applications in chat conversations |
PCT/US2018/022501 WO2018231306A1 (en) | 2017-06-15 | 2018-03-14 | Suggested items for use with embedded applications in chat conversations |
Publications (2)
Publication Number | Publication Date |
---|---|
CN110709869A CN110709869A (en) | 2020-01-17 |
CN110709869B true CN110709869B (en) | 2024-05-10 |
Family
ID=
Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2011002989A1 (en) * | 2009-07-02 | 2011-01-06 | Livechime, Inc. | System and method for enhancing digital content |
CN103493035A (en) * | 2011-03-15 | 2014-01-01 |  | Inline user addressing in chat and document editing sessions |
US8996639B1 (en) * | 2013-10-15 | 2015-03-31 | Google Inc. | Predictive responses to incoming communications |
CN106412712A (en) * | 2016-09-26 | 2017-02-15 |  | Video playing method and apparatus |
CN106708538A (en) * | 2017-01-23 | 2017-05-24 |  | Interface display method and device |
Patent Citations (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2011002989A1 (en) * | 2009-07-02 | 2011-01-06 | Livechime, Inc. | System and method for enhancing digital content |
CN103493035A (en) * | 2011-03-15 | 2014-01-01 |  | Inline user addressing in chat and document editing sessions |
US8996639B1 (en) * | 2013-10-15 | 2015-03-31 | Google Inc. | Predictive responses to incoming communications |
CN106412712A (en) * | 2016-09-26 | 2017-02-15 |  | Video playing method and apparatus |
CN106708538A (en) * | 2017-01-23 | 2017-05-24 |  | Interface display method and device |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
CN110945840B (en) | Method and system for providing embedded application associated with messaging application | |
US11050694B2 (en) | Suggested items for use with embedded applications in chat conversations | |
US11805091B1 (en) | Social topical context adaptive network hosted system | |
US11303590B2 (en) | Suggested responses based on message stickers | |
KR102050334B1 (en) | Automatic suggestion responses to images received in messages, using the language model | |
US20200265070A1 (en) | Social network driven indexing system for instantly clustering people with concurrent focus on same topic into on topic chat rooms and/or for generating on-topic search results tailored to user preferences regarding topic | |
JP6605151B2 (en) | Bot interaction | |
US20190394153A1 (en) | Automatic response suggestions based on images received in messaging applications | |
US11406896B1 (en) | Augmented reality storytelling: audience-side | |
US20220345537A1 (en) | Systems and Methods for Providing User Experiences on AR/VR Systems | |
CN110709869B (en) | Suggested items for use with embedded applications in chat conversations | |
Deuze | Life in Media: A Global Introduction to Media Studies | |
Van Loon | The agile content marketing roadmap: Integrating strategy and execution | |
US20240137733A1 (en) | Complex computing network for improving establishment and access of audio communication among mobile computing devices | |
Chadha | The Next FrontierExpanding the Definition of Accessibility | |
Magid et al. | Myspace: Safe Online Networking for Your Kids | |
Davis | Exploring the media effects of three-dimensional online immersive worlds and how they impact both virtual and real social capital |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
GR01 | Patent grant |