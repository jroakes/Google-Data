US20240112084A1 - Scalable Feature Selection Via Sparse Learnable Masks - Google Patents
Scalable Feature Selection Via Sparse Learnable Masks Download PDFInfo
- Publication number
- US20240112084A1 US20240112084A1 US18/372,900 US202318372900A US2024112084A1 US 20240112084 A1 US20240112084 A1 US 20240112084A1 US 202318372900 A US202318372900 A US 202318372900A US 2024112084 A1 US2024112084 A1 US 2024112084A1
- Authority
- US
- United States
- Prior art keywords
- features
- learnable
- sparse
- training
- mask vector
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000012549 training Methods 0.000 claims abstract description 79
- 239000013598 vector Substances 0.000 claims description 70
- 238000010801 machine learning Methods 0.000 claims description 56
- 238000000034 method Methods 0.000 claims description 37
- 238000010606 normalization Methods 0.000 claims description 19
- 238000009826 distribution Methods 0.000 claims description 17
- 230000003247 decreasing effect Effects 0.000 claims description 9
- 238000005496 tempering Methods 0.000 abstract description 13
- 238000013459 approach Methods 0.000 abstract description 12
- 230000007246 mechanism Effects 0.000 abstract description 3
- 230000009977 dual effect Effects 0.000 abstract description 2
- 238000004590 computer program Methods 0.000 description 20
- 238000012545 processing Methods 0.000 description 20
- 230000015654 memory Effects 0.000 description 15
- 230000008569 process Effects 0.000 description 12
- 238000004891 communication Methods 0.000 description 10
- 238000010586 diagram Methods 0.000 description 10
- 238000005457 optimization Methods 0.000 description 10
- 230000006870 function Effects 0.000 description 7
- 238000001514 detection method Methods 0.000 description 5
- 230000003287 optical effect Effects 0.000 description 5
- 241000699670 Mus sp. Species 0.000 description 4
- 238000003745 diagnosis Methods 0.000 description 4
- 238000012360 testing method Methods 0.000 description 4
- 230000008901 benefit Effects 0.000 description 3
- 230000001419 dependent effect Effects 0.000 description 3
- 230000000694 effects Effects 0.000 description 3
- 238000013515 script Methods 0.000 description 3
- 230000001143 conditioned effect Effects 0.000 description 2
- 238000013135 deep learning Methods 0.000 description 2
- 238000013507 mapping Methods 0.000 description 2
- 238000007781 pre-processing Methods 0.000 description 2
- 230000000644 propagated effect Effects 0.000 description 2
- 102000004169 proteins and genes Human genes 0.000 description 2
- 108090000623 proteins and genes Proteins 0.000 description 2
- 230000009467 reduction Effects 0.000 description 2
- 238000010200 validation analysis Methods 0.000 description 2
- 241000699666 Mus <mouse, genus> Species 0.000 description 1
- 238000003491 array Methods 0.000 description 1
- 238000013528 artificial neural network Methods 0.000 description 1
- 230000005540 biological transmission Effects 0.000 description 1
- 238000004422 calculation algorithm Methods 0.000 description 1
- 238000004364 calculation method Methods 0.000 description 1
- 230000015556 catabolic process Effects 0.000 description 1
- 230000002860 competitive effect Effects 0.000 description 1
- 230000002596 correlated effect Effects 0.000 description 1
- 238000006731 degradation reaction Methods 0.000 description 1
- 238000005516 engineering process Methods 0.000 description 1
- 238000000605 extraction Methods 0.000 description 1
- 238000007667 floating Methods 0.000 description 1
- 230000001939 inductive effect Effects 0.000 description 1
- 230000000977 initiatory effect Effects 0.000 description 1
- 230000003993 interaction Effects 0.000 description 1
- 238000005259 measurement Methods 0.000 description 1
- 238000013139 quantization Methods 0.000 description 1
- 230000002787 reinforcement Effects 0.000 description 1
- 230000003252 repetitive effect Effects 0.000 description 1
- 230000004044 response Effects 0.000 description 1
- 229920006395 saturated elastomer Polymers 0.000 description 1
- 239000004065 semiconductor Substances 0.000 description 1
- 238000000926 separation method Methods 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
- 230000003595 spectral effect Effects 0.000 description 1
- 239000000758 substrate Substances 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N20/00—Machine learning
Definitions
- Feature selection is utilized to filter out irrelevant features from the input features.
- Feature selection can bring multitude of benefits in machine learning.
- a smaller number of features can yield superior generalization, and hence better test accuracy, by minimizing information extraction from spurious patterns that do not hold consistently and by more optimally utilizing the model capacity on the most relevant features.
- reducing the number of input features can decrease the computational complexity and cost for deployed models, allowing for a decrease in infrastructure requirements to support the features, as the deployed models can learn mappings from input data with smaller dimensions. Further, reducing the number of input features can improve interpretability and controllability, as users can focus on understanding outputs of deployed models from a smaller subset of input features.
- feature selection can consider the predictive model itself, as an optimal set of features would depend on how mapping occurs between inputs and outputs. This may be referred to as embedded feature selection and can include regularization techniques and extensions.
- embedded feature selection can include regularization techniques and extensions.
- selection operations are non-differentiable, given a target count for selected features, which can require soft approximations for feature selection and result in lower quality outputs.
- SLM sparse learnable masks
- MI mutual information
- An aspect of the disclosure provides for a method for training a machine learning model with scalable feature selection, including: receiving, by one or more processors, a plurality of features for training the machine learning model; initializing, by the one or more processors, a learnable mask vector representing the plurality of features; receiving, by the one or more processors, a number of features to be selected; generating, by the one or more processors, a sparse mask vector from the learnable mask vector; selecting, by the one or more processors, a selected set of features of the plurality of features based on the sparse mask vector and the number of features to be selected; computing, by the one or more processors, a mutual information based error based on the selected set of features being input into the machine learning model; and updating, by the one or more processors, the learnable mask vector based on the mutual information based error.
- the method further includes receiving, by the one or more processors, a total number of training steps.
- the receiving, generating, selecting, computing, and updating is iterative for the total number of training steps.
- the learnable mask vector updated after the total number of training steps includes a final selected set of features to be utilized by the machine learning model.
- training the machine learning model further includes gradient-descent based learning.
- the method further includes removing non-selected features of the plurality of features.
- the method further includes applying a sparsemax normalization to the learnable mask vector.
- the method further includes decreasing the number of features over a total number of training steps until reaching a target number of features to be selected.
- gradually decreasing the number of features to be selected is based on a discrete number of evenly spaced steps.
- selecting the selected set of features further includes multiplying the sparse vector by a positive scalar based on a predetermined number of features.
- computing the mutual information based error is based on maximizing mutual information between a distribution of the selected set of features and a distribution of labels for the selected set of features.
- updating the learnable mask vector is based on minimizing the mutual information based error.
- Another aspect of the disclosure provides for a system including: one or more processors; and one or more storage devices coupled to the one or more processors and storing instructions that, when executed by the one or more processors, cause the one or more processors to perform operations for training a machine learning model with scalable feature selection, the operations including: receiving a plurality of features for training the machine learning model; initializing a learnable mask vector representing the plurality of features; receiving a number of features to be selected; generating a sparse mask vector from the learnable mask vector; selecting a selected set of features of the plurality of features based on the sparse mask vector and the number of features to be selected; computing a mutual information based error based on the selected set of features being input into the machine learning model; and updating the learnable mask vector based on the mutual information based error.
- the operations further include receiving a total number of training steps; the receiving, generating, selecting, computing, and updating is iterative for the total number of training steps; and the learnable mask vector updated after the total number of training steps includes a final selected set of features to be utilized by the machine learning model.
- the operations further include removing non-selected features of the plurality of features. In yet another example, the operations further include applying a sparsemax normalization to the learnable mask vector. In yet another example, the operations further include gradually decreasing the number of features over a total number of training steps until reaching a target number of features to be selected.
- selecting the selected set of features further includes multiplying the sparse vector by a positive scalar based on a predetermined number of features.
- computing the mutual information based error is based on maximizing mutual information between a distribution of the selected set of features and a distribution of labels for the selected set of features.
- Yet another aspect of the disclosure provides for a non-transitory computer readable medium for storing instructions that, when executed by one or more processors, cause the one or more processors to perform operations for training a machine learning model with scalable feature selection, the operations including: receiving a plurality of features for training the machine learning model; initializing a learnable mask vector representing the plurality of features; receiving a number of features to be selected; generating a sparse mask vector from the learnable mask vector; selecting a selected set of features of the plurality of features based on the sparse mask vector and the number of features to be selected; computing a mutual information based error based on the selected set of features being input into the machine learning model; and updating the learnable mask vector based on the mutual information based error.
- FIG. 1 depicts a block diagram of an example sparse learnable masks system for scalable feature selection according to aspects of the disclosure.
- FIG. 2 depicts a block diagram of an example environment for implementing a sparse learnable masks system according to aspects of the disclosure.
- FIG. 3 depicts a block diagram illustrating one or more machine learning model architectures according to aspects of the disclosure.
- FIG. 4 depicts a flow diagram of an example process for training a machine learning model using scalable feature selection according to aspects of the disclosure.
- FIG. 5 depicts a flow diagram of an example process for performing a training step for training the machine learning model using scalable feature selection according to aspects of the disclosure.
- FIG. 6 depicts a table comparing accuracy for the sparse learnable masks system to other feature selection approaches over various datasets according to aspects of the disclosure.
- FIG. 7 depicts a table comparing accuracy for the sparse learnable masks system to other feature selection approaches over various numbers of features to be selected according to aspects of the disclosure.
- the technology relates generally to scalable feature selection, which may be referred to herein as sparse learnable masks (SLM).
- SLM can be integrated into any deep learning or machine learning architecture due to its gradient-descent based optimization.
- SLM can utilize end-to-end learning through joint training with predictive models.
- SLM can improve scaling of feature selection, yielding a target number of features even when the number of input features or samples are large.
- SLM can modify learnable masks to select the target number of features while addressing differentiability challenges.
- SLM can utilize improved mutual information (MI) regularization based on a quadratic relaxation of the MI between labels and selected features, conditioned on the probability that a feature is selected.
- MI mutual information
- FIG. 1 depicts a block diagram of an example sparse learnable masks system 100 for scalable feature selection.
- the sparse learnable masks system 100 can be implemented on one or more computing devices in one or more locations.
- the sparse learnable masks system 100 can be configured to receive input data 102 , such as inference data and/or training data, for use in selecting features to train one or more machine learning models.
- the sparse learnable masks system 100 can receive the input data 102 as part of a call to an application programming interface (API) exposing the sparse learnable masks system 100 to one or more computing devices.
- API application programming interface
- the input data 102 can also be provided to the sparse learnable masks system 100 through a storage medium, such as remote storage connected to the one or more computing devices over a network.
- the input data 102 can further be provided as input through a user interface on a client computing device coupled to the sparse learnable masks system 100 .
- the input data 102 can include training data associated with feature selection, such as covariate input data and target labels.
- the input data 102 can be numerical, such as categorical features mapped to embeddings.
- the input data 102 can include training data for any machine learning task, such as medical diagnosis, image classification, speech recognition, price forecasting, and/or fraud detection.
- the training data can be split into a training set, a validation set, and/or a testing set.
- An example training/validation/testing split can be an 80/10/10 split, although any other split may be possible.
- the training data can include examples of features and labels associated with the machine learning task.
- the training data can be in any form suitable for training a machine learning model, according to one of a variety of different learning techniques.
- Learning techniques for training a model can include supervised learning, unsupervised learning, semi-supervised learning techniques, parameter-efficient techniques, and reinforcement learning techniques.
- the training data can include multiple training examples that can be received as input by a model.
- the training examples can be labeled with a desired output for the model when processing the labeled training examples.
- the label and the model output can be evaluated through a loss function to determine an error, which can be back propagated through the model to update weights for the model.
- a supervised learning technique can be applied to calculate an error between outputs, with a ground-truth label of a training example processed by the model.
- loss or error functions appropriate for the type of the task the model is being trained for can be utilized, such as cross-entropy loss for classification tasks, or mean square error for regression tasks.
- the gradient of the error with respect to the different weights of the candidate model on candidate hardware can be calculated, for example using a backpropagation algorithm, and the weights for the model can be updated.
- the model can be trained until stopping criteria are met, such as a number of iterations for training, a maximum period of time, a convergence, or when a minimum accuracy threshold is met.
- the sparse learnable masks system 100 can be configured to output one or more results related to scalable feature selection, generated as output data 104 .
- the output data 104 can include selected features associated with a machine learning task.
- the sparse learnable masks system 100 can be configured to send the output data 104 for display on a client or user display.
- the sparse learnable masks system 100 can be configured to provide the output data 104 as a set of computer-readable instructions, such as one or more computer programs.
- the computer programs can be written in any type of programming language, and according to any programming paradigm, e.g., declarative, procedural, assembly, object-oriented, data-oriented, functional, or imperative.
- the computer programs can be written to perform one or more different functions and to operate within a computing environment, e.g., on a physical device, virtual machine, or across multiple devices.
- the computer programs can also implement functionality described herein, for example, as performed by a system, engine, module, or model.
- the sparse learnable masks system 100 can further be configured to forward the output data 104 to one or more other devices configured for translating the output data into an executable program written in a computer programming language.
- the sparse learnable masks system 100 can also be configured to send the output data 104 to a storage device for storage and later retrieval.
- the sparse learning masks system 100 can integrate a feature selection layer into a machine learning architecture guided by gradient-descent based learning.
- x ⁇ R F 0 denote covariate input data
- y denote a target, such as class labels.
- the sparse learning masks system 100 can be integrated with a predictor model f ⁇ , with learnable parameters ⁇ , that is applied to selected features x sp ⁇ R F t , where F t denotes the number of selected features at step t.
- the predictor model can be any architecture trained via gradient descent, such as a multi-layer perceptron or deep tabular data learning. Multiplication of a binary mask M sp can indicate feature selection operation.
- the sparse learnable masks system 100 can perform training for scalable feature selection as follows.
- Input input data x with target labels y;
- Task loss may refer to a target prediction task of the dataset, such as medical diagnosis, image classification, speech recognition, price forecasting, and/or fraud detection, and MI loss may refer to how well one or more selected features align with the dataset labels.
- the sparse learnable masks system 100 can include a normalization engine 106 , a tempering engine 108 , a mask scaling engine 110 , and a mutual information engine 112 .
- the normalization engine 106 , tempering engine 108 , mask scaling engine 110 , and mutual information engine 112 can be implemented as one or more computer programs, specially configured electronic circuitry, or any combination thereof.
- the normalization engine 106 can be configured to combine sparse non-linear normalization with learnable feature selection vectors in SLM.
- the normalization engine 106 can perform a sparsemax normalization to achieve feature sparsity.
- Sparsemax may refer to any normalization operation able to achieve sparsity, e.g., the output includes more than a threshold amount of 0 elements.
- the normalization engine 106 can perform sparsemax normalization by returning a Euclidean projection of an input vector onto a probability simplex. For example:
- the probability simplex projection in sparsemax(v) can scale top values in v so they are equidistributed over [0,1]. This equidistribution can result in greater feature weight separation, encouraging discrimination among the features.
- the normalization engine 106 can apply the sparsemax normalization to a normalized mask argument to obtain a sparse feature mask. For example:
- the tempering engine 108 can be configured to gradually decrease a number of features selected until reaching a target number of selected features F N . For example:
- the tempering engine 108 can further be configured to decrease the number of features based on a discrete number of steps. The discrete number of steps can be evenly spaced. For example, the tempering engine 108 can decrease the number of features after every five steps.
- the tempering engine 108 allows the predictor model to learn from more than the final target number of features during training.
- the tempering engine 108 further allows for a more robust initialization for training the predictor model based on learning from all features initially compared to starting learning with the target number of features, as the randomness in the initial selection is seldom optimal.
- the mask scaling engine 110 can be configured to scale the sparse feature mask to achieve a predetermined number of non-zero features.
- the sparsity in the sparsemax normalization can be based on where the projection lands on the probability simplex ⁇ K ⁇ 1 .
- the mask scaling engine 110 can adjust the projection of v onto ⁇ K ⁇ 1 , such as by multiplying v by a positive scalar.
- sparsemax(m(x y)) argmin (z,w) ( ⁇ my ⁇ w ⁇ 2 + ⁇ mx ⁇ z ⁇ 2 ).
- d(0,1) ⁇ d(0.5,0.5) mx ⁇ my+0.5.
- sparsemax(m(x,y)) is closer to (0,1) ⁇ 1 whenever m>1/(2(y ⁇ x)) and closer to (0.5,0.5) otherwise. Since the projection is linear, varying the multiplier m varies the sparsity of sparsemax((x,y)). For example, larger multipliers can result in sparser output.
- the mask scaling engine 110 can obtain a predetermined number of nonzero elements in the sparse feature mask by multiplying by a scalar. For example, given a vector v ⁇ R K , the mask scaling engine 110 can obtain F nonzero elements in sparsemax(v) by multiplying v by the scalar:
- the mutual information engine 112 can be configured to increase the mutual information (MI) between the distribution of the selected features and the distribution of the labels as an inductive bias to the model that accounts for sample labels during feature selection.
- MI between distributions may refer to how similar or correlated the distributions are.
- the mutual information engine 112 can maximize the MI between the distribution of the selected features and the distribution of the labels.
- the mutual information engine 112 can condition the MI on the probability that a feature is selected given by the mask M.
- X can denote a random variable representing features and Y can denote a random variable representing labels, with value spaces X ⁇ X and Y ⁇ Y.
- Maximizing the conditional or the joint MI between selected features and labels can require computation of an exponential number of probabilities, the optimization of which can be intractable. Therefore, the mutual information engine 112 can conduct a quadratic relaxation of the MI which is end-to-end differentiable.
- MI I X,Y
- the mutual information engine 112 can ignore the second term during optimization, since the second term does not depend on features X. Therefore, the mutual information engine 112 can perform optimization to increase MI based on a quadratic relaxation I q (X,Y) to simplify I(X,Y) while retaining much of its properties, allowing for a reduction in computation cost and memory usage. For example:
- I q ( X,Y ): ( ⁇ x ⁇ X ⁇ y ⁇ Y P X,Y ( x,y ) 2 /P X ( x )) ⁇ y ⁇ Y P Y ( y ) 2 (6)
- p can be P X,Y (x,y) in the first term and P Y (y) in the second. Since both P X,Y (x,y) and P Y (y) are probabilities and sum to 1 across the label space for any given sample, the linear term ⁇ 3p/2 does not affect gradient descent optimization. Normalization can be a hard constraint enforced during training that supersedes this linear term in the objective. Therefore, during optimization,
- the mutual information engine 112 can connect I q (X,Y) with predictions from the predictor model using Lagrange multipliers.
- R(x,y): X ⁇ Y ⁇ [0,1] denote a probability outcome of the predictor model for sample x and outcome y.
- the below equations model a discrete label case, such as for classification, but a case where labels are continuous can be reduced to the discrete label case through quantization.
- a quadratic error term E(X,Y) can be defined in terms of R(x, y) and expanded as follows:
- the mutual information engine 112 can increase, such as maximize, the quadratic relaxation of MI by decreasing, such as minimizing, the error. For example:
- Lagrange multipliers can be used to solve for the optimal model predictions in terms of P X,Y (x,y) and P X (x), which can be used to express the objective E(X,Y) as a function of I q (X,Y).
- the mutual information engine 112 can select a given number of features that reduce, e.g., minimize, E(X,Y).
- I can denote the index set of the dataset samples
- J can denote the index set of the features
- L can denote the set of possible labels.
- S ⁇ J can denote the index set of features selected
- X i S can denote the random variable representing a selected subset of features for the i th sample.
- the mutual information engine 112 can reduce, e.g., minimize, error under one or more consistency constraints.
- This constraint can be included as a soft consistency regularization term r cs , converting constrained optimization to unconstrained optimization with regularization. For example:
- the consistency regularization encourages the selection of features with diverse ranges, since it encourages higher p j for the features with many X i 1 (j) ⁇ X i 2 (j) pairs. Therefore, as an example, the regularized objective to increase, e.g., maximize, the MI between selected features and the labels can be:
- r cs ⁇ ⁇ i 1 , i 2 ⁇ ⁇ I 2 , i 1 ⁇ i 2 ⁇ ( ⁇ X i 1 ( j ) ⁇ X i 2 ( j ) ⁇ ( 1 - p j ) ⁇ ( R ⁇ ( X i 1 S , Y i 1 ) - R ⁇ ( X i 2 S , Y i 2 ) 2 ) .
- the mutual information engine 112 can enforce the regularization term batch-wise and can vectorize the regularization term for a parallel computation of X i 1 (j) ⁇ X i (j) pairs per batch.
- the reduction, e g , minimization, objective with the consistency regularization can be derived similarly.
- the sparse learnable masks system 100 can reduce computational complexity through the normalization engine 106 , tempering engine 108 , mask scaling engine 110 , and/or mutual information engine 112 , resulting in lower processing power and memory usage while still achieving desired results.
- the sparsemax operation can be dominated by sorting and can have a complexity O(F 0 log log F 0 ) per sample, with an overall complexity of O(nF 0 log log F 0 ).
- the consistency regularization r cs in the MI-increasing objective E(X,Y) can have a complexity O(nbF N ), as the calculation occurs over the selected feature index set and is done between each sample and other in its batch.
- the non-regularization component in E(X,Y) has a complexity nc where c is the constant for the number of discrete or binned labels.
- nc the constant for the number of discrete or binned labels.
- O(nh 2 ) the overall computations have a complexity O(F 0 log log F 0 +nbF N +nc+nh 2 ), such that the dependence on the total number of features is ⁇ (F 0 ), allowing the sparse learnable masks system 100 to scale to a large number of features.
- FIG. 2 depicts a block diagram of an example environment 200 for implementing a sparse learnable masks system 218 .
- the sparse learnable masks system 218 can be implemented on one or more devices having one or more processors in one or more locations, such as in server computing device 202 .
- Client computing device 204 and the server computing device 202 can be communicatively coupled to one or more storage devices 206 over a network 208 .
- the storage devices 206 can be a combination of volatile and non-volatile memory and can be at the same or different physical locations than the computing devices 202 , 204 .
- the storage devices 206 can include any type of non-transitory computer readable medium capable of storing information, such as a hard-drive, solid state drive, tape drive, optical storage, memory card, ROM, RAM, DVD, CD-ROM, write-capable, and read-only memories.
- the server computing device 202 can include one or more processors 210 and memory 212 .
- the memory 212 can store information accessible by the processors 210 , including instructions 214 that can be executed by the processors 210 .
- the memory 212 can also include data 216 that can be retrieved, manipulated, or stored by the processors 210 .
- the memory 212 can be a type of transitory or non-transitory computer readable medium capable of storing information accessible by the processors 210 , such as volatile and non-volatile memory.
- the processors 210 can include one or more central processing units (CPUs), graphic processing units (GPUs), field-programmable gate arrays (FPGAs), and/or application-specific integrated circuits (ASICs), such as tensor processing units (TPUs).
- CPUs central processing units
- GPUs graphic processing units
- FPGAs field-programmable gate arrays
- ASICs application-specific integrated circuits
- TPUs tensor processing units
- the instructions 214 can include one or more instructions that, when executed by the processors 210 , cause the one or more processors 210 to perform actions defined by the instructions 214 .
- the instructions 214 can be stored in object code format for direct processing by the processors 210 , or in other formats including interpretable scripts or collections of independent source code modules that are interpreted on demand or compiled in advance.
- the instructions 214 can include instructions for implementing a sparse learnable masks system 218 , which can correspond to the sparse learnable masks system 100 of FIG. 1 .
- the sparse learnable masks system 218 can be executed using the processors 210 , and/or using other processors remotely located from the server computing device 202 .
- the data 216 can be retrieved, stored, or modified by the processors 210 in accordance with the instructions 214 .
- the data 216 can be stored in computer registers, in a relational or non-relational database as a table having a plurality of different fields and records, or as JSON, YAML, proto, or XML documents.
- the data 216 can also be formatted in a computer-readable format such as, but not limited to, binary values, ASCII, or Unicode.
- the data 216 can include information sufficient to identify relevant information, such as numbers, descriptive text, proprietary codes, pointers, references to data stored in other memories, including other network locations, or information that is used by a function to calculate relevant data.
- the client computing device 204 can also be configured similarly to the server computing device 202 , with one or more processors 220 , memory 222 , instructions 224 , and data 226 .
- the client computing device 204 can also include a user input 228 and a user output 230 .
- the user input 228 can include any appropriate mechanism or technique for receiving input from a user, such as keyboard, mouse, mechanical actuators, soft actuators, touchscreens, microphones, and sensors.
- the server computing device 202 can be configured to transmit data to the client computing device 204 , and the client computing device 204 can be configured to display at least a portion of the received data on a display implemented as part of the user output 230 .
- the user output 230 can also be used for displaying an interface between the client computing device 204 and the server computing device 202 .
- the user output 230 can alternatively or additionally include one or more speakers, transducers or other audio outputs, a haptic interface or other tactile feedback that provides non-visual and non-audible information to the platform user of the client computing device 204 .
- FIG. 2 illustrates the processors 210 , 220 and the memories 212 , 222 as being within the respective computing devices 202 , 204
- components described herein can include multiple processors and memories that can operate in different physical locations and not within the same computing device.
- some of the instructions 214 , 224 and the data 216 , 226 can be stored on a removable SD card and others within a read-only computer chip.
- Some or all of the instructions 214 , 224 and data 216 , 226 can be stored in a location physically remote from, yet still accessible by, the processors 210 , 220 .
- the processors 210 , 220 can include a collection of processors that can perform concurrent and/or sequential operation.
- the computing devices 202 , 204 can each include one or more internal clocks providing timing information, which can be used for time measurement for operations and programs run by the computing devices 202 , 204 .
- the server computing device 202 can be connected over the network 208 to a data center 232 housing any number of hardware accelerators 234 .
- the data center 232 can be one of multiple data centers or other facilities in which various types of computing devices, such as hardware accelerators, are located. Computing resources housed in the data center 232 can be specified for deploying models with scalable feature selection, as described herein.
- the server computing device 202 can be configured to receive requests to process data from the client computing device 204 on computing resources in the data center 232 .
- the environment 200 can be part of a computing platform configured to provide a variety of services to users, through various user interfaces and/or application programming interfaces (APIs) exposing the platform services.
- the variety of services can include medical diagnosis, image classification, speech recognition, price forecasting, and/or fraud detection utilizing the scalable feature selection as described herein.
- the client computing device 204 can transmit input data associated with feature selection, such as covariate input data and target labels.
- the sparse learnable masks system 218 can receive the input data, and in response, generate output data including a selected predetermined number of features with increased mutual information between the selected features and the labels.
- the server computing device 202 can maintain a variety of models in accordance with different constraints available at the data center 232 .
- the server computing device 202 can maintain different families for deploying models on various types of TPUs and/or GPUs housed in the data center 232 or otherwise available for processing.
- FIG. 3 depicts a block diagram 300 illustrating one or more machine learning model architectures 302 , more specifically 302 A-N for each architecture, for deployment in a datacenter 304 housing a hardware accelerator 306 on which the deployed machine learning models 302 will execute, such as for scalable feature selection as described herein.
- the hardware accelerator 306 can be any type of processor, such as a CPU, GPU, FPGA, or ASIC such as a TPU.
- An architecture 302 of a machine learning model can refer to characteristics defining the model, such as characteristics of layers for the model, how the layers process input, or how the layers interact with one another.
- the architecture 302 of the machine learning model can also define types of operations performed within each layer.
- One or more machine learning model architectures 302 can be generated that can output results, such as for scalable feature selection.
- Example model architectures 302 can correspond to a multi-layer perceptron and/or deep tabular data learning.
- the devices 202 , 204 and the data center 232 can be capable of direct and indirect communication over the network 208 .
- the client computing device 204 can connect to a service operating in the data center 232 through an Internet protocol.
- the devices 202 , 204 can set up listening sockets that may accept an initiating connection for sending and receiving information.
- the network 208 can include various configurations and protocols including the Internet, World Wide Web, intranets, virtual private networks, wide area networks, local networks, and private networks using communication protocols proprietary to one or more companies.
- the network 208 can support a variety of short- and long-range connections.
- the short- and long-range connections may be made over different bandwidths, such as 2.402 GHz to 2.480 GHz, commonly associated with the Bluetooth® standard, 2.4 GHz and 5 GHz, commonly associated with the Wi-Fi® communication protocol; or with a variety of communication standards, such as the LTE® standard for wireless broadband communication.
- the network 208 in addition or alternatively, can also support wired connections between the devices 202 , 204 and the data center 232 , including over various types of Ethernet connection.
- FIG. 2 Although a single server computing device 202 , client computing device 204 , and data center 232 are shown in FIG. 2 , it is understood that the aspects of the disclosure can be implemented according to a variety of different configurations and quantities of computing devices, including in paradigms for sequential or parallel processing, or over a distributed network of multiple devices. In some implementations, aspects of the disclosure can be performed on a single device connected to hardware accelerators configured for processing optimization models, and any combination thereof.
- FIG. 4 depicts a flow diagram of an example process 400 for training a machine learning model using scalable feature selection.
- the example process 400 can be performed on a system of one or more processors in one or more locations, such as the sparse learnable masks system 100 as depicted in FIG. 1 .
- the sparse learnable masks system 100 can be configured to receive a plurality of features for training a machine learning model.
- the plurality of features can be numerical, such as categorical features mapped to embeddings.
- the plurality of features can be associated with any machine learning task, such as medical diagnosis, image classification, speech recognition, price forecasting, and/or fraud detection.
- the machine learning model can include any architecture trained using gradient descent, such as a multi-layer perceptron or a deep tabular data learning model.
- the sparse learnable masks system 100 can further receive a plurality of labels associated with the plurality of features. For example, each of the plurality of labels can denote a target based on one or more of the plurality of features, such as classification labels.
- the sparse learnable masks system 100 can be configured to receive a total number of training steps.
- the total number of training steps can correspond to a number of iterations in training the machine learning model, such as for a particular machine learning task.
- the sparse learnable masks system 100 can be configured to initialize a learnable mask vector representing the plurality of features.
- the learnable mask vector can be initialized with all ones to indicate all of the plurality of features are initially selected.
- the sparse learnable masks system 100 can be configured to iteratively perform a training step for the total number of training steps.
- Performing the training step can include receiving a number of features to be selected for the training step; generating a sparse mask vector from the learnable mask vector; selecting a set of features of the plurality of features based on the sparse mask vector and the number of features to be selected; computing a mutual information based error based on the selected set of features being input into the machine learning model; and updating the learnable mask vector based on the mutual information-based error.
- the sparse learnable masks system 100 can be configured to output a final selected set of features, represented by the updated learnable mask vector, to be utilized by the machine learning model.
- the updated learnable mask vector can have ones indicating selected features and zeros indicating non-selected features.
- the sparse learnable masks system 100 can further output a trained machine learning model that utilizes the final selected set of features when performing the machine learning task.
- FIG. 5 depicts a flow diagram of an example process 500 for performing a training step for training the machine learning model using scalable feature selection.
- the example process 500 can be performed on a system of one or more processors in one or more locations, such as the sparse learnable masks system 100 as depicted in FIG. 1 .
- the sparse learnable masks system 100 can be configured to receive a number of features to be selected for the training step.
- the number of features to be selected can be gradually decreased over a total number of training steps until reaching a target number of features to be selected.
- Gradually decreasing the number of features to be selected can be based on a discrete number of evenly spaced steps.
- the number of features to be selected can start at 50 features and gradually decrease every 5 th training step.
- the gradual decrease of selected features can be based on a tempering threshold, which can be a fraction of the number of training steps.
- the sparse learnable masks system 100 can be configured to generate a sparse mask vector from the learnable mask vector.
- the sparse learnable masks system 100 can apply a sparsemax normalization to the learnable mask vector.
- the sparse learnable masks system 100 can return a Euclidean projection of the learnable mask vector onto a probability simplex. The projection can scale values in the learnable mask vector to be equidistributed over [0,1].
- the sparse learnable masks system 100 can be configured to select a set of features of the plurality of features based on the sparse mask vector and the number of features to be selected.
- the sparse learnable masks system 100 can scale the sparse feature mask to achieve a predetermined number of non-zero values representing a set of features to be selected.
- the sparse learnable masks system 100 can adjust the projection in the learnable mask vector by multiplying by a positive scalar. Larger positive scalars may increase sparsity while smaller positive scalars may decrease sparsity in the sparse mask vector.
- the sparse learnable masks system 100 can be configured to compute a mutual information based error based on the selected set of features being input into the machine learning model. For example, computing the mutual information based error can be based on maximizing mutual information between a distribution of the selected set of features and a distribution of labels for the selected set of features. The mutual information can be conditioned on the probability that a feature is selected based on the sparse feature mask.
- the sparse learnable masks system 100 can further be configured to compute a training task loss based on the selected set of features being input into the machine learning model, such as by calculating a difference between model predictions and dataset labels.
- the sparse learnable masks system 100 can update the learnable mask vector based on the mutual information based error.
- the sparse learnable masks system 100 can further update the learnable mask vector based on the training task loss.
- the sparse learnable masks system 100 can further update one or more parameters for the machine learning model based on the mutual information based error and/or the training task loss. Updating the learnable mask vector can be based on an objective of reducing, e.g., minimizing, the mutual information based error and/or training task loss. Updating the learnable mask vector can include removing non-selected features of the plurality of features.
- the updated learnable mask vector can have ones indicating selected features and zeros indicating non-selected features or floating point numbers to indicate the probability of selecting a feature.
- SLM can achieve or improve upon other approaches to feature selection while reducing computational complexity and cost.
- the various datasets include the following domains: Mice, MNIST, Fashion-MNIST, Isolet, Coil-20, Activity, Ames, Fraud.
- Mice refers to protein expression levels measured in the cortex of normal and trisomic mice who had been exposed to different experimental conditions. Each feature is the expression level of one protein.
- MNIST and Fashion-MNIST refer to 28-by-28 grayscale images of hand-written digits and clothing items, respectively.
- the images are converted to tabular data by treating each pixel as a separate feature.
- Isolet refers to preprocessed speech data of people speaking the names of the letters in the English alphabet with each feature being one of the preprocessed quantities, including spectral coefficients and sonorant features.
- Coil-20 refers to centered grayscale images of 20 objects taken at pose intervals of 5 degrees amounting to 72 images for each object. During preprocessing, the images were resized to produce 20-by-20 images, with each feature being one of the pixels.
- Activity refers to sensor data collected from a smartphone mounted on subjects while they performed several activities such as walking upstairs, standing and laying, with each being one of the 561 raw or processed quantities from the sensors on the phone.
- IEEE-CIS Fraud Detection refers to a dataset with the goal of predicting residential housing prices based on each features of the home.
- IEEE-CIS Fraud Detection refers to a dataset with the goal of identifying fraudulent transactions from numerous transaction and identity dependent features.
- FIG. 6 depicts a table comparing accuracy for the sparse learnable masks system to other feature selection approaches over various datasets.
- the table illustrates selecting 50 features across a wide range of high dimensional datasets, most with >400 features.
- the table shows that the SLM consistently yields competitive performance, outperforming all other approaches in all cases except on Mice and Ames, for both of which the performance was saturated due to the small numbers of original features, making feature selection less relevant.
- Most other feature selection approaches are not consistent in their performance while SLM had consistently strong performance. SLM even improved upon a baseline of using all features, which can likely be attributed to superior generalization when the limited model capacity is focused on the most salient features.
- FIG. 7 depicts a table comparing accuracy for the sparse learnable masks system to other feature selection approaches over various numbers of features to be selected.
- the table focuses on the Fraud dataset and reports performance as a different number of selected features.
- the table illustrates that SLM outperforms the other approaches, and its performance degradation is smaller with less features.
- SLM can also be used for interpretation of global feature importance during inference, yielding the importance ranking of selected features. This can be highly desired in high-stakes applications, such as healthcare or finance, where an importance score can be more useful than simply whether a feature is selected or not.
- MI high-stakes applications, such as healthcare or finance, where an importance score can be more useful than simply whether a feature is selected or not.
- SLM does not need to sample from the joint or marginal distributions, a potentially computationally intensive process, and does not require a contrastive term in the estimation of MI, resulting in less computational cost.
- SLM accounts for feature inter-dependence by learning inter-dependent probabilities for the selected feature, where the inter-dependent probabilities jointly maximize the MI between features and labels.
- SLM learns feature selection and the task objective in an end-to-end manner, which alleviates the selection of repetitive features that may individually be predictive, but less predictive over an individually predictive but redundant feature.
- SLM can improve generalization, especially for high capacity models like deep neural networks, as they can easily overfit patterns from spurious features that do not hold across training and test data splits. For instance, the table in FIG. 6 shows that in some cases, especially with SLM, prediction on a subset of features can outperform that on all features.
- aspects of this disclosure can be implemented in digital electronic circuitry, in tangibly embodied computer software or firmware, and/or in computer hardware, such as the structure disclosed herein, their structural equivalents, or combinations thereof.
- aspects of this disclosure can further be implemented as one or more computer programs, such as one or more modules of computer program instructions encoded on a tangible non-transitory computer storage medium for execution by, or to control the operation of, one or more data processing apparatus.
- the computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or combinations thereof.
- the computer program instructions can be encoded on an artificially generated propagated signal, such as a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- data processing apparatus or “data processing system” refers to data processing hardware and encompasses various apparatus, devices, and machines for processing data, including programmable processors, computers, or combinations thereof.
- the data processing apparatus can include special purpose logic circuitry, such as a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC).
- FPGA field programmable gate array
- ASIC application specific integrated circuit
- the data processing apparatus can include code that creates an execution environment for computer programs, such as code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or combinations thereof.
- computer program refers to a program, software, a software application, an app, a module, a software module, a script, or code.
- the computer program can be written in any form of programming language, including compiled, interpreted, declarative, or procedural languages, or combinations thereof.
- the computer program can be deployed in any form, including as a standalone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.
- the computer program can correspond to a file in a file system and can be stored in a portion of a file that holds other programs or data, such as one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, such as files that store one or more modules, sub programs, or portions of code.
- the computer program can be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a data communication network.
- database refers to any collection of data.
- the data can be unstructured or structured in any manner
- the data can be stored on one or more storage devices in one or more locations.
- an index database can include multiple collections of data, each of which may be organized and accessed differently.
- engine refers to a software-based system, subsystem, or process that is programmed to perform one or more specific functions.
- the engine can be implemented as one or more software modules or components or can be installed on one or more computers in one or more locations.
- a particular engine can have one or more computers dedicated thereto, or multiple engines can be installed and running on the same computer or computers.
- the processes and logic flows described herein can be performed by one or more computers executing one or more computer programs to perform functions by operating on input data and generating output data.
- the processes and logic flows can also be performed by special purpose logic circuitry, or by a combination of special purpose logic circuitry and one or more computers.
- a computer or special purpose logic circuitry executing the one or more computer programs can include a central processing unit, including general or special purpose microprocessors, for performing or executing instructions and one or more memory devices for storing the instructions and data.
- the central processing unit can receive instructions and data from the one or more memory devices, such as read only memory, random access memory, or combinations thereof, and can perform or execute the instructions.
- the computer or special purpose logic circuitry can also include, or be operatively coupled to, one or more storage devices for storing data, such as magnetic, magneto optical disks, or optical disks, for receiving data from or transferring data to.
- the computer or special purpose logic circuitry can be embedded in another device, such as a mobile phone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS), or a portable storage device, e.g., a universal serial bus (USB) flash drive, as examples.
- a mobile phone such as a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS), or a portable storage device, e.g., a universal serial bus (USB) flash drive, as examples.
- PDA personal digital assistant
- GPS Global Positioning System
- USB universal serial bus
- Computer readable media suitable for storing the one or more computer programs can include any form of volatile or non-volatile memory, media, or memory devices. Examples include semiconductor memory devices, e.g., EPROM, EEPROM, or flash memory devices, magnetic disks, e.g., internal hard disks or removable disks, magneto optical disks, CD-ROM disks, DVD-ROM disks, or combinations thereof.
- semiconductor memory devices e.g., EPROM, EEPROM, or flash memory devices
- magnetic disks e.g., internal hard disks or removable disks, magneto optical disks, CD-ROM disks, DVD-ROM disks, or combinations thereof.
- aspects of the disclosure can be implemented in a computing system that includes a back end component, e.g., as a data server, a middleware component, e.g., an application server, or a front end component, e.g., a client computer having a graphical user interface, a web browser, or an app, or any combination thereof.
- the components of the system can be interconnected by any form or medium of digital data communication, such as a communication network. Examples of communication networks include a local area network (LAN) and a wide area network (WAN), e.g., the Internet.
- LAN local area network
- WAN wide area network
- the computing system can include clients and servers.
- a client and server can be remote from each other and interact through a communication network.
- the relationship of client and server arises by virtue of the computer programs running on the respective computers and having a client-server relationship to each other.
- a server can transmit data, e.g., an HTML page, to a client device, e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device.
- Data generated at the client device e.g., a result of the user interaction, can be received at the server from the client device.
Abstract
Aspects of the disclosure are directed to a canonical approach for feature selection referred to as sparse learnable masks (SLM). SLM integrates learnable sparse masks into end-to-end training. For the fundamental non-differentiability challenge of selecting a desired number of features, SLM includes dual mechanisms for automatic mask scaling by achieving a desired feature sparsity and gradually tempering this sparsity for effective learning. SLM further employs an objective that increases mutual information (MI) between selected features and labels in an efficient and scalable manner. Empirically, SLM can achieve or improve upon state-of-the-art results on several benchmark datasets, often by a significant margin, while reducing computational complexity and cost.
Description
- The present application claims the benefit of the filing date of U.S. Provisional Patent Application No. 63/410,883, filed Sep. 28, 2022, the disclosure of which is hereby incorporated herein by reference.
- In many machine learning scenarios, a significant portion of input features may be irrelevant to generating outputs. Therefore, feature selection is utilized to filter out irrelevant features from the input features. Feature selection can bring multitude of benefits in machine learning. A smaller number of features can yield superior generalization, and hence better test accuracy, by minimizing information extraction from spurious patterns that do not hold consistently and by more optimally utilizing the model capacity on the most relevant features. In addition, reducing the number of input features can decrease the computational complexity and cost for deployed models, allowing for a decrease in infrastructure requirements to support the features, as the deployed models can learn mappings from input data with smaller dimensions. Further, reducing the number of input features can improve interpretability and controllability, as users can focus on understanding outputs of deployed models from a smaller subset of input features. As an example, feature selection can consider the predictive model itself, as an optimal set of features would depend on how mapping occurs between inputs and outputs. This may be referred to as embedded feature selection and can include regularization techniques and extensions. However, a fundamental challenge, especially with respect to deep learning, is that selection operations are non-differentiable, given a target count for selected features, which can require soft approximations for feature selection and result in lower quality outputs.
- Aspects of the disclosure are directed to a canonical approach for feature selection referred to as sparse learnable masks (SLM). SLM integrates learnable sparse masks into end-to-end training. For the fundamental non-differentiability challenge of selecting a desired number of features, SLM includes dual mechanisms for automatic mask scaling by achieving a desired feature sparsity and gradually tempering this sparsity for effective learning. SLM further employs an objective that increases mutual information (MI) between selected features and labels in an efficient and scalable manner Empirically, SLM can achieve or improve upon state-of-the-art results on several benchmark datasets, often by a significant margin, while reducing computational complexity and cost.
- An aspect of the disclosure provides for a method for training a machine learning model with scalable feature selection, including: receiving, by one or more processors, a plurality of features for training the machine learning model; initializing, by the one or more processors, a learnable mask vector representing the plurality of features; receiving, by the one or more processors, a number of features to be selected; generating, by the one or more processors, a sparse mask vector from the learnable mask vector; selecting, by the one or more processors, a selected set of features of the plurality of features based on the sparse mask vector and the number of features to be selected; computing, by the one or more processors, a mutual information based error based on the selected set of features being input into the machine learning model; and updating, by the one or more processors, the learnable mask vector based on the mutual information based error.
- In an example, the method further includes receiving, by the one or more processors, a total number of training steps. In another example, the receiving, generating, selecting, computing, and updating is iterative for the total number of training steps. In yet another example, the learnable mask vector updated after the total number of training steps includes a final selected set of features to be utilized by the machine learning model.
- In yet another example, training the machine learning model further includes gradient-descent based learning. In yet another example, the method further includes removing non-selected features of the plurality of features. In yet another example, the method further includes applying a sparsemax normalization to the learnable mask vector.
- In yet another example, the method further includes decreasing the number of features over a total number of training steps until reaching a target number of features to be selected. In yet another example, gradually decreasing the number of features to be selected is based on a discrete number of evenly spaced steps.
- In yet another example, selecting the selected set of features further includes multiplying the sparse vector by a positive scalar based on a predetermined number of features. In yet another example, computing the mutual information based error is based on maximizing mutual information between a distribution of the selected set of features and a distribution of labels for the selected set of features. In yet another example, updating the learnable mask vector is based on minimizing the mutual information based error.
- Another aspect of the disclosure provides for a system including: one or more processors; and one or more storage devices coupled to the one or more processors and storing instructions that, when executed by the one or more processors, cause the one or more processors to perform operations for training a machine learning model with scalable feature selection, the operations including: receiving a plurality of features for training the machine learning model; initializing a learnable mask vector representing the plurality of features; receiving a number of features to be selected; generating a sparse mask vector from the learnable mask vector; selecting a selected set of features of the plurality of features based on the sparse mask vector and the number of features to be selected; computing a mutual information based error based on the selected set of features being input into the machine learning model; and updating the learnable mask vector based on the mutual information based error.
- In an example, the operations further include receiving a total number of training steps; the receiving, generating, selecting, computing, and updating is iterative for the total number of training steps; and the learnable mask vector updated after the total number of training steps includes a final selected set of features to be utilized by the machine learning model.
- In another example, the operations further include removing non-selected features of the plurality of features. In yet another example, the operations further include applying a sparsemax normalization to the learnable mask vector. In yet another example, the operations further include gradually decreasing the number of features over a total number of training steps until reaching a target number of features to be selected.
- In yet another example, selecting the selected set of features further includes multiplying the sparse vector by a positive scalar based on a predetermined number of features. In yet another example, computing the mutual information based error is based on maximizing mutual information between a distribution of the selected set of features and a distribution of labels for the selected set of features.
- Yet another aspect of the disclosure provides for a non-transitory computer readable medium for storing instructions that, when executed by one or more processors, cause the one or more processors to perform operations for training a machine learning model with scalable feature selection, the operations including: receiving a plurality of features for training the machine learning model; initializing a learnable mask vector representing the plurality of features; receiving a number of features to be selected; generating a sparse mask vector from the learnable mask vector; selecting a selected set of features of the plurality of features based on the sparse mask vector and the number of features to be selected; computing a mutual information based error based on the selected set of features being input into the machine learning model; and updating the learnable mask vector based on the mutual information based error.
-
FIG. 1 depicts a block diagram of an example sparse learnable masks system for scalable feature selection according to aspects of the disclosure. -
FIG. 2 depicts a block diagram of an example environment for implementing a sparse learnable masks system according to aspects of the disclosure. -
FIG. 3 depicts a block diagram illustrating one or more machine learning model architectures according to aspects of the disclosure. -
FIG. 4 depicts a flow diagram of an example process for training a machine learning model using scalable feature selection according to aspects of the disclosure. -
FIG. 5 depicts a flow diagram of an example process for performing a training step for training the machine learning model using scalable feature selection according to aspects of the disclosure. -
FIG. 6 depicts a table comparing accuracy for the sparse learnable masks system to other feature selection approaches over various datasets according to aspects of the disclosure. -
FIG. 7 depicts a table comparing accuracy for the sparse learnable masks system to other feature selection approaches over various numbers of features to be selected according to aspects of the disclosure. - The technology relates generally to scalable feature selection, which may be referred to herein as sparse learnable masks (SLM). SLM can be integrated into any deep learning or machine learning architecture due to its gradient-descent based optimization. SLM can utilize end-to-end learning through joint training with predictive models. SLM can improve scaling of feature selection, yielding a target number of features even when the number of input features or samples are large. SLM can modify learnable masks to select the target number of features while addressing differentiability challenges. Further, SLM can utilize improved mutual information (MI) regularization based on a quadratic relaxation of the MI between labels and selected features, conditioned on the probability that a feature is selected. SLM can demonstrate feature selection with improved results compared to state-of-the-art feature selection, resulting in higher quality models with reduced computational complexity and cost.
-
FIG. 1 depicts a block diagram of an example sparselearnable masks system 100 for scalable feature selection. The sparselearnable masks system 100 can be implemented on one or more computing devices in one or more locations. - The sparse
learnable masks system 100 can be configured to receiveinput data 102, such as inference data and/or training data, for use in selecting features to train one or more machine learning models. For example, the sparselearnable masks system 100 can receive theinput data 102 as part of a call to an application programming interface (API) exposing the sparselearnable masks system 100 to one or more computing devices. Theinput data 102 can also be provided to the sparselearnable masks system 100 through a storage medium, such as remote storage connected to the one or more computing devices over a network. Theinput data 102 can further be provided as input through a user interface on a client computing device coupled to the sparselearnable masks system 100. - The
input data 102 can include training data associated with feature selection, such as covariate input data and target labels. Theinput data 102 can be numerical, such as categorical features mapped to embeddings. Theinput data 102 can include training data for any machine learning task, such as medical diagnosis, image classification, speech recognition, price forecasting, and/or fraud detection. The training data can be split into a training set, a validation set, and/or a testing set. An example training/validation/testing split can be an 80/10/10 split, although any other split may be possible. The training data can include examples of features and labels associated with the machine learning task. - The training data can be in any form suitable for training a machine learning model, according to one of a variety of different learning techniques. Learning techniques for training a model can include supervised learning, unsupervised learning, semi-supervised learning techniques, parameter-efficient techniques, and reinforcement learning techniques. For example, the training data can include multiple training examples that can be received as input by a model. The training examples can be labeled with a desired output for the model when processing the labeled training examples. The label and the model output can be evaluated through a loss function to determine an error, which can be back propagated through the model to update weights for the model. For example, a supervised learning technique can be applied to calculate an error between outputs, with a ground-truth label of a training example processed by the model. Any of a variety of loss or error functions appropriate for the type of the task the model is being trained for can be utilized, such as cross-entropy loss for classification tasks, or mean square error for regression tasks. The gradient of the error with respect to the different weights of the candidate model on candidate hardware can be calculated, for example using a backpropagation algorithm, and the weights for the model can be updated. The model can be trained until stopping criteria are met, such as a number of iterations for training, a maximum period of time, a convergence, or when a minimum accuracy threshold is met.
- From the
input data 102, the sparselearnable masks system 100 can be configured to output one or more results related to scalable feature selection, generated asoutput data 104. Theoutput data 104 can include selected features associated with a machine learning task. As an example, the sparselearnable masks system 100 can be configured to send theoutput data 104 for display on a client or user display. As another example, the sparselearnable masks system 100 can be configured to provide theoutput data 104 as a set of computer-readable instructions, such as one or more computer programs. The computer programs can be written in any type of programming language, and according to any programming paradigm, e.g., declarative, procedural, assembly, object-oriented, data-oriented, functional, or imperative. The computer programs can be written to perform one or more different functions and to operate within a computing environment, e.g., on a physical device, virtual machine, or across multiple devices. The computer programs can also implement functionality described herein, for example, as performed by a system, engine, module, or model. The sparselearnable masks system 100 can further be configured to forward theoutput data 104 to one or more other devices configured for translating the output data into an executable program written in a computer programming language. The sparselearnable masks system 100 can also be configured to send theoutput data 104 to a storage device for storage and later retrieval. - The sparse
learning masks system 100 can integrate a feature selection layer into a machine learning architecture guided by gradient-descent based learning. As an example, let x∈RF0 denote covariate input data and y denote a target, such as class labels. The sparselearning masks system 100 can be integrated with a predictor model fθ, with learnable parameters θ, that is applied to selected features xsp∈RFt , where Ft denotes the number of selected features at step t. The predictor model can be any architecture trained via gradient descent, such as a multi-layer perceptron or deep tabular data learning. Multiplication of a binary mask Msp can indicate feature selection operation. The sparselearnable masks system 100 can perform training for scalable feature selection as follows. - Input: input data x with target labels y;
- Input: total training steps N;
- Initialize: learnable mask argument M←all-ones vector;
- For t=1 to N do:
- Obtain a number of selected features Ft for step t;
- Generate sparse mask Msp=sparsemax(M);
- Select and weigh input features: xsp=x·Msp where non-selected features are zeroed out;
- Input the selected features into a predictor fθ(xsp) for a machine learning task;
- Compute a training task loss l(xsp,y) and MI loss E(xsp,y); and
- Update parameters θ and M using the task loss l and/or MI loss E (xsp,y).
- Task loss may refer to a target prediction task of the dataset, such as medical diagnosis, image classification, speech recognition, price forecasting, and/or fraud detection, and MI loss may refer to how well one or more selected features align with the dataset labels.
- The sparse
learnable masks system 100 can include anormalization engine 106, atempering engine 108, a mask scaling engine 110, and a mutual information engine 112. Thenormalization engine 106, temperingengine 108, mask scaling engine 110, and mutual information engine 112 can be implemented as one or more computer programs, specially configured electronic circuitry, or any combination thereof. - The
normalization engine 106 can be configured to combine sparse non-linear normalization with learnable feature selection vectors in SLM. For example, thenormalization engine 106 can perform a sparsemax normalization to achieve feature sparsity. Sparsemax may refer to any normalization operation able to achieve sparsity, e.g., the output includes more than a threshold amount of 0 elements. Thenormalization engine 106 can perform sparsemax normalization by returning a Euclidean projection of an input vector onto a probability simplex. For example: -
sparsemax(v):=argmin p∈ΔK−1 ∥p−v∥ 2 (1) - The probability simplex projection in sparsemax(v) can scale top values in v so they are equidistributed over [0,1]. This equidistribution can result in greater feature weight separation, encouraging discrimination among the features. The
normalization engine 106 can apply the sparsemax normalization to a normalized mask argument to obtain a sparse feature mask. For example: -
M sp=sparsemax(M) (2) - The tempering
engine 108 can be configured to gradually decrease a number of features selected until reaching a target number of selected features FN. For example: -
- FN can denote the number of selected features at a step t and Ntmp can denote a tempering threshold. As examples, Ntmp=N/2or Ntmp=N/4, though any tempering threshold can be utilized. The tempering
engine 108 can further be configured to decrease the number of features based on a discrete number of steps. The discrete number of steps can be evenly spaced. For example, the temperingengine 108 can decrease the number of features after every five steps. The temperingengine 108 allows the predictor model to learn from more than the final target number of features during training. The temperingengine 108 further allows for a more robust initialization for training the predictor model based on learning from all features initially compared to starting learning with the target number of features, as the randomness in the initial selection is seldom optimal. - The mask scaling engine 110 can be configured to scale the sparse feature mask to achieve a predetermined number of non-zero features. The sparsity in the sparsemax normalization can be based on where the projection lands on the probability simplex ΔK−1. For a non-uniform vector v∈R, the mask scaling engine 110 can adjust the projection of v onto ΔK−1, such as by multiplying v by a positive scalar.
- Larger scalars may increase sparsity while smaller scalars may decrease sparsity. For example, for two dimensional data, the probability simplex Δ1 in R2 is the line connecting (0,1) and (1,0), with these two points as the simplex boundary. Let v=(x, y) be a point in R2, and (z, w) be the projection of the point onto Δ1. With a varying multiplier m, sparsemax(mv) can have varying degrees of sparsity. The projection (z,w)=sparsemax((x,y)) can be the unique point that satisfies (z,w)=argmin(z,w)(∥y−w∥2+∥x−z∥2), where (z,w) is element wise positive and z+w=1. As (x,y) is scaled with m, sparsemax(m(x y))=argmin(z,w)(∥my−w∥2+∥mx−z∥2). This projection distance can expand to: d(z,w):=∥my−w∥2+∥mx−z∥2=m2y2−2myw+w2+m2x2−2mxz+z2. Hence, d(0,1)−d(0.5,0.5)=mx−my+0.5. For any (x,y) and m with y>x, sparsemax(m(x,y)) is closer to (0,1)∈Δ1 whenever m>1/(2(y−x)) and closer to (0.5,0.5) otherwise. Since the projection is linear, varying the multiplier m varies the sparsity of sparsemax((x,y)). For example, larger multipliers can result in sparser output.
- The mask scaling engine 110 can obtain a predetermined number of nonzero elements in the sparse feature mask by multiplying by a scalar. For example, given a vector v∈RK, the mask scaling engine 110 can obtain F nonzero elements in sparsemax(v) by multiplying v by the scalar:
-
-
- where v(1)≥v(2) . . . v(K) denote sorted elements of v in descending order.
- The mutual information engine 112 can be configured to increase the mutual information (MI) between the distribution of the selected features and the distribution of the labels as an inductive bias to the model that accounts for sample labels during feature selection. MI between distributions may refer to how similar or correlated the distributions are. For example, the mutual information engine 112 can maximize the MI between the distribution of the selected features and the distribution of the labels. The mutual information engine 112 can condition the MI on the probability that a feature is selected given by the mask M.
- As an example, X can denote a random variable representing features and Y can denote a random variable representing labels, with value spaces X∈X and Y∈Y. Maximizing the conditional or the joint MI between selected features and labels can require computation of an exponential number of probabilities, the optimization of which can be intractable. Therefore, the mutual information engine 112 can conduct a quadratic relaxation of the MI which is end-to-end differentiable. As an example, when the mutual information engine 112 models X and Y as random variables, their MI I (X,Y) can be defined, and after marginalizing over X, can be determined as:
-
I(X,Y):=Σx∈XΣy∈Y P X,Y(x,y) log log P x,y(x,y)/P X(x)P Y(y)=(Σx∈XΣy∈Y P X,Y(x,y) log log P X,Y(x,y)/P X(x))−Σy∈Y P Y(y) log log P Y(y) (5) - The mutual information engine 112 can ignore the second term during optimization, since the second term does not depend on features X. Therefore, the mutual information engine 112 can perform optimization to increase MI based on a quadratic relaxation Iq(X,Y) to simplify I(X,Y) while retaining much of its properties, allowing for a reduction in computation cost and memory usage. For example:
-
I q(X,Y):=(Σx∈XΣy∈Y P X,Y(x,y)2 /P X(x))−Σy∈Y P Y(y)2 (6) - In this example, p log log q is relaxed to pq, as both p log log q and pq are convex with respect to p and q. From an optimization perspective, Iq(X,Y) can approximate I(X,Y) where PX,Y(X,Y)/PX(x) and PY(y) are in within (1−δ,1+δ). Here, using Taylor expansion, log log (q)=log log (q0)+(q−q0)/q0−(q−q0)2/2q0 2+ . . . . When q0=1, the Taylor expansion becomes
-
- Therefore, p log log q can have a second order approximation −3p/2+2pq or −3p/2+2p2 when p=q. In I(X,Y), p can be PX,Y(x,y) in the first term and PY(y) in the second. Since both PX,Y(x,y) and PY(y) are probabilities and sum to 1 across the label space for any given sample, the linear term −3p/2 does not affect gradient descent optimization. Normalization can be a hard constraint enforced during training that supersedes this linear term in the objective. Therefore, during optimization,
-
- and thus Iq(X,Y) and I(X,Y), agree based on their second order approximation.
- The mutual information engine 112 can connect Iq(X,Y) with predictions from the predictor model using Lagrange multipliers. As an example, let R(x,y): X×Y→[0,1] denote a probability outcome of the predictor model for sample x and outcome y. The below equations model a discrete label case, such as for classification, but a case where labels are continuous can be reduced to the discrete label case through quantization. A quadratic error term E(X,Y) can be defined in terms of R(x, y) and expanded as follows:
-
E(X,Y):=Σx∈XΣy∈Y P X,Y(x,y)((1−R(x,y))2+Σy′∈Y\y R(x,y′)2)=1−2Σx∈XΣy∈Y P X,Y(x,y)R(x,y)+Σx∈XΣy′∈Y P X(x)R(x,y′)2 (7) - The mutual information engine 112 can increase, such as maximize, the quadratic relaxation of MI by decreasing, such as minimizing, the error. For example:
-
E(X,Y)=1−Σy∈Y P Y(y)2 −I q(X,Y) (8) - Lagrange multipliers can be used to solve for the optimal model predictions in terms of PX,Y(x,y) and PX(x), which can be used to express the objective E(X,Y) as a function of Iq(X,Y).
- With respect to feature selection, the mutual information engine 112 can select a given number of features that reduce, e.g., minimize, E(X,Y). For example, given a dataset, I can denote the index set of the dataset samples, J can denote the index set of the features, and L can denote the set of possible labels. Further, S⊂J can denote the index set of features selected, Xi S can denote the random variable representing a selected subset of features for the ith sample. Then, the joint probability can be PX,Y(x,y)=|{i ∈I|Xi S=x,Yi=y}|/|I| and the error can be defined as:
-
E(X,Y):=Σx∈XΣy∈Y P X,Y(x,y)((1−R(x,y))2+Σy≠Yi R(x,y′)2)=Σi∈I((1−R X i S ,Y i))2+Σy≠Yi R(X i S ,y)2 /|I|) (9) - During training, the mutual information engine 112 can reduce, e.g., minimize, error under one or more consistency constraints. As an example, for two samples i1 and i2 that have the same values in the selected features, e.g., Xi
1 S=Xi2 S, their model predictions are the same, e.g., R(Xi1 S ,Y i1 )=R(Xi2 S,Yi2 ). This constraint can be included as a soft consistency regularization term rcs, converting constrained optimization to unconstrained optimization with regularization. For example: -
r cs:=Σ{i1 i2 }∈I2 ,i1 <i2 P(X i1 S =X i2 S)(R(X i1 S ,Y i1 )−R(X i2 S ,Y i2 ))2 (10) - where P(Xi
1 S=Xi2 S) is the probability that the samples Xi1 S and Xi2 S take the same values in the selected feature set S. The learned mask can include probabilities M={pj}j∈J where pj is the probability that a feature j is selected. Then, P(Xi1 S=Xi2 S) can be the product over probabilities that the feature j is not selected if Xi1 S and Xi2 S differ at feature j. For example, -
- In this probabilistic form, the consistency regularization encourages the selection of features with diverse ranges, since it encourages higher pj for the features with many Xi
1 (j)≠Xi2 (j) pairs. Therefore, as an example, the regularized objective to increase, e.g., maximize, the MI between selected features and the labels can be: -
E(X,Y)=Σi∈I((1−R(X i S ,Y i))2+Σy≠Ti R(X i S ,y)2 /|I|)+r cs (11) - where
-
- The mutual information engine 112 can enforce the regularization term batch-wise and can vectorize the regularization term for a parallel computation of Xi
1 (j)≠Xi (j) pairs per batch. When the labels are in a continuous space, the reduction, e g , minimization, objective with the consistency regularization can be derived similarly. For example: -
E(X,Y)=Σi∈I(Y i −R(X i S))2 /|I|+r cs (12) - The sparse
learnable masks system 100 can reduce computational complexity through thenormalization engine 106, temperingengine 108, mask scaling engine 110, and/or mutual information engine 112, resulting in lower processing power and memory usage while still achieving desired results. The sparsemax operation can be dominated by sorting and can have a complexity O(F0 log log F0) per sample, with an overall complexity of O(nF0 log log F0). The consistency regularization rcs in the MI-increasing objective E(X,Y) can have a complexity O(nbFN), as the calculation occurs over the selected feature index set and is done between each sample and other in its batch. The non-regularization component in E(X,Y) has a complexity nc where c is the constant for the number of discrete or binned labels. As an example, with a multi-layer perceptron classifier having a complexity O(nh2), the overall computations have a complexity O(F0 log log F0+nbFN+nc+nh2), such that the dependence on the total number of features is Õ(F0), allowing the sparselearnable masks system 100 to scale to a large number of features. -
FIG. 2 depicts a block diagram of anexample environment 200 for implementing a sparselearnable masks system 218. The sparselearnable masks system 218 can be implemented on one or more devices having one or more processors in one or more locations, such as inserver computing device 202.Client computing device 204 and theserver computing device 202 can be communicatively coupled to one ormore storage devices 206 over anetwork 208. Thestorage devices 206 can be a combination of volatile and non-volatile memory and can be at the same or different physical locations than thecomputing devices storage devices 206 can include any type of non-transitory computer readable medium capable of storing information, such as a hard-drive, solid state drive, tape drive, optical storage, memory card, ROM, RAM, DVD, CD-ROM, write-capable, and read-only memories. - The
server computing device 202 can include one or more processors 210 andmemory 212. Thememory 212 can store information accessible by the processors 210, includinginstructions 214 that can be executed by the processors 210. Thememory 212 can also includedata 216 that can be retrieved, manipulated, or stored by the processors 210. Thememory 212 can be a type of transitory or non-transitory computer readable medium capable of storing information accessible by the processors 210, such as volatile and non-volatile memory. The processors 210 can include one or more central processing units (CPUs), graphic processing units (GPUs), field-programmable gate arrays (FPGAs), and/or application-specific integrated circuits (ASICs), such as tensor processing units (TPUs). - The
instructions 214 can include one or more instructions that, when executed by the processors 210, cause the one or more processors 210 to perform actions defined by theinstructions 214. Theinstructions 214 can be stored in object code format for direct processing by the processors 210, or in other formats including interpretable scripts or collections of independent source code modules that are interpreted on demand or compiled in advance. Theinstructions 214 can include instructions for implementing a sparselearnable masks system 218, which can correspond to the sparselearnable masks system 100 ofFIG. 1 . The sparselearnable masks system 218 can be executed using the processors 210, and/or using other processors remotely located from theserver computing device 202. - The
data 216 can be retrieved, stored, or modified by the processors 210 in accordance with theinstructions 214. Thedata 216 can be stored in computer registers, in a relational or non-relational database as a table having a plurality of different fields and records, or as JSON, YAML, proto, or XML documents. Thedata 216 can also be formatted in a computer-readable format such as, but not limited to, binary values, ASCII, or Unicode. Moreover, thedata 216 can include information sufficient to identify relevant information, such as numbers, descriptive text, proprietary codes, pointers, references to data stored in other memories, including other network locations, or information that is used by a function to calculate relevant data. - The
client computing device 204 can also be configured similarly to theserver computing device 202, with one ormore processors 220,memory 222,instructions 224, anddata 226. Theclient computing device 204 can also include a user input 228 and a user output 230. The user input 228 can include any appropriate mechanism or technique for receiving input from a user, such as keyboard, mouse, mechanical actuators, soft actuators, touchscreens, microphones, and sensors. - The
server computing device 202 can be configured to transmit data to theclient computing device 204, and theclient computing device 204 can be configured to display at least a portion of the received data on a display implemented as part of the user output 230. The user output 230 can also be used for displaying an interface between theclient computing device 204 and theserver computing device 202. The user output 230 can alternatively or additionally include one or more speakers, transducers or other audio outputs, a haptic interface or other tactile feedback that provides non-visual and non-audible information to the platform user of theclient computing device 204. - Although
FIG. 2 illustrates theprocessors 210, 220 and thememories respective computing devices instructions data instructions data processors 210, 220. Similarly, theprocessors 210, 220 can include a collection of processors that can perform concurrent and/or sequential operation. Thecomputing devices computing devices - The
server computing device 202 can be connected over thenetwork 208 to adata center 232 housing any number ofhardware accelerators 234. Thedata center 232 can be one of multiple data centers or other facilities in which various types of computing devices, such as hardware accelerators, are located. Computing resources housed in thedata center 232 can be specified for deploying models with scalable feature selection, as described herein. - The
server computing device 202 can be configured to receive requests to process data from theclient computing device 204 on computing resources in thedata center 232. For example, theenvironment 200 can be part of a computing platform configured to provide a variety of services to users, through various user interfaces and/or application programming interfaces (APIs) exposing the platform services. The variety of services can include medical diagnosis, image classification, speech recognition, price forecasting, and/or fraud detection utilizing the scalable feature selection as described herein. Theclient computing device 204 can transmit input data associated with feature selection, such as covariate input data and target labels. The sparselearnable masks system 218 can receive the input data, and in response, generate output data including a selected predetermined number of features with increased mutual information between the selected features and the labels. - As other examples of potential services provided by a platform implementing the environment, the
server computing device 202 can maintain a variety of models in accordance with different constraints available at thedata center 232. For example, theserver computing device 202 can maintain different families for deploying models on various types of TPUs and/or GPUs housed in thedata center 232 or otherwise available for processing. -
FIG. 3 depicts a block diagram 300 illustrating one or more machinelearning model architectures 302, more specifically 302A-N for each architecture, for deployment in adatacenter 304 housing a hardware accelerator 306 on which the deployedmachine learning models 302 will execute, such as for scalable feature selection as described herein. The hardware accelerator 306 can be any type of processor, such as a CPU, GPU, FPGA, or ASIC such as a TPU. - An
architecture 302 of a machine learning model can refer to characteristics defining the model, such as characteristics of layers for the model, how the layers process input, or how the layers interact with one another. Thearchitecture 302 of the machine learning model can also define types of operations performed within each layer. One or more machinelearning model architectures 302 can be generated that can output results, such as for scalable feature selection.Example model architectures 302 can correspond to a multi-layer perceptron and/or deep tabular data learning. - Referring back to
FIG. 2 , thedevices data center 232 can be capable of direct and indirect communication over thenetwork 208. For example, using a network socket, theclient computing device 204 can connect to a service operating in thedata center 232 through an Internet protocol. Thedevices network 208 can include various configurations and protocols including the Internet, World Wide Web, intranets, virtual private networks, wide area networks, local networks, and private networks using communication protocols proprietary to one or more companies. Thenetwork 208 can support a variety of short- and long-range connections. The short- and long-range connections may be made over different bandwidths, such as 2.402 GHz to 2.480 GHz, commonly associated with the Bluetooth® standard, 2.4 GHz and 5 GHz, commonly associated with the Wi-Fi® communication protocol; or with a variety of communication standards, such as the LTE® standard for wireless broadband communication. Thenetwork 208, in addition or alternatively, can also support wired connections between thedevices data center 232, including over various types of Ethernet connection. - Although a single
server computing device 202,client computing device 204, anddata center 232 are shown inFIG. 2 , it is understood that the aspects of the disclosure can be implemented according to a variety of different configurations and quantities of computing devices, including in paradigms for sequential or parallel processing, or over a distributed network of multiple devices. In some implementations, aspects of the disclosure can be performed on a single device connected to hardware accelerators configured for processing optimization models, and any combination thereof. -
FIG. 4 depicts a flow diagram of anexample process 400 for training a machine learning model using scalable feature selection. Theexample process 400 can be performed on a system of one or more processors in one or more locations, such as the sparselearnable masks system 100 as depicted inFIG. 1 . - As shown in
block 410, the sparselearnable masks system 100 can be configured to receive a plurality of features for training a machine learning model. The plurality of features can be numerical, such as categorical features mapped to embeddings. The plurality of features can be associated with any machine learning task, such as medical diagnosis, image classification, speech recognition, price forecasting, and/or fraud detection. The machine learning model can include any architecture trained using gradient descent, such as a multi-layer perceptron or a deep tabular data learning model. The sparselearnable masks system 100 can further receive a plurality of labels associated with the plurality of features. For example, each of the plurality of labels can denote a target based on one or more of the plurality of features, such as classification labels. - As shown in
block 420, the sparselearnable masks system 100 can be configured to receive a total number of training steps. The total number of training steps can correspond to a number of iterations in training the machine learning model, such as for a particular machine learning task. - As shown in
block 430, the sparselearnable masks system 100 can be configured to initialize a learnable mask vector representing the plurality of features. For example, the learnable mask vector can be initialized with all ones to indicate all of the plurality of features are initially selected. - As shown in
block 440, the sparselearnable masks system 100 can be configured to iteratively perform a training step for the total number of training steps. Performing the training step can include receiving a number of features to be selected for the training step; generating a sparse mask vector from the learnable mask vector; selecting a set of features of the plurality of features based on the sparse mask vector and the number of features to be selected; computing a mutual information based error based on the selected set of features being input into the machine learning model; and updating the learnable mask vector based on the mutual information-based error. - As shown in
block 450, the sparselearnable masks system 100 can be configured to output a final selected set of features, represented by the updated learnable mask vector, to be utilized by the machine learning model. For example, the updated learnable mask vector can have ones indicating selected features and zeros indicating non-selected features. The sparselearnable masks system 100 can further output a trained machine learning model that utilizes the final selected set of features when performing the machine learning task. -
FIG. 5 depicts a flow diagram of anexample process 500 for performing a training step for training the machine learning model using scalable feature selection. Theexample process 500 can be performed on a system of one or more processors in one or more locations, such as the sparselearnable masks system 100 as depicted inFIG. 1 . - As shown in
block 510, the sparselearnable masks system 100 can be configured to receive a number of features to be selected for the training step. The number of features to be selected can be gradually decreased over a total number of training steps until reaching a target number of features to be selected. Gradually decreasing the number of features to be selected can be based on a discrete number of evenly spaced steps. For example, the number of features to be selected can start at 50 features and gradually decrease every 5th training step. The gradual decrease of selected features can be based on a tempering threshold, which can be a fraction of the number of training steps. - As shown in
block 520, the sparselearnable masks system 100 can be configured to generate a sparse mask vector from the learnable mask vector. The sparselearnable masks system 100 can apply a sparsemax normalization to the learnable mask vector. For example, the sparselearnable masks system 100 can return a Euclidean projection of the learnable mask vector onto a probability simplex. The projection can scale values in the learnable mask vector to be equidistributed over [0,1]. - As shown in
block 530, the sparselearnable masks system 100 can be configured to select a set of features of the plurality of features based on the sparse mask vector and the number of features to be selected. The sparselearnable masks system 100 can scale the sparse feature mask to achieve a predetermined number of non-zero values representing a set of features to be selected. For example, the sparselearnable masks system 100 can adjust the projection in the learnable mask vector by multiplying by a positive scalar. Larger positive scalars may increase sparsity while smaller positive scalars may decrease sparsity in the sparse mask vector. - As shown in
block 540, the sparselearnable masks system 100 can be configured to compute a mutual information based error based on the selected set of features being input into the machine learning model. For example, computing the mutual information based error can be based on maximizing mutual information between a distribution of the selected set of features and a distribution of labels for the selected set of features. The mutual information can be conditioned on the probability that a feature is selected based on the sparse feature mask. The sparselearnable masks system 100 can further be configured to compute a training task loss based on the selected set of features being input into the machine learning model, such as by calculating a difference between model predictions and dataset labels. - As shown in
block 550, the sparselearnable masks system 100 can update the learnable mask vector based on the mutual information based error. The sparselearnable masks system 100 can further update the learnable mask vector based on the training task loss. The sparselearnable masks system 100 can further update one or more parameters for the machine learning model based on the mutual information based error and/or the training task loss. Updating the learnable mask vector can be based on an objective of reducing, e.g., minimizing, the mutual information based error and/or training task loss. Updating the learnable mask vector can include removing non-selected features of the plurality of features. For example, the updated learnable mask vector can have ones indicating selected features and zeros indicating non-selected features or floating point numbers to indicate the probability of selecting a feature. - As illustrated in
FIGS. 6-7 , SLM can achieve or improve upon other approaches to feature selection while reducing computational complexity and cost. A similar hyperparameter search space and budget, as well as data splits and preprocessing approaches, were employed for each approach to ensure a fair comparison. The various datasets include the following domains: Mice, MNIST, Fashion-MNIST, Isolet, Coil-20, Activity, Ames, Fraud. Mice refers to protein expression levels measured in the cortex of normal and trisomic mice who had been exposed to different experimental conditions. Each feature is the expression level of one protein. MNIST and Fashion-MNIST refer to 28-by-28 grayscale images of hand-written digits and clothing items, respectively. The images are converted to tabular data by treating each pixel as a separate feature. Isolet refers to preprocessed speech data of people speaking the names of the letters in the English alphabet with each feature being one of the preprocessed quantities, including spectral coefficients and sonorant features. Coil-20 refers to centered grayscale images of 20 objects taken at pose intervals of 5 degrees amounting to 72 images for each object. During preprocessing, the images were resized to produce 20-by-20 images, with each feature being one of the pixels. Activity refers to sensor data collected from a smartphone mounted on subjects while they performed several activities such as walking upstairs, standing and laying, with each being one of the 561 raw or processed quantities from the sensors on the phone. Ames refers to a housing dataset with the goal of predicting residential housing prices based on each features of the home. IEEE-CIS Fraud Detection refers to a dataset with the goal of identifying fraudulent transactions from numerous transaction and identity dependent features. The adversarial nature of the task, the nature of fraudsters adapting themselves and yielding different fraud patterns, cause the data to be highly non i.i.d., thus making feature selection important given that high capacity models can be prone to overfitting and poor generalization. -
FIG. 6 depicts a table comparing accuracy for the sparse learnable masks system to other feature selection approaches over various datasets. The table illustrates selecting 50 features across a wide range of high dimensional datasets, most with >400 features. The table shows that the SLM consistently yields competitive performance, outperforming all other approaches in all cases except on Mice and Ames, for both of which the performance was saturated due to the small numbers of original features, making feature selection less relevant. Most other feature selection approaches are not consistent in their performance while SLM had consistently strong performance. SLM even improved upon a baseline of using all features, which can likely be attributed to superior generalization when the limited model capacity is focused on the most salient features. -
FIG. 7 depicts a table comparing accuracy for the sparse learnable masks system to other feature selection approaches over various numbers of features to be selected. The table focuses on the Fraud dataset and reports performance as a different number of selected features. The table illustrates that SLM outperforms the other approaches, and its performance degradation is smaller with less features. - Further, SLM can also be used for interpretation of global feature importance during inference, yielding the importance ranking of selected features. This can be highly desired in high-stakes applications, such as healthcare or finance, where an importance score can be more useful than simply whether a feature is selected or not. With respect to MI, SLM does not need to sample from the joint or marginal distributions, a potentially computationally intensive process, and does not require a contrastive term in the estimation of MI, resulting in less computational cost. SLM accounts for feature inter-dependence by learning inter-dependent probabilities for the selected feature, where the inter-dependent probabilities jointly maximize the MI between features and labels. Furthermore, SLM learns feature selection and the task objective in an end-to-end manner, which alleviates the selection of repetitive features that may individually be predictive, but less predictive over an individually predictive but redundant feature. SLM can improve generalization, especially for high capacity models like deep neural networks, as they can easily overfit patterns from spurious features that do not hold across training and test data splits. For instance, the table in
FIG. 6 shows that in some cases, especially with SLM, prediction on a subset of features can outperform that on all features. - Aspects of this disclosure can be implemented in digital electronic circuitry, in tangibly embodied computer software or firmware, and/or in computer hardware, such as the structure disclosed herein, their structural equivalents, or combinations thereof. Aspects of this disclosure can further be implemented as one or more computer programs, such as one or more modules of computer program instructions encoded on a tangible non-transitory computer storage medium for execution by, or to control the operation of, one or more data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or combinations thereof. The computer program instructions can be encoded on an artificially generated propagated signal, such as a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus.
- The term “configured” is used herein in connection with systems and computer program components. For a system of one or more computers to be configured to perform particular operations or actions means that the system has installed thereon software, firmware, hardware, or a combination thereof that cause the system to perform the operations or actions. For one or more computer programs to be configured to perform particular operations or actions means that the one or more programs include instructions that, when executed by one or more data processing apparatus, cause the apparatus to perform the operations or actions.
- The term “data processing apparatus” or “data processing system” refers to data processing hardware and encompasses various apparatus, devices, and machines for processing data, including programmable processors, computers, or combinations thereof. The data processing apparatus can include special purpose logic circuitry, such as a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC). The data processing apparatus can include code that creates an execution environment for computer programs, such as code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or combinations thereof.
- The term “computer program” refers to a program, software, a software application, an app, a module, a software module, a script, or code. The computer program can be written in any form of programming language, including compiled, interpreted, declarative, or procedural languages, or combinations thereof. The computer program can be deployed in any form, including as a standalone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. The computer program can correspond to a file in a file system and can be stored in a portion of a file that holds other programs or data, such as one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, such as files that store one or more modules, sub programs, or portions of code. The computer program can be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a data communication network.
- The term “database” refers to any collection of data. The data can be unstructured or structured in any manner The data can be stored on one or more storage devices in one or more locations. For example, an index database can include multiple collections of data, each of which may be organized and accessed differently.
- The term “engine” refers to a software-based system, subsystem, or process that is programmed to perform one or more specific functions. The engine can be implemented as one or more software modules or components or can be installed on one or more computers in one or more locations. A particular engine can have one or more computers dedicated thereto, or multiple engines can be installed and running on the same computer or computers.
- The processes and logic flows described herein can be performed by one or more computers executing one or more computer programs to perform functions by operating on input data and generating output data. The processes and logic flows can also be performed by special purpose logic circuitry, or by a combination of special purpose logic circuitry and one or more computers.
- A computer or special purpose logic circuitry executing the one or more computer programs can include a central processing unit, including general or special purpose microprocessors, for performing or executing instructions and one or more memory devices for storing the instructions and data. The central processing unit can receive instructions and data from the one or more memory devices, such as read only memory, random access memory, or combinations thereof, and can perform or execute the instructions. The computer or special purpose logic circuitry can also include, or be operatively coupled to, one or more storage devices for storing data, such as magnetic, magneto optical disks, or optical disks, for receiving data from or transferring data to. The computer or special purpose logic circuitry can be embedded in another device, such as a mobile phone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS), or a portable storage device, e.g., a universal serial bus (USB) flash drive, as examples.
- Computer readable media suitable for storing the one or more computer programs can include any form of volatile or non-volatile memory, media, or memory devices. Examples include semiconductor memory devices, e.g., EPROM, EEPROM, or flash memory devices, magnetic disks, e.g., internal hard disks or removable disks, magneto optical disks, CD-ROM disks, DVD-ROM disks, or combinations thereof.
- Aspects of the disclosure can be implemented in a computing system that includes a back end component, e.g., as a data server, a middleware component, e.g., an application server, or a front end component, e.g., a client computer having a graphical user interface, a web browser, or an app, or any combination thereof. The components of the system can be interconnected by any form or medium of digital data communication, such as a communication network. Examples of communication networks include a local area network (LAN) and a wide area network (WAN), e.g., the Internet.
- The computing system can include clients and servers. A client and server can be remote from each other and interact through a communication network. The relationship of client and server arises by virtue of the computer programs running on the respective computers and having a client-server relationship to each other. For example, a server can transmit data, e.g., an HTML page, to a client device, e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device. Data generated at the client device, e.g., a result of the user interaction, can be received at the server from the client device.
- Unless otherwise stated, the foregoing alternative examples are not mutually exclusive, but may be implemented in various combinations to achieve unique advantages. As these and other variations and combinations of the features discussed above can be utilized without departing from the subject matter defined by the claims, the foregoing description of the examples should be taken by way of illustration rather than by way of limitation of the subject matter defined by the claims. In addition, the provision of the examples described herein, as well as clauses phrased as “such as,” “including” and the like, should not be interpreted as limiting the subject matter of the claims to the specific examples; rather, the examples are intended to illustrate only one of many possible implementations. Further, the same reference numbers in different drawings can identify the same or similar elements.
Claims (20)
1. A method for training a machine learning model with scalable feature selection, comprising:
receiving, by one or more processors, a plurality of features for training the machine learning model;
initializing, by the one or more processors, a learnable mask vector representing the plurality of features;
receiving, by the one or more processors, a number of features to be selected;
generating, by the one or more processors, a sparse mask vector from the learnable mask vector;
selecting, by the one or more processors, a selected set of features of the plurality of features based on the sparse mask vector and the number of features to be selected;
computing, by the one or more processors, a mutual information based error based on the selected set of features being input into the machine learning model; and
updating, by the one or more processors, the learnable mask vector based on the mutual information based error.
2. The method of claim 1 , further comprising receiving, by the one or more processors, a total number of training steps.
3. The method of claim 2 , wherein the receiving, generating, selecting, computing, and updating is iterative for the total number of training steps.
4. The method of claim 3 , wherein the learnable mask vector updated after the total number of training steps comprises a final selected set of features to be utilized by the machine learning model.
5. The method of claim 1 , wherein training the machine learning model further comprises gradient-descent based learning.
6. The method of claim 1 , further comprising removing non-selected features of the plurality of features.
7. The method of claim 1 , further comprising applying a sparsemax normalization to the learnable mask vector.
8. The method of claim 1 , further comprising decreasing the number of features over a total number of training steps until reaching a target number of features to be selected.
9. The method of claim 8 , wherein gradually decreasing the number of features to be selected is based on a discrete number of evenly spaced steps.
10. The method of claim 1 , wherein selecting the selected set of features further comprises multiplying the sparse vector by a positive scalar based on a predetermined number of features.
11. The method of claim 1 , wherein computing the mutual information based error is based on maximizing mutual information between a distribution of the selected set of features and a distribution of labels for the selected set of features.
12. The method of claim 1 , wherein updating the learnable mask vector is based on minimizing the mutual information based error.
13. A system comprising:
one or more processors; and
one or more storage devices coupled to the one or more processors and storing instructions that, when executed by the one or more processors, cause the one or more processors to perform operations for training a machine learning model with scalable feature selection, the operations comprising:
receiving a plurality of features for training the machine learning model;
initializing a learnable mask vector representing the plurality of features;
receiving a number of features to be selected;
generating a sparse mask vector from the learnable mask vector;
selecting a selected set of features of the plurality of features based on the sparse mask vector and the number of features to be selected;
computing a mutual information based error based on the selected set of features being input into the machine learning model; and
updating the learnable mask vector based on the mutual information based error.
14. The system of claim 13 , wherein:
the operations further comprise receiving a total number of training steps;
the receiving, generating, selecting, computing, and updating is iterative for the total number of training steps; and
the learnable mask vector updated after the total number of training steps comprises a final selected set of features to be utilized by the machine learning model.
15. The system of claim 13 , wherein the operations further comprise removing non-selected features of the plurality of features.
16. The system of claim 13 , wherein the operations further comprise applying a sparsemax normalization to the learnable mask vector.
17. The system of claim 13 , wherein the operations further comprise gradually decreasing the number of features over a total number of training steps until reaching a target number of features to be selected.
18. The system of claim 13 , wherein selecting the selected set of features further comprises multiplying the sparse vector by a positive scalar based on a predetermined number of features.
19. The system of claim 13 , wherein computing the mutual information based error is based on maximizing mutual information between a distribution of the selected set of features and a distribution of labels for the selected set of features.
20. A non-transitory computer readable medium for storing instructions that, when executed by one or more processors, cause the one or more processors to perform operations for training a machine learning model with scalable feature selection, the operations comprising:
receiving a plurality of features for training the machine learning model;
initializing a learnable mask vector representing the plurality of features;
receiving a number of features to be selected;
generating a sparse mask vector from the learnable mask vector;
selecting a selected set of features of the plurality of features based on the sparse mask vector and the number of features to be selected;
computing a mutual information based error based on the selected set of features being input into the machine learning model; and
updating the learnable mask vector based on the mutual information based error.
Priority Applications (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US18/372,900 US20240112084A1 (en) | 2022-09-28 | 2023-09-26 | Scalable Feature Selection Via Sparse Learnable Masks |
PCT/US2023/033924 WO2024072924A2 (en) | 2022-09-28 | 2023-09-28 | Scalable feature selection via sparse learnable masks |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US202263410883P | 2022-09-28 | 2022-09-28 | |
US18/372,900 US20240112084A1 (en) | 2022-09-28 | 2023-09-26 | Scalable Feature Selection Via Sparse Learnable Masks |
Publications (1)
Publication Number | Publication Date |
---|---|
US20240112084A1 true US20240112084A1 (en) | 2024-04-04 |
Family
ID=90470918
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US18/372,900 Pending US20240112084A1 (en) | 2022-09-28 | 2023-09-26 | Scalable Feature Selection Via Sparse Learnable Masks |
Country Status (1)
Country | Link |
---|---|
US (1) | US20240112084A1 (en) |
-
2023
- 2023-09-26 US US18/372,900 patent/US20240112084A1/en active Pending
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11803744B2 (en) | Neural network learning apparatus for deep learning and method thereof | |
Awad et al. | Efficient learning machines: theories, concepts, and applications for engineers and system designers | |
Tatsat et al. | Machine Learning and Data Science Blueprints for Finance | |
Qi et al. | Feature selection and multiple kernel boosting framework based on PSO with mutation mechanism for hyperspectral classification | |
EP3924893A1 (en) | Incremental training of machine learning tools | |
WO2018212710A1 (en) | Predictive analysis methods and systems | |
US11087215B1 (en) | Machine learning classification system | |
US20230102337A1 (en) | Method and apparatus for training recommendation model, computer device, and storage medium | |
US20220230048A1 (en) | Neural Architecture Scaling For Hardware Accelerators | |
US20220215298A1 (en) | Method for training sequence mining model, method for processing sequence data, and device | |
US20200167690A1 (en) | Multi-task Equidistant Embedding | |
US20210357680A1 (en) | Machine learning classification system | |
US20220114481A1 (en) | Systems and methods for counterfactual explanation in machine learning models | |
US20210374132A1 (en) | Diversity and Explainability Parameters for Recommendation Accuracy in Machine Learning Recommendation Systems | |
CN114429170A (en) | Separation maximization technique for comparing anomaly scores of anomaly detection models | |
US20220237890A1 (en) | Method and apparatus with neural network training | |
EP3912042A1 (en) | A deep learning model for learning program embeddings | |
US11100428B2 (en) | Distributable event prediction and machine learning recognition system | |
Yuan et al. | Deep learning from a statistical perspective | |
EP4217928A1 (en) | Neural architecture scaling for hardware accelerators | |
US20220405640A1 (en) | Learning apparatus, classification apparatus, learning method, classification method and program | |
US20240112084A1 (en) | Scalable Feature Selection Via Sparse Learnable Masks | |
US11921821B2 (en) | System and method for labelling data for trigger identification | |
US20230206134A1 (en) | Rank Distillation for Training Supervised Machine Learning Models | |
US20220084306A1 (en) | Method and system of guiding a user on a graphical interface with computer vision |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:ARIK, SERCAN OMER;DONG, YIHE;REEL/FRAME:065029/0899Effective date: 20220929 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |