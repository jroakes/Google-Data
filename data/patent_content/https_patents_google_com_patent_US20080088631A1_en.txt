US20080088631A1 - Multi-mode parallel graphics rendering and display system supporting real-time detection of scene profile indices programmed within pre-profiled scenes of the graphics-based application - Google Patents
Multi-mode parallel graphics rendering and display system supporting real-time detection of scene profile indices programmed within pre-profiled scenes of the graphics-based application Download PDFInfo
- Publication number
- US20080088631A1 US20080088631A1 US11/901,696 US90169607A US2008088631A1 US 20080088631 A1 US20080088631 A1 US 20080088631A1 US 90169607 A US90169607 A US 90169607A US 2008088631 A1 US2008088631 A1 US 2008088631A1
- Authority
- US
- United States
- Prior art keywords
- graphics
- mmpgrs
- mode
- module
- gpu
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Abandoned
Links
- 238000009877 rendering Methods 0.000 title claims abstract description 250
- 230000008093 supporting effect Effects 0.000 title claims abstract description 83
- 238000011897 real-time detection Methods 0.000 title claims abstract description 8
- 238000000034 method Methods 0.000 claims abstract description 174
- 238000012545 processing Methods 0.000 claims abstract description 122
- 230000008569 process Effects 0.000 claims abstract description 103
- 238000000354 decomposition reaction Methods 0.000 claims description 287
- 239000000872 buffer Substances 0.000 claims description 93
- 238000011068 loading method Methods 0.000 claims description 3
- 238000001914 filtration Methods 0.000 claims description 2
- 238000012546 transfer Methods 0.000 description 89
- 230000007704 transition Effects 0.000 description 39
- 238000004458 analytical method Methods 0.000 description 38
- 238000001514 detection method Methods 0.000 description 37
- 230000006870 function Effects 0.000 description 36
- 230000003993 interaction Effects 0.000 description 34
- 238000007726 management method Methods 0.000 description 26
- 230000004927 fusion Effects 0.000 description 24
- 239000012634 fragment Substances 0.000 description 22
- 230000002452 interceptive effect Effects 0.000 description 20
- 238000012360 testing method Methods 0.000 description 19
- 238000004806 packaging method and process Methods 0.000 description 18
- 230000006854 communication Effects 0.000 description 12
- 230000000903 blocking effect Effects 0.000 description 10
- 238000004422 calculation algorithm Methods 0.000 description 10
- 238000004891 communication Methods 0.000 description 10
- 230000009977 dual effect Effects 0.000 description 10
- 239000004065 semiconductor Substances 0.000 description 10
- 238000013461 design Methods 0.000 description 9
- 230000000694 effects Effects 0.000 description 9
- XUIMIQQOPSSXEZ-UHFFFAOYSA-N Silicon Chemical compound [Si] XUIMIQQOPSSXEZ-UHFFFAOYSA-N 0.000 description 8
- 230000008901 benefit Effects 0.000 description 8
- 239000000203 mixture Substances 0.000 description 8
- 229910052710 silicon Inorganic materials 0.000 description 8
- 239000010703 silicon Substances 0.000 description 8
- 238000013459 approach Methods 0.000 description 7
- 230000003449 preventive effect Effects 0.000 description 7
- 230000003044 adaptive effect Effects 0.000 description 6
- 230000008859 change Effects 0.000 description 5
- 238000010586 diagram Methods 0.000 description 5
- 230000007246 mechanism Effects 0.000 description 5
- 239000004606 Fillers/Extenders Substances 0.000 description 4
- 238000005516 engineering process Methods 0.000 description 4
- 230000001976 improved effect Effects 0.000 description 4
- 238000012544 monitoring process Methods 0.000 description 4
- 230000000737 periodic effect Effects 0.000 description 4
- 230000004044 response Effects 0.000 description 4
- 238000003491 array Methods 0.000 description 3
- 230000006399 behavior Effects 0.000 description 3
- 230000003542 behavioural effect Effects 0.000 description 3
- 238000004364 calculation method Methods 0.000 description 3
- 230000004424 eye movement Effects 0.000 description 3
- 239000000463 material Substances 0.000 description 3
- 230000004048 modification Effects 0.000 description 3
- 238000012986 modification Methods 0.000 description 3
- 238000005192 partition Methods 0.000 description 3
- 238000004088 simulation Methods 0.000 description 3
- 238000011144 upstream manufacturing Methods 0.000 description 3
- 241000577979 Peromyscus spicilegus Species 0.000 description 2
- 101100116390 Schizosaccharomyces pombe (strain 972 / ATCC 24843) ded1 gene Proteins 0.000 description 2
- 238000010521 absorption reaction Methods 0.000 description 2
- 230000002776 aggregation Effects 0.000 description 2
- 238000004220 aggregation Methods 0.000 description 2
- 238000000149 argon plasma sintering Methods 0.000 description 2
- 239000003086 colorant Substances 0.000 description 2
- 238000010276 construction Methods 0.000 description 2
- 238000011156 evaluation Methods 0.000 description 2
- 230000004886 head movement Effects 0.000 description 2
- 230000006872 improvement Effects 0.000 description 2
- 230000000977 initiatory effect Effects 0.000 description 2
- 230000010354 integration Effects 0.000 description 2
- 239000011159 matrix material Substances 0.000 description 2
- 238000002156 mixing Methods 0.000 description 2
- 230000009466 transformation Effects 0.000 description 2
- 238000000844 transformation Methods 0.000 description 2
- 206010021403 Illusion Diseases 0.000 description 1
- 230000003466 anti-cipated effect Effects 0.000 description 1
- 230000009286 beneficial effect Effects 0.000 description 1
- 230000003139 buffering effect Effects 0.000 description 1
- 238000006243 chemical reaction Methods 0.000 description 1
- 239000002131 composite material Substances 0.000 description 1
- 238000013500 data storage Methods 0.000 description 1
- 230000001419 dependent effect Effects 0.000 description 1
- 238000011161 development Methods 0.000 description 1
- 230000008030 elimination Effects 0.000 description 1
- 238000003379 elimination reaction Methods 0.000 description 1
- 238000011010 flushing procedure Methods 0.000 description 1
- 230000008570 general process Effects 0.000 description 1
- 238000005286 illumination Methods 0.000 description 1
- 238000009434 installation Methods 0.000 description 1
- 238000007620 mathematical function Methods 0.000 description 1
- 230000000116 mitigating effect Effects 0.000 description 1
- 238000003032 molecular docking Methods 0.000 description 1
- 238000011160 research Methods 0.000 description 1
- 238000005070 sampling Methods 0.000 description 1
- 239000002210 silicon-based material Substances 0.000 description 1
- 230000008961 swelling Effects 0.000 description 1
- 230000001360 synchronised effect Effects 0.000 description 1
- 230000008685 targeting Effects 0.000 description 1
- 230000002123 temporal effect Effects 0.000 description 1
- 230000007723 transport mechanism Effects 0.000 description 1
- 230000001960 triggered effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T1/00—General purpose image data processing
- G06T1/20—Processor architectures; Processor configuration, e.g. pipelining
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/50—Allocation of resources, e.g. of the central processing unit [CPU]
- G06F9/5005—Allocation of resources, e.g. of the central processing unit [CPU] to service a request
- G06F9/5027—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resource being a machine, e.g. CPUs, Servers, Terminals
- G06F9/5044—Allocation of resources, e.g. of the central processing unit [CPU] to service a request the resource being a machine, e.g. CPUs, Servers, Terminals considering hardware capabilities
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T15/00—3D [Three Dimensional] image rendering
- G06T15/005—General purpose rendering architectures
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2209/00—Indexing scheme relating to G06F9/00
- G06F2209/50—Indexing scheme relating to G06F9/50
- G06F2209/501—Performance criteria
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T2210/00—Indexing scheme for image generation or computer graphics
- G06T2210/52—Parallel processing
Definitions
- the present invention relates generally to the field of computer graphics rendering, and more particularly, ways of and means for improving the performance of parallel graphics rendering processes supported on multiple 3D graphics processing pipeline (GPPL) platforms associated with diverse types of computing machinery, including, but not limited, to PC-level computers, game console systems, graphics-supporting application servers, and the like.
- GPPL 3D graphics processing pipeline
- Object-Oriented Graphics Systems wherein 3D scenes are represented as a complex of geometric objects (primitives) in 3D continuous geometric space, and 2D views or images of such 3D scenes are computed using geometrical projection, ray tracing, and light scattering/reflection/absorption modeling techniques, typically based upon laws of physics; and (2) VOlume ELement (VOXEL) Graphics Systems, wherein 3D scenes and objects are represented as a complex of voxels (x,y,z volume elements) represented in 3D Cartesian Space, and 2D views or images of such 3D voxel-based scenes are also computed using geometrical projection, ray tracing, and light scattering/reflection/absorption modeling techniques, again typically based upon laws of physics.
- VOXEL VOlume ELement
- 3D geometrical models In such graphics system design, “objects” within a 3D scene are represented by 3D geometrical models, and these geometrical models are typically constructed from continuous-type 3D geometric representations including, for example, 3D straight line segments, planar polygons, polyhedra, cubic polynomial curves, surfaces, volumes, circles, and quadratic objects such as spheres, cones, and cylinders (i.e. geometrical data and commands). These 3D geometrical representations are used to model various parts of the 3D scene or object, and are expressed in the form of mathematical functions evaluated over particular values of coordinates in continuous Cartesian space.
- the 3D geometrical representations of the 3D geometric model are stored in the format of a graphical display list (i.e. a structured collection of 2D and 3D geometric primitives).
- planar polygons mathematically described by a set of vertices, are the most popular form of 3D geometric representation.
- the 3D scene is graphically displayed (as a 2D view of the 3D geometrical model) along a particular viewing direction, by repeatedly scan-converting the stream of graphics commands and data (GCAD).
- the scan-conversion process can be viewed as a “computational geometry” process which involves the use of (i) a geometry processor (i.e. geometry processing subsystem or engine) as well as a pixel processor (i.e. pixel processing subsystem or engine) which together transform (i.e. project, shade and color) the graphics objects and bit-mapped textures, respectively, into an unstructured matrix of pixels.
- the composed set of pixel data is stored within a 2D frame buffer (i.e. Z buffer) before being transmitted to and displayed on the surface of a display screen.
- a video processor/engine refreshes the display screen using the pixel data stored in the 2D frame buffer.
- a typical PC based graphic architecture has an external graphics card 105 comprising a graphics processing unit (GPU) and video memory.
- the graphic card is connected to the display 106 on one side, and the CPU 101 through bus (e.g. PCI-Express) 107 and Memory Bridge 103 (termed also “chipset”, e.g. 975 by Intel), on the other side.
- bus e.g. PCI-Express
- Memory Bridge 103 Termed also “chipset”, e.g. 975 by Intel
- the host CPU program/memory space stores the graphics applications, the standard graphics library, and the vendor's GPU drivers.
- a typical prior art PC-based computing system employs a conventional graphics architecture employing a North memory bridge with an integrated graphics device (IGD) 103 .
- the IGD supports a single graphics pipeline process, and is operably coupled to a South bridge, via a PCI-express bus, for supporting the input/output ports of the system.
- the IGD includes a video engine, a 2D engine, a 3D engine, and a display engine.
- a prior art PC-based computing system employs a conventional Fusion-type CPU/GPU hybrid architecture, wherein a single GPU implemented on the same die as the CPU is used to support a graphics pipeline that drives an external display device.
- the motherboard supports the processor die, memory, a bridge with a display interface for connecting to a display device 106 , and a PCI-express bus.
- the processor die supports a CPU 1241 , a GPU 1242 , L2 cache, buffers, an Interconnect (e.g. crossbar switch), a hyper transport mechanism and a memory controller.
- Interconnect e.g. crossbar switch
- the process of rendering three successive frames by a single GPU is graphically illustrated. Notably, this graphical rendering process may be supported using any of the single GPU-based computing systems described above.
- the application assisted by the graphics library, creates a stream of graphics commands and data describing a 3D scene. The stream is then pipelined through the GPU's geometry and pixel subsystems so as to create a bitmap of pixels in the Frame Buffer, and finally a rendered image of the scene is displayed on a display screen.
- the generation of a sequence of successive frames produces a visual illusion of a dynamic picture.
- the structure of a GPU subsystem 124 on a graphics card or in an IGD comprises: a video memory which is external to GPU, and two 3D engines: (i) a transform bound geometry subsystem 224 for processing 3D graphics primitives; (ii) and a fill bound pixel subsystem 225 .
- the video memory shares its storage resources among geometry buffer 222 through which all geometric (i.e. polygonal) data is transferred, commands buffer, texture buffers 223 , and Frame Buffer 226 .
- the first potential bottleneck 221 stems from transferring data from CPU to GPU.
- Two other bottlenecks are video memory related: geometry data memory limits 222 , and texture data memory limits 223 .
- transform bound 224 in the geometry subsystem and fragment rendering 225 in pixel subsystem. These bottlenecks determine overall throughput. In general, the bottlenecks vary over the course of a graphics application.
- FIG. 2A there is shown an advanced chipset (e.g. Bearlake by Intel) having two buses 107 , 108 instead of one, and allowing the interconnection of two external graphics cards in parallel: primary card 105 and secondary card 104 , to share the computation load associated with the 3D graphics rendering process.
- the display 106 is attached to the primary card 105 . It is anticipated that even more advanced commercial chipsets with greater than two buses will appear in the future, allowing the interconnection of more than two graphic cards.
- the general software architecture of prior art graphic system 200 comprises: the graphics application 201 , standard graphics library 202 , and the vendor's GPU drivers ( 203 ).
- This graphic software environment resides in the “program space” of main memory 102 on the host computer system.
- the graphic application 201 runs in the program space (i.e. memory space), building up the 3D scene, typically as a data base of polygons, where each polygon is represented as a set of vertices. The vertices and others components of these polygons are transferred to the graphic card(s) for rendering, and displayed as a 2D image, on the display screen.
- FIG. 2C the structure of a GPU subsystem on the graphics card is shown comprising: a video memory disposed external to the GPU, and two 3D engines: (i) a transform bound geometry subsystem 224 for processing 3D graphics primitives; and (ii) a fill bound pixel subsystem 225 .
- the video memory shares its storage resources among geometry buffer 222 , through which all geometric (i.e. polygonal) data is transferred to the commands buffer, texture buffers 223 , and Frame Buffer FB 226 .
- the division of graphics data among GPUs reduces (i) the bottleneck 222 posed by the video memory footprint at each GPU, (ii) the transform bound processing bottleneck 224 , and (iii) the fill bound processing bottleneck 225 .
- FIGS. 2A through 2C there is a need to distribute the computational workload associated with interactive parallel graphics rendering processes.
- two different kind of parallel rendering methods have been applied to PC-based dual GPU graphics systems of the kind illustrated in FIGS. 2A through 2C , namely: the Time Division Method of Parallel Graphics Rendering illustrated in FIG. 2D ; and the Image Division Method of Parallel Graphics Rendering illustrated in FIG. 2E .
- Object Division Method a third type of method of parallel graphics rendering, referred to as the Object Division Method, has been developed over the years and practiced exclusively on complex computing platforms requiring complex and expensive hardware platforms for compositing the pixel output of the multiple graphics processing pipelines (GPPLs).
- the Object Division Method illustrated in FIG. 3A , can be found applied on conventional graphics platforms of the kind shown in FIG. 3 , as well as on specialized graphics computing platforms as described in US Patent Application Publication No. US 2002/0015055, assigned to Silicon Graphics, Inc. (SGI), published on Feb. 7, 2002, and incorporated herein by reference.
- the parallel graphics platform uses the multiple sets of pixel data generated by each graphics pipeline to synthesize (or compose) a final set of pixels that are representative of the 3D scene (taken along the specified viewing direction), and this final set of pixel data is then stored in a frame buffer (FB); and
- the Image Division (Sort-First) Method of Parallel Graphics Rendering distributes all graphics display list data and commands to each of the graphics pipelines, and decomposes the final view (i.e. projected 2D image) in Screen Space, so that, each graphical contributor (e.g. graphics pipeline and GPU) renders a 2D tile of the final view.
- This mode has a limited scalability due to the parallel overhead caused by objects rendered on multiple tiles.
- the Split Frame Rendering mode divides up the screen among GPUs by continuous segments. e.g. two GPUs each one handles about one half of the screen. The exact division may change dynamically due to changing load across the screen image. This method is used in nVidia's SLITM multiple-GPU graphics product.
- Tiled Frame Rendering mode divides up the image into small tiles. Each GPU is assigned tiles that are spread out across the screen, contributing to good load balancing. This method is implemented by ATI's CrossfireTM multiple GPU graphics card solution.
- the entire database is broadcast to each GPU for geometric processing.
- the processing load at each Pixel Subsystem is reduced to about 1/N. This way of parallelism relieves the fill bound bottleneck 225 .
- the image division method ideally suits graphics applications requiring intensive pixel processing.
- the Time Division (DPlex) Method of Parallel Graphics Rendering distributes all display list graphics data and commands associated with a first scene to the first graphics pipeline, and all graphics display list data and commands associated with a second/subsequent scene to the second graphics pipeline, so that each graphics pipeline (and its individual rendering node or GPU) handles the processing of a full, alternating image frame.
- each graphics pipeline and its individual rendering node or GPU
- Each GPU is give extra time of N time frames (for N parallel GPUs) to process a frame.
- the released bottlenecks are those of transform bound 224 at geometry subsystem, and fill bound 225 at pixel subsystem.
- each GPU must access all of the data. This requires either maintaining multiple copies of large data sets or creating possible access conflicts to the source copy at the host swelling up the video memory bottlenecks 222 , 223 and data transfer bottleneck 221 .
- the Object Division (Sort-Last) Method of Parallel Graphics Rendering decomposes the 3D scene (i.e. rendered database) and distributes graphics display list data and commands associated with a portion of the scene to the particular graphics pipeline (i.e. rendering unit), and recombines the partially rendered pixel frames, during recomposition.
- the geometric database is therefore shared among GPUs, reducing the load on the geometry buffer, the geometry subsystem, and even to some extent, the pixel subsystem.
- the main concern is how to divide the data in order to keep load balance.
- An exemplary multiple-GPU platform of FIG. 3B for supporting the object-division method is shown in FIG. 3A .
- the platform requires complex and costly pixel compositing hardware which prevents its current application in a modern PC-based computer architecture.
- a given graphics processing pipeline along a parallel graphics rendering system is only as strong as the weakest link of it stages, and thus a single bottleneck determines the overall throughput along the graphics pipelines, resulting in unstable frame-rate, poor scalability, and poor performance.
- a primary object of the present invention is to provide a new and improved method of and apparatus for practicing parallel 3D graphics rendering processes in modern multiple-GPU based computer graphics systems, while avoiding the shortcomings and drawbacks associated with prior art apparatus and methodologies.
- Another object of the present invention is to provide a novel multi-mode parallel graphics rendering system (MMPGRS) embodied within a host computing system having (i) host memory space (HMS) for storing one or more graphics-based applications and a graphics library for generating graphics commands and data (GCAD) during the run-time (i.e. execution) of the graphics-based application, (ii) one or more CPUs for executing said graphics-based applications, and (iii) a display device for displaying images containing graphics during the execution of said graphics-based applications.
- HMS host memory space
- GCAD graphics commands and data
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system comprising: a multi-mode parallel graphics rendering subsystem supporting multiple modes of parallel operation selected from the group consisting of object division, image division, and time division; a plurality of graphic processing pipelines (GPPLs) supporting a parallel graphics rendering process that employs one of the object division, image division and/or time division modes of parallel operation in order to execute graphic commands and process graphics data (GCAD) render pixel-composited images containing graphics for display on a display device during the run-time of the graphics-based application; and an automatic mode control module (AMCM) for automatically controlling the mode of parallel operation during the run-time of the graphics-based application.
- GPPLs graphic processing pipelines
- AMCM automatic mode control module
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein the automatic mode control module employs the profiling of scenes in said graphics-based application.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein the automatic mode control module employs the profiling of scenes in the graphics-based application, on an image frame by image frame basis.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein the profiling of scenes in the graphics-based application, is carried out in real-time, during run-time of the graphics-based application, on an image frame by image frame basis.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein said real-time profiling of scenes in the graphics-based application involves (i) collecting and analyzing performance data associated with the MMPGRS and the host computing system, during application run-time, (ii) constructing scene profiles for the image frames associated with particular scenes in the particular graphics-based application, and (iii) maintaining the scene profiles in a application/scene profile database that is accessible to the automatic mode control module during run-time, so that during the run-time of the graphics-based application, the automatic mode control module can access and use the scene profiles maintained in the application/scene profile database and determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein the automatic mode control module employs real-time detection of scene profile indices directly programmed within pre-profiled scenes of the graphics-based application; wherein the pre-profiled scenes are analyzed prior to run-time, and indexed with the scene profile indices; and wherein and mode control parameters (MCPs) corresponding to the scene profile indices, are stored within an application/scene profile database accessible to the automatic mode control module during application run-time.
- MCPs mode control parameters
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein during run-time, the automatic mode control module automatically detects the scene profile indices and uses the detected said scene profile indices to access corresponding MCPs from the application/scene profile database so as to determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein the automatic mode control module employs real-time detection of mode control commands (MCCs) directly programmed within pre-profiled scenes of the graphics-based application; wherein the pre-profiled scenes are analyzed prior to run-time, and the MCCs are directly programmed within the individual image frames of each scene; and wherein during run-time, the automatic mode control module automatically detects the MCCs along the graphics command and data stream, and uses the MCCs so as to determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance.
- MCCs mode control commands
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein the automatic mode control module employs a user interaction detection (UID) mechanism for real-time detection of the user's interaction with the host computing system.
- UID user interaction detection
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein, in conjunction with scene profiling, the automatic mode control module also uses said UID mechanism to determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance, at any instance in time during run-time of the graphics-based application.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system (MMPGRS), having multiple graphics processing pipelines (GPPLs) with multiple GPUs supporting a parallel graphics rendering process having time, frame and object division modes of operation, wherein each GPPL comprises video memory and a GPU having a geometry processing subsystem and a pixel processing subsystem, and wherein 3D scene profiling is performed in real-time, and the parallelization state/mode of the system is dynamically controlled to meet graphics application requirements.
- MMPGRS multi-mode parallel graphics rendering system
- Another object of the present invention is to provide a multi-mode parallel graphics rendering and display system having multiple graphics processing pipelines (GPPLs), each having a GPU and video memory, and supporting multiple modes of parallel graphics rendering using real-time graphics application profiling and automatic configuration of the multiple graphics processing pipelines supporting multiple modes of parallel graphics rendering, including a time-division mode, a frame-division mode, and an object-division mode of parallel operation.
- GPPLs graphics processing pipelines
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, which is capable of dynamically handling bottlenecks that are automatically detected during any particular graphics application running on the host computing system.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system, wherein different parallelization schemes are employed to reduce pipeline bottlenecks, and increase graphics performance.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system, wherein image, time and object division methods of parallelization are implemented on the same parallel graphics platform.
- Another object of the present invention is to provide a method of multi-mode parallel graphics rendering that can be practiced on a multiple GPU-based PC-level graphics system, and which, during application run-time, dynamically alternates among Time, Frame/Image and Object division modes of parallel operation, adapting the optimal method of parallel operation to the real time needs of the graphics application.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system, which is capable of supervising the performance level of a graphic application by dynamically adapting different parallelization schemes to solve instantaneous bottlenecks along the graphic pipelines thereof.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system, having run-time configuration flexibility for various parallel schemes to achieve the best system performance.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system having architectural flexibility and real-time profiling and control capabilities which enable utilization of different modes of parallel operation for high and steady performance along the application running on the associated host system.
- Another object of the present invention is to provide a novel method of multi-mode parallel graphics rendering on a multiple GPU-based graphics system, which achieves improved system performance by using adaptive parallelization of multiple graphics processing units (GPUs), on conventional and non-conventional platform architectures, as well as on monolithic platforms, such as multiple GPU chips or integrated graphic devices (IGD).
- GPUs graphics processing units
- IGD integrated graphic devices
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, wherein bottlenecks are dynamically handled.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system, wherein stable performance is maintained throughout course of a graphics application.
- Another object of the present invention to provide a multi-mode parallel graphics rendering system supporting software-based adaptive graphics parallelism for the best performance, seamlessly to the graphics application, and compliant with graphic standards (e.g. OpenGL and Direct3D).
- graphic standards e.g. OpenGL and Direct3D
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, wherein all parallel modes are implemented in a single architecture.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, wherein the architecture is flexible, supporting fast inter-mode transitions.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system which is adaptive to changing to meet the needs of any graphics application during the course of its operation.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system which employs a user interaction detection (UID) subsystem for enabling the automatic and dynamic detection of the user's interaction with the host computing system.
- UID user interaction detection
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system, continuously processes user-system interaction data, and automatically detects user-system interactivity (e.g. mouse click, keyboard depression, eye-movement, etc).
- user-system interactivity e.g. mouse click, keyboard depression, eye-movement, etc.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system the system, wherein absent preventive conditions (such as CPU bottlenecks and need for the same FB in successive frames), the user interaction detection (UID) subsystem enables timely implementation of the Time Division Mode only when no user-system interactivity is detected so that system performance is automatically optimized.
- absent preventive conditions such as CPU bottlenecks and need for the same FB in successive frames
- the user interaction detection (UID) subsystem enables timely implementation of the Time Division Mode only when no user-system interactivity is detected so that system performance is automatically optimized.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be implemented using a software implementation of present invention.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be realized using a hardware implementation.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, can be realized as chip implementation.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be realized as an integrated monolithic implementation.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be implemented using IGD technology.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, characterized by run-time configuration flexibility for various parallel schemes to achieve the best parallel performance.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system that operates seamlessly to the application and is compliant with graphic standards (e.g. OpenGL and Direct3D).
- graphic standards e.g. OpenGL and Direct3D
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be implemented on conventional multi-GPU platforms replacing image division or time division parallelism.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which enables the multiple GPU platform vendors to incorporate the solution in their systems supporting only image division and time division modes of operation.
- Another object of the present invention is to provide such multiple GPU-based graphics system, which enables implementation using low cost multi-GPU cards.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system implemented using IGD technology, and wherein it is impossible for the IGD to get disconnected by the BIOS when an external graphics card is connected and operating.
- Another object of the present invention is to provide a multiple GPU-based graphics system, wherein a new method of dynamically controlled parallelism improves the system's efficiency and performance.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be implemented using an IGD supporting more than one external GPU.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be implemented using an IGD-based chipset having two or more IGDs.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which employs a user interaction detection (UID) subsystem that enables automatic and dynamic detection of the user's interaction with the system, so that absent preventive conditions (such as CPU bottlenecks and need for the same FB in successive frames), this subsystem enables timely implementation of the Time Division Mode only when no user-system interactivity is detected, thereby achieving the highest performance mode of parallel graphics rendering at runtime, and automatically optimizing the graphics performance of the host computing system.
- UID user interaction detection
- Another object of the present invention is to provide a parallel graphics rendering system employing multiple graphics processing pipelines supporting the object division mode of parallel graphics rendering using pixel processing resources provided therewithin.
- Another object of the present invention is to provide a parallel graphics rendering system for carrying out the object division method of parallel graphics rendering on multiple GPU-based graphics platforms associated with diverse types of computing machinery.
- Another object of the present invention is to provide a novel method having multiple graphics processing pipelines (GPPLs) with multiple GPUs or CPU-cores supporting a parallel graphics rendering process having an object division mode of operation, wherein each GPPL includes video memory, a geometry processing subsystem, and a pixel processing subsystem, wherein pixel (color and z depth) data buffered in the video memory of each GPPL is communicated to the video memory of a primary GPPL, and wherein the video memory and the pixel processing subsystem in the primary GPPL are used to carry out the image recomposition phase of the object division mode of parallel graphics rendering process.
- GPPLs graphics processing pipelines
- each GPPL includes video memory, a geometry processing subsystem, and a pixel processing subsystem, wherein pixel (color and z depth) data buffered in the video memory of each GPPL is communicated to the video memory of a primary GPPL, and wherein the video memory and the pixel processing subsystem in the primary GPPL are used to carry out
- Another object of the present invention is to provide a parallel graphics rendering system having multiple graphics processing pipelines (GPPLs) with multiple GPUs or CPU-cores supporting a parallel graphics rendering process having an object division mode of operation, wherein each GPU comprises video memory, a geometry processing subsystem and a pixel processing subsystem, wherein pixel (color and z depth) data buffered in the video memory of each GPPL is communicated to the video memory of a primary GPPL, and wherein the video memory and the pixel processing subsystem in the primary GPPL are used to carry out the image recomposition phase of the object division mode of the parallel graphics rendering process.
- GPPLs graphics processing pipelines
- each GPU comprises video memory, a geometry processing subsystem and a pixel processing subsystem, wherein pixel (color and z depth) data buffered in the video memory of each GPPL is communicated to the video memory of a primary GPPL, and wherein the video memory and the pixel processing subsystem in the primary GPPL are used to carry out the image
- Another object of the present invention is to provide a parallel graphics rendering system having multiple graphics processing pipelines (GPPLs) with multiple GPUs supporting a parallel graphics rendering process having an object division mode of operation, wherein each GPU comprises video memory, a geometry processing subsystem and a pixel processing subsystem, wherein pixel (color and z depth) data buffered in the video memory of each GPU is communicated to the video memory of a primary GPU, and wherein the video memory and both the geometry and pixel processing subsystems in the primary GPU are used to carry out the image recomposition phase of the object division mode of parallel graphics rendering process.
- GPPLs graphics processing pipelines
- Another object of the present invention is to provide a parallel rendering graphics system having multiple graphics processing pipelines (GPPLs) with multiple GPUs supporting a parallel graphics rendering process having an object division mode of operation, wherein the video memory of each GPPL includes texture memory and a pixel frame buffer, wherein the geometry processing subsystem includes a vertex shading unit, wherein the pixel processing subsystem includes a fragment/pixel shading unit, wherein pixel (color and z depth) data buffered in the video memory of each GPPL is communicated to the video memory of a primary GPPL, and wherein the texture memory and the fragment/pixel shading unit are used to carry out the image recomposition phase of the object division mode of the parallel graphics rendering process.
- GPPLs graphics processing pipelines
- Another object of the present invention is to provide a parallel graphics rendering system having multiple graphics processing pipelines (GPPLs) with multiple GPUs supporting a parallel graphics rendering process having an object division mode of operation, wherein the video memory of each GPPL includes texture memory and a pixel frame buffer, wherein the geometry processing subsystem includes a vertex shading unit, wherein the pixel processing subsystem includes a fragment/pixel shading unit, wherein pixel (color and z depth) data buffered in the video memory of each GPPL is communicated to the video memory of a primary GPPL, and wherein the texture memory and the vertex shading unit are used to carry out the image recomposition phase of the object division mode of the parallel graphics rendering process.
- GPPLs graphics processing pipelines
- Another object of the present invention is to provide a parallel graphics rendering system having multiple graphics processing pipelines (GPPLs) with multiple GPUs supporting a parallel graphics rendering process having an object division mode of operation, which does not require compositing in main, shared or distributed memory of the host computing system (e.g. involving the movement of pixel data from the frame buffers or FBs to main memory, processing the pixel data in the CPU of the host for composition, and moving the result out to the primary GPPL for display) thereby avoiding the use of expensive procedure and resources of the system (e.g. buses, caches, memory, and CPU bandwidth).
- GPPLs graphics processing pipelines
- Another object of the present invention is to provide a novel method of operating a parallel graphics rendering system having multiple graphics processing pipelines (GPPLs) with multiple GPUs supporting a parallel graphics rendering process having an object division mode of operation, wherein implementation of the pixel composition phase of the parallel graphics rendering process is carried out using the computational resources within the GPUs, thereby avoiding the need for dedicated or specialized pixel image compositing hardware and/or software based apparatus.
- GPPLs graphics processing pipelines
- Another object of the present invention is to provide a novel method of object division parallel graphics rendering carried out on a multi-mode parallel graphics rendering system (MMPGRS) or platform supporting multiple graphical processing pipelines (GPPLs) with multiple graphical processing units (GPUs), wherein the recomposition stage of the rendering process is carried out using computational resources (e.g. video memory and the geometry and/or pixel processing subsystems/engines) supplied by the GPPLs employed on the MMPGRS platform.
- computational resources e.g. video memory and the geometry and/or pixel processing subsystems/engines
- Another object of the present invention is to provide a novel method of object division parallel rendering of pixel-composited images for graphics-based applications running on a host computing system embodying a multi-mode parallel graphics rendering system or platform (MMPGRS), wherein the movement and merging of composited pixel data occurs during the recomposition stage of the parallel graphics rendering process in a manner that is transparent to the graphics-based application.
- MMPGRS multi-mode parallel graphics rendering system or platform
- Another object of the present invention is to provide a novel parallel rendering graphics system having multiple graphics processing pipelines (GPPLs) supporting a parallel graphics rendering process having an object division mode of operation, wherein each GPPL comprises video memory, a geometry processing subsystem and a pixel processing subsystem, wherein pixel (color and z depth) data buffered in the video memory of each GPPL is communicated (via an inter-GPPL communication process) to the video memory of a primary GPPL, and wherein the video memory and the geometry and/or pixel processing subsystems in the primary GPPL are used to carry out the image recomposition phase of the object division mode of the parallel graphics rendering process.
- GPPLs graphics processing pipelines
- Another object of the present invention is to provide a novel parallel graphics rendering system supporting multiple modes of parallel operation during graphical rendering, which allows users to enjoy sharp videos and photos, smooth video playback, astonishing effects, and vibrant colors, as well as texture-rich 3D performance in next-generation games.
- Another object of the present invention is to provide a novel multi-user computer network supporting a plurality of client machines, wherein each client machine employs the MMPGRS of the present invention based on a software architecture and responds to user-interaction input data streams from one or more network users who might be local to each other as over a LAN, or be remote to each other, as when operating over a WAN or the Internet infrastructure.
- Another object of the present invention is to provide a novel multi-user computer network supporting a plurality of client machines, wherein each client machine employs the MMPGRS of the present invention based on a hardware architecture and responds to user-interaction input data streams from one or more network users who might be local to each other as over a LAN, or be remote to each other, as when operating over a WAN or the Internet infrastructure.
- Another object of the present invention is to provide an Internet-based central application profile database server system for automatically updating, over the Internet, graphic application profiles (GAPs) within the MMPGRS of client machines.
- GAPs graphic application profiles
- Another object of the present invention is to provide such Internet-based Central Application Profile Database Server System which ensures that each MMPGRS is optimally programmed at all possible times so that it quickly and continuously offers users high graphics performance through its adaptive multi-modal parallel graphics operation.
- Another object of the present invention is to provide such an Internet-based Central Application Profile Database Server System which supports a Web-based Game Application Registration and Profile Management Application, that provides a number of Web-based services, including:
- Another object of the present invention is to provide such an Internet-based Central Application Profile Database Server System that enables the MMGPRS of registered client computing machines to automatically and periodically upload, over the Internet, Graphic Application Profiles (GAPs) for storage and use within the Application/Scene Profile Database of the MMPGRS.
- GAPs Graphic Application Profiles
- Another object of the present invention is to provide such an Internet-based Central Application Profile Database Server System which, by enabling the automatic uploading of expert GAPs into the MMPGRS, graphic application users (e.g. gamers) can immediately enjoy high performance graphics on the display devices of their client machines, without having to develop a robust behavioral profile based on many hours of actual user-system interaction.
- graphic application users e.g. gamers
- Another object of the present invention is to provide such an Internet-based Central Application Profile Database Server System, wherein “expert” GAPs are automatically generated by the Central Application Profile Database Server System by analyzing the GAPs of thousands of different game application users connected to the Internet, and participating in the system.
- Another object of the present invention is to provide such an Internet-based Central Application Profile Database Server System, wherein for MMPGRS users subscribing to the Automatic GAP Management Services, each such MMPGRS runs an application profiling and control algorithm that uses the most recently uploaded expert GAP loaded into its automatic mode control mechanism (AMCM), and then allow system-user interaction, user behavior, and application performance to modify the expert GAP profile over time until the next update occurs.
- AMCM automatic mode control mechanism
- Another object of the present invention is to provide such an Internet-based Central Application Profile Database Server System, wherein the Application Profiling and Analysis Module in each MMGPRS subscribing to the Automatic GAP Management Services supported by the Central Application Profile Database Server System of the present invention, modifies and improves the downloaded expert GAP within particularly set limits and constraints, and according to particular criteria, so that the expert GAP is allowed to evolve in an optimal manner, without performance regression.
- FIG. 1A 1 is a graphical representation of a typical prior art PC-based computing system employing a conventional graphics architecture driving a single external graphic card 105 ;
- FIG. 1A 2 a graphical representation of a conventional GPU subsystem supported on the graphics card of the PC-based graphics system of FIG. 1A 1 ;
- FIG. 1A 3 is a graphical representation illustrating the general software architecture of the prior art computing system shown in FIG. 1A 2 ;
- FIG. 1B 1 is a graphical representation of a typical prior art PC-based computing system employing a conventional graphics architecture employing a North memory bridge circuit (i.e. semiconductor chip of monolithic construction) with an integrated graphics device (IGD) 103 supporting a single graphics pipeline process, and being operably coupled to a South bridge circuit (i.e. semiconductor chip of monolithic construction) supporting the input/output ports of the system;
- a North memory bridge circuit i.e. semiconductor chip of monolithic construction
- IGD integrated graphics device
- FIG. 1B 2 is graphical representation of the North memory bridge employed in the system of FIG. 1B 1 , showing in greater detail the micro-architecture of the IGD supporting the single graphics pipeline process therewithin;
- FIG. 1B 3 is a graphical representation illustrating the general software architecture of the prior art PC-based IGD-driven computing system shown in FIGS. 1 B 1 and 1 B 2 ;
- FIG. 1B 4 is a graphical representation of a prior art PC-based computing system employing a conventional Fusion-type CPU/GPU hybrid architecture, wherein a single GPU 1242 implemented on the same semiconductor die as the CPU 1241 is used to support a graphics pipeline that drives an external display device, e.g. LCD panel, projection display or the like 106 , via a bridge circuit, with display interface, as shown;
- an external display device e.g. LCD panel, projection display or the like 106
- FIG. 1B 5 is a schematic representation showing the structure of a prior art GPU subsystem mounted on a graphics card or in an IGD, and comprising a GPU, and a video memory which is external to the GPU, wherein the GPU has includes two 3D engines, namely, (i) a transform bound geometry subsystem 124 for processing 3D graphics primitives 121 , and (ii) and a fill bound pixel subsystem 125 , and wherein the video memory shares its storage resources among a geometry buffer 122 A through which all geometric (i.e. polygonal) data 121 is transferred, a commands buffer 122 B, texture buffers 123 , and a Frame Buffer 126 ;
- FIG. 1C is a graphical representation illustrating a conventional process for rendering successive 3D scenes using a single GPU graphics platform to support a single graphics pipeline process, as shown in FIGS. 1 A 1 through 1 B 5 ;
- FIG. 2A 1 is a graphical representation of a prior art PC-based computing system employing a conventional dual-GPU graphic architecture comprising two external graphic cards 205 204 and two PCI-e buses, e.g. Bearlake by Intel 207 , 208 , wherein the primary and secondary graphics cards are connected to and driven by the North memory bridge circuit 103 , while a display device 106 is attached to the primary graphics card 205 , and Ethernet and mobile docking ports and other local I/O ports are driven by the South bridge circuit, as shown;
- a conventional dual-GPU graphic architecture comprising two external graphic cards 205 204 and two PCI-e buses, e.g. Bearlake by Intel 207 , 208 , wherein the primary and secondary graphics cards are connected to and driven by the North memory bridge circuit 103 , while a display device 106 is attached to the primary graphics card 205 , and Ethernet and mobile docking ports and other local I/O ports are driven by the South bridge circuit, as shown;
- FIG. 2A 2 is a graphical representation of a prior art PC-based computing system employing a conventional dual-GPU graphic architecture comprising two external graphic cards 204 , 205 and two PCI-e buses (e.g. Bearlake by Intel), wherein the primary graphics card 205 is connected to and driven by the North memory bridge via the first PCI-e bus with a display device 106 is attached to the primary graphics card 205 , and wherein the secondary graphics card 204 is connected to and driven by the South bridge via the second PCI-e bus;
- a conventional dual-GPU graphic architecture comprising two external graphic cards 204 , 205 and two PCI-e buses (e.g. Bearlake by Intel), wherein the primary graphics card 205 is connected to and driven by the North memory bridge via the first PCI-e bus with a display device 106 is attached to the primary graphics card 205 , and wherein the secondary graphics card 204 is connected to and driven by the South bridge via the second PCI-e bus;
- PCI-e buses e.g
- FIG. 2A 3 is a graphical representation of a conventional GPU subsystem supported on each of the graphics cards employed in the prior art PC-based computing systems of FIGS. 2 A 1 and 2 A 2 ;
- FIG. 2A 4 is a graphical representation illustrating the general software architecture of the prior art PC-based graphics systems shown in FIG. 2A 1 , as well as FIG. 2A 2 ;
- FIG. 2A 5 is a graphical representation of a prior art PC-based computing system employing a conventional multi-core microprocessor (CPU) chip to implement multiple processing cores in a single physical package, wherein some of the cores can be potentially used as soft graphic graphics pipelines, and wherein a display device 106 is connected to and driven by the North (memory) bridge chip on the motherboard;
- CPU central processing unit
- FIG. 2B is a graphical representation of a conventional parallel graphics rendering process being carried out according to the Image Division Method of parallelism using the dual GPUs provided on the prior art graphics platform illustrated in FIGS. 2 A 1 through 2 A 3 ;
- FIG. 2C is a graphical representation of a conventional parallel graphics rendering process being carried out according to the Time Division Method of parallelism using the dual GPUs provided on the prior art graphics platforms illustrated in FIGS. 2 A 1 through 2 A 5 ;
- FIG. 3A is a schematic representation of a prior art parallel graphics rendering platform comprising multiple parallel graphics pipelines, each supporting video memory and a GPU, and feeding complex pixel compositing hardware for composing a final pixel-based images for display on the display device;
- FIG. 3B is a graphical representation of a conventional parallel graphics rendering process being carried out according to the Object Division Method of parallelism using multiple GPUs on the prior art graphics platform of FIG. 3A ;
- FIG. 3C 1 is a schematic representation of the GPU and Video Memory structure employed in conventional multi-GPU PC-based computing systems, and illustrating the various kinds of bottlenecks (e.g. geometry limited, pixel limited, data transfer limited, and memory limited) that occur in such systems;
- bottlenecks e.g. geometry limited, pixel limited, data transfer limited, and memory limited
- FIG. 3C 2 is a table summarizing the kinds of bottleneck problems which conventional parallelization modes are currently capable of mitigating along the multi-GPU pipelines of conventional PC-based computing systems;
- FIG. 4A is a schematic representation of a generalized embodiment of the multi-mode parallel 3D graphics rendering system (MMPGRS) of the present invention shown comprising (i) an automatic mode control module or mechanism (AMCM) 400 for supporting automatic mode control using diverse types of 3D scene profiling techniques and/or system-user interaction detection techniques, (ii) a multi-mode parallel graphics rendering subsystem 41 for supporting at least three primary parallelization stages of decomposition, distribution and recomposition implemented using the Decomposition Module 401 , the Distribution Module 402 and the Recomposition Module 403 , respectively, and (ii) a plurality of either GPU and/or CPU based “graphics processing pipelines (GPPLs)” 410 ′, wherein each parallelization stage performed by its corresponding Module is configured (i.e. set up) into a “sub-state” by set of parameters, and wherein the “graphics rendering parallelism state” for the overall multi-mode parallel graphics system is established or otherwise determined by the combination of sub-states of these component stages;
- FIG. 4B 1 is a schematic representation of the subcomponents of a first illustrative embodiment of a GPU-based graphics processing pipeline (GPPL) that can be employed in the MMPGRS of the present invention depicted in FIG. 4A , shown comprising (i) a video memory structure supporting a frame buffer (FB) including stencil, depth and color buffers, and (ii) a graphics processing unit (GPU) supporting (1) a geometry subsystem having an input assembler and a vertex shader, (2) a set up engine, and (3) a pixel subsystem including a pixel shader receiving pixel data from the frame buffer and a raster operators operating on pixel data in the frame buffers;
- a graphics processing unit GPU supporting (1) a geometry subsystem having an input assembler and a vertex shader, (2) a set up engine, and (3) a pixel subsystem including a pixel shader receiving pixel data from the frame buffer and a raster operators operating on pixel data in the frame buffers;
- FIG. 4B 2 is a schematic representation of the subcomponents of a second illustrative embodiment of a GPU-based graphics processing pipeline (GPPL) that can be employed in the MMPGRS of the present invention depicted in FIG. 4A , shown comprising (i) a video memory structure supporting a frame buffer (FB) including stencil, depth and color buffers, and (ii) a graphics processing unit (GPU) supporting (1) a geometry subsystem having an input assembler, a vertex shader and a geometry shader, (2) a rasterizer, and (3) a pixel subsystem including a pixel shader receiving pixel data from the frame buffer and a raster operators operating on pixel data in the frame buffers;
- a graphics processing unit GPU supporting (1) a geometry subsystem having an input assembler, a vertex shader and a geometry shader, (2) a rasterizer, and (3) a pixel subsystem including a pixel shader receiving pixel data from the frame buffer and a raster operators
- FIG. 4B 3 is a schematic representation of the subcomponents of a illustrative embodiment of a CPU-based graphics processing pipeline that can be employed in the MMPGRS of the present invention depicted in FIG. 4A , shown comprising (i) a video memory structure supporting a frame buffer including stencil, depth and color buffers, and (ii) a graphics processing pipeline realized by one cell of a multi-core CPU chip, consisting of 16 in-order SIMD processors, and further including a GPU-specific extension, namely, a texture sampler that loads texture maps from memory, filters them for level-of-detail, and feeds to pixel processing portion of the pipeline;
- FIG. 4C is a schematic representation for the Mode Definition Table which shows the four combinations of sub-modes (i.e. sub-states) A:B:C for realizing the three (3) Parallel Modes of the MMPGRS of the present invention (i.e. Object Division Mode, Image Division Mode and Time/Alternative Division Mode), and the one (1) Single GPU (i.e. Non-Parallel Functioning) Mode of the system;
- FIG. 4D is a schematic representation illustrating the various Performance and Interactive Device Data Inputs supplied to the Application Profiling and Analysis Module (within the Automatic Mode Control Module (AMCM)) employed in the MMPGRS of present invention shown in FIG. 4A , as well as the Tasks carried out by the Application Profiling and Analysis Module;
- ACM Automatic Mode Control Module
- FIG. 5A is a schematic representation of the User Interaction Detection (UID) Subsystem employed within the Application Profiling and Analysis Module of the Automatic Mode Control Module (AMCM) in the MMPGRS of the present invention, wherein the UID Subsystem is shown comprising a Detection and Counting Module arranged in combination with a UID Transition Decision Module;
- UID User Interaction Detection
- AMCM Automatic Mode Control Module
- FIG. 5B is a flow chart representation of the state transition process between Object-Division/Image-Division Modes and the Time Division Mode initiated by the UID subsystem employed in the MMPGRS of the present invention
- FIG. 5C 1 is a schematic representation of the process carried out by the Profiling and Control Cycle in the Automatic Mode Control Module (AMCM) in the MMPGRS of present invention, while the UID Subsystem is disabled;
- AMCM Automatic Mode Control Module
- FIG. 5C 2 is a schematic representation of the process carried out by the Profiling and Control Cycle in the Automatic Mode Control Module in the MMPGRS of present invention, while the UID Subsystem is enabled;
- FIG. 5C 3 is a schematic representation of the process carried out by the Periodical Trial & Error Based Control Cycle in the Automatic Mode Control Module employed in the MMPGRS of present invention, shown in FIG. 4A ;
- FIG. 5C 4 is a schematic representation of the process carried out by the Event Driven Trial & Error Control Cycle in the Automatic Mode Control Module employed in the MMPGRS of present invention, shown in FIG. 4A ;
- FIG. 6A is a State Transition Diagram for the MMPGRS of present invention, illustrating that a parallel state is characterized by A, B, C sub-state parameters, that the non-parallel state (single GPPL) is an exceptional state, reachable from any state by a graphics application or AMCM requirement, and that all state transitions in the system are controlled by Automatic Mode Control Module (AMCM), wherein in those cases of known and previously analyzed graphics applications, the AMCM, when triggered by events (e.g. drop in frames per second FPS rate), automatically consults the Application/Scene Profile Database during the course of the Application, or otherwise, makes decisions which are supported by continuous profiling and analysis of listed parameters, and/or trial and error event driven or periodical cycles;
- AMCM Automatic Mode Control Module
- FIG. 6B is a schematic representation of the MMPGRS of the present invention supporting multiple graphic processing pipelines (GPPLs), with dynamic application profiling and parallelism mode control, in accordance with the principles of the present invention;
- GPPLs graphic processing pipelines
- FIG. 6C 1 is a flow chart illustrating the processing of a sequence of pipelined image frames during the Image Division Mode of parallel graphics rendering supported on the MMPGRS of the present invention depicted in FIGS. 4A through 6A ;
- FIG. 6C 2 is a flow chart illustrating the processing of a sequence of pipelined image frames during the Time Division Mode of parallel graphics rendering supported on the MMPGRS of the present invention depicted in FIGS. 4A through 6A ;
- FIG. 6C 3 is a flow chart illustrating the processing of a single image frame during the Object Division mode of parallel graphics rendering supported on the MMPGRS of the present invention depicted in FIGS. 4A through 6A ;
- FIG. 7A 1 - 1 is a schematic representation of various possible graphics architectural spaces within which the components of the MMPGRS of the present invention can be embodied in any given application, namely: Host Memory Space (HMS), Processor/CPU Die Space, Bridge Circuit (IGD) Space, Graphics Hub Space, and External GPU Space;
- HMS Host Memory Space
- IGD Bridge Circuit
- FIG. 7A 1 - 2 sets forth a table listing diverse classes of system architectures in which the MMPGRS can be embodied, expressed in terms of the different kinds of architectural spaces, identified in FIG. 7A 1 - 1 , in which the primary MMPGRS components (i.e. AMCM, Decomposition Submodule 1 , Decomposition Module 2 , Distribution Module, Multiple GPUs and Recomposition Module) can be embodied in each such class of MMPGRS Architecture, namely—Host Memory Space HMS (software), HMS+IGD, HMS+Fusion, HMS+Multicore, HMS+GPU-Recomposition, HUB; HUB+GPU-Recomposition, Chipset; CPU/GPU Fusion, Multicore CPU, and Game Console;
- the primary MMPGRS components i.e. AMCM, Decomposition Submodule 1 , Decomposition Module 2 , Distribution Module, Multiple GPUs and Recomposition Module
- FIG. 7A 2 is a schematic representation of a first illustrative embodiment of the MMPGRS of the present invention, following the HMS Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401 , 402 , 403 , respectively, of the Multimode Parallel Graphics Rendering Subsystem resides as a software package 701 in the Host Memory Space (HMS) while multiple GPUs are supported on a pair of external graphic cards 204 , 205 connected to a North memory bridge chip 103 and driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Module 401 divides (i.e.
- HMS Host Memory Space
- the Distribution Module 402 uses the North bridge chip to distribute graphic commands and data (GCAD) to the multiple GPUs on board the external graphics cards
- the Recomposition Module 403 uses the North bridge chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphics cards via a PCI-express interface (which is connected to the North bridge chip);
- FIG. 7A 3 is a schematic representation of a second illustrative embodiment of the MMPGRS of the present invention, following the HMS+IGD Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401 , 402 , 403 , respectively, of the Multimode Parallel Graphics Rendering Subsystem resides as a software package 701 in the Host or CPU Memory Space (HMS) while multiple GPUs are supported in an IGD within the North memory bridge circuit as well as on external graphic cards connected to the North memory bridge chip and driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Module 401 divides (i.e.
- HMS Host or CPU Memory Space
- the Distribution Module 402 uses the North bridge chip to distribute the graphic commands and data (GCAD) to the multiple GPUs located in the IGD and on the external graphics cards
- the Recomposition Module 403 uses the North bridge chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphics cards or the IGD;
- CPD composited pixel data
- FIG. 7A 4 is a schematic representation of a third illustrative embodiment of the MMPGRS of the present invention, following the HMS+IGD Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401 , 402 , 403 , respectively, of the Multimode Parallel Graphics Rendering Subsystem resides as a software package 701 in the Host Memory Space (HMS) while multiple GPUs are supported in an IGD within the South bridge circuit as well as on external graphic cards connected to the South bridge chip, and driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Module 401 divides (i.e.
- HMS Host Memory Space
- the Distribution Module 402 uses the North bridge chip to distribute graphic commands and data (CGAD) to the multiple GPUs located in the IGD and on external graphics cards
- the Recomposition Module 403 uses the South bridge chip to transfer recomposited pixel data between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphics cards or the IGD;
- FIG. 7A 5 is a schematic representation of a fourth illustrative embodiment of the MMPGRS of the present invention, following the HMS+Fusion Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401 , 402 , 403 , respectively, of the Multimode Parallel Graphics Rendering Subsystem resides as a software package 701 in the Host Memory Space (HMS) while a single GPU 1242 is supported on a CPU/GPU fusion-architecture processor die (alongside the CPU 1241 ) and one or more GPUs are supported on an external graphic card connected to the CPU processor die and driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Module 401 divides (i.e.
- the Distribution Module 402 uses the memory controller (controlling the HMS) and the interconnect network (e.g. crossbar switch) within the CPU/GPU processor chip to distribute graphic commands and data to the multiple GPUs on the CPU/GPU die chip and on the external graphics cards
- the Recomposition Module 403 uses the memory controller and interconnect (e.g.
- crossbar switch within the CPU/GPU processor chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphics card via a PCI-express interface (which is connected to the CPU/GPU fusion-architecture chip);
- CPD composited pixel data
- PCI-express interface which is connected to the CPU/GPU fusion-architecture chip
- FIG. 7A 6 is a schematic representation of a fifth illustrative embodiment of the MMPGRS of the present invention, following the HMS+Multicore Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401 , 402 , 403 , respectively, of the Multimode Parallel Graphics Rendering Subsystem resides as a software package 701 in the Host or CPU Memory Space (HMS) while some of the CPU cores on a multi-core CPU chip are used to implement a plurality of multi-core graphics pipelines parallelized under the control of the AMCM, (ii) the Decomposition Module 401 divides (i.e.
- HMS Host or CPU Memory Space
- the Distribution Module 402 uses the North memory bridge and interconnect network within the multi-core CPU chip to distribute graphic commands and data (GCAD) to the multi-core graphic pipelines implemented on the multi-core CPU chip
- the Recomposition Module 403 uses the North memory bridge and interconnect network within the multi-core CPU chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multi-core graphics pipelines during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the North bridge chip via a display interface;
- CPD composited pixel data
- FIG. 7A 7 is a schematic representation of a sixth illustrative embodiment of the MMPGRS of the present invention, following the HMS+GPU-Recomposition Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401 , 402 respectively, of the Multimode Parallel Graphics Rendering Subsystem resides as a software package 701 in the Host or CPU Memory Space (HMS) while multiple GPUs on external GPU cards are used to implement the Recomposition Module, and driven in parallelized manner under the control of the AMCM, (ii) the Decomposition Module 401 divides (i.e.
- HMS Host or CPU Memory Space
- the Distribution Module 402 uses the North or South bridge circuit and interconnect network to distribute graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module uses the North memory bridge and associated system bus (e.g.
- PCI-express bus to transfer composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets (recomposited within the vertex and/or fragment shaders of the primary GPU) are displayed as graphical images on one or more display devices, connected to an external graphics card via a PCI-express interface (which is connected to either the North or South bridge circuits of the host computing system);
- FIG. 7A 7 - 1 is a schematic representation of the parallel graphics rendering process supported within the MMPGRS of FIG. 7A 7 during its object division mode of parallel operation;
- FIG. 7A 7 - 2 is a graphical representation of Shader code (expressed in a graphics programming language, e.g. Cg) that is used within the primary GPPL of the MMPGRS of FIG. 7A 7 , in order to carry out the pixel recomposition stage of the object division mode/method of the parallel graphics rendering process of the present invention, supported on the dual GPU-based parallel graphics system shown in FIG. 7A 7 ;
- Shader code expressed in a graphics programming language, e.g. Cg
- FIG. 7A 7 - 3 is a time-line representation of process of generating a frame of pixels for an image along a specified viewing direction, during a particular parallel rendering cycle in the MMPGRS of FIG. 7A 7 , wherein the pixel recomposition step of the parallel rendering process is shown reusing GPU-based computational resources during its idle time, without the need for specialized or dedicated compositional apparatus required by prior art parallel graphics systems supporting an object division mode of parallel graphics rendering;
- FIG. 7B 1 is a schematic representation of a seventh illustrative embodiment of the MMPGRS of the present invention, following the Hub Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401 ′′, Distribution Module 402 ′′ and Recomposition Module 403 ′′ are realized within a single graphics hub device (e.g.
- ACM Automatic Mode Control Module
- HMS Host or CPU Memory Space
- the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North memory bridge circuit
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the primary GPU on the graphical display card which is connected to the graphics hub chip of the present invention via the interconnect 404 ′′;
- FIG. 7B 2 is a schematic representation of an eighth illustrative embodiment of the MMPGRS of the present invention, following the Hub+GPU-Recomposition Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host Memory Space (HMS) of the host computing system, while the Decomposition Submodule No. 2 401 ′′ and the Distribution Module 402 ′′ are realized within a single graphics hub device (e.g.
- ACM Automatic Mode Control Module
- HMS Host Memory Space
- the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the primary GPU on the graphical display card(s) (which are connected to the graphics hub chip of the present invention);
- FIG. 7B 3 is a schematic representation of a ninth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS CPU Memory Space
- the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes graphic commands and data (GCAD) to the internal GPUs via the interconnect network
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphical display card or the primary GPU in the IGB;
- FIG. 7B 4 is a schematic representation of a tenth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS CPU Memory Space
- the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the communication interfaces of the North and South bridge circuits, (iii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphical display card or the primary GPU in the IGB;
- FIG. 7B 4 - 1 is a schematic representation of an eleventh illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS CPU Memory Space
- the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the communication interfaces of the North and South bridge circuits, (iii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 implemented within Primary GPU, transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphical display card or the primary GPU in the IGB;
- FIG. 7B 5 is a schematic representation of an twelfth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS CPU Memory Space
- the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphical display card or the primary GPU in the IGB;
- FIG. 7B 6 is a schematic representation of a thirteenth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS CPU Memory Space
- Distribution Module 402 ′′ and Recomposition Module 403 ′′ are realized (as a graphics hub) in an integrated graphics device (IGD) within the South bridge circuit of the host computing system and having a single GPU driven with a single GPU on an external graphics card in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfer graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North and South bridge circuits, (iii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes the graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphics card or the primary GPU in the IGB;
- FIG. 7B 6 - 1 is a schematic representation of a fourteenth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS CPU Memory Space
- the Distribution Module 402 ′′ are realized (as a graphics hub) in an integrated graphics device (IGD) within the South bridge circuit of the host computing system and having multiple GPUs driven with a single GPU on an external graphics card in a parallelized manner under the control of the AMCM, while the Recomposition Module 403 ′′ is implemented across two or more GPUs 715 , 716 , (ii) the Decomposition Submodule No. 1 transfer graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North and South bridge circuits, (iii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes the graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphics card or the primary GPU in the IGB;
- FIG. 7B 7 is a schematic representation of a fifteenth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS CPU Memory Space
- Distribution Module 402 ′′ and Recomposition Module 403 ′′ are realized (as a graphics hub) in an integrated graphics device (IGD) within the North memory bridge of the host computing system and having a single GPU being driven with one or more GPUs on multiple external graphics cards in a parallelized manner under the control of the AMCM (or alternatively (ii) controlling a single GPU aboard the IGD for driving a display device connected to the IGD via a display interface), (ii) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (iii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- CPD composited pixel data
- FIG. 7B 7 - 1 is a schematic representation of a sixteenth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS CPU Memory Space
- the Distribution Module 402 ′′ are realized (as a graphics hub) in an integrated graphics device (IGD) realized within the North memory bridge chip of the host computing system, and driving (a) multiple GPUs on multiple external graphics cards in a parallelized manner under the control of the AMCM while the Recomposition Module 403 ′′ is implemented across two or more GPUs 715 , 716 , or alternatively (b) controlling a single GPU aboard the IGD for driving a display device connected to the IGD via a display interface, (ii) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (iii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs
- the Recomposition Module 403 ′′ implemented in the primary GPU transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphic cards or the primary GPU in the IGB;
- FIG. 7B 8 - 1 is a schematic representation of a seventeenth illustrative embodiment of the MMPGRS of the present invention, following the CPU/GPU_Fusion Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS Host Memory Space
- the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the external graphics card connected to the hybrid CPU/GPU chip via a PCI-express interface;
- FIG. 7B 8 - 2 is a schematic representation of an eighteenth illustrative embodiment of the MMPGRS of the present invention, following the CPU/GPU Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS Host Memory Space
- the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 ′′ uses the crossbar switch (i.e. interconnect) on the processor die to distribute the graphic commands and data (GCAD) to the internal GPUs and external GPUs,
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and
- finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the external graphics card connected to the hybrid CPU/GPU chip via a PCI-express interface;
- FIG. 7B 8 - 3 is a schematic representation of a nineteenth illustrative embodiment of the MMPGRS of the present invention, following the CPU/GPU Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host Memory Space (HMS), (ii) the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS Host Memory Space
- the Distribution Module 402 ′′ are realized (as a graphics hub) in on the die of a hybrid CPU/GPU fusion-architecture chip within the host computing system and having multiple GPUs 1242 ′′ driven with one or more GPUs on an external graphics card 205 (connected to the CPU/GPU chip) in a parallelized manner under the control of the AMCM, (iii) the Recomposition Module 403 ′′ is implemented across two or more GPUs 715 , 716 provided on the CPU/GPU fusion chip die and external graphics cards, (iv) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 , (v) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 ′′ uses the crossbar switch (i.e. interconnect) on the processor die to distribute the graphic commands and data (GCAD) to the internal GPUs and external GPUs,
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and
- CPD composited pixel data
- finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the external graphics card connected to the hybrid CPU/GPU chip via a PCI-express interface;
- FIG. 7B 9 - 1 is a schematic representation of a twentieth illustrative embodiment of the MMPGRS of the present invention, following the Multicore CPU Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS Host Memory Space
- the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the North memory bridge circuit and interconnect network within the multi-core CPU chip, (iii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 ′′ uses the crossbar switch (i.e. interconnect) on the processor die to distribute the graphic commands and data (GCAD) to the multiple soft parallel graphics pipelines (implemented by the multiple CPU cores),
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the multiple CPU cores during the image recomposition stage, and
- finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the North memory bridge chip via a display interface;
- FIG. 7B 9 - 2 is a schematic representation of a twenty-first illustrative embodiment of the MMPGRS of the present invention, following the Multicore CPU Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ resides as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS Host Memory Space
- the Distribution Module 402 ′′ uses the interconnect (i.e. crossbar switch) in the multi-core CPU chip to distribute the graphic commands and data (GCAD) to the multiple soft graphics pipelines (e.g.
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the soft graphics pipelines on the multi-core CPU chip and hard GPUs on the external graphics card during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the external graphics card which is connected to the multi-core CPU chip via a PCI-express interface;
- CPD composited pixel data
- FIG. 7B 10 is a schematic representation of a twenty-second illustrative embodiment of the MMPGRS of the present invention, following the Game Console Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ are realized as a software package 711 within the Host Memory Space (HMS), while the Decomposition Submodule No. 2 401 ′′, the Distribution Module 402 ′′ and the Recomposition Module 403 ′ are realized as a graphics hub semiconductor chip within the game console system in which multiple GPUs are driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS Host Memory Space
- the Decomposition Submodule No. 2 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 , via the memory controller on the multi-core CPU chip and the interconnect in the graphics hub chip of the present invention, (iii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes the graphic commands and data (GCAD) to the multiple GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the multiple GPUs during the image recomposition stage
- recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the primary GPU 715 via a analog display interface
- FIG. 7B 11 is a schematic representation of a twenty-third illustrative embodiment of the MMPGRS of the present invention, following the Game Console Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ are realized as a software package 711 within the Host Memory Space (HMS) of the host computing system while the Decomposition Submodule No. 2 401 ′′ and Distribution Module 402 ′ are realized as a graphics hub semiconductor chip within the game console system in which multiple GPUs are driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No.
- AMCM Automatic Mode Control Module
- HMS Host Memory Space
- the Decomposition Submodule No. 2 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 , via the memory controller on the multi-core CPU chip and the interconnect in the graphics hub chip of the present invention, (iii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 ′ distributes the graphic commands and data (GCAD) to the multiple GPUs
- the Recomposition Module 403 ′ realized primarily within the substructure of the primary GPU, transfers composited pixel data (CPD) between the multiple GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets (recomposited within the vertex and/or fragment shaders of the primary GPU) are displayed as graphical images on one or more display devices 106 connected to the primary GPU 715 via an analog display interface or the like;
- FIG. 8A is a schematic block representation of an illustrative implementation of the MMPGRS of the present invention following the Hub Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , wherein (i) the AMCM and Decomposition No.
- HMS host memory space
- multiple discrete graphic cards are connected to the bridge circuit of the host computing system by way of a hardware-based graphics hub chip of the present invention 404 ′′, 402 ′′, 403 ′′, 404 ′′,
- hardware-based Distribution and Recomposition Modules 402 ′′ and 403 ′′ are realized on the hardware-based graphics hub chip of the present invention, and
- a graphics display device is connected to the primary GPU;
- FIG. 8A 1 is a schematic representation of a first illustrative embodiment of the MMPGRS implementation of FIG. 8A , showing a possible packaging of the Hub architecture of the present invention as an assembly comprising a Hub-extender card 811 carrying multiple (e.g. dual) graphics cards 812 , 813 supported on a motherboard 814 within the host computing system;
- a Hub-extender card 811 carrying multiple (e.g. dual) graphics cards 812 , 813 supported on a motherboard 814 within the host computing system
- FIG. 8A 2 is a schematic representation of a second illustrative embodiment of the MMPGRS implementation of FIG. 8A , showing a possible packaging of the Hub architecture of the present invention as an external box containing a Hub chip of the present invention mounted on a PC board, that is connected to the motherboard of the host computing system via a wire harness or the like, and supporting a plurality of graphics cards 813 that are connected to the Hub chip;
- FIG. 8A 3 is a schematic representation of a third illustrative embodiment of the MMPGRS implementation of FIG. 8A , showing a possible packaging of the Hub architecture of the present invention realized as a graphics Hub chip of the present invention mounted on the motherboard 814 of the host computing system, which supports multiple graphics cards 813 with multiple GPUs;
- FIG. 8B is a schematic block representation of an illustrative implementation of the MMPGRS of the present invention following the Hub+GPU-Recomposition Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , wherein (i) the AMCM and Decomposition No. 1 Submodule are implemented as a software-package 701 within host memory space (HMS) of the host computing system, (ii) multiple discrete graphic cards are connected to a bridge chipset on the host computing system by way of a hardware-based graphics hub chip realizing the Decomposition No.
- HMS host memory space
- FIG. 8B 1 is a schematic representation of a first illustrative embodiment of the MMPGRS implementation of FIG. 8B , showing a possible packaging of the Hub+GPU Recomposition architecture of the present invention as an assembly comprising a graphic hub-extender card 811 carrying multiple (e.g. dual) graphics cards 812 , 813 supported on a motherboard 814 within the host computing system;
- a graphic hub-extender card 811 carrying multiple (e.g. dual) graphics cards 812 , 813 supported on a motherboard 814 within the host computing system;
- FIG. 8B 2 is a schematic representation of a second illustrative embodiment of the MMPGRS implementation of FIG. 8B , showing a possible packaging of the Hub architecture of the present invention as an external box containing a Hub chip of the present invention mounted on a PC board, that is connected to the motherboard of the host computing system via a wire harness or the like, and supporting a plurality of graphics cards 813 that are connected to the graphics hub chip;
- FIG. 8B 3 is a schematic representation of a third illustrative embodiment of the MMPGRS implementation of FIG. 8B , showing a possible packaging of the Hub architecture of the present invention realized as a graphics hub chip of the present invention mounted on the motherboard 814 of the host computing system, which supports multiple graphics cards 813 with multiple GPUs;
- FIG. 8C is a schematic block representation of an illustrative embodiment of the MMPGRS of the present invention following the HM Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , wherein (i) the AMCM, Decomposition, Distribution and Recomposition Modules are implemented as a software-package 701 within host memory space (HMS) of the host computing system, (ii) multiple discrete GPUs on one or more graphics cards, are connected to the bridge circuit on the host computing system, and (iii) a graphics display device is connected to the primary GPU;
- HMS host memory space
- FIG. 8C 1 is a schematic representation of a first illustrative embodiment of the MMPGRS implementation of FIG. 8C , wherein discrete multiple graphics cards 851 , each supporting at least a single GPU, are interfaced with the bridge circuit chipset of the CPU motherboard by way of a PCI-express or like interface;
- FIG. 8C 2 is a schematic representation of a second illustrative embodiment of the MMPGRS implementation of FIG. 8C , wherein multiple GPUs are realized on a single graphics card 852 which is interfaced to bridge circuit on the CPU motherboard by way of a PCI-express or like interface;
- FIG. 8C 3 is a schematic representation of a third illustrative embodiment of the MMPGRS implementation of FIG. 8C , wherein multiple discrete graphics cards 851 , each supporting at least a single GPU, are interfaced with the bridge circuit on a board within an external box 821 that is interface to the motherboard within the host computing system;
- FIG. 8D 1 is a schematic representation of a first illustrative embodiment of the MMPGRS implementation of FIG. 8D , wherein discrete multiple graphics cards 851 , each supporting at least a single GPU, are interfaced with the bridge circuit chipset of the CPU motherboard by way of a PCI-express or like interface;
- FIG. 8D 2 is a schematic representation of a second illustrative embodiment of the MMPGRS implementation of FIG. 8D , wherein multiple GPUs are realized on a single graphics card 852 which is interfaced to bridge circuit on the CPU motherboard by way of a PCI-express or like interface;
- FIG. 8D 3 is a schematic representation of a third illustrative embodiment of the MMPGRS implementation of FIG. 8D , wherein multiple discrete graphics cards 851 , each supporting at least a single GPU, are interfaced with the bridge circuit on a board within an external box 821 that is interface to the motherboard within the host computing system;
- FIG. 9A is a schematic block representation of an illustrative implementation of the MMPGRS of the present invention following the Hub Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , wherein (i) the AMCM and Decomposition Submodule No. 1 are realized as a software package 711 on the host memory space (HMS), (ii) multiple GPUs (i.e. Primary GPU 715 and Secondary GPUs 716 ) are assembled on a external graphics card 902 which connects the GPUs to the bridge circuit on the host computing system by way of a hardware-based graphics hub chip implementing the Decomposition Submodule No. 2 401 ′′, the Distribution Module 402 ′′ and the Recomposition Module 403 ′′, and (iii) a graphics display device is connected to the primary GPU;
- HMS host memory space
- multiple GPUs i.e. Primary GPU 715 and Secondary GPUs 716
- a graphics display device is connected to the primary GPU
- FIG. 9A 1 is a schematic representation of an illustrative embodiment of the MMPGRS of FIG. 9A , wherein multiple GPUs 715 , 716 and hardware-based Decomposition Submodule No. 2 401 ′′, Distribution Module 402 ′′ and the Recomposition Modules 403 ′′ are implemented as a graphics hub chip or chipset 401 ′′, 402 ′, 403 ,′′ and 404 ′′ on a single graphics display card 902 , which is interfaced to the bridge circuit on the motherboard 814 within the host computing system;
- FIG. 10A is a schematic block representation of an illustrative implementation of the MMPGRS of the present invention following the Hub Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , wherein (i) the AMCM and Decomposition Submodule No. 1 are realized as a software package 711 on the host memory space (HMS), (ii) a single SOC-based graphics chip 1001 mounted on a single graphics card 1002 is interfaced with a bridge circuit on the motherboard 1002 , and supporting multiple GPUs (i.e. the primary GPU and secondary GPUs), (iii) hardware-based Decomposition Submodule No. 2 , the Distribution Module and the Recomposition Module are implemented on the SOC-based graphics chip 1001 , and (iv) a graphics display device is connected to the primary GPU;
- HMS host memory space
- a single SOC-based graphics chip 1001 mounted on a single graphics card 1002 is interfaced with a bridge circuit on the motherboard 1002 , and supporting multiple GPUs (i.
- FIG. 10A 1 is a schematic representation of possible packaging of the SOC-based graphics hub chip 101 depicted in FIG. 10A , wherein multiple GPUs 715 , 716 and hardware-based Decomposition Submodule 401 ′′, Distribution Module 402 ′′, and Recomposition Module 4 - 3 ′′ are realized on a single SOC implementation 1001 mounted on a single graphics card 1002 ;
- FIG. 10B is a schematic block representation of an illustrative implementation of the MMPGRS of the present invention following the Hub+GPU-Recomposition Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , wherein (i) the AMCM and Decomposition Submodule No. 1 are realized as a software package 711 on the host memory space (HMS), (ii) a single SOC-based graphics chip 1003 mounted on a single graphics card 1002 is interfaced with a bridge circuit on the motherboard 1002 , and supporting multiple GPUs (i.e. the primary GPU and secondary GPUs), (iii) hardware-based Decomposition Submodule No.
- HMS host memory space
- a single SOC-based graphics chip 1003 mounted on a single graphics card 1002 is interfaced with a bridge circuit on the motherboard 1002 , and supporting multiple GPUs (i.e. the primary GPU and secondary GPUs),
- the Distribution Module are implemented on the SOC-based graphics hub chip 1001 , (iv) the Recomposition Module is implemented across two or more GPUs 715 , 716 , and (v) a graphics display device is connected to the primary GPU by way of a display interface implemented on the SOC-based graphics hub chip;
- FIG. 10B 1 is a schematic representation of possible packaging of the SOC-based graphics hub chip 101 depicted in FIG. 10B , wherein multiple GPUs 715 , 716 and hardware-based Decomposition Submodule 401 ′′, Distribution Module 402 ′′, and Recomposition Module 4 - 3 ′′ are realized in the primary GPU of a single SOC implementation 1003 mounted on a single graphics card 1002 ;
- FIG. 10C is a schematic block representation of an illustrative implementation of the MMPGRS of the present invention following the HMS+GPU-Recomposition Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , wherein (i) the AMCM, Decomposition Module and Distribution Module are realized as a software package 701 on the host memory space (HMS), (ii) a single multi-GPU chip 1031 mounted on a single graphics card 1002 is interfaced with a bridge circuit on the motherboard, and supporting multiple GPUs (i.e.
- HMS host memory space
- the Recomposition Module is implemented across two or more GPUs 715 , 716 , and (iv) a graphics display device is connected to the primary GPU by way of a display interface implemented on the multi-GPU chip;
- FIG. 10C 1 is a schematic representation of possible packaging of the multi-GPU chip 1031 depicted in FIG. 10C , wherein multiple GPUs 715 , 716 and Recomposition Module/Process 403 ′′ are implemented in the primary GPU 715 of a multi-GPU chip 1031 ;
- FIG. 11A is a schematic block representation of an illustrative implementation of the MMPGRS following the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , wherein (i) the AMCM and Decomposition Submodule No. 1 are realized as a software package 711 within the host memory space (HMS) of the host computing system, (ii) plurality of GPUs 852 on one or more external graphics cards 851 is connected to the bridge circuit on the host computing platform, (iii) an integrated graphics device (IGD) 1101 , supporting hardware-based Decomposition Submodule No.
- HMS host memory space
- IGD integrated graphics device
- the Distribution Module 402 ′′ and Recomposition Module 403 ′′ are implemented within the bridge circuit 1101 on the motherboard 814 of the host computing system, and (iv) a display device is interfaced to the primary GPU by way of a PCI-express interface or the like;
- FIG. 11A 1 is a schematic representation of a first illustrative embodiment of the Chipset MMPGRS implementation of FIG. 11A , wherein multiple discrete graphics cards 851 , each supporting at least a single GPU, are interfaced with the bridge circuit on a board within an external box 821 that is interface to the motherboard within the host computing system;
- FIG. 11A 1 is a schematic representation of a second illustrative embodiment of the Chipset MMPGRS implementation of FIG. 11A , wherein discrete multiple graphics cards 851 , each supporting at least a single GPU, are interfaced with the bridge circuit chipset of the CPU motherboard by way of a PCI-express or like interface;
- FIG. 11A 3 is a schematic representation of a third illustrative embodiment of the Chipset MMPGRS implementation of FIG. 11A , wherein multiple GPUs are realized on a single graphics card 852 which is interfaced to bridge circuit on the CPU motherboard by way of a PCI-express or like interface;
- FIG. 11B is schematic representation of an illustrative implementation of the MMPGRS following the CPU/GPU Fusion Class of MMPGRS Architecture or Multi-Core Class MMPGRS Architecture described in FIG. 7A 1 - 2 , wherein (i) a CPU/GPU fusion-architecture chip or a multi-core CPU chip is mounted on the motherboard of a host computing system having memory and North and South bridge circuits, (ii) the software-based AMCM and Decomposition Submodule No. 1 are realized as a software package 701 within the host memory space (HMS) of the host computing system while Decomposition Submodule No.
- HMS host memory space
- the Distribution Module and the Recomposition Module are realized on the die of the CPU/GPU fusion-architecture chip or the multi-core CPU chip, and (iii) multiple GPUs on external graphic cards or elsewhere, are interfaced to the CPU/GPU fusion-architecture chip or the multi-core CPU chip, by way of a PCI-express or like interface, and (iv) a display device is interfaced to the primary GPU by way of a PCI-express interface or the like.
- FIG. 11B 1 is a schematic representation of a first illustrative embodiment of the CPU/GPU Fusion or Multi-Core MMPGRS implementation of FIG. 11B , wherein a CPU/GPU Fusion or Multi-Core chip is used to drive an assemble of graphic cards or GPUs on one or more external graphics cards 851 ;
- FIG. 11B 2 is a schematic representation of a second illustrative embodiment of the Chipset MMPGRS implementation of FIG. 11B , wherein a CPU/GPU Fusion or Multi-Core chip is used to drive an assemble of GPUs on a single external graphics card 852 ;
- FIG. 11B 3 is a schematic representation of a third illustrative embodiment of the Chipset MMPGRS implementation of FIG. 11B , wherein a CPU/GPU Fusion or Multi-Core chip is used to drive only an assemble of internal GPUs on the CPU/GPU Fusion or Multi-Core chip;
- FIG. 11C is schematic representation of an illustrative implementation of the MMPGRS following the Game Console Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , wherein (i) the AMCM 400 and Decomposition Submodule No. 1 401 ′ are realized as a software package within the host memory space (HMS) of the game console system, (ii) a graphics hub chip 401 ′′, 402 ′′, 403 ′′, 404 ′′ mounted on the PC board of the game console system implements the Decomposition Submodule No. 2 401 ′′, the Distribution Module 402 ′, the Recomposition Module 403 ′ as well as an interconnect network (e.g.
- HMS host memory space
- crossbar switch 404 ′′
- multiple GPUs on the PC board of the game console system are interfaced to Distribution and Recomposition Modules by way of the interconnect 404 ′′ within the graphics hub chip, and optionally, the Recompostion Module can be implemented within two or more GPUs 715 , 716 , and (iv) a display device 106 is interfaced to the primary GPU by way of an analog display interface or the like;
- FIG. 11C 1 is a schematic representation of an illustrative embodiment of the Game Console MMPGS implementation of FIG. 11D , showing its controller in combination with its game console unit;
- FIG. 12A is a schematic representation of a multi-user computer network supporting a plurality of client machines, wherein one or more client machines (i) employ the MMPGRS of the present invention following any MMPGRS Architecture described in FIG. 7A 1 - 2 , and (ii) respond to user-system interaction input data streams from one or more network users who might be local to each other as over a LAN, or be remote to each other, as when operating over a WAN or the Internet infrastructure; and
- FIG. 12B is a schematic representation of a multi-user computer network supporting a plurality of client machines, wherein one or more client machines (i) employ the MMPGRS of the present invention following any MMPGRS Architecture described in FIG. 7A 1 - 2 , and (ii) respond to user-system interaction input data streams from one or more network users who might be local to each other as over a LAN, or be remote to each other, as when operating over a WAN or the Internet infrastructure.
- MMPGRS Multi-Mode Parallel Graphics Rendering System
- MMPGRP Multi-Mode Parallel Graphics Rendering Process
- one aspect of the present invention teaches how to dynamically retain high and steady performance of a three-dimensional (3D) graphics system on conventional platforms (e.g. PCs, laptops, servers, etc.), as well as on silicon level graphics systems (e.g. graphics system on chip (SOC) implementations, integrated graphics device IGD implementations, and hybrid CPU/GPU die implementations).
- SOC graphics system on chip
- the MMPGRS and MMPGRP of the present invention fulfills a great need in the marketplace by providing a highly-suited parallelism scheme.
- different GPPL-based parallel rendering schemes supported on the MMPGRS, dynamically alternate throughout the course of any particular graphics application running on the host system in which the MMPGRS is embodied, and adapting the optimal parallel rendering method (e.g. Image/Frame, Time or Object Division) in real-time to meet the changing needs of the graphics application(s).
- the MMPGRS of the Present Invention employs Automatic Mode and Control Module (AMCM)
- Multi-Mode Parallel Graphics Rendering Subsystem 420 including (i) a Decomposition Module 401 , Distribution Module 402 and Recomposition Module 403 for supporting three stages of parallelization namely decomposition, distribution, and recomposition, and (ii) an Array or Cluster of Graphic Processing Pipelines (GPPLs) for supporting and driving Graphics Rendering and Image Display Processes; and
- GPPLs Graphic Processing Pipelines
- AMCM Automatic Mode Control Module
- the GPPLs can be realized in various ways, including (i) Graphic Processing Units (GPUs) 407 as shown in FIGS. 4 B 1 and 4 B 2 , and/or (ii) Computational Processing Units (CPUs), or CPU-cores, as shown in FIGS. 4 B 3 and 4 B 4 .
- GPUs Graphic Processing Units
- CPUs Computational Processing Units
- CPU-cores CPU-cores
- the Graphics Commands and Data (CGAD) to the MMPGRS will typically be produced and provided from the Graphics-based Application being executed by one or more CPUs and associated memory on the host computing system.
- the Interaction Data will be supplied from the user or users interaction with the host computing system.
- the host computing system may be a PC-level computer, application server, laptop, game console system, portable computing system, or the like supporting the real-time generation and display of 3D graphics), and that the MMPGRS may be embodied within any such system in accordance with the principles of the present invention.
- each GPPL employed within the MMPGRS of the present invention can be realized in a variety of different ways.
- each graphics processing pipeline will typically include some basic structures including for example, video memory and a computational unit such as a GPU, or CPU having multi-cores typically implementing SIMD elements.
- the graphic processing pipelines are often considered “hard” graphical processing pipelines.
- the graphic processing pipelines are often considered “soft” graphical processing pipelines.
- each graphic processing pipeline provides sufficient computational and memory/buffering resources to carry out the execution of graphics commands and the processing of graphics data, as specified by the graphical rendering processed required by the graphics-based Application running on the host computing system, at any particular instant in time.
- FIGS. 4 B 1 and 4 B 2 two illustrative embodiments for the GPU-based graphics processing pipeline approach are shown.
- FIG. 4B 3 one illustrative embodiment is shown for the CPU-based graphics processing pipeline approach.
- each GPU-based graphics processing pipeline (GPPL) deployed in the MMPGRS of a first illustrative embodiment comprises: (i) video memory (e.g. a stencil memory buffer, a depth memory buffer, and a color memory buffer); and (ii) a classic shader-based GPU which includes: a geometry subsystem; a set up engine; and a pixel subsystem.
- the geometry subsystem further comprises a vertex shader which implements a graphics processing function that perform is 3D geometrical transformations and lighting calculations on the objects' vertex data.
- the Setup engine assembles primitives (lines, points, triangles) from vertices, assigns parameters to primitives, divides the primitives into tiles, and distributes these tiles to the pixel pipelines of the Pixel subsystem.
- the Pixel subsystem further comprises: a pixel shader for receiving input from the Setup engine and the video memory and performing shading and texturing of pixels; and a plurality of raster operators which receive output from the pixel shader and produce blending, z-buffering and antialiasing of pixels, storing them into Frame Buffer buffer.
- This graphics pipeline architecture can be found used in conventional graphics devices such as nVidia's GeForce 7700.
- each GPU-based graphics processing pipeline (GPPL) deployed in the MMPGRS of a second illustrative embodiment comprises: (i) video memory (e.g. a stencil memory buffer, a depth memory buffer, and a color memory buffer); and (ii) a shader-based GPU which includes: a geometry subsystem; a rasterizer; and a pixel subsystem.
- video memory e.g. a stencil memory buffer, a depth memory buffer, and a color memory buffer
- shader-based GPU which includes: a geometry subsystem; a rasterizer; and a pixel subsystem.
- the geometry subsystem further comprises: an input assembler for gathering vertex data from the CPU and converting its format, and generating various index IDs that are helpful for performing various repeated operations on vertices, primitives, and scene objects; a vertex shader for performing 3D geometrical transformations and lighting calculations on the objects' vertex data; and a geometry shader permitting a range of effects and features, such as process entire primitives as inputs and generate entire primitives as output, rather than processing just one vertex at a time, as with a vertex shader, while reducing dependence on the CPU for geometry processing.
- the stream output permits data generated from geometry shaders to be forwarded back to the top of the pipeline to be processed again.
- the rasterizer assembles primitives (lines, points, triangles) from vertices, assigns parameters to primitives, and converts them into pixels for output to the Pixel subsystem.
- the pixel subsystem further comprises: a pixel shader for receiving input from the Setup engine and the video memory and performing shading and texturing of pixels; and a plurality of raster operators which receive output from the pixel shader and produce blending, z-buffering and anti-aliasing of pixels, storing them out into Frame Buffer (FB).
- This graphics pipeline architecture can be found used in conventional graphics devices such as nVidia's GeForce 8800 GTX.
- each CPU-based graphics processing pipeline (GPPL) deployed in the MMPGRS of a third illustrative embodiment comprises: (i) a video memory structure supporting a frame buffer (including stencil, depth and color buffers); (ii) a memory controller; (iii) a graphics processing pipeline realized by one cell of a multi-core CPU chip, consisting of 16 in-order SIMD processors; (iv) L2 cache memory; and (v) a GPU-specific extension, namely, a texture sampler, for loading texture maps from memory, filtering them for level-of-detail, and feeding the same to the pixel processing portion of the graphic processing pipeline (GPPL).
- This graphics pipeline architecture can be found used in such conventional devices as Larrabee multi-core processor by Intel.
- the array of GPPLs 407 comprises N pairs of GPU or CPU and Video Memory pipelines
- only one GPPL in the array termed “primary GPPL,” is responsible for driving the display unit which may be realized as a LCD panel, an LCD or DLP Image/Video “Multi-Media” Projector, or the like. All other GPPLs in the array are deemed “secondary GPPLs.”
- each stage (or Module) is induced or set up into a sub-state by a set of parameters managed within the MMPGRS, namely: parameter A for Module 401 ; parameter B for Module 402 ; and parameter C for Module 403 .
- the state of parallelism of the overall MMPGRS is established by the combination of sub-state parameters A, B and C, as listed in the Mode/State Definition Table of FIG. 4C , which will be elaborated hereinafter.
- Multi-Mode Parallel Graphics Rendering Subsystem 420 stems from its ability to quickly change its sub-states, resulting in transition of the overall graphic system (i.e. MMPGS) to another parallel state of operation, namely: the Object Division State, the Image Division State or the Time Division State, as well as to other potential parallelization schemes that may be developed and readily programmed into the MMPGRS platform of the present invention.
- MMPGS overall graphic system
- the Decomposition Module 401 , Distribution Module 402 and Recomposition Module 403 cooperate to carry out all functions required by the different parallelization schemes supported on the MMPGRS platform of the present invention. It is appropriate at this juncture to described how the primary modes of parallelism (i.e. Image, Time and Object Division) are implemented on the MMPGS using combinations of sub-state parameters (A:B:C).
- each GPU renders the next successive frame.
- the Single GPPL State of Operation is a non-parallel state of operation, it is allowed and supported in the system of the present invention as this state of operation is beneficial in some exceptional cases.
- the primary function of the Decomposition Module 401 is to divide (i.e. Split Up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time.
- GCAD graphic commands and data
- the typical graphic processing s pipeline is fed by stream of graphic commands and data from the application and graphics library (OpenGL or Direct 3D).
- This stream which is sequential in nature, has to be properly handled and eventually partitioned, according to parallelization mode (i.e. method) used.
- parallelization mode i.e. method
- the Decomposition Module 401 is preferably implemented using two submodules, namely: (i) a Decomposition Submodule No. 1 including an OS-GPU Interface and Utilities Module; and (ii) a Decomposition Submodule No. 2 , including a Division Control Module and a State Monitoring Module.
- a Decomposition Submodule No. 1 including an OS-GPU Interface and Utilities Module
- a Decomposition Submodule No. 2 including a Division Control Module and a State Monitoring Module.
- the subcomponents of these submodules will be described in detail below.
- the OS-GPU Interface and Utilities Module performs all the functions associated with interaction with the Operating System (OS), Graphics Library (e.g. OpenGL or DirectX), and interfacing with GPUs or CPU-cores, as the case may be.
- the OS-GPU Interface and Utilities Module is responsible for interception of the graphic commands from the standard graphic library, forwarding and creating graphic commands to the Vendor's GPU Driver, controlling registry, installations, OS services and utilities. Another task performed by this module is reading Performance Data from different sources (e.g. GPUs, vendor's driver, and chipset) and forwarding the Performance Data to the Automatic Mode Control Module (AMCM).
- ACM Automatic Mode Control Module
- the OS-GPU Interface and Utilities Module includes software drivers that drive subcomponents within the Decomposition, Distribution and/or Recomposition Modules that are implemented in system architectures (e.g. Hub, Chipset, etc identified in FIG. 4A 1 - 2 and shown in FIGS. 7 B 1 through 7 B 11 ) in which both the Decomposition and Distribution Modules are not implemented as software packages within the Host Memory Space (HMS) of the host computing system in which the MMPGRS is embodied.
- system architectures e.g. Hub, Chipset, etc identified in FIG. 4A 1 - 2 and shown in FIGS. 7 B 1 through 7 B 11
- HMS Host Memory Space
- the Division Control Module controls the division parameters and data to be processed by each GPU, according to parallelization scheme instantiated at any instant of system operation (e.g. division of data among GPUs in the Object Division Mode, or the partition of the image screen among GPUs in the Image Division Mode).
- the Division Control Module assigns for duplication all the geometric data and common rendering commands to all GPUs. However specific rendering commands to define clipping windows corresponding to image portions at each GPU, are assigned separately to each GPU.
- polygon division control involves sending each polygon (in the scene) randomly to a different GPU within the MMPGRS. This is an easy algorithm to implement, and it turns out to be quite efficient. There are different variations of this basic algorithm, as described below.
- the vertex-arrays can be maintained in their entirety and sent to different GPUs, as the input might be in the form of vertex arrays, and dividing it may be too expensive.
- GPU loads are detected at real time and the next polygon is sent to the least loaded GPU.
- Dynamic load balancing is achieved by building complex objects (out of polygons). GPU loads are detected at real time and the next object is sent to the least loaded GPU.
- the graphic libraries are state machines. Parallelization must preserve a cohesive state across all of the GPU pipelines in the MMPGRS. According to this method, this is achieved by continuously analyzing all incoming graphics commands, while the state commands and some of the data is duplicated to all graphics pipelines in order to preserve the valid state across all of the graphic pipelines in the MMPGRS. This function is exercised mainly in Object Division Mode, as disclosed in detail in Applicant's previous International Patent PCT/IL04/001069, now published as WIPO International Publication No. WO 2005/050557, incorporated herein by reference in its entirety.
- the primary function of the Distribution Module 402 is to physically distribute the streams of graphics data and commands to the cluster of GPUs supported on the MMPGRS platform.
- an additional source of Performance Data i.e. beyond the GPUs, vendor's driver, and chipset
- Performance Data includes the internal Profiler employed in the Distribution Module in Hub-based embodiments of the present invention.
- the Distribution Module is implemented by the following components: (i) the Distribution Management Module, which addresses the streams of graphics commands and data to the different GPPLs via chipset outputs, according to needs of the parallelization schemes instantiated by the MMPGRS; (iii) Profiler module used in graphics hub type system architectures, as illustrated in FIGS. 7 B 1 through 7 B 12 , so as to provide an additional source of Performance Data (i.e. beyond the GPUs, vendor's driver, and chipset); and (iv) a Hub Control module, operating under control of the Distributed Graphics Function Control Module 409 within the AMCM 400 , in graphics hub type system architectures, as illustrated in FIGS. 7 B 1 through 7 B 12 , for configuring the Interconnect Network 404 according to the various parallelization modes and to coordinate the overall functioning of hardware components within the Recomposition Module across the graphics hub device (GHD) of the present invention.
- the Distribution Management Module which addresses the streams of graphics commands and data to the different GPPLs via chipset outputs, according to needs of
- the Distribution Module 402 comprises three functional units: the Distribution Management, the Profiler, and the Hub Control modules.
- the Distribution Management activates the Interconnect network 404 to transfer command and data stream to the GPPLs.
- the Interconnect network serves to (i) transfer command and data stream from the CPU to GPPLs, (ii) transfer raster data from GPPLs to the Recomposition Module, (iii) transfer raster data among GPPUs for an alternative GPPL-based Recomposition, and (iv) conduct other communication tasks, such as profiling data, control, etc. among the various system components.
- Interconnect for a cluster of 4 GPPLs is a configurable switch with 5 way PCI express ⁇ 16 lanes, having one upstream path between Hub and CPU, and 4 downstream paths between Hub and four GPUs. It receives upstream of commands and data from the CPU, and transfers them downstream to GPPLs, under the control of Distribution Management unit (of Distribution module), following the data division scheme generated by the Division Control block of Decomposition sub-module ( 2 ), according to ongoing parallel division mode.
- the switch can be set into one of the following possible transfer sub-states: Divide, Broadcast, and Single.
- the Divide sub-state is set when the MMGPRS is operating in its Object Division Mode.
- the Broadcast sub-state is set when the MMGPRS is operating in its Image Division Mode.
- the Single sub-state is set when the MMGPRS is operating in its Time Division Mode, or in Single mode.
- the Profiler Unit 407 ′ has several functions in system architectures employing graphics hub device (GHD)s as illustrated in FIG. 7B 1 through 7 B 12 , namely: (i) to deliver to Division Control its own generated profiling data; (ii) to forward the profiling data from GPUs to Division Control, due the fact that the GPUs are not directly connected to the host computing system in graphics hub based system architectures, whereas they are in system architectures illustrated in FIGS. 7 A 2 through 7 A 7 - 3 ; and (iii) to forward the Hub pre-GPU profiling data to the Division Control block within the Decomposition Module.
- the Profiler 403 monitors the stream of geometric data and commands, for graphics hub profiling purposes. Such monitoring operations involve polygon, command, and texture count and quantifying data structures and their volumes for load balance purposes.
- the collected data is mainly related to the performance of the geometry subsystem employed in each GPU.
- the Hub Controller Module 409 ′ operates under control of the Distributed Graphics Function Control Module 409 within the Automatic Mode Control Module 400 .
- the primary function performed by this Hub Controller Module 409 ′ is to configure the Interconnect Network 404 according to the various parallelization modes and to coordinate the overall functioning of hardware components across the Distribution Module of the graphics hub device (GHD) of the present invention.
- the primary function of the Recomposition Module 403 is to merge together, the partial results of multiple graphics pipelines, according to parallelization mode that is operative at any instant in time.
- the Test based sub-state carries out re-composition based on a test performed on partial frame buffer pixels. Typically, these tests include the depth test, the stencil test, or combination thereof.
- the Screen based sub-state combines together parts of the final frame buffers, in a puzzle like fashion, creating a single image.
- the None sub-state, or submode makes no merges, just moves one of the pipeline frame buffers to the display, as required in time division parallelism or in single GPU (Non-Parallel) mode of operation.
- the Test-Based Compositing suits compositing during the Object Division Mode.
- sets of Z-buffer, stencil-buffer and color-buffer are read back from the GPU FBs to host's memory for compositing.
- the pixels of color-buffers from different GPUs are merged into single color-buffer, based on per pixel comparison of depth and/or stencil values (e.g. at given x-y position only the pixel associated with the lowest z value is let out to the output color-buffer).
- This is a software technique to perform hidden surface elimination among multiple frame buffers required for the Object Division Mode.
- Frame buffers are merged based on depth and stencil tests. Stencil tests, with or without combination with depth test, are used in different multi-pass algorithms.
- the final color-buffer is down-loaded to the primary GPU for display.
- the Screen-Based compositing involves a puzzle-like merging of image portions from all GPUs into a single image at the primary GPU, which is then sent out to the display. This method is a much simpler procedure than the Test-Based Compositing Method, as no tests are needed. While the primary GPU is sending its color-buffer segment to display, the Merger Module reads back other GPUs color-buffer segments to host's memory, for downloading them into primary GPU's FB for display.
- the None Sub-state is a non-compositing option which involves moving the incoming Frame Buffer to the display. This option is used when no compositing is required.
- a single color-buffer is read back from a GPU to host's memory and downloaded to primary GPU for display.
- the Non-Parallel Mode e.g. employing a single GPPL
- usually the primary GPPL is employed for rendering, so that no host memory transit is needed.
- the Recomposition Module is realized by several modules: (i) the Merge Management Module which handles the reading of frame buffers and the compositing during the Test-Based, Screen-Based And None Sub-States; (ii) the Merger Module which is an algorithmic module that performs the different compositing algorithms, namely, Test Based Compositing during the Test-Based Sub-state, and Screen Based Compositing during the Screen-Based Sub-state; (iii) Profiler module used in graphics hub type system architectures, as illustrated in FIGS. 7 B 1 through 7 B 12 , so as to provide an additional source of Performance Data (i.e.
- a Hub Control module operating under control of the Distributed Graphics Function Control Module 409 within the AMCM 400 , in graphics hub type system architectures, as illustrated in FIGS. 7 B 1 through 7 B 12 , for configuring the Interconnect Network 404 according to the various parallelization modes and to coordinate the overall functioning of hardware components within the Recomposition Module across the graphics hub device (GHD) of the present invention.
- GDD graphics hub device
- a configurable switch can be used having 5 way PCI express ⁇ 16 lanes, with one upstream path between the Hub and CPU, and 4 downstream paths between Hub and four GPUs.
- the Interconnect e.g.
- switch also performs the following functions: (i) transferring read-back FB raster data from GPPLs to the Merger block of Recomposition Module and returning composited image to primary GPPL, all under orchestration of the Merge Management block; (ii) transferring the read-back FB raster data among GPPLs for GPPL-based recomposition, so that the finally recomposited pixel data in final image is composited in the primary GPPL; (iii) transferring additional data, e.g. profiler data, to Decomposition module; and (iv) transferring control commands across the MMPGRS system.
- the Profiler unit 403 has several functions in system architectures employing graphics hub device (GHD)s as illustrated in FIG. 7B 1 through 7 B 12 , namely: (i) to deliver to Division Control its own generated profiling data; (ii) to forward the profiling data from GPUs to Division Control, due the fact that the GPUs are not directly connected to the host computing system in graphics hub based system architectures, whereas they are in system architectures illustrated in FIGS. 7 A 2 through 7 A 7 - 3 ; and (iii) to forward the Hub post-GPU profiling data to the Division Control block within the Decomposition Module.
- the Profiler 403 monitors the stream of geometric data and commands, for graphics hub profiling purposes. Such monitoring operations involve polygon, command, and texture count and quantifying data structures and their volumes for load balance purposes.
- the collected data is mainly related to the performance of the geometry subsystem employed in each GPU.
- GDD graphics hub device
- AMCM Automatic Mode Control Module
- FIG. 4A the communication linkage between the two Profiling blocks is achieved using the Interconnect network 404 .
- the two “pre-GPU” and “post-GPU” units of the graphics hub device (GHD), formed by the components within the Distribution and Recomposition Modules of system architectures illustrated in FIGS. 7 B 1 through 7 B 12 , may reside on the same silicon chip, having many internal interconnections, whereas in other illustrative embodiments, these subcomponents may be realized on different pieces of silicon or functionally like semiconductor material, used to fabricate the graphics hub device (GHD)s of the present invention within diverse embodiments of the MMPGRS of the present invention.
- the Hub Controller Module 409 ′ operates under control of the Distributed Graphics Function Control Module 409 within the AMCM 400 .
- the primary function performed by this Hub Controller Module 409 ′ is to configure the Interconnect Network 404 according to the various parallelization modes and to coordinate the overall functioning of hardware components across the Recomposition Module of the graphics hub device (GHD) of the present invention.
- the Hub Controllers 409 ′ in the Distribution and Recomposition Modules in system architectures embraced by the graphics hub device (GHD) of the present invention, can be realized as a single device or unit, on the same piece of silicon or like semiconductor material.
- the Hub Controllers 409 ′ can be realized as discrete units, on the same piece of silicon or like semiconductor material, or on separate pieces of silicon material (e.g. on different chips sets).
- AMCM Automatic Mode Control Module
- the MMPGRS renders and displays the graphics environment being generated by the application, which typically will include many dynamically changing scenes, where the plot unfolds, and each scene typically involves a sequence of many image frames.
- scenes could involve virtually anything, including a forest with many leaves moving in the wind, a lake with many reflections, or a closed space in a castle with many light sources.
- Such scenes require parallel rendering, and the role of the MMPGS is to automatically determine which mode of parallel operation will result in optimal performance on the host computing system.
- the Automatic Mode Control Module (AMCM) 400 comprises three algorithmic modules, namely: an Application Profiling and Analysis Module 407 ; a Parallel Policy Management Module 408 ; and a Distributed Graphics Function Control.
- the AMCM also comprises two data stores: a Historical Repository 404 ; and a Application/Scene Profile Database 405 .
- the primary function of the AMCM is to control the state of Multi-mode Parallel Rendering Subsystem 410 by virtue of its flexible multi-state behavior and fast interstate transition capabilities.
- the AMCM 400 comprises a User Interaction Detection (UID) Subsystem 438 which includes a Detection and Counting Module 433 in combination with a UID Transition Decision Module 436 .
- UID User Interaction Detection
- AMCM Automatic Mode Control Module or Mechanism
- This method involves collecting and analysis of Performance Data, during application run-time, in order to construct scene profiles for image frames associated with particular scenes in a particular graphics-based application, and maintaining these scene profiles in the Scene/Application Profile Database within the AMCM.
- the AMCM can access and use these scene profiles so as to best determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance.
- this technique can be practiced using the Application Profiling and Analysis Module 407 and Parallel Policy Management Module 408 illustrated in FIGS.
- This technique involves analyzing, prior to run-time, the scenes of a particular application, and then indexing the scene with Scene Profile Indices and storing corresponding Mode Control Parameters (MCPs) (e.g. Switch to Object Division Mode) within the local Scene/Application Profile Database within the AMCM, or other data storage device that is accessible in real-time by the AMCM during application run-time. Then during run-time, the AMCM automatically detects the scene, and consults the Scene Profile Indices for the corresponding MCPs from the Scene/Application Profile Database so as to best determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance.
- MCPs Mode Control Parameters
- MCCs Mode Control Command
- This technique involves, prior to run-time (e.g. during game application development), analyzing the scenes of a particular application, and the directly programming Mode Control Commands (MMCs) (e.g. Switch to Object Division Mode) within the individual image frames of each scene, following standards to be established and followed by developers in the computer graphics industry. Then during run-time, the MCM automatically detects these MCCs along the graphics command and data stream, and use these commands so as to best determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance.
- MMCs Mode Control Commands
- This approach which can be used in conjunction with any of the above Scene/Application Profiling Techniques, involves automatically detecting the users interaction with the host computing system (e.g. mouse device movement, keyboard depressions, etc) and providing this Interaction Data to the AMCM so that it can best determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance, given the user's interaction with the host computing system, or application running thereon, at any instance in time.
- this technique can be practiced using the UID Subsystem 438 illustrated in FIGS. 5A, 5B and 5 C 2 .
- the Application Profiling and Analysis Module 407 monitors and analyzes Performance and Interactive data streams continuously acquired by profiling the Application while its running.
- the Performance Data inputs provided to the Application Profiling and Analysis Module include: texture count; screen resolution; polygon count; utilization of geometry engine, pixel engine, video memory and GPPL; the total pixels rendered, the total geometric data rendered; the workload of each GPPL; the volumes of transferred data.
- the System-User Interactive (Device) Data inputs provided to the Application Profiling and Analysis Module include: mouse movement; head movement; voice commands; eye movement; feet movement; keyboard; LAN, WAN or Internet (WWW) originated application (e.g. game) updates.
- the Tasks performed by the Application Profiling and Analysis Module include: Recognition of the Application; Processing of Trial and Error Results; Utilization of Application Profile from Application/Scene Profile Database; Data Aggregation in the Historical Depository; Analysis of input performance data (frame-based); Analysis based on integration of frame-based “atomic” performance data, aggregated data at Historical Depository, and Application/Scene Profile Database data; Detection of rendering algorithms used by Application; Detection of use of FB in next successive frame; Recognition of preventative conditions (to parallel modes); Evaluation of pixel layer depth; Frame/second count; Detection of critical events (e.g. frames/sec/drop); Detection of bottlenecks in graphics pipeline; Measure of load balance among GPUs; Update Application/Scene Profile Database from the Historical Depository; and Recommendation on optimal parallel scheme.
- the Application Profiling and Analysis Module performs its analysis based on the following:
- Performance Data collected from several sources such as vendor's driver, GPUs, chipset, and optionally—from the graphics Hub embodiments of the present invention, described in greater detail hereinafter;
- Historical repository 404 which continuously stores up the acquired data (i.e. this data having historical depth, and being used for constructing behavioral profile of ongoing application);
- Knowledge based Application/Scene Profile Database 405 which is an application profile library of prior known graphics applications (and further enriched by newly created profiles based on data from the Historical Depository).
- the choice of parallel rendering mode at any instant in time involves profiling and analyzing the system's performance by way of processing both Performance Data Inputs and Interactive Device Inputs, which are typically generated from a several different sources within MMPGRS, namely: the GPUs, the vendor's driver, the chipset, and the graphic Hub (optional).
- Performance Data needed for estimating system performance and locating casual bottlenecks includes:
- this Performance Data is fed as input into the Application Profiling and Analysis Module for real-time processing and analysis Application Profiling and Analysis Module.
- the Application Profiling and Analysis Module performs the following tasks:
- Parallel Policy Management Module 408 makes the final decision regarding the preferred mode of parallel graphics rendering used at any instant in time within the MMPGRS, and this decision is based on the profiling and analysis results generated by the Application Profiling and Analysis Module. The decision is made on the basis of some number N of graphics frames. As shown above, the layer depth factor, differentiating between the effectiveness of the Object Division vs. Image Division Mode, can be evaluated by analyzing the relationship of geometric data vs. fragment data at a scene, or alternatively can be found heuristically. Illustrative control policies have been described above and in FIGS. 5 C 1 through 5 C 3 .
- the Distributed Graphic Function Control Module Distributed Graphic Function Control Module 409 carries out all the functions associated with the different parallelization modes, according to the decision made by the Parallel Policy Management Module.
- the Distributed Graphic Function Control Module 409 drives directly the configuration sub-states of the Decomposition, Distribution and Recomposition Modules, according to the parallelization mode.
- Application Profiling and Analysis includes drivers needed for hardware components such as graphic Hub, described hereinafter in the present Patent Specification.
- the MMPGRS of the illustrative embodiment has six (6) system states.
- Three of these system states are parallel graphics rendering states, namely: the Image Division State, which is attained when the MMPGRS is operating in its Image Division Mode; the Object Division State, which is attained when the MMPGRS is operating in its Object Division Mode; and the Time Division State, which is attained when the MMPGRS is operating in its Time Division Mode.
- the system also includes a Non-Parallel Graphics Rendering State, which is attained only when a single GPPL is operational during the graphics rendering process. There is also an Application Identification State, and a Trial & Error Cycle State. As illustrated in FIG. 4C and FIG.
- each parallelization state is characterized by sub-state parameters A, B, C.
- the Non-Parallel (i.e. Single GPPL) State is reachable from any other state of system operation.
- profiles of all previously analyzed and known graphics-based Applications are stored in the Application/Scene Profile Database 405 of the MMPGRS.
- the system enters Application Identification State, and the AMCM attempts to automatically identify whether this application is previously known to the system.
- the optimal starting state is recommended by the Database, and the system transitions to that system state.
- the AMCM is assisted by the Application/Scene Profile Database to optimize the inter-state tracking process within the MMPGRS.
- the Trial & Error Cycle State is entered, and attempts to run all three parallelization schemes (i.e. Modes) are made for a limited number of cycles.
- the decision by the system as to which mode of graphics rendering parallelization to employ is supported either by continuous profiling and analysis, and/or by trial and error.
- the Trial and Error Process is based on comparing the results of a single, or very few cycles spent by the system at each parallelization state.
- the Time Division Mode is the fastest among the parallel graphics rendering modes of the MMGRS, and this is by virtue of the fact that the Time Division Mode works favorably to reduce geometry and fragment bottlenecks by allowing more time.
- the Time Division Mode i.e. method
- the Time Division Mode suffers from other problems, namely: (i) CPU bottlenecks; (ii) the unavailability of GPU-generated frame buffers to each other, in cases where the previous frame is required as a start point for the successive frame; and also (iii) from pipeline latency. Automatic transition of the MMGPRS to its Object-Division Mode effectively releases the system from transform and video memory loads.
- Time Division Mode may be suitable and perform better than other parallelization schemes available on the MMGPRS of the present invention (e.g. Object-Division Mode and Image-Division Mode).
- the MMPGRS of the present invention employs a User Interaction Detection (UID) Subsystem 438 which enables automatic and dynamic detection of the user's interaction with the system. Absent preventive conditions (such as CPU bottlenecks and need for the same FB in successive frames), the UID subsystem 438 enables timely automated implementation of the Time Division Mode only when no user-system interactivity is detected so that system performance is automatically optimized.
- UID User Interaction Detection
- Transition from Object Division to Image Division follows a combination of one or more of the following conditions:
- Transition from Image Division to Object Division follows a combination of one or more of the following conditions:
- Transition from Object Division to Time Division follows a combination of one or more of the following conditions:
- Transition from Time Division to Object Division follows a combination of one or more of the following conditions:
- Transition from Time Division to Image Division follows a combination of one or more of the following conditions:
- Transition from Image Division to Time Division follows a combination of one or more of the following conditions:
- this capacity of the MMPGRS is realized by the User Interaction Detection (UID) Subsystem 438 provided within the Application Profiling and Analysis Module 407 in the Automatic Mode Control Module of the system.
- the UID subsystem 438 comprises: a Detection and Counting Module 433 in combination with a UID Transition Decision Module 436 .
- the set of interactive devices which can supply User Interactive Data to the UID subsystem can include, for example, a computer mouse, a keyboard, eye-movement trackers, head-movement trackers, feet-movement trackers, voice command subsystems, Internet, LAN, WAN and/or Internet originated user-interaction or game updates, and any other means of user interaction detection, and the like.
- each interactive device input 432 supported by the computing system employing the MMPGRS feeds User Interaction Data to the Detection and Counting Module 433 which automatically counts the elapsed passage of time for the required non-interactive interval.
- the Detection and Counting Module 433 automatically generates a signal indicative of this non-interactivity ( 434 ) which is transmitted to the UID Transition Decision Module 436 .
- UID Transition Decision Module 436 issues a state transition command (i.e.
- an system-user interactivity signal 435 is transferred to the UID Transition Decision Module 436 , thereby initiating the system to return from the then currently Time Division Mode, to its original parallel mode of operation (i.e. the Image or Object Division Mode, as the case may be).
- an Initialization Signal 431 is provided to the Detection and Counting Module 433 when no preventive conditions for Time Division exist.
- the function of the Initialization Signal 431 is to (1) define the set of input (interactive) devices supplying interactive inputs, as well as (2) define the minimum elapsed time period with no interactive activity required for transition to the Time Division Mode (termed non-interactive interval).
- the function of the UID Transition Decision Module 436 is to receive detected inputs 435 and no inputs 434 during the required interval, and, produce and provide as output, a signal to the Parallel Policy Management System, initiating a transition to or from the Time Division Mode of system operation, as shown.
- the UID Subsystem 438 within the MMGPRS can automatically initiate a transition into its Time Division Mode upon detection of user-interactivity, without the system experiencing user lag. Then as soon as the user is interacting with the application, the UID Subsystem of the MMGPRS can automatically transition (i.e. switch) the system back into its dominating mode (i.e. the Image Division or Object Division).
- UID user-interaction detection
- the automated event detection functions described above can be performed using any of the following techniques: (i) detecting whether or not a mouse movement or keyboard depression has occurred within a particular time interval (i.e. a strong criterion); (ii) detecting whether or not the application (i.e. game) is checking for such events (i.e. a more subtle criterion); or (iii) allowing the application's game engine itself to directly generate a signal indicating that it is entering an interactive mode.
- the state transition process between Object-Division/Image-Division Modes and the Time Division Mode initiated by the UID subsystem of the present invention is described in the flow-chart shown in FIG. 5B .
- the UID subsystem is initialized.
- the time counter of the Detection and Counting Module 433 is initialized.
- the UID subsystem counts for the predefined non-interactive interval, and the result is repeatedly tested at Block D.
- the parallel mode is switched to the Time-Division at Block E by the Parallel Policy Management Module.
- the UID subsystem determines whether user interactive input (interactivity) has been detected, and when interactive input has been detected, the UID subsystem automatically returns the MMPGRS to its original Image or Object Division Mode of operation, at Block G of FIG. 5B .
- Steps A through C test whether the graphics application is listed in the Application/Scene Profile Database of the MMPGRS. If the application is listed in the Application/Scene Profile Database, then the application's profile is taken from the Database at Step E, and a preferred state is set at Step G.
- Steps I-J N successive frames are rendered according to Control Policy, under the control of the AMCM with its UID Subsystem disabled.
- Performance Data is collected, and at Step M, the collected Performance Data is added to the Historical Repository, and then analyzed for next optimal parallel graphics rendering state at Step F.
- the Application/Scene Profile Database is updated at Step N using Performance Data collected from the Historical Repository.
- Steps A through C test whether the graphics application is listed in the Application/Scene Profile Database of the MMPGRS. If the application is listed in the Application/Scene Profile Database, then the application's profile is taken from the Database at Step E, and a preferred state is set at Step G.
- Steps I-J N successive frames are rendered according to Control Policy under the control of the AMCM with its UID Subsystem enabled and playing an active role in Parallel Graphics Rendering State transition within the MMPGRS.
- Performance Data is collected, and at Step M, the collected Performance Data is added to the Historical Repository, and then analyzed for next optimal parallel graphics rendering state at Step F.
- the Application/Scene Profile Database is updated at Step N using Performance Data collected from the Historical Repository.
- the Periodical Trial & Error Process differs from the Profiling and Control Cycle Process/Method described above, based on its empirical approach. According the Periodical Trial & Error Process, the best parallelization scheme for the graphical application at hand is chosen by a series of trials described at Steps A through M in FIG. 5C 3 . After N successive frames of graphic data and commands are processed (i.e. graphically rendered) during Steps N through O, another periodical trial is performed at Steps A through M.
- a preventive condition for any of parallelization schemes can be set and tested during Steps B, E, and H, such as used by the application of the Frame Buffer FB for the next successive frame, which prevents entering the Time Division Mode of the MMPGRS.
- Object Division Mode supersedes the Image Division Mode in that it reduces more bottlenecks.
- the Object Division Mode relaxes bottleneck across the pipeline: (i) the geometry (i.e. polygons, lines, dots, etc) transform processing is offloaded at each GPU, handling only 1/N of polygons (N—number of participating GPUs); (ii) fill bound processing is reduced since less polygons are feeding the rasterizer; (iii) less geometry memory is needed; and (iv) less texture memory is needed.
- the duration of transform and fill phases differ between the Object and Image Division Modes (i.e. States) of operation.
- the fill function Depth Complexity in Object Division Mode depends on depth complexity of the scene. Depth complexity is the number of fragment replacements as a result of depth tests (the number of polygons drawn on every pixel). In the ideal case of no fragment replacement (e.g.
- T ImgDiv Transform/2+Fill/2
- an algorithm is used which detects which transform and fill bound processing is smaller. Once the layer-depth reaches some threshold value throughout the scene, the Object Division Mode will not minimize the Fill function any more.
- Render(n,p) the time for drawing n polygons and p pixels.
- P the time taken to draw one pixel.
- the drawing time is assumed to be constant for all pixels (which may be a good approximation, but is not perfectly accurate).
- the screen space of a general scene is divided into sub-spaces based on the layer-depth of each pixel. This leads to some meaningful figures.
- the improvement factor when using Object Division Mode support is 1.3602643398952217.
- a CAD engine might have a constant layer depth of 4. The improvement factor for interesting cases is shown in a table set forth in copending application Ser. No. 11/789,039, supra
- the parallel graphics rendering process for a single frame is described in connection with the Image Division Mode of the MMPRS of the present invention.
- the Decomposition, Distribution and Recomposition Modules are set as follows: the Decomposition Module is set on sub-state A- 2 , the Distribution Module is set on sub-state B- 2 , and the Recomposition Module is set on sub-state C- 2 .
- the Decomposition Module splits up the image area into sub-images and prepares partition parameters for each GPPL 6120 . Typically, the partition ratio is dictated by the Automatic Mode Control Module based on load balancing considerations. The physical distribution of these parameters among multiple GPPLs is done by the Distribution Module ( 6124 ).
- the Decomposition, Distribution and Recomposition Modules are set as follows: the Decomposition Module is set on sub-state A- 3 , the Distribution Module is set on sub-state B- 3 , and the Recomposition Module is set on sub-state C- 3 .
- the Decomposition Module aligns a queue of GPPLs 6130 , appoints the next frame to the next available GPPL 6131 , and monitors the stream of commands and data to all GPPLs 6132 .
- the physical distribution of that GCAD stream is performed by the Distribution Module 6134 .
- the control moves to the Recomposition Module which moves the color-FB of the completing secondary GPPL, to the primary GPPLs 6135 .
- the primary GPPL then displays the recomposited image in the FB on the display screen 6136 of the display device.
- the parallel graphics rendering process for a single frame is described in connection with the Object Division Mode of the MMPRS implemented according to the software-based architecture of the present invention.
- the Decomposition, Distribution and Recomposition Modules are set as follows: the Decomposition Module is set on sub-state A- 1 , the Distribution Module is set on sub-state B- 1 , and the Recomposition Module is set on sub-state C- 1 .
- the Decomposition Module activity starts with interception of graphics commands 6140 on their way between standard graphics library (e.g. OpenGL, Dirct3D) and vendor's GPU driver. Each graphics command is tested for blocking mode 6142 , 6143 and state operation class 6144 .
- standard graphics library e.g. OpenGL, Dirct3D
- Blocking operations are exceptional in that they require a composed valid FB data, thus in the Object Division Mode, they have an inter-GPPL effect. Therefore, whenever one of the blocking operations is issued, all the GPPLs must be synchronized. Each frame has at least 2 blocking operations: Flush and Swap, which terminate the frame. State operations (e.g. definition of light source) have an across the board effect on all GPPLS. In both cases the command must be duplicated to all GPPLs, rather than delivered to one of them. Therefore the Distribution Module physically sends the command to all GPPLs 6150 . On the other hand, a regular command that passed the above tests is designated to a single target GPPL 6145 , and sent by Distribution Module to that GPPL 6151 .
- a blocking flag is set on 6147 indicating blocking state.
- the rendering of upcoming commands is mirrored (duplicated) at all of the GPPL, unless an end-of-blocking mode is detected.
- the compositing sequence includes issuing of a flushing command 6149 to empty the pipeline. Such a command is sent to all GPPLs 6152 . Then at each GPPL the color and Z Frame Buffer are read back to host memory 6154 , and all color Frame Buffers are composited based on Z and stencil buffers 6156 . Finally, the resulting Frame Buffer is sent to all GPPLs 6160 .
- state operation commands e.g. glLight, glColor
- glLight e.g. glLight, glColor
- a compositing process is taking place 6153 , 6155 , 6157 , 6158 , very similar to that of blocking mode.
- the merging result is sent to the display screen connected to the primary GPPL.
- FIG. 7A 1 - 1 sets forth a schematic diagram that illustrates different environments for practicing the embodiments of MMPGRS present invention, namely: Host Memory Space (HMS), Processor/CPU Die Space, Bridge Circuit (IGD) Space, Graphics Hub Space, and External GPU Space.
- HMS Host Memory Space
- IGD Bridge Circuit
- the table describes eleven (11) different Classes of MMPGRS Architecture, defined in terms of the Architectural Spaces specified in FIG. 7A 1 - 1 in which the primary MMPGRS components are embodied in any particular Class of MMPGRS Architecture, namely: Host Memory Space HMS (software); HMS+IGD; HMS+Fusion; HMS+Multicore; HMS+GPU-Recomposition; HUB; HUB+GPU-Recomposition; Chipset; CPU/GPU Fusion; Multicore CPU; and Game Console.
- Host Memory Space HMS software
- HMS+IGD HMS+Fusion
- HMS+Multicore HMS+GPU-Recomposition
- HUB HUB+GPU-Recomposition
- Chipset CPU/GPU Fusion
- Multicore CPU Multicore CPU
- Game Console the table describes eleven (11) different Classes of MMPGRS Architecture, defined in terms of the Architectural Spaces specified in FIG. 7A 1 - 1 in which the primary MMPGRS components are embodied in any particular Class of MMPG
- the MMPGRS Architecture Table (i.e. Map) of the illustrative embodiments of the present invention illustrates several things.
- each MMPGRS Architecture illustrated in FIG. 7A 1 - 2 , the Automatic Mode Control Module (AMCM) 400 and Modules and Submodules of the Multimode Parallel Graphics Rendering Subsystem 401 , 402 , 403 may reside in the different kinds of Architectural Space specified in FIG. 7A 1 - 1 , while multiple GPPLs, distributed in various ways in such environment, are driven multiple modes of parallelism that are dynamically managed in accordance with the principles of the present invention.
- each Class of MMPGRS Architecture will typically have numerous implementation options, with the illustrative embodiments shown in FIGS. 8 A through 11 D 1 simply being just a handful of possible implementation options.
- the MMPGRS Architecture Table set forth in FIG. 7A 1 - 2 is by no means a list of all possible Class of MMPGRS Architecture, but rather is an exemplary listing of the primary classes which comes to mind of the Inventors at the time of filing the present Application, and that it is expected, in the future, that other architectural spaces will evolve or be developed, thereby providing additional environments in which the MMPGRS of the present invention may be embodied or otherwise practiced.
- Various examples of how the MMPGRS of the present invention can be practiced will be described in greater detail below.
- the first illustrative embodiment of the MMPGRS of present invention 700 is shown embodied within the HMS Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401 , 402 , 403 , respectively, of the Multimode Parallel Graphics Rendering Subsystem resides as a software package 701 in the Host Memory Space (HMS) while multiple GPUs are supported on a pair of external graphic cards 204 , 205 connected to a North memory bridge chip ( 103 ) and driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM.
- HMS Host Memory Space
- the Decomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (ii) the Distribution Module 402 uses the North bridge chip to distribute graphic commands and data (GCAD) to the multiple GPUs on board the external graphics cards, (iii) the Recomposition Module 403 uses the North bridge chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (iv) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphics cards via a PCI-express interface, which is connected to the North bridge chip.
- CPD composited pixel data
- the second illustrative embodiment of the MMPGRS of present invention is shown embodied within the HMS+IGD Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401 , 402 , 403 , respectively, of the Multimode Parallel Graphics Rendering Subsystem reside as a software package 701 in the Host or CPU Memory Space (HMS), while multiple GPUs are supported in an IGD within the North memory bridge circuit as well as on external graphic cards connected to the North memory bridge chip and driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM.
- HMS Host or CPU Memory Space
- the Decomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (ii) the Distribution Module 402 uses the North bridge chip to distribute the graphic commands and data (GCAD) to the multiple GPUs located in the IGD and on the external graphics cards, (iii) the Recomposition Module 403 uses the North bridge chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (iv) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphics cards or the IGB, as shown.
- CPD composited pixel data
- the third MMPGRS of present invention is shown embodied within the HMS+IGD Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401 , 402 , 403 , respectively, of the Multimode Parallel Graphics Rendering Subsystem reside as a software package 701 in the Host Memory Space (HMS) while multiple GPUs are supported in an IGD within the South bridge circuit as well as on external graphic cards connected to the South bridge chip, and driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM.
- HMS Host Memory Space
- the Decomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (ii) the Distribution Module 402 uses the North bridge chip to distribute graphic commands and data (CGAD) to the multiple GPUs located in the IGD and on external graphics cards, (iii) the Recomposition Module 403 uses the South bridge chip to transfer recomposited pixel data between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (iv) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphics cards or the IGB, as shown.
- GCAD graphic commands and data
- the fourth illustrative embodiment of the MMPGRS of present invention is shown embodied within the HMS+Fusion Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401 , 402 , 403 , respectively, of the Multimode Parallel Graphics Rendering Subsystem resides as a software package 701 in the Host Memory Space (HMS) while a single GPU ( 1242 ) is supported on a CPU/GPU fusion-architecture processor die (alongside the CPU 1241 ) and one or more GPUs are supported on an external graphic card connected to the CPU processor die and driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM.
- HMS Host Memory Space
- the Decomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (ii) the Distribution Module 402 uses the memory controller and interconnect (e.g. crossbar switch) within the CPU/GPU processor chip to distribute graphic commands and data to the multiple GPUs on the CPU/GPU die chip and on the external graphics cards, (iii) the Recomposition Module 403 uses the memory controller and interconnect (e.g.
- crossbar switch within the CPU/GPU processor chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (iv) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphics card via a PCI-express interface, which is connected to the CPU/GPU fusion-architecture chip.
- CPD composited pixel data
- the fifth illustrative embodiment of the MMPGRS of present invention is shown embodied within the HMS+Multicore Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401 , 402 , 403 , respectively of the Multimode Parallel Graphics Rendering Subsystem resides as a software package 701 in the Host or CPU Memory Space (HMS) while some of the CPU cores on a multi-core CPU chip are used to implement a plurality of multi-core graphics pipelines parallelized by the modules of the software package 701 of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM.
- HMS Host or CPU Memory Space
- the Decomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (ii) the Distribution Module 402 uses the North memory bridge and interconnect network within the multi-core CPU chip to distribute graphic commands and data (GCAD) to the multi-core graphic pipelines implemented on the multi-core CPU chip, (iii) the Recomposition Module 403 uses the North memory bridge and interconnect network within the multi-core CPU chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multi-core graphics pipelines during the image recomposition stage, and (iv) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the North bridge chip via a display interface.
- CPD composited pixel data
- FIG. 7A 7 the sixth illustrative embodiment of the MMPGRS of present invention is shown embodied within the HMS+GPU-Recomposition Class of MMPGRS Architecture described in FIG. 7A 1 - 2 , and in copending U.S. patent application Ser. No. 11/648,160 incorporated herein by reference.
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401 , 402 respectively, of the Multimode Parallel Graphics Rendering Subsystem resides as a software package 701 in the Host or CPU Memory Space (HMS) while multiple GPUs on external GPU cards driven in parallelized manner by the modules of the software package 701 of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM, and two or more GPUs 715 , 716 are used to implement the Recomposition Module.
- HMS Host or CPU Memory Space
- the Decomposition Module 401 divides (i.e.
- the Distribution Module 402 uses the North or South bridge circuit and interconnect network to distribute graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module uses the North memory bridge and associated system bus (e.g. PCI-express bus) to transfer composited pixel data (CPD) between the GPUs during the image recomposition stage
- CPD composited pixel data
- finally recomposited pixel data sets are displayed as graphical images on one or more display devices, connected to an external graphics card via a PCI-express interface which is connected to either the North or South bridge circuits of the host computing system.
- each non-primary GPU moves its full-color composited image to the frame buffer (FB) of the primary GPU for display on the display screen of the display device.
- FB frame buffer
- the primary GPU outputs one/half of the color image in its frame buffer (FB) to the display device, while the secondary GPU moves one/half of the image in its FB to the primary GPU. Then the primary GPU does the same with the second part of the image in its frame buffer (FB).
- the recomposition involves a coordinated output of two image halves, that have been composited within the frame buffers (FBs) of two GPUs, to the frame buffer of the primary GPU (for recompositing) and ultimately display to the display device.
- FIG. 7A 7 - 1 the innovative pixel recompositing process supported within the MMPGRS of FIG. 7A 7 during its Object Division Mode will now be described in great technical detail.
- the recompositing phase/stage of the present invention involves moving the pixel Depth and Color values from the frame buffers (FB) in the secondary GPPL, to the FB in the primary GPPL (via inter-GPPL communication), and then merging these pixel values with their counterparts at the primary GPPL by means of programmable Fragment Shader supported in the pixel processing subsystem ( 211 ).
- FIG. 7A 7 - 2 describes the compositing process carried out by programmable Fragment Shader for the case where the MMPGRS employs dual GPPLs (i.e. GPUs).
- the pixel frame generating pipeline includes three basic steps, namely: the decompose 402 , distribute 403 , and render 404 stages.
- the recompose step 405 is carried out for final FB, which is finally displayed to the display device 405 .
- the Distributing step 403 is supervised by the Distribution module 505 .
- Decomposed graphics commands and data elements are sent to the Vendor's GPU Driver ( 506 ) and memory bridge ( 203 ), and delivered for rendering the primary 205 and secondary 204 graphics cards, via separate PCIexpress buses 207 , 208 .
- Rendering (step 404 ) is done simultaneously 602 , 603 in both GPPLs, creating two partial FBs.
- the compositing process (step 405 ) comprises the following substeps:
- step 405 the detailed shader program is used to composite two color textures based on the depth test conducted between the two depth textures, as shown in FIG. 7B 7 - 2 .
- the recompositing phase/stage can involve moving the pixel Depth and Color values from the frame buffers (FBs) in the secondary GPPLs, to the FB in the primary GPPL (via inter-GPPL communication), and then merging these pixel values with their counterparts at the primary GPPL by means of the programmable Vertex Shader provided in the geometry processing subsystem 210 of the primary GPPL.
- FBs frame buffers
- the recompositing phase/stage can involve moving the pixel Depth and Color values from the frame buffers (FBs) in the secondary GPPLs, to the FB in the primary GPPL (via inter-GPPL communication), and then merging these pixel values with their counterparts at the primary GPPL by means of the programmable Vertex Shader provided in the geometry processing subsystem 210 of the primary GPPL.
- the recompositing phase/stage can involve moving the pixel Depth and Color values from the frame buffers FB in the secondary GPPLs, to the FB in the primary GPPL (via inter-GPPL communication), and then merging these pixel values with their counterparts at the primary GPPL by the means of both programmable Vertex and Fragment Shaders provided in the geometry and pixel processing subsystems in the primary GPPL.
- the pixel data contained in the Frame Buffers (FB) associated with the secondary GPPLs are moved to the primary GPPL by way of an inter-GPPL communication process (e.g. the Interconnect network 404 implemented by multiple-lane PCI ExpressTM buses), and then processed within the local FB of the primary GPPL, to perform pixel image (re)composition.
- the pixel composition result is then sent to display device, and alternatively, also returned to the secondary GPPLs, if required in some applications as a basis of the next pixel frame.
- the GPPL-based recomposition process of the present invention can be implemented across two or more GPPLs using software that (i) controls the computational machinery within the GPPLs of the MMPGRS platform, and (ii) exploits the Shader (pixel) processing capabilities in the primary GPPL, with no need for any external hardware.
- the GPPL-based recomposition process of the present invention can be implemented across two or more GPPLs using hardware circuitry and/or firmware (within a graphics hub architecture of the present invention) that (i) controls the computational machinery within the GPPLs of the MMPGRS platform, and (ii) exploits the Shader (pixel) processing capabilities in the primary GPPL, as shown in FIGS. 7 B 2 , 7 B 4 - 1 , 7 B 6 - 1 , 7 B 7 - 1 , 7 B 8 - 3 , and 7 B 1 , and described below.
- FIG. 7A 7 - 3 illustrates the time-line of one complete composited pixel frame, including time slots associated with the different steps of object division rendering.
- the reuse of GPPL resources for recompositing occurs during a time slot, where the GPPL resources are generally idle during the recompose step.
- GPPL resources are used “for free” during recomposition, without sacrificing system performance.
- FIGS. 7 B 1 through 7 B 11 illustrate that the graphics hub device (GHD) of the present invention can be expressed in different ways in different MPGRS system architectures
- the function of the graphics hub device (GHD) is essentially the same, namely: (i) to interconnect the graphics-based application in memory space, with the cluster of GPUs or CPU-cores along the parallelized GPPLs; and (ii) to support the basic functionalities of the Distribution Module 402 and the Recomposition Module 403 in such MMPGRS system architectures.
- the Distribution Module resides before the cluster of GPUs or CPU-cores, delivering graphics commands and data (GCAD) for rendering (and thus functioning as a “pre GPU unit” of sorts), whereas the Recomposition Module functions logically after the cluster of GPUs, and collects post rendering data (“post GPU unit”).
- GCAD graphics commands and data
- post GPU unit post rendering data
- both the Distribution Module and the Recomposition Module typically share the same physical hardware unit (e.g. silicon chip).
- FIGS. 7 B 1 through 7 B 11 for various types of MMGPRS system architectures indicated in FIG. 7A 1 - 2 .
- FIGS. 7 B 1 through 7 B 11 the two major advantages should be pointed out when using the “graphics hub device” architecture approach of the present invention, illustrated in FIGS. 7 B 1 through 7 B 11 .
- the first advantage of the “graphics hub device” architecture is that the number of driven GPPLs in the MMPGRS is no longer limited by the number of buses provided by the memory bridge circuit employed in the CPU-based host computing system.
- the Interconnect Network 404 employed in the graphics hub device (GD) of the present invention allows (theoretically) for the connection of an unlimited number of GPUs to the Host CPU.
- the second advantage of the “graphics hub device” architecture is the high performance achieved during image recomposition using the graphic hub device architecture, thereby eliminating the need of moving the Frame Buffer (FB) pixel data from multiple GPPLs to the host or CPU memory for merging, as it is done in the system architectures illustrated in FIGS. 7 A 2 through 7 A 7 .
- the merge function is performed by fast, highly specialized hardware within the GPUs, independent of other tasks that are concurrently trying to access the main memory of the host computing system, which occurs in a multi-tasking system architectures illustrated in FIGS. 7 A 2 through 7 A 7 .
- FIG. 7B 1 the seventh illustrative embodiment of the MMPGRS of present invention is shown embodied within the Hub Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401 ′′, Distribution Module 402 ′′ and Recomposition Module 403 ′′ are realized within a single graphics hub device (e.g.
- HMS Host or CPU Memory Space
- the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North memory bridge circuit
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- CPD composited pixel data
- finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the primary GPU on the graphical display card which is connected to the graphics hub chip of the present invention via the interconnect 404 ′′.
- the eighth illustrative embodiment of the MMPGRS of present invention is shown embodied within the Hub+GPU-Recomposition Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host Memory Space (HMS) of the host computing system, while the Decomposition Submodule No. 2 401 ′′ and the Distribution Module 402 ′′ are realized within a single graphics hub device (e.g.
- the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (ii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 implemented within the primary GPU 715 , transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the primary GPU on the graphical display card(s), which are connected to the graphics hub chip of the present invention.
- FIG. 7B 3 the ninth illustrative embodiment of the MMPGRS of present invention is shown embodied within the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- HMS Host or CPU Memory Space
- the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes graphic commands and data (GCAD) to the internal GPUs via the interconnect network
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- CPD composited pixel data
- FIG. 7B 4 the tenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- HMS CPU Memory Space
- the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the communication interfaces of the North and South bridge circuits, (ii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- CPD composited pixel data
- FIG. 7B 4 - 1 the eleventh illustrative embodiment of the MMPGRS of present invention is shown embodied within the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- HMS CPU Memory Space
- the Distribution Module 402 ′′ 403 ′′ are realized (as a graphics hub) in an integrated graphics device (IGD) within the South bridge circuit of the host computing system and having a plurality of GPUs driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM, while the Recomposition Module 403 ′′ is implemented across two or more GPUs 715 , 716 .
- the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the communication interfaces of the North and South bridge circuits
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 implemented at the Primary GPU, transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- CPD composited pixel data
- FIG. 7B 5 the twelfth illustrative embodiment of the MMPGRS of present invention is shown embodied within the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- HMS CPU Memory Space
- the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- CPD composited pixel data
- FIG. 7B 6 the thirteenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- HMS Host or CPU Memory Space
- the Decomposition Submodule No. 1 transfer graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North and South bridge circuits, (ii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes the graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- CPD composited pixel data
- FIG. 7B 6 - 1 the fourteenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No.
- HMS CPU Memory Space
- the Distribution Module 402 ′′ are realized (as a graphics hub) in an integrated graphics device (IGD) within the South bridge circuit of the host computing system and having multiple GPUs driven with a single GPU on an external graphics card in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM, while the Recomposition Module 403 ′′ is implemented across two or more GPUs 715 , 716 .
- the Decomposition Submodule No. 1 transfer graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North and South bridge circuits
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes the graphic commands and data (GCAD) to the external GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- CPD composited pixel data
- FIG. 7B 7 the fifteenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- ACM Automatic Mode Control Module
- HMS CPU Memory Space
- the Distribution Module 402 ′′ and Recomposition Module 403 ′′ are realized (as a graphics hub) in an integrated graphics device (IGD) realized within the North memory bridge chip of the host computing system, and driving (i) multiple GPUs on multiple external graphics cards in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM, or alternatively (ii) controlling a single GPU aboard the IGD for driving a display device connected to the IGD via a display interface.
- the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- CPD composited pixel data
- FIG. 7B 7 - 1 the sixteenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- ACM Automatic Mode Control Module
- HMS CPU Memory Space
- the Distribution Module 402 ′′ are realized (as a graphics hub) in an integrated graphics device (IGD) realized within the North memory bridge chip of the host computing system, and driving (i) multiple GPUs on multiple external graphics cards in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM, or alternatively (ii) controlling a single GPU aboard the IGD for driving a display device connected to the IGD via a display interface, while the Recomposition Module 403 ′′ is implemented across two or more GPUs ( 715 , 716 ).
- the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No.
- the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) the Distribution Module 402 ′′ distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs, (iv) the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphic cards or the primary GPU in the IGB, as shown.
- the Distribution Module 402 distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- CPD composited pixel data
- finally recomposited pixel data sets are displayed as graphical images on one or more display devices
- FIG. 7B 8 - 1 the seventeenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the CPU/GPU Fusion Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No.
- HMS Host Memory Space
- the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage
- CPD composited pixel data
- FIG. 7B 8 - 2 the eighteenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the CPU/GPU Fusion Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- AMCM Automatic Mode Control Module
- HMS Host Memory Space
- the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the North memory bridge circuit and interconnect network within the multi-core CPU chip, (ii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 ′′ uses the crossbar switch (i.e. interconnect) on the processor die to distribute the graphic commands and data (GCAD) to the multiple soft parallel graphics pipelines (implemented by the multiple CPU cores),
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the multiple CPU cores during the image recomposition stage, and
- finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the North memory bridge chip via a display interface.
- FIG. 7B 8 - 3 the nineteenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the CPU/GPU Fusion Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- AMCM Automatic Mode Control Module
- HMS Host Memory Space
- the Distribution Module 402 ′′ are realized (as a graphics hub) in on the die of a hybrid CPU/GPU fusion-architecture chip within the host computing system and having multiple GPUs 1242 ′′ driven with one or more GPUs on an external graphics card 205 (connected to the CPU/GPU chip) in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem under the control of the AMCM, and (iii) the Recomposition Module 403 ′′ is implemented across two or more GPUs 715 , 716 provided on the CPU/GPU fusion chip die and external graphics cards.
- the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No.
- the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (vi) the Distribution Module 402 ′′ uses the crossbar switch (i.e. interconnect) on the processor die to distribute the graphic commands and data (GCAD) to the internal GPUs and external GPUs, (vii) the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (viii) finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the external graphics card connected to the hybrid CPU/GPU chip via a PCI-express interface.
- the Distribution Module 402 ′′ uses the crossbar switch (i.e. interconnect) on the processor die to distribute the graphic commands and data (GCAD) to the internal GPUs and external GPUs, (vii) the Recomposition Module 403 ′′ transfers composited pixel data (CPD)
- the twentieth illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the Multicore CPU Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ reside as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No. 2 401 ′′, Distribution Module 402 ′′ and Recomposition Module 403 ′′ are realized (as a graphics hub) on the die of a multi-core CPU chip within the host computing system.
- HMS Host Memory Space
- some of the CPU cores are used to implement multiple soft parallel graphics pipelines (“soft GPUs”) that are driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem under the control of the AMCM.
- the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the North memory bridge circuit and interconnect network within the multi-core CPU chip,
- the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time
- the Distribution Module 402 ′′ uses the crossbar switch (i.e.
- the processor die to distribute the graphic commands and data (GCAD) to the multiple soft parallel graphics pipelines (implemented by the multiple CPU cores), (iv) the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the multiple CPU cores during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the North memory bridge chip via a display interface implemented therein, as shown.
- GCAD graphic commands and data
- CPD composited pixel data
- FIG. 7B 9 - 2 the twenty-first illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the Multicore CPU Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- AMCM Automatic Mode Control Module
- HMS Host Memory Space
- the Distribution Module 402 ′′ and the Recomposition Module 403 ′′ are realized as a graphics hub within a multi-core CPU chip employed within the host computing system, having a plurality of CPU cores, some of which implement multiple soft graphics pipelines which, along with multiple GPUs supported on an external graphics card 205 , are driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem under the control of the AMCM.
- the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the interconnects within the North memory bridge chip and the multi-core CPU chip
- the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 ′′ uses the interconnect (i.e. crossbar switch) in the multi-core CPU chip to distribute the graphic commands and data (GCAD) to the multiple soft graphics pipelines (e.g.
- the Recomposition Module 403 ′′ transfers composited pixel data (CPD) between the soft graphics pipelines on the multi-core CPU chip and hard GPUs on the external graphics card during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the external graphics card which is connected to the multi-core CPU chip via a PCI-express interface.
- CPD composited pixel data
- the twenty-second illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the Game Console Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ are realized as a software package 711 within the Host Memory Space (HMS), while the Decomposition Submodule No. 2 401 ′′, the Distribution Module 402 ′′ and the Recomposition Module 403 ′ are realized as a graphics hub semiconductor chip within the game console system in which multiple GPUs are driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem under the control of the AMCM.
- HMS Host Memory Space
- the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 , via the memory controller on the multi-core CPU chip and the interconnect in the graphics hub chip of the present invention, (ii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 distributes the graphic commands and data (GCAD) to the multiple GPUs
- the Recomposition Module 403 transfers composited pixel data (CPD) between the multiple GPUs during the image recomposition stage
- recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the primary GPU 715 via a analog display interface.
- FIG. 7B 11 the twenty-third illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the Game Console Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the Profiling and Control Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401 ′ are realized as a software package 711 within the Host Memory Space (HMS) of the host computing system while the Decomposition Submodule No.
- HMS Host Memory Space
- the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 , via the memory controller on the multi-core CPU chip and the interconnect in the graphics hub chip of the present invention, (ii) the Decomposition Submodule No. 2 divides (i.e.
- the Distribution Module 402 ′ distributes the graphic commands and data (GCAD) to the multiple GPUs
- the Recomposition Module 403 ′ realized primarily within the substructure of the primary GPU, transfers composited pixel data (CPD) between the multiple GPUs during the image recomposition stage
- recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the primary GPU 715 via an analog display interface.
- FIGS. 8A through II DI there is shown a sampling of the illustrative implementations that are possible for the diverse MMPGRS designs of the present invention disclosed, taught and suggested herein.
- FIG. 8A shows an illustrative implementation of the MMPGRS of the present invention following the Hub Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- HMS host memory space
- multiple discrete graphic cards are connected to the bridge circuit of the host computing system by way of a hardware-based graphics hub chip of the present invention 404 ′′, 402 ′′, 403 ′′, 404 ′′,
- hardware-based Distribution and Recomposition Modules 402 ′′ and 403 ′′ are realized on the hardware-based graphics hub chip of the present invention, and
- a graphics display device is connected to the primary GPU.
- FIG. 8A 1 shows a first illustrative embodiment of the MMPGRS implementation of FIG. 8A , wherein a possible packaging of the Hub architecture of the present invention employs an assembly comprising a Hub-extender card 811 carrying multiple (e.g. dual) graphics cards 812 , 813 supported on a motherboard 814 within the host computing system.
- a Hub-extender card 811 carrying multiple (e.g. dual) graphics cards 812 , 813 supported on a motherboard 814 within the host computing system.
- FIG. 8A 2 shows a second illustrative embodiment of the MMPGRS implementation of FIG. 8A , wherein a possible packaging of the Hub architecture of the present invention employs an external box containing a Hub chip of the present invention mounted on a PC board, that is connected to the motherboard of the host computing system via a wire harness or the like, and supporting a plurality of graphics cards 813 that are connected to the Hub chip.
- FIG. 8A 3 shows a third illustrative embodiment of the MMPGRS implementation of FIG. 8A , wherein a possible packaging of the Hub architecture of the present invention employs a graphics hub chip of the present invention mounted on the motherboard 814 of the host computing system, which supports multiple graphics cards 813 with multiple GPUs.
- FIG. 8B shows an illustrative implementation of the MMPGRS of the present invention following the Hub+GPU-Recomposition Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the AMCM and Decomposition Submodule No. 1 are implemented as a software-package 701 within host memory space (HMS) of the host computing system,
- multiple discrete graphic cards are connected to a bridge chipset on the host computing system by way of a hardware-based graphics hub chip realizing the Decomposition No.
- FIG. 8B 1 shows a first illustrative embodiment of the MMPGRS implementation of FIG. 8B , wherein a possible packaging of the Hub+GPU Recomposition architecture of the present invention employs an assembly comprising a Hub-extender card 811 carrying multiple (e.g. dual) graphics cards 812 , 813 supported on a motherboard 814 within the host computing system.
- a Hub-extender card 811 carrying multiple (e.g. dual) graphics cards 812 , 813 supported on a motherboard 814 within the host computing system.
- FIG. 8B 2 shows a second illustrative embodiment of the MMPGRS implementation of FIG. 8B , wherein a possible packaging of the Hub architecture of the present invention employs an external box containing a Hub chip of the present invention mounted on a PC board, that is connected to the motherboard of the host computing system via a wire harness or the like, and supporting a plurality of graphics cards 813 that are connected to the Hub chip.
- FIG. 8B 3 shows a third illustrative embodiment of the MMPGRS implementation of FIG. 8B , wherein a possible packaging of the Hub architecture of the present invention employs a graphics hub chip of the present invention mounted on the motherboard 814 of the host computing system, which supports multiple graphics cards 813 with multiple GPUs.
- FIG. 8C shows an illustrative embodiment of the MMPGRS of the present invention following the HM Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the AMCM, Decomposition, Distribution and Recomposition Modules are implemented as a software-package 701 within host memory space (HMS) of the host computing system, (ii) multiple discrete GPUs on one or more graphics cards are connected to the bridge circuit on the host computing system, and (iii) a graphics display device is connected to the primary GPU.
- HMS host memory space
- FIG. 8C 1 shows a first illustrative embodiment of the MMPGRS implementation of FIG. 8C , wherein discrete multiple graphics cards 851 , each supporting at least a single GPU, are interfaced with the bridge circuit chipset of the CPU motherboard by way of a PCI-express or like interface.
- FIG. 8C 2 shows a second illustrative embodiment of the MMPGRS implementation of FIG. 8C , wherein multiple GPUs are realized on a single graphics card 852 which is interfaced to bridge circuit on the CPU motherboard by way of a PCI-express or like interface.
- FIG. 8C 3 shows a third illustrative embodiment of the MMPGRS implementation of FIG. 8C , wherein multiple discrete graphics cards 851 , each supporting at least a single GPU, are interfaced with the bridge circuit on a board within an external box 821 that is interface to the motherboard within the host computing system.
- FIG. 8D shows an illustrative embodiment of the MMPGRS of the present invention following the Hub+GPU-Recomposition Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the AMCM, Decomposition Submodule No. 1 and the Distribution Module are implemented as a software-package 701 within host memory space (HMS) of the host computing system, (ii) multiple discrete GPUs on one or more external graphics cards are connected to the bridge circuit of the host computing system, (iii) the Recomposition Module 403 ′′ is implemented across two or more GPUs, and (iv) a graphics display device is connected to the primary GPU.
- HMS host memory space
- FIG. 8D 1 shows a first illustrative embodiment of the MMPGRS implementation of FIG. 8D , wherein discrete multiple graphics cards 851 , each supporting at least a single GPU, are interfaced with the bridge circuit chipset of the CPU motherboard by way of a PCI-express or like interface.
- FIG. 8D 2 shows a second illustrative embodiment of the MMPGRS implementation of FIG. 8D , wherein multiple GPUs are realized on a single graphics card 852 which is interfaced to bridge circuit on the CPU motherboard by way of a PCI-express or like interface.
- FIG. 8D 3 shows a third illustrative embodiment of the MMPGRS implementation of FIG. 8D , wherein multiple discrete graphics cards 851 , each supporting at least a single GPU, are interfaced with the bridge circuit on a board within an external box 821 that is interface to the motherboard within the host computing system.
- FIG. 9A shows an illustrative implementation of the MMPGRS of the present invention following the Hub Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the AMCM and Decomposition Submodule No. 1 are implemented as a software package 711 on the host memory space (HMS),
- multiple GPUs i.e. Primary GPU 715 and Secondary GPUs 716
- a graphics card 902 which connects the GPUs to the bridge circuit on the host computing system by way of a hardware-based graphics hub chip implementing the Decomposition Submodule No. 2 401 ′′, the Distribution Module 402 ′′ and the Recomposition Module 403 ′′, and
- a graphics display device is connected to the primary GPU.
- FIG. 9A 1 shows an illustrative embodiment of the MMPGRS of FIG. 9A , wherein multiple GPUs ( 715 , 716 ) and hardware-based Decomposition Submodule No. 2 401 ′′, Distribution Module 402 ′′ and the Recomposition Modules 403 ′′ are implemented as a graphics hub chip or chipset 401 ′′, 402 ′, 403 ,′′ and 404′′ on a single graphics display card 902 , which is interfaced to the bridge circuit on the motherboard 814 within the host computing system.
- FIG. 10A shows an illustrative implementation of the MMPGRS of the present invention following the Hub Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the AMCM and Decomposition Submodule No. 1 are implemented as a software package 711 on the host memory space (HMS)
- HMS host memory space
- a single SOC-based graphics chip 1001 is mounted on a single graphics card 1002 interfaced with a bridge circuit on the motherboard 1002 , and supporting multiple GPUs (i.e. the primary GPU and secondary GPUs)
- the Distribution Module and the Recomposition Module are implemented on the SOC-based graphics chip 1001
- a graphics display device is connected to the primary GPU.
- FIG. 10A 1 shows a possible packaging of the SOC-based graphics hub chip ( 101 ) depicted in FIG. 10A , wherein multiple GPUs 715 , 716 and hardware-based Decomposition Submodule 401 ′′, Distribution Module 402 ′′, and Recomposition Module ( 4 - 3 ′′) are realized on a single SOC implementation 1001 mounted on a single graphics card 1002 .
- FIG. 10B shows an illustrative implementation of the MMPGRS of the present invention following the Hub+GPU-Recomposition Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the AMCM and Decomposition Submodule No. 1 are implemented as a software package 711 on the host memory space (HMS),
- HMS host memory space
- a single SOC-based graphics chip 1003 is mounted on a single graphics card 1002 interfaced with a bridge circuit on the motherboard 1002 , and supporting multiple GPUs (i.e. the primary GPU and secondary GPUs),
- the Distribution Module is implemented on the SOC-based graphics hub chip 1001 , (iv) the Recomposition Module is implemented across two or more GPUs 715 , 716 , and (v) a graphics display device is connected to the primary GPU by way of a display interface implemented on the SOC-based graphics hub chip.
- FIG. 10B 1 shows a possible packaging of the SOC-based graphics hub chip 101 depicted in FIG. 10B , wherein multiple GPUs 715 , 716 and hardware-based Decomposition Submodule 401 ′′, Distribution Module 402 ′′ are implemented in single SOC implementation 1003 mounted on a single graphics card 1002 , with the Recomposition Module ( 4 - 3 ′′) being implemented across two or more of the GPUs (e.g. on the same piece of silicon).
- FIG. 10C shows an illustrative implementation of the MMPGRS of the present invention following the HMS+GPU-Recomposition Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the AMCM, Decomposition Module and Distribution Module are implemented as a software package 701 on the host memory space (HMS),
- HMS host memory space
- a single multi-GPU chip 1031 is mounted on a single graphics card 1002 that is interfaced with a bridge circuit on the motherboard, and supporting multiple GPUs (i.e. the primary GPU and secondary GPUs)
- the Recomposition Module is implemented within two or more GPU
- a graphics display device is connected to the primary GPU by way of a display interface implemented on the multi-GPU chip.
- FIG. 10C 1 shows a possible packaging of the multi-GPU chip ( 1031 ) depicted in FIG. 10C , wherein multiple GPUs 715 , 716 and Recomposition Module 403 ′′ is implemented across two or more GPUs 715 , 716 of a multi-GPU chip ( 1031 ).
- FIG. 11A shows an illustrative implementation of the MMPGRS following the Chipset Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the AMCM and Decomposition Submodule No. 1 are realized as a software package 711 within the host memory space (HMS) of the host computing system,
- plurality of GPUs 852 on one or more external graphics cards 851 are connected to the bridge circuit on the host computing platform,
- an integrated graphics device (IGD) 1101 supporting hardware-based Decomposition Submodule No.
- the Distribution Module 402 ′′ and Recomposition Module 403 ′′ are implemented within the bridge circuit 1101 on the motherboard 814 of the host computing system, and (iv) a display device is interfaced to the primary GPU by way of a PCI-express interface or the like.
- FIG. 11A 1 shows a first illustrative embodiment of the Chipset MMPGRS implementation of FIG. 11A , wherein multiple discrete graphics cards 851 , each supporting at least a single GPU, are interfaced with the bridge circuit on a board within an external box 821 that is interface to the motherboard within the host computing system.
- FIG. 11A 1 shows a second illustrative embodiment of the Chipset MMPGRS implementation of FIG. 11A , wherein discrete multiple graphics cards 851 , each supporting at least a single GPU, are interfaced with the bridge circuit chipset of the CPU motherboard by way of a PCI-express or like interface.
- FIG. 11A 3 shows a third illustrative embodiment of the Chipset MMPGRS implementation of FIG. 11A , wherein multiple GPUs are realized on a single graphics card 852 which is interfaced to bridge circuit on the CPU motherboard by way of a PCI-express or like interface.
- FIG. 11B shows an illustrative implementation of the MMPGRS following the CPU/GPU Fusion Class of MMPGRS Architecture or Multi-Core Class MMPGRS Architecture described in FIG. 7A 1 - 2 .
- a CPU/GPU fusion-architecture chip or a multi-core CPU chip is mounted on the motherboard of a host computing system having memory and North and South bridge circuits
- AMCM and Decomposition Submodule No. 1 are realized as a software package 701 within the host memory space (HMS) of the host computing system while Decomposition Submodule No.
- the Distribution Module and the Recomposition Module are realized/implemented on the die of the CPU/GPU fusion-architecture chip or the multi-core CPU chip, and (iii) multiple GPUs on external graphic cards or elsewhere, are interfaced to the CPU/GPU fusion-architecture chip or the multi-core CPU chip, by way of a PCI-express or like interface, and (iv) a display device is interfaced to the primary GPU by way of a PCI-express interface or the like.
- FIG. 11B 1 shows a first illustrative embodiment of the CPU/GPU Fusion or Multi-Core MMPGRS implementation of FIG. 11B , wherein a CPU/GPU Fusion or Multi-Core chip is used to drive an assemble of graphic cards or GPUs on one or more external graphics cards 851 .
- FIG. 11B 2 shows a second illustrative embodiment of the Chipset MMPGRS implementation of FIG. 11B , wherein a CPU/GPU Fusion or Multi-Core chip is used to drive an assemble of GPUs on a single external graphics card 852 .
- FIG. 11B 3 shows a third illustrative embodiment of the Chipset MMPGRS implementation of FIG. 11B , wherein a CPU/GPU Fusion or Multi-Core chip is used to drive only an assemble of internal GPUs on the CPU/GPU Fusion or Multi-Core chip.
- FIG. 11C shows an illustrative implementation of the MMPGRS following the Game Console Class of MMPGRS Architecture described in FIG. 7A 1 - 2 .
- the AMCM 400 and Decomposition Submodule No. 1 401 ′ are realized as a software package within the host memory space (HMS) of the game console system,
- a graphics hub chip 401 ′′, 402 ′′, 403 ′′, 404 ′′, mounted on the PC board of the game console system implements the Decomposition Submodule No. 2 401 ′′, the Distribution Module 402 ′, the Recomposition Module 403 ′ as well as the interconnect network (e.g.
- crossbar switch 404 ′′
- multiple GPUs on the PC board of the game console system are interfaced to Distribution and Recomposition Modules by way of the interconnect network 404 ′′ within the graphics hub chip, and optionally, the Recompostion Module can be implemented across two or more GPUs 715 , 716 , and (iv) a display device 106 is interfaced to the primary GPU by way of an analog display interface or the like.
- FIG. 11C 1 shows an illustrative embodiment of the Game Console MMPGS implementation of FIG. 11D , showing its controller in combination with its game console unit.
- the MMPGRS of the Present Invention Deployed in Client Machines on Multi-User Computer Networks
- the graphics-based applications e.g. games, simulations, business processes, etc.
- 3D graphics processes which are rendered using the parallel computing principles of the present invention
- the parallel graphics rendering processes carried out using the principles of the present invention can stem from applications supported on (i) multi-CPU host computing platforms, as well as (ii) single and multiple CPU based network-based application servers.
- streams of graphics commands and data (GCAD) pertaining to the graphics-based application at hand can be generated by application server(s) in response to one or more multiple users (e.g. players) who may be either local or remote with respect to each other.
- the application servers would transmit streams of graphics commands and data to the participants (e.g. users or players) of a multi-player game.
- the client-based computing machine of each user would embody one form of the MMPGRS of the present invention, and receive the graphics commands and data streams support the client-side operations of either (i) a client-server based application (running at the remote application servers), and/or (ii) a Web-based application generated from http (Web) servers interfaced to application servers, driven by database servers, as illustrated in FIGS. 12A and 12B .
- the MMPGRS aboard each client machine on the network would support its parallel graphics rendering processes, as described in great detail hereinabove, and composited images will be displayed on the display device of the client machine.
- Display devices available to the users of a particular graphics-based application can include LCD panels, plasma display panels, LCD or DLP based multi-media projectors and the like.
- FIG. 12A shows a first illustrative embodiment of the multi-user computer network according to the present invention, comprising a plurality of client machines, wherein one or more client machines embody the MMPGRS of the present invention designed using the software-based system architecture of FIG. 7A .
- FIG. 12B a second illustrative embodiment of the multi-user computer network of the present invention, is shown comprising a plurality of client machines, wherein one or more client machines embody the MMPGRS of the present invention designed using the hardware-based system architecture of FIG. 7B .
- the application server(s) driven by one or more database servers (RDBMS) on the network, and typically supported by a cluster of communication servers (e.g.
- RDBMS database servers
- GAPs Graphic Application Profiles
- each MMPGRS is optimally programmed at all possible times so that it quickly and continuously offers users high graphics performance through its adaptive multi-modal parallel graphics operation.
- One way to help carry out this objective is to set up a Central Application/Scene Profile Database Server System on the Internet, as shown in FIGS. 12A and 12B , and support the various Internet-based application registration and profile management and delivery services, as described hereinbelow.
- the Central Application/Scene Profile Database Server System of the illustrative embodiment comprises a cluster of Web (http) servers, interfaced with a cluster of application servers, which in turn are interfaced with one or more database servers (supporting RDBMS software), well known in the art.
- the Central Application/Scene Profile Database Server System would support a Web-based Game Application Registration and Profile Management Application, providing a number of Web-based services, including:
- the Web-based Game Application Registration and Profile Management Application of the present invention would be designed (using UML techniques) and implemented (using Java or C+) so as to provide an industrial-strength system capable of serving potentially millions of client machines embodying the MMPGRS of the present invention.
- GAPs Graphic Application Profiles
- graphic application users e.g. gamers
- the MMPGRS would preferably run an application profiling and analysis algorithm that uses the most recently downloaded expert GAP loaded into its AMCM, and then allow system-user interaction, user behavior, and application performance to modify and improve the expert GAP profile over time until the next automated update occurs.
- the Application Profiling and Analysis Module in each MMGPRS subscribing to the Automatic GAP Management Service will be designed to that it modifies and improves the downloaded expert GAP within particularly set limits and constraints, and according to particular criteria, so that the expert GAP is allowed to evolve in an optimal manner, without performance regression.
- the MMPGRS of the present invention can be programmed with other modes of 3D graphics rendering (beyond traditional Object, Image and Time Division Modes), and that these new and/or extended mode of parallel operation can be based on novel ways of dividing and/or quantizing: (i) objects and/or scenery being graphically rendered; (ii) the graphical display screen (on which graphical images of the rendered object/scenery are projected); (iii) temporal aspects of the graphical rendering process; (iv) the illumination sources used during the graphical rendering process using parallel computational operations; as well as (v) various hybrid combinations of these components of the 3D graphical rendering process.
Abstract
A multi-mode parallel graphics rendering and display system supporting real-time detection of scene profile indices programmed within pre-profiled scenes of the graphics-based application. The system includes a multi-mode parallel graphics rendering subsystem (MMPGRS) having multiple graphics processing pipelines (GPPLs) and supporting multiple modes of parallel operation selected from the group consisting of object division, image division, and time division. The GPPLs support a parallel graphics rendering process that employs one or more of the object division, image division and/or time division modes of parallel operation in order to execute graphic commands and process graphics data, and render pixel-composited images containing graphics for display on a display device during the run-time of the graphics-based application. During run-time, an automatic mode controller automatically detects the scene profile indices and uses the detected scene profile indices to access corresponding mode control parameters (MCPs) from an application/scene profile database so as to determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance.
Description
- The present application is a Continuation of U.S. application Ser. No. 11/897,536 filed Aug. 30, 2007; which is a Continuation-in-Part (CIP) of the following Applications: U.S. application Ser. No. 11/789,039 filed Apr. 23, 2007; U.S. application Ser. No. 11/655,735 filed Jan. 18, 2007, which is based on Provisional Application Ser. No. 60/759,608 filed Jan. 18, 2006; U.S. application Ser. No. 11/648,160 filed Dec. 31, 2006; U.S. application Ser. No. 11/386,454 filed Mar. 22, 2006; U.S. application Ser. No. 11/340,402 filed Jan. 25, 2006, which is based on Provisional Application No. 60/647,146 filed Jan. 25, 2005; U.S. application Ser. No. 10/579,682 filed May 17, 2006, which is a National Stage Entry of International Application No. PCT/IL2004/001069 filed Nov. 19, 2004, which is based on Provisional Application Ser. No. 60/523,084 filed Nov. 19, 2003; each said patent application being commonly owned by Lucid Information Technology, Ltd., and being incorporated herein by reference as if set forth fully herein.
- 1. Field of Invention
- The present invention relates generally to the field of computer graphics rendering, and more particularly, ways of and means for improving the performance of parallel graphics rendering processes supported on multiple 3D graphics processing pipeline (GPPL) platforms associated with diverse types of computing machinery, including, but not limited, to PC-level computers, game console systems, graphics-supporting application servers, and the like.
- 2. Brief Description of the State of Knowledge in the Art
- There is a great demand for high performance three-dimensional (3D) computer graphics systems in the fields of product design, simulation, virtual-reality, video-gaming, scientific research, and personal computing (PC). Clearly a major goal of the computer graphics industry is to realize real-time photo-realistic 3D imagery on PC-based workstations, desktops, laptops, and mobile computing devices. In general, there are two fundamentally different classes of machines in the 3D computer graphics field, namely: (1) Object-Oriented Graphics Systems, wherein 3D scenes are represented as a complex of geometric objects (primitives) in 3D continuous geometric space, and 2D views or images of such 3D scenes are computed using geometrical projection, ray tracing, and light scattering/reflection/absorption modeling techniques, typically based upon laws of physics; and (2) VOlume ELement (VOXEL) Graphics Systems, wherein 3D scenes and objects are represented as a complex of voxels (x,y,z volume elements) represented in 3D Cartesian Space, and 2D views or images of such 3D voxel-based scenes are also computed using geometrical projection, ray tracing, and light scattering/reflection/absorption modeling techniques, again typically based upon laws of physics. Examples of early GDL-based graphics systems are disclosed in U.S. Pat. No. 4,862,155, whereas examples of early voxel-based 3D graphics systems are disclosed in U.S. Pat. No. 4,985,856, each incorporated herein by reference in its entirety. In the contemporary period, most PC-based computing systems include a 3D graphics subsystem based the “Object-Orient Graphics” system design. In such graphics system design, “objects” within a 3D scene are represented by 3D geometrical models, and these geometrical models are typically constructed from continuous-
type 3D geometric representations including, for example, 3D straight line segments, planar polygons, polyhedra, cubic polynomial curves, surfaces, volumes, circles, and quadratic objects such as spheres, cones, and cylinders (i.e. geometrical data and commands). These 3D geometrical representations are used to model various parts of the 3D scene or object, and are expressed in the form of mathematical functions evaluated over particular values of coordinates in continuous Cartesian space. Typically, the 3D geometrical representations of the 3D geometric model are stored in the format of a graphical display list (i.e. a structured collection of 2D and 3D geometric primitives). Currently, planar polygons, mathematically described by a set of vertices, are the most popular form of 3D geometric representation. - Once modeled using continuous 3D geometrical representations, the 3D scene is graphically displayed (as a 2D view of the 3D geometrical model) along a particular viewing direction, by repeatedly scan-converting the stream of graphics commands and data (GCAD). At the current state of the art, the scan-conversion process can be viewed as a “computational geometry” process which involves the use of (i) a geometry processor (i.e. geometry processing subsystem or engine) as well as a pixel processor (i.e. pixel processing subsystem or engine) which together transform (i.e. project, shade and color) the graphics objects and bit-mapped textures, respectively, into an unstructured matrix of pixels. The composed set of pixel data is stored within a 2D frame buffer (i.e. Z buffer) before being transmitted to and displayed on the surface of a display screen.
- A video processor/engine refreshes the display screen using the pixel data stored in the 2D frame buffer. Any changes in the 3D scene requires that the geometry and pixel processors repeat the whole computationally-intensive pixel-generation pipeline process, again and again, to meet the requirements of the graphics application at hand. For every small change or modification in viewing direction of the human system user, the graphical display list must be manipulated and repeatedly scan-converted. This, in turn, causes both computational and buffer contention challenges which slow down the working rate of the graphics system. To accelerate this computationally-intensive graphics processing pipeline process, custom hardware including geometry, pixel and video engines, have been developed and incorporated into most conventional graphics system designs.
- In order to render a 3D scene (from its underlying graphics commands and data) and produce high-resolution graphical projections for display on a display device, such as a LCD panel, early 3D graphics systems attempted to relieve the host CPU of computational loading by employing a single graphics pipeline comprising a single graphics processing unit (GPU), supported by video memory.
- As shown in FIGS. 1A1, 1A2 and 1A3, a typical PC based graphic architecture has an
external graphics card 105 comprising a graphics processing unit (GPU) and video memory. As shown, the graphic card is connected to thedisplay 106 on one side, and theCPU 101 through bus (e.g. PCI-Express) 107 and Memory Bridge 103 (termed also “chipset”, e.g. 975 by Intel), on the other side. As shown inFIG. 1A 3, the host CPU program/memory space stores the graphics applications, the standard graphics library, and the vendor's GPU drivers. - As shown in FIGS. 1B1, 1B2 and 1B3, a typical prior art PC-based computing system employs a conventional graphics architecture employing a North memory bridge with an integrated graphics device (IGD) 103. The IGD supports a single graphics pipeline process, and is operably coupled to a South bridge, via a PCI-express bus, for supporting the input/output ports of the system. As shown, the IGD includes a video engine, a 2D engine, a 3D engine, and a display engine.
- As shown in
FIG. 1B 4, a prior art PC-based computing system employs a conventional Fusion-type CPU/GPU hybrid architecture, wherein a single GPU implemented on the same die as the CPU is used to support a graphics pipeline that drives an external display device. As shown, the motherboard supports the processor die, memory, a bridge with a display interface for connecting to adisplay device 106, and a PCI-express bus. As shown, the processor die supports aCPU 1241, aGPU 1242, L2 cache, buffers, an Interconnect (e.g. crossbar switch), a hyper transport mechanism and a memory controller. - As shown in
FIG. 1C , the process of rendering three successive frames by a single GPU is graphically illustrated. Notably, this graphical rendering process may be supported using any of the single GPU-based computing systems described above. During operation, the application, assisted by the graphics library, creates a stream of graphics commands and data describing a 3D scene. The stream is then pipelined through the GPU's geometry and pixel subsystems so as to create a bitmap of pixels in the Frame Buffer, and finally a rendered image of the scene is displayed on a display screen. The generation of a sequence of successive frames produces a visual illusion of a dynamic picture. - While the performance of single-GPU powered computing systems have greatly improved in As shown in
FIG. 1B 5, the structure of aGPU subsystem 124 on a graphics card or in an IGD comprises: a video memory which is external to GPU, and two 3D engines: (i) a transform bound geometry subsystem 224 for processing 3D graphics primitives; (ii) and a fill bound pixel subsystem 225. The video memory shares its storage resources amonggeometry buffer 222 through which all geometric (i.e. polygonal) data is transferred, commands buffer,texture buffers 223, and Frame Buffer 226. - Limitations of a single graphics pipeline arise from its typical bottlenecks. The first
potential bottleneck 221 stems from transferring data from CPU to GPU. Two other bottlenecks are video memory related: geometrydata memory limits 222, and texturedata memory limits 223. There are two additional bottlenecks inside the GPU: transform bound 224 in the geometry subsystem, and fragment rendering 225 in pixel subsystem. These bottlenecks determine overall throughput. In general, the bottlenecks vary over the course of a graphics application. - In high-performance graphics applications, the number of computations required to render a 3D scene and produce high-resolution graphical projections, greatly exceeds the capabilities of systems employing a single GPU graphics subsystem. Consequently, the use of parallel graphics pipelines, and multiple graphics processing units (GPUs), have become the rule for high-performance graphics system architecture and design, in order to relieve the overload presented by the different bottlenecks associated with single GPU graphics subsystems.
- In
FIG. 2A , there is shown an advanced chipset (e.g. Bearlake by Intel) having twobuses 107, 108 instead of one, and allowing the interconnection of two external graphics cards in parallel:primary card 105 andsecondary card 104, to share the computation load associated with the 3D graphics rendering process. As shown, thedisplay 106 is attached to theprimary card 105. It is anticipated that even more advanced commercial chipsets with greater than two buses will appear in the future, allowing the interconnection of more than two graphic cards. - As shown in
FIG. 2B , the general software architecture of prior art graphic system 200 comprises: the graphics application 201, standard graphics library 202, and the vendor's GPU drivers (203). This graphic software environment resides in the “program space” ofmain memory 102 on the host computer system. As shown, the graphic application 201 runs in the program space (i.e. memory space), building up the 3D scene, typically as a data base of polygons, where each polygon is represented as a set of vertices. The vertices and others components of these polygons are transferred to the graphic card(s) for rendering, and displayed as a 2D image, on the display screen. - In
FIG. 2C , the structure of a GPU subsystem on the graphics card is shown comprising: a video memory disposed external to the GPU, and two 3D engines: (i) a transform bound geometry subsystem 224 forprocessing 3D graphics primitives; and (ii) a fill bound pixel subsystem 225. The video memory shares its storage resources amonggeometry buffer 222, through which all geometric (i.e. polygonal) data is transferred to the commands buffer, texture buffers 223, and Frame Buffer FB 226. - As shown in
FIG. 2C , the division of graphics data among GPUs reduces (i) thebottleneck 222 posed by the video memory footprint at each GPU, (ii) the transform bound processing bottleneck 224, and (iii) the fill bound processing bottleneck 225. - However, when using a multiple GPU graphics architecture of the type shown in
FIGS. 2A through 2C , there is a need to distribute the computational workload associated with interactive parallel graphics rendering processes. To achieve this objective, two different kind of parallel rendering methods have been applied to PC-based dual GPU graphics systems of the kind illustrated inFIGS. 2A through 2C , namely: the Time Division Method of Parallel Graphics Rendering illustrated inFIG. 2D ; and the Image Division Method of Parallel Graphics Rendering illustrated inFIG. 2E . - Notably, a third type of method of parallel graphics rendering, referred to as the Object Division Method, has been developed over the years and practiced exclusively on complex computing platforms requiring complex and expensive hardware platforms for compositing the pixel output of the multiple graphics processing pipelines (GPPLs). The Object Division Method, illustrated in
FIG. 3A , can be found applied on conventional graphics platforms of the kind shown inFIG. 3 , as well as on specialized graphics computing platforms as described in US Patent Application Publication No. US 2002/0015055, assigned to Silicon Graphics, Inc. (SGI), published on Feb. 7, 2002, and incorporated herein by reference. - While the differences between the Image, Frame and Object Division Methods of Parallel Graphics Rendering will be described below, it will be helpful to first briefly describe the five (5) basic stages or phases of the parallel graphics rendering process, which all three such methods of parallel rendering have in common, namely:
- (1) the Decomposition Phase, wherein the 3D scene or object is analyzed and its corresponding graphics display list data and commands are assigned to particular graphics pipelines available on the parallel multiple GPU-based graphics platform;
- (2) the Distribution Phase, wherein the graphics data and commands are distributed to particular available graphics processing pipelines determined during the Decomposition Phase;
- (3) the Rendering Phase, wherein the geometry processing subsystem/engine and the pixel processing subsystem/engine along each graphics processing pipeline of the parallel graphics platform uses the graphics data and commands distributed to its pipeline, and transforms (i.e. projects, shades and colors) the graphics objects and bit-mapped textures into a subset of unstructured matrix of pixels;
- (4) the Recomposition Phase, wherein the parallel graphics platform uses the multiple sets of pixel data generated by each graphics pipeline to synthesize (or compose) a final set of pixels that are representative of the 3D scene (taken along the specified viewing direction), and this final set of pixel data is then stored in a frame buffer (FB); and
- (5) the Display Phase, wherein the final set of pixel data retrieved from the frame buffer, and provided to the screen of the device of the system.
- As will be explained below with reference to
FIGS. 3B through 3D , each of these three different methods of parallel graphics rendering has both advantages and disadvantages. - Image Division Method of Parallel Graphics Rendering
- As illustrated in
FIG. 2D , the Image Division (Sort-First) Method of Parallel Graphics Rendering distributes all graphics display list data and commands to each of the graphics pipelines, and decomposes the final view (i.e. projected 2D image) in Screen Space, so that, each graphical contributor (e.g. graphics pipeline and GPU) renders a 2D tile of the final view. This mode has a limited scalability due to the parallel overhead caused by objects rendered on multiple tiles. There are two image domain modes, all well known in prior art. They differ by the way the final image is divided among GPUs. - (1) The Split Frame Rendering mode divides up the screen among GPUs by continuous segments. e.g. two GPUs each one handles about one half of the screen. The exact division may change dynamically due to changing load across the screen image. This method is used in nVidia's SLI™ multiple-GPU graphics product.
- (2) Tiled Frame Rendering mode divides up the image into small tiles. Each GPU is assigned tiles that are spread out across the screen, contributing to good load balancing. This method is implemented by ATI's Crossfire™ multiple GPU graphics card solution.
- In image division, the entire database is broadcast to each GPU for geometric processing. However, the processing load at each Pixel Subsystem is reduced to about 1/N. This way of parallelism relieves the fill bound bottleneck 225. Thus, the image division method ideally suits graphics applications requiring intensive pixel processing.
- Time Division (DPlex) Method of Parallel Graphics Rendering
- As illustrated in
FIG. 2F , the Time Division (DPlex) Method of Parallel Graphics Rendering distributes all display list graphics data and commands associated with a first scene to the first graphics pipeline, and all graphics display list data and commands associated with a second/subsequent scene to the second graphics pipeline, so that each graphics pipeline (and its individual rendering node or GPU) handles the processing of a full, alternating image frame. Notably, while this method scales very well, the latency between user input and final display increases with scale, which is often irritating for the user. Each GPU is give extra time of N time frames (for N parallel GPUs) to process a frame. Referring toFIG. 3 , the released bottlenecks are those of transform bound 224 at geometry subsystem, and fill bound 225 at pixel subsystem. Though, with large data sets, each GPU must access all of the data. This requires either maintaining multiple copies of large data sets or creating possible access conflicts to the source copy at the host swelling up thevideo memory bottlenecks data transfer bottleneck 221. - Object Division (Sort-Last) Method of Parallel Graphics Rendering
- As illustrated in
FIG. 3B , the Object Division (Sort-Last) Method of Parallel Graphics Rendering decomposes the 3D scene (i.e. rendered database) and distributes graphics display list data and commands associated with a portion of the scene to the particular graphics pipeline (i.e. rendering unit), and recombines the partially rendered pixel frames, during recomposition. The geometric database is therefore shared among GPUs, reducing the load on the geometry buffer, the geometry subsystem, and even to some extent, the pixel subsystem. The main concern is how to divide the data in order to keep load balance. An exemplary multiple-GPU platform ofFIG. 3B for supporting the object-division method is shown inFIG. 3A . The platform requires complex and costly pixel compositing hardware which prevents its current application in a modern PC-based computer architecture. - Today, real-time graphics applications, such as advanced video games, are more demanding than ever, utilizing massive textures, abundance of polygons, high depth-complexity, anti-aliasing, multi-pass rendering, etc., with such robustness growing exponentially over time.
- Conventional PC-level dual-mode parallel graphics systems employing multiple-GPUs, such as nVidia's SLI™ multiple-GPU graphics platform, support either the Time Division Mode (termed Alternate Frame Rendering) of parallelism, or the Image Division Mode (termed Split Frame Rendering) of parallelism, which is automatically selected during application set-up (e.g. by the vendor's driver). However, once a graphics-based application is set-up and the time or image division mode of parallel operation selected, the selected mode of parallel operation is fixed during application run-time.
- Clearly, conventional PC-based graphics systems fail to address the dynamically changing needs of modern graphics applications. By their very nature, prior art PC-based graphics systems are unable to resolve the variety of bottlenecks (e.g. geometry limited, pixel limited, data transfer limited, and memory limited) summarized in
FIG. 1, that dynamically arise along 3D graphic pipelines. Consequently, such prior art graphics systems are often unable to maintain a high and steady level of performance throughout a particular graphics application.3C - Indeed, a given graphics processing pipeline along a parallel graphics rendering system is only as strong as the weakest link of it stages, and thus a single bottleneck determines the overall throughput along the graphics pipelines, resulting in unstable frame-rate, poor scalability, and poor performance.
- And while each parallelization mode described above and summarized in
FIG. 2 solves only part of the bottleneck dilemma currently existing along the PC-based graphics pipelines, no one parallelization method, in and of itself, is sufficient to resolve all bottlenecks in demanding graphics applications, and enable quantum leaps in graphics performance necessary for photo-realistic imagery demanded in real-time interactive graphics environments.3C - Thus, there is a great need in the art for a new and improved way of and means for practicing parallel 3D graphics rendering processes in modern multiple-GPU based computer graphics systems, while avoiding the shortcomings and drawbacks of such prior art methodologies and apparatus.
- Accordingly, a primary object of the present invention is to provide a new and improved method of and apparatus for practicing parallel 3D graphics rendering processes in modern multiple-GPU based computer graphics systems, while avoiding the shortcomings and drawbacks associated with prior art apparatus and methodologies.
- Another object of the present invention is to provide a novel multi-mode parallel graphics rendering system (MMPGRS) embodied within a host computing system having (i) host memory space (HMS) for storing one or more graphics-based applications and a graphics library for generating graphics commands and data (GCAD) during the run-time (i.e. execution) of the graphics-based application, (ii) one or more CPUs for executing said graphics-based applications, and (iii) a display device for displaying images containing graphics during the execution of said graphics-based applications.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system comprising: a multi-mode parallel graphics rendering subsystem supporting multiple modes of parallel operation selected from the group consisting of object division, image division, and time division; a plurality of graphic processing pipelines (GPPLs) supporting a parallel graphics rendering process that employs one of the object division, image division and/or time division modes of parallel operation in order to execute graphic commands and process graphics data (GCAD) render pixel-composited images containing graphics for display on a display device during the run-time of the graphics-based application; and an automatic mode control module (AMCM) for automatically controlling the mode of parallel operation during the run-time of the graphics-based application.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein the automatic mode control module employs the profiling of scenes in said graphics-based application.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein the automatic mode control module employs the profiling of scenes in the graphics-based application, on an image frame by image frame basis.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein the profiling of scenes in the graphics-based application, is carried out in real-time, during run-time of the graphics-based application, on an image frame by image frame basis.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein said real-time profiling of scenes in the graphics-based application involves (i) collecting and analyzing performance data associated with the MMPGRS and the host computing system, during application run-time, (ii) constructing scene profiles for the image frames associated with particular scenes in the particular graphics-based application, and (iii) maintaining the scene profiles in a application/scene profile database that is accessible to the automatic mode control module during run-time, so that during the run-time of the graphics-based application, the automatic mode control module can access and use the scene profiles maintained in the application/scene profile database and determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein the automatic mode control module employs real-time detection of scene profile indices directly programmed within pre-profiled scenes of the graphics-based application; wherein the pre-profiled scenes are analyzed prior to run-time, and indexed with the scene profile indices; and wherein and mode control parameters (MCPs) corresponding to the scene profile indices, are stored within an application/scene profile database accessible to the automatic mode control module during application run-time.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein during run-time, the automatic mode control module automatically detects the scene profile indices and uses the detected said scene profile indices to access corresponding MCPs from the application/scene profile database so as to determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein the automatic mode control module employs real-time detection of mode control commands (MCCs) directly programmed within pre-profiled scenes of the graphics-based application; wherein the pre-profiled scenes are analyzed prior to run-time, and the MCCs are directly programmed within the individual image frames of each scene; and wherein during run-time, the automatic mode control module automatically detects the MCCs along the graphics command and data stream, and uses the MCCs so as to determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein the automatic mode control module employs a user interaction detection (UID) mechanism for real-time detection of the user's interaction with the host computing system.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, wherein, in conjunction with scene profiling, the automatic mode control module also uses said UID mechanism to determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance, at any instance in time during run-time of the graphics-based application.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system (MMPGRS), having multiple graphics processing pipelines (GPPLs) with multiple GPUs supporting a parallel graphics rendering process having time, frame and object division modes of operation, wherein each GPPL comprises video memory and a GPU having a geometry processing subsystem and a pixel processing subsystem, and wherein 3D scene profiling is performed in real-time, and the parallelization state/mode of the system is dynamically controlled to meet graphics application requirements.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering and display system having multiple graphics processing pipelines (GPPLs), each having a GPU and video memory, and supporting multiple modes of parallel graphics rendering using real-time graphics application profiling and automatic configuration of the multiple graphics processing pipelines supporting multiple modes of parallel graphics rendering, including a time-division mode, a frame-division mode, and an object-division mode of parallel operation.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering and display system, which is capable of dynamically handling bottlenecks that are automatically detected during any particular graphics application running on the host computing system.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system, wherein different parallelization schemes are employed to reduce pipeline bottlenecks, and increase graphics performance.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system, wherein image, time and object division methods of parallelization are implemented on the same parallel graphics platform.
- Another object of the present invention is to provide a method of multi-mode parallel graphics rendering that can be practiced on a multiple GPU-based PC-level graphics system, and which, during application run-time, dynamically alternates among Time, Frame/Image and Object division modes of parallel operation, adapting the optimal method of parallel operation to the real time needs of the graphics application.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system, which is capable of supervising the performance level of a graphic application by dynamically adapting different parallelization schemes to solve instantaneous bottlenecks along the graphic pipelines thereof.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system, having run-time configuration flexibility for various parallel schemes to achieve the best system performance.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system having architectural flexibility and real-time profiling and control capabilities which enable utilization of different modes of parallel operation for high and steady performance along the application running on the associated host system.
- Another object of the present invention is to provide a novel method of multi-mode parallel graphics rendering on a multiple GPU-based graphics system, which achieves improved system performance by using adaptive parallelization of multiple graphics processing units (GPUs), on conventional and non-conventional platform architectures, as well as on monolithic platforms, such as multiple GPU chips or integrated graphic devices (IGD).
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, wherein bottlenecks are dynamically handled.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system, wherein stable performance is maintained throughout course of a graphics application.
- Another object of the present invention to provide a multi-mode parallel graphics rendering system supporting software-based adaptive graphics parallelism for the best performance, seamlessly to the graphics application, and compliant with graphic standards (e.g. OpenGL and Direct3D).
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, wherein all parallel modes are implemented in a single architecture.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, wherein the architecture is flexible, supporting fast inter-mode transitions.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system which is adaptive to changing to meet the needs of any graphics application during the course of its operation.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system which employs a user interaction detection (UID) subsystem for enabling the automatic and dynamic detection of the user's interaction with the host computing system.
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system, continuously processes user-system interaction data, and automatically detects user-system interactivity (e.g. mouse click, keyboard depression, eye-movement, etc).
- Another object of the present invention is to provide such a multi-mode parallel graphics rendering system the system, wherein absent preventive conditions (such as CPU bottlenecks and need for the same FB in successive frames), the user interaction detection (UID) subsystem enables timely implementation of the Time Division Mode only when no user-system interactivity is detected so that system performance is automatically optimized.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be implemented using a software implementation of present invention.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be realized using a hardware implementation.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, can be realized as chip implementation.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be realized as an integrated monolithic implementation.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be implemented using IGD technology.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, characterized by run-time configuration flexibility for various parallel schemes to achieve the best parallel performance.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system that operates seamlessly to the application and is compliant with graphic standards (e.g. OpenGL and Direct3D).
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be implemented on conventional multi-GPU platforms replacing image division or time division parallelism.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which enables the multiple GPU platform vendors to incorporate the solution in their systems supporting only image division and time division modes of operation.
- Another object of the present invention is to provide such multiple GPU-based graphics system, which enables implementation using low cost multi-GPU cards.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system implemented using IGD technology, and wherein it is impossible for the IGD to get disconnected by the BIOS when an external graphics card is connected and operating.
- Another object of the present invention is to provide a multiple GPU-based graphics system, wherein a new method of dynamically controlled parallelism improves the system's efficiency and performance.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be implemented using an IGD supporting more than one external GPU.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which can be implemented using an IGD-based chipset having two or more IGDs.
- Another object of the present invention is to provide a multi-mode parallel graphics rendering system, which employs a user interaction detection (UID) subsystem that enables automatic and dynamic detection of the user's interaction with the system, so that absent preventive conditions (such as CPU bottlenecks and need for the same FB in successive frames), this subsystem enables timely implementation of the Time Division Mode only when no user-system interactivity is detected, thereby achieving the highest performance mode of parallel graphics rendering at runtime, and automatically optimizing the graphics performance of the host computing system.
- Another object of the present invention is to provide a parallel graphics rendering system employing multiple graphics processing pipelines supporting the object division mode of parallel graphics rendering using pixel processing resources provided therewithin.
- Another object of the present invention is to provide a parallel graphics rendering system for carrying out the object division method of parallel graphics rendering on multiple GPU-based graphics platforms associated with diverse types of computing machinery.
- Another object of the present invention is to provide a novel method having multiple graphics processing pipelines (GPPLs) with multiple GPUs or CPU-cores supporting a parallel graphics rendering process having an object division mode of operation, wherein each GPPL includes video memory, a geometry processing subsystem, and a pixel processing subsystem, wherein pixel (color and z depth) data buffered in the video memory of each GPPL is communicated to the video memory of a primary GPPL, and wherein the video memory and the pixel processing subsystem in the primary GPPL are used to carry out the image recomposition phase of the object division mode of parallel graphics rendering process.
- Another object of the present invention is to provide a parallel graphics rendering system having multiple graphics processing pipelines (GPPLs) with multiple GPUs or CPU-cores supporting a parallel graphics rendering process having an object division mode of operation, wherein each GPU comprises video memory, a geometry processing subsystem and a pixel processing subsystem, wherein pixel (color and z depth) data buffered in the video memory of each GPPL is communicated to the video memory of a primary GPPL, and wherein the video memory and the pixel processing subsystem in the primary GPPL are used to carry out the image recomposition phase of the object division mode of the parallel graphics rendering process.
- Another object of the present invention is to provide a parallel graphics rendering system having multiple graphics processing pipelines (GPPLs) with multiple GPUs supporting a parallel graphics rendering process having an object division mode of operation, wherein each GPU comprises video memory, a geometry processing subsystem and a pixel processing subsystem, wherein pixel (color and z depth) data buffered in the video memory of each GPU is communicated to the video memory of a primary GPU, and wherein the video memory and both the geometry and pixel processing subsystems in the primary GPU are used to carry out the image recomposition phase of the object division mode of parallel graphics rendering process.
- Another object of the present invention is to provide a parallel rendering graphics system having multiple graphics processing pipelines (GPPLs) with multiple GPUs supporting a parallel graphics rendering process having an object division mode of operation, wherein the video memory of each GPPL includes texture memory and a pixel frame buffer, wherein the geometry processing subsystem includes a vertex shading unit, wherein the pixel processing subsystem includes a fragment/pixel shading unit, wherein pixel (color and z depth) data buffered in the video memory of each GPPL is communicated to the video memory of a primary GPPL, and wherein the texture memory and the fragment/pixel shading unit are used to carry out the image recomposition phase of the object division mode of the parallel graphics rendering process.
- Another object of the present invention is to provide a parallel graphics rendering system having multiple graphics processing pipelines (GPPLs) with multiple GPUs supporting a parallel graphics rendering process having an object division mode of operation, wherein the video memory of each GPPL includes texture memory and a pixel frame buffer, wherein the geometry processing subsystem includes a vertex shading unit, wherein the pixel processing subsystem includes a fragment/pixel shading unit, wherein pixel (color and z depth) data buffered in the video memory of each GPPL is communicated to the video memory of a primary GPPL, and wherein the texture memory and the vertex shading unit are used to carry out the image recomposition phase of the object division mode of the parallel graphics rendering process.
- Another object of the present invention is to provide a parallel graphics rendering system having multiple graphics processing pipelines (GPPLs) with multiple GPUs supporting a parallel graphics rendering process having an object division mode of operation, which does not require compositing in main, shared or distributed memory of the host computing system (e.g. involving the movement of pixel data from the frame buffers or FBs to main memory, processing the pixel data in the CPU of the host for composition, and moving the result out to the primary GPPL for display) thereby avoiding the use of expensive procedure and resources of the system (e.g. buses, caches, memory, and CPU bandwidth).
- Another object of the present invention is to provide a novel method of operating a parallel graphics rendering system having multiple graphics processing pipelines (GPPLs) with multiple GPUs supporting a parallel graphics rendering process having an object division mode of operation, wherein implementation of the pixel composition phase of the parallel graphics rendering process is carried out using the computational resources within the GPUs, thereby avoiding the need for dedicated or specialized pixel image compositing hardware and/or software based apparatus.
- Another object of the present invention is to provide a novel method of object division parallel graphics rendering carried out on a multi-mode parallel graphics rendering system (MMPGRS) or platform supporting multiple graphical processing pipelines (GPPLs) with multiple graphical processing units (GPUs), wherein the recomposition stage of the rendering process is carried out using computational resources (e.g. video memory and the geometry and/or pixel processing subsystems/engines) supplied by the GPPLs employed on the MMPGRS platform.
- Another object of the present invention is to provide a novel method of object division parallel rendering of pixel-composited images for graphics-based applications running on a host computing system embodying a multi-mode parallel graphics rendering system or platform (MMPGRS), wherein the movement and merging of composited pixel data occurs during the recomposition stage of the parallel graphics rendering process in a manner that is transparent to the graphics-based application.
- Another object of the present invention is to provide a novel parallel rendering graphics system having multiple graphics processing pipelines (GPPLs) supporting a parallel graphics rendering process having an object division mode of operation, wherein each GPPL comprises video memory, a geometry processing subsystem and a pixel processing subsystem, wherein pixel (color and z depth) data buffered in the video memory of each GPPL is communicated (via an inter-GPPL communication process) to the video memory of a primary GPPL, and wherein the video memory and the geometry and/or pixel processing subsystems in the primary GPPL are used to carry out the image recomposition phase of the object division mode of the parallel graphics rendering process.
- Another object of the present invention is to provide a novel parallel graphics rendering system supporting multiple modes of parallel operation during graphical rendering, which allows users to enjoy sharp videos and photos, smooth video playback, astonishing effects, and vibrant colors, as well as texture-rich 3D performance in next-generation games.
- Another object of the present invention is to provide a novel multi-user computer network supporting a plurality of client machines, wherein each client machine employs the MMPGRS of the present invention based on a software architecture and responds to user-interaction input data streams from one or more network users who might be local to each other as over a LAN, or be remote to each other, as when operating over a WAN or the Internet infrastructure.
- Another object of the present invention is to provide a novel multi-user computer network supporting a plurality of client machines, wherein each client machine employs the MMPGRS of the present invention based on a hardware architecture and responds to user-interaction input data streams from one or more network users who might be local to each other as over a LAN, or be remote to each other, as when operating over a WAN or the Internet infrastructure.
- Another object of the present invention is to provide an Internet-based central application profile database server system for automatically updating, over the Internet, graphic application profiles (GAPs) within the MMPGRS of client machines.
- Another object of the present invention is to provide such Internet-based Central Application Profile Database Server System which ensures that each MMPGRS is optimally programmed at all possible times so that it quickly and continuously offers users high graphics performance through its adaptive multi-modal parallel graphics operation.
- Another object of the present invention is to provide such an Internet-based Central Application Profile Database Server System which supports a Web-based Game Application Registration and Profile Management Application, that provides a number of Web-based services, including:
- (1) the registration of Game Application Developers within the RDBMS of the Server System;
- (2) the registration of game applications with the RDBMS of the Central Application Profile Database Server System, by registered game application developers;
- (3) the registration of each MMPGRS deployed on a client machine or server system having Internet-connectivity, and requesting subscription to periodic/automatic Graphic Application Profile (GAP) Updates (downloaded to the MMPGRS over the Internet) from the Central Application Profile Database Server System; and
- (4) the registration of each deployed MMPGRS requesting the periodic uploading of its Game Application Profiles (GAPS)—stored in an Application/Scene Profile Database and Historical Repository—to the Central Application Profile Database Server System for the purpose of automated analysis and processing so as to formulate “expert” Game Application Profiles (GAPs) that have been based on robust user-experience and which are optimized for particular client machine configurations.
- Another object of the present invention is to provide such an Internet-based Central Application Profile Database Server System that enables the MMGPRS of registered client computing machines to automatically and periodically upload, over the Internet, Graphic Application Profiles (GAPs) for storage and use within the Application/Scene Profile Database of the MMPGRS.
- Another object of the present invention is to provide such an Internet-based Central Application Profile Database Server System which, by enabling the automatic uploading of expert GAPs into the MMPGRS, graphic application users (e.g. gamers) can immediately enjoy high performance graphics on the display devices of their client machines, without having to develop a robust behavioral profile based on many hours of actual user-system interaction.
- Another object of the present invention is to provide such an Internet-based Central Application Profile Database Server System, wherein “expert” GAPs are automatically generated by the Central Application Profile Database Server System by analyzing the GAPs of thousands of different game application users connected to the Internet, and participating in the system.
- Another object of the present invention is to provide such an Internet-based Central Application Profile Database Server System, wherein for MMPGRS users subscribing to the Automatic GAP Management Services, each such MMPGRS runs an application profiling and control algorithm that uses the most recently uploaded expert GAP loaded into its automatic mode control mechanism (AMCM), and then allow system-user interaction, user behavior, and application performance to modify the expert GAP profile over time until the next update occurs.
- Another object of the present invention is to provide such an Internet-based Central Application Profile Database Server System, wherein the Application Profiling and Analysis Module in each MMGPRS subscribing to the Automatic GAP Management Services supported by the Central Application Profile Database Server System of the present invention, modifies and improves the downloaded expert GAP within particularly set limits and constraints, and according to particular criteria, so that the expert GAP is allowed to evolve in an optimal manner, without performance regression.
- These and other objects of the present invention will become apparent hereinafter and in the claims to invention.
- For a more complete understanding of how to practice the Objects of the Present Invention, the following Detailed Description of the Illustrative Embodiments can be read in conjunction with the accompanying Drawings, briefly described below:
-
FIG. 1 is a graphical representation of a typical prior art PC-based computing system employing a conventional graphics architecture driving a single external1A graphic card 105; -
FIG. 1A 2 a graphical representation of a conventional GPU subsystem supported on the graphics card of the PC-based graphics system ofFIG. 1;1A -
FIG. 3 is a graphical representation illustrating the general software architecture of the prior art computing system shown in1A FIG. 2;1A -
FIG. 1 is a graphical representation of a typical prior art PC-based computing system employing a conventional graphics architecture employing a North memory bridge circuit (i.e. semiconductor chip of monolithic construction) with an integrated graphics device (IGD) 103 supporting a single graphics pipeline process, and being operably coupled to a South bridge circuit (i.e. semiconductor chip of monolithic construction) supporting the input/output ports of the system;1B -
FIG. 2 is graphical representation of the North memory bridge employed in the system of1B FIG. 1, showing in greater detail the micro-architecture of the IGD supporting the single graphics pipeline process therewithin;1B -
FIG. 3 is a graphical representation illustrating the general software architecture of the prior art PC-based IGD-driven computing system shown in FIGS. 1B1 and 1B2;1B -
FIG. 4 is a graphical representation of a prior art PC-based computing system employing a conventional Fusion-type CPU/GPU hybrid architecture, wherein a1B single GPU 1242 implemented on the same semiconductor die as theCPU 1241 is used to support a graphics pipeline that drives an external display device, e.g. LCD panel, projection display or the like 106, via a bridge circuit, with display interface, as shown; -
FIG. 5 is a schematic representation showing the structure of a prior art GPU subsystem mounted on a graphics card or in an IGD, and comprising a GPU, and a video memory which is external to the GPU, wherein the GPU has includes two 3D engines, namely, (i) a transform bound1B geometry subsystem 124 forprocessing 3D graphics primitives 121, and (ii) and a fill boundpixel subsystem 125, and wherein the video memory shares its storage resources among ageometry buffer 122A through which all geometric (i.e. polygonal)data 121 is transferred, acommands buffer 122B, texture buffers 123, and aFrame Buffer 126; -
FIG. 1C is a graphical representation illustrating a conventional process for rendering successive 3D scenes using a single GPU graphics platform to support a single graphics pipeline process, as shown in FIGS. 1A1 through 1B5; -
FIG. 1 is a graphical representation of a prior art PC-based computing system employing a conventional dual-GPU graphic architecture comprising two external2A graphic cards 205 204 and two PCI-e buses, e.g. Bearlake byIntel memory bridge circuit 103, while adisplay device 106 is attached to theprimary graphics card 205, and Ethernet and mobile docking ports and other local I/O ports are driven by the South bridge circuit, as shown; -
FIG. 2 is a graphical representation of a prior art PC-based computing system employing a conventional dual-GPU graphic architecture comprising two external2A graphic cards primary graphics card 205 is connected to and driven by the North memory bridge via the first PCI-e bus with adisplay device 106 is attached to theprimary graphics card 205, and wherein thesecondary graphics card 204 is connected to and driven by the South bridge via the second PCI-e bus; -
FIG. 3 is a graphical representation of a conventional GPU subsystem supported on each of the graphics cards employed in the prior art PC-based computing systems of FIGS. 2A1 and 2A2;2A -
FIG. 4 is a graphical representation illustrating the general software architecture of the prior art PC-based graphics systems shown in2A FIG. 1, as well as2A FIG. 2;2A -
FIG. 5 is a graphical representation of a prior art PC-based computing system employing a conventional multi-core microprocessor (CPU) chip to implement multiple processing cores in a single physical package, wherein some of the cores can be potentially used as soft graphic graphics pipelines, and wherein a2A display device 106 is connected to and driven by the North (memory) bridge chip on the motherboard; -
FIG. 2B is a graphical representation of a conventional parallel graphics rendering process being carried out according to the Image Division Method of parallelism using the dual GPUs provided on the prior art graphics platform illustrated in FIGS. 2A1 through 2A3; -
FIG. 2C is a graphical representation of a conventional parallel graphics rendering process being carried out according to the Time Division Method of parallelism using the dual GPUs provided on the prior art graphics platforms illustrated in FIGS. 2A1 through 2A5; -
FIG. 3A is a schematic representation of a prior art parallel graphics rendering platform comprising multiple parallel graphics pipelines, each supporting video memory and a GPU, and feeding complex pixel compositing hardware for composing a final pixel-based images for display on the display device; -
FIG. 3B is a graphical representation of a conventional parallel graphics rendering process being carried out according to the Object Division Method of parallelism using multiple GPUs on the prior art graphics platform ofFIG. 3A ; -
FIG. 1 is a schematic representation of the GPU and Video Memory structure employed in conventional multi-GPU PC-based computing systems, and illustrating the various kinds of bottlenecks (e.g. geometry limited, pixel limited, data transfer limited, and memory limited) that occur in such systems;3C -
FIG. 2 is a table summarizing the kinds of bottleneck problems which conventional parallelization modes are currently capable of mitigating along the multi-GPU pipelines of conventional PC-based computing systems;3C -
FIG. 4A is a schematic representation of a generalized embodiment of the multi-mode parallel 3D graphics rendering system (MMPGRS) of the present invention shown comprising (i) an automatic mode control module or mechanism (AMCM) 400 for supporting automatic mode control using diverse types of 3D scene profiling techniques and/or system-user interaction detection techniques, (ii) a multi-mode parallel graphics rendering subsystem 41 for supporting at least three primary parallelization stages of decomposition, distribution and recomposition implemented using theDecomposition Module 401, theDistribution Module 402 and theRecomposition Module 403, respectively, and (ii) a plurality of either GPU and/or CPU based “graphics processing pipelines (GPPLs)” 410′, wherein each parallelization stage performed by its corresponding Module is configured (i.e. set up) into a “sub-state” by set of parameters, and wherein the “graphics rendering parallelism state” for the overall multi-mode parallel graphics system is established or otherwise determined by the combination of sub-states of these component stages; -
FIG. 1 is a schematic representation of the subcomponents of a first illustrative embodiment of a GPU-based graphics processing pipeline (GPPL) that can be employed in the MMPGRS of the present invention depicted in4B FIG. 4A , shown comprising (i) a video memory structure supporting a frame buffer (FB) including stencil, depth and color buffers, and (ii) a graphics processing unit (GPU) supporting (1) a geometry subsystem having an input assembler and a vertex shader, (2) a set up engine, and (3) a pixel subsystem including a pixel shader receiving pixel data from the frame buffer and a raster operators operating on pixel data in the frame buffers; -
FIG. 2 is a schematic representation of the subcomponents of a second illustrative embodiment of a GPU-based graphics processing pipeline (GPPL) that can be employed in the MMPGRS of the present invention depicted in4B FIG. 4A , shown comprising (i) a video memory structure supporting a frame buffer (FB) including stencil, depth and color buffers, and (ii) a graphics processing unit (GPU) supporting (1) a geometry subsystem having an input assembler, a vertex shader and a geometry shader, (2) a rasterizer, and (3) a pixel subsystem including a pixel shader receiving pixel data from the frame buffer and a raster operators operating on pixel data in the frame buffers; -
FIG. 3 is a schematic representation of the subcomponents of a illustrative embodiment of a CPU-based graphics processing pipeline that can be employed in the MMPGRS of the present invention depicted in4B FIG. 4A , shown comprising (i) a video memory structure supporting a frame buffer including stencil, depth and color buffers, and (ii) a graphics processing pipeline realized by one cell of a multi-core CPU chip, consisting of 16 in-order SIMD processors, and further including a GPU-specific extension, namely, a texture sampler that loads texture maps from memory, filters them for level-of-detail, and feeds to pixel processing portion of the pipeline; -
FIG. 4C is a schematic representation for the Mode Definition Table which shows the four combinations of sub-modes (i.e. sub-states) A:B:C for realizing the three (3) Parallel Modes of the MMPGRS of the present invention (i.e. Object Division Mode, Image Division Mode and Time/Alternative Division Mode), and the one (1) Single GPU (i.e. Non-Parallel Functioning) Mode of the system; -
FIG. 4D is a schematic representation illustrating the various Performance and Interactive Device Data Inputs supplied to the Application Profiling and Analysis Module (within the Automatic Mode Control Module (AMCM)) employed in the MMPGRS of present invention shown inFIG. 4A , as well as the Tasks carried out by the Application Profiling and Analysis Module; -
FIG. 5A is a schematic representation of the User Interaction Detection (UID) Subsystem employed within the Application Profiling and Analysis Module of the Automatic Mode Control Module (AMCM) in the MMPGRS of the present invention, wherein the UID Subsystem is shown comprising a Detection and Counting Module arranged in combination with a UID Transition Decision Module; -
FIG. 5B is a flow chart representation of the state transition process between Object-Division/Image-Division Modes and the Time Division Mode initiated by the UID subsystem employed in the MMPGRS of the present invention; -
FIG. 1 is a schematic representation of the process carried out by the Profiling and Control Cycle in the Automatic Mode Control Module (AMCM) in the MMPGRS of present invention, while the UID Subsystem is disabled;5C -
FIG. 2 is a schematic representation of the process carried out by the Profiling and Control Cycle in the Automatic Mode Control Module in the MMPGRS of present invention, while the UID Subsystem is enabled;5C -
FIG. 3 is a schematic representation of the process carried out by the Periodical Trial & Error Based Control Cycle in the Automatic Mode Control Module employed in the MMPGRS of present invention, shown in5C FIG. 4A ; -
FIG. 4 is a schematic representation of the process carried out by the Event Driven Trial & Error Control Cycle in the Automatic Mode Control Module employed in the MMPGRS of present invention, shown in5C FIG. 4A ; -
FIG. 6A is a State Transition Diagram for the MMPGRS of present invention, illustrating that a parallel state is characterized by A, B, C sub-state parameters, that the non-parallel state (single GPPL) is an exceptional state, reachable from any state by a graphics application or AMCM requirement, and that all state transitions in the system are controlled by Automatic Mode Control Module (AMCM), wherein in those cases of known and previously analyzed graphics applications, the AMCM, when triggered by events (e.g. drop in frames per second FPS rate), automatically consults the Application/Scene Profile Database during the course of the Application, or otherwise, makes decisions which are supported by continuous profiling and analysis of listed parameters, and/or trial and error event driven or periodical cycles; -
FIG. 6B is a schematic representation of the MMPGRS of the present invention supporting multiple graphic processing pipelines (GPPLs), with dynamic application profiling and parallelism mode control, in accordance with the principles of the present invention; -
FIG. 1 is a flow chart illustrating the processing of a sequence of pipelined image frames during the Image Division Mode of parallel graphics rendering supported on the MMPGRS of the present invention depicted in6C FIGS. 4A through 6A ; -
FIG. 2 is a flow chart illustrating the processing of a sequence of pipelined image frames during the Time Division Mode of parallel graphics rendering supported on the MMPGRS of the present invention depicted in6C FIGS. 4A through 6A ; -
FIG. 3 is a flow chart illustrating the processing of a single image frame during the Object Division mode of parallel graphics rendering supported on the MMPGRS of the present invention depicted in6C FIGS. 4A through 6A ; -
FIG. 7A 1-1 is a schematic representation of various possible graphics architectural spaces within which the components of the MMPGRS of the present invention can be embodied in any given application, namely: Host Memory Space (HMS), Processor/CPU Die Space, Bridge Circuit (IGD) Space, Graphics Hub Space, and External GPU Space; -
FIG. 7A 1-2 sets forth a table listing diverse classes of system architectures in which the MMPGRS can be embodied, expressed in terms of the different kinds of architectural spaces, identified inFIG. 7A 1-1, in which the primary MMPGRS components (i.e. AMCM,Decomposition Submodule 1,Decomposition Module 2, Distribution Module, Multiple GPUs and Recomposition Module) can be embodied in each such class of MMPGRS Architecture, namely—Host Memory Space HMS (software), HMS+IGD, HMS+Fusion, HMS+Multicore, HMS+GPU-Recomposition, HUB; HUB+GPU-Recomposition, Chipset; CPU/GPU Fusion, Multicore CPU, and Game Console; -
FIG. 2 is a schematic representation of a first illustrative embodiment of the MMPGRS of the present invention, following the HMS Class of MMPGRS Architecture described in7A FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution andRecomposition Modules software package 701 in the Host Memory Space (HMS) while multiple GPUs are supported on a pair of externalgraphic cards memory bridge chip 103 and driven in a parallelized manner under the control of the AMCM, (ii) theDecomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402 uses the North bridge chip to distribute graphic commands and data (GCAD) to the multiple GPUs on board the external graphics cards, (iv) theRecomposition Module 403 uses the North bridge chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphics cards via a PCI-express interface (which is connected to the North bridge chip); -
FIG. 3 is a schematic representation of a second illustrative embodiment of the MMPGRS of the present invention, following the HMS+IGD Class of MMPGRS Architecture described in7A FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution andRecomposition Modules software package 701 in the Host or CPU Memory Space (HMS) while multiple GPUs are supported in an IGD within the North memory bridge circuit as well as on external graphic cards connected to the North memory bridge chip and driven in a parallelized manner under the control of the AMCM, (ii) theDecomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402 uses the North bridge chip to distribute the graphic commands and data (GCAD) to the multiple GPUs located in the IGD and on the external graphics cards, (iv) theRecomposition Module 403 uses the North bridge chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphics cards or the IGD; -
FIG. 4 is a schematic representation of a third illustrative embodiment of the MMPGRS of the present invention, following the HMS+IGD Class of MMPGRS Architecture described in7A FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution andRecomposition Modules software package 701 in the Host Memory Space (HMS) while multiple GPUs are supported in an IGD within the South bridge circuit as well as on external graphic cards connected to the South bridge chip, and driven in a parallelized manner under the control of the AMCM, (ii) theDecomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) that theDistribution Module 402 uses the North bridge chip to distribute graphic commands and data (CGAD) to the multiple GPUs located in the IGD and on external graphics cards, (iv) theRecomposition Module 403 uses the South bridge chip to transfer recomposited pixel data between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphics cards or the IGD; -
FIG. 5 is a schematic representation of a fourth illustrative embodiment of the MMPGRS of the present invention, following the HMS+Fusion Class of MMPGRS Architecture described in7A FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401, 402, 403, respectively, of the Multimode Parallel Graphics Rendering Subsystem resides as a software package 701 in the Host Memory Space (HMS) while a single GPU 1242 is supported on a CPU/GPU fusion-architecture processor die (alongside the CPU 1241) and one or more GPUs are supported on an external graphic card connected to the CPU processor die and driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) the Distribution Module 402 uses the memory controller (controlling the HMS) and the interconnect network (e.g. crossbar switch) within the CPU/GPU processor chip to distribute graphic commands and data to the multiple GPUs on the CPU/GPU die chip and on the external graphics cards, (iv) the Recomposition Module 403 uses the memory controller and interconnect (e.g. crossbar switch) within the CPU/GPU processor chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphics card via a PCI-express interface (which is connected to the CPU/GPU fusion-architecture chip); -
FIG. 6 is a schematic representation of a fifth illustrative embodiment of the MMPGRS of the present invention, following the HMS+Multicore Class of MMPGRS Architecture described in7A FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution andRecomposition Modules software package 701 in the Host or CPU Memory Space (HMS) while some of the CPU cores on a multi-core CPU chip are used to implement a plurality of multi-core graphics pipelines parallelized under the control of the AMCM, (ii) theDecomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402 uses the North memory bridge and interconnect network within the multi-core CPU chip to distribute graphic commands and data (GCAD) to the multi-core graphic pipelines implemented on the multi-core CPU chip, (iv) theRecomposition Module 403 uses the North memory bridge and interconnect network within the multi-core CPU chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multi-core graphics pipelines during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the North bridge chip via a display interface; -
FIG. 7 is a schematic representation of a sixth illustrative embodiment of the MMPGRS of the present invention, following the HMS+GPU-Recomposition Class of MMPGRS Architecture described in7A FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution and Recomposition Modules 401, 402 respectively, of the Multimode Parallel Graphics Rendering Subsystem resides as a software package 701 in the Host or CPU Memory Space (HMS) while multiple GPUs on external GPU cards are used to implement the Recomposition Module, and driven in parallelized manner under the control of the AMCM, (ii) the Decomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) the Distribution Module 402 uses the North or South bridge circuit and interconnect network to distribute graphic commands and data (GCAD) to the external GPUs, (iv) the Recomposition Module uses the North memory bridge and associated system bus (e.g. PCI-express bus) to transfer composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets (recomposited within the vertex and/or fragment shaders of the primary GPU) are displayed as graphical images on one or more display devices, connected to an external graphics card via a PCI-express interface (which is connected to either the North or South bridge circuits of the host computing system); -
FIG. 7A 7-1 is a schematic representation of the parallel graphics rendering process supported within the MMPGRS ofFIG. 7 during its object division mode of parallel operation;7A -
FIG. 7A 7-2 is a graphical representation of Shader code (expressed in a graphics programming language, e.g. Cg) that is used within the primary GPPL of the MMPGRS ofFIG. 7, in order to carry out the pixel recomposition stage of the object division mode/method of the parallel graphics rendering process of the present invention, supported on the dual GPU-based parallel graphics system shown in7A FIG. 7;7A -
FIG. 7A 7-3 is a time-line representation of process of generating a frame of pixels for an image along a specified viewing direction, during a particular parallel rendering cycle in the MMPGRS ofFIG. 7, wherein the pixel recomposition step of the parallel rendering process is shown reusing GPU-based computational resources during its idle time, without the need for specialized or dedicated compositional apparatus required by prior art parallel graphics systems supporting an object division mode of parallel graphics rendering;7A -
FIG. 1 is a schematic representation of a seventh illustrative embodiment of the MMPGRS of the present invention, following the Hub Class of MMPGRS Architecture described in7B FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″, Distribution Module 402″ and Recomposition Module 403″ are realized within a single graphics hub device (e.g. chip) that is connected to the North memory bridge of the host computing system via a PCI-express interface and to a cluster of external GPUs 410″ via an interconnect, with the GPUs being driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North memory bridge circuit, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ distributes graphic commands and data (GCAD) to the external GPUs, (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the primary GPU on the graphical display card which is connected to the graphics hub chip of the present invention via the interconnect 404″; -
FIG. 2 is a schematic representation of an eighth illustrative embodiment of the MMPGRS of the present invention, following the Hub+GPU-Recomposition Class of MMPGRS Architecture described in7B FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host Memory Space (HMS) of the host computing system, while the Decomposition Submodule No. 2 401″ and theDistribution Module 402″ are realized within a single graphics hub device (e.g. chip) that is connected to the North bridge of the host computing system and a cluster ofexternal GPUs 410″, and the Recomposition Module (403″ is implemented across two ormore GPUs FIG. 7A 7), and that all of the GPUs are driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) theDistribution Module 402″ distributes graphic commands and data (GCAD) to the external GPUs, (v) theRecomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets (recomposited within the vertex and/or fragment shaders of the primary GPU) are displayed as graphical images on one or more display devices connected to the primary GPU on the graphical display card(s) (which are connected to the graphics hub chip of the present invention); -
FIG. 3 is a schematic representation of a ninth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in7B FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″, Distribution Module 402″ and Recomposition Module 403″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the North memory bridge circuit and having a plurality of GPUs being driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ distributes graphic commands and data (GCAD) to the internal GPUs via the interconnect network, (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphical display card or the primary GPU in the IGB; -
FIG. 4 is a schematic representation of a tenth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in7B FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″, Distribution Module 402″ and Recomposition Module 403″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the South bridge circuit of the host computing system and having a plurality of GPUs driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the communication interfaces of the North and South bridge circuits, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ distributes graphic commands and data (GCAD) to the external GPUs, (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphical display card or the primary GPU in the IGB; -
FIG. 7B 4-1 is a schematic representation of an eleventh illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described inFIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″ and Distribution Module 402″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the South bridge circuit of the host computing system and having a plurality of GPUs driven in a parallelized manner under the control of the AMCM, while the Recomposition Module 403″ is implemented across two or more GPUs 715, 716, (ii) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the communication interfaces of the North and South bridge circuits, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ distributes graphic commands and data (GCAD) to the external GPUs, (v) the Recomposition Module 403″, implemented within Primary GPU, transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphical display card or the primary GPU in the IGB; -
FIG. 5 is a schematic representation of an twelfth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in7B FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″, Distribution Module 402″ and Recomposition Module 403″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the North memory bridge of the host computing system and having multiple GPUs being driven with a single GPU on an external graphics card in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ distributes graphic commands and data (GCAD) to the external GPUs, (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphical display card or the primary GPU in the IGB; -
FIG. 6 is a schematic representation of a thirteenth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in7B FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″, Distribution Module 402″ and Recomposition Module 403″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the South bridge circuit of the host computing system and having a single GPU driven with a single GPU on an external graphics card in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfer graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North and South bridge circuits, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ distributes the graphic commands and data (GCAD) to the external GPUs, (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphics card or the primary GPU in the IGB; -
FIG. 7B 6-1 is a schematic representation of a fourteenth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described inFIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″ and Distribution Module 402″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the South bridge circuit of the host computing system and having multiple GPUs driven with a single GPU on an external graphics card in a parallelized manner under the control of the AMCM, while the Recomposition Module 403″ is implemented across two or more GPUs 715, 716, (ii) the Decomposition Submodule No. 1 transfer graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North and South bridge circuits, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ distributes the graphic commands and data (GCAD) to the external GPUs, (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphics card or the primary GPU in the IGB; -
FIG. 7 is a schematic representation of a fifteenth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described in7B FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″, Distribution Module 402″ and Recomposition Module 403″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the North memory bridge of the host computing system and having a single GPU being driven with one or more GPUs on multiple external graphics cards in a parallelized manner under the control of the AMCM (or alternatively (ii) controlling a single GPU aboard the IGD for driving a display device connected to the IGD via a display interface), (ii) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs, (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphic cards or the primary GPU in the IGB; -
FIG. 7B 7-1 is a schematic representation of a sixteenth illustrative embodiment of the MMPGRS of the present invention, following the Chipset Class of MMPGRS Architecture described inFIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″ and Distribution Module 402″ are realized (as a graphics hub) in an integrated graphics device (IGD) realized within the North memory bridge chip of the host computing system, and driving (a) multiple GPUs on multiple external graphics cards in a parallelized manner under the control of the AMCM while the Recomposition Module 403″ is implemented across two or more GPUs 715, 716, or alternatively (b) controlling a single GPU aboard the IGD for driving a display device connected to the IGD via a display interface, (ii) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs, (v) the Recomposition Module 403″ implemented in the primary GPU, transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphic cards or the primary GPU in the IGB; -
FIG. 7B 8-1 is a schematic representation of a seventeenth illustrative embodiment of the MMPGRS of the present invention, following the CPU/GPU_Fusion Class of MMPGRS Architecture described inFIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No. 2 401″, Distribution Module 402″ and Recomposition Module 403″ are realized (as a graphics hub) on the die of a hybrid CPU/GPU fusion-architecture chip within the host computing system and having a single GPU driven with one or more GPUs on an external graphics card (connected to the CPU/GPU chip) in a parallelized under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs, (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the external graphics card connected to the hybrid CPU/GPU chip via a PCI-express interface; -
FIG. 7B 8-2 is a schematic representation of an eighteenth illustrative embodiment of the MMPGRS of the present invention, following the CPU/GPU Class of MMPGRS Architecture described inFIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No. 2 401″, Distribution Module 402″ and Recomposition Module 403″ are realized (as a graphics hub) on the die of a hybrid CPU/GPU fusion-architecture chip within the host computing system and having multiple GPUs 1242″ driven with one or more GPUs on an external graphics card 205 (connected to the CPU/GPU chip) in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ uses the crossbar switch (i.e. interconnect) on the processor die to distribute the graphic commands and data (GCAD) to the internal GPUs and external GPUs, (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the external graphics card connected to the hybrid CPU/GPU chip via a PCI-express interface; -
FIG. 7B 8-3 is a schematic representation of a nineteenth illustrative embodiment of the MMPGRS of the present invention, following the CPU/GPU Class of MMPGRS Architecture described inFIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host Memory Space (HMS), (ii) the Decomposition Submodule No. 2 401″ and Distribution Module 402″ are realized (as a graphics hub) in on the die of a hybrid CPU/GPU fusion-architecture chip within the host computing system and having multiple GPUs 1242″ driven with one or more GPUs on an external graphics card 205 (connected to the CPU/GPU chip) in a parallelized manner under the control of the AMCM, (iii) the Recomposition Module 403″ is implemented across two or more GPUs 715, 716 provided on the CPU/GPU fusion chip die and external graphics cards, (iv) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2, (v) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (vi) the Distribution Module 402″ uses the crossbar switch (i.e. interconnect) on the processor die to distribute the graphic commands and data (GCAD) to the internal GPUs and external GPUs, (vii) the Recomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (viii) finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the external graphics card connected to the hybrid CPU/GPU chip via a PCI-express interface; -
FIG. 7B 9-1 is a schematic representation of a twentieth illustrative embodiment of the MMPGRS of the present invention, following the Multicore CPU Class of MMPGRS Architecture described inFIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No. 2 401″, Distribution Module 402″ and Recomposition Module 403″ are realized (as a graphics hub) in on the die of a multi-core CPU chip within the host computing system and having multiple CPU cores, some of which implement multiple soft parallel graphics pipelines (“soft GPUs”) driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the North memory bridge circuit and interconnect network within the multi-core CPU chip, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ uses the crossbar switch (i.e. interconnect) on the processor die to distribute the graphic commands and data (GCAD) to the multiple soft parallel graphics pipelines (implemented by the multiple CPU cores), (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the multiple CPU cores during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the North memory bridge chip via a display interface; -
FIG. 7B 9-2 is a schematic representation of a twenty-first illustrative embodiment of the MMPGRS of the present invention, following the Multicore CPU Class of MMPGRS Architecture described inFIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ resides as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No. 2 401″, the Distribution Module 402″ and the Recomposition Module 403″ are realized as a graphics hub chip within a gaming console system interconnecting a multi-core CPU ship and a cluster of GPUs on the game console board, so that the GPUs are driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the interconnects within the North memory bridge chip and the multi-core CPU chip, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ uses the interconnect (i.e. crossbar switch) in the multi-core CPU chip to distribute the graphic commands and data (GCAD) to the multiple soft graphics pipelines (e.g. soft GPUs) and the GPUs on the external graphics card 205, and (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the soft graphics pipelines on the multi-core CPU chip and hard GPUs on the external graphics card during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices 106 connected to the external graphics card which is connected to the multi-core CPU chip via a PCI-express interface; -
FIG. 10 is a schematic representation of a twenty-second illustrative embodiment of the MMPGRS of the present invention, following the Game Console Class of MMPGRS Architecture described in7B FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ are realized as a software package 711 within the Host Memory Space (HMS), while the Decomposition Submodule No. 2 401″, the Distribution Module 402″ and the Recomposition Module 403′ are realized as a graphics hub semiconductor chip within the game console system in which multiple GPUs are driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2, via the memory controller on the multi-core CPU chip and the interconnect in the graphics hub chip of the present invention, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ distributes the graphic commands and data (GCAD) to the multiple GPUs, (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the multiple GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets (recomposited within the vertex and/or fragment shaders of the primary GPU) are displayed as graphical images on one or more display devices 106 connected to the primary GPU 715 via a analog display interface; -
FIG. 11 is a schematic representation of a twenty-third illustrative embodiment of the MMPGRS of the present invention, following the Game Console Class of MMPGRS Architecture described in7B FIG. 7A 1-2, and showing (i) that the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ are realized as a software package 711 within the Host Memory Space (HMS) of the host computing system while the Decomposition Submodule No. 2 401″ and Distribution Module 402′ are realized as a graphics hub semiconductor chip within the game console system in which multiple GPUs are driven in a parallelized manner under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2, via the memory controller on the multi-core CPU chip and the interconnect in the graphics hub chip of the present invention, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402′ distributes the graphic commands and data (GCAD) to the multiple GPUs, (v) the Recomposition Module 403′, realized primarily within the substructure of the primary GPU, transfers composited pixel data (CPD) between the multiple GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets (recomposited within the vertex and/or fragment shaders of the primary GPU) are displayed as graphical images on one or more display devices 106 connected to the primary GPU 715 via an analog display interface or the like; -
FIG. 8A is a schematic block representation of an illustrative implementation of the MMPGRS of the present invention following the Hub Class of MMPGRS Architecture described inFIG. 7A 1-2, wherein (i) the AMCM and Decomposition No. 1 Module are implemented as a software-package 701 within host memory space (HMS) of the host computing system, (ii) multiple discrete graphic cards are connected to the bridge circuit of the host computing system by way of a hardware-based graphics hub chip of thepresent invention 404″, 402″, 403″, 404″, (iii) hardware-based Distribution andRecomposition Modules 402″ and 403″ are realized on the hardware-based graphics hub chip of the present invention, and (iv) a graphics display device is connected to the primary GPU; -
FIG. 1 is a schematic representation of a first illustrative embodiment of the MMPGRS implementation of8A FIG. 8A , showing a possible packaging of the Hub architecture of the present invention as an assembly comprising a Hub-extender card 811 carrying multiple (e.g. dual)graphics cards motherboard 814 within the host computing system; -
FIG. 2 is a schematic representation of a second illustrative embodiment of the MMPGRS implementation of8A FIG. 8A , showing a possible packaging of the Hub architecture of the present invention as an external box containing a Hub chip of the present invention mounted on a PC board, that is connected to the motherboard of the host computing system via a wire harness or the like, and supporting a plurality ofgraphics cards 813 that are connected to the Hub chip; -
FIG. 3 is a schematic representation of a third illustrative embodiment of the MMPGRS implementation of8A FIG. 8A , showing a possible packaging of the Hub architecture of the present invention realized as a graphics Hub chip of the present invention mounted on themotherboard 814 of the host computing system, which supportsmultiple graphics cards 813 with multiple GPUs; -
FIG. 8B is a schematic block representation of an illustrative implementation of the MMPGRS of the present invention following the Hub+GPU-Recomposition Class of MMPGRS Architecture described inFIG. 7A 1-2, wherein (i) the AMCM and Decomposition No. 1 Submodule are implemented as a software-package 701 within host memory space (HMS) of the host computing system, (ii) multiple discrete graphic cards are connected to a bridge chipset on the host computing system by way of a hardware-based graphics hub chip realizing the Decomposition No. 2Submodule 401″ and theDistribution Module 402″, (iii) theRecomposition Module 403″ is implemented across two ormore GPUs -
FIG. 1 is a schematic representation of a first illustrative embodiment of the MMPGRS implementation of8B FIG. 8B , showing a possible packaging of the Hub+GPU Recomposition architecture of the present invention as an assembly comprising a graphic hub-extender card 811 carrying multiple (e.g. dual)graphics cards motherboard 814 within the host computing system; -
FIG. 2 is a schematic representation of a second illustrative embodiment of the MMPGRS implementation of8B FIG. 8B , showing a possible packaging of the Hub architecture of the present invention as an external box containing a Hub chip of the present invention mounted on a PC board, that is connected to the motherboard of the host computing system via a wire harness or the like, and supporting a plurality ofgraphics cards 813 that are connected to the graphics hub chip; -
FIG. 3 is a schematic representation of a third illustrative embodiment of the MMPGRS implementation of8B FIG. 8B , showing a possible packaging of the Hub architecture of the present invention realized as a graphics hub chip of the present invention mounted on themotherboard 814 of the host computing system, which supportsmultiple graphics cards 813 with multiple GPUs; -
FIG. 8C is a schematic block representation of an illustrative embodiment of the MMPGRS of the present invention following the HM Class of MMPGRS Architecture described inFIG. 7A 1-2, wherein (i) the AMCM, Decomposition, Distribution and Recomposition Modules are implemented as a software-package 701 within host memory space (HMS) of the host computing system, (ii) multiple discrete GPUs on one or more graphics cards, are connected to the bridge circuit on the host computing system, and (iii) a graphics display device is connected to the primary GPU; -
FIG. 1 is a schematic representation of a first illustrative embodiment of the MMPGRS implementation of8C FIG. 8C , wherein discretemultiple graphics cards 851, each supporting at least a single GPU, are interfaced with the bridge circuit chipset of the CPU motherboard by way of a PCI-express or like interface; -
FIG. 2 is a schematic representation of a second illustrative embodiment of the MMPGRS implementation of8C FIG. 8C , wherein multiple GPUs are realized on asingle graphics card 852 which is interfaced to bridge circuit on the CPU motherboard by way of a PCI-express or like interface; -
FIG. 3 is a schematic representation of a third illustrative embodiment of the MMPGRS implementation of8C FIG. 8C , wherein multiplediscrete graphics cards 851, each supporting at least a single GPU, are interfaced with the bridge circuit on a board within anexternal box 821 that is interface to the motherboard within the host computing system; -
FIG. 8D is a schematic block representation of an illustrative embodiment of the MMPGRS of the present invention following the Hub+GPU-Recomposition Class of MMPGRS Architecture described inFIG. 7A 1-2, wherein (i) the AMCM, Decomposition Submodule No. 1 and a Distribution Module are implemented as a software-package 701 within host memory space (HMS) of the host computing system, (ii) multiple discrete GPUs on one or more external graphics cards are connected to the bridge circuit of the host computing system, (iii) aRecomposition Module 403″ is implemented across two ormore GPUs -
FIG. 1 is a schematic representation of a first illustrative embodiment of the MMPGRS implementation of8D FIG. 8D , wherein discretemultiple graphics cards 851, each supporting at least a single GPU, are interfaced with the bridge circuit chipset of the CPU motherboard by way of a PCI-express or like interface; -
FIG. 2 is a schematic representation of a second illustrative embodiment of the MMPGRS implementation of8D FIG. 8D , wherein multiple GPUs are realized on asingle graphics card 852 which is interfaced to bridge circuit on the CPU motherboard by way of a PCI-express or like interface; -
FIG. 3 is a schematic representation of a third illustrative embodiment of the MMPGRS implementation of8D FIG. 8D , wherein multiplediscrete graphics cards 851, each supporting at least a single GPU, are interfaced with the bridge circuit on a board within anexternal box 821 that is interface to the motherboard within the host computing system; -
FIG. 9A is a schematic block representation of an illustrative implementation of the MMPGRS of the present invention following the Hub Class of MMPGRS Architecture described inFIG. 7A 1-2, wherein (i) the AMCM and Decomposition Submodule No. 1 are realized as asoftware package 711 on the host memory space (HMS), (ii) multiple GPUs (i.e.Primary GPU 715 and Secondary GPUs 716) are assembled on aexternal graphics card 902 which connects the GPUs to the bridge circuit on the host computing system by way of a hardware-based graphics hub chip implementing the Decomposition Submodule No. 2 401″, theDistribution Module 402″ and theRecomposition Module 403″, and (iii) a graphics display device is connected to the primary GPU; -
FIG. 1 is a schematic representation of an illustrative embodiment of the MMPGRS of9A FIG. 9A , whereinmultiple GPUs Distribution Module 402″ and theRecomposition Modules 403″ are implemented as a graphics hub chip orchipset 401″, 402′, 403,″ and 404″ on a singlegraphics display card 902, which is interfaced to the bridge circuit on themotherboard 814 within the host computing system; -
FIG. 10A is a schematic block representation of an illustrative implementation of the MMPGRS of the present invention following the Hub Class of MMPGRS Architecture described inFIG. 7A 1-2, wherein (i) the AMCM and Decomposition Submodule No. 1 are realized as asoftware package 711 on the host memory space (HMS), (ii) a single SOC-basedgraphics chip 1001 mounted on asingle graphics card 1002 is interfaced with a bridge circuit on themotherboard 1002, and supporting multiple GPUs (i.e. the primary GPU and secondary GPUs), (iii) hardware-based Decomposition Submodule No. 2, the Distribution Module and the Recomposition Module are implemented on the SOC-basedgraphics chip 1001, and (iv) a graphics display device is connected to the primary GPU; -
FIG. 1 is a schematic representation of possible packaging of the SOC-based10A graphics hub chip 101 depicted inFIG. 10A , whereinmultiple GPUs Decomposition Submodule 401″,Distribution Module 402″, and Recomposition Module 4-3″ are realized on asingle SOC implementation 1001 mounted on asingle graphics card 1002; -
FIG. 10B is a schematic block representation of an illustrative implementation of the MMPGRS of the present invention following the Hub+GPU-Recomposition Class of MMPGRS Architecture described inFIG. 7A 1-2, wherein (i) the AMCM and Decomposition Submodule No. 1 are realized as asoftware package 711 on the host memory space (HMS), (ii) a single SOC-basedgraphics chip 1003 mounted on asingle graphics card 1002 is interfaced with a bridge circuit on themotherboard 1002, and supporting multiple GPUs (i.e. the primary GPU and secondary GPUs), (iii) hardware-based Decomposition Submodule No. 2 and the Distribution Module are implemented on the SOC-basedgraphics hub chip 1001, (iv) the Recomposition Module is implemented across two ormore GPUs -
FIG. 1 is a schematic representation of possible packaging of the SOC-based10B graphics hub chip 101 depicted inFIG. 10B , whereinmultiple GPUs Decomposition Submodule 401″,Distribution Module 402″, and Recomposition Module 4-3″ are realized in the primary GPU of asingle SOC implementation 1003 mounted on asingle graphics card 1002; -
FIG. 10C is a schematic block representation of an illustrative implementation of the MMPGRS of the present invention following the HMS+GPU-Recomposition Class of MMPGRS Architecture described inFIG. 7A 1-2, wherein (i) the AMCM, Decomposition Module and Distribution Module are realized as asoftware package 701 on the host memory space (HMS), (ii) asingle multi-GPU chip 1031 mounted on asingle graphics card 1002 is interfaced with a bridge circuit on the motherboard, and supporting multiple GPUs (i.e. the primary GPU and secondary GPUs), (iii) the Recomposition Module is implemented across two ormore GPUs -
FIG. 1 is a schematic representation of possible packaging of the10C multi-GPU chip 1031 depicted inFIG. 10C , whereinmultiple GPUs Process 403″ are implemented in theprimary GPU 715 of amulti-GPU chip 1031; -
FIG. 11A is a schematic block representation of an illustrative implementation of the MMPGRS following the Chipset Class of MMPGRS Architecture described inFIG. 7A 1-2, wherein (i) the AMCM and Decomposition Submodule No. 1 are realized as asoftware package 711 within the host memory space (HMS) of the host computing system, (ii) plurality ofGPUs 852 on one or moreexternal graphics cards 851 is connected to the bridge circuit on the host computing platform, (iii) an integrated graphics device (IGD) 1101, supporting hardware-based Decomposition Submodule No. 2, theDistribution Module 402″ andRecomposition Module 403″, are implemented within the bridge circuit 1101 on themotherboard 814 of the host computing system, and (iv) a display device is interfaced to the primary GPU by way of a PCI-express interface or the like; -
FIG. 1 is a schematic representation of a first illustrative embodiment of the Chipset MMPGRS implementation of11A FIG. 11A , wherein multiplediscrete graphics cards 851, each supporting at least a single GPU, are interfaced with the bridge circuit on a board within anexternal box 821 that is interface to the motherboard within the host computing system; -
FIG. 1 is a schematic representation of a second illustrative embodiment of the Chipset MMPGRS implementation of11A FIG. 11A , wherein discretemultiple graphics cards 851, each supporting at least a single GPU, are interfaced with the bridge circuit chipset of the CPU motherboard by way of a PCI-express or like interface; -
FIG. 3 is a schematic representation of a third illustrative embodiment of the Chipset MMPGRS implementation of11A FIG. 11A , wherein multiple GPUs are realized on asingle graphics card 852 which is interfaced to bridge circuit on the CPU motherboard by way of a PCI-express or like interface; -
FIG. 11B is schematic representation of an illustrative implementation of the MMPGRS following the CPU/GPU Fusion Class of MMPGRS Architecture or Multi-Core Class MMPGRS Architecture described inFIG. 7A 1-2, wherein (i) a CPU/GPU fusion-architecture chip or a multi-core CPU chip is mounted on the motherboard of a host computing system having memory and North and South bridge circuits, (ii) the software-based AMCM and Decomposition Submodule No. 1 are realized as asoftware package 701 within the host memory space (HMS) of the host computing system while Decomposition Submodule No. 2, the Distribution Module and the Recomposition Module are realized on the die of the CPU/GPU fusion-architecture chip or the multi-core CPU chip, and (iii) multiple GPUs on external graphic cards or elsewhere, are interfaced to the CPU/GPU fusion-architecture chip or the multi-core CPU chip, by way of a PCI-express or like interface, and (iv) a display device is interfaced to the primary GPU by way of a PCI-express interface or the like. -
FIG. 1 is a schematic representation of a first illustrative embodiment of the CPU/GPU Fusion or Multi-Core MMPGRS implementation of11B FIG. 11B , wherein a CPU/GPU Fusion or Multi-Core chip is used to drive an assemble of graphic cards or GPUs on one or moreexternal graphics cards 851; -
FIG. 2 is a schematic representation of a second illustrative embodiment of the Chipset MMPGRS implementation of11B FIG. 11B , wherein a CPU/GPU Fusion or Multi-Core chip is used to drive an assemble of GPUs on a singleexternal graphics card 852; -
FIG. 3 is a schematic representation of a third illustrative embodiment of the Chipset MMPGRS implementation of11B FIG. 11B , wherein a CPU/GPU Fusion or Multi-Core chip is used to drive only an assemble of internal GPUs on the CPU/GPU Fusion or Multi-Core chip; -
FIG. 11C is schematic representation of an illustrative implementation of the MMPGRS following the Game Console Class of MMPGRS Architecture described inFIG. 7A 1-2, wherein (i) theAMCM 400 and Decomposition Submodule No. 1 401′ are realized as a software package within the host memory space (HMS) of the game console system, (ii) agraphics hub chip 401″, 402″, 403″, 404″ mounted on the PC board of the game console system implements the Decomposition Submodule No. 2 401″, theDistribution Module 402′, theRecomposition Module 403′ as well as an interconnect network (e.g. crossbar switch) 404″, (iii) multiple GPUs on the PC board of the game console system are interfaced to Distribution and Recomposition Modules by way of theinterconnect 404″ within the graphics hub chip, and optionally, the Recompostion Module can be implemented within two ormore GPUs display device 106 is interfaced to the primary GPU by way of an analog display interface or the like; -
FIG. 1 is a schematic representation of an illustrative embodiment of the Game Console MMPGS implementation of11C FIG. 11D , showing its controller in combination with its game console unit; -
FIG. 12A is a schematic representation of a multi-user computer network supporting a plurality of client machines, wherein one or more client machines (i) employ the MMPGRS of the present invention following any MMPGRS Architecture described inFIG. 7A 1-2, and (ii) respond to user-system interaction input data streams from one or more network users who might be local to each other as over a LAN, or be remote to each other, as when operating over a WAN or the Internet infrastructure; and -
FIG. 12B is a schematic representation of a multi-user computer network supporting a plurality of client machines, wherein one or more client machines (i) employ the MMPGRS of the present invention following any MMPGRS Architecture described inFIG. 7A 1-2, and (ii) respond to user-system interaction input data streams from one or more network users who might be local to each other as over a LAN, or be remote to each other, as when operating over a WAN or the Internet infrastructure. - Referring now to
FIGS. 4A through 12B in the accompanying Drawings, the various illustrative embodiments of the Multi-Mode Parallel Graphics Rendering System (MMPGRS) and Multi-Mode Parallel Graphics Rendering Process (MMPGRP) of the present invention will now be described in great technical detail, wherein like elements will be indicated using like reference numerals. - In general, one aspect of the present invention teaches how to dynamically retain high and steady performance of a three-dimensional (3D) graphics system on conventional platforms (e.g. PCs, laptops, servers, etc.), as well as on silicon level graphics systems (e.g. graphics system on chip (SOC) implementations, integrated graphics device IGD implementations, and hybrid CPU/GPU die implementations). This aspect of the present invention is accomplished by means of a novel architecture supporting adaptive graphics parallelism having both software, hardware and hybrid embodiments.
- The MMPGRS and MMPGRP of the present invention fulfills a great need in the marketplace by providing a highly-suited parallelism scheme, By virtue of the present invention, different GPPL-based parallel rendering schemes, supported on the MMPGRS, dynamically alternate throughout the course of any particular graphics application running on the host system in which the MMPGRS is embodied, and adapting the optimal parallel rendering method (e.g. Image/Frame, Time or Object Division) in real-time to meet the changing needs of the graphics application(s).
- The MMPGRS of the Present Invention Employs Automatic Mode and Control Module (AMCM)
-
FIG. 4A shows the MMPGRS of the present invention employing automatic 3D scene profiling and multiple GPPL control, and supporting at least three different parallelization modes (e.g. Image/Frame, Time and Object Division). As shown, the MMPGRS comprises two primary subcomponents, namely: - (1) Multi-Mode Parallel Graphics Rendering Subsystem 420 including (i) a
Decomposition Module 401,Distribution Module 402 andRecomposition Module 403 for supporting three stages of parallelization namely decomposition, distribution, and recomposition, and (ii) an Array or Cluster of Graphic Processing Pipelines (GPPLs) for supporting and driving Graphics Rendering and Image Display Processes; and - (2) a Automatic Mode Control Module (AMCM) 400, described in FIGS. 4C through 5C4 and 6A, for dynamically profiling Graphics-based Applications running on the host computing system, and controlling the various modes of parallelism supported by the MMPGRS of the present invention.
- In general, the GPPLs can be realized in various ways, including (i) Graphic Processing Units (GPUs) 407 as shown in FIGS. 4B1 and 4B2, and/or (ii) Computational Processing Units (CPUs), or CPU-cores, as shown in FIGS. 4B3 and 4B4.
- As shown in
FIGS. 4A and 4D , the Graphics Commands and Data (CGAD) to the MMPGRS will typically be produced and provided from the Graphics-based Application being executed by one or more CPUs and associated memory on the host computing system. In contrast, the Interaction Data will be supplied from the user or users interaction with the host computing system. - In general, the host computing system may be a PC-level computer, application server, laptop, game console system, portable computing system, or the like supporting the real-time generation and display of 3D graphics), and that the MMPGRS may be embodied within any such system in accordance with the principles of the present invention.
- The Graphics Processing Pipelines (GPPLs) Employed within the MMPGRS of the Present Invention
- In general, each GPPL employed within the MMPGRS of the present invention can be realized in a variety of different ways. However, in general, each graphics processing pipeline (GPPL) will typically include some basic structures including for example, video memory and a computational unit such as a GPU, or CPU having multi-cores typically implementing SIMD elements. When using GPUs, the graphic processing pipelines (GPPLs) are often considered “hard” graphical processing pipelines. When using CPUs, the graphic processing pipelines are often considered “soft” graphical processing pipelines. In either case, each graphic processing pipeline (GPPL) provides sufficient computational and memory/buffering resources to carry out the execution of graphics commands and the processing of graphics data, as specified by the graphical rendering processed required by the graphics-based Application running on the host computing system, at any particular instant in time.
- In FIGS. 4B1 and 4B2, two illustrative embodiments for the GPU-based graphics processing pipeline approach are shown. In
FIG. 3, one illustrative embodiment is shown for the CPU-based graphics processing pipeline approach.4B - As shown in
FIG. 1, each GPU-based graphics processing pipeline (GPPL) deployed in the MMPGRS of a first illustrative embodiment comprises: (i) video memory (e.g. a stencil memory buffer, a depth memory buffer, and a color memory buffer); and (ii) a classic shader-based GPU which includes: a geometry subsystem; a set up engine; and a pixel subsystem. As shown, the geometry subsystem further comprises a vertex shader which implements a graphics processing function that perform is 3D geometrical transformations and lighting calculations on the objects' vertex data. The Setup engine assembles primitives (lines, points, triangles) from vertices, assigns parameters to primitives, divides the primitives into tiles, and distributes these tiles to the pixel pipelines of the Pixel subsystem. The Pixel subsystem further comprises: a pixel shader for receiving input from the Setup engine and the video memory and performing shading and texturing of pixels; and a plurality of raster operators which receive output from the pixel shader and produce blending, z-buffering and antialiasing of pixels, storing them into Frame Buffer buffer. This graphics pipeline architecture can be found used in conventional graphics devices such as nVidia's GeForce 7700.4B - As shown in
FIG. 2, each GPU-based graphics processing pipeline (GPPL) deployed in the MMPGRS of a second illustrative embodiment comprises: (i) video memory (e.g. a stencil memory buffer, a depth memory buffer, and a color memory buffer); and (ii) a shader-based GPU which includes: a geometry subsystem; a rasterizer; and a pixel subsystem. As shown, the geometry subsystem further comprises: an input assembler for gathering vertex data from the CPU and converting its format, and generating various index IDs that are helpful for performing various repeated operations on vertices, primitives, and scene objects; a vertex shader for performing 3D geometrical transformations and lighting calculations on the objects' vertex data; and a geometry shader permitting a range of effects and features, such as process entire primitives as inputs and generate entire primitives as output, rather than processing just one vertex at a time, as with a vertex shader, while reducing dependence on the CPU for geometry processing. The stream output permits data generated from geometry shaders to be forwarded back to the top of the pipeline to be processed again. The rasterizer assembles primitives (lines, points, triangles) from vertices, assigns parameters to primitives, and converts them into pixels for output to the Pixel subsystem. The pixel subsystem further comprises: a pixel shader for receiving input from the Setup engine and the video memory and performing shading and texturing of pixels; and a plurality of raster operators which receive output from the pixel shader and produce blending, z-buffering and anti-aliasing of pixels, storing them out into Frame Buffer (FB). This graphics pipeline architecture can be found used in conventional graphics devices such as nVidia's GeForce 8800 GTX.4B - As shown in
FIG. 3, each CPU-based graphics processing pipeline (GPPL) deployed in the MMPGRS of a third illustrative embodiment comprises: (i) a video memory structure supporting a frame buffer (including stencil, depth and color buffers); (ii) a memory controller; (iii) a graphics processing pipeline realized by one cell of a multi-core CPU chip, consisting of 16 in-order SIMD processors; (iv) L2 cache memory; and (v) a GPU-specific extension, namely, a texture sampler, for loading texture maps from memory, filtering them for level-of-detail, and feeding the same to the pixel processing portion of the graphic processing pipeline (GPPL). This graphics pipeline architecture can be found used in such conventional devices as Larrabee multi-core processor by Intel.4B - Notably, as shown in
FIG. 4A , while the array ofGPPLs 407 comprises N pairs of GPU or CPU and Video Memory pipelines, only one GPPL in the array, termed “primary GPPL,” is responsible for driving the display unit which may be realized as a LCD panel, an LCD or DLP Image/Video “Multi-Media” Projector, or the like. All other GPPLs in the array are deemed “secondary GPPLs.” - The Multi-Mode Parallel Graphics Rendering Subsystem
- In the Multi-Mode Parallel Graphics Rendering Subsystem 420, each stage (or Module) is induced or set up into a sub-state by a set of parameters managed within the MMPGRS, namely: parameter A for
Module 401; parameter B forModule 402; and parameter C forModule 403. The state of parallelism of the overall MMPGRS is established by the combination of sub-state parameters A, B and C, as listed in the Mode/State Definition Table ofFIG. 4C , which will be elaborated hereinafter. - The unique flexibility of the Multi-Mode Parallel Graphics Rendering Subsystem 420 stems from its ability to quickly change its sub-states, resulting in transition of the overall graphic system (i.e. MMPGS) to another parallel state of operation, namely: the Object Division State, the Image Division State or the Time Division State, as well as to other potential parallelization schemes that may be developed and readily programmed into the MMPGRS platform of the present invention.
- Implementing Parallelization Modes Through a Net Combination of Sub-States (A:B:C) Among the Decomposition, Distribution And Recomposition Modules
- As indicated in the State Table of
FIG. 4C , the net combination of all Sub-States (A:B:C) among theDecomposition Module 401,Distribution Module 402 andRecomposition Module 403, respectively, implements the various parallelization schemes (i.e. parallelization modes) supported on the MMPGRS of the present invention, which will now be described hereinbelow. Thus, theDecomposition Module 401,Distribution Module 402 andRecomposition Module 403 cooperate to carry out all functions required by the different parallelization schemes supported on the MMPGRS platform of the present invention. It is appropriate at this juncture to described how the primary modes of parallelism (i.e. Image, Time and Object Division) are implemented on the MMPGS using combinations of sub-state parameters (A:B:C). - The Image Division State of Parallel Operation:
- In the Image Division State of Operation, the
Decomposition Module 401 is set to the Image Decomposition Sub-State or Sub-mode (A=2), multiplicating the same command and data stream to all GPUs, and defining unique screen portion for each one, according to the specific Image Division Mode in use (e.g. split screen, or tiled screen). The Distribution Module is set in Broadcast Sub-mode B=2, to physically broadcast the stream to all GPUs. Finally, the Recomposition Module No. 1 set to Screen-based Sub-mode C=2, and collects all the partial images into final frame buffer, performing the screen based composition. - The Time Division State of Parallel Operation:
- In the Time Division State of Operation, each GPU renders the next successive frame. The Decomposition Module is set to the Alternate Sub-mode, A=3, alternating the command and data stream among GPUs on frame basis. The Distribution Module is set to the Single Sub-mode, B=3, physically moving the stream to the designated GPU. Finally, the Recomposition Module is set to None, C=3, as no merge is needed and the frame buffer is just moved from the designated GPU to the screen for display.
- The Object Division State of Parallel Operation:
- In the Object Division State of operation, the Decomposition Module is set to the Object Decomposition Sub-mode, A=1, decomposing the command and data stream, and targeting partial streams to different GPUs. The Distribution Module is set to the Divide Sub-mode, B=1, physically delivering the partial commands and data to GPUs. Finally the Recomposition Module is set to Test-Based Sub-mode, C=1, compositing the frame buffer color components of GPUs, based on depth and/or stencil tests.
- The Single GPPL State of Operation:
- While the Single GPPL State of Operation is a non-parallel state of operation, it is allowed and supported in the system of the present invention as this state of operation is beneficial in some exceptional cases. In the Single GPPL State, the Decomposition, Distribution, and Recomposition Modules are set on Single (A=4), Single (B=3) and None (C=3), respectively. Only one GPPL, among all pipelines supported by the MMPGRS, is used in the single GPPL state of operation.
- Description of the Decomposition Module of the MMPGRS of the Present Invention
- The primary function of the
Decomposition Module 401 is to divide (i.e. Split Up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time. In general, the typical graphic processing s pipeline is fed by stream of graphic commands and data from the application and graphics library (OpenGL or Direct 3D). This stream, which is sequential in nature, has to be properly handled and eventually partitioned, according to parallelization mode (i.e. method) used. Under theAMCM 400, the Decomposition Module can be set to different decomposing sub-states (A=1 through A=4), according toFIG. 4C , namely: Object Decomposition Sub-state A=1 during the Object Division State; Image Decomposition Sub-state A=2 during the Image Division State; Alternate Decomposition Sub-state A=3 during the Time Division State; and the Single Sub-state A=4 during the Single GPPL (Non-Parallel) State. Each one of these parallelization states (i.e. Object, Image, Time and Single/Non-Parallel States) will be described in great technical detail below. - As shown in
FIG. 4A , theDecomposition Module 401 is preferably implemented using two submodules, namely: (i) a Decomposition Submodule No. 1 including an OS-GPU Interface and Utilities Module; and (ii) a Decomposition Submodule No. 2, including a Division Control Module and a State Monitoring Module. The subcomponents of these submodules will be described in detail below. - The OS-GPU Interface and Utilities Module
- The OS-GPU Interface and Utilities Module performs all the functions associated with interaction with the Operating System (OS), Graphics Library (e.g. OpenGL or DirectX), and interfacing with GPUs or CPU-cores, as the case may be. The OS-GPU Interface and Utilities Module is responsible for interception of the graphic commands from the standard graphic library, forwarding and creating graphic commands to the Vendor's GPU Driver, controlling registry, installations, OS services and utilities. Another task performed by this module is reading Performance Data from different sources (e.g. GPUs, vendor's driver, and chipset) and forwarding the Performance Data to the Automatic Mode Control Module (AMCM). Also, the OS-GPU Interface and Utilities Module includes software drivers that drive subcomponents within the Decomposition, Distribution and/or Recomposition Modules that are implemented in system architectures (e.g. Hub, Chipset, etc identified in
FIG. 4A 1-2 and shown in FIGS. 7B1 through 7B11) in which both the Decomposition and Distribution Modules are not implemented as software packages within the Host Memory Space (HMS) of the host computing system in which the MMPGRS is embodied. - The Division Control Module
- In the Division Control Module, all graphics commands and data are processed for decomposition and marked for division. However, these commands and data are sent in a single stream into the Distribution Module for physical distribution. The Division Control Module controls the division parameters and data to be processed by each GPU, according to parallelization scheme instantiated at any instant of system operation (e.g. division of data among GPUs in the Object Division Mode, or the partition of the image screen among GPUs in the Image Division Mode).
- In the Image Division Mode, the Division Control Module assigns for duplication all the geometric data and common rendering commands to all GPUs. However specific rendering commands to define clipping windows corresponding to image portions at each GPU, are assigned separately to each GPU.
- In the Object Division Mode, polygon division control involves sending each polygon (in the scene) randomly to a different GPU within the MMPGRS. This is an easy algorithm to implement, and it turns out to be quite efficient. There are different variations of this basic algorithm, as described below.
- Polygon Division Control by Distribution of Vertex Arrays
- According to this method, instead of randomly dividing the polygons, the vertex-arrays can be maintained in their entirety and sent to different GPUs, as the input might be in the form of vertex arrays, and dividing it may be too expensive.
- Polygon Division Control by Dynamic Load Balancing
- According to this method, GPU loads are detected at real time and the next polygon is sent to the least loaded GPU. Dynamic load balancing is achieved by building complex objects (out of polygons). GPU loads are detected at real time and the next object is sent to the least loaded GPU.
- Handling State Validity Across the MMPGRS by State Monitoring
- The graphic libraries (e.g. OpenGL and DirectX) are state machines. Parallelization must preserve a cohesive state across all of the GPU pipelines in the MMPGRS. According to this method, this is achieved by continuously analyzing all incoming graphics commands, while the state commands and some of the data is duplicated to all graphics pipelines in order to preserve the valid state across all of the graphic pipelines in the MMPGRS. This function is exercised mainly in Object Division Mode, as disclosed in detail in Applicant's previous International Patent PCT/IL04/001069, now published as WIPO International Publication No. WO 2005/050557, incorporated herein by reference in its entirety.
- The Description of the Distribution Module of the Present Invention
- The primary function of the
Distribution Module 402 is to physically distribute the streams of graphics data and commands to the cluster of GPUs supported on the MMPGRS platform. Under theAMCM 400, the Distribution Module can be set to different distribution sub-states (B=1 through B=3), according toFIG. 4C , namely: the Divide Sub-state B1 during the Object Division State; the B=2 Sub-state (i.e. the Broadcast Sub-state) during the Image Division State; and the B3 Sub-state (i.e. Single GPU Sub-state) during the Time Division and Single GPU (i.e. Non-Parallel system) States. As shown inFIG. 4A , an additional source of Performance Data (i.e. beyond the GPUs, vendor's driver, and chipset) includes the internal Profiler employed in the Distribution Module in Hub-based embodiments of the present invention. - As shown in
FIG. 4A , the Distribution Module is implemented by the following components: (i) the Distribution Management Module, which addresses the streams of graphics commands and data to the different GPPLs via chipset outputs, according to needs of the parallelization schemes instantiated by the MMPGRS; (iii) Profiler module used in graphics hub type system architectures, as illustrated in FIGS. 7B1 through 7B12, so as to provide an additional source of Performance Data (i.e. beyond the GPUs, vendor's driver, and chipset); and (iv) a Hub Control module, operating under control of the Distributed GraphicsFunction Control Module 409 within theAMCM 400, in graphics hub type system architectures, as illustrated in FIGS. 7B1 through 7B12, for configuring theInterconnect Network 404 according to the various parallelization modes and to coordinate the overall functioning of hardware components within the Recomposition Module across the graphics hub device (GHD) of the present invention. - As shown in
FIG. 4A , theDistribution Module 402″ comprises three functional units: the Distribution Management, the Profiler, and the Hub Control modules. The Distribution Management activates theInterconnect network 404 to transfer command and data stream to the GPPLs. The Interconnect network serves to (i) transfer command and data stream from the CPU to GPPLs, (ii) transfer raster data from GPPLs to the Recomposition Module, (iii) transfer raster data among GPPUs for an alternative GPPL-based Recomposition, and (iv) conduct other communication tasks, such as profiling data, control, etc. among the various system components. - An exemplary embodiment of Interconnect for a cluster of 4 GPPLs is a configurable switch with 5 way PCI express ×16 lanes, having one upstream path between Hub and CPU, and 4 downstream paths between Hub and four GPUs. It receives upstream of commands and data from the CPU, and transfers them downstream to GPPLs, under the control of Distribution Management unit (of Distribution module), following the data division scheme generated by the Division Control block of Decomposition sub-module (2), according to ongoing parallel division mode. The switch can be set into one of the following possible transfer sub-states: Divide, Broadcast, and Single. The Divide sub-state is set when the MMGPRS is operating in its Object Division Mode. The Broadcast sub-state is set when the MMGPRS is operating in its Image Division Mode. The Single sub-state is set when the MMGPRS is operating in its Time Division Mode, or in Single mode.
- Within the Distribution Module, the
Profiler Unit 407′ has several functions in system architectures employing graphics hub device (GHD)s as illustrated inFIG. 1 through 7B12, namely: (i) to deliver to Division Control its own generated profiling data; (ii) to forward the profiling data from GPUs to Division Control, due the fact that the GPUs are not directly connected to the host computing system in graphics hub based system architectures, whereas they are in system architectures illustrated in FIGS. 7A2 through 7A7-3; and (iii) to forward the Hub pre-GPU profiling data to the Division Control block within the Decomposition Module. Being close to the raw data passing by the GPUs, the7B Profiler 403 monitors the stream of geometric data and commands, for graphics hub profiling purposes. Such monitoring operations involve polygon, command, and texture count and quantifying data structures and their volumes for load balance purposes. The collected data is mainly related to the performance of the geometry subsystem employed in each GPU. - Within the Distribution Module of system architectures employing the graphics hub device (GHD) of the present invention, illustrated in FIGS. 7B1 through 7B12, the
Hub Controller Module 409′, operates under control of the Distributed GraphicsFunction Control Module 409 within the AutomaticMode Control Module 400. The primary function performed by thisHub Controller Module 409′ is to configure theInterconnect Network 404 according to the various parallelization modes and to coordinate the overall functioning of hardware components across the Distribution Module of the graphics hub device (GHD) of the present invention. - The Description of the Recomposition Module of the Present Invention
- The primary function of the
Recomposition Module 403 is to merge together, the partial results of multiple graphics pipelines, according to parallelization mode that is operative at any instant in time. The resulting or final Frame Buffer (FB) is sent to the display device (via primary GPU, or directly Under theAMCM 400, the Recomposition Module can be set to three different decomposing sub-states (C=1 through C=3), according toFIG. 4C , namely: The Test Based Sub-state C=1; the Screen Based Sub-state C=2; and the None State C=3. The Test based sub-state carries out re-composition based on a test performed on partial frame buffer pixels. Typically, these tests include the depth test, the stencil test, or combination thereof. The Screen based sub-state combines together parts of the final frame buffers, in a puzzle like fashion, creating a single image. The None sub-state, or submode, makes no merges, just moves one of the pipeline frame buffers to the display, as required in time division parallelism or in single GPU (Non-Parallel) mode of operation. - The Test-Based Compositing suits compositing during the Object Division Mode. According to this method, sets of Z-buffer, stencil-buffer and color-buffer are read back from the GPU FBs to host's memory for compositing. The pixels of color-buffers from different GPUs are merged into single color-buffer, based on per pixel comparison of depth and/or stencil values (e.g. at given x-y position only the pixel associated with the lowest z value is let out to the output color-buffer). This is a software technique to perform hidden surface elimination among multiple frame buffers required for the Object Division Mode. Frame buffers are merged based on depth and stencil tests. Stencil tests, with or without combination with depth test, are used in different multi-pass algorithms. The final color-buffer is down-loaded to the primary GPU for display.
- Screen-Based Compositing Suits Compositing During the Image Division Mode
- The Screen-Based compositing involves a puzzle-like merging of image portions from all GPUs into a single image at the primary GPU, which is then sent out to the display. This method is a much simpler procedure than the Test-Based Compositing Method, as no tests are needed. While the primary GPU is sending its color-buffer segment to display, the Merger Module reads back other GPUs color-buffer segments to host's memory, for downloading them into primary GPU's FB for display.
- The None Sub-state is a non-compositing option which involves moving the incoming Frame Buffer to the display. This option is used when no compositing is required. In the Time Division Mode, a single color-buffer is read back from a GPU to host's memory and downloaded to primary GPU for display. In the Non-Parallel Mode (e.g. employing a single GPPL), usually the primary GPPL is employed for rendering, so that no host memory transit is needed.
- In the illustrative embodiments, the Recomposition Module is realized by several modules: (i) the Merge Management Module which handles the reading of frame buffers and the compositing during the Test-Based, Screen-Based And None Sub-States; (ii) the Merger Module which is an algorithmic module that performs the different compositing algorithms, namely, Test Based Compositing during the Test-Based Sub-state, and Screen Based Compositing during the Screen-Based Sub-state; (iii) Profiler module used in graphics hub type system architectures, as illustrated in FIGS. 7B1 through 7B12, so as to provide an additional source of Performance Data (i.e. beyond the GPUs, vendor's driver, and chipset); and (iv) a Hub Control module, operating under control of the Distributed Graphics
Function Control Module 409 within theAMCM 400, in graphics hub type system architectures, as illustrated in FIGS. 7B1 through 7B12, for configuring theInterconnect Network 404 according to the various parallelization modes and to coordinate the overall functioning of hardware components within the Recomposition Module across the graphics hub device (GHD) of the present invention. - In the case where the Interconnect needs to interconnect a cluster of 4 GPPLs, a configurable switch can be used having 5 way PCI express ×16 lanes, with one upstream path between the Hub and CPU, and 4 downstream paths between Hub and four GPUs. Under the local control of the Merge Management and the Hub Controller in the Recomposition Module, the Interconnect (e.g. switch) also performs the following functions: (i) transferring read-back FB raster data from GPPLs to the Merger block of Recomposition Module and returning composited image to primary GPPL, all under orchestration of the Merge Management block; (ii) transferring the read-back FB raster data among GPPLs for GPPL-based recomposition, so that the finally recomposited pixel data in final image is composited in the primary GPPL; (iii) transferring additional data, e.g. profiler data, to Decomposition module; and (iv) transferring control commands across the MMPGRS system.
- Within the Recomposition Module, the
Profiler unit 403 has several functions in system architectures employing graphics hub device (GHD)s as illustrated inFIG. 1 through 7B12, namely: (i) to deliver to Division Control its own generated profiling data; (ii) to forward the profiling data from GPUs to Division Control, due the fact that the GPUs are not directly connected to the host computing system in graphics hub based system architectures, whereas they are in system architectures illustrated in FIGS. 7A2 through 7A7-3; and (iii) to forward the Hub post-GPU profiling data to the Division Control block within the Decomposition Module. Being close to the raw data passing by the GPUs, the7B Profiler 403 monitors the stream of geometric data and commands, for graphics hub profiling purposes. Such monitoring operations involve polygon, command, and texture count and quantifying data structures and their volumes for load balance purposes. The collected data is mainly related to the performance of the geometry subsystem employed in each GPU. - Another function performed by the
Profiler 403 within the Recomposition Module is to profile the merge process and monitor the task completion of each GPU for load balancing purposes. In graphics hub device (GHD) class of system architecture illustrated in FIGS. 7B1 through 7B12, bothProfilers 407′ and 403′, in the Distribution and Recomposition Modules, unify their collected Performance Data and deliver the unified performance data, as feedback, to the Automatic Mode Control Module (AMCM) via the Decomposition Module, as shown inFIG. 4A . Notably, the communication linkage between the two Profiling blocks is achieved using theInterconnect network 404. In some illustrative embodiments, the two “pre-GPU” and “post-GPU” units of the graphics hub device (GHD), formed by the components within the Distribution and Recomposition Modules of system architectures illustrated in FIGS. 7B1 through 7B12, may reside on the same silicon chip, having many internal interconnections, whereas in other illustrative embodiments, these subcomponents may be realized on different pieces of silicon or functionally like semiconductor material, used to fabricate the graphics hub device (GHD)s of the present invention within diverse embodiments of the MMPGRS of the present invention. - Within the Recomposition Module of system architectures employing the graphics hub device (GHD) of the present invention, illustrated in FIGS. 7B1 through 7B12, the
Hub Controller Module 409′, operates under control of the Distributed GraphicsFunction Control Module 409 within theAMCM 400. The primary function performed by thisHub Controller Module 409′ is to configure theInterconnect Network 404 according to the various parallelization modes and to coordinate the overall functioning of hardware components across the Recomposition Module of the graphics hub device (GHD) of the present invention. - Notably, in some illustrative embodiments of the present invention, the
Hub Controllers 409′, in the Distribution and Recomposition Modules in system architectures embraced by the graphics hub device (GHD) of the present invention, can be realized as a single device or unit, on the same piece of silicon or like semiconductor material. In other embodiments, theHub Controllers 409′ can be realized as discrete units, on the same piece of silicon or like semiconductor material, or on separate pieces of silicon material (e.g. on different chips sets). - Description of the Automatic Mode Control Module (AMCM) 400 within the MMPGRS of the Present Invention
- During the run-time of any graphics-based application on the host computing system, the MMPGRS renders and displays the graphics environment being generated by the application, which typically will include many dynamically changing scenes, where the plot unfolds, and each scene typically involves a sequence of many image frames. Such scenes could involve virtually anything, including a forest with many leaves moving in the wind, a lake with many reflections, or a closed space in a castle with many light sources. Such scenes require parallel rendering, and the role of the MMPGS is to automatically determine which mode of parallel operation will result in optimal performance on the host computing system.
- As shown in
FIG. 4A , the Automatic Mode Control Module (AMCM) 400 comprises three algorithmic modules, namely: an Application Profiling andAnalysis Module 407; a ParallelPolicy Management Module 408; and a Distributed Graphics Function Control. - In the preferred embodiment shown in
FIG. 4B , the AMCM also comprises two data stores: aHistorical Repository 404; and a Application/Scene Profile Database 405. The primary function of the AMCM is to control the state of Multi-modeParallel Rendering Subsystem 410 by virtue of its flexible multi-state behavior and fast interstate transition capabilities. - As shown in
FIG. 4C , theAMCM 400 comprises a User Interaction Detection (UID)Subsystem 438 which includes a Detection andCounting Module 433 in combination with a UIDTransition Decision Module 436. These subsystems and modules will be described in greater detail hereinbelow. - Overview on the Automatic Mode Control Module (AMCM) in the MMPGRS of the Present Invention
- When implementing the Automatic Mode Control Module or Mechanism (AMCM) in the MMPGRS of the present invention, there are several classes of techniques which can be usefully applied, to determine when and how to switch into, out of, and transition between modes of parallel operation on the MMPGRS platform, during the run-time of a particular graphics-based application, and optimize system performance, namely: Mode Control Techniques Based On Scene/Application Profiling; and Mode Control Techniques Based On System-User Interaction Detection. It is appropriate at this juncture to provide an overview on the various techniques that the AMCM can use to best determine how to automatically control the mode of parallel operation on the MMPGRS Platform, and optimize system performance.
- Description of Mode Control Techniques Employed within the AMCM Based on Scene/Application Profiling
- (1) Real-Time Profiling of Scenes (on a Frame-by-Frame Basis):
- This method involves collecting and analysis of Performance Data, during application run-time, in order to construct scene profiles for image frames associated with particular scenes in a particular graphics-based application, and maintaining these scene profiles in the Scene/Application Profile Database within the AMCM. This way, during run-time, the AMCM can access and use these scene profiles so as to best determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance. As will be described in greater detail hereinafter, this technique can be practiced using the Application Profiling and
Analysis Module 407 and ParallelPolicy Management Module 408 illustrated inFIGS. 4A, 4D , 5C1, 5C2, 5C3, and 5C4, in the context of highly diverse MMPGRS system architectures, as well as within multi-user application environments supported over distributed network environments, as shown inFIGS. 12A and 12B . - (2) Real-Time Detection of Scene Profile Indices Directly Programmed within Pre-Profiled Scenes of Particular Applications:
- This technique involves analyzing, prior to run-time, the scenes of a particular application, and then indexing the scene with Scene Profile Indices and storing corresponding Mode Control Parameters (MCPs) (e.g. Switch to Object Division Mode) within the local Scene/Application Profile Database within the AMCM, or other data storage device that is accessible in real-time by the AMCM during application run-time. Then during run-time, the AMCM automatically detects the scene, and consults the Scene Profile Indices for the corresponding MCPs from the Scene/Application Profile Database so as to best determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance.
- (3) Real-Time Detection of Mode Control Command (MCCs) Directly Programmed within Pre-Profiled Scenes of Particular Applications:
- This technique involves, prior to run-time (e.g. during game application development), analyzing the scenes of a particular application, and the directly programming Mode Control Commands (MMCs) (e.g. Switch to Object Division Mode) within the individual image frames of each scene, following standards to be established and followed by developers in the computer graphics industry. Then during run-time, the MCM automatically detects these MCCs along the graphics command and data stream, and use these commands so as to best determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance.
- Description of Mode Control Techniques Employed within the AMCM Based on System-User Interaction Detection
- This approach, which can be used in conjunction with any of the above Scene/Application Profiling Techniques, involves automatically detecting the users interaction with the host computing system (e.g. mouse device movement, keyboard depressions, etc) and providing this Interaction Data to the AMCM so that it can best determine how to dynamically control the modes of parallel operation of the MMPGRS to optimize system performance, given the user's interaction with the host computing system, or application running thereon, at any instance in time. As will be described in greater detail hereinafter, this technique can be practiced using the
UID Subsystem 438 illustrated inFIGS. 5A, 5B and 5C2. - The Application Profiling and Analysis Module
- As shown in
FIG. 4D , the Application Profiling andAnalysis Module 407 monitors and analyzes Performance and Interactive data streams continuously acquired by profiling the Application while its running. InFIG. 5D , the Performance Data inputs provided to the Application Profiling and Analysis Module include: texture count; screen resolution; polygon count; utilization of geometry engine, pixel engine, video memory and GPPL; the total pixels rendered, the total geometric data rendered; the workload of each GPPL; the volumes of transferred data. The System-User Interactive (Device) Data inputs provided to the Application Profiling and Analysis Module include: mouse movement; head movement; voice commands; eye movement; feet movement; keyboard; LAN, WAN or Internet (WWW) originated application (e.g. game) updates. - The Tasks performed by the Application Profiling and Analysis Module include: Recognition of the Application; Processing of Trial and Error Results; Utilization of Application Profile from Application/Scene Profile Database; Data Aggregation in the Historical Depository; Analysis of input performance data (frame-based); Analysis based on integration of frame-based “atomic” performance data, aggregated data at Historical Depository, and Application/Scene Profile Database data; Detection of rendering algorithms used by Application; Detection of use of FB in next successive frame; Recognition of preventative conditions (to parallel modes); Evaluation of pixel layer depth; Frame/second count; Detection of critical events (e.g. frames/sec/drop); Detection of bottlenecks in graphics pipeline; Measure of load balance among GPUs; Update Application/Scene Profile Database from the Historical Depository; and Recommendation on optimal parallel scheme.
- The Application Profiling and Analysis Module performs its analysis based on the following:
- (1) The Performance Data collected from several sources, such as vendor's driver, GPUs, chipset, and optionally—from the graphics Hub embodiments of the present invention, described in greater detail hereinafter;
- (2)
Historical repository 404 which continuously stores up the acquired data (i.e. this data having historical depth, and being used for constructing behavioral profile of ongoing application); and - (3) Knowledge based Application/
Scene Profile Database 405 which is an application profile library of prior known graphics applications (and further enriched by newly created profiles based on data from the Historical Depository). - In the MMGPRS of the illustrative embodiment, the choice of parallel rendering mode at any instant in time involves profiling and analyzing the system's performance by way of processing both Performance Data Inputs and Interactive Device Inputs, which are typically generated from a several different sources within MMPGRS, namely: the GPUs, the vendor's driver, the chipset, and the graphic Hub (optional).
- Performance Data needed for estimating system performance and locating casual bottlenecks, includes:
-
- (I) Texture Count;
- (Ii) Screen Resolution;
- (Iii) Polygon Volume;
- (iv) at each GPPL, utilization of
- (a) the Geometry Engine
- (b) the Pixel engine, and
- (c) Video memory;
- (v) Utilization of the CPU;
- (vi) total pixels rendered;
- (vii) total geometric data rendered;
- (viii) workload of each GPU; and
- (ix) volumes of transferred data.
- As shown in
FIG. 4D , this Performance Data is fed as input into the Application Profiling and Analysis Module for real-time processing and analysis Application Profiling and Analysis Module. In the illustrative embodiment, the Application Profiling and Analysis Module performs the following tasks: -
- (1) Recognition of Application (e.g. video game, simulation, etc.);
- (2) Processing of trial & error results produced by the processes described in FIGS. 5C3 and 5C4;
- (3) Utilization of the Application Profile from data in the Application/Scene Profile Database;
- (4) Aggregation of Data in the Historical Repository;
- (5) Analysis of Performance Data Inputs;
- (6) Analysis based on the integration of
- (a) Frame-based “atomic” Performance Data,
- (b) Aggregated data within the Historical Repository, and
- (c) Data stored in the Application/Scene Profile Database;
- (7) Detection of rendering algorithms used by Application
- (8) Detection of use of the FB in next successive frame as a preventive condition for Time Division Mode;
- (9) Recognition of preventive conditions for other parallel modes;
- (10) Evaluation of pixel layer depth at the pixel subsystem of GPU;
- (11) Frame/sec count;
- (12) Detection of critical events (e.g. frame/sec drop);
- (13) Detection of bottlenecks in graphics pipeline;
- (14) Measure and balance of load among the GPUs;
- (15) Update Application/Scene Profile Database from data in the Historical Depository; and
- (16) Selection of the optimal parallel graphics rendering mode of operation for the MMPGRS.
The Parallel Policy Management Module
- Parallel
Policy Management Module 408 makes the final decision regarding the preferred mode of parallel graphics rendering used at any instant in time within the MMPGRS, and this decision is based on the profiling and analysis results generated by the Application Profiling and Analysis Module. The decision is made on the basis of some number N of graphics frames. As shown above, the layer depth factor, differentiating between the effectiveness of the Object Division vs. Image Division Mode, can be evaluated by analyzing the relationship of geometric data vs. fragment data at a scene, or alternatively can be found heuristically. Illustrative control policies have been described above and in FIGS. 5C1 through 5C3. - The Distributed Graphic Function Control Module Distributed Graphic
Function Control Module 409 carries out all the functions associated with the different parallelization modes, according to the decision made by the Parallel Policy Management Module. The Distributed GraphicFunction Control Module 409 drives directly the configuration sub-states of the Decomposition, Distribution and Recomposition Modules, according to the parallelization mode. Moreover, Application Profiling and Analysis includes drivers needed for hardware components such as graphic Hub, described hereinafter in the present Patent Specification. - State Transitions within the MMPGRS of the Illustrative Embodiment of the Present Invention
- As shown in the state transition diagram of
FIG. 6A , the MMPGRS of the illustrative embodiment has six (6) system states. Three of these system states are parallel graphics rendering states, namely: the Image Division State, which is attained when the MMPGRS is operating in its Image Division Mode; the Object Division State, which is attained when the MMPGRS is operating in its Object Division Mode; and the Time Division State, which is attained when the MMPGRS is operating in its Time Division Mode. The system also includes a Non-Parallel Graphics Rendering State, which is attained only when a single GPPL is operational during the graphics rendering process. There is also an Application Identification State, and a Trial & Error Cycle State. As illustrated inFIG. 4C andFIG. 6A , each parallelization state is characterized by sub-state parameters A, B, C. As shown in the state transition diagram ofFIG. 6A , the Non-Parallel (i.e. Single GPPL) State is reachable from any other state of system operation. - In accordance with the principles of the present invention, profiles of all previously analyzed and known graphics-based Applications are stored in the Application/
Scene Profile Database 405 of the MMPGRS. Whenever the graphics-based application starts, the system enters Application Identification State, and the AMCM attempts to automatically identify whether this application is previously known to the system. In the case of a previously known application, the optimal starting state is recommended by the Database, and the system transitions to that system state. Further on, during the course of the application, the AMCM is assisted by the Application/Scene Profile Database to optimize the inter-state tracking process within the MMPGRS. In the case of an application previously unknown to the MMPGRS, the Trial & Error Cycle State is entered, and attempts to run all three parallelization schemes (i.e. Modes) are made for a limited number of cycles. - During the course of the Application, the decision by the system as to which mode of graphics rendering parallelization to employ (at any instant in time) is supported either by continuous profiling and analysis, and/or by trial and error. The Trial and Error Process is based on comparing the results of a single, or very few cycles spent by the system at each parallelization state.
- During the course of continuous profiling and analysis by the Application Profiling and
Analysis Module 407, the following parameters are considered and analyzed by the AMCM with respect to each state/mode transition decision: -
- Pixel processing load
- Screen resolution
- Depth complexity of the scene
- Polygon count
- Video-memory usage
- Frame/second rate
- Change of frames/second rate
- Tolerance of latency
- Use of the same FB in successive frame
- (10) User-System Interaction during the running of the Application.
User-Interactivity Driven Mode Selection within the MMPGRS of the Present Invention
- Purely in terms of “frames/second” rate, the Time Division Mode is the fastest among the parallel graphics rendering modes of the MMGRS, and this is by virtue of the fact that the Time Division Mode works favorably to reduce geometry and fragment bottlenecks by allowing more time. However, the Time Division Mode (i.e. method) of parallelization does not solve video memory bottlenecks. Also, the Time Division Mode suffers from other problems, namely: (i) CPU bottlenecks; (ii) the unavailability of GPU-generated frame buffers to each other, in cases where the previous frame is required as a start point for the successive frame; and also (iii) from pipeline latency. Automatic transition of the MMGPRS to its Object-Division Mode effectively releases the system from transform and video memory loads. In many applications, these problems provide reasons not for the MMPGS to use or enter into its Time Division Mode. However, for some other applications, the Time Division Mode may be suitable and perform better than other parallelization schemes available on the MMGPRS of the present invention (e.g. Object-Division Mode and Image-Division Mode).
- During the Time Division Mode, the pipeline latency problem arises only when user-system interaction occurs. Also, in many interactive gaming applications (e.g. video games), often there are 3D scenes with intervals of user-system interactivity during the Time Division Mode. Thus, in order to achieve the highest performance mode of parallel graphics rendering at runtime, the MMPGRS of the present invention employs a User Interaction Detection (UID)
Subsystem 438 which enables automatic and dynamic detection of the user's interaction with the system. Absent preventive conditions (such as CPU bottlenecks and need for the same FB in successive frames), theUID subsystem 438 enables timely automated implementation of the Time Division Mode only when no user-system interactivity is detected so that system performance is automatically optimized. - These and other constraints are taken into account during the inter-modal transition process, as illustrated in the State Transition Diagram of
FIG. 6A , and described below: - Transition from Object Division to Image Division follows a combination of one or more of the following conditions:
-
- Increase in pixel processing load
- Increase in screen resolution
- Increase in scene depth complexity
- Decrease in polygon count
- Transition from Image Division to Object Division follows a combination of one or more of the following conditions:
-
- Increase of polygon count
- Increase of video memory footprint
- Decrease of scene depth complexity
- Transition from Object Division to Time Division follows a combination of one or more of the following conditions:
-
- Demand for higher frame/second rate
- Higher latency is tolerated
- There is no use of the FB for successive frame
- No predefined input activity detected by the UID Subsystem
- Transition from Time Division to Object Division follows a combination of one or more of the following conditions:
-
- Latency is not tolerable
- FB is used for successive frame
- High polygon count
- Input activity detected by the UID Subsystem
- Transition from Time Division to Image Division follows a combination of one or more of the following conditions:
-
- Latency is not tolerable
- FB is used for successive frame
- High pixel processing load
- Input activity detected by the UID Subsystem
- Transition from Image Division to Time Division follows a combination of one or more of the following conditions:
-
- Demand for higher frame/second rate
- Latency is tolerable
- High polygon count
- No predefined input activity detected by the UID Subsystem.
- In the illustrative embodiment, this capacity of the MMPGRS is realized by the User Interaction Detection (UID)
Subsystem 438 provided within the Application Profiling andAnalysis Module 407 in the Automatic Mode Control Module of the system. As shown inFIG. 5A , theUID subsystem 438 comprises: a Detection andCounting Module 433 in combination with a UIDTransition Decision Module 436. - As shown in
FIGS. 5A and 4D , the set of interactive devices which can supply User Interactive Data to the UID subsystem can include, for example, a computer mouse, a keyboard, eye-movement trackers, head-movement trackers, feet-movement trackers, voice command subsystems, Internet, LAN, WAN and/or Internet originated user-interaction or game updates, and any other means of user interaction detection, and the like. - As shown in
FIG. 5A , eachinteractive device input 432 supported by the computing system employing the MMPGRS feeds User Interaction Data to the Detection andCounting Module 433 which automatically counts the elapsed passage of time for the required non-interactive interval. When such a time interval is counted or has elapsed (i.e. without detection of user-system interactivity), the Detection andCounting Module 433 automatically generates a signal indicative of this non-interactivity (434) which is transmitted to the UIDTransition Decision Module 436. Thereafter, UIDTransition Decision Module 436 issues a state transition command (i.e. signal) to the ParallelPolicy Management Module 408, thereby causing the MMPGRS to automatically switch from its currently running parallel mode of graphics rendering operation, to its Time Division Mode of operation. During the newly initiated Time Division Mode, whenever system-user interactivity from the interactive device is detected 432 by the Detection andCounting Module 433, an system-user interactivity signal 435 is transferred to the UIDTransition Decision Module 436, thereby initiating the system to return from the then currently Time Division Mode, to its original parallel mode of operation (i.e. the Image or Object Division Mode, as the case may be). - As shown in
FIG. 5A , anInitialization Signal 431 is provided to the Detection andCounting Module 433 when no preventive conditions for Time Division exist. The function of theInitialization Signal 431 is to (1) define the set of input (interactive) devices supplying interactive inputs, as well as (2) define the minimum elapsed time period with no interactive activity required for transition to the Time Division Mode (termed non-interactive interval). The function of the UIDTransition Decision Module 436 is to receive detectedinputs 435 and noinputs 434 during the required interval, and, produce and provide as output, a signal to the Parallel Policy Management System, initiating a transition to or from the Time Division Mode of system operation, as shown. - In applications dominated by Image Division or Object Division Modes of operation, with intervals of non-interactivity, the
UID Subsystem 438 within the MMGPRS can automatically initiate a transition into its Time Division Mode upon detection of user-interactivity, without the system experiencing user lag. Then as soon as the user is interacting with the application, the UID Subsystem of the MMGPRS can automatically transition (i.e. switch) the system back into its dominating mode (i.e. the Image Division or Object Division). The benefits of this method of automatic “user-interaction detection (UID)” driven mode control embodied within the MMGRPS of the present invention are numerous, including: best performance; no user-lag; and ease of implementation. - Notably, the automated event detection functions described above can be performed using any of the following techniques: (i) detecting whether or not a mouse movement or keyboard depression has occurred within a particular time interval (i.e. a strong criterion); (ii) detecting whether or not the application (i.e. game) is checking for such events (i.e. a more subtle criterion); or (iii) allowing the application's game engine itself to directly generate a signal indicating that it is entering an interactive mode.
- The state transition process between Object-Division/Image-Division Modes and the Time Division Mode initiated by the UID subsystem of the present invention is described in the flow-chart shown in
FIG. 5B . As shown therein, at Block A, the UID subsystem is initialized. At Block B, the time counter of the Detection andCounting Module 433 is initialized. At Block C, the UID subsystem counts for the predefined non-interactive interval, and the result is repeatedly tested at Block D. When the test is positively passed, the parallel mode is switched to the Time-Division at Block E by the Parallel Policy Management Module. At Block F, the UID subsystem determines whether user interactive input (interactivity) has been detected, and when interactive input has been detected, the UID subsystem automatically returns the MMPGRS to its original Image or Object Division Mode of operation, at Block G ofFIG. 5B . - As will be described in greater detail below, the entire process of User-Interactivity-Driven Mode Selection occurs within the MMPGRS of the present invention when N successive frames according control policy are run in either the Object Division or Image Division Mode of operation, as shown during Blocks I and J of FIGS. 5C1 and 5C2.
- Operation of the Automatic Mode Control Cycle within the MMPGRS of the Present Invention
- Referring to
FIG. 1, the Profiling and Control Cycle Process within the MMPGRS will now be described in detail, wherein each state transition is based on above listed parameters (i.e. events or conditions) (1) through (6) listed above, and the UID Subsystem is disabled. In this process, Steps A through C test whether the graphics application is listed in the Application/Scene Profile Database of the MMPGRS. If the application is listed in the Application/Scene Profile Database, then the application's profile is taken from the Database at Step E, and a preferred state is set at Step G. During Steps I-J, N successive frames are rendered according to Control Policy, under the control of the AMCM with its UID Subsystem disabled. At Step K, Performance Data is collected, and at Step M, the collected Performance Data is added to the Historical Repository, and then analyzed for next optimal parallel graphics rendering state at Step F. Upon conclusion of application, at Step L, the Application/Scene Profile Database is updated at Step N using Performance Data collected from the Historical Repository.5C - Referring to
FIG. 2, the Profiling and Control Cycle Process within the MMPGRS will now be described in detail, with the UID Subsystem is enabled. In this process, Steps A through C test whether the graphics application is listed in the Application/Scene Profile Database of the MMPGRS. If the application is listed in the Application/Scene Profile Database, then the application's profile is taken from the Database at Step E, and a preferred state is set at Step G. During Steps I-J, N successive frames are rendered according to Control Policy under the control of the AMCM with its UID Subsystem enabled and playing an active role in Parallel Graphics Rendering State transition within the MMPGRS. At Step K, Performance Data is collected, and at Step M, the collected Performance Data is added to the Historical Repository, and then analyzed for next optimal parallel graphics rendering state at Step F. Upon conclusion of application, at Step L, the Application/Scene Profile Database is updated at Step N using Performance Data collected from the Historical Repository.5C - Operation of the Periodical Trial & Error Process of the Present Invention within the MMPGRS of the Present Invention
- As depicted in
FIG. 3, the Periodical Trial & Error Process differs from the Profiling and Control Cycle Process/Method described above, based on its empirical approach. According the Periodical Trial & Error Process, the best parallelization scheme for the graphical application at hand is chosen by a series of trials described at Steps A through M in5C FIG. 3. After N successive frames of graphic data and commands are processed (i.e. graphically rendered) during Steps N through O, another periodical trial is performed at Steps A through M. In order to omit slow and not necessary trials, a preventive condition for any of parallelization schemes can be set and tested during Steps B, E, and H, such as used by the application of the Frame Buffer FB for the next successive frame, which prevents entering the Time Division Mode of the MMPGRS.5C - In the flowchart of
FIG. 4, a slightly different Periodical Trial & Error Process (also based on an empirical approach) is disclosed, wherein the tests for change of parallel graphics rendering state (i.e. mode) are done only in response to, or upon the occurrence of a drop in the frame-rate-per-second (FPS), as indicated during Steps O, and B through M.5C - Conditions for Transition Between Object and Image Division Modes of Operation in the MMPGRS of The Present Invention
- In a well-defined case, Object Division Mode supersedes the Image Division Mode in that it reduces more bottlenecks. In contrast to the Image Division Mode that reduces only the fragment/fill bound processing at each GPU, the Object Division Mode relaxes bottleneck across the pipeline: (i) the geometry (i.e. polygons, lines, dots, etc) transform processing is offloaded at each GPU, handling only 1/N of polygons (N—number of participating GPUs); (ii) fill bound processing is reduced since less polygons are feeding the rasterizer; (iii) less geometry memory is needed; and (iv) less texture memory is needed.
- Automated transition to the Object Division State of operation effectively releases the MMPGRS of the present invention from transform and video memory loads. However, for fill loads, the Object Division State of operation will be less effective than the Image Division State of operation.
- At this juncture it will be helpful to consider under what conditions a transition from the Object Division State to the Image Division State can occur, so that the parallel graphics system of the present invention will perform better “fill loads”, especially in higher resolution.
- Notably, the duration of transform and fill phases differ between the Object and Image Division Modes (i.e. States) of operation. For clarity purposes, consider the case of a dual-GPU graphics rendering system. Rendering time in the Image Division Mode is given by:
T ObjDiv=Transform+Fill/2 (1)
whereas in Object Division Mode, the fill load does not reduce in the same factor as transform load.
The render time is:
T ImgDiv=Transform/2+DepthComplexity*Fill/2 (2)
The fill function Depth Complexity in Object Division Mode depends on depth complexity of the scene. Depth complexity is the number of fragment replacements as a result of depth tests (the number of polygons drawn on every pixel). In the ideal case of no fragment replacement (e.g. all polygons of the scene are located on the same depth level), the second component of the Object Division Mode reduces to:
T ImgDiv=Transform/2+Fill/2 (2)
However, when depth complexity becomes high, the advantage of the Object Division Mode drops significantly, and in some cases the Image Division Mode may even perform better (e.g. in Applications with small number of polygons and high volume of textures).
The function DepthComplexity denotes the way the fill time is affected by depth complexity:
where E(L) is the expected number of fragments drawn at pixel for L total polygon layers. In ideal case DepthComplexity=1. In this case, E is given by:
For a uniform layer-depth of L throughout the scene, the following algorithm is used to find conditions for switching from the Object Division Mode to the Image Division Mode:
In order to choose between the Image Division and the Object Division Mode, an algorithm is used which detects which transform and fill bound processing is smaller. Once the layer-depth reaches some threshold value throughout the scene, the Object Division Mode will not minimize the Fill function any more. - Denote the time for drawing n polygons and p pixels as Render(n,p), and allow P to be equal to the time taken to draw one pixel. Here the drawing time is assumed to be constant for all pixels (which may be a good approximation, but is not perfectly accurate). Also, it is assumed that the Render function, which is linearly dependent on p (the number of pixels actually drawn), is independent of the number of non-drawings that were calculated. This means that if the system has drawn a big polygon that covers the entire screen surface first, then for any additional n polygons: Render(n,p)=p×P.
- The screen space of a general scene is divided into sub-spaces based on the layer-depth of each pixel. This leads to some meaningful figures.
- For example, suppose a game engine generates a scene, wherein most of the screen (90%) has a depth of four layers (the scenery) and a small part is covered by the player (10%) with a depth of 20 layers. Without Object Division Mode support, the value of Render function is given by:
Render(n,p)=p×0.9×E(4)+p×0.1×E(20)=2.2347739657143681×p
With Object Division Mode support, the value of the Render function is:
Render(n/2,p)=p×0.9×E(4/2)+p×0.1×E(20/2)=1.6428968253968255×p
Notably, in this case, the improvement factor when using Object Division Mode support is 1.3602643398952217. On the other hand, a CAD engine might have a constant layer depth of 4. The improvement factor for interesting cases is shown in a table set forth in copending application Ser. No. 11/789,039, supra. - It is easily seen from that table that when the layer depth DepthComplexity becomes larger, the Object Division Mode does not improve the rendering time by a large amount, and if rendering time is the bottleneck of the total frame calculation procedure, then the Image Division Mode might be a better approach. The analysis results by the Application Profiling and Analysis Module are passed down to the next module of Parallel Policy Management Module.
- Parallel Graphics Rendering Process of the Present Invention Performed During Each Mode of Parallelism On The MMPGRS
- The parallel graphics rendering process performed during each mode of parallelism on the MMPGRS will now be described with reference to the Parallel Graphics Processing Pipeline Model of
FIG. 6B and flowcharts set forth in FIGS. 6C1, 6C2 and 6C3, for the Image, Time and Object Division Modes, respectively. - Parallel Graphics Rendering Process for a Single Frame During the Image Division Mode of the MMPRS of the Present Invention
- In
FIG. 1, the parallel graphics rendering process for a single frame is described in connection with the Image Division Mode of the MMPRS of the present invention. In the Image Division Mode, the Decomposition, Distribution and Recomposition Modules are set as follows: the Decomposition Module is set on sub-state A-2, the Distribution Module is set on sub-state B-2, and the Recomposition Module is set on sub-state C-2. The Decomposition Module splits up the image area into sub-images and prepares partition parameters for each6C GPPL 6120. Typically, the partition ratio is dictated by the Automatic Mode Control Module based on load balancing considerations. The physical distribution of these parameters among multiple GPPLs is done by the Distribution Module (6124). From this point on the stream of commands and data (6121) is broadcasted to all GPPLs for rendering (6123), unless end-of-frame is encountered (6122). When rendering of frame is accomplished, each GPPL holds a different part of the entire image. Compositing of these parts into final image is done by the Recomposition Module moving all partial images (i.e. color-FB) from secondary GPPLs to the primary GPPL (6125), merging the sub-images into final color-FB (6126), and displaying the FB on the display screen (6127). - Parallel Graphics Rendering Process for a Single Frame During the Time Division Mode of the MMPRS of the Present Invention
- In
FIG. 2, the parallel graphics rendering process for a single frame is described in connection with the Time Division Mode of the MMPRS of the present invention. In the Time Division Mode, the Decomposition, Distribution and Recomposition Modules are set as follows: the Decomposition Module is set on sub-state A-3, the Distribution Module is set on sub-state B-3, and the Recomposition Module is set on sub-state C-3. The Decomposition Module aligns a queue of6C GPPLs 6130, appoints the next frame to the nextavailable GPPL 6131, and monitors the stream of commands and data to allGPPLs 6132. The physical distribution of that GCAD stream is performed by theDistribution Module 6134. Upon detection of an end-of-frame command 6133 at one of the GPPLs, the control moves to the Recomposition Module which moves the color-FB of the completing secondary GPPL, to theprimary GPPLs 6135. The primary GPPL then displays the recomposited image in the FB on thedisplay screen 6136 of the display device. - Parallel Graphics Rendering Process for a Single Frame During the Object Division Mode of the MMPRS of the Present Invention
- In
FIG. 3, the parallel graphics rendering process for a single frame is described in connection with the Object Division Mode of the MMPRS implemented according to the software-based architecture of the present invention. In the Object Division Mode, the Decomposition, Distribution and Recomposition Modules are set as follows: the Decomposition Module is set on sub-state A-1, the Distribution Module is set on sub-state B-1, and the Recomposition Module is set on sub-state C-1. The Decomposition Module activity starts with interception of graphics commands 6140 on their way between standard graphics library (e.g. OpenGL, Dirct3D) and vendor's GPU driver. Each graphics command is tested for blocking6C mode state operation class 6144. Blocking operations are exceptional in that they require a composed valid FB data, thus in the Object Division Mode, they have an inter-GPPL effect. Therefore, whenever one of the blocking operations is issued, all the GPPLs must be synchronized. Each frame has at least 2 blocking operations: Flush and Swap, which terminate the frame. State operations (e.g. definition of light source) have an across the board effect on all GPPLS. In both cases the command must be duplicated to all GPPLs, rather than delivered to one of them. Therefore the Distribution Module physically sends the command to allGPPLs 6150. On the other hand, a regular command that passed the above tests is designated to asingle target GPPL 6145, and sent by Distribution Module to thatGPPL 6151. - When a blocking mode command is detected 6143, a blocking flag is set on 6147 indicating blocking state. At this point, a composition of all frame buffers must occur and its result be duplicated to all GPPL. The rendering of upcoming commands is mirrored (duplicated) at all of the GPPL, unless an end-of-blocking mode is detected. The compositing sequence includes issuing of a
flushing command 6149 to empty the pipeline. Such a command is sent to allGPPLs 6152. Then at each GPPL the color and Z Frame Buffer are read back tohost memory 6154, and all color Frame Buffers are composited based on Z andstencil buffers 6156. Finally, the resulting Frame Buffer is sent to allGPPLs 6160. All successive graphics commands will be duplicated (i.e. replicated) to all GPPLs generating identical rendering results, unless the blocking mode flag is turned off. When the end-of-blocking mode is detected 6146, the blocking flag is turned off 6148 and regular object division is resumed. - When detected 6144 by the Decomposition Module, state operation commands (e.g. glLight, glColor) are being duplicated to all
GPPLs 6150. Upon End-of-frame detection 6141, a compositing process is takingplace - Illustrative Designs for the Multi-Mode Parallel Graphics Rendering System (MMPGRS) of the Present Invention Having Diverse System Architectures Parallelizing the Operation of Multiple Graphics Processing Pipelines (GPPLs)
-
FIG. 7A 1-1 sets forth a schematic diagram that illustrates different environments for practicing the embodiments of MMPGRS present invention, namely: Host Memory Space (HMS), Processor/CPU Die Space, Bridge Circuit (IGD) Space, Graphics Hub Space, and External GPU Space. - In
FIG. 7A 1-2, the table describes eleven (11) different Classes of MMPGRS Architecture, defined in terms of the Architectural Spaces specified inFIG. 7A 1-1 in which the primary MMPGRS components are embodied in any particular Class of MMPGRS Architecture, namely: Host Memory Space HMS (software); HMS+IGD; HMS+Fusion; HMS+Multicore; HMS+GPU-Recomposition; HUB; HUB+GPU-Recomposition; Chipset; CPU/GPU Fusion; Multicore CPU; and Game Console. - The MMPGRS Architecture Table (i.e. Map) of the illustrative embodiments of the present invention illustrates several things.
- First, within each MMPGRS Architecture, illustrated in
FIG. 7A 1-2, the Automatic Mode Control Module (AMCM) 400 and Modules and Submodules of the Multimode ParallelGraphics Rendering Subsystem FIG. 7A 1-1, while multiple GPPLs, distributed in various ways in such environment, are driven multiple modes of parallelism that are dynamically managed in accordance with the principles of the present invention. Secondly, each Class of MMPGRS Architecture will typically have numerous implementation options, with the illustrative embodiments shown in FIGS. 8A through 11D1 simply being just a handful of possible implementation options. - Thirdly, the MMPGRS Architecture Table set forth in
FIG. 7A 1-2 is by no means a list of all possible Class of MMPGRS Architecture, but rather is an exemplary listing of the primary classes which comes to mind of the Inventors at the time of filing the present Application, and that it is expected, in the future, that other architectural spaces will evolve or be developed, thereby providing additional environments in which the MMPGRS of the present invention may be embodied or otherwise practiced. Various examples of how the MMPGRS of the present invention can be practiced will be described in greater detail below. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation of Multiple GPUs Supported on External Graphics Cards
- In
FIG. 2, the first illustrative embodiment of the MMPGRS of7A present invention 700 is shown embodied within the HMS Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution andRecomposition Modules software package 701 in the Host Memory Space (HMS) while multiple GPUs are supported on a pair of externalgraphic cards Decomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (ii) theDistribution Module 402 uses the North bridge chip to distribute graphic commands and data (GCAD) to the multiple GPUs on board the external graphics cards, (iii) theRecomposition Module 403 uses the North bridge chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (iv) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphics cards via a PCI-express interface, which is connected to the North bridge chip. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation of GPU Supported on Integrated Graphics Device (IGD) and Multiple GPUs Supported on External Graphics Cards
- In
FIG. 3, the second illustrative embodiment of the MMPGRS of present invention is shown embodied within the HMS+IGD Class of MMPGRS Architecture described in7A FIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution andRecomposition Modules software package 701 in the Host or CPU Memory Space (HMS), while multiple GPUs are supported in an IGD within the North memory bridge circuit as well as on external graphic cards connected to the North memory bridge chip and driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM. During operation (i) theDecomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (ii) theDistribution Module 402 uses the North bridge chip to distribute the graphic commands and data (GCAD) to the multiple GPUs located in the IGD and on the external graphics cards, (iii) theRecomposition Module 403 uses the North bridge chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (iv) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphics cards or the IGB, as shown. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation of GPU Supported on Integrated Graphics Device (IGD) and Multiple GPUs Supported on External Graphics Cards
- In
FIG. 4, the third MMPGRS of present invention is shown embodied within the HMS+IGD Class of MMPGRS Architecture described in7A FIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution andRecomposition Modules software package 701 in the Host Memory Space (HMS) while multiple GPUs are supported in an IGD within the South bridge circuit as well as on external graphic cards connected to the South bridge chip, and driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM. During operation, (i) theDecomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (ii) theDistribution Module 402 uses the North bridge chip to distribute graphic commands and data (CGAD) to the multiple GPUs located in the IGD and on external graphics cards, (iii) theRecomposition Module 403 uses the South bridge chip to transfer recomposited pixel data between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (iv) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphics cards or the IGB, as shown. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation of GPU Supported on Hybrid CPU/GPU Fusion Chip and GPUs Supported on External Graphics Cards
- In
FIG. 5, the fourth illustrative embodiment of the MMPGRS of present invention is shown embodied within the HMS+Fusion Class of MMPGRS Architecture described in7A FIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution andRecomposition Modules software package 701 in the Host Memory Space (HMS) while a single GPU (1242) is supported on a CPU/GPU fusion-architecture processor die (alongside the CPU 1241) and one or more GPUs are supported on an external graphic card connected to the CPU processor die and driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM. During operation, (i) theDecomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (ii) theDistribution Module 402 uses the memory controller and interconnect (e.g. crossbar switch) within the CPU/GPU processor chip to distribute graphic commands and data to the multiple GPUs on the CPU/GPU die chip and on the external graphics cards, (iii) theRecomposition Module 403 uses the memory controller and interconnect (e.g. crossbar switch) within the CPU/GPU processor chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multiple GPUs during the image recomposition stage, and (iv) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphics card via a PCI-express interface, which is connected to the CPU/GPU fusion-architecture chip. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation of Multiple Graphics Pipelines Supported on Multi-Core CPU Chip
- In
FIG. 6, the fifth illustrative embodiment of the MMPGRS of present invention is shown embodied within the HMS+Multicore Class of MMPGRS Architecture described in7A FIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution andRecomposition Modules software package 701 in the Host or CPU Memory Space (HMS) while some of the CPU cores on a multi-core CPU chip are used to implement a plurality of multi-core graphics pipelines parallelized by the modules of thesoftware package 701 of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM. During operation, (i) theDecomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (ii) theDistribution Module 402 uses the North memory bridge and interconnect network within the multi-core CPU chip to distribute graphic commands and data (GCAD) to the multi-core graphic pipelines implemented on the multi-core CPU chip, (iii) theRecomposition Module 403 uses the North memory bridge and interconnect network within the multi-core CPU chip to transfer composited pixel data (CPD) between the Recomposition Module (or CPU) and the multi-core graphics pipelines during the image recomposition stage, and (iv) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the North bridge chip via a display interface. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation of Multiple GPUs Supported on External Graphics Cards, and Carrying Out Pixel Image Recomposition within External GPUs
- In
FIG. 7, the sixth illustrative embodiment of the MMPGRS of present invention is shown embodied within the HMS+GPU-Recomposition Class of MMPGRS Architecture described in7A FIG. 7A 1-2, and in copending U.S. patent application Ser. No. 11/648,160 incorporated herein by reference. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition, Distribution andRecomposition Modules software package 701 in the Host or CPU Memory Space (HMS) while multiple GPUs on external GPU cards driven in parallelized manner by the modules of thesoftware package 701 of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM, and two ormore GPUs Decomposition Module 401 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (ii) theDistribution Module 402 uses the North or South bridge circuit and interconnect network to distribute graphic commands and data (GCAD) to the external GPUs, (iii) the Recomposition Module uses the North memory bridge and associated system bus (e.g. PCI-express bus) to transfer composited pixel data (CPD) between the GPUs during the image recomposition stage, and (iv) finally recomposited pixel data sets are displayed as graphical images on one or more display devices, connected to an external graphics card via a PCI-express interface which is connected to either the North or South bridge circuits of the host computing system. - During the Time Division Mode of this MMPGRS, each non-primary GPU, during its assigned time slot, moves its full-color composited image to the frame buffer (FB) of the primary GPU for display on the display screen of the display device.
- Considering the case of a dual-GPU MMPGRS, for simplicity of explanation, during the Image Division Mode of this MMPGRS, the primary GPU outputs one/half of the color image in its frame buffer (FB) to the display device, while the secondary GPU moves one/half of the image in its FB to the primary GPU. Then the primary GPU does the same with the second part of the image in its frame buffer (FB). Thus, during the Image Division Mode, the recomposition involves a coordinated output of two image halves, that have been composited within the frame buffers (FBs) of two GPUs, to the frame buffer of the primary GPU (for recompositing) and ultimately display to the display device. In this mode, there is no merge function between the pixels of these two image halves involved in the recompositing process. In the case of multiple GPUs, the process is essentially the same, except that each GPU moves its 1/n part of the image to the frame buffer of the primary GPU for recompositing and subsequent display.
- During the Object Division Mode of this MMPGRS, the merging of pixel data in the FBs of the GPUs is much more complicated, involving compositing within the vertex and/or fragment shaders of the primary GPU, as will be described in great detail below.
- Referring to
FIG. 7A 7-1, the innovative pixel recompositing process supported within the MMPGRS ofFIG. 7 during its Object Division Mode will now be described in great technical detail.7A - In general, the recompositing phase/stage of the present invention involves moving the pixel Depth and Color values from the frame buffers (FB) in the secondary GPPL, to the FB in the primary GPPL (via inter-GPPL communication), and then merging these pixel values with their counterparts at the primary GPPL by means of programmable Fragment Shader supported in the pixel processing subsystem (211).
FIG. 7A 7-2 describes the compositing process carried out by programmable Fragment Shader for the case where the MMPGRS employs dual GPPLs (i.e. GPUs). It is understood, however, that if more GPPLs are involved, then the (re)compositing process will repeat accordingly for each additional “secondary” GPPL, until the final step when the partially composited pixel data in the frame buffer (FB) in the last secondary GPPL, is finally recomposited with the pixel data within the frame buffer (FB) of the primary GPPL. - As shown in
FIG. 7A 7-1, the pixel frame generating pipeline includes three basic steps, namely: the decompose 402, distribute 403, and render 404 stages. Towards the end of the graphics processing pipeline (GPPL), therecompose step 405 is carried out for final FB, which is finally displayed to thedisplay device 405. - During the
Decompositing step 402, graphics commands and data stream are decomposed into well load balanced sub-streams in theDecompositing Module 504, keeping state consistency of the graphics libraries. - The
Distributing step 403 is supervised by theDistribution module 505. Decomposed graphics commands and data elements are sent to the Vendor's GPU Driver (506) and memory bridge (203), and delivered for rendering the primary 205 and secondary 204 graphics cards, viaseparate PCIexpress buses - Rendering (step 404) is done simultaneously 602, 603 in both GPPLs, creating two partial FBs.
- The compositing process (step 405) comprises the following substeps:
-
- Step (606): The color FB is read back from the secondary GPPL, and moved via memory bridge (203) to the primary GPPL's Texture memory (218) as a texture tex1.
- Step (607)L The Z-buff is read back from the secondary GPPL, and moved via memory bridge (203) to the primary GPPL's Texture memory (218) as a texture dep1.
- Step (604): Color FB of primary GPPL is copied to texture memory as texture tex2.
- Step (605): Z-buffer of primary GPPL is copied to texture memory as texture dep2.
- Step (608): Shader code for recomposition (described in
FIG. 7B 7-2) is downloaded and exercised on four textures tex1, tex2, dep1, dep2 as follows: - Step (609): The two depth textures are compared pixel by pixel for their depth values. Assuming the rule that the closest pixel is the one to be transferred to the final FB, at each x,y location the two depth textures are compared for lowest depth value, the lowest is chosen, and the color value at x,y of its correspondent color texture is moved to the x,y location in the final texture.
- Step (610): The resulting texture is copied back to the primary color FB. To complete rendering (step 404 b), the following substeps are performed:
- Step (611): All transparent objects of the scene and overlays (such as score titles) are essentially kept by applications for the very last data to be rendered. Therefore, once all opaque objects have been rendered in parallel at separate GPPLs and composed back to the primary's FB, the additional and final phase of a non-parallel rendering of transparent objects takes place in the primary GPPL.
- Step (612): The final FB is sent to the display device for display on its display screen.
- In
step 405, the detailed shader program is used to composite two color textures based on the depth test conducted between the two depth textures, as shown inFIG. 7B 7-2. - While the above illustrative embodiment discloses the use of the Fragment Shader in the pixel processing subsystem/engine within the primary GPPL, to carry out the composition process in the dual GPPL-based graphics platform of the present invention, it is understood that other computational resources within the GPPL can be used in accordance with the scope and spirit of the present invention. In particular, in an alternative illustrative embodiment, the recompositing phase/stage can involve moving the pixel Depth and Color values from the frame buffers (FBs) in the secondary GPPLs, to the FB in the primary GPPL (via inter-GPPL communication), and then merging these pixel values with their counterparts at the primary GPPL by means of the programmable Vertex Shader provided in the geometry processing subsystem 210 of the primary GPPL. And in yet another illustrative embodiment of the present invention, the recompositing phase/stage can involve moving the pixel Depth and Color values from the frame buffers FB in the secondary GPPLs, to the FB in the primary GPPL (via inter-GPPL communication), and then merging these pixel values with their counterparts at the primary GPPL by the means of both programmable Vertex and Fragment Shaders provided in the geometry and pixel processing subsystems in the primary GPPL. Such modifications will become readily apparent to those skilled in the art having the benefit of the present inventive disclosure.
- In the general case of MMPGRS having n GPPLs, the pixel data contained in the Frame Buffers (FB) associated with the secondary GPPLs are moved to the primary GPPL by way of an inter-GPPL communication process (e.g. the
Interconnect network 404 implemented by multiple-lane PCI Express™ buses), and then processed within the local FB of the primary GPPL, to perform pixel image (re)composition. The pixel composition result is then sent to display device, and alternatively, also returned to the secondary GPPLs, if required in some applications as a basis of the next pixel frame. - As shown in FIGS. 7A7, 7A7-1 and 7A7-2 and described in detail above, the GPPL-based recomposition process of the present invention can be implemented across two or more GPPLs using software that (i) controls the computational machinery within the GPPLs of the MMPGRS platform, and (ii) exploits the Shader (pixel) processing capabilities in the primary GPPL, with no need for any external hardware. Alternatively, however, the GPPL-based recomposition process of the present invention can be implemented across two or more GPPLs using hardware circuitry and/or firmware (within a graphics hub architecture of the present invention) that (i) controls the computational machinery within the GPPLs of the MMPGRS platform, and (ii) exploits the Shader (pixel) processing capabilities in the primary GPPL, as shown in FIGS. 7B2, 7B4-1, 7B6-1, 7B7-1, 7B8-3, and 7B1, and described below.
-
FIG. 7A 7-3 illustrates the time-line of one complete composited pixel frame, including time slots associated with the different steps of object division rendering. As shown, the reuse of GPPL resources for recompositing occurs during a time slot, where the GPPL resources are generally idle during the recompose step. Thus, by virtue of the present invention, GPPL resources are used “for free” during recomposition, without sacrificing system performance. - The Graphics Hub Structure of the Present Invention Expressed in Different Ways in Different MMPGRS System Architectures
- While FIGS. 7B1 through 7B11 illustrate that the graphics hub device (GHD) of the present invention can be expressed in different ways in different MPGRS system architectures, it should be pointed out that, within each such system architecture, the function of the graphics hub device (GHD) is essentially the same, namely: (i) to interconnect the graphics-based application in memory space, with the cluster of GPUs or CPU-cores along the parallelized GPPLs; and (ii) to support the basic functionalities of the
Distribution Module 402 and theRecomposition Module 403 in such MMPGRS system architectures. - Also, it should be noted that from a functional point of view, the Distribution Module resides before the cluster of GPUs or CPU-cores, delivering graphics commands and data (GCAD) for rendering (and thus functioning as a “pre GPU unit” of sorts), whereas the Recomposition Module functions logically after the cluster of GPUs, and collects post rendering data (“post GPU unit”). However, both the Distribution Module and the Recomposition Module typically share the same physical hardware unit (e.g. silicon chip). Various examples of the graphics hub device (GHD) of the present invention will now be described in great detail in FIGS. 7B1 through 7B11, for various types of MMGPRS system architectures indicated in
FIG. 7A 1-2. - At this juncture, the two major advantages should be pointed out when using the “graphics hub device” architecture approach of the present invention, illustrated in FIGS. 7B1 through 7B11.
- The first advantage of the “graphics hub device” architecture is that the number of driven GPPLs in the MMPGRS is no longer limited by the number of buses provided by the memory bridge circuit employed in the CPU-based host computing system. The
Interconnect Network 404 employed in the graphics hub device (GD) of the present invention allows (theoretically) for the connection of an unlimited number of GPUs to the Host CPU. - The second advantage of the “graphics hub device” architecture is the high performance achieved during image recomposition using the graphic hub device architecture, thereby eliminating the need of moving the Frame Buffer (FB) pixel data from multiple GPPLs to the host or CPU memory for merging, as it is done in the system architectures illustrated in FIGS. 7A2 through 7A7. During GPU-based Recomposition process of the present invention, the merge function is performed by fast, highly specialized hardware within the GPUs, independent of other tasks that are concurrently trying to access the main memory of the host computing system, which occurs in a multi-tasking system architectures illustrated in FIGS. 7A2 through 7A7.
- Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation of Multiple GPUs Supported on External Graphics Cards Connected to Graphics Hub Device of the Present Invention
- In
FIG. 1, the seventh illustrative embodiment of the MMPGRS of present invention is shown embodied within the Hub Class of MMPGRS Architecture described in7B FIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″, Distribution Module 402″ and Recomposition Module 403″ are realized within a single graphics hub device (e.g. chip) that is connected to the North memory bridge of the host computing system via a PCI-express interface and to a cluster of external GPUs 410″ via an interconnect, with the GPUs being driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM, (ii) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North memory bridge circuit, (iii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iv) the Distribution Module 402″ distributes graphic commands and data (GCAD) to the external GPUs, (v) the Recomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the primary GPU on the graphical display card which is connected to the graphics hub chip of the present invention via the interconnect 404″. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation Multiple GPUs Supported on External Graphics Cards and Carrying Out Image Recomposition Across Two or More of Said GPUs
- In
FIG. 2, the eighth illustrative embodiment of the MMPGRS of present invention is shown embodied within the Hub+GPU-Recomposition Class of MMPGRS Architecture described in7B FIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host Memory Space (HMS) of the host computing system, while the Decomposition Submodule No. 2 401″ and theDistribution Module 402″ are realized within a single graphics hub device (e.g. chip) that is connected to the North bridge of the host computing system and a cluster ofexternal GPUs 410″, and theRecomposition Module 403″ is implemented across two ormore GPUs FIG. 7, and that all of the GPUs are driven in a parallelized manner, under the control of the AMCM. During operation, (i) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (ii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) the7A Distribution Module 402″ distributes graphic commands and data (GCAD) to the external GPUs, (iv) theRecomposition Module 403″, implemented within theprimary GPU 715, transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets (recomposited within the vertex and/or fragment shaders of the primary GPU) are displayed as graphical images on one or more display devices connected to the primary GPU on the graphical display card(s), which are connected to the graphics hub chip of the present invention. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation Multiple GPUs Supported on an Integrated Graphics Device (IGD) Within a North Memory Bridge Chip
- In
FIG. 3, the ninth illustrative embodiment of the MMPGRS of present invention is shown embodied within the Chipset Class of MMPGRS Architecture described in7B FIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″,Distribution Module 402″ andRecomposition Module 403″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the North memory bridge circuit and having a plurality of GPUs being driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM. During operation, (i) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (ii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402″ distributes graphic commands and data (GCAD) to the internal GPUs via the interconnect network, (iv) theRecomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphical display card, or the primary GPU in the IGB, as shown. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation Multiple GPUs Supported on an Integrated Graphics Device (IGD) Within A South Bridge Chip
- In
FIG. 4, the tenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the Chipset Class of MMPGRS Architecture described in7B FIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″,Distribution Module 402″ andRecomposition Module 403″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the South bridge circuit of the host computing system and having a plurality of GPUs driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM. During operation, (i) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the communication interfaces of the North and South bridge circuits, (ii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402″ distributes graphic commands and data (GCAD) to the external GPUs, (iv) theRecomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphical display card, or the primary GPU in the IGB, as shown. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation Multiple GPUs Supported on an Integrated Graphics Device (IGD) Within a South Bridge Chip, Wherein Recomposition is Implemented Across Two or More GPUs
- In
FIG. 7B 4-1, the eleventh illustrative embodiment of the MMPGRS of present invention is shown embodied within the Chipset Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″ and theDistribution Module 402″ 403″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the South bridge circuit of the host computing system and having a plurality of GPUs driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM, while theRecomposition Module 403″ is implemented across two ormore GPUs Distribution Module 402″ distributes graphic commands and data (GCAD) to the external GPUs, (iv) theRecomposition Module 403″, implemented at the Primary GPU, transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphical display card, or the primary GPU in the IGB, as shown. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation of Multiple GPUs Supported on an Integrated Graphics Device (IGD) Within a North Memory Bridge Chip, and GPUs on an External Graphics Card
- In
FIG. 5, the twelfth illustrative embodiment of the MMPGRS of present invention is shown embodied within the Chipset Class of MMPGRS Architecture described in7B FIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″,Distribution Module 402″ andRecomposition Module 403″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the North memory bridge of the host computing system and having multiple GPUs being driven with a single GPU on an external graphics card in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM. During operation, (i) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (ii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402″ distributes graphic commands and data (GCAD) to the external GPUs, (iv) theRecomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphical display card, or the primary GPU in the IGB, as shown. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation of a Single GPU Supported on an Integrated Graphics Device (IGD) Within a South Bridge Chip, and Multiple GPUs Supported on an External Graphics Card
- In
FIG. 6, the thirteenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the Chipset Class of MMPGRS Architecture described in7B FIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″,Distribution Module 402″ andRecomposition Module 403″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the South bridge circuit of the host computing system and having multiple GPUs driven with a single GPU on an external graphics card in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM. During operation, (i) the Decomposition Submodule No. 1 transfer graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North and South bridge circuits, (ii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402″ distributes the graphic commands and data (GCAD) to the external GPUs, (iv) theRecomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphics card, or the primary GPU in the IGB, as shown. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation of a Single GPU Supported on an Integrated Graphics Device (IGD) Within a South Bridge Chip, and Multiple GPUs Supported on an External Graphics Card with the Recomposition Module Implemented Across Two or More GPUs
- In
FIG. 7B 6-1, the fourteenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the Chipset Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″ andDistribution Module 402″ are realized (as a graphics hub) in an integrated graphics device (IGD) within the South bridge circuit of the host computing system and having multiple GPUs driven with a single GPU on an external graphics card in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM, while theRecomposition Module 403″ is implemented across two ormore GPUs Distribution Module 402″ distributes the graphic commands and data (GCAD) to the external GPUs, (iv) theRecomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to the external graphics card, or the primary GPU in the IGB, as shown. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Employing an Integrated Graphics Device (IGD) within a Bridge Chip Capable of Parallelizing the Operation Of Multiple GPUs Supported On Multiple External Graphics Cards, or Controlling a Single GPU within the IGD of the Present Invention for Driving an Display Device Connected Thereto
- In
FIG. 7, the fifteenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the Chipset Class of MMPGRS Architecture described in7B FIG. 7A 1-2. The shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″,Distribution Module 402″ andRecomposition Module 403″ are realized (as a graphics hub) in an integrated graphics device (IGD) realized within the North memory bridge chip of the host computing system, and driving (i) multiple GPUs on multiple external graphics cards in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM, or alternatively (ii) controlling a single GPU aboard the IGD for driving a display device connected to the IGD via a display interface. During operation, (i) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (ii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402″ distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs, (iv) theRecomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphic cards or the primary GPU in the IGB, as shown. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Employing an Integrated Graphics Device (IGD) within a Bridge Chip Capable of (i) Parallelizing the Operation of Multiple GPUs Supported on Multiple External Graphics Cards with the Recomposition Module Implemented Across Two or More GPUs, or (ii) Controlling a Single GPU within the IGD of the Present Invention for Driving an Display Device Connected Thereto
- In
FIG. 7B 7-1, the sixteenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the Chipset Class of MMPGRS Architecture described inFIG. 7A 1-2. The shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host or CPU Memory Space (HMS) while the Decomposition Submodule No. 2 401″ andDistribution Module 402″ are realized (as a graphics hub) in an integrated graphics device (IGD) realized within the North memory bridge chip of the host computing system, and driving (i) multiple GPUs on multiple external graphics cards in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem, under the control of the AMCM, or alternatively (ii) controlling a single GPU aboard the IGD for driving a display device connected to the IGD via a display interface, while theRecomposition Module 403″ is implemented across two or more GPUs (715, 716). During operation, (i) the Decomposition Submodule No. 1 transfers graphic commands and data (GCAD) to the Decomposition Submodule No. 2 via the North bridge circuit, (ii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402″ distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs, (iv) theRecomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one or more display devices connected to one of the external graphic cards or the primary GPU in the IGB, as shown. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Employing a CPU/GPU Fusion-Type Chip Capable of Parallelizing the Operation of an Internal GPU and Multiple GPUs Supported on an External Graphics Card
- In
FIG. 7B 8-1, the seventeenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the CPU/GPU Fusion Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No. 2 401″,Distribution Module 402″ andRecomposition Module 403″ are realized (as a graphics hub) in on the die of a hybrid CPU/GPU fusion-architecture chip within the host computing system and having a single GPU driven with one or more GPUs on an external graphics card (connected to the CPU/GPU chip) in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem under the control of the AMCM. During operation, (i) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2, (ii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402″ distributes the graphic commands and data (GCAD) to the internal GPU and external GPUs, (iv) theRecomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one ormore display devices 106 connected to the external graphics card connected to the hybrid CPU/GPU chip via a PCI-express interface. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Employing a CPU/GPU Fusion-Type Chip Capable of Parallelizing the Operation of Multiple Internal GPUs and Multiple GPUs Supported on an External Graphics Card
- In
FIG. 7B 8-2, the eighteenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the CPU/GPU Fusion Class of MMPGRS Architecture described inFIG. 7A 1-2. The shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No. 2 401″,Distribution Module 402″ andRecomposition Module 403″ are realized (as a graphics hub) on the die of a multi-core CPU chip within the host computing system and having multiple CPU cores, some of which implement multiple soft parallel graphics pipelines (“soft GPUs”) driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem under the control of the AMCM. During operation, (i) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the North memory bridge circuit and interconnect network within the multi-core CPU chip, (ii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402″ uses the crossbar switch (i.e. interconnect) on the processor die to distribute the graphic commands and data (GCAD) to the multiple soft parallel graphics pipelines (implemented by the multiple CPU cores), (v) theRecomposition Module 403″ transfers composited pixel data (CPD) between the multiple CPU cores during the image recomposition stage, and (vi) finally recomposited pixel data sets are displayed as graphical images on one ormore display devices 106 connected to the North memory bridge chip via a display interface. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Employing a CPU/GPU Fusion-Type Chip Capable of Parallelizing the Operation of Multiple Internal GPUs and Multiple GPUs Supported on an External Graphics Card, with the Recomposition Module being Implemented Across Two of More of Said GPUs
- In
FIG. 7B 8-3 the nineteenth illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the CPU/GPU Fusion Class of MMPGRS Architecture described inFIG. 7A 1-2. The shown, (i) the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host Memory Space (HMS), (ii) the Decomposition Submodule No. 2 401″ andDistribution Module 402″ are realized (as a graphics hub) in on the die of a hybrid CPU/GPU fusion-architecture chip within the host computing system and havingmultiple GPUs 1242″ driven with one or more GPUs on an external graphics card 205 (connected to the CPU/GPU chip) in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem under the control of the AMCM, and (iii) theRecomposition Module 403″ is implemented across two ormore GPUs Distribution Module 402″ uses the crossbar switch (i.e. interconnect) on the processor die to distribute the graphic commands and data (GCAD) to the internal GPUs and external GPUs, (vii) theRecomposition Module 403″ transfers composited pixel data (CPD) between the GPUs during the image recomposition stage, and (viii) finally recomposited pixel data sets are displayed as graphical images on one ormore display devices 106 connected to the external graphics card connected to the hybrid CPU/GPU chip via a PCI-express interface. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation of Multiple Graphics Pipelines Implemented on a Multi-Core CPU Chip of the Present Invention, and Driving a Display Device Connected to the North Memory Bridge Chip of the Host Computing System
- In
FIG. 7B 9-1, the twentieth illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the Multicore CPU Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ reside as a software package in the Host Memory Space (HMS) while the Decomposition Submodule No. 2 401″,Distribution Module 402″ andRecomposition Module 403″ are realized (as a graphics hub) on the die of a multi-core CPU chip within the host computing system. As shown, some of the CPU cores are used to implement multiple soft parallel graphics pipelines (“soft GPUs”) that are driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem under the control of the AMCM. During operation, (i) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the North memory bridge circuit and interconnect network within the multi-core CPU chip, (ii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402″ uses the crossbar switch (i.e. interconnect) on the processor die to distribute the graphic commands and data (GCAD) to the multiple soft parallel graphics pipelines (implemented by the multiple CPU cores), (iv) theRecomposition Module 403″ transfers composited pixel data (CPD) between the multiple CPU cores during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one ormore display devices 106 connected to the North memory bridge chip via a display interface implemented therein, as shown. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Capable of Parallelizing the Operation of Multiple Soft Graphics Pipelines Implemented on a Multi-Core CPU Chip, and One or More GPUs Supported on an External Graphics Card Interfaced to the Multi-Core CPU Chip
- In
FIG. 7B 9-2, the twenty-first illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the Multicore CPU Class of MMPGRS Architecture described inFIG. 7A 1-2. The shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ resides as asoftware package 711 in the Host Memory Space (HMS) while the Decomposition Submodule No. 2 401″, theDistribution Module 402″ and theRecomposition Module 403″ are realized as a graphics hub within a multi-core CPU chip employed within the host computing system, having a plurality of CPU cores, some of which implement multiple soft graphics pipelines which, along with multiple GPUs supported on anexternal graphics card 205, are driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem under the control of the AMCM. During operation, (i) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2 via the interconnects within the North memory bridge chip and the multi-core CPU chip, (ii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402″ uses the interconnect (i.e. crossbar switch) in the multi-core CPU chip to distribute the graphic commands and data (GCAD) to the multiple soft graphics pipelines (e.g. soft GPUs) and the GPUs on theexternal graphics card 205, and (iv) theRecomposition Module 403″ transfers composited pixel data (CPD) between the soft graphics pipelines on the multi-core CPU chip and hard GPUs on the external graphics card during the image recomposition stage, and (v) finally recomposited pixel data sets are displayed as graphical images on one ormore display devices 106 connected to the external graphics card which is connected to the multi-core CPU chip via a PCI-express interface. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Employing a Graphics Hub Device Capable of Parallelizing the Operation of Multiple GPUs Supported on a Game Console Board
- In
FIG. 10, the twenty-second illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the Game Console Class of MMPGRS Architecture described in7B FIG. 7A 1-2. As shown, the Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ are realized as asoftware package 711 within the Host Memory Space (HMS), while the Decomposition Submodule No. 2 401″, theDistribution Module 402″ and theRecomposition Module 403′ are realized as a graphics hub semiconductor chip within the game console system in which multiple GPUs are driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem under the control of the AMCM. During operation, (i) the Decomposition Submodule No. 1 transfers graphics commands and data (GCAD) to the Decomposition Submodule No. 2, via the memory controller on the multi-core CPU chip and the interconnect in the graphics hub chip of the present invention, (ii) the Decomposition Submodule No. 2 divides (i.e. splits up) the stream of graphic commands and data (GCAD) according to the required parallelization mode, operative at any instant in time, (iii) theDistribution Module 402″ distributes the graphic commands and data (GCAD) to the multiple GPUs, (iv) theRecomposition Module 403″ transfers composited pixel data (CPD) between the multiple GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets (recomposited within the vertex and/or fragment shaders of the primary GPU) are displayed as graphical images on one ormore display devices 106 connected to theprimary GPU 715 via a analog display interface. - Illustrative Embodiment of the MMPGRS of the Present Invention Having a System Architecture Employing a Graphics Hub Device Capable of Parallelizing the Operation of Multiple GPUs Supported on a Game Console Board, with the Recomposition Module Realized Across Two or More GPUs
- In
FIG. 11, the twenty-third illustrative embodiment of the MMPGRS of present invention is shown embodied within the following the Game Console Class of MMPGRS Architecture described in7B FIG. 7A 1-2. As shown, the Profiling and Control Automatic Mode Control Module (AMCM) 400 and the Decomposition Submodule No. 1 401′ are realized as asoftware package 711 within the Host Memory Space (HMS) of the host computing system while the Decomposition Submodule No. 2 401″ andDistribution Module 402′ are realized as a graphics hub semiconductor chip within the game console system in which multiple GPUs are driven in a parallelized manner by the modules of the multi-mode parallel graphics rendering subsystem under the control of the AMCM, while theRecomposition Module 403′ is implemented across two ormore GPUs Distribution Module 402′ distributes the graphic commands and data (GCAD) to the multiple GPUs, (iv) theRecomposition Module 403′, realized primarily within the substructure of the primary GPU, transfers composited pixel data (CPD) between the multiple GPUs during the image recomposition stage, and (v) finally recomposited pixel data sets (recomposited within the vertex and/or fragment shaders of the primary GPU) are displayed as graphical images on one ormore display devices 106 connected to theprimary GPU 715 via an analog display interface. - Various Options for Implementing the MMPGRS of the Present Invention
- There are numerous options for implementing the various possible designs for the MMPGRS of the present invention taught herein. Also, as the inventive principles of the MMPGRS can be expressed using software and hardware based system architectures, the possibilities for the MMPGS are virtually endless.
- In
FIGS. 8A through II DI, there is shown a sampling of the illustrative implementations that are possible for the diverse MMPGRS designs of the present invention disclosed, taught and suggested herein. -
FIG. 8A shows an illustrative implementation of the MMPGRS of the present invention following the Hub Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown in this MMGPRS implementation, (i) the AMCM and Decomposition Submodule No. 1 are implemented as a software-package 701 within host memory space (HMS) of the host computing system, (ii) multiple discrete graphic cards are connected to the bridge circuit of the host computing system by way of a hardware-based graphics hub chip of thepresent invention 404″, 402″, 403″, 404″, (iii) hardware-based Distribution andRecomposition Modules 402″ and 403″ are realized on the hardware-based graphics hub chip of the present invention, and (iv) a graphics display device is connected to the primary GPU. -
FIG. 1 shows a first illustrative embodiment of the MMPGRS implementation of8A FIG. 8A , wherein a possible packaging of the Hub architecture of the present invention employs an assembly comprising a Hub-extender card 811 carrying multiple (e.g. dual)graphics cards motherboard 814 within the host computing system. -
FIG. 2 shows a second illustrative embodiment of the MMPGRS implementation of8A FIG. 8A , wherein a possible packaging of the Hub architecture of the present invention employs an external box containing a Hub chip of the present invention mounted on a PC board, that is connected to the motherboard of the host computing system via a wire harness or the like, and supporting a plurality ofgraphics cards 813 that are connected to the Hub chip. -
FIG. 3 shows a third illustrative embodiment of the MMPGRS implementation of8A FIG. 8A , wherein a possible packaging of the Hub architecture of the present invention employs a graphics hub chip of the present invention mounted on themotherboard 814 of the host computing system, which supportsmultiple graphics cards 813 with multiple GPUs. -
FIG. 8B shows an illustrative implementation of the MMPGRS of the present invention following the Hub+GPU-Recomposition Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown in this MMPGRS implementation, (i) the AMCM and Decomposition Submodule No. 1 are implemented as a software-package 701 within host memory space (HMS) of the host computing system, (ii) multiple discrete graphic cards are connected to a bridge chipset on the host computing system by way of a hardware-based graphics hub chip realizing the Decomposition No. 2Submodule 401″ and theDistribution Module 402″, (iii) theRecomposition Module 403″ is implemented across two ormore GPUs -
FIG. 1 shows a first illustrative embodiment of the MMPGRS implementation of8B FIG. 8B , wherein a possible packaging of the Hub+GPU Recomposition architecture of the present invention employs an assembly comprising a Hub-extender card 811 carrying multiple (e.g. dual)graphics cards motherboard 814 within the host computing system. -
FIG. 2 shows a second illustrative embodiment of the MMPGRS implementation of8B FIG. 8B , wherein a possible packaging of the Hub architecture of the present invention employs an external box containing a Hub chip of the present invention mounted on a PC board, that is connected to the motherboard of the host computing system via a wire harness or the like, and supporting a plurality ofgraphics cards 813 that are connected to the Hub chip. -
FIG. 3 shows a third illustrative embodiment of the MMPGRS implementation of8B FIG. 8B , wherein a possible packaging of the Hub architecture of the present invention employs a graphics hub chip of the present invention mounted on themotherboard 814 of the host computing system, which supportsmultiple graphics cards 813 with multiple GPUs. -
FIG. 8C shows an illustrative embodiment of the MMPGRS of the present invention following the HM Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown in this MMPGRS implementation, (i) the AMCM, Decomposition, Distribution and Recomposition Modules are implemented as a software-package 701 within host memory space (HMS) of the host computing system, (ii) multiple discrete GPUs on one or more graphics cards are connected to the bridge circuit on the host computing system, and (iii) a graphics display device is connected to the primary GPU. -
FIG. 1 shows a first illustrative embodiment of the MMPGRS implementation of8C FIG. 8C , wherein discretemultiple graphics cards 851, each supporting at least a single GPU, are interfaced with the bridge circuit chipset of the CPU motherboard by way of a PCI-express or like interface. -
FIG. 2 shows a second illustrative embodiment of the MMPGRS implementation of8C FIG. 8C , wherein multiple GPUs are realized on asingle graphics card 852 which is interfaced to bridge circuit on the CPU motherboard by way of a PCI-express or like interface. -
FIG. 3 shows a third illustrative embodiment of the MMPGRS implementation of8C FIG. 8C , wherein multiplediscrete graphics cards 851, each supporting at least a single GPU, are interfaced with the bridge circuit on a board within anexternal box 821 that is interface to the motherboard within the host computing system. -
FIG. 8D shows an illustrative embodiment of the MMPGRS of the present invention following the Hub+GPU-Recomposition Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown in this MMPGRS implementation, (i) the AMCM, Decomposition Submodule No. 1 and the Distribution Module are implemented as a software-package 701 within host memory space (HMS) of the host computing system, (ii) multiple discrete GPUs on one or more external graphics cards are connected to the bridge circuit of the host computing system, (iii) theRecomposition Module 403″ is implemented across two or more GPUs, and (iv) a graphics display device is connected to the primary GPU. -
FIG. 1 shows a first illustrative embodiment of the MMPGRS implementation of8D FIG. 8D , wherein discretemultiple graphics cards 851, each supporting at least a single GPU, are interfaced with the bridge circuit chipset of the CPU motherboard by way of a PCI-express or like interface. -
FIG. 2 shows a second illustrative embodiment of the MMPGRS implementation of8D FIG. 8D , wherein multiple GPUs are realized on asingle graphics card 852 which is interfaced to bridge circuit on the CPU motherboard by way of a PCI-express or like interface. -
FIG. 3 shows a third illustrative embodiment of the MMPGRS implementation of8D FIG. 8D , wherein multiplediscrete graphics cards 851, each supporting at least a single GPU, are interfaced with the bridge circuit on a board within anexternal box 821 that is interface to the motherboard within the host computing system. -
FIG. 9A shows an illustrative implementation of the MMPGRS of the present invention following the Hub Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown in this MMPGRS implementation, (i) the AMCM and Decomposition Submodule No. 1 are implemented as asoftware package 711 on the host memory space (HMS), (ii) multiple GPUs (i.e.Primary GPU 715 and Secondary GPUs 716) are assembled on aexternal graphics card 902 which connects the GPUs to the bridge circuit on the host computing system by way of a hardware-based graphics hub chip implementing the Decomposition Submodule No. 2 401″, theDistribution Module 402″ and theRecomposition Module 403″, and (iii) a graphics display device is connected to the primary GPU. -
FIG. 1 shows an illustrative embodiment of the MMPGRS of9A FIG. 9A , wherein multiple GPUs (715, 716) and hardware-based Decomposition Submodule No. 2 401″,Distribution Module 402″ and theRecomposition Modules 403″ are implemented as a graphics hub chip orchipset 401″, 402′, 403,″ and 404″ on a singlegraphics display card 902, which is interfaced to the bridge circuit on themotherboard 814 within the host computing system. -
FIG. 10A shows an illustrative implementation of the MMPGRS of the present invention following the Hub Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown in this MMGPRS implementation, (i) the AMCM and Decomposition Submodule No. 1 are implemented as asoftware package 711 on the host memory space (HMS), (ii) a single SOC-basedgraphics chip 1001 is mounted on asingle graphics card 1002 interfaced with a bridge circuit on themotherboard 1002, and supporting multiple GPUs (i.e. the primary GPU and secondary GPUs), (iii) hardware-based Decomposition Submodule No. 2, the Distribution Module and the Recomposition Module are implemented on the SOC-basedgraphics chip 1001, and (iv) a graphics display device is connected to the primary GPU. -
FIG. 1 shows a possible packaging of the SOC-based graphics hub chip (101) depicted in10A FIG. 10A , whereinmultiple GPUs Decomposition Submodule 401″,Distribution Module 402″, and Recomposition Module (4-3″) are realized on asingle SOC implementation 1001 mounted on asingle graphics card 1002. -
FIG. 10B shows an illustrative implementation of the MMPGRS of the present invention following the Hub+GPU-Recomposition Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown in this MMPGRS implementation, (i) the AMCM and Decomposition Submodule No. 1 are implemented as asoftware package 711 on the host memory space (HMS), (ii) a single SOC-basedgraphics chip 1003 is mounted on asingle graphics card 1002 interfaced with a bridge circuit on themotherboard 1002, and supporting multiple GPUs (i.e. the primary GPU and secondary GPUs), (iii) hardware-based Decomposition Submodule No. 2 and the Distribution Module are implemented on the SOC-basedgraphics hub chip 1001, (iv) the Recomposition Module is implemented across two ormore GPUs -
FIG. 1 shows a possible packaging of the SOC-based10B graphics hub chip 101 depicted inFIG. 10B , whereinmultiple GPUs Decomposition Submodule 401″,Distribution Module 402″ are implemented insingle SOC implementation 1003 mounted on asingle graphics card 1002, with the Recomposition Module (4-3″) being implemented across two or more of the GPUs (e.g. on the same piece of silicon). -
FIG. 10C shows an illustrative implementation of the MMPGRS of the present invention following the HMS+GPU-Recomposition Class of MMPGRS Architecture described inFIG. 7A 1-2. IN this MMPGRS implementation, (i) the AMCM, Decomposition Module and Distribution Module are implemented as asoftware package 701 on the host memory space (HMS), (ii) asingle multi-GPU chip 1031 is mounted on asingle graphics card 1002 that is interfaced with a bridge circuit on the motherboard, and supporting multiple GPUs (i.e. the primary GPU and secondary GPUs), (iii) the Recomposition Module is implemented within two or more GPU, and (iv) a graphics display device is connected to the primary GPU by way of a display interface implemented on the multi-GPU chip. -
FIG. 1 shows a possible packaging of the multi-GPU chip (1031) depicted in10C FIG. 10C , whereinmultiple GPUs Recomposition Module 403″ is implemented across two ormore GPUs -
FIG. 11A shows an illustrative implementation of the MMPGRS following the Chipset Class of MMPGRS Architecture described inFIG. 7A 1-2. In this MMPGRS implementation, (i) the AMCM and Decomposition Submodule No. 1 are realized as asoftware package 711 within the host memory space (HMS) of the host computing system, (ii) plurality ofGPUs 852 on one or moreexternal graphics cards 851 are connected to the bridge circuit on the host computing platform, (iii) an integrated graphics device (IGD) 1101, supporting hardware-based Decomposition Submodule No. 2, theDistribution Module 402″ andRecomposition Module 403″, are implemented within the bridge circuit 1101 on themotherboard 814 of the host computing system, and (iv) a display device is interfaced to the primary GPU by way of a PCI-express interface or the like. -
FIG. 1 shows a first illustrative embodiment of the Chipset MMPGRS implementation of11A FIG. 11A , wherein multiplediscrete graphics cards 851, each supporting at least a single GPU, are interfaced with the bridge circuit on a board within anexternal box 821 that is interface to the motherboard within the host computing system. -
FIG. 1 shows a second illustrative embodiment of the Chipset MMPGRS implementation of11A FIG. 11A , wherein discretemultiple graphics cards 851, each supporting at least a single GPU, are interfaced with the bridge circuit chipset of the CPU motherboard by way of a PCI-express or like interface. -
FIG. 3 shows a third illustrative embodiment of the Chipset MMPGRS implementation of11A FIG. 11A , wherein multiple GPUs are realized on asingle graphics card 852 which is interfaced to bridge circuit on the CPU motherboard by way of a PCI-express or like interface. -
FIG. 11B shows an illustrative implementation of the MMPGRS following the CPU/GPU Fusion Class of MMPGRS Architecture or Multi-Core Class MMPGRS Architecture described inFIG. 7A 1-2. As shown in this MMPGRS implementation, (i) a CPU/GPU fusion-architecture chip or a multi-core CPU chip is mounted on the motherboard of a host computing system having memory and North and South bridge circuits, (ii) AMCM and Decomposition Submodule No. 1 are realized as asoftware package 701 within the host memory space (HMS) of the host computing system while Decomposition Submodule No. 2, the Distribution Module and the Recomposition Module are realized/implemented on the die of the CPU/GPU fusion-architecture chip or the multi-core CPU chip, and (iii) multiple GPUs on external graphic cards or elsewhere, are interfaced to the CPU/GPU fusion-architecture chip or the multi-core CPU chip, by way of a PCI-express or like interface, and (iv) a display device is interfaced to the primary GPU by way of a PCI-express interface or the like. -
FIG. 1 shows a first illustrative embodiment of the CPU/GPU Fusion or Multi-Core MMPGRS implementation of11B FIG. 11B , wherein a CPU/GPU Fusion or Multi-Core chip is used to drive an assemble of graphic cards or GPUs on one or moreexternal graphics cards 851. -
FIG. 2 shows a second illustrative embodiment of the Chipset MMPGRS implementation of11B FIG. 11B , wherein a CPU/GPU Fusion or Multi-Core chip is used to drive an assemble of GPUs on a singleexternal graphics card 852. -
FIG. 3 shows a third illustrative embodiment of the Chipset MMPGRS implementation of11B FIG. 11B , wherein a CPU/GPU Fusion or Multi-Core chip is used to drive only an assemble of internal GPUs on the CPU/GPU Fusion or Multi-Core chip. -
FIG. 11C shows an illustrative implementation of the MMPGRS following the Game Console Class of MMPGRS Architecture described inFIG. 7A 1-2. As shown in this MMPGRS implementation, (i) theAMCM 400 and Decomposition Submodule No. 1 401′ are realized as a software package within the host memory space (HMS) of the game console system, (ii) agraphics hub chip 401″, 402″, 403″, 404″, mounted on the PC board of the game console system, implements the Decomposition Submodule No. 2 401″, theDistribution Module 402′, theRecomposition Module 403′ as well as the interconnect network (e.g. crossbar switch) 404″, (iii) multiple GPUs on the PC board of the game console system are interfaced to Distribution and Recomposition Modules by way of theinterconnect network 404″ within the graphics hub chip, and optionally, the Recompostion Module can be implemented across two ormore GPUs display device 106 is interfaced to the primary GPU by way of an analog display interface or the like. -
FIG. 1 shows an illustrative embodiment of the Game Console MMPGS implementation of11C FIG. 11D , showing its controller in combination with its game console unit. - The MMPGRS of the Present Invention Deployed in Client Machines on Multi-User Computer Networks
- In the illustrative embodiments described above, the graphics-based applications (e.g. games, simulations, business processes, etc.) supporting 3D graphics processes which are rendered using the parallel computing principles of the present invention, have been shown as being supported on single CPU-based host computing platforms, as well as multi-core CPU platforms. It is understood, however, that the parallel graphics rendering processes carried out using the principles of the present invention can stem from applications supported on (i) multi-CPU host computing platforms, as well as (ii) single and multiple CPU based network-based application servers.
- In the case of network-based application servers, streams of graphics commands and data (GCAD) pertaining to the graphics-based application at hand can be generated by application server(s) in response to one or more multiple users (e.g. players) who may be either local or remote with respect to each other. The application servers would transmit streams of graphics commands and data to the participants (e.g. users or players) of a multi-player game. The client-based computing machine of each user would embody one form of the MMPGRS of the present invention, and receive the graphics commands and data streams support the client-side operations of either (i) a client-server based application (running at the remote application servers), and/or (ii) a Web-based application generated from http (Web) servers interfaced to application servers, driven by database servers, as illustrated in
FIGS. 12A and 12B . In such multi-user computer network environments, the MMPGRS aboard each client machine on the network would support its parallel graphics rendering processes, as described in great detail hereinabove, and composited images will be displayed on the display device of the client machine. Display devices available to the users of a particular graphics-based application can include LCD panels, plasma display panels, LCD or DLP based multi-media projectors and the like. -
FIG. 12A shows a first illustrative embodiment of the multi-user computer network according to the present invention, comprising a plurality of client machines, wherein one or more client machines embody the MMPGRS of the present invention designed using the software-based system architecture ofFIG. 7A . InFIG. 12B , a second illustrative embodiment of the multi-user computer network of the present invention, is shown comprising a plurality of client machines, wherein one or more client machines embody the MMPGRS of the present invention designed using the hardware-based system architecture ofFIG. 7B . In either network design, the application server(s), driven by one or more database servers (RDBMS) on the network, and typically supported by a cluster of communication servers (e.g. running http), respond to user-system interaction input data streams that have been transmitted from one or more network users on the network. Notably, these user (e.g. gamers or players) might be local each other as over a LAN, or be remote to each other as over a WAN or the Internet infrastructure. In response to such user-system interaction, as well as Application profiling carried out in accordance with the principles of the present invention, the MMPGRs aboard each client machine will automatically control, in real-time, the mode of parallel graphics rendering supported by the client machine, in order to optimize the graphics performance of the client machine. - Using a Central Application Profile Database Server System to Automatically Update Over the Internet, Graphic Application Profiles (GAPs) within the MMPGRS of Client Machines
- It is with the scope and spirit of the present invention to ensure that each MMPGRS is optimally programmed at all possible times so that it quickly and continuously offers users high graphics performance through its adaptive multi-modal parallel graphics operation. One way to help carry out this objective is to set up a Central Application/Scene Profile Database Server System on the Internet, as shown in
FIGS. 12A and 12B , and support the various Internet-based application registration and profile management and delivery services, as described hereinbelow. - As shown in
FIGS. 12A and 12B , the Central Application/Scene Profile Database Server System of the illustrative embodiment comprises a cluster of Web (http) servers, interfaced with a cluster of application servers, which in turn are interfaced with one or more database servers (supporting RDBMS software), well known in the art. The Central Application/Scene Profile Database Server System would support a Web-based Game Application Registration and Profile Management Application, providing a number of Web-based services, including: - (1) the registration of Game Application Developers within the RDBMS of the Server;
- (2) the registration of game applications with the RDBMS of the Central Application/Scene Profile Database Server System, by registered game application developers;
- (3) registration of each MMPGRS deployed on a client machine or server system having Internet-connectivity, and requesting subscription to periodic/automatic Graphic Application Profile (GAP) Updates (downloaded to the MMPGRS over the Internet) from the Central Application Profile Database Server System; and
- (4) registration of each deployed MMPGRS requesting the periodic uploading of its Game Application Profiles (GAPS)—stored in Application/
Scene Profile Database 405 andHistorical Repository 404—to the Central Application/Scene Profile Database Server System for the purpose of automated analysis and processing so as to formulate “expert” Game Application Profiles (GAPs) that have been based on robust user-experience and which are optimized for particular client machine configurations. - Preferably, the Web-based Game Application Registration and Profile Management Application of the present invention would be designed (using UML techniques) and implemented (using Java or C+) so as to provide an industrial-strength system capable of serving potentially millions of client machines embodying the MMPGRS of the present invention.
- Using the Central Application/Scene Profile Database Server System of the present invention, it is now possible to automatically and periodically upload, over the Internet, Graphic Application Profiles (GAPs) within the Application/
Scene Profile Database 405 of the MMPGRS of registered client machines. By doing so, graphic application users (e.g. gamers) can immediately enjoy high performance graphics on the display devices of their client machines, without having to develop a robust behavioral profile based on many hours of actual user-system interaction, but rather, automatically periodically uploading in their MMPGRSs, “expert” GAPs generated by the Central Application/Scene Profile Database Server System by analyzing the GAPs of thousands of game application users connected to the Internet. - For MMPGRS users subscribing to this Automatic GAP Management Service, supported by the Central Application/Scene Profile Database Server System of the present invention, it is understood that such MMPGRSs would use a different type of Application Profiling and Analysis than that disclosed in FIGS. 5C1 and 5C2.
- For Automatic GAP Management Service subscribers, the MMPGRS would preferably run an application profiling and analysis algorithm that uses the most recently downloaded expert GAP loaded into its AMCM, and then allow system-user interaction, user behavior, and application performance to modify and improve the expert GAP profile over time until the next automated update occurs.
- Alternatively, the Application Profiling and Analysis Module in each MMGPRS subscribing to the Automatic GAP Management Service, will be designed to that it modifies and improves the downloaded expert GAP within particularly set limits and constraints, and according to particular criteria, so that the expert GAP is allowed to evolve in an optimal manner, without performance regression.
- For users, not subscribing to the Automatic GAP Management Service, Application Profiling and Analysis will occur in their MMPGRSs according to general processes described in FIGS. 5C1 and 5C2.
- Variations of the Present Invention which Readily Come to Mind in View of the Present Invention Disclosure
- While the illustrative embodiments of the present invention have been described in connection with various PC-based computing system applications and video game consoles and systems, it is understood that that multi-modal parallel graphics rendering subsystems, systems and rendering processes of the present invention can also be used in mobile computing devices, e-commerce and POS displays and the like.
- While Applicants have disclosed such subsystems, systems and methods in connection with Object, Image and Time Division methods being automatically instantiated in response to the graphical computing needs of the application(s) running on the host computing system at any instant in time, it is understood, however, that the MMPGRS of the present invention can be programmed with other modes of 3D graphics rendering (beyond traditional Object, Image and Time Division Modes), and that these new and/or extended mode of parallel operation can be based on novel ways of dividing and/or quantizing: (i) objects and/or scenery being graphically rendered; (ii) the graphical display screen (on which graphical images of the rendered object/scenery are projected); (iii) temporal aspects of the graphical rendering process; (iv) the illumination sources used during the graphical rendering process using parallel computational operations; as well as (v) various hybrid combinations of these components of the 3D graphical rendering process.
- It is understood that the multi-modal parallel graphics rendering technology employed in computer graphics systems of the illustrative embodiments may be modified in a variety of ways which will become readily apparent to those skilled in the art of having the benefit of the novel teachings disclosed herein. All such modifications and variations of the illustrative embodiments thereof shall be deemed to be within the scope and spirit of the present invention as defined by the Claims to Invention appended hereto.
Claims (10)
1. A multi-mode parallel graphics rendering and display system for running a graphics-based application that generates pre-profiled scenes programmed with scene profile indices, said multi-mode parallel graphics rendering and display system comprising:
CPU memory space for storing one or more graphics-based applications and a graphics library for generating graphics commands and data (GCAD) during the run-time of said graphics-based application;
one or more CPUs for executing said graphics-based applications;
a multi-mode parallel graphics rendering subsystem (MMPGRS) supporting multiple modes of parallel operation selected from the group consisting of object division, image division, and time division, and including
(i) a plurality of graphic processing pipelines (GPPLs) supporting a parallel graphics rendering process that employs one of said object division, image division and/or time division modes of parallel operation in order to execute graphic commands and process graphics data and render pixel-composited images containing graphics for display on a display device during the run-time of said graphics-based application, and
(ii) an automatic mode controller for automatically controlling the mode of parallel operation of said MMPGRS during the run-time of said graphics-based application, by employing real-time detection of scene profile indices programmed within pre-profiled scenes generated by said graphics-based application;
wherein said pre-profiled scenes are analyzed prior to run-time, and indexed with said scene profile indices; and
wherein mode control parameters (MCPs) corresponding to said scene profile indices are stored within a application/scene profile database accessible to said automatic mode control module during application run-time; and
wherein during run-time, said automatic mode controller automatically detects said scene profile indices and uses said detected scene profile indices to access corresponding MCPs from said application/scene profile database so as to determine how to dynamically control the modes of parallel operation of said MMPGRS to optimize system performance.
2. The multi-mode parallel graphics rendering and display system of claim 1 , wherein each mode of parallel operation includes at least three stages, namely, decomposition, distribution and recomposition, and wherein said multi-mode parallel graphics rendering subsystem comprises:
a decomposition module for supporting the decomposition stage of parallel operation;
a distribution module for supporting the distribution stage of parallel operation; and
a recomposition module for supporting the recomposition stage of parallel operation; and
wherein said decomposition, distribution and recomposition modules cooperate to carry out the decomposition, distribution and recomposition stages, respectively, of the different modes of parallel operation supported on said MMPGRS.
3. The multi-mode parallel graphics rendering and display system of claim 2 ,
wherein said decomposition module divides up the stream of graphic commands and data (GCAD) according to the required mode of parallel operation determined by said automatic mode control module;
wherein said distribution module physically distributes the streams of graphics commands and data to said plurality of GPPLs;
wherein said GPPLs execute said graphics commands using said graphics data and generate partial pixel data sets associated with frames of images to be composited, within the frame buffer, by the primary GPPL in said MMPGRS; and
wherein said recomposition module merges together the partial pixel data sets from produced from said GPPLs, according to mode of parallel operation at any instant in time, and producing a final pixel data set within the frame buffer of the primary GPPL, which is sent into said display device for display.
4. The multi-mode parallel graphics rendering and display system of claim 1 , which further comprises said display device for displaying said pixel-composited images during the run-time of said graphics-based application.
5. The multi-mode parallel graphics rendering and display system of claim 4 , wherein said display device is a device selected from the group consisting of an flat-type display panel, a projection-type display panel, and other image display devices.
6. The multi-mode parallel graphics rendering and display system of claim 1 , which is a machine selected from the group consisting of a PC-level computer, information server, laptop, game console system, portable computing system, and any computational-based machine supporting the real-time generation and display of 3D graphics.
7. The multi-mode parallel graphics rendering and display system of claim 1 , wherein each said GPPL is a GPU-based GPPL which comprises:
(i) a video memory structure supporting a frame buffer including stencil, depth and color buffers, and
(ii) a graphics processing unit (GPU) supporting (1) a geometry subsystem having an input assembler, a vertex shader and a geometry shader, (2) a rasterizer, and (3) a pixel subsystem including a pixel shader receiving pixel data from said frame buffer and raster operators operating on pixel data in said frame buffer.
8. The multi-mode parallel graphics rendering and display system of claim 1 , wherein each said GPPL is a CPU-based GPPL which comprises:
(i) a video memory structure supporting a frame buffer including stencil, depth and color buffers; and
(ii) a graphics processing pipeline realized by one cell of a multi-core CPU chip, consisting of a plurality of processors.
9. The multi-mode parallel graphics rendering and display system of claim 8 , wherein said plurality of processors comprises a plurality of in-order SIMD processors.
10. The multi-mode parallel graphics rendering and display system of claim 1 , wherein said CPU-based GPPL further comprises:
(iii) a texture sampler for loading texture maps from memory, filtering said texture maps for level-of-detail, and feeding said texture maps to the pixel processing portion of said CPU-based GPPL.
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US11/901,696 US20080088631A1 (en) | 2003-11-19 | 2007-09-18 | Multi-mode parallel graphics rendering and display system supporting real-time detection of scene profile indices programmed within pre-profiled scenes of the graphics-based application |
Applications Claiming Priority (12)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US52308403P | 2003-11-19 | 2003-11-19 | |
PCT/IL2004/001069 WO2005050557A2 (en) | 2003-11-19 | 2004-11-19 | Method and system for multiple 3-d graphic pipeline over a pc bus |
US64714605P | 2005-01-25 | 2005-01-25 | |
US75960806P | 2006-01-18 | 2006-01-18 | |
US11/340,402 US7812844B2 (en) | 2004-01-28 | 2006-01-25 | PC-based computing system employing a silicon chip having a routing unit and a control unit for parallelizing multiple GPU-driven pipeline cores according to the object division mode of parallel operation during the running of a graphics application |
US11/386,454 US7834880B2 (en) | 2004-01-28 | 2006-03-22 | Graphics processing and display system employing multiple graphics cores on a silicon chip of monolithic construction |
US11/648,160 US8497865B2 (en) | 2006-12-31 | 2006-12-31 | Parallel graphics system employing multiple graphics processing pipelines with multiple graphics processing units (GPUS) and supporting an object division mode of parallel graphics processing using programmable pixel or vertex processing resources provided with the GPUS |
US11/655,735 US8085273B2 (en) | 2003-11-19 | 2007-01-18 | Multi-mode parallel graphics rendering system employing real-time automatic scene profiling and mode control |
US57968207A | 2007-03-23 | 2007-03-23 | |
US11/789,039 US20070291040A1 (en) | 2005-01-25 | 2007-04-23 | Multi-mode parallel graphics rendering system supporting dynamic profiling of graphics-based applications and automatic control of parallel modes of operation |
US11/897,536 US7961194B2 (en) | 2003-11-19 | 2007-08-30 | Method of controlling in real time the switching of modes of parallel operation of a multi-mode parallel graphics processing subsystem embodied within a host computing system |
US11/901,696 US20080088631A1 (en) | 2003-11-19 | 2007-09-18 | Multi-mode parallel graphics rendering and display system supporting real-time detection of scene profile indices programmed within pre-profiled scenes of the graphics-based application |
Related Parent Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/897,536 Continuation US7961194B2 (en) | 2003-11-19 | 2007-08-30 | Method of controlling in real time the switching of modes of parallel operation of a multi-mode parallel graphics processing subsystem embodied within a host computing system |
Publications (1)
Publication Number | Publication Date |
---|---|
US20080088631A1 true US20080088631A1 (en) | 2008-04-17 |
Family
ID=40135999
Family Applications (21)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/901,745 Abandoned US20080079737A1 (en) | 2003-11-19 | 2007-09-18 | Multi-mode parallel graphics rendering and display system supporting real-time detection of mode control commands (MCCS) programmed within pre-profiled scenes of the graphics-based application |
US11/901,713 Abandoned US20080068389A1 (en) | 2003-11-19 | 2007-09-18 | Multi-mode parallel graphics rendering system (MMPGRS) embodied within a host computing system and employing the profiling of scenes in graphics-based applications |
US11/901,715 Abandoned US20080074431A1 (en) | 2003-11-19 | 2007-09-18 | Computing system capable of parallelizing the operation of multiple graphics processing units (GPUS) supported on external graphics cards |
US11/901,733 Abandoned US20080094404A1 (en) | 2003-11-19 | 2007-09-18 | Computing system having multi-mode parallel graphics rendering subsystem including multiple graphics processing pipelines (GPPLS) and supporting automated division of graphics commands and data during automatic mode control |
US11/901,727 Abandoned US20080094402A1 (en) | 2003-11-19 | 2007-09-18 | Computing system having a parallel graphics rendering system employing multiple graphics processing pipelines (GPPLS) dynamically controlled according to time, image and object division modes of parallel operation during the run-time of graphics-based applications running on the computing system |
US11/901,692 Active 2025-02-13 US7777748B2 (en) | 2003-11-19 | 2007-09-18 | PC-level computing system with a multi-mode parallel graphics rendering subsystem employing an automatic mode controller, responsive to performance data collected during the run-time of graphics applications |
US11/901,716 Abandoned US20080246772A1 (en) | 2003-11-19 | 2007-09-18 | Multi-mode parallel graphics rendering system (MMPGRS) employing multiple graphics processing pipelines (GPPLS) and real-time performance data collection and analysis during the automatic control of the mode of parallel operation of said GPPLS |
US11/901,714 Abandoned US20080074429A1 (en) | 2003-11-19 | 2007-09-18 | Multi-mode parallel graphics rendering system (MMPGRS) supporting real-time transition between multiple states of parallel rendering operation in response to the automatic detection of predetermined operating conditions |
US11/901,697 Abandoned US20080074428A1 (en) | 2003-11-19 | 2007-09-18 | Method of rendering pixel-composited images for a graphics-based application running on a computing system embodying a multi-mode parallel graphics rendering system |
US11/901,696 Abandoned US20080088631A1 (en) | 2003-11-19 | 2007-09-18 | Multi-mode parallel graphics rendering and display system supporting real-time detection of scene profile indices programmed within pre-profiled scenes of the graphics-based application |
US11/903,203 Abandoned US20080316216A1 (en) | 2003-11-19 | 2007-09-20 | Computing system capable of parallelizing the operation of multiple graphics processing pipelines (GPPLS) supported on a multi-core CPU chip, and employing a software-implemented multi-mode parallel graphics rendering subsystem |
US11/903,202 Abandoned US20080198167A1 (en) | 2003-11-19 | 2007-09-20 | Computing system capable of parallelizing the operation of graphics processing units (GPUS) supported on an integrated graphics device (IGD) and one or more external graphics cards, employing a software-implemented multi-mode parallel graphics rendering subsystem |
US11/904,042 Abandoned US20080084422A1 (en) | 2003-11-19 | 2007-09-25 | Computing system capable of parallelizing the operation of multiple graphics processing units (GPUS) supported on external graphics cards connected to a graphics hub device with image recomposition being carried out across two or more of said GPUS |
US11/904,041 Abandoned US20080084421A1 (en) | 2003-11-19 | 2007-09-25 | Computing system capable of parallelizing the operation of multiple graphical processing units (GPUs) supported on external graphics cards, with image recomposition being carried out within said GPUs |
US11/904,043 Abandoned US20080088632A1 (en) | 2003-11-19 | 2007-09-25 | Computing system capable of parallelizing the operation of multiple graphics processing units (GPUs) supported on an integrated graphics device (IGD) within a bridge circuit, wherewithin image recomposition is carried out |
US11/904,039 Abandoned US20080084419A1 (en) | 2003-11-19 | 2007-09-25 | Computing system capable of parallelizing the operation of multiple graphics processing units supported on external graphics cards connected to a graphics hub device |
US11/904,022 Abandoned US20080084418A1 (en) | 2003-11-19 | 2007-09-25 | Computing system capable of parallelizing the operation of multiple graphics processing units (GPUS) supported on an integrated graphics device (IGD) within a bridge circuit |
US11/904,040 Active 2026-04-29 US7940274B2 (en) | 2003-11-19 | 2007-09-25 | Computing system having a multiple graphics processing pipeline (GPPL) architecture supported on multiple external graphics cards connected to an integrated graphics device (IGD) embodied within a bridge circuit |
US11/904,294 Abandoned US20080084423A1 (en) | 2003-11-19 | 2007-09-26 | Computing system capable of parallelizing the operation of multiple graphics pipelines (GPPLS) implemented on a multi-core CPU chip |
US11/904,300 Active 2026-04-27 US7944450B2 (en) | 2003-11-19 | 2007-09-26 | Computing system having a hybrid CPU/GPU fusion-type graphics processing pipeline (GPPL) architecture |
US11/904,317 Active 2026-03-12 US8125487B2 (en) | 2003-11-19 | 2007-09-26 | Game console system capable of paralleling the operation of multiple graphic processing units (GPUS) employing a graphics hub device supported on a game console board |
Family Applications Before (9)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/901,745 Abandoned US20080079737A1 (en) | 2003-11-19 | 2007-09-18 | Multi-mode parallel graphics rendering and display system supporting real-time detection of mode control commands (MCCS) programmed within pre-profiled scenes of the graphics-based application |
US11/901,713 Abandoned US20080068389A1 (en) | 2003-11-19 | 2007-09-18 | Multi-mode parallel graphics rendering system (MMPGRS) embodied within a host computing system and employing the profiling of scenes in graphics-based applications |
US11/901,715 Abandoned US20080074431A1 (en) | 2003-11-19 | 2007-09-18 | Computing system capable of parallelizing the operation of multiple graphics processing units (GPUS) supported on external graphics cards |
US11/901,733 Abandoned US20080094404A1 (en) | 2003-11-19 | 2007-09-18 | Computing system having multi-mode parallel graphics rendering subsystem including multiple graphics processing pipelines (GPPLS) and supporting automated division of graphics commands and data during automatic mode control |
US11/901,727 Abandoned US20080094402A1 (en) | 2003-11-19 | 2007-09-18 | Computing system having a parallel graphics rendering system employing multiple graphics processing pipelines (GPPLS) dynamically controlled according to time, image and object division modes of parallel operation during the run-time of graphics-based applications running on the computing system |
US11/901,692 Active 2025-02-13 US7777748B2 (en) | 2003-11-19 | 2007-09-18 | PC-level computing system with a multi-mode parallel graphics rendering subsystem employing an automatic mode controller, responsive to performance data collected during the run-time of graphics applications |
US11/901,716 Abandoned US20080246772A1 (en) | 2003-11-19 | 2007-09-18 | Multi-mode parallel graphics rendering system (MMPGRS) employing multiple graphics processing pipelines (GPPLS) and real-time performance data collection and analysis during the automatic control of the mode of parallel operation of said GPPLS |
US11/901,714 Abandoned US20080074429A1 (en) | 2003-11-19 | 2007-09-18 | Multi-mode parallel graphics rendering system (MMPGRS) supporting real-time transition between multiple states of parallel rendering operation in response to the automatic detection of predetermined operating conditions |
US11/901,697 Abandoned US20080074428A1 (en) | 2003-11-19 | 2007-09-18 | Method of rendering pixel-composited images for a graphics-based application running on a computing system embodying a multi-mode parallel graphics rendering system |
Family Applications After (11)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US11/903,203 Abandoned US20080316216A1 (en) | 2003-11-19 | 2007-09-20 | Computing system capable of parallelizing the operation of multiple graphics processing pipelines (GPPLS) supported on a multi-core CPU chip, and employing a software-implemented multi-mode parallel graphics rendering subsystem |
US11/903,202 Abandoned US20080198167A1 (en) | 2003-11-19 | 2007-09-20 | Computing system capable of parallelizing the operation of graphics processing units (GPUS) supported on an integrated graphics device (IGD) and one or more external graphics cards, employing a software-implemented multi-mode parallel graphics rendering subsystem |
US11/904,042 Abandoned US20080084422A1 (en) | 2003-11-19 | 2007-09-25 | Computing system capable of parallelizing the operation of multiple graphics processing units (GPUS) supported on external graphics cards connected to a graphics hub device with image recomposition being carried out across two or more of said GPUS |
US11/904,041 Abandoned US20080084421A1 (en) | 2003-11-19 | 2007-09-25 | Computing system capable of parallelizing the operation of multiple graphical processing units (GPUs) supported on external graphics cards, with image recomposition being carried out within said GPUs |
US11/904,043 Abandoned US20080088632A1 (en) | 2003-11-19 | 2007-09-25 | Computing system capable of parallelizing the operation of multiple graphics processing units (GPUs) supported on an integrated graphics device (IGD) within a bridge circuit, wherewithin image recomposition is carried out |
US11/904,039 Abandoned US20080084419A1 (en) | 2003-11-19 | 2007-09-25 | Computing system capable of parallelizing the operation of multiple graphics processing units supported on external graphics cards connected to a graphics hub device |
US11/904,022 Abandoned US20080084418A1 (en) | 2003-11-19 | 2007-09-25 | Computing system capable of parallelizing the operation of multiple graphics processing units (GPUS) supported on an integrated graphics device (IGD) within a bridge circuit |
US11/904,040 Active 2026-04-29 US7940274B2 (en) | 2003-11-19 | 2007-09-25 | Computing system having a multiple graphics processing pipeline (GPPL) architecture supported on multiple external graphics cards connected to an integrated graphics device (IGD) embodied within a bridge circuit |
US11/904,294 Abandoned US20080084423A1 (en) | 2003-11-19 | 2007-09-26 | Computing system capable of parallelizing the operation of multiple graphics pipelines (GPPLS) implemented on a multi-core CPU chip |
US11/904,300 Active 2026-04-27 US7944450B2 (en) | 2003-11-19 | 2007-09-26 | Computing system having a hybrid CPU/GPU fusion-type graphics processing pipeline (GPPL) architecture |
US11/904,317 Active 2026-03-12 US8125487B2 (en) | 2003-11-19 | 2007-09-26 | Game console system capable of paralleling the operation of multiple graphic processing units (GPUS) employing a graphics hub device supported on a game console board |
Country Status (1)
Country | Link |
---|---|
US (21) | US20080079737A1 (en) |
Cited By (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20100201691A1 (en) * | 2009-02-12 | 2010-08-12 | Microsoft Corporation | Shader-based finite state machine frame detection |
US20120133667A1 (en) * | 2010-11-30 | 2012-05-31 | Autodesk, Inc. | Method and apparatus for designing, stylizing, and supplementing an image/scene |
US11074453B2 (en) | 2018-01-31 | 2021-07-27 | Hewlett Packard Enterprise Development Lp | Video active region batching |
Families Citing this family (146)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
JP3862649B2 (en) * | 2002-11-29 | 2006-12-27 | 任天堂株式会社 | GAME DEVICE, GAME PROGRAM, BACKUP WRITE CONTROL METHOD, AND GAME INFORMATION RECORDING MEDIUM |
US7961194B2 (en) | 2003-11-19 | 2011-06-14 | Lucid Information Technology, Ltd. | Method of controlling in real time the switching of modes of parallel operation of a multi-mode parallel graphics processing subsystem embodied within a host computing system |
EP1687732A4 (en) | 2003-11-19 | 2008-11-19 | Lucid Information Technology Ltd | Method and system for multiple 3-d graphic pipeline over a pc bus |
US8427490B1 (en) | 2004-05-14 | 2013-04-23 | Nvidia Corporation | Validating a graphics pipeline using pre-determined schedules |
US8941668B2 (en) * | 2004-06-25 | 2015-01-27 | Nvidia Corporation | Method and system for a scalable discrete graphics system |
US8411093B2 (en) * | 2004-06-25 | 2013-04-02 | Nvidia Corporation | Method and system for stand alone graphics independent of computer system form factor |
US7663633B1 (en) | 2004-06-25 | 2010-02-16 | Nvidia Corporation | Multiple GPU graphics system for implementing cooperative graphics instruction execution |
US8446417B2 (en) * | 2004-06-25 | 2013-05-21 | Nvidia Corporation | Discrete graphics system unit for housing a GPU |
US9087161B1 (en) | 2004-06-28 | 2015-07-21 | Nvidia Corporation | Asymmetrical scaling multiple GPU graphics system for implementing cooperative graphics instruction execution |
US7958498B1 (en) * | 2004-07-02 | 2011-06-07 | Nvidia Corporation | Methods and systems for processing a geometry shader program developed in a high-level shading language |
US8044951B1 (en) | 2004-07-02 | 2011-10-25 | Nvidia Corporation | Integer-based functionality in a graphics shading language |
US8624906B2 (en) | 2004-09-29 | 2014-01-07 | Nvidia Corporation | Method and system for non stalling pipeline instruction fetching from memory |
US8424012B1 (en) * | 2004-11-15 | 2013-04-16 | Nvidia Corporation | Context switching on a video processor having a scalar execution unit and a vector execution unit |
FR2884949B1 (en) * | 2005-04-26 | 2007-06-22 | Thales Sa | GRAPHIC GENERATION DEVICE HAVING MONITORS FOR MONITORING ITS OPERATION. |
US10026140B2 (en) * | 2005-06-10 | 2018-07-17 | Nvidia Corporation | Using a scalable graphics system to enable a general-purpose multi-user computer system |
US8893016B2 (en) * | 2005-06-10 | 2014-11-18 | Nvidia Corporation | Using a graphics system to enable a multi-user computer system |
US9092170B1 (en) | 2005-10-18 | 2015-07-28 | Nvidia Corporation | Method and system for implementing fragment operation processing across a graphics bus interconnect |
US7948497B2 (en) * | 2005-11-29 | 2011-05-24 | Via Technologies, Inc. | Chipset and related method of processing graphic signals |
US7728841B1 (en) | 2005-12-19 | 2010-06-01 | Nvidia Corporation | Coherent shader output for multiple targets |
US7916864B2 (en) * | 2006-02-08 | 2011-03-29 | Nvidia Corporation | Graphics processing unit used for cryptographic processing |
US20080036758A1 (en) * | 2006-03-31 | 2008-02-14 | Intelisum Inc. | Systems and methods for determining a global or local position of a point of interest within a scene using a three-dimensional model of the scene |
US8683126B2 (en) | 2007-07-30 | 2014-03-25 | Nvidia Corporation | Optimal use of buffer space by a storage controller which writes retrieved data directly to a memory |
US8698819B1 (en) | 2007-08-15 | 2014-04-15 | Nvidia Corporation | Software assisted shader merging |
US8659601B1 (en) | 2007-08-15 | 2014-02-25 | Nvidia Corporation | Program sequencer for generating indeterminant length shader programs for a graphics processor |
US8411096B1 (en) | 2007-08-15 | 2013-04-02 | Nvidia Corporation | Shader program instruction fetch |
US9024957B1 (en) | 2007-08-15 | 2015-05-05 | Nvidia Corporation | Address independent shader program loading |
US20090138647A1 (en) * | 2007-11-26 | 2009-05-28 | Hagita Yasuharu | Bus switch, electronic equipment, and data transfer method |
US8515052B2 (en) | 2007-12-17 | 2013-08-20 | Wai Wu | Parallel signal processing system and method |
US8780123B2 (en) | 2007-12-17 | 2014-07-15 | Nvidia Corporation | Interrupt handling techniques in the rasterizer of a GPU |
US9064333B2 (en) | 2007-12-17 | 2015-06-23 | Nvidia Corporation | Interrupt handling techniques in the rasterizer of a GPU |
EP2245536B1 (en) * | 2008-01-27 | 2018-10-24 | Citrix Systems, Inc. | Methods and systems for remoting three dimensional graphics |
US9471996B2 (en) * | 2008-02-29 | 2016-10-18 | Autodesk, Inc. | Method for creating graphical materials for universal rendering framework |
US8134551B2 (en) * | 2008-02-29 | 2012-03-13 | Autodesk, Inc. | Frontend for universal rendering framework |
EP2098994A1 (en) * | 2008-03-04 | 2009-09-09 | Agfa HealthCare NV | System for real-time volume rendering on thin clients via a render server |
US8212806B2 (en) * | 2008-04-08 | 2012-07-03 | Autodesk, Inc. | File format extensibility for universal rendering framework |
US20100073695A1 (en) * | 2008-04-18 | 2010-03-25 | Global Graphics Software Limited | Methods and systems for increasing performance of server-based rendering |
US8681861B2 (en) | 2008-05-01 | 2014-03-25 | Nvidia Corporation | Multistandard hardware video encoder |
US8923385B2 (en) | 2008-05-01 | 2014-12-30 | Nvidia Corporation | Rewind-enabled hardware encoder |
US8432405B2 (en) * | 2008-06-26 | 2013-04-30 | Microsoft Corporation | Dynamically transitioning between hardware-accelerated and software rendering |
US8319782B2 (en) * | 2008-07-08 | 2012-11-27 | Dell Products, Lp | Systems and methods for providing scalable parallel graphics rendering capability for information handling systems |
US8856196B2 (en) * | 2008-07-22 | 2014-10-07 | Toyota Jidosha Kabushiki Kaisha | System and method for transferring tasks in a multi-core processor based on trial execution and core node |
US8667404B2 (en) * | 2008-08-06 | 2014-03-04 | Autodesk, Inc. | Predictive material editor |
JP2010062695A (en) * | 2008-09-02 | 2010-03-18 | Sony Corp | Image processing apparatus, image processing method, and program |
US8754895B2 (en) * | 2008-09-09 | 2014-06-17 | Sony Corporation | Pipelined image processing engine |
US8601398B2 (en) * | 2008-10-13 | 2013-12-03 | Autodesk, Inc. | Data-driven interface for managing materials |
US8560957B2 (en) * | 2008-10-13 | 2013-10-15 | Autodesk, Inc. | Data-driven interface for managing materials |
US8279229B1 (en) * | 2008-10-27 | 2012-10-02 | Nvidia Corporation | System, method, and computer program product for providing access to graphics processor CPU cores, to both a graphics processor and a CPU |
US9342901B2 (en) * | 2008-10-27 | 2016-05-17 | Autodesk, Inc. | Material data processing pipeline |
US8584084B2 (en) * | 2008-11-12 | 2013-11-12 | Autodesk, Inc. | System for library content creation |
US8489851B2 (en) | 2008-12-11 | 2013-07-16 | Nvidia Corporation | Processing of read requests in a memory controller using pre-fetch mechanism |
US8594467B2 (en) * | 2008-12-19 | 2013-11-26 | Microsoft Corporation | Interactive virtual display system for ubiquitous devices |
US8180165B2 (en) * | 2008-12-19 | 2012-05-15 | Microsoft Corp. | Accelerated screen codec |
KR101511273B1 (en) * | 2008-12-29 | 2015-04-10 | 삼성전자주식회사 | System and method for 3d graphic rendering based on multi-core processor |
US9110706B2 (en) * | 2009-02-09 | 2015-08-18 | Microsoft Technology Licensing, Llc | General purpose distributed data parallel computing using a high level language |
US20100214294A1 (en) * | 2009-02-20 | 2010-08-26 | Microsoft Corporation | Method for tessellation on graphics hardware |
US8471858B2 (en) * | 2009-06-02 | 2013-06-25 | Qualcomm Incorporated | Displaying a visual representation of performance metrics for rendered graphics elements |
EP2470991A1 (en) | 2009-08-24 | 2012-07-04 | ABB Technology AG | Improved execution of real time applications with an automation controller |
US20110169844A1 (en) * | 2009-09-16 | 2011-07-14 | Nvidia Corporation | Content Protection Techniques on Heterogeneous Graphics Processing Units |
US8704836B1 (en) * | 2009-10-19 | 2014-04-22 | Nvidia Corporation | Distributing primitives to multiple rasterizers |
US9536341B1 (en) * | 2009-10-19 | 2017-01-03 | Nvidia Corporation | Distributing primitives to multiple rasterizers |
US8532098B2 (en) * | 2009-11-30 | 2013-09-10 | Nvidia Corporation | System and method for virtual channel communication |
US9176909B2 (en) * | 2009-12-11 | 2015-11-03 | Nvidia Corporation | Aggregating unoccupied PCI-e links to provide greater bandwidth |
US8669990B2 (en) * | 2009-12-31 | 2014-03-11 | Intel Corporation | Sharing resources between a CPU and GPU |
AR074703A1 (en) * | 2010-01-14 | 2011-02-09 | Dixar Inc S A | PROVISION FOR PROCESSING OF DATA FROM THE FRACTIONATION OF INFORMATION AND PROCEDURE OF PROCESSING OF SUCH DATA |
US8854365B2 (en) * | 2010-01-15 | 2014-10-07 | Microsoft Corporation | Rendering parametric surface patches |
SG183423A1 (en) * | 2010-02-20 | 2012-09-27 | Omega Engineering | Multi-mode graphic display for a test and/or measurement device |
TW201142696A (en) * | 2010-05-19 | 2011-12-01 | Xgi Technology Inc | Image processing device and image signal processing system |
US8593466B2 (en) * | 2010-06-08 | 2013-11-26 | Intel Corporation | Tile rendering for image processing |
US8381108B2 (en) * | 2010-06-21 | 2013-02-19 | Microsoft Corporation | Natural user input for driving interactive stories |
JP5835942B2 (en) * | 2010-06-25 | 2015-12-24 | キヤノン株式会社 | Image processing apparatus, control method thereof, and program |
WO2012096672A1 (en) * | 2011-01-14 | 2012-07-19 | Dixar Inc. S.A. | Arrangement for data processing based on division of the information into fractions |
CN102073543B (en) * | 2011-01-14 | 2013-03-20 | 上海交通大学 | General processor and graphics processor fusion system and method |
US8339409B2 (en) * | 2011-02-16 | 2012-12-25 | Arm Limited | Tile-based graphics system and method of operation of such a system |
US8786619B2 (en) * | 2011-02-25 | 2014-07-22 | Adobe Systems Incorporated | Parallelized definition and display of content in a scripting environment |
US8976189B2 (en) | 2011-04-25 | 2015-03-10 | Microsoft Corporation | Drawing operations using multiple graphics interfaces |
JP5829684B2 (en) | 2011-04-28 | 2015-12-09 | 株式会社ディジタルメディアプロフェッショナル | Heterogeneous graphics processor and configuration method thereof |
US8982136B2 (en) | 2011-05-16 | 2015-03-17 | Qualcomm Incorporated | Rendering mode selection in graphics processing units |
US10013731B2 (en) * | 2011-06-30 | 2018-07-03 | Intel Corporation | Maximizing parallel processing in graphics processors |
US9044677B2 (en) * | 2011-07-11 | 2015-06-02 | Roblox Corporation | System for optimizing processing capacity for a group of gaming appliances engaged in play of an online game |
US8884974B2 (en) | 2011-08-12 | 2014-11-11 | Microsoft Corporation | Managing multiple GPU-based rendering contexts |
US9135189B2 (en) | 2011-09-07 | 2015-09-15 | Microsoft Technology Licensing, Llc | Delivering GPU resources across machine boundaries |
KR101926570B1 (en) | 2011-09-14 | 2018-12-10 | 삼성전자주식회사 | Method and apparatus for graphic processing using post shader |
KR101145588B1 (en) * | 2011-09-26 | 2012-05-15 | 한국항공우주산업 주식회사 | Mission computer system with dual-task graphics processor module |
US9053067B2 (en) * | 2011-09-30 | 2015-06-09 | International Business Machines Corporation | Distributed data scalable adaptive map-reduce framework |
US9821230B2 (en) | 2011-11-08 | 2017-11-21 | Zynga Inc. | Data-driven state machine for user interactive displays |
US9463386B1 (en) * | 2011-11-08 | 2016-10-11 | Zynga Inc. | State machine scripting in computer-implemented games |
CN102625144A (en) * | 2011-11-28 | 2012-08-01 | 苏州奇可思信息科技有限公司 | Parallel video processing method based on Cloud Network of local area network |
US9330031B2 (en) | 2011-12-09 | 2016-05-03 | Nvidia Corporation | System and method for calibration of serial links using a serial-to-parallel loopback |
US8692832B2 (en) | 2012-01-23 | 2014-04-08 | Microsoft Corporation | Para-virtualized asymmetric GPU processors |
KR101956197B1 (en) | 2012-07-18 | 2019-03-08 | 삼성전자 주식회사 | Method and apparatus for data processing using graphic processing unit |
KR101970041B1 (en) * | 2012-09-07 | 2019-04-18 | 카네기 멜론 유니버시티 | Methods for Hybrid GPU/CPU Data Processing |
US9449359B2 (en) * | 2012-09-13 | 2016-09-20 | Ati Technologies Ulc | Rendering settings in a multi-graphics processing unit system |
US20140189544A1 (en) * | 2012-12-27 | 2014-07-03 | Nvidia Corporation | Web-based graphics development system and method of graphics program interaction therewith |
US9805497B2 (en) * | 2013-02-05 | 2017-10-31 | Reuven Bakalash | Collision-culling of lines over polygons |
CN103984669A (en) * | 2013-02-07 | 2014-08-13 | 辉达公司 | System and method for image processing |
US9317465B2 (en) * | 2013-03-15 | 2016-04-19 | Janus Technologies, Inc. | System and method of sending PCI express data over ethernet connection |
GB2514397B (en) | 2013-05-23 | 2017-10-11 | Linear Algebra Tech Ltd | Corner detection |
US9495722B2 (en) | 2013-05-24 | 2016-11-15 | Sony Interactive Entertainment Inc. | Developer controlled layout |
US10255650B2 (en) * | 2013-05-24 | 2019-04-09 | Sony Interactive Entertainment Inc. | Graphics processing using dynamic resources |
JP6195476B2 (en) | 2013-05-31 | 2017-09-13 | 矢崎総業株式会社 | Analysis device, analysis method and program |
US9273980B2 (en) | 2013-06-09 | 2016-03-01 | Apple Inc. | Direction list |
JP6195480B2 (en) * | 2013-07-08 | 2017-09-13 | 矢崎総業株式会社 | Analysis device, analysis method, and program |
US11768689B2 (en) | 2013-08-08 | 2023-09-26 | Movidius Limited | Apparatus, systems, and methods for low power computational imaging |
US9934043B2 (en) | 2013-08-08 | 2018-04-03 | Linear Algebra Technologies Limited | Apparatus, systems, and methods for providing computational imaging pipeline |
US10001993B2 (en) | 2013-08-08 | 2018-06-19 | Linear Algebra Technologies Limited | Variable-length instruction buffer management |
US9727113B2 (en) | 2013-08-08 | 2017-08-08 | Linear Algebra Technologies Limited | Low power computational imaging |
US9910675B2 (en) | 2013-08-08 | 2018-03-06 | Linear Algebra Technologies Limited | Apparatus, systems, and methods for low power computational imaging |
CN103679780B (en) * | 2013-08-22 | 2016-06-22 | 中国人民解放军信息工程大学 | A kind of space target real time simulation method |
FI20135946L (en) * | 2013-09-23 | 2015-03-24 | Procomp Solutions Oy | Calculation of parallel solution |
US9196017B2 (en) | 2013-11-15 | 2015-11-24 | Linear Algebra Technologies Limited | Apparatus, systems, and methods for removing noise from an image |
US9270872B2 (en) | 2013-11-26 | 2016-02-23 | Linear Algebra Technologies Limited | Apparatus, systems, and methods for removing shading effect from image |
AU2015214262A1 (en) * | 2014-02-04 | 2016-08-18 | Tactual Labs Co. | Low-latency visual response to input via pre-generation of alternative graphical representations of application elements and input handling on a graphical processing unit |
US9679347B2 (en) | 2014-02-18 | 2017-06-13 | Qualcomm Incorporated | Shader pipeline with shared data channels |
AU2014403813A1 (en) * | 2014-08-20 | 2017-02-02 | Landmark Graphics Corporation | Optimizing computer hardware resource utilization when processing variable precision data |
US10055672B2 (en) | 2015-03-11 | 2018-08-21 | Microsoft Technology Licensing, Llc | Methods and systems for low-energy image classification |
US10268886B2 (en) | 2015-03-11 | 2019-04-23 | Microsoft Technology Licensing, Llc | Context-awareness through biased on-device image classifiers |
US20160292117A1 (en) * | 2015-03-30 | 2016-10-06 | Integrated Device Technology, Inc. | Methods and Apparatus for Efficient Network Analytics and Computing Card |
GB2536964B (en) * | 2015-04-02 | 2019-12-25 | Ge Aviat Systems Ltd | Avionics display system |
US10019775B2 (en) | 2015-04-30 | 2018-07-10 | Honeywell International Inc. | Method and system for scalable, radiation-tolerant, space-rated, high integrity graphics processing unit |
US9779466B2 (en) | 2015-05-07 | 2017-10-03 | Microsoft Technology Licensing, Llc | GPU operation |
CN105045726B (en) * | 2015-08-10 | 2019-10-11 | Tcl集团股份有限公司 | A kind of picture operation method and system based on parallel computation |
CN106910234A (en) * | 2015-12-18 | 2017-06-30 | 普联软件股份有限公司 | One kind is based on improved 3 d rendering engine Distributed Rendering Environment method and system |
US10453445B2 (en) * | 2016-02-16 | 2019-10-22 | Carnegie Mellon University | System and method for multi-user GPU-accelerated speech recognition engine for client-server architectures |
US10460704B2 (en) | 2016-04-01 | 2019-10-29 | Movidius Limited | Systems and methods for head-mounted display adapted to human visual mechanism |
US10345876B2 (en) | 2016-10-13 | 2019-07-09 | Microsoft Technology Licensing, Llc | Computing device with removable power module |
US11455011B2 (en) | 2016-10-13 | 2022-09-27 | Microsoft Technology Licensing, Llc | Modular computing device with common AC power |
CN106686352B (en) * | 2016-12-23 | 2019-06-07 | 北京大学 | The real-time processing method of the multi-path video data of more GPU platforms |
US11150943B2 (en) * | 2017-04-10 | 2021-10-19 | Intel Corporation | Enabling a single context hardware system to operate as a multi-context system |
US10290141B2 (en) | 2017-04-17 | 2019-05-14 | Intel Corporation | Cloud based distributed single game calculation of shared computational work for multiple cloud gaming client devices |
CN107221023A (en) * | 2017-05-27 | 2017-09-29 | 郑州云海信息技术有限公司 | A kind of creation method and device of modularized equipment design sketch |
KR102340199B1 (en) * | 2017-06-14 | 2021-12-16 | 삼성전자주식회사 | Image display apparatus, and operating method for the same |
GB2563588B (en) | 2017-06-16 | 2019-06-26 | Imagination Tech Ltd | Scheduling tasks |
US20210134049A1 (en) * | 2017-08-08 | 2021-05-06 | Sony Corporation | Image processing apparatus and method |
US10798162B2 (en) * | 2017-08-28 | 2020-10-06 | Texas Instruments Incorporated | Cluster system with fail-safe fallback mechanism |
US10949947B2 (en) | 2017-12-29 | 2021-03-16 | Intel Corporation | Foveated image rendering for head-mounted display devices |
CN108596065A (en) * | 2018-04-13 | 2018-09-28 | 深圳职业技术学院 | One kind is based on deep semantic segmentation marine oil spill detecting system and method |
CN109617859B (en) * | 2018-11-13 | 2021-12-03 | 视联动力信息技术股份有限公司 | Method and device for realizing split screen mode |
CN109727186B (en) * | 2018-12-12 | 2023-03-21 | 中国航空工业集团公司西安航空计算技术研究所 | SystemC-based GPU (graphics processing Unit) fragment coloring task scheduling method |
CN109656532B (en) * | 2018-12-12 | 2022-03-15 | 中国航空工业集团公司西安航空计算技术研究所 | UML-based GPU (graphics processing Unit) -oriented fragment coloring task scheduling method |
TWI715166B (en) * | 2019-08-27 | 2021-01-01 | 宏正自動科技股份有限公司 | Multi-screen control system |
CN110751712A (en) * | 2019-10-22 | 2020-02-04 | 中设数字技术股份有限公司 | Online three-dimensional rendering technology and system based on cloud platform |
CN111045665B (en) * | 2019-11-21 | 2023-03-10 | 中国航空工业集团公司西安航空计算技术研究所 | UML-based GPU command processor |
US11170461B2 (en) * | 2020-02-03 | 2021-11-09 | Sony Interactive Entertainment Inc. | System and method for efficient multi-GPU rendering of geometry by performing geometry analysis while rendering |
CN112328532B (en) * | 2020-11-02 | 2024-02-09 | 长沙景嘉微电子股份有限公司 | Method and device for multi-GPU communication, storage medium and electronic device |
CN113744123B (en) * | 2021-11-05 | 2022-01-25 | 四川见山科技有限责任公司 | Large-scale dynamic object drawing method and system based on global instantiation |
CN114820279B (en) * | 2022-05-18 | 2023-03-24 | 北京百度网讯科技有限公司 | Distributed deep learning method and device based on multiple GPUs and electronic equipment |
Citations (85)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5740464A (en) * | 1995-05-15 | 1998-04-14 | Nvidia Corporation | Architecture for providing input/output operations in a computer system |
US5754866A (en) * | 1995-05-08 | 1998-05-19 | Nvidia Corporation | Delayed interrupts with a FIFO in an improved input/output architecture |
US5758182A (en) * | 1995-05-15 | 1998-05-26 | Nvidia Corporation | DMA controller translates virtual I/O device address received directly from application program command to physical i/o device address of I/O device on device bus |
US6169553B1 (en) * | 1997-07-02 | 2001-01-02 | Ati Technologies, Inc. | Method and apparatus for rendering a three-dimensional scene having shadowing |
US6181352B1 (en) * | 1999-03-22 | 2001-01-30 | Nvidia Corporation | Graphics pipeline selectively providing multiple pixels or multiple textures |
US6184908B1 (en) * | 1998-04-27 | 2001-02-06 | Ati Technologies, Inc. | Method and apparatus for co-processing video graphics data |
US6188412B1 (en) * | 1998-08-28 | 2001-02-13 | Ati Technologies, Inc. | Method and apparatus for performing setup operations in a video graphics system |
US6201545B1 (en) * | 1997-09-23 | 2001-03-13 | Ati Technologies, Inc. | Method and apparatus for generating sub pixel masks in a three dimensional graphic processing system |
US6337686B2 (en) * | 1998-01-07 | 2002-01-08 | Ati Technologies Inc. | Method and apparatus for line anti-aliasing |
US20020015055A1 (en) * | 2000-07-18 | 2002-02-07 | Silicon Graphics, Inc. | Method and system for presenting three-dimensional computer graphics images using multiple graphics processing units |
US6352479B1 (en) * | 1999-08-31 | 2002-03-05 | Nvidia U.S. Investment Company | Interactive gaming server and online community forum |
US6415345B1 (en) * | 1998-08-03 | 2002-07-02 | Ati Technologies | Bus mastering interface control system for transferring multistream data over a host bus |
US20020085007A1 (en) * | 2000-06-29 | 2002-07-04 | Sun Microsystems, Inc. | Graphics system configured to parallel-process graphics data using multiple pipelines |
US6442656B1 (en) * | 1999-08-18 | 2002-08-27 | Ati Technologies Srl | Method and apparatus for interfacing memory with a bus |
US20020118308A1 (en) * | 2001-02-27 | 2002-08-29 | Ati Technologies, Inc. | Integrated single and dual television tuner having improved fine tuning |
US20030020720A1 (en) * | 1999-12-06 | 2003-01-30 | Nvidia Corporation | Method, apparatus and article of manufacture for a sequencer in a transform/lighting module capable of processing multiple independent execution threads |
US20030034975A1 (en) * | 1999-12-06 | 2003-02-20 | Nvidia Corporation | Lighting system and method for a graphics processor |
US6532525B1 (en) * | 2000-09-29 | 2003-03-11 | Ati Technologies, Inc. | Method and apparatus for accessing memory |
US6532013B1 (en) * | 2000-05-31 | 2003-03-11 | Nvidia Corporation | System, method and article of manufacture for pixel shaders for programmable shading |
US6535209B1 (en) * | 1999-03-17 | 2003-03-18 | Nvidia Us Investments Co. | Data stream splitting and storage in graphics data processing |
US6542971B1 (en) * | 2001-04-23 | 2003-04-01 | Nvidia Corporation | Memory access system and method employing an auxiliary buffer |
US20030080959A1 (en) * | 2001-10-29 | 2003-05-01 | Ati Technologies, Inc. | System, Method, and apparatus for early culling |
US20030103054A1 (en) * | 1999-12-06 | 2003-06-05 | Nvidia Corporation | Integrated graphics processing unit with antialiasing |
US6577320B1 (en) * | 1999-03-22 | 2003-06-10 | Nvidia Corporation | Method and apparatus for processing multiple types of pixel component representations including processes of premultiplication, postmultiplication, and colorkeying/chromakeying |
US6577309B2 (en) * | 1999-12-06 | 2003-06-10 | Nvidia Corporation | System and method for a graphics processing framework embodied utilizing a single semiconductor platform |
US20030112246A1 (en) * | 1999-12-06 | 2003-06-19 | Nvidia Corporation | Blending system and method in an integrated computer graphics pipeline |
US20030128197A1 (en) * | 2002-01-04 | 2003-07-10 | Ati Technologies, Inc. | Portable device for providing dual display and method thereof |
US6593923B1 (en) * | 2000-05-31 | 2003-07-15 | Nvidia Corporation | System, method and article of manufacture for shadow mapping |
US20030151606A1 (en) * | 2001-10-29 | 2003-08-14 | Ati Technologies Inc. | System, method, and apparatus for multi-level hierarchical Z buffering |
US6677953B1 (en) * | 2001-11-08 | 2004-01-13 | Nvidia Corporation | Hardware viewport system and method for use in a graphics pipeline |
US20040012600A1 (en) * | 2002-03-22 | 2004-01-22 | Deering Michael F. | Scalable high performance 3d graphics |
US6691180B2 (en) * | 1998-04-17 | 2004-02-10 | Nvidia Corporation | Apparatus for accelerating the rendering of images |
US6690372B2 (en) * | 2000-05-31 | 2004-02-10 | Nvidia Corporation | System, method and article of manufacture for shadow mapping |
US20040036159A1 (en) * | 2002-08-23 | 2004-02-26 | Ati Technologies, Inc. | Integrated circuit having memory disposed thereon and method of making thereof |
US6700583B2 (en) * | 2001-05-14 | 2004-03-02 | Ati Technologies, Inc. | Configurable buffer for multipass applications |
US6704025B1 (en) * | 2001-08-31 | 2004-03-09 | Nvidia Corporation | System and method for dual-depth shadow-mapping |
US6724394B1 (en) * | 2000-05-31 | 2004-04-20 | Nvidia Corporation | Programmable pixel shading architecture |
US6725457B1 (en) * | 2000-05-17 | 2004-04-20 | Nvidia Corporation | Semaphore enhancement to improve system performance |
US6728820B1 (en) * | 2000-05-26 | 2004-04-27 | Ati International Srl | Method of configuring, controlling, and accessing a bridge and apparatus therefor |
US6731298B1 (en) * | 2000-10-02 | 2004-05-04 | Nvidia Corporation | System, method and article of manufacture for z-texture mapping |
US6734861B1 (en) * | 2000-05-31 | 2004-05-11 | Nvidia Corporation | System, method and article of manufacture for an interlock module in a computer graphics processing pipeline |
US6744433B1 (en) * | 2001-08-31 | 2004-06-01 | Nvidia Corporation | System and method for using and collecting information from a plurality of depth layers |
US20040153778A1 (en) * | 2002-06-12 | 2004-08-05 | Ati Technologies, Inc. | Method, system and software for configuring a graphics processing communication mode |
US6774895B1 (en) * | 2002-02-01 | 2004-08-10 | Nvidia Corporation | System and method for depth clamping in a hardware graphics pipeline |
US6778181B1 (en) * | 2000-12-07 | 2004-08-17 | Nvidia Corporation | Graphics processing system having a virtual texturing array |
US6779069B1 (en) * | 2002-09-04 | 2004-08-17 | Nvidia Corporation | Computer system with source-synchronous digital link |
US6778189B1 (en) * | 2001-08-24 | 2004-08-17 | Nvidia Corporation | Two-sided stencil testing system and method |
US20040159488A1 (en) * | 2002-07-25 | 2004-08-19 | Hitachi, Ltd. | Torque sensor and motor-driven power steering apparatus using thereof |
US6856320B1 (en) * | 1997-11-25 | 2005-02-15 | Nvidia U.S. Investment Company | Demand-based memory system for graphics applications |
US20050041031A1 (en) * | 2003-08-18 | 2005-02-24 | Nvidia Corporation | Adaptive load balancing in a multi-processor graphics processing system |
US6864893B2 (en) * | 2002-07-19 | 2005-03-08 | Nvidia Corporation | Method and apparatus for modifying depth values using pixel programs |
US6870540B1 (en) * | 1999-12-06 | 2005-03-22 | Nvidia Corporation | System, method and computer program product for a programmable pixel processing model with instruction set |
US6876362B1 (en) * | 2002-07-10 | 2005-04-05 | Nvidia Corporation | Omnidirectional shadow texture mapping |
US20050081115A1 (en) * | 2003-09-26 | 2005-04-14 | Ati Technologies, Inc. | Method and apparatus for monitoring and resetting a co-processor |
US6894689B1 (en) * | 1998-07-22 | 2005-05-17 | Nvidia Corporation | Occlusion culling method and apparatus for graphics systems |
US6894687B1 (en) * | 2001-06-08 | 2005-05-17 | Nvidia Corporation | System, method and computer program product for vertex attribute aliasing in a graphics pipeline |
US6900810B1 (en) * | 2003-04-10 | 2005-05-31 | Nvidia Corporation | User programmable geometry engine |
US20050122330A1 (en) * | 2003-11-14 | 2005-06-09 | Microsoft Corporation | Systems and methods for downloading algorithmic elements to a coprocessor and corresponding techniques |
US6909595B2 (en) * | 2000-08-11 | 2005-06-21 | Epcos Ag | Capacitor winding and a capacitor having the capacitor winding |
US20050162437A1 (en) * | 2004-01-23 | 2005-07-28 | Ati Technologies, Inc. | Method and apparatus for graphics processing using state and shader management |
US20050166207A1 (en) * | 2003-12-26 | 2005-07-28 | National University Corporation Utsunomiya University | Self-optimizing computer system |
US6982718B2 (en) * | 2001-06-08 | 2006-01-03 | Nvidia Corporation | System, method and computer program product for programmable fragment processing in a graphics pipeline |
US20060005178A1 (en) * | 2004-07-02 | 2006-01-05 | Nvidia Corporation | Optimized chaining of vertex and fragment programs |
US6985152B2 (en) * | 2004-04-23 | 2006-01-10 | Nvidia Corporation | Point-to-point bus bridging without a bridge controller |
US6989840B1 (en) * | 2001-08-31 | 2006-01-24 | Nvidia Corporation | Order-independent transparency rendering system and method |
US6995767B1 (en) * | 2003-07-31 | 2006-02-07 | Nvidia Corporation | Trilinear optimization for texture filtering |
US7002588B1 (en) * | 1999-12-06 | 2006-02-21 | Nvidia Corporation | System, method and computer program product for branching during programmable vertex processing |
US20060055695A1 (en) * | 2004-09-13 | 2006-03-16 | Nvidia Corporation | Increased scalability in the fragment shading pipeline |
US20060059494A1 (en) * | 2004-09-16 | 2006-03-16 | Nvidia Corporation | Load balancing |
US7015915B1 (en) * | 2003-08-12 | 2006-03-21 | Nvidia Corporation | Programming multiple chips from a command buffer |
US7023437B1 (en) * | 1998-07-22 | 2006-04-04 | Nvidia Corporation | System and method for accelerating graphics processing using a post-geometry data stream during multiple-pass rendering |
US7027972B1 (en) * | 2001-01-24 | 2006-04-11 | Ati Technologies, Inc. | System for collecting and analyzing graphics data and method thereof |
US7038692B1 (en) * | 1998-04-07 | 2006-05-02 | Nvidia Corporation | Method and apparatus for providing a vertex cache |
US7038678B2 (en) * | 2003-05-21 | 2006-05-02 | Nvidia Corporation | Dependent texture shadow antialiasing |
US7038685B1 (en) * | 2003-06-30 | 2006-05-02 | Nvidia Corporation | Programmable graphics processor for multithreaded execution of programs |
US20060101218A1 (en) * | 2004-11-11 | 2006-05-11 | Nvidia Corporation | Memory controller-adaptive 1T/2T timing control |
US7053901B2 (en) * | 2003-12-11 | 2006-05-30 | Nvidia Corporation | System and method for accelerating a special purpose processor |
US20060123142A1 (en) * | 2004-12-06 | 2006-06-08 | Nvidia Corporation | Method and apparatus for providing peer-to-peer data transfer within a computing environment |
US20060119607A1 (en) * | 2004-02-27 | 2006-06-08 | Nvidia Corporation | Register based queuing for texture requests |
US20060120376A1 (en) * | 2004-12-06 | 2006-06-08 | Nvidia Corporation | Method and apparatus for providing peer-to-peer data transfer within a computing environment |
US7068278B1 (en) * | 2003-04-17 | 2006-06-27 | Nvidia Corporation | Synchronized graphics processing units |
US20060156399A1 (en) * | 2004-12-30 | 2006-07-13 | Parmar Pankaj N | System and method for implementing network security using a sequestered partition |
US7080194B1 (en) * | 2002-02-12 | 2006-07-18 | Nvidia Corporation | Method and system for memory access arbitration for minimizing read/write turnaround penalties |
US7081895B2 (en) * | 2002-07-18 | 2006-07-25 | Nvidia Corporation | Systems and methods of multi-pass data processing |
US7248261B1 (en) * | 2003-12-15 | 2007-07-24 | Nvidia Corporation | Method and apparatus to accelerate rendering of shadow effects for computer-generated images |
Family Cites Families (139)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US669180A (en) * | 1900-05-14 | 1901-03-05 | James Pullar | Combination fire-escape and water-tower. |
US664960A (en) * | 1900-09-05 | 1901-01-01 | John A Hill | Oil-separator and automatic regulating-valve for refrigerating systems. |
US706272A (en) * | 1901-12-05 | 1902-08-05 | Charles W Stimson | Clasp. |
US734861A (en) * | 1903-01-29 | 1903-07-28 | Joseph E Austrian | Cast-off. |
CA2073516A1 (en) * | 1991-11-27 | 1993-05-28 | Peter Michael Kogge | Dynamic multi-mode parallel processor array architecture computer system |
JP3199205B2 (en) | 1993-11-19 | 2001-08-13 | 株式会社日立製作所 | Parallel processing unit |
EP0693737A3 (en) * | 1994-07-21 | 1997-01-08 | Ibm | Method and apparatus for managing multiprocessor graphical workload distribution |
US5745762A (en) * | 1994-12-15 | 1998-04-28 | International Business Machines Corporation | Advanced graphics driver architecture supporting multiple system emulations |
US5687357A (en) | 1995-04-14 | 1997-11-11 | Nvidia Corporation | Register array for utilizing burst mode transfer on local bus |
US5909595A (en) * | 1995-05-15 | 1999-06-01 | Nvidia Corporation | Method of controlling I/O routing by setting connecting context for utilizing I/O processing elements within a computer system to produce multimedia effects |
US5764866A (en) * | 1995-05-26 | 1998-06-09 | Ricoh Company, Ltd. | Scanner, network scanner system, and method for network scanner system |
US5794016A (en) * | 1995-12-11 | 1998-08-11 | Dynamic Pictures, Inc. | Parallel-processor graphics architecture |
KR100269106B1 (en) | 1996-03-21 | 2000-11-01 | 윤종용 | Multiprocessor graphics system |
EP0948859A1 (en) * | 1996-08-14 | 1999-10-13 | Nortel Networks Limited | Internet-based telephone call manager |
US6118462A (en) * | 1997-07-01 | 2000-09-12 | Memtrax Llc | Computer system controller having internal memory and external memory control |
US6496187B1 (en) | 1998-02-17 | 2002-12-17 | Sun Microsystems, Inc. | Graphics system configured to perform parallel sample to pixel calculation |
US6473089B1 (en) | 1998-03-02 | 2002-10-29 | Ati Technologies, Inc. | Method and apparatus for a video graphics circuit having parallel pixel processing |
US6259460B1 (en) | 1998-03-26 | 2001-07-10 | Silicon Graphics, Inc. | Method for efficient handling of texture cache misses by recirculation |
US6212617B1 (en) * | 1998-05-13 | 2001-04-03 | Microsoft Corporation | Parallel processing method and system using a lazy parallel data type to reduce inter-processor communication |
US6477687B1 (en) | 1998-06-01 | 2002-11-05 | Nvidia U.S. Investment Company | Method of embedding RAMS and other macrocells in the core of an integrated circuit chip |
US6636215B1 (en) | 1998-07-22 | 2003-10-21 | Nvidia Corporation | Hardware-assisted z-pyramid creation for host-based occlusion culling |
US6191800B1 (en) * | 1998-08-11 | 2001-02-20 | International Business Machines Corporation | Dynamic balancing of graphics workloads using a tiling strategy |
US6492987B1 (en) | 1998-08-27 | 2002-12-10 | Ati Technologies, Inc. | Method and apparatus for processing object elements that are being rendered |
US6292200B1 (en) | 1998-10-23 | 2001-09-18 | Silicon Graphics, Inc. | Apparatus and method for utilizing multiple rendering pipes for a single 3-D display |
JP4223609B2 (en) * | 1998-12-24 | 2009-02-12 | Ｈｏｙａ株式会社 | Endoscope device |
US6362825B1 (en) * | 1999-01-19 | 2002-03-26 | Hewlett-Packard Company | Real-time combination of adjacent identical primitive data sets in a graphics call sequence |
US6753878B1 (en) | 1999-03-08 | 2004-06-22 | Hewlett-Packard Development Company, L.P. | Parallel pipelined merge engines |
JP3169933B2 (en) * | 1999-03-16 | 2001-05-28 | 四国日本電気ソフトウェア株式会社 | Parallel drawing device |
US6288418B1 (en) | 1999-03-19 | 2001-09-11 | Nvidia Corporation | Multiuse input/output connector arrangement for graphics accelerator integrated circuit |
US6333744B1 (en) | 1999-03-22 | 2001-12-25 | Nvidia Corporation | Graphics pipeline including combiner stages |
DE19917092A1 (en) | 1999-04-15 | 2000-10-26 | Sp3D Chip Design Gmbh | Accelerated method for grid forming of graphic basic element in order beginning with graphic base element instruction data to produce pixel data for graphic base element |
US6990076B1 (en) * | 1999-05-18 | 2006-01-24 | Mcnamara Timothy G | Synchronous bi-directional data transfer having increased bandwidth and scan test features |
US6535525B1 (en) * | 1999-06-10 | 2003-03-18 | Unisys Corporation | Method of transmitting streams of video data, in multi-length frames, at a single average bit rate |
US6578068B1 (en) * | 1999-08-31 | 2003-06-10 | Accenture Llp | Load balancer in environment services patterns |
US6657635B1 (en) | 1999-09-03 | 2003-12-02 | Nvidia Corporation | Binning flush in graphics data processing |
US7002577B2 (en) | 1999-12-06 | 2006-02-21 | Nvidia Corporation | Clipping system and method for a single graphics semiconductor platform |
US6473086B1 (en) * | 1999-12-09 | 2002-10-29 | Ati International Srl | Method and apparatus for graphics processing using parallel graphics processors |
US6557065B1 (en) * | 1999-12-20 | 2003-04-29 | Intel Corporation | CPU expandability bus |
US6760031B1 (en) * | 1999-12-31 | 2004-07-06 | Intel Corporation | Upgrading an integrated graphics subsystem |
US7064783B2 (en) * | 1999-12-31 | 2006-06-20 | Stmicroelectronics, Inc. | Still picture format for subsequent picture stitching for forming a panoramic image |
WO2001069207A1 (en) * | 2000-03-16 | 2001-09-20 | Fuji Photo Film Co., Ltd. | Measuring method and instrument utilizing total reflection attenuation |
US6975319B1 (en) | 2000-03-24 | 2005-12-13 | Nvidia Corporation | System, method and article of manufacture for calculating a level of detail (LOD) during computer graphics processing |
US6831652B1 (en) | 2000-03-24 | 2004-12-14 | Ati International, Srl | Method and system for storing graphics data |
US6741243B2 (en) * | 2000-05-01 | 2004-05-25 | Broadcom Corporation | Method and system for reducing overflows in a computer graphics system |
US6789154B1 (en) | 2000-05-26 | 2004-09-07 | Ati International, Srl | Apparatus and method for transmitting data |
US6670958B1 (en) | 2000-05-26 | 2003-12-30 | Ati International, Srl | Method and apparatus for routing data to multiple graphics devices |
US6633296B1 (en) | 2000-05-26 | 2003-10-14 | Ati International Srl | Apparatus for providing data to a plurality of graphics processors and method thereof |
US6662257B1 (en) | 2000-05-26 | 2003-12-09 | Ati International Srl | Multiple device bridge apparatus and method thereof |
US6664963B1 (en) | 2000-05-31 | 2003-12-16 | Nvidia Corporation | System, method and computer program product for programmable shading using pixel shaders |
US6959110B1 (en) | 2000-08-17 | 2005-10-25 | Nvidia Corporation | Multi-mode texture compression algorithm |
US7116331B1 (en) | 2000-08-23 | 2006-10-03 | Intel Corporation | Memory controller hub interface |
US6842180B1 (en) * | 2000-09-20 | 2005-01-11 | Intel Corporation | Opportunistic sharing of graphics resources to enhance CPU performance in an integrated microprocessor |
US6502173B1 (en) | 2000-09-29 | 2002-12-31 | Ati Technologies, Inc. | System for accessing memory and method therefore |
US6828980B1 (en) | 2000-10-02 | 2004-12-07 | Nvidia Corporation | System, method and computer program product for z-texture mapping |
JP3580789B2 (en) * | 2000-10-10 | 2004-10-27 | 株式会社ソニー・コンピュータエンタテインメント | Data communication system and method, computer program, recording medium |
US6961057B1 (en) | 2000-10-12 | 2005-11-01 | Nvidia Corporation | Method and apparatus for managing and accessing depth data in a computer graphics system |
US6362997B1 (en) | 2000-10-16 | 2002-03-26 | Nvidia | Memory system for use on a circuit board in which the number of loads are minimized |
US6636212B1 (en) | 2000-11-14 | 2003-10-21 | Nvidia Corporation | Method and apparatus for determining visibility of groups of pixels |
US6535013B2 (en) * | 2000-12-28 | 2003-03-18 | Intel Corporation | Parameter variation probing technique |
US7358974B2 (en) | 2001-01-29 | 2008-04-15 | Silicon Graphics, Inc. | Method and system for minimizing an amount of data needed to test data against subarea boundaries in spatially composited digital video |
US7130316B2 (en) | 2001-04-11 | 2006-10-31 | Ati Technologies, Inc. | System for frame based audio synchronization and method thereof |
JP2002335597A (en) * | 2001-05-09 | 2002-11-22 | Citizen Electronics Co Ltd | Combination speaker |
US6664960B2 (en) | 2001-05-10 | 2003-12-16 | Ati Technologies Inc. | Apparatus for processing non-planar video graphics primitives and associated method of operation |
US7081971B2 (en) * | 2001-05-23 | 2006-07-25 | Pitney Bowes Inc. | System and method for printing on mailpieces using a fixed print head |
WO2002101497A2 (en) | 2001-06-08 | 2002-12-19 | Nvidia Corporation | System, method and computer program product for programmable fragment processing in a graphics pipeline |
JP2003030641A (en) * | 2001-07-19 | 2003-01-31 | Nec System Technologies Ltd | Plotting device, parallel plotting method therefor and parallel plotting program |
US6828987B2 (en) | 2001-08-07 | 2004-12-07 | Ati Technologies, Inc. | Method and apparatus for processing video and graphics data |
US6947047B1 (en) | 2001-09-20 | 2005-09-20 | Nvidia Corporation | Method and system for programmable pipelined graphics processing with branching instructions |
US6938176B1 (en) * | 2001-10-05 | 2005-08-30 | Nvidia Corporation | Method and apparatus for power management of graphics processors and subsystems that allow the subsystems to respond to accesses when subsystems are idle |
US6592923B2 (en) * | 2001-10-09 | 2003-07-15 | Recot, Inc. | System and method for molding a snack chip |
JP2003180876A (en) * | 2001-12-17 | 2003-07-02 | Bridgestone Sports Co Ltd | Two-piece golf ball |
US20030117971A1 (en) * | 2001-12-21 | 2003-06-26 | Celoxica Ltd. | System, method, and article of manufacture for profiling an executable hardware model using calls to profiling functions |
US6683614B2 (en) * | 2001-12-21 | 2004-01-27 | Hewlett-Packard Development Company, L.P. | System and method for automatically configuring graphics pipelines by tracking a region of interest in a computer graphical display system |
US6947865B1 (en) | 2002-02-15 | 2005-09-20 | Nvidia Corporation | Method and system for dynamic power supply voltage adjustment for a semiconductor integrated circuit device |
US6933943B2 (en) | 2002-02-27 | 2005-08-23 | Hewlett-Packard Development Company, L.P. | Distributed resource architecture and system |
US6700580B2 (en) | 2002-03-01 | 2004-03-02 | Hewlett-Packard Development Company, L.P. | System and method utilizing multiple pipelines to render graphical data |
US6853380B2 (en) | 2002-03-04 | 2005-02-08 | Hewlett-Packard Development Company, L.P. | Graphical display system and method |
US20030171907A1 (en) | 2002-03-06 | 2003-09-11 | Shay Gal-On | Methods and Apparatus for Optimizing Applications on Configurable Processors |
US6919896B2 (en) | 2002-03-11 | 2005-07-19 | Sony Computer Entertainment Inc. | System and method of optimizing graphics processing |
US7009605B2 (en) | 2002-03-20 | 2006-03-07 | Nvidia Corporation | System, method and computer program product for generating a shader program |
US20030212735A1 (en) | 2002-05-13 | 2003-11-13 | Nvidia Corporation | Method and apparatus for providing an integrated network of processors |
US6980209B1 (en) | 2002-06-14 | 2005-12-27 | Nvidia Corporation | Method and system for scalable, dataflow-based, programmable processing of graphics data |
US6812927B1 (en) | 2002-06-18 | 2004-11-02 | Nvidia Corporation | System and method for avoiding depth clears using a stencil buffer |
US6989152B1 (en) * | 2002-07-08 | 2006-01-24 | John Campbell | Compound for the amelioration of pseudofolliculitis |
US6797998B2 (en) | 2002-07-16 | 2004-09-28 | Nvidia Corporation | Multi-configuration GPU interface device |
US6825843B2 (en) | 2002-07-18 | 2004-11-30 | Nvidia Corporation | Method and apparatus for loop and branch instructions in a programmable graphics pipeline |
US6773086B2 (en) * | 2002-08-02 | 2004-08-10 | Hewlett-Packard Development Company, L.P. | Misalignment reduction of staggered fluid ejector assemblies along axis along which assemblies are positioned |
US6952206B1 (en) | 2002-08-12 | 2005-10-04 | Nvidia Corporation | Graphics application program interface system and method for accelerating graphics processing |
US6995787B2 (en) * | 2002-08-21 | 2006-02-07 | Adams Steven L | Sports projectile and camera apparatus |
US7324547B1 (en) * | 2002-12-13 | 2008-01-29 | Nvidia Corporation | Internet protocol (IP) router residing in a processor chipset |
US6885376B2 (en) * | 2002-12-30 | 2005-04-26 | Silicon Graphics, Inc. | System, method, and computer program product for near-real time load balancing across multiple rendering pipelines |
CA2514296A1 (en) | 2003-01-28 | 2004-08-19 | Lucid Information Technology Ltd. | Method and system for compositing three-dimensional graphics images using associative decision mechanism |
US7145565B2 (en) | 2003-02-27 | 2006-12-05 | Nvidia Corporation | Depth bounds testing |
US6911983B2 (en) | 2003-03-12 | 2005-06-28 | Nvidia Corporation | Double-buffering of pixel data using copy-on-write semantics |
US7129909B1 (en) | 2003-04-09 | 2006-10-31 | Nvidia Corporation | Method and system using compressed display mode list |
US6940515B1 (en) | 2003-04-10 | 2005-09-06 | Nvidia Corporation | User programmable primitive engine |
US7120816B2 (en) | 2003-04-17 | 2006-10-10 | Nvidia Corporation | Method for testing synchronization and connection status of a graphics processing unit module |
US7483031B2 (en) | 2003-04-17 | 2009-01-27 | Nvidia Corporation | Method for synchronizing graphics processing units |
US7119808B2 (en) | 2003-07-15 | 2006-10-10 | Alienware Labs Corp. | Multiple parallel processor computer graphics system |
US7525547B1 (en) * | 2003-08-12 | 2009-04-28 | Nvidia Corporation | Programming multiple chips from a command buffer to process multiple images |
US6956579B1 (en) | 2003-08-18 | 2005-10-18 | Nvidia Corporation | Private addressing in a multi-processor graphics processing system |
US7388581B1 (en) | 2003-08-28 | 2008-06-17 | Nvidia Corporation | Asynchronous conditional graphics rendering |
US7015914B1 (en) | 2003-12-10 | 2006-03-21 | Nvidia Corporation | Multiple data buffers for processing graphics data |
US7259606B2 (en) | 2004-01-27 | 2007-08-21 | Nvidia Corporation | Data sampling clock edge placement training for high speed GPU-memory interface |
US7483034B2 (en) * | 2004-02-25 | 2009-01-27 | Siemens Medical Solutions Usa, Inc. | System and method for GPU-based 3D nonrigid registration |
US7289125B2 (en) | 2004-02-27 | 2007-10-30 | Nvidia Corporation | Graphics device clustering with PCI-express |
US20050195186A1 (en) | 2004-03-02 | 2005-09-08 | Ati Technologies Inc. | Method and apparatus for object based visibility culling |
US20050275760A1 (en) | 2004-03-02 | 2005-12-15 | Nvidia Corporation | Modifying a rasterized surface, such as by trimming |
US7978194B2 (en) | 2004-03-02 | 2011-07-12 | Ati Technologies Ulc | Method and apparatus for hierarchical Z buffering and stenciling |
US7315912B2 (en) | 2004-04-01 | 2008-01-01 | Nvidia Corporation | Deadlock avoidance in a bus fabric |
US7336284B2 (en) | 2004-04-08 | 2008-02-26 | Ati Technologies Inc. | Two level cache memory architecture |
US7265759B2 (en) * | 2004-04-09 | 2007-09-04 | Nvidia Corporation | Field changeable rendering system for a computing device |
US20050237329A1 (en) | 2004-04-27 | 2005-10-27 | Nvidia Corporation | GPU rendering to system memory |
US7738045B2 (en) | 2004-05-03 | 2010-06-15 | Broadcom Corporation | Film-mode (3:2/2:2 Pulldown) detector, method and video device |
US7079156B1 (en) | 2004-05-14 | 2006-07-18 | Nvidia Corporation | Method and system for implementing multiple high precision and low precision interpolators for a graphics pipeline |
US7721118B1 (en) | 2004-09-27 | 2010-05-18 | Nvidia Corporation | Optimizing power and performance for multi-processor graphics processing |
US8066515B2 (en) | 2004-11-17 | 2011-11-29 | Nvidia Corporation | Multiple graphics adapter connection systems |
US7477256B1 (en) * | 2004-11-17 | 2009-01-13 | Nvidia Corporation | Connecting graphics adapters for scalable performance |
US7598958B1 (en) | 2004-11-17 | 2009-10-06 | Nvidia Corporation | Multi-chip graphics processing unit apparatus, system, and method |
US7545380B1 (en) | 2004-12-16 | 2009-06-09 | Nvidia Corporation | Sequencing of displayed images for alternate frame rendering in a multi-processor graphics system |
US7372465B1 (en) * | 2004-12-17 | 2008-05-13 | Nvidia Corporation | Scalable graphics processing for remote display |
US7089922B2 (en) * | 2004-12-23 | 2006-08-15 | Cummins, Incorporated | Apparatus, system, and method for minimizing NOx in exhaust gasses |
US7924281B2 (en) | 2005-03-09 | 2011-04-12 | Ati Technologies Ulc | System and method for determining illumination of a pixel by shadow planes |
US7796095B2 (en) | 2005-03-18 | 2010-09-14 | Ati Technologies Ulc | Display specific image processing in an integrated circuit |
US7568056B2 (en) | 2005-03-28 | 2009-07-28 | Nvidia Corporation | Host bus adapter that interfaces with host computer bus to multiple types of storage devices |
US7681187B2 (en) | 2005-03-31 | 2010-03-16 | Nvidia Corporation | Method and apparatus for register allocation in presence of hardware constraints |
US7616207B1 (en) | 2005-04-25 | 2009-11-10 | Nvidia Corporation | Graphics processing system including at least three bus devices |
US7817155B2 (en) * | 2005-05-24 | 2010-10-19 | Ati Technologies Inc. | Master/slave graphics adapter arrangement |
US20080143731A1 (en) * | 2005-05-24 | 2008-06-19 | Jeffrey Cheng | Video rendering across a high speed peripheral interconnect bus |
US20060282604A1 (en) | 2005-05-27 | 2006-12-14 | Ati Technologies, Inc. | Methods and apparatus for processing graphics data using multiple processing circuits |
US7539801B2 (en) | 2005-05-27 | 2009-05-26 | Ati Technologies Ulc | Computing device with flexibly configurable expansion slots, and method of operation |
US7325086B2 (en) * | 2005-12-15 | 2008-01-29 | Via Technologies, Inc. | Method and system for multiple GPU support |
US7728841B1 (en) * | 2005-12-19 | 2010-06-01 | Nvidia Corporation | Coherent shader output for multiple targets |
US9349219B2 (en) * | 2006-01-09 | 2016-05-24 | Autodesk, Inc. | 3D scene object switching system |
US7768517B2 (en) | 2006-02-21 | 2010-08-03 | Nvidia Corporation | Asymmetric multi-GPU processing |
US7773090B1 (en) | 2006-06-13 | 2010-08-10 | Nvidia Corporation | Kernel mode graphics driver for dual-core computer system |
US8284204B2 (en) * | 2006-06-30 | 2012-10-09 | Nokia Corporation | Apparatus, method and a computer program product for providing a unified graphics pipeline for stereoscopic rendering |
US7941791B2 (en) * | 2007-04-13 | 2011-05-10 | Perry Wang | Programming environment for heterogeneous processor resource integration |
US8736617B2 (en) | 2008-08-04 | 2014-05-27 | Nvidia Corporation | Hybrid graphic display |
-
2007
- 2007-09-18 US US11/901,745 patent/US20080079737A1/en not_active Abandoned
- 2007-09-18 US US11/901,713 patent/US20080068389A1/en not_active Abandoned
- 2007-09-18 US US11/901,715 patent/US20080074431A1/en not_active Abandoned
- 2007-09-18 US US11/901,733 patent/US20080094404A1/en not_active Abandoned
- 2007-09-18 US US11/901,727 patent/US20080094402A1/en not_active Abandoned
- 2007-09-18 US US11/901,692 patent/US7777748B2/en active Active
- 2007-09-18 US US11/901,716 patent/US20080246772A1/en not_active Abandoned
- 2007-09-18 US US11/901,714 patent/US20080074429A1/en not_active Abandoned
- 2007-09-18 US US11/901,697 patent/US20080074428A1/en not_active Abandoned
- 2007-09-18 US US11/901,696 patent/US20080088631A1/en not_active Abandoned
- 2007-09-20 US US11/903,203 patent/US20080316216A1/en not_active Abandoned
- 2007-09-20 US US11/903,202 patent/US20080198167A1/en not_active Abandoned
- 2007-09-25 US US11/904,042 patent/US20080084422A1/en not_active Abandoned
- 2007-09-25 US US11/904,041 patent/US20080084421A1/en not_active Abandoned
- 2007-09-25 US US11/904,043 patent/US20080088632A1/en not_active Abandoned
- 2007-09-25 US US11/904,039 patent/US20080084419A1/en not_active Abandoned
- 2007-09-25 US US11/904,022 patent/US20080084418A1/en not_active Abandoned
- 2007-09-25 US US11/904,040 patent/US7940274B2/en active Active
- 2007-09-26 US US11/904,294 patent/US20080084423A1/en not_active Abandoned
- 2007-09-26 US US11/904,300 patent/US7944450B2/en active Active
- 2007-09-26 US US11/904,317 patent/US8125487B2/en active Active
Patent Citations (99)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5754866A (en) * | 1995-05-08 | 1998-05-19 | Nvidia Corporation | Delayed interrupts with a FIFO in an improved input/output architecture |
US5758182A (en) * | 1995-05-15 | 1998-05-26 | Nvidia Corporation | DMA controller translates virtual I/O device address received directly from application program command to physical i/o device address of I/O device on device bus |
US5740464A (en) * | 1995-05-15 | 1998-04-14 | Nvidia Corporation | Architecture for providing input/output operations in a computer system |
US6169553B1 (en) * | 1997-07-02 | 2001-01-02 | Ati Technologies, Inc. | Method and apparatus for rendering a three-dimensional scene having shadowing |
US6201545B1 (en) * | 1997-09-23 | 2001-03-13 | Ati Technologies, Inc. | Method and apparatus for generating sub pixel masks in a three dimensional graphic processing system |
US6856320B1 (en) * | 1997-11-25 | 2005-02-15 | Nvidia U.S. Investment Company | Demand-based memory system for graphics applications |
US7170515B1 (en) * | 1997-11-25 | 2007-01-30 | Nvidia Corporation | Rendering pipeline |
US6337686B2 (en) * | 1998-01-07 | 2002-01-08 | Ati Technologies Inc. | Method and apparatus for line anti-aliasing |
US7038692B1 (en) * | 1998-04-07 | 2006-05-02 | Nvidia Corporation | Method and apparatus for providing a vertex cache |
US6691180B2 (en) * | 1998-04-17 | 2004-02-10 | Nvidia Corporation | Apparatus for accelerating the rendering of images |
US6184908B1 (en) * | 1998-04-27 | 2001-02-06 | Ati Technologies, Inc. | Method and apparatus for co-processing video graphics data |
US6894689B1 (en) * | 1998-07-22 | 2005-05-17 | Nvidia Corporation | Occlusion culling method and apparatus for graphics systems |
US7023437B1 (en) * | 1998-07-22 | 2006-04-04 | Nvidia Corporation | System and method for accelerating graphics processing using a post-geometry data stream during multiple-pass rendering |
US7170513B1 (en) * | 1998-07-22 | 2007-01-30 | Nvidia Corporation | System and method for display list occlusion branching |
US6415345B1 (en) * | 1998-08-03 | 2002-07-02 | Ati Technologies | Bus mastering interface control system for transferring multistream data over a host bus |
US6188412B1 (en) * | 1998-08-28 | 2001-02-13 | Ati Technologies, Inc. | Method and apparatus for performing setup operations in a video graphics system |
US6535209B1 (en) * | 1999-03-17 | 2003-03-18 | Nvidia Us Investments Co. | Data stream splitting and storage in graphics data processing |
US6181352B1 (en) * | 1999-03-22 | 2001-01-30 | Nvidia Corporation | Graphics pipeline selectively providing multiple pixels or multiple textures |
US6577320B1 (en) * | 1999-03-22 | 2003-06-10 | Nvidia Corporation | Method and apparatus for processing multiple types of pixel component representations including processes of premultiplication, postmultiplication, and colorkeying/chromakeying |
US6442656B1 (en) * | 1999-08-18 | 2002-08-27 | Ati Technologies Srl | Method and apparatus for interfacing memory with a bus |
US6352479B1 (en) * | 1999-08-31 | 2002-03-05 | Nvidia U.S. Investment Company | Interactive gaming server and online community forum |
US6778176B2 (en) * | 1999-12-06 | 2004-08-17 | Nvidia Corporation | Sequencer system and method for sequencing graphics processing |
US7064763B2 (en) * | 1999-12-06 | 2006-06-20 | Nvidia Corporation | Single semiconductor graphics platform |
US20030103054A1 (en) * | 1999-12-06 | 2003-06-05 | Nvidia Corporation | Integrated graphics processing unit with antialiasing |
US20030034975A1 (en) * | 1999-12-06 | 2003-02-20 | Nvidia Corporation | Lighting system and method for a graphics processor |
US6577309B2 (en) * | 1999-12-06 | 2003-06-10 | Nvidia Corporation | System and method for a graphics processing framework embodied utilizing a single semiconductor platform |
US20030112246A1 (en) * | 1999-12-06 | 2003-06-19 | Nvidia Corporation | Blending system and method in an integrated computer graphics pipeline |
US20030112245A1 (en) * | 1999-12-06 | 2003-06-19 | Nvidia Corporation | Single semiconductor graphics platform |
US6992667B2 (en) * | 1999-12-06 | 2006-01-31 | Nvidia Corporation | Single semiconductor graphics platform system and method with skinning, swizzling and masking capabilities |
US20030038808A1 (en) * | 1999-12-06 | 2003-02-27 | Nvidia Corporation | Method, apparatus and article of manufacture for a sequencer in a transform/lighting module capable of processing multiple independent execution threads |
US6870540B1 (en) * | 1999-12-06 | 2005-03-22 | Nvidia Corporation | System, method and computer program product for a programmable pixel processing model with instruction set |
US20030020720A1 (en) * | 1999-12-06 | 2003-01-30 | Nvidia Corporation | Method, apparatus and article of manufacture for a sequencer in a transform/lighting module capable of processing multiple independent execution threads |
US7002588B1 (en) * | 1999-12-06 | 2006-02-21 | Nvidia Corporation | System, method and computer program product for branching during programmable vertex processing |
US6734874B2 (en) * | 1999-12-06 | 2004-05-11 | Nvidia Corporation | Graphics processing unit with transform module capable of handling scalars and vectors |
US6725457B1 (en) * | 2000-05-17 | 2004-04-20 | Nvidia Corporation | Semaphore enhancement to improve system performance |
US6728820B1 (en) * | 2000-05-26 | 2004-04-27 | Ati International Srl | Method of configuring, controlling, and accessing a bridge and apparatus therefor |
US6724394B1 (en) * | 2000-05-31 | 2004-04-20 | Nvidia Corporation | Programmable pixel shading architecture |
US6690372B2 (en) * | 2000-05-31 | 2004-02-10 | Nvidia Corporation | System, method and article of manufacture for shadow mapping |
US7068272B1 (en) * | 2000-05-31 | 2006-06-27 | Nvidia Corporation | System, method and article of manufacture for Z-value and stencil culling prior to rendering in a computer graphics processing pipeline |
US6734861B1 (en) * | 2000-05-31 | 2004-05-11 | Nvidia Corporation | System, method and article of manufacture for an interlock module in a computer graphics processing pipeline |
US6593923B1 (en) * | 2000-05-31 | 2003-07-15 | Nvidia Corporation | System, method and article of manufacture for shadow mapping |
US6532013B1 (en) * | 2000-05-31 | 2003-03-11 | Nvidia Corporation | System, method and article of manufacture for pixel shaders for programmable shading |
US20020085007A1 (en) * | 2000-06-29 | 2002-07-04 | Sun Microsystems, Inc. | Graphics system configured to parallel-process graphics data using multiple pipelines |
US20020015055A1 (en) * | 2000-07-18 | 2002-02-07 | Silicon Graphics, Inc. | Method and system for presenting three-dimensional computer graphics images using multiple graphics processing units |
US6909595B2 (en) * | 2000-08-11 | 2005-06-21 | Epcos Ag | Capacitor winding and a capacitor having the capacitor winding |
US6532525B1 (en) * | 2000-09-29 | 2003-03-11 | Ati Technologies, Inc. | Method and apparatus for accessing memory |
US6731298B1 (en) * | 2000-10-02 | 2004-05-04 | Nvidia Corporation | System, method and article of manufacture for z-texture mapping |
US6778181B1 (en) * | 2000-12-07 | 2004-08-17 | Nvidia Corporation | Graphics processing system having a virtual texturing array |
US7027972B1 (en) * | 2001-01-24 | 2006-04-11 | Ati Technologies, Inc. | System for collecting and analyzing graphics data and method thereof |
US20020118308A1 (en) * | 2001-02-27 | 2002-08-29 | Ati Technologies, Inc. | Integrated single and dual television tuner having improved fine tuning |
US6542971B1 (en) * | 2001-04-23 | 2003-04-01 | Nvidia Corporation | Memory access system and method employing an auxiliary buffer |
US6700583B2 (en) * | 2001-05-14 | 2004-03-02 | Ati Technologies, Inc. | Configurable buffer for multipass applications |
US6982718B2 (en) * | 2001-06-08 | 2006-01-03 | Nvidia Corporation | System, method and computer program product for programmable fragment processing in a graphics pipeline |
US6894687B1 (en) * | 2001-06-08 | 2005-05-17 | Nvidia Corporation | System, method and computer program product for vertex attribute aliasing in a graphics pipeline |
US6778189B1 (en) * | 2001-08-24 | 2004-08-17 | Nvidia Corporation | Two-sided stencil testing system and method |
US6989840B1 (en) * | 2001-08-31 | 2006-01-24 | Nvidia Corporation | Order-independent transparency rendering system and method |
US6744433B1 (en) * | 2001-08-31 | 2004-06-01 | Nvidia Corporation | System and method for using and collecting information from a plurality of depth layers |
US6704025B1 (en) * | 2001-08-31 | 2004-03-09 | Nvidia Corporation | System and method for dual-depth shadow-mapping |
US20030080959A1 (en) * | 2001-10-29 | 2003-05-01 | Ati Technologies, Inc. | System, Method, and apparatus for early culling |
US20030151606A1 (en) * | 2001-10-29 | 2003-08-14 | Ati Technologies Inc. | System, method, and apparatus for multi-level hierarchical Z buffering |
US6999076B2 (en) * | 2001-10-29 | 2006-02-14 | Ati Technologies, Inc. | System, method, and apparatus for early culling |
US6677953B1 (en) * | 2001-11-08 | 2004-01-13 | Nvidia Corporation | Hardware viewport system and method for use in a graphics pipeline |
US20030128197A1 (en) * | 2002-01-04 | 2003-07-10 | Ati Technologies, Inc. | Portable device for providing dual display and method thereof |
US6774895B1 (en) * | 2002-02-01 | 2004-08-10 | Nvidia Corporation | System and method for depth clamping in a hardware graphics pipeline |
US7224359B1 (en) * | 2002-02-01 | 2007-05-29 | Nvidia Corporation | Depth clamping system and method in a hardware graphics pipeline |
US7080194B1 (en) * | 2002-02-12 | 2006-07-18 | Nvidia Corporation | Method and system for memory access arbitration for minimizing read/write turnaround penalties |
US20040012600A1 (en) * | 2002-03-22 | 2004-01-22 | Deering Michael F. | Scalable high performance 3d graphics |
US20040153778A1 (en) * | 2002-06-12 | 2004-08-05 | Ati Technologies, Inc. | Method, system and software for configuring a graphics processing communication mode |
US6876362B1 (en) * | 2002-07-10 | 2005-04-05 | Nvidia Corporation | Omnidirectional shadow texture mapping |
US7081895B2 (en) * | 2002-07-18 | 2006-07-25 | Nvidia Corporation | Systems and methods of multi-pass data processing |
US6864893B2 (en) * | 2002-07-19 | 2005-03-08 | Nvidia Corporation | Method and apparatus for modifying depth values using pixel programs |
US20040159488A1 (en) * | 2002-07-25 | 2004-08-19 | Hitachi, Ltd. | Torque sensor and motor-driven power steering apparatus using thereof |
US20040036159A1 (en) * | 2002-08-23 | 2004-02-26 | Ati Technologies, Inc. | Integrated circuit having memory disposed thereon and method of making thereof |
US6779069B1 (en) * | 2002-09-04 | 2004-08-17 | Nvidia Corporation | Computer system with source-synchronous digital link |
US6900810B1 (en) * | 2003-04-10 | 2005-05-31 | Nvidia Corporation | User programmable geometry engine |
US7068278B1 (en) * | 2003-04-17 | 2006-06-27 | Nvidia Corporation | Synchronized graphics processing units |
US7038678B2 (en) * | 2003-05-21 | 2006-05-02 | Nvidia Corporation | Dependent texture shadow antialiasing |
US7038685B1 (en) * | 2003-06-30 | 2006-05-02 | Nvidia Corporation | Programmable graphics processor for multithreaded execution of programs |
US6995767B1 (en) * | 2003-07-31 | 2006-02-07 | Nvidia Corporation | Trilinear optimization for texture filtering |
US7015915B1 (en) * | 2003-08-12 | 2006-03-21 | Nvidia Corporation | Programming multiple chips from a command buffer |
US20060114260A1 (en) * | 2003-08-12 | 2006-06-01 | Nvidia Corporation | Programming multiple chips from a command buffer |
US20050041031A1 (en) * | 2003-08-18 | 2005-02-24 | Nvidia Corporation | Adaptive load balancing in a multi-processor graphics processing system |
US7075541B2 (en) * | 2003-08-18 | 2006-07-11 | Nvidia Corporation | Adaptive load balancing in a multi-processor graphics processing system |
US20050081115A1 (en) * | 2003-09-26 | 2005-04-14 | Ati Technologies, Inc. | Method and apparatus for monitoring and resetting a co-processor |
US20050122330A1 (en) * | 2003-11-14 | 2005-06-09 | Microsoft Corporation | Systems and methods for downloading algorithmic elements to a coprocessor and corresponding techniques |
US7053901B2 (en) * | 2003-12-11 | 2006-05-30 | Nvidia Corporation | System and method for accelerating a special purpose processor |
US7248261B1 (en) * | 2003-12-15 | 2007-07-24 | Nvidia Corporation | Method and apparatus to accelerate rendering of shadow effects for computer-generated images |
US20050166207A1 (en) * | 2003-12-26 | 2005-07-28 | National University Corporation Utsunomiya University | Self-optimizing computer system |
US20050162437A1 (en) * | 2004-01-23 | 2005-07-28 | Ati Technologies, Inc. | Method and apparatus for graphics processing using state and shader management |
US20060119607A1 (en) * | 2004-02-27 | 2006-06-08 | Nvidia Corporation | Register based queuing for texture requests |
US6985152B2 (en) * | 2004-04-23 | 2006-01-10 | Nvidia Corporation | Point-to-point bus bridging without a bridge controller |
US20060028478A1 (en) * | 2004-04-23 | 2006-02-09 | Nvidia Corporation | Point-to-point bus bridging without a bridge controller |
US20060005178A1 (en) * | 2004-07-02 | 2006-01-05 | Nvidia Corporation | Optimized chaining of vertex and fragment programs |
US20060055695A1 (en) * | 2004-09-13 | 2006-03-16 | Nvidia Corporation | Increased scalability in the fragment shading pipeline |
US20060059494A1 (en) * | 2004-09-16 | 2006-03-16 | Nvidia Corporation | Load balancing |
US20060101218A1 (en) * | 2004-11-11 | 2006-05-11 | Nvidia Corporation | Memory controller-adaptive 1T/2T timing control |
US20060120376A1 (en) * | 2004-12-06 | 2006-06-08 | Nvidia Corporation | Method and apparatus for providing peer-to-peer data transfer within a computing environment |
US20060123142A1 (en) * | 2004-12-06 | 2006-06-08 | Nvidia Corporation | Method and apparatus for providing peer-to-peer data transfer within a computing environment |
US20060156399A1 (en) * | 2004-12-30 | 2006-07-13 | Parmar Pankaj N | System and method for implementing network security using a sequestered partition |
Cited By (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20100201691A1 (en) * | 2009-02-12 | 2010-08-12 | Microsoft Corporation | Shader-based finite state machine frame detection |
US8237720B2 (en) | 2009-02-12 | 2012-08-07 | Microsoft Corporation | Shader-based finite state machine frame detection |
US20120133667A1 (en) * | 2010-11-30 | 2012-05-31 | Autodesk, Inc. | Method and apparatus for designing, stylizing, and supplementing an image/scene |
US11074453B2 (en) | 2018-01-31 | 2021-07-27 | Hewlett Packard Enterprise Development Lp | Video active region batching |
Also Published As
Publication number | Publication date |
---|---|
US8125487B2 (en) | 2012-02-28 |
US20080084418A1 (en) | 2008-04-10 |
US20080246772A1 (en) | 2008-10-09 |
US20080074428A1 (en) | 2008-03-27 |
US20080084422A1 (en) | 2008-04-10 |
US20080068389A1 (en) | 2008-03-20 |
US20080084421A1 (en) | 2008-04-10 |
US20080316216A1 (en) | 2008-12-25 |
US20080088630A1 (en) | 2008-04-17 |
US20080100630A1 (en) | 2008-05-01 |
US20080100629A1 (en) | 2008-05-01 |
US20080094402A1 (en) | 2008-04-24 |
US7940274B2 (en) | 2011-05-10 |
US20080198167A1 (en) | 2008-08-21 |
US20080088632A1 (en) | 2008-04-17 |
US20080094404A1 (en) | 2008-04-24 |
US20080079737A1 (en) | 2008-04-03 |
US20080084423A1 (en) | 2008-04-10 |
US7777748B2 (en) | 2010-08-17 |
US20080084420A1 (en) | 2008-04-10 |
US20080074431A1 (en) | 2008-03-27 |
US20080074429A1 (en) | 2008-03-27 |
US20080084419A1 (en) | 2008-04-10 |
US7944450B2 (en) | 2011-05-17 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US9584592B2 (en) | Internet-based graphics application profile management system for updating graphic application profiles stored within the multi-GPU graphics rendering subsystems of client machines running graphics-based applications | |
US7777748B2 (en) | PC-level computing system with a multi-mode parallel graphics rendering subsystem employing an automatic mode controller, responsive to performance data collected during the run-time of graphics applications | |
US20080094403A1 (en) | Computing system capable of parallelizing the operation graphics processing units (GPUs) supported on a CPU/GPU fusion-architecture chip and one or more external graphics cards, employing a software-implemented multi-mode parallel graphics rendering subsystem | |
US8085273B2 (en) | Multi-mode parallel graphics rendering system employing real-time automatic scene profiling and mode control | |
US20080129747A1 (en) | Multi-mode parallel graphics rendering system employing real-time automatic scene profiling and mode control | |
US20070291040A1 (en) | Multi-mode parallel graphics rendering system supporting dynamic profiling of graphics-based applications and automatic control of parallel modes of operation | |
US7796130B2 (en) | PC-based computing system employing multiple graphics processing units (GPUS) interfaced with the central processing unit (CPU) using a PC bus and a hardware hub, and parallelized according to the object division mode of parallel operation | |
US8497865B2 (en) | Parallel graphics system employing multiple graphics processing pipelines with multiple graphics processing units (GPUS) and supporting an object division mode of parallel graphics processing using programmable pixel or vertex processing resources provided with the GPUS | |
WO2008004135A9 (en) | Multi-mode parallel graphics rendering system employing real-time automatic scene profiling and mode control |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: LUCID INFORMATION TECHNOLOGY, LTD., ISRAELFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:BAKALASH, REUVEN;LEVIATHAN, YANIV;REEL/FRAME:020347/0529Effective date: 20071115 |
|
STCB | Information on status: application discontinuation |
Free format text: EXPRESSLY ABANDONED -- DURING EXAMINATION |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:LUCIDLOGIX TECHNOLOGY LTD.;REEL/FRAME:046361/0169Effective date: 20180131 |