WO2017131908A1 - Dynamic reference motion vector coding mode - Google Patents
Dynamic reference motion vector coding mode Download PDFInfo
- Publication number
- WO2017131908A1 WO2017131908A1 PCT/US2016/068472 US2016068472W WO2017131908A1 WO 2017131908 A1 WO2017131908 A1 WO 2017131908A1 US 2016068472 W US2016068472 W US 2016068472W WO 2017131908 A1 WO2017131908 A1 WO 2017131908A1
- Authority
- WO
- WIPO (PCT)
- Prior art keywords
- motion vector
- frame
- block
- current block
- inter
- Prior art date
Links
Classifications
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/60—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using transform coding
- H04N19/61—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using transform coding in combination with predictive coding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/513—Processing of motion vectors
- H04N19/517—Processing of motion vectors by encoding
- H04N19/52—Processing of motion vectors by encoding by predictive encoding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/103—Selection of coding mode or of prediction mode
- H04N19/109—Selection of coding mode or of prediction mode among a plurality of temporal predictive coding modes
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/134—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or criterion affecting or controlling the adaptive coding
- H04N19/136—Incoming video signal characteristics or properties
- H04N19/137—Motion inside a coding unit, e.g. average field, frame or block difference
- H04N19/139—Analysis of motion vectors, e.g. their magnitude, direction, variance or reliability
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/169—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding
- H04N19/17—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object
- H04N19/172—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the coding unit, i.e. the structural portion or semantic portion of the video signal being the object or the subject of the adaptive coding the unit being an image region, e.g. an object the region being a picture, frame or field
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/513—Processing of motion vectors
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/503—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving temporal prediction
- H04N19/51—Motion estimation or motion compensation
- H04N19/573—Motion compensation with multiple frame prediction using two or more reference frames in a given prediction direction
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/80—Details of filtering operations specially adapted for video compression, e.g. for pixel interpolation
- H04N19/82—Details of filtering operations specially adapted for video compression, e.g. for pixel interpolation involving filtering within a prediction loop
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/85—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using pre-processing or post-processing specially adapted for video compression
- H04N19/86—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using pre-processing or post-processing specially adapted for video compression involving reduction of coding artifacts, e.g. of blockiness
Definitions
- Digital video streams may represent video using a sequence of frames or still images.
- Digital video can be used for various applications including, for example, video conferencing, high definition video entertainment, video advertisements, or sharing of user- generated videos.
- a digital video stream can contain a large amount of data and consume a significant amount of computing or communication resources of a computing device for processing, transmission or storage of the video data.
- Various approaches have been proposed to reduce the amount of data in video streams, including compression and other encoding techniques.
- This disclosure relates generally to encoding and decoding video data and more particularly relates to video coding using reference motion vectors.
- a method for decoding a video stream includes identifying, for a current block, a reference frame used to encode the current block within a current frame, creating a reference motion vector candidate list for the reference frame using reference blocks, ranking each motion vector within the reference motion vector candidate list by a distance from the current block to a reference block providing the motion vector, and by a popularity value of the motion vector that indicates a level of use of the motion vector by the reference block that indicates a level of use of the motion vector by the reference blocks, assigning the motion vectors to a plurality of inter- prediction modes based on the ranking, selecting an inter-prediction mode for decoding the current block, and decoding the current block using the inter-prediction mode.
- the reference blocks can including spatially adjacent blocks of the current frame, a collocated block within a previous frame, and spatially adjacent blocks of the collocated block within the previous frame, or other reference blocks.
- a corresponding apparatus for decoding a video stream is also provided, for example an apparatus including a processor and a memory, the memory storing instructions that cause the processor to perform the method above.
- a method for encoding a video stream include identifying, for each of a plurality of reference frames, candidate motion vectors for encoding a current block within a current frame using reference blocks, ranking the candidate motion vectors within a reference motion vector candidate list for a reference frame by a distance from the current block of a respective reference block providing a respective candidate motion vector, and by a popularity value of the motion vector that indicates a level of use of the motion vector by the reference blocks, assigning the motion vectors to a plurality of inter-prediction modes based on the ranking, selecting an inter- prediction mode for encoding the current block, and encoding the current block using the inter-prediction mode.
- a corresponding apparatus for encoding a video stream is also provided, for example an apparatus including a processor and a memory, the memory storing instructions that cause the processor to perform the method above. Also provided are one or more computer readable media providing computer program code arranged to put into effect the encoding and/or decoding methods and apparatus described herein when executed on suitable computer apparatus.
- FIG. 1 is a schematic of a video encoding and decoding system.
- FIG. 2 is a block diagram of an example of a computing device that can implement a transmitting station or a receiving station.
- FIG. 3 is a diagram of a video stream to be encoded and subsequently decoded.
- FIG. 4 is a block diagram of a video compression system according to an aspect of the teachings herein.
- FIG. 5 is a block diagram of a video decompression system according to another aspect of the teachings herein.
- FIG. 6 is a flowchart diagram of a process for encoding a video stream using reference motion vectors in accordance with an implementation of this disclosure.
- FIGS. 7 A and 7B are diagrams of a sequence of frames used to explain the identification of candidate motion vectors within the process of FIG. 6.
- FIG. 8 is a flowchart diagram of a process for decoding an encoded video stream using reference motion vectors in accordance with implementations of this disclosure.
- Compression schemes related to coding video streams may include breaking each image into blocks and generating a digital video output bitstream using one or more techniques to limit the information included in the output.
- a received bitstream can be decoded to re-create the blocks and the source images from the limited information.
- Encoding a video stream, or a portion thereof, such as a frame or a block can include using temporal and spatial similarities in the video stream to improve coding efficiency.
- a current block of a video stream may be encoded based on a previously encoded block in the video stream by predicting motion and color information for the current block based on the previously encoded block and identifying a difference (residual) between the predicted values and the current block. In this way, only the residual and parameters used to generate it need be added to the bitstream instead of including the entirety of the current block.
- This technique may be referred to as inter prediction.
- One of the parameters in inter prediction is a motion vector that represents the spatial displacement of the previously coded block relative to the current block.
- the motion vector can be identified using a method of motion estimation, such as a motion search.
- motion search a portion of a reference frame can be translated to a succession of locations to form a prediction block that can be subtracted from a portion of a current frame to form a series of residuals.
- the X and Y translations corresponding to the location having the smallest residual can be selected as the motion vector.
- Bits representing the motion vector can be included in the encoded bitstream to permit a decoder to reproduce the prediction block and decode the portion of the encoded video bitstream associated with the motion vector.
- a motion vector can be differentially encoded using a reference motion vector, i.e., only the difference between the motion vector and the reference motion vector is encoded.
- the reference motion vector can be selected from previously used motion vectors in the video stream, for example, the last non-zero motion vector from neighboring blocks. Selecting a previously used motion vector to encode a current motion vector can further reduce the number of bits included in the encoded video bitstream and thereby reduce transmission and storage bandwidth requirements.
- Motion vector referencing modes allow a coding block to infer motion information from previously coded neighboring blocks.
- the reference motion vector candidate list can be constructed according to the distance between the reference block and the current block being encoded. However, ranking solely according to the block distance ignores that a motion vector may be used by multiple blocks. How many pixels in a reference area are using the motion vector may indicate the likelihood that the motion vector is an effective motion vector for the current block.
- neighboring blocks may be used to construct a reference motion vector candidate list.
- previously coded blocks are used. When coding in raster scan order, this limits the neighboring blocks to those to the left and above the current block to the extent they are available.
- the collocated block from the previous frame also called the last frame
- the collocated block is a block located in the last frame having the same pixel location as the current block, so potentially useful motion information from the right and bottom of the current block is still omitted.
- the reference motion vector candidate list there may be a fixed number of motion vector referencing modes, such as two.
- the use of a fixed number of reference modes can be inefficient. For example, if the reference motion vector candidate list has less than the fixed number of motion vectors, zero motion vectors may be need to pad the modes without a motion vector. In other cases, the reference motion vector candidate list may have more than the fixed number of motion vectors.
- the omitted motion vectors may be better candidates than those kept— that is, an omitted motion vector may result in a better rate and/or less distortion in coding the current block.
- compression performance may be improved by employing an efficient reference motion vector ranking system, followed by a dynamic motion vector referencing mode that fully accounts for the available motion vector candidate list.
- reference motion vector candidates for blocks with a single reference frame may be ranked according to both relative distance from the current block and the coverage area (e.g., the use of the motion vector).
- the candidate motion vectors from reference blocks that share the same reference frame combination may be ranked with a higher priority. Ranked below this are, optionally, combinations of motion vectors from neighboring blocks with a single reference frame.
- motion information associated with blocks below and to the right of the collocated block may be considered so as to capture those directions of movement.
- the dynamic motion vector referencing mode may use a number of modes that is dependent on the size of reference motion vector candidate list so that the chance of losing potentially valuable reference information is reduced.
- a reference motion vector may be selected from candidate motion vectors based on the distance between the reference block and the current block and the popularity of the reference motion vector.
- the distance between the reference block and the current block can be based on the spatial displacement between the pixels in the previously coded block and corresponding collocated pixels in the current block, measured in the unit of pixels.
- the popularity of the motion vector can be based on the amount of previously coded pixels that use the motion vector. The more previously coded pixels that use the motion vector, the higher the probability of the motion vector.
- the popularity value is the number of previously coded pixels that use the motion vector.
- the popularity value is a percentage of previously coded pixels within an area that use the motion vector.
- a candidate motion vector used in a reference block near the current block may closely resemble the actual motion vector for the current block.
- a candidate motion vector that is used by the most amount of pixels in a reference block near the current block would further resemble the actual motion vector for the current block.
- the motion vector of the candidate motion vectors with the highest popularity used in a nearby reference block may be selected as the reference motion vector for the actual motion vector of the current block. Fewer bits can be used to code the actual motion vector by coding the small difference in motion vectors, thus improving the overall coding efficiency. Other ways in which the selected motion vector may be used are discussed hereinafter.
- the candidate motion vectors may be limited to spatial-temporal neighboring motion vectors. That is, the pool of candidate motion vectors may be selected from regions neighboring regions of the current block. In some video coding schemes, particularly those where video frames are encoded out of order, it is desirable to include in the pool of candidate motion vectors motion information from video frames in the distant past or future. Encoding video frames can out of order may occur, for example, in the coding of so-called "alternate reference frames" that are not temporally neighboring to the frames coded immediately before or after them.
- An alternate reference frame may be a synthesized frame that does not occur in the input video stream or is a duplicate frame to one in the input video stream that is used for prediction and is generally not displayed following decoding.
- Such a frame can resemble a video frame in the non-adjacent future.
- Another example in which out of order encoding may occur is through the use of a so-called “golden reference frame,” which is a reconstructed video frame that may or may not be neighboring to a current video frame and is stored in memory for use as a reference frame until replaced, e.g., by a new golden reference frame.
- alternate reference frames and golden reference frames may be used to infer motion vector candidates for a block of a frame of video data.
- alternate reference frames and golden reference frames also called alternate frames and golden frames
- alternate frames and golden frames may be used to infer motion vector candidates for a block of a frame of video data.
- Other details are described herein after first describing an environment in which the disclosure may be implemented.
- FIG. 1 is a schematic of a video encoding and decoding system 100.
- transmitting station 102 can be, for example, a computer having an internal configuration of hardware such as that described in FIG. 2. However, other implementations of the transmitting station 102 are possible. For example, the processing of the transmitting station 102 can be distributed among multiple devices.
- a network 104 can connect the transmitting station 102 and a receiving station 106 for encoding and decoding of the video stream.
- the video stream can be encoded in the transmitting station 102 and the encoded video stream can be decoded in the receiving station 106.
- the network 104 can be, for example, the Internet.
- the network 104 can also be a local area network (LAN), wide area network (WAN), virtual private network (VPN), cellular telephone network or any other means of transferring the video stream from the transmitting station 102 to, in this example, the receiving station 106.
- the receiving station 106 in one example, can be a computer having an internal configuration of hardware such as that described in FIG. 2. However, other implementations of the receiving station 106 are possible. For example, the processing of the receiving station 106 can be distributed among multiple devices.
- a video stream can be encoded and then stored for transmission at a later time to the receiving station 106 or any other device having memory.
- the receiving station 106 receives (e.g., via the network 104, a computer bus, and/or some communication pathway) the encoded video stream and stores the video stream for later decoding.
- a real-time transport protocol RTP
- a transport protocol other than RTP may be used, e.g., a Hypertext Transfer Protocol (HTTP)- based video streaming protocol.
- HTTP Hypertext Transfer Protocol
- the transmitting station 102 and/or the receiving station 106 may include the ability to both encode and decode a video stream as described below.
- the receiving station 106 could be a video conference participant who receives an encoded video bitstream from a video conference server (e.g., the transmitting station 102) to decode and view and further encodes and transmits its own video bitstream to the video conference server for decoding and viewing by other participants.
- FIG. 2 is a block diagram of an example of a computing device 200 that can implement a transmitting station or a receiving station.
- the computing device 200 can implement one or both of the transmitting station 102 and the receiving station 106 of FIG. 1.
- the computing device 200 can be in the form of a computing system including multiple computing devices, or in the form of a single computing device, for example, a mobile phone, a tablet computer, a laptop computer, a notebook computer, a desktop computer, and the like.
- a CPU 202 in the computing device 200 can be a central processing unit.
- the CPU 202 can be any other type of device, or multiple devices, capable of manipulating or processing information now-existing or hereafter developed.
- the disclosed implementations can be practiced with a single processor as shown, e.g., the CPU 202, advantages in speed and efficiency can be achieved using more than one processor.
- a memory 204 in the computing device 200 can be a read only memory (ROM) device or a random access memory (RAM) device in an implementation. Any other suitable type of storage device can be used as the memory 204.
- the memory 204 can include code and data 206 that is accessed by the CPU 202 using a bus 212.
- the memory 204 can further include an operating system 208 and application programs 210, the application programs 210 including at least one program that permits the CPU 202 to perform the methods described here.
- the application programs 210 can include applications 1 through N, which further include a video coding application that performs the methods described here.
- the computing device 200 can also include additional memory in the form of a secondary storage 214, which can, for example, be a memory card used with a mobile computing device.
- the video communication sessions may contain a significant amount of information, they can be stored in whole or in part in the secondary storage 214 and loaded into the memory 204 as needed for processing.
- the computing device 200 can also include one or more output devices, such as a display 218.
- the display 218 may be, in one example, a touch sensitive display that combines a display with a touch sensitive element that is operable to sense touch inputs.
- the display 218 can be coupled to the CPU 202 via the bus 212.
- Other output devices that permit a user to program or otherwise use the computing device 200 can be provided in addition to or as an alternative to the display 218.
- the output device is or includes a display
- the display can be implemented in various ways, including by a liquid crystal display (LCD), a cathode-ray tube (CRT) display or light emitting diode (LED) display, such as an organic LED (OLED) display.
- LCD liquid crystal display
- CRT cathode-ray tube
- LED light emitting diode
- OLED organic LED
- the computing device 200 can also include or be in communication with an image-sensing device 220, for example a camera, or any other image-sensing device 220 now existing or hereafter developed that can sense an image such as the image of a user operating the computing device 200.
- the image-sensing device 220 can be positioned such that it is directed toward the user operating the computing device 200.
- the position and optical axis of the image-sensing device 220 can be configured such that the field of vision includes an area that is directly adjacent to the display 218 and from which the display 218 is visible.
- the computing device 200 can also include or be in communication with a sound- sensing device 222, for example a microphone, or any other sound-sensing device now existing or hereafter developed that can sense sounds near the computing device 200.
- the sound-sensing device 222 can be positioned such that it is directed toward the user operating the computing device 200 and can be configured to receive sounds, for example, speech or other utterances, made by the user while the user operates the computing device 200.
- FIG. 2 depicts the CPU 202 and the memory 204 of the computing device 200 as being integrated into a single unit, other configurations can be utilized.
- the operations of the CPU 202 can be distributed across multiple machines (each machine having one or more of processors) that can be coupled directly or across a local area or other network.
- the memory 204 can be distributed across multiple machines such as a network-based memory or memory in multiple machines performing the operations of the computing device 200.
- the bus 212 of the computing device 200 can be composed of multiple buses.
- the secondary storage 214 can be directly coupled to the other components of the computing device 200 or can be accessed via a network and can comprise a single integrated unit such as a memory card or multiple units such as multiple memory cards.
- the computing device 200 can thus be implemented in a wide variety of configurations.
- FIG. 3 is a diagram of an example of a video stream 300 to be encoded and subsequently decoded.
- the video stream 300 includes a video sequence 302.
- the video sequence 302 includes a number of adjacent frames 304. While three frames are depicted as the adjacent frames 304, the video sequence 302 can include any number of adjacent frames 304.
- the adjacent frames 304 can then be further subdivided into individual frames, e.g., a frame 306.
- the frame 306 can be divided into a series of planes or segments 308.
- the segments (or planes) 308 can be subsets of frames that permit parallel processing, for example.
- the segments 308 can also be subsets of frames that can separate the video data into separate colors.
- the frame 306 of color video data can include a luminance plane and two chrominance planes.
- the segments 308 may be sampled at different resolutions.
- the frame 306 may be further subdivided into blocks 310, which can contain data corresponding to, for example, 16x16 pixels in frame 306.
- the blocks 310 can also be arranged to include data from one or more planes of pixel data.
- the blocks 310 can also be of any other suitable size such as 4x4 pixels, 8x8 pixels, 16x8 pixels, 8x16 pixels, 16x16 pixels or larger. Unless otherwise noted, the terms block and macroblock are used interchangeably herein.
- FIG. 4 is a block diagram of an encoder 400 in accordance with an
- the encoder 400 can be implemented, as described above, in the
- the transmitting station 102 such as by providing a computer software program stored in memory, for example, the memory 204.
- the computer software program can include machine instructions that, when executed by a processor such as the CPU 202, cause the transmitting station 102 to encode video data in the manner described in FIG. 4 and in FIG. 6, below.
- the encoder 400 can also be implemented as specialized hardware included in, for example, the transmitting station 102.
- the encoder 400 has the following stages to perform the various functions in a forward path (shown by the solid connection lines) to produce an encoded or compressed bitstream 420 using the video stream 300 as input: an intra/inter prediction stage 402, a transform stage 404, a quantization stage 406, and an entropy encoding stage 408.
- the encoder 400 may also include a reconstruction path (shown by the dotted connection lines) to reconstruct a frame for encoding of future blocks.
- the encoder 400 has the following stages to perform the various functions in the reconstruction path: a dequantization stage 410, an inverse transform stage 412, a reconstruction stage 414, and a loop filtering stage 416.
- Other structural variations of the encoder 400 can be used to encode the video stream 300.
- each frame 306 can be processed in units of blocks.
- each block can be encoded using intra-frame prediction (also called intra-prediction) or inter-frame prediction (also called inter-prediction), or a combination both.
- intra-prediction also called intra-prediction
- inter-frame prediction also called inter-prediction
- a prediction block can be formed.
- intra-prediction all or a part of a prediction block may be formed from samples in the current frame that have been previously encoded and reconstructed.
- inter-prediction all or part of a prediction block may be formed from samples in one or more previously constructed reference frames determined using motion vectors.
- the prediction block can be subtracted from the current block at the intra/inter prediction stage 402 to produce a residual block (also called a residual).
- the transform stage 404 transforms the residual into transform coefficients in, for example, the frequency domain using block-based transforms.
- block-based transforms include, for example, the Discrete Cosine Transform (DCT) and the Asymmetric Discrete Sine Transform (ADST).
- DCT Discrete Cosine Transform
- ADST Asymmetric Discrete Sine Transform
- combinations of different transforms may be applied to a single residual.
- the DCT transforms the residual block into the frequency domain where the transform coefficient values are based on spatial frequency.
- the lowest frequency (DC) coefficient at the top-left of the matrix and the highest frequency coefficient at the bottom- right of the matrix may be different from the size of the transform block.
- the prediction block may be split into smaller blocks to which separate transforms are applied.
- the quantization stage 406 converts the transform coefficients into discrete quantum values, which are referred to as quantized transform coefficients, using a quantizer value or a quantization level. For example, the transform coefficients may be divided by the quantizer value and truncated.
- the quantized transform coefficients are then entropy encoded by the entropy encoding stage 408. Entropy coding may be performed using any number of techniques, including token and binary trees.
- the entropy-encoded coefficients, together with other information used to decode the block, which may include for example the type of prediction used, transform type, motion vectors and quantizer value, are then output to the compressed bitstream 420.
- the information needed to decode the block may be entropy coded into block, frame, slice and/or section headers within the compressed bitstream 420.
- the compressed bitstream 420 can also be referred to as an encoded video stream or encoded video bitstream, and the terms will be used interchangeably herein.
- the reconstruction path in FIG. 4 can be used to ensure that both the encoder 400 and a decoder 500 (described below) use the same reference frames and blocks to decode the compressed bitstream 420.
- the reconstruction path performs functions that are similar to functions that take place during the decoding process that are discussed in more detail below, including dequantizing the quantized transform coefficients at the dequantization stage 410 and inverse transforming the dequantized transform coefficients at the inverse transform stage 412 to produce a derivative residual block (also called a derivative residual).
- the prediction block that was predicted at the intra/inter prediction stage 402 can be added to the derivative residual to create a reconstructed block.
- the loop filtering stage 416 can be applied to the reconstructed block to reduce distortion such as blocking artifacts.
- encoder 400 can be used to encode the compressed bitstream 420.
- a non-transform based encoder 400 can quantize the residual signal directly without the transform stage 404 for certain blocks or frames.
- an encoder 400 can have the quantization stage 406 and the dequantization stage 410 combined into a single stage.
- FIG. 5 is a block diagram of a decoder 500 in accordance with another
- the decoder 500 can be implemented in the receiving station 106, for example, by providing a computer software program stored in the memory 204.
- the computer software program can include machine instructions that, when executed by a processor such as the CPU 202, cause the receiving station 106 to decode video data in the manner described in FIG. 5 and in FIG. 8 below.
- the decoder 500 can also be implemented in hardware included in, for example, the transmitting station 102 or the receiving station 106.
- the decoder 500 similar to the reconstruction path of the encoder 400 discussed above, includes in one example the following stages to perform various functions to produce an output video stream 516 from the compressed bitstream 420: an entropy decoding stage 502, a dequantization stage 504, an inverse transform stage 506, an intra/inter-prediction stage 508, a reconstruction stage 510, a loop filtering stage 512 and a deblocking filtering stage 514.
- stages to perform various functions to produce an output video stream 516 from the compressed bitstream 420 includes in one example the following stages to perform various functions to produce an output video stream 516 from the compressed bitstream 420: an entropy decoding stage 502, a dequantization stage 504, an inverse transform stage 506, an intra/inter-prediction stage 508, a reconstruction stage 510, a loop filtering stage 512 and a deblocking filtering stage 514.
- Other structural variations of the decoder 500 can be used to decode the
- the data elements within the compressed bitstream 420 can be decoded by the entropy decoding stage 502 to produce a set of quantized transform coefficients.
- the dequantization stage 504 dequantizes the quantized transform coefficients (e.g., by multiplying the quantized transform coefficients by the quantizer value), and the inverse transform stage 506 inverse transforms the dequantized transform coefficients using the selected transform type to produce a derivative residual that can be identical to that created by the inverse transform stage 412 in the encoder 400.
- the decoder 500 can use the intra/inter-prediction stage 508 to create the same prediction block as was created in the encoder 400, e.g., at the intra/inter prediction stage 402.
- the prediction block can be added to the derivative residual to create a reconstructed block.
- the loop filtering stage 512 can be applied to the reconstructed block to reduce blocking artifacts. Other filtering can be applied to the reconstructed block.
- the deblocking filtering stage 514 is applied to the reconstructed block to reduce blocking distortion, and the result is output as an output video stream 516.
- the output video stream 516 can also be referred to as a decoded video stream, and the terms will be used
- decoder 500 can be used to decode the compressed bitstream 420.
- the decoder 500 can produce the output video stream 516 without the deblocking filtering stage 514.
- a block may be encoded or decoded by motion vector prediction a dynamic reference motion vector coding mode.
- a dynamic reference motion vector coding mode One implementation of using the dynamic reference motion vector coding mode for encoding and decoding is next discussed.
- FIG. 6 is a flow diagram showing a process 600 for encoding a video stream using reference motion vectors in accordance with an implementation of this disclosure.
- Process 600 can be implemented in an encoder such as encoder 400 and can be implemented, for example, as a software program that can be executed by computing devices such as transmitting station 102 or receiving station 106.
- the software program can include machine-readable instructions that can be stored in a memory such as memory 204 or 214, and that can be executed by a processor, such as CPU 202, to cause the computing device to perform process 600.
- the process 600 can be implemented using specialized hardware or firmware. Some computing devices can have multiple memories, multiple processors, or both. The steps or operations of the process 600 can be distributed using different processors, memories, or both. Use of the terms "processor” or “memory” in the singular encompasses computing devices that have one processor or one memory as well as devices that have multiple processors or multiple memories that can each be used in the performance of some or all of the recited steps.
- process 600 is depicted and described as a series of steps or operations. However, the teachings in accordance with this disclosure can occur in various orders and/or concurrently. Additionally, steps in accordance with this disclosure may occur with other steps not presented and described herein. Furthermore, not all illustrated steps or operations may be required to implement a method in accordance with the disclosed subject matter.
- the process 600 assumes that a stream of video data having multiple frames, each having multiple blocks, is being encoded using a video encoder such as encoder 400 executing on a computing device such as transmitting station 102.
- the video data or stream can be received by the computing device in any number of ways, such as by receiving the video data over a network, over a cable, or by reading the video data from a primary memory or other storage device, including a disk drive or removable media such as a CompactFlash (CF) card, Secure Digital (SD) card, or any other device capable of communicating video data.
- video data can be received from a video camera connected to the computing device operating the encoder. At least some of the blocks within frames are encoded using inter prediction as described in more detail below.
- the process 600 identifies candidate motion vectors from previously coded blocks in the video stream.
- the process 600 analyzes the motion activity of previously coded blocks to produce a list of ranked candidate motion vectors, employing an efficient reference motion vector ranking system, and provides a dynamic motion referencing mode that fully accounts for the available motion vector candidate list, which allows the number of the reference motion vector modes to be dynamically extended or shortened and improves the efficacy of entropy coding.
- the pool of the candidate motion vectors can be dynamically extended or shortened according to the neighboring reference block condition, i.e., how the list of candidate motion vectors is created.
- the previously coded blocks in the video stream can include any block encoded using inter-prediction before the current block, such as a block from a previously coded frame or a block from the same frame as the current block that has been encoded before the current block.
- the previously coded blocks can include a block above, to the left, or to the above-left of the current block in the same frame.
- the previously coded blocks can also include, for example, a block from the immediately previous frame (i.e., last frame), a block from the golden frame (described at intra/inter prediction stage 402), a block from any other reference frame, or any combination thereof.
- the candidate motion vectors are obtained from previously coded blocks that correspond in some way to the current block based on the theory that such blocks, due to the proximity of their pixels to the current block, are likely to have similar motion
- Blocks may be predicted from a single reference frame or compound, such as two, reference frames.
- the process 600 identifies candidate motion vectors from the nearest spatial neighboring blocks that are associated with the reference frame.
- the candidate motion vectors may include the motion vector reference blocks within a reference coverage area, such as the motion vector(s) from a boundary area (e.g., a block) above the current block, the motion vector(s) from a boundary area (e.g., a block) to the left of the current block, the motion vector from a top-right corner of the current block, and the motion vector(s) from a collocated block in the previous frame.
- motion vectors associated with blocks below and to the right of the collocated block are considered.
- FIG. 7 is a diagram of a sequence of frames used to explain the identification of candidate motion vectors of 602 within the process 600 of FIG. 6.
- the current block B being encoded is located within current Frame N.
- Frame N-l is the preceding frame, also called a temporally adjacent frame, which may be the reconstructed frame stored in a so-called last reference frame buffer that is available for coding blocks of Frame N.
- block R3 is the collocated block to the current block B, and it is located at the same pixel location (usually measured from the top-left pixel) and has the same pixel dimensions in the x- and y- planes (i.e., the same pixel coordinates) within Frame N-l as the current block B has within Frame N. Stated another way, the block R3 spatially corresponds to the current block B.
- the motion vector candidate buffer is associated with the reference frame. Given the reference frame index, a search for motion vectors associated with the same reference frame may be performed through the reference blocks shown in FIG. 7 for inclusion in the candidate list.
- the blocks B and R3 are of an arbitrary block size.
- the blocks B and R3 may each be 32z32 pixels.
- each frame may be partitioned into blocks for coding. Those blocks may be further partitioned into smaller blocks for coding purposes. For this reason, any block or region adjacent to the current block B may have been partitioned into smaller blocks that are predicted by different motion vectors. Therefore, the search for motion vectors may be take this into consideration by assessing the motion information for the smallest possible prediction block size within a frame.
- the search for motion vectors in the current frame is done using motion information from a top row boundary region, also called block RO, a left column boundary region, also called block Rl, and the top-right corner, also call block R2.
- the blocks RO and Rl are regions whose size (dimensions) is related to the size of the current block B.
- the blocks RO and Rl are of the same size as the current block B, but they may be half the size of the current block B or otherwise relate to the size of the current block B.
- each sub-block of pixels e.g., having the smallest prediction block size within blocks RO and Rl can be scanned through for candidate motion vectors.
- the smallest prediction block size may be 8x8 or 4x4.
- the block R2 is desirably the smallest prediction block size to minimize searching and because more distant blocks are likely to provide less relevant information.
- the block R2 would only have one motion vector (or two in combined prediction) if the block R2 is the smallest prediction block size.
- the block R2 may be larger in size in an implementation.
- the search for motion vectors in the last frame is done using motion information from the collocated block R3, and the additional reference blocks R4, R5, R6, and R7 adjacent to the bottom row (blocks R6, R7), the right column (R4), or both (R5). That is, they each proximate to (e.g., in contact with) a corner of the collocated block.
- the collocated block R3 has the same size as the current block.
- Each sub-block of the smallest prediction block size within the collocated block R3 may be scanned or searched for candidate motion vectors.
- the additional reference blocks R4, R5, R6, and R7 respectively have the smallest prediction block size regardless of the size of the current block B, but this is not required.
- the process 600 may determine, for each candidate motion vector, a distance between the previously coded block associated with the candidate motion vector and the current block.
- the motion vectors from the nearest row and column boundaries and the top-right corner to the current block are in contact with the current block and may be considered to be more relevant and so are ranked higher than those further away.
- the distance may be used to group the motion vectors into categories. For example, and with reference to FIG.
- any motion vectors from the sub- blocks of the reference blocks R0 and Rl, and a motion vector from the reference block R2, if any, may be considered as category 1 candidate motion vectors, while the remaining candidate motion vectors from the blocks R3 through R7 and from any other sub-blocks of the reference blocks R0 and Rl are considered to be category 2 candidate motion vectors.
- category 1 candidate motion vectors would assume a higher priority than category 2 candidate motion vectors.
- the distance may additionally or alternatively include calculating a straight line distance between the centers of the current block and each of the reference blocks and/or sub-blocks of the reference blocks.
- the distance between the reference block and the current block can be based on the spatial displacement between the pixels in the previously coded block and the collocated pixels in the current block, measured in the unit of pixels.
- a collocated block may be ranked higher than reference blocks in a current frame (e.g., because the difference/displacement is zero), even when popularity values are considered.
- Other ways of grouping and/or ranking the motion vectors based on distance are possible.
- the motion vectors may be ranked according to the number of pixels within the search areas (e.g., the previously coded pixels of at least some of the reference blocks) that are using each motion vector.
- the process 600 may determine a popularity value based on the previously coded pixel values associated with the particular candidate motion vector at 606. The larger the number of previously coded pixel values associated with the candidate motion vector, the higher the popularity value of the candidate motion vector.
- the popularity value may be a raw number of pixels or a percentage of the total number of pixels within all or some of the reference blocks, for example.
- motion vectors There could be up to twenty-eight motion vectors associated with the reference frame and assigned to category 2, four each from the remaining 8x8 sub-blocks of the reference blocks R0 and Rl, sixteen from the collocate block R3, and one each from the additional four 8x8 reference blocks R4-R7.
- motion vectors are often re-used.
- Each of the unique motion vectors within a category from all of those identified is attributed with a popularity value corresponding to each of the groups of 8x8 pixels (that is, 64 pixels) using that motion vector.
- the motion vector does not have to be identical to another. Ranges can be used so as to provide a motion vector candidate list demonstrating sufficient variation to useful.
- a motion vector may be omitted within a category if it does not vary enough from a motion vector candidate already in a category, such as by 10% or some other variable.
- motion vectors are ranked by category and then ranked within the categories, but this is not required.
- the motion vector candidates may be grouped together for ranking based on the popularity value.
- the reference motion vector candidate list may be constructed as described for each unique reference frame associated with a previously coded block or sub-block. For example, three reference frames may be available for each frame as described above— a last frame, an alternative (or alternate or alt) reference frame, and a golden reference frame. In this case, separate reference motion vector candidate list may be constructed using those previously coded blocks or sub-blocks having motion vectors pointing each of the last frame, the alt reference frame, and the golden reference frame. The last frame is updated for each frame, and the alt reference frame and golden reference frame may be updated less frequently.
- motion vector scaling is performed when constructing a reference motion vector candidate list.
- Motion vector scaling may be done as part of the determination of a popularity value at 606, or may be done at other points in the process 600.
- Motion vector scaling adjusts the magnitude of a motion vector to account for the temporal differences between reference frames relative to the frame under consideration within the sequence of frames within the video stream.
- the reference block R2 uses the last frame, which is Frame N-1, for inter-prediction
- the reference block R4 uses the last frame, which is the frame preceding Frame N-1 (or Frame N- 2, not shown), for inter-prediction.
- the temporal difference between the frame in which each block R2 and R4 is located (Frame N and Frame N-1, respectively) and the corresponding reference frame (Frame N- 1 and Frame N-2, respectively) is one frame, so no scaling is indicated.
- the reference blocks R2 and R4 both use the golden reference frame, the temporal differences between Frame N and the golden reference frame and the between the Frame N- 1 and the golden reference frame are different if the golden reference frame is unchanged.
- a candidate motion vector can be generated by scaling up the magnitude of the motion vector associated with the shorter temporal difference or scaling down the magnitude of the motion vector associated with the longer temporal differences so that the motion vectors share a common basis.
- the factor used for scaling can be based on a ratio formed by the temporal differences.
- Motion vector scaling may also be used in implementations where only one reference motion vector candidate list is prepared for all reference frames, instead of separate lists for each reference frame. Reference frames may be located either before or after the current frame in the video sequence. In some implementations, motion vector scaling is omitted.
- a block may be predicted from two or more reference frames, where the pixel values are combinations of the pixels values from prediction blocks within each frame generated by respective motion vectors.
- the list is constructed by first looking for neighboring blocks that share the same compound reference frames (i.e., the same combination of reference frames) for their reference motion vectors. A higher priority is assigned to candidate motion vectors from neighboring reference blocks that share the combination of reference frames as that under consideration for the current block.
- the motion vectors may also be ranked from highest to lowest popularity value.
- the list may be appended with combinations of reference motion vectors of single reference frames that are identified and ranked as described above. For example, if a compound reference mode that uses the last frame and the alt reference frame is under consideration, the reference blocks are searched for motion vectors referencing either the last frame or the alt reference frame, which are then ranked based on a popularity value as discussed.
- the determination of the popularity values at 608 includes ranking the motion vectors using the popularity values. It can also include assigning the motion vectors to inter-coding (or inter-prediction) modes based on the ranking.
- the most popular motion vector may be selected for an inter-prediction mode that includes differential coding of a new motion vector. This may be referred to as a NEWMV mode.
- the remaining motion vectors may be assigned to other reference vector motion modes.
- a REFMV mode is a dynamic reference motion vector coding mode that includes at least two modes where an existing motion vector is re-used.
- these two inter-prediction modes are a NEARESTMV mode and a NEARMV mode.
- the next motion vector in the ranking after the one assigned to the NEWMV mode i.e., the motion vector with the second highest popularity value
- the next motion vector after that i.e., the motion vector with the third highest popularity value
- NEARMV mode If the candidate reference motion vector list for a particular reference frame is longer than two, the number of reference motion vector modes may be extended to accommodate the remaining entries in the list.
- Another available inter-prediction mode may be a ZEROMV mode, which means that no motion exists.
- an inter-prediction mode is selected for the current block. This may include testing each of the inter-prediction modes and selecting the inter-prediction mode that results in the most efficient coding of the current block.
- the process 600 may be part of a rate-distortion loop used to select the inter-prediction mode for the current block to be encoded.
- an actual motion vector for inter prediction of the current block may be determined through a motion search according to any number of motion searching techniques.
- one use of the reference motion vector may include using the reference motion vector assigned to the NEWMV mode or one of the other identified candidate motion vectors as a starting parameter for the motion search algorithm based on the reasoning that the actual motion vector is likely to be close to highly ranked motion vectors for the reference frame.
- Combinations of reference frames in a compound prediction mode may be similarly searched using motion vectors from the candidate list, particularly those having the highest rank for each of the reference frames.
- Motion searches may alternatively be performed without using motion vectors from the candidate lists. Whether or not a reference motion vector is used in the motion search, various inter-prediction modes may be tested. In one implementation, an exhaustive motion search that attempts each of the available inter-prediction modes using single or compound modes (i.e., using each of the three reference frames and combinations of reference frames).
- a bit cost (also called a rate) of encoding the current block using the inter-prediction mode, including the bits required to signal the inter-prediction mode, the reference frame(s), the residual block generated from the current block, and, if required, one or more motion vector(s) or motion vector differential(s), and the resulting error in the pixel values between the original values and the reconstructed values (also called a distortion) are calculated.
- the inter-prediction mode and reference frame(s) resulting in the lowest rate-distortion value also called a ratio
- An exhaustive search does not need to be performed.
- the inter-prediction modes used for adjacent blocks in the frames may be tested first, and then only certain inter-prediction modes may be tested to see if an improved rate-distortion ratio results. Further, motion searching is applicable to inter-prediction.
- the rate-distortion loop may include tests for various intra- prediction modes, or a separate rate-distortion loop may be used to select the most efficient intra-prediction mode from available intra-prediction modes. Then, the most efficient inter- prediction mode and the most efficient intra-prediction mode are compared to select the prediction mode for the block.
- the current block is encoded at 610 using the inter- prediction mode.
- the inter-prediction mode selected at 608 is better than the available intra-prediction modes.
- the current block is encoded at 610 using the inter- prediction mode.
- the predicted block is generated using the actual motion vector(s) from the motion search and the selected reference frame(s).
- the residual between the current block and the predicted block is generated and encoded as described with reference to FIG. 4.
- the motion vector(s) assigned to the NEWMV mode by the ranking can be used to differentially encode the actual motion vector(s).
- a difference value or residual can be calculated by subtracting a reference motion vector from a motion vector used to encode the current block.
- the difference value can be encoded and included in the video stream.
- bits indicating the reference frame(s) and that the NEWMV mode was used may be indicated in the block header and/or in a frame or slice header.
- the motion search results in a motion vector equal to or within a range of values about one of the reference motion vectors assigned to reference motion vector modes.
- the REFMV inter-prediction mode is indicated. If the motion vector resulting from the search is equal to or within a range of values about the reference motion vector assigned to the NEARMV mode in this example, the predicted block is generated using the reference motion vector assigned to the NEARMV mode and the selected reference frame. Then, the residual between the current block and the predicted block is generated and encoded as described with reference to FIG. 4.
- bits indicating the reference frame and that the REFMV mode and particularly the NEARMV mode was used may be indicated in the block header and/or in a frame or slice header.
- inter-prediction modes may similarly be used to encode the current block, if selected at 608, or to encode other blocks of the frames within a video sequence.
- the process 600 of FIG. 6 may be repeated as needed.
- encoding the current block may include entropy coding.
- Entropy coding the inter-prediction modes may be modified to take into account the new dynamic reference motion vector modes. Assuming three inter-prediction modes corresponding to a new motion vector, a zero motion vector, and a dynamic reference motion vector mode, respectively the NEWMV mode, the ZEROMV mode, and REFMV mode in this example, entropy coding starts with the NEWMV mode.
- the probability model may be selected according to two contexts: 1) how many reference motion vectors are found; and 2) if neighboring block(s) with a matched reference frame is found, how likely they are to be coded in the NEWMV mode.
- next coding mode is not the NEWMV mode
- coding continues if the next coding mode is the ZEROMV mode.
- the probability model may be selected according to two contexts: 1) if the collocated block in the last (or previous) frame using a zero motion vector, or close to a zero motion vector (i.e., less than one full pixel in both row and column components); and 2) whether (and possibly how many of) the spatial neighboring blocks within the current frame are using zero motion vectors, or close to zero motion vectors.
- next coding mode is not the ZEROMV mode (i.e., is the dynamic reference motion vector mode indicated by the REFMV mode)
- ZEROMV mode i.e., is the dynamic reference motion vector mode indicated by the REFMV mode
- the associated context is how many reference motion vectors are checked into the candidate list and, when applicable, their weighting coefficients used in compound prediction.
- FIG. 8 is a flowchart diagram of a process 800 for decoding an encoded video stream using reference motion vectors in accordance with implementations of this disclosure.
- the process 800 can be implemented, for example, as a software program that may be executed by computing devices such as transmitting station 102 or receiving station 106.
- the software program can include machine-readable instructions that may be stored in a memory such as memory 204 or 214, and that, when executed by a processor, such as CPU 202, may cause the computing device to perform the process 800.
- the process 800 can be implemented using specialized hardware or firmware. As explained above, some computing devices may have multiple memories or processors, and the operations described in the process 800 can be distributed using multiple processors, memories, or both.
- process 800 is depicted and described as a series of steps or operations. However, the steps or operations in accordance with this disclosure can occur in various orders and/or concurrently. Additionally, other steps or operations not presented and described herein may be used. Furthermore, not all illustrated steps or operations may be required to implement a method in accordance with the disclosed subject matter.
- the decoder determines whether the current block was encoded using single or compound prediction. This information can be communicated by reading and decoding bits from an encoded video bitstream that indicate the one or more than one motion vectors was used to encode the current block.
- the encoded bitstream (or encoded video data) may be received by a decoder of a computing device in any number of ways, such as by receiving the video data over a network, over a cable, or by reading the video data from a primary memory or other storage device, including a disk drive or removable media such as a DVD, CompactFlash (CF) card, Secure Digital (SD) card, or any other device capable of communicating a video stream.
- This information can be included in a header associated with a current block or a frame header, for example. This explanation assumes that the current block is inter-predicted. Otherwise, no reference frame is encoded into the bitstream in association with the current block, and the current block was intra-predicted.
- the candidate motion vectors can be ranked in a similar manner as described with reference to the process 600 of FIG. 6. That is, the encoder and decoder can share rules regarding the generation of reference motion vector candidate lists so that the decoder, receiving header information related to which inter-prediction mode was used to encode the current block (e.g., NEWMV, NEARESTMV, NEARMV, etc.), is able to identify the same reference motion vector(s) used by the encoder.
- the candidate motion vectors can be identified from previously coded blocks at 804 in a like manner as they are identified at 602 in the process 600. While the process 600 may identify the candidate motion vectors for ranking using all available reference frames and combinations of reference frames in order to select the inter-prediction mode, the process 800 only needs to rank those candidate motion vectors for the reference frame(s) actually to encode the block.
- ranking the candidate motion vectors includes determining, for each candidate motion vector, the distance between the previously coded block that is the source of the motion vector and the current block at 806. This involves the same operations as those described above with respect to the determination at 604 in the process 600. The result of this operation is a list of candidate motion vectors grouped by the distance in an embodiment. Then, determining a respective popularity value for the candidate motion vectors from previously coded blocks at 804 is performed the same as the determination at 606 in the process 600. The result of this operation is a ranked list of candidate motion vectors for the single reference frame or the combined reference frames used in the prediction of the current block.
- the highest ranked (e.g., most probable) motion vector is assigned to a NEWMV mode, and the next two motion vectors in the ranking are assigned respectively to the NEARESTMV and NEARMV reference motion vector modes of the dynamic reference motion vector (REFMV) mode. Any further reference motion vectors are assigned in sequence thereafter.
- the inter-prediction mode that was used to encode the current block is identified.
- the inter-prediction mode is identified by decoding bits included within the bitstream that identify the inter-prediction mode.
- the inter- prediction mode may be the new motion vector mode, the zero motion vector mode, or the dynamic reference motion vector mode. If the inter-prediction mode is the dynamic reference motion vector mode, the particular reference motion vector mode used can be similarly determined, e.g., from bits included within header(s) in the bitstream.
- the inter-prediction mode identified at 810 is used to decode the current block at 812, such as through the decoding process described with reference to FIG. 5.
- the reference motion vector can be used to decode the motion vector used to predict the current block.
- the inter-prediction mode may indicate the motion vector by reference to the list. Regardless of the source of the one or more motion vectors, the prediction block is generated using the motion vector(s) and is added to the residual for the current block decoded from the bitstream.
- the process 800 may be repeated for each block that is encoded using inter- prediction to generate a reconstructed block.
- the frame is reconstructed using the
- an output video stream such as the output video stream 516 shown in FIG. 5, can be reconstructed.
- Implementations of transmitting station 102 and/or receiving station 106 can be realized in hardware, software, or any combination thereof.
- the hardware can include, for example, computers, intellectual property (IP) cores, application-specific integrated circuits (ASICs), programmable logic arrays, optical processors, programmable logic controllers, microcode, microcontrollers, servers, microprocessors, digital signal processors or any other suitable circuit.
- IP intellectual property
- ASICs application-specific integrated circuits
- programmable logic arrays optical processors
- programmable logic controllers programmable logic controllers
- microcode microcontrollers
- servers microprocessors, digital signal processors or any other suitable circuit.
- signal processors digital signal processors
- transmitting station 102 or receiving station 106 can be implemented using a general purpose computer or general purpose processor with a computer program that, when executed, carries out any of the respective methods, algorithms and/or instructions described herein.
- a special purpose computer/processor can be utilized which can contain other hardware for carrying out any of the methods, algorithms, or instructions described herein.
- Transmitting station 102 and receiving station 106 can, for example, be implemented on computers in a video conferencing system.
- transmitting station 102 can be implemented on a server and receiving station 106 can be implemented on a device separate from the server, such as a hand-held communications device.
- transmitting station 102 can encode content using an encoder 400 into an encoded video signal and transmit the encoded video signal to the communications device.
- the communications device can then decode the encoded video signal using a decoder 500.
- the communications device can decode content stored locally on the communications device, for example, content that was not transmitted by transmitting station 102.
- Other transmitting station 102 and receiving station 106 implementation schemes are available.
- receiving station 106 can be a generally stationary personal computer rather than a portable communications device and/or a device including an encoder 400 may also include a decoder 500.
- implementations of the present disclosure can take the form of a computer program product accessible from, for example, a tangible computer- usable or computer-readable medium.
- a computer-usable or computer-readable medium can be any device that can, for example, tangibly contain, store, communicate, or transport the program for use by or in connection with any processor.
- the medium can be, for example, an electronic, magnetic, optical, electromagnetic, or a semiconductor device. Other suitable mediums are also available.
Abstract
Techniques are described to use a reference motion vector to reduce the amount of bits needed to encode motion vectors for inter prediction. A dynamic motion vector coding mode generates a ranked list of motion vector candidates using a distance between previously coded blocks and a current block, and the frequency of use of the motion vectors of those previously coded blocks. The list is used to assign the effective motion vectors to different inter-prediction modes, including a variable number of reference motion vector modes.
Description
DYNAMIC REFERENCE MOTION VECTOR CODING MODE
BACKGROUND
[0001] Digital video streams may represent video using a sequence of frames or still images. Digital video can be used for various applications including, for example, video conferencing, high definition video entertainment, video advertisements, or sharing of user- generated videos. A digital video stream can contain a large amount of data and consume a significant amount of computing or communication resources of a computing device for processing, transmission or storage of the video data. Various approaches have been proposed to reduce the amount of data in video streams, including compression and other encoding techniques.
SUMMARY
[0002] This disclosure relates generally to encoding and decoding video data and more particularly relates to video coding using reference motion vectors.
[0003] A method for decoding a video stream according to one implementation of this disclosure includes identifying, for a current block, a reference frame used to encode the current block within a current frame, creating a reference motion vector candidate list for the reference frame using reference blocks, ranking each motion vector within the reference motion vector candidate list by a distance from the current block to a reference block providing the motion vector, and by a popularity value of the motion vector that indicates a level of use of the motion vector by the reference block that indicates a level of use of the motion vector by the reference blocks, assigning the motion vectors to a plurality of inter- prediction modes based on the ranking, selecting an inter-prediction mode for decoding the current block, and decoding the current block using the inter-prediction mode. The reference blocks can including spatially adjacent blocks of the current frame, a collocated block within a previous frame, and spatially adjacent blocks of the collocated block within the previous frame, or other reference blocks.
[0004] A corresponding apparatus for decoding a video stream is also provided, for example an apparatus including a processor and a memory, the memory storing instructions that cause the processor to perform the method above.
[0005] A method for encoding a video stream according to one implementation of this
disclosure include identifying, for each of a plurality of reference frames, candidate motion vectors for encoding a current block within a current frame using reference blocks, ranking the candidate motion vectors within a reference motion vector candidate list for a reference frame by a distance from the current block of a respective reference block providing a respective candidate motion vector, and by a popularity value of the motion vector that indicates a level of use of the motion vector by the reference blocks, assigning the motion vectors to a plurality of inter-prediction modes based on the ranking, selecting an inter- prediction mode for encoding the current block, and encoding the current block using the inter-prediction mode.
[0006] A corresponding apparatus for encoding a video stream is also provided, for example an apparatus including a processor and a memory, the memory storing instructions that cause the processor to perform the method above. Also provided are one or more computer readable media providing computer program code arranged to put into effect the encoding and/or decoding methods and apparatus described herein when executed on suitable computer apparatus.
[0007] Variations in these and other aspects of the disclosure will be described in additional detail hereafter.
BRIEF DESCRIPTION OF THE DRAWINGS
[0008] The description herein makes reference to the accompanying drawings described below wherein like reference numerals refer to like parts throughout the several views.
[0009] FIG. 1 is a schematic of a video encoding and decoding system.
[0010] FIG. 2 is a block diagram of an example of a computing device that can implement a transmitting station or a receiving station.
[0011] FIG. 3 is a diagram of a video stream to be encoded and subsequently decoded.
[0012] FIG. 4 is a block diagram of a video compression system according to an aspect of the teachings herein.
[0013] FIG. 5 is a block diagram of a video decompression system according to another aspect of the teachings herein.
[0014] FIG. 6 is a flowchart diagram of a process for encoding a video stream using reference motion vectors in accordance with an implementation of this disclosure.
[0015] FIGS. 7 A and 7B are diagrams of a sequence of frames used to explain the identification of candidate motion vectors within the process of FIG. 6.
[0016] FIG. 8 is a flowchart diagram of a process for decoding an encoded video stream
using reference motion vectors in accordance with implementations of this disclosure.
DETAILED DESCRIPTION
[0017] Compression schemes related to coding video streams may include breaking each image into blocks and generating a digital video output bitstream using one or more techniques to limit the information included in the output. A received bitstream can be decoded to re-create the blocks and the source images from the limited information. Encoding a video stream, or a portion thereof, such as a frame or a block, can include using temporal and spatial similarities in the video stream to improve coding efficiency. For example, a current block of a video stream may be encoded based on a previously encoded block in the video stream by predicting motion and color information for the current block based on the previously encoded block and identifying a difference (residual) between the predicted values and the current block. In this way, only the residual and parameters used to generate it need be added to the bitstream instead of including the entirety of the current block. This technique may be referred to as inter prediction.
[0018] One of the parameters in inter prediction is a motion vector that represents the spatial displacement of the previously coded block relative to the current block. The motion vector can be identified using a method of motion estimation, such as a motion search. In motion search, a portion of a reference frame can be translated to a succession of locations to form a prediction block that can be subtracted from a portion of a current frame to form a series of residuals. The X and Y translations corresponding to the location having the smallest residual can be selected as the motion vector. Bits representing the motion vector can be included in the encoded bitstream to permit a decoder to reproduce the prediction block and decode the portion of the encoded video bitstream associated with the motion vector.
[0019] For video compression schemes, the number of bits used to encode the motion vectors can be significant, especially for video streams encoded at lower data rates or higher compression ratios. To improve the encoding efficiency, a motion vector can be differentially encoded using a reference motion vector, i.e., only the difference between the motion vector and the reference motion vector is encoded. In some instances, the reference motion vector can be selected from previously used motion vectors in the video stream, for example, the last non-zero motion vector from neighboring blocks. Selecting a previously used motion vector to encode a current motion vector can further reduce the number of bits included in the encoded video bitstream and thereby reduce transmission and storage bandwidth
requirements. Motion vector referencing modes allow a coding block to infer motion information from previously coded neighboring blocks.
[0020] The reference motion vector candidate list can be constructed according to the distance between the reference block and the current block being encoded. However, ranking solely according to the block distance ignores that a motion vector may be used by multiple blocks. How many pixels in a reference area are using the motion vector may indicate the likelihood that the motion vector is an effective motion vector for the current block.
[0021] As mentioned, neighboring blocks may be used to construct a reference motion vector candidate list. In order that the encoder and decoder are using the same information, previously coded blocks are used. When coding in raster scan order, this limits the neighboring blocks to those to the left and above the current block to the extent they are available. The collocated block from the previous frame (also called the last frame) can also be considered. However, the collocated block is a block located in the last frame having the same pixel location as the current block, so potentially useful motion information from the right and bottom of the current block is still omitted.
[0022] Regardless of how the reference motion vector candidate list is constructed, there may be a fixed number of motion vector referencing modes, such as two. The use of a fixed number of reference modes can be inefficient. For example, if the reference motion vector candidate list has less than the fixed number of motion vectors, zero motion vectors may be need to pad the modes without a motion vector. In other cases, the reference motion vector candidate list may have more than the fixed number of motion vectors. The omitted motion vectors may be better candidates than those kept— that is, an omitted motion vector may result in a better rate and/or less distortion in coding the current block.
[0023] In implementations of this disclosure, compression performance may be improved by employing an efficient reference motion vector ranking system, followed by a dynamic motion vector referencing mode that fully accounts for the available motion vector candidate list. In the ranking system, for example, reference motion vector candidates for blocks with a single reference frame may be ranked according to both relative distance from the current block and the coverage area (e.g., the use of the motion vector). For blocks with compound (e.g., two) reference frames, the candidate motion vectors from reference blocks that share the same reference frame combination may be ranked with a higher priority. Ranked below this are, optionally, combinations of motion vectors from neighboring blocks with a single reference frame. In the determination of motion vector candidates, motion information associated with blocks below and to the right of the collocated block may be considered so as
to capture those directions of movement. Finally, the dynamic motion vector referencing mode may use a number of modes that is dependent on the size of reference motion vector candidate list so that the chance of losing potentially valuable reference information is reduced.
[0024] A reference motion vector may be selected from candidate motion vectors based on the distance between the reference block and the current block and the popularity of the reference motion vector. For example, the distance between the reference block and the current block can be based on the spatial displacement between the pixels in the previously coded block and corresponding collocated pixels in the current block, measured in the unit of pixels. For example, the popularity of the motion vector can be based on the amount of previously coded pixels that use the motion vector. The more previously coded pixels that use the motion vector, the higher the probability of the motion vector. In one example, the popularity value is the number of previously coded pixels that use the motion vector. In another example, the popularity value is a percentage of previously coded pixels within an area that use the motion vector.
[0025] Due to the proximity of the current block to pixels in the reference block, it is likely in many cases that the current block has similar motion characteristics to those pixels. Thus, a candidate motion vector used in a reference block near the current block may closely resemble the actual motion vector for the current block. Additionally, a candidate motion vector that is used by the most amount of pixels in a reference block near the current block would further resemble the actual motion vector for the current block. For this reason, the motion vector of the candidate motion vectors with the highest popularity used in a nearby reference block may be selected as the reference motion vector for the actual motion vector of the current block. Fewer bits can be used to code the actual motion vector by coding the small difference in motion vectors, thus improving the overall coding efficiency. Other ways in which the selected motion vector may be used are discussed hereinafter.
[0026] The candidate motion vectors may be limited to spatial-temporal neighboring motion vectors. That is, the pool of candidate motion vectors may be selected from regions neighboring regions of the current block. In some video coding schemes, particularly those where video frames are encoded out of order, it is desirable to include in the pool of candidate motion vectors motion information from video frames in the distant past or future. Encoding video frames can out of order may occur, for example, in the coding of so-called "alternate reference frames" that are not temporally neighboring to the frames coded immediately before or after them. An alternate reference frame may be a synthesized frame
that does not occur in the input video stream or is a duplicate frame to one in the input video stream that is used for prediction and is generally not displayed following decoding. Such a frame can resemble a video frame in the non-adjacent future. Another example in which out of order encoding may occur is through the use of a so-called "golden reference frame," which is a reconstructed video frame that may or may not be neighboring to a current video frame and is stored in memory for use as a reference frame until replaced, e.g., by a new golden reference frame.
[0027] Herein, alternate reference frames and golden reference frames (also called alternate frames and golden frames), in addition to adjacent video frames, may be used to infer motion vector candidates for a block of a frame of video data. Other details are described herein after first describing an environment in which the disclosure may be implemented.
[0028] FIG. 1 is a schematic of a video encoding and decoding system 100. A
transmitting station 102 can be, for example, a computer having an internal configuration of hardware such as that described in FIG. 2. However, other implementations of the transmitting station 102 are possible. For example, the processing of the transmitting station 102 can be distributed among multiple devices.
[0029] A network 104 can connect the transmitting station 102 and a receiving station 106 for encoding and decoding of the video stream. Specifically, the video stream can be encoded in the transmitting station 102 and the encoded video stream can be decoded in the receiving station 106. The network 104 can be, for example, the Internet. The network 104 can also be a local area network (LAN), wide area network (WAN), virtual private network (VPN), cellular telephone network or any other means of transferring the video stream from the transmitting station 102 to, in this example, the receiving station 106.
[0030] The receiving station 106, in one example, can be a computer having an internal configuration of hardware such as that described in FIG. 2. However, other implementations of the receiving station 106 are possible. For example, the processing of the receiving station 106 can be distributed among multiple devices.
[0031] Other implementations of the video encoding and decoding system 100 are possible. For example, an implementation can omit the network 104. In another
implementation, a video stream can be encoded and then stored for transmission at a later time to the receiving station 106 or any other device having memory. In one implementation, the receiving station 106 receives (e.g., via the network 104, a computer bus, and/or some communication pathway) the encoded video stream and stores the video stream for later
decoding. In an example implementation, a real-time transport protocol (RTP) is used for transmission of the encoded video over the network 104. In another implementation, a transport protocol other than RTP may be used, e.g., a Hypertext Transfer Protocol (HTTP)- based video streaming protocol.
[0032] When used in a video conferencing system, for example, the transmitting station 102 and/or the receiving station 106 may include the ability to both encode and decode a video stream as described below. For example, the receiving station 106 could be a video conference participant who receives an encoded video bitstream from a video conference server (e.g., the transmitting station 102) to decode and view and further encodes and transmits its own video bitstream to the video conference server for decoding and viewing by other participants.
[0033] FIG. 2 is a block diagram of an example of a computing device 200 that can implement a transmitting station or a receiving station. For example, the computing device 200 can implement one or both of the transmitting station 102 and the receiving station 106 of FIG. 1. The computing device 200 can be in the form of a computing system including multiple computing devices, or in the form of a single computing device, for example, a mobile phone, a tablet computer, a laptop computer, a notebook computer, a desktop computer, and the like.
[0034] A CPU 202 in the computing device 200 can be a central processing unit.
Alternatively, the CPU 202 can be any other type of device, or multiple devices, capable of manipulating or processing information now-existing or hereafter developed. Although the disclosed implementations can be practiced with a single processor as shown, e.g., the CPU 202, advantages in speed and efficiency can be achieved using more than one processor.
[0035] A memory 204 in the computing device 200 can be a read only memory (ROM) device or a random access memory (RAM) device in an implementation. Any other suitable type of storage device can be used as the memory 204. The memory 204 can include code and data 206 that is accessed by the CPU 202 using a bus 212. The memory 204 can further include an operating system 208 and application programs 210, the application programs 210 including at least one program that permits the CPU 202 to perform the methods described here. For example, the application programs 210 can include applications 1 through N, which further include a video coding application that performs the methods described here. The computing device 200 can also include additional memory in the form of a secondary storage 214, which can, for example, be a memory card used with a mobile computing device.
Because the video communication sessions may contain a significant amount of information,
they can be stored in whole or in part in the secondary storage 214 and loaded into the memory 204 as needed for processing.
[0036] The computing device 200 can also include one or more output devices, such as a display 218. The display 218 may be, in one example, a touch sensitive display that combines a display with a touch sensitive element that is operable to sense touch inputs. The display 218 can be coupled to the CPU 202 via the bus 212. Other output devices that permit a user to program or otherwise use the computing device 200 can be provided in addition to or as an alternative to the display 218. When the output device is or includes a display, the display can be implemented in various ways, including by a liquid crystal display (LCD), a cathode-ray tube (CRT) display or light emitting diode (LED) display, such as an organic LED (OLED) display.
[0037] The computing device 200 can also include or be in communication with an image-sensing device 220, for example a camera, or any other image-sensing device 220 now existing or hereafter developed that can sense an image such as the image of a user operating the computing device 200. The image-sensing device 220 can be positioned such that it is directed toward the user operating the computing device 200. In an example, the position and optical axis of the image-sensing device 220 can be configured such that the field of vision includes an area that is directly adjacent to the display 218 and from which the display 218 is visible.
[0038] The computing device 200 can also include or be in communication with a sound- sensing device 222, for example a microphone, or any other sound-sensing device now existing or hereafter developed that can sense sounds near the computing device 200. The sound-sensing device 222 can be positioned such that it is directed toward the user operating the computing device 200 and can be configured to receive sounds, for example, speech or other utterances, made by the user while the user operates the computing device 200.
[0039] Although FIG. 2 depicts the CPU 202 and the memory 204 of the computing device 200 as being integrated into a single unit, other configurations can be utilized. The operations of the CPU 202 can be distributed across multiple machines (each machine having one or more of processors) that can be coupled directly or across a local area or other network. The memory 204 can be distributed across multiple machines such as a network-based memory or memory in multiple machines performing the operations of the computing device 200. Although depicted here as a single bus, the bus 212 of the computing device 200 can be composed of multiple buses. Further, the secondary storage 214 can be directly coupled to the other components of the computing device 200 or can be accessed via a network and can
comprise a single integrated unit such as a memory card or multiple units such as multiple memory cards. The computing device 200 can thus be implemented in a wide variety of configurations.
[0040] FIG. 3 is a diagram of an example of a video stream 300 to be encoded and subsequently decoded. The video stream 300 includes a video sequence 302. At the next level, the video sequence 302 includes a number of adjacent frames 304. While three frames are depicted as the adjacent frames 304, the video sequence 302 can include any number of adjacent frames 304. The adjacent frames 304 can then be further subdivided into individual frames, e.g., a frame 306. At the next level, the frame 306 can be divided into a series of planes or segments 308. The segments (or planes) 308 can be subsets of frames that permit parallel processing, for example. The segments 308 can also be subsets of frames that can separate the video data into separate colors. For example, the frame 306 of color video data can include a luminance plane and two chrominance planes. The segments 308 may be sampled at different resolutions.
[0041] Whether or not the frame 306 is divided into the segments 308, the frame 306 may be further subdivided into blocks 310, which can contain data corresponding to, for example, 16x16 pixels in frame 306. The blocks 310 can also be arranged to include data from one or more planes of pixel data. The blocks 310 can also be of any other suitable size such as 4x4 pixels, 8x8 pixels, 16x8 pixels, 8x16 pixels, 16x16 pixels or larger. Unless otherwise noted, the terms block and macroblock are used interchangeably herein.
[0042] FIG. 4 is a block diagram of an encoder 400 in accordance with an
implementation. The encoder 400 can be implemented, as described above, in the
transmitting station 102 such as by providing a computer software program stored in memory, for example, the memory 204. The computer software program can include machine instructions that, when executed by a processor such as the CPU 202, cause the transmitting station 102 to encode video data in the manner described in FIG. 4 and in FIG. 6, below. The encoder 400 can also be implemented as specialized hardware included in, for example, the transmitting station 102. The encoder 400 has the following stages to perform the various functions in a forward path (shown by the solid connection lines) to produce an encoded or compressed bitstream 420 using the video stream 300 as input: an intra/inter prediction stage 402, a transform stage 404, a quantization stage 406, and an entropy encoding stage 408. The encoder 400 may also include a reconstruction path (shown by the dotted connection lines) to reconstruct a frame for encoding of future blocks. In FIG. 4, the encoder 400 has the following stages to perform the various functions in the reconstruction path: a dequantization
stage 410, an inverse transform stage 412, a reconstruction stage 414, and a loop filtering stage 416. Other structural variations of the encoder 400 can be used to encode the video stream 300.
[0043] When the video stream 300 is presented for encoding, each frame 306 can be processed in units of blocks. At the intra/inter prediction stage 402, each block can be encoded using intra-frame prediction (also called intra-prediction) or inter-frame prediction (also called inter-prediction), or a combination both. In any case, a prediction block can be formed. In the case of intra-prediction, all or a part of a prediction block may be formed from samples in the current frame that have been previously encoded and reconstructed. In the case of inter-prediction, all or part of a prediction block may be formed from samples in one or more previously constructed reference frames determined using motion vectors.
[0044] Next, still referring to FIG. 4, the prediction block can be subtracted from the current block at the intra/inter prediction stage 402 to produce a residual block (also called a residual). The transform stage 404 transforms the residual into transform coefficients in, for example, the frequency domain using block-based transforms. Such block-based transforms include, for example, the Discrete Cosine Transform (DCT) and the Asymmetric Discrete Sine Transform (ADST). Other block-based transforms are possible. Further, combinations of different transforms may be applied to a single residual. In one example of application of a transform, the DCT transforms the residual block into the frequency domain where the transform coefficient values are based on spatial frequency. The lowest frequency (DC) coefficient at the top-left of the matrix and the highest frequency coefficient at the bottom- right of the matrix. It is worth noting that the size of a prediction block, and hence the resulting residual block, may be different from the size of the transform block. For example, the prediction block may be split into smaller blocks to which separate transforms are applied.
[0045] The quantization stage 406 converts the transform coefficients into discrete quantum values, which are referred to as quantized transform coefficients, using a quantizer value or a quantization level. For example, the transform coefficients may be divided by the quantizer value and truncated. The quantized transform coefficients are then entropy encoded by the entropy encoding stage 408. Entropy coding may be performed using any number of techniques, including token and binary trees. The entropy-encoded coefficients, together with other information used to decode the block, which may include for example the type of prediction used, transform type, motion vectors and quantizer value, are then output to the compressed bitstream 420. The information needed to decode the block may be entropy coded into block, frame, slice and/or section headers within the compressed bitstream 420.
The compressed bitstream 420 can also be referred to as an encoded video stream or encoded video bitstream, and the terms will be used interchangeably herein.
[0046] The reconstruction path in FIG. 4 (shown by the dotted connection lines) can be used to ensure that both the encoder 400 and a decoder 500 (described below) use the same reference frames and blocks to decode the compressed bitstream 420. The reconstruction path performs functions that are similar to functions that take place during the decoding process that are discussed in more detail below, including dequantizing the quantized transform coefficients at the dequantization stage 410 and inverse transforming the dequantized transform coefficients at the inverse transform stage 412 to produce a derivative residual block (also called a derivative residual). At the reconstruction stage 414, the prediction block that was predicted at the intra/inter prediction stage 402 can be added to the derivative residual to create a reconstructed block. The loop filtering stage 416 can be applied to the reconstructed block to reduce distortion such as blocking artifacts.
[0047] Other variations of the encoder 400 can be used to encode the compressed bitstream 420. For example, a non-transform based encoder 400 can quantize the residual signal directly without the transform stage 404 for certain blocks or frames. In another implementation, an encoder 400 can have the quantization stage 406 and the dequantization stage 410 combined into a single stage.
[0048] FIG. 5 is a block diagram of a decoder 500 in accordance with another
implementation. The decoder 500 can be implemented in the receiving station 106, for example, by providing a computer software program stored in the memory 204. The computer software program can include machine instructions that, when executed by a processor such as the CPU 202, cause the receiving station 106 to decode video data in the manner described in FIG. 5 and in FIG. 8 below. The decoder 500 can also be implemented in hardware included in, for example, the transmitting station 102 or the receiving station 106.
[0049] The decoder 500, similar to the reconstruction path of the encoder 400 discussed above, includes in one example the following stages to perform various functions to produce an output video stream 516 from the compressed bitstream 420: an entropy decoding stage 502, a dequantization stage 504, an inverse transform stage 506, an intra/inter-prediction stage 508, a reconstruction stage 510, a loop filtering stage 512 and a deblocking filtering stage 514. Other structural variations of the decoder 500 can be used to decode the
compressed bitstream 420.
[0050] When the compressed bitstream 420 is presented for decoding, the data elements within the compressed bitstream 420 can be decoded by the entropy decoding stage 502 to
produce a set of quantized transform coefficients. The dequantization stage 504 dequantizes the quantized transform coefficients (e.g., by multiplying the quantized transform coefficients by the quantizer value), and the inverse transform stage 506 inverse transforms the dequantized transform coefficients using the selected transform type to produce a derivative residual that can be identical to that created by the inverse transform stage 412 in the encoder 400. Using header information decoded from the compressed bitstream 420, the decoder 500 can use the intra/inter-prediction stage 508 to create the same prediction block as was created in the encoder 400, e.g., at the intra/inter prediction stage 402. At the reconstruction stage 510, the prediction block can be added to the derivative residual to create a reconstructed block. The loop filtering stage 512 can be applied to the reconstructed block to reduce blocking artifacts. Other filtering can be applied to the reconstructed block. In this example, the deblocking filtering stage 514 is applied to the reconstructed block to reduce blocking distortion, and the result is output as an output video stream 516. The output video stream 516 can also be referred to as a decoded video stream, and the terms will be used
interchangeably herein.
[0051] Other variations of the decoder 500 can be used to decode the compressed bitstream 420. For example, the decoder 500 can produce the output video stream 516 without the deblocking filtering stage 514.
[0052] As mentioned briefly above, a block may be encoded or decoded by motion vector prediction a dynamic reference motion vector coding mode. One implementation of using the dynamic reference motion vector coding mode for encoding and decoding is next discussed.
[0053] FIG. 6 is a flow diagram showing a process 600 for encoding a video stream using reference motion vectors in accordance with an implementation of this disclosure. Process 600 can be implemented in an encoder such as encoder 400 and can be implemented, for example, as a software program that can be executed by computing devices such as transmitting station 102 or receiving station 106. For example, the software program can include machine-readable instructions that can be stored in a memory such as memory 204 or 214, and that can be executed by a processor, such as CPU 202, to cause the computing device to perform process 600.
[0054] The process 600 can be implemented using specialized hardware or firmware. Some computing devices can have multiple memories, multiple processors, or both. The steps or operations of the process 600 can be distributed using different processors, memories, or both. Use of the terms "processor" or "memory" in the singular encompasses computing devices that have one processor or one memory as well as devices that have multiple
processors or multiple memories that can each be used in the performance of some or all of the recited steps. For simplicity of explanation, process 600 is depicted and described as a series of steps or operations. However, the teachings in accordance with this disclosure can occur in various orders and/or concurrently. Additionally, steps in accordance with this disclosure may occur with other steps not presented and described herein. Furthermore, not all illustrated steps or operations may be required to implement a method in accordance with the disclosed subject matter.
[0055] The process 600 assumes that a stream of video data having multiple frames, each having multiple blocks, is being encoded using a video encoder such as encoder 400 executing on a computing device such as transmitting station 102. The video data or stream can be received by the computing device in any number of ways, such as by receiving the video data over a network, over a cable, or by reading the video data from a primary memory or other storage device, including a disk drive or removable media such as a CompactFlash (CF) card, Secure Digital (SD) card, or any other device capable of communicating video data. In some implementations, video data can be received from a video camera connected to the computing device operating the encoder. At least some of the blocks within frames are encoded using inter prediction as described in more detail below.
[0056] At 602, the process 600 identifies candidate motion vectors from previously coded blocks in the video stream. The process 600 analyzes the motion activity of previously coded blocks to produce a list of ranked candidate motion vectors, employing an efficient reference motion vector ranking system, and provides a dynamic motion referencing mode that fully accounts for the available motion vector candidate list, which allows the number of the reference motion vector modes to be dynamically extended or shortened and improves the efficacy of entropy coding. The pool of the candidate motion vectors can be dynamically extended or shortened according to the neighboring reference block condition, i.e., how the list of candidate motion vectors is created. The previously coded blocks in the video stream can include any block encoded using inter-prediction before the current block, such as a block from a previously coded frame or a block from the same frame as the current block that has been encoded before the current block. For example, in some encoding/decoding (codec) schemes such as ones that code in raster scan order, the previously coded blocks can include a block above, to the left, or to the above-left of the current block in the same frame. The previously coded blocks can also include, for example, a block from the immediately previous frame (i.e., last frame), a block from the golden frame (described at intra/inter prediction stage 402), a block from any other reference frame, or any combination thereof.
Desirably, however, the candidate motion vectors are obtained from previously coded blocks that correspond in some way to the current block based on the theory that such blocks, due to the proximity of their pixels to the current block, are likely to have similar motion
characteristics to the current block.
[0057] Blocks may be predicted from a single reference frame or compound, such as two, reference frames. For blocks with a single reference frame, the process 600 identifies candidate motion vectors from the nearest spatial neighboring blocks that are associated with the reference frame. The candidate motion vectors may include the motion vector reference blocks within a reference coverage area, such as the motion vector(s) from a boundary area (e.g., a block) above the current block, the motion vector(s) from a boundary area (e.g., a block) to the left of the current block, the motion vector from a top-right corner of the current block, and the motion vector(s) from a collocated block in the previous frame. In certain implementations, motion vectors associated with blocks below and to the right of the collocated block are considered.
[0058] This initial step of constructing a reference motion vector candidate list is described with reference to FIG. 7. That is, FIG. 7 is a diagram of a sequence of frames used to explain the identification of candidate motion vectors of 602 within the process 600 of FIG. 6. The current block B being encoded is located within current Frame N. Frame N-l is the preceding frame, also called a temporally adjacent frame, which may be the reconstructed frame stored in a so-called last reference frame buffer that is available for coding blocks of Frame N. In this case, block R3 is the collocated block to the current block B, and it is located at the same pixel location (usually measured from the top-left pixel) and has the same pixel dimensions in the x- and y- planes (i.e., the same pixel coordinates) within Frame N-l as the current block B has within Frame N. Stated another way, the block R3 spatially corresponds to the current block B. In a single reference mode, i.e., where the current block B is being inter-predicted using a single reference frame, the motion vector candidate buffer is associated with the reference frame. Given the reference frame index, a search for motion vectors associated with the same reference frame may be performed through the reference blocks shown in FIG. 7 for inclusion in the candidate list.
[0059] The blocks B and R3 are of an arbitrary block size. For example, the blocks B and R3 may each be 32z32 pixels. As mentioned above, each frame may be partitioned into blocks for coding. Those blocks may be further partitioned into smaller blocks for coding purposes. For this reason, any block or region adjacent to the current block B may have been partitioned into smaller blocks that are predicted by different motion vectors. Therefore, the
search for motion vectors may be take this into consideration by assessing the motion information for the smallest possible prediction block size within a frame. In the example shown, the search for motion vectors in the current frame is done using motion information from a top row boundary region, also called block RO, a left column boundary region, also called block Rl, and the top-right corner, also call block R2. The blocks RO and Rl are regions whose size (dimensions) is related to the size of the current block B. In some cases, the blocks RO and Rl are of the same size as the current block B, but they may be half the size of the current block B or otherwise relate to the size of the current block B. In any case, each sub-block of pixels, e.g., having the smallest prediction block size within blocks RO and Rl can be scanned through for candidate motion vectors. For example, the smallest prediction block size may be 8x8 or 4x4. The block R2 is desirably the smallest prediction block size to minimize searching and because more distant blocks are likely to provide less relevant information. The block R2 would only have one motion vector (or two in combined prediction) if the block R2 is the smallest prediction block size. The block R2 may be larger in size in an implementation.
[0060] The search for motion vectors in the last frame is done using motion information from the collocated block R3, and the additional reference blocks R4, R5, R6, and R7 adjacent to the bottom row (blocks R6, R7), the right column (R4), or both (R5). That is, they each proximate to (e.g., in contact with) a corner of the collocated block. As mentioned, the collocated block R3 has the same size as the current block. Each sub-block of the smallest prediction block size within the collocated block R3 may be scanned or searched for candidate motion vectors. In the example shown, the additional reference blocks R4, R5, R6, and R7 respectively have the smallest prediction block size regardless of the size of the current block B, but this is not required.
[0061] Returning now to FIG. 6, once the reference motion vectors are obtained at 602 they can be ranked according to the distance from the corresponding reference block and its overlapped length with the current block at 604. Stated another way, the process 600 may determine, for each candidate motion vector, a distance between the previously coded block associated with the candidate motion vector and the current block. The motion vectors from the nearest row and column boundaries and the top-right corner to the current block are in contact with the current block and may be considered to be more relevant and so are ranked higher than those further away. The distance may be used to group the motion vectors into categories. For example, and with reference to FIG. 7, any motion vectors from the sub- blocks of the reference blocks R0 and Rl, and a motion vector from the reference block R2,
if any, may be considered as category 1 candidate motion vectors, while the remaining candidate motion vectors from the blocks R3 through R7 and from any other sub-blocks of the reference blocks R0 and Rl are considered to be category 2 candidate motion vectors. In this case, category 1 candidate motion vectors would assume a higher priority than category 2 candidate motion vectors. The distance may additionally or alternatively include calculating a straight line distance between the centers of the current block and each of the reference blocks and/or sub-blocks of the reference blocks. The distance between the reference block and the current block can be based on the spatial displacement between the pixels in the previously coded block and the collocated pixels in the current block, measured in the unit of pixels. In these latter examples, a collocated block may be ranked higher than reference blocks in a current frame (e.g., because the difference/displacement is zero), even when popularity values are considered. Other ways of grouping and/or ranking the motion vectors based on distance are possible.
[0062] When the motion vectors are grouped by category, within each category the motion vectors may be ranked according to the number of pixels within the search areas (e.g., the previously coded pixels of at least some of the reference blocks) that are using each motion vector. For example, the process 600 may determine a popularity value based on the previously coded pixel values associated with the particular candidate motion vector at 606. The larger the number of previously coded pixel values associated with the candidate motion vector, the higher the popularity value of the candidate motion vector. The popularity value may be a raw number of pixels or a percentage of the total number of pixels within all or some of the reference blocks, for example.
[0063] This can be described with reference to the example of FIG. 7 assuming that the current block B and the collocated block R3, each comprise 32x32 pixels, the reference block R0 and the reference block Rl respectively comprise 32x16 and 16x32 pixels, and the reference blocks R2 and R4-R7 each comprise 8x8 pixels, which also corresponds to the smallest prediction block size. In this case, there could be up to nine motion vector candidates associated with a reference frame and assigned to category 1, four each from the 8x8 sub- blocks of reference blocks R0 and Rl adjacent to the current block B and one from the 8x8 reference block R2. There could be up to twenty-eight motion vectors associated with the reference frame and assigned to category 2, four each from the remaining 8x8 sub-blocks of the reference blocks R0 and Rl, sixteen from the collocate block R3, and one each from the additional four 8x8 reference blocks R4-R7. In actuality, motion vectors are often re-used. Each of the unique motion vectors within a category from all of those identified is attributed
with a popularity value corresponding to each of the groups of 8x8 pixels (that is, 64 pixels) using that motion vector. In assessing whether a motion vector that is identified at 602 is unique, the motion vector does not have to be identical to another. Ranges can be used so as to provide a motion vector candidate list demonstrating sufficient variation to useful. That is, a motion vector may be omitted within a category if it does not vary enough from a motion vector candidate already in a category, such as by 10% or some other variable. In this implementation, motion vectors are ranked by category and then ranked within the categories, but this is not required. The motion vector candidates may be grouped together for ranking based on the popularity value.
[0064] The reference motion vector candidate list may be constructed as described for each unique reference frame associated with a previously coded block or sub-block. For example, three reference frames may be available for each frame as described above— a last frame, an alternative (or alternate or alt) reference frame, and a golden reference frame. In this case, separate reference motion vector candidate list may be constructed using those previously coded blocks or sub-blocks having motion vectors pointing each of the last frame, the alt reference frame, and the golden reference frame. The last frame is updated for each frame, and the alt reference frame and golden reference frame may be updated less frequently.
[0065] In some implementations, motion vector scaling is performed when constructing a reference motion vector candidate list. Motion vector scaling may be done as part of the determination of a popularity value at 606, or may be done at other points in the process 600. Motion vector scaling adjusts the magnitude of a motion vector to account for the temporal differences between reference frames relative to the frame under consideration within the sequence of frames within the video stream. For example, and again with reference to FIG. 7, the reference block R2 uses the last frame, which is Frame N-1, for inter-prediction, while the reference block R4 uses the last frame, which is the frame preceding Frame N-1 (or Frame N- 2, not shown), for inter-prediction. The temporal difference between the frame in which each block R2 and R4 is located (Frame N and Frame N-1, respectively) and the corresponding reference frame (Frame N- 1 and Frame N-2, respectively) is one frame, so no scaling is indicated. In contrast, if the reference blocks R2 and R4 both use the golden reference frame, the temporal differences between Frame N and the golden reference frame and the between the Frame N- 1 and the golden reference frame are different if the golden reference frame is unchanged. A candidate motion vector can be generated by scaling up the magnitude of the motion vector associated with the shorter temporal difference or scaling down the magnitude
of the motion vector associated with the longer temporal differences so that the motion vectors share a common basis. The factor used for scaling can be based on a ratio formed by the temporal differences.
[0066] Motion vector scaling may also be used in implementations where only one reference motion vector candidate list is prepared for all reference frames, instead of separate lists for each reference frame. Reference frames may be located either before or after the current frame in the video sequence. In some implementations, motion vector scaling is omitted.
[0067] Thus far, candidate list construction for a single reference mode where one reference frame (and thus typically one motion vector associated with the one reference frame) is used for inter-prediction. In some cases, however, a block may be predicted from two or more reference frames, where the pixel values are combinations of the pixels values from prediction blocks within each frame generated by respective motion vectors. When considering a compound reference mode for prediction of the current block, the list is constructed by first looking for neighboring blocks that share the same compound reference frames (i.e., the same combination of reference frames) for their reference motion vectors. A higher priority is assigned to candidate motion vectors from neighboring reference blocks that share the combination of reference frames as that under consideration for the current block. The motion vectors may also be ranked from highest to lowest popularity value. If the resulting candidate list has a length shorter than a defined number, such as two, the list may be appended with combinations of reference motion vectors of single reference frames that are identified and ranked as described above. For example, if a compound reference mode that uses the last frame and the alt reference frame is under consideration, the reference blocks are searched for motion vectors referencing either the last frame or the alt reference frame, which are then ranked based on a popularity value as discussed.
[0068] Referring again to FIG. 6, and as explained above, the determination of the popularity values at 608 includes ranking the motion vectors using the popularity values. It can also include assigning the motion vectors to inter-coding (or inter-prediction) modes based on the ranking. The most popular motion vector may be selected for an inter-prediction mode that includes differential coding of a new motion vector. This may be referred to as a NEWMV mode. Then, according to the ranking results, the remaining motion vectors may be assigned to other reference vector motion modes. In some implementations, a REFMV mode is a dynamic reference motion vector coding mode that includes at least two modes where an existing motion vector is re-used. In an example, these two inter-prediction modes are a
NEARESTMV mode and a NEARMV mode. The next motion vector in the ranking after the one assigned to the NEWMV mode (i.e., the motion vector with the second highest popularity value) is assigned to the NEARESTMV mode, and the next motion vector after that (i.e., the motion vector with the third highest popularity value) is assigned to the
NEARMV mode. If the candidate reference motion vector list for a particular reference frame is longer than two, the number of reference motion vector modes may be extended to accommodate the remaining entries in the list. Another available inter-prediction mode may be a ZEROMV mode, which means that no motion exists.
[0069] At 608, an inter-prediction mode is selected for the current block. This may include testing each of the inter-prediction modes and selecting the inter-prediction mode that results in the most efficient coding of the current block. For example, the process 600 may be part of a rate-distortion loop used to select the inter-prediction mode for the current block to be encoded. As part of the rate-distortion loop, an actual motion vector for inter prediction of the current block may be determined through a motion search according to any number of motion searching techniques. For each reference frame, one use of the reference motion vector may include using the reference motion vector assigned to the NEWMV mode or one of the other identified candidate motion vectors as a starting parameter for the motion search algorithm based on the reasoning that the actual motion vector is likely to be close to highly ranked motion vectors for the reference frame. Combinations of reference frames in a compound prediction mode may be similarly searched using motion vectors from the candidate list, particularly those having the highest rank for each of the reference frames.
[0070] Motion searches may alternatively be performed without using motion vectors from the candidate lists. Whether or not a reference motion vector is used in the motion search, various inter-prediction modes may be tested. In one implementation, an exhaustive motion search that attempts each of the available inter-prediction modes using single or compound modes (i.e., using each of the three reference frames and combinations of reference frames). For each proposed motion vector and for each tested inter-prediction mode, a bit cost (also called a rate) of encoding the current block using the inter-prediction mode, including the bits required to signal the inter-prediction mode, the reference frame(s), the residual block generated from the current block, and, if required, one or more motion vector(s) or motion vector differential(s), and the resulting error in the pixel values between the original values and the reconstructed values (also called a distortion) are calculated. The inter-prediction mode and reference frame(s) resulting in the lowest rate-distortion value (also called a ratio) may be selected as the inter-prediction mode for the current block at 608.
[0071] An exhaustive search does not need to be performed. Various techniques may be used to reduce the computational burden. For example, the inter-prediction modes used for adjacent blocks in the frames may be tested first, and then only certain inter-prediction modes may be tested to see if an improved rate-distortion ratio results. Further, motion searching is applicable to inter-prediction. The rate-distortion loop may include tests for various intra- prediction modes, or a separate rate-distortion loop may be used to select the most efficient intra-prediction mode from available intra-prediction modes. Then, the most efficient inter- prediction mode and the most efficient intra-prediction mode are compared to select the prediction mode for the block.
[0072] Assuming here that the inter-prediction mode selected at 608 is better than the available intra-prediction modes, the current block is encoded at 610 using the inter- prediction mode. For example, if the NEWMV mode is used to encode the current block, the predicted block is generated using the actual motion vector(s) from the motion search and the selected reference frame(s). Then, the residual between the current block and the predicted block is generated and encoded as described with reference to FIG. 4. The motion vector(s) assigned to the NEWMV mode by the ranking can be used to differentially encode the actual motion vector(s). For example, a difference value or residual can be calculated by subtracting a reference motion vector from a motion vector used to encode the current block. The difference value can be encoded and included in the video stream. In addition, bits indicating the reference frame(s) and that the NEWMV mode was used may be indicated in the block header and/or in a frame or slice header.
[0073] In another example with a single reference frame, the motion search results in a motion vector equal to or within a range of values about one of the reference motion vectors assigned to reference motion vector modes. In this case the REFMV inter-prediction mode is indicated. If the motion vector resulting from the search is equal to or within a range of values about the reference motion vector assigned to the NEARMV mode in this example, the predicted block is generated using the reference motion vector assigned to the NEARMV mode and the selected reference frame. Then, the residual between the current block and the predicted block is generated and encoded as described with reference to FIG. 4. In addition, bits indicating the reference frame and that the REFMV mode and particularly the NEARMV mode was used may be indicated in the block header and/or in a frame or slice header.
[0074] The remaining inter-prediction modes may similarly be used to encode the current block, if selected at 608, or to encode other blocks of the frames within a video sequence. The process 600 of FIG. 6 may be repeated as needed.
[0075] As mentioned with respect to operation of the encoder 400 of FIG. 4, encoding the current block may include entropy coding. Entropy coding the inter-prediction modes may be modified to take into account the new dynamic reference motion vector modes. Assuming three inter-prediction modes corresponding to a new motion vector, a zero motion vector, and a dynamic reference motion vector mode, respectively the NEWMV mode, the ZEROMV mode, and REFMV mode in this example, entropy coding starts with the NEWMV mode. That is, assuming the current block is encoded using the NEWMV mode, the probability model may be selected according to two contexts: 1) how many reference motion vectors are found; and 2) if neighboring block(s) with a matched reference frame is found, how likely they are to be coded in the NEWMV mode.
[0076] If the next coding mode is not the NEWMV mode, coding continues if the next coding mode is the ZEROMV mode. In this case, the probability model may be selected according to two contexts: 1) if the collocated block in the last (or previous) frame using a zero motion vector, or close to a zero motion vector (i.e., less than one full pixel in both row and column components); and 2) whether (and possibly how many of) the spatial neighboring blocks within the current frame are using zero motion vectors, or close to zero motion vectors.
[0077] If instead the next coding mode is not the ZEROMV mode (i.e., is the dynamic reference motion vector mode indicated by the REFMV mode), a decision is made between the reference motion vectors as discussed above. The associated context is how many reference motion vectors are checked into the candidate list and, when applicable, their weighting coefficients used in compound prediction.
[0078] FIG. 8 is a flowchart diagram of a process 800 for decoding an encoded video stream using reference motion vectors in accordance with implementations of this disclosure. The process 800 can be implemented, for example, as a software program that may be executed by computing devices such as transmitting station 102 or receiving station 106. For example, the software program can include machine-readable instructions that may be stored in a memory such as memory 204 or 214, and that, when executed by a processor, such as CPU 202, may cause the computing device to perform the process 800. The process 800 can be implemented using specialized hardware or firmware. As explained above, some computing devices may have multiple memories or processors, and the operations described in the process 800 can be distributed using multiple processors, memories, or both.
[0079] For simplicity of explanation, the process 800 is depicted and described as a series of steps or operations. However, the steps or operations in accordance with this disclosure
can occur in various orders and/or concurrently. Additionally, other steps or operations not presented and described herein may be used. Furthermore, not all illustrated steps or operations may be required to implement a method in accordance with the disclosed subject matter.
[0080] At 802, the decoder determines whether the current block was encoded using single or compound prediction. This information can be communicated by reading and decoding bits from an encoded video bitstream that indicate the one or more than one motion vectors was used to encode the current block. The encoded bitstream (or encoded video data) may be received by a decoder of a computing device in any number of ways, such as by receiving the video data over a network, over a cable, or by reading the video data from a primary memory or other storage device, including a disk drive or removable media such as a DVD, CompactFlash (CF) card, Secure Digital (SD) card, or any other device capable of communicating a video stream. This information can be included in a header associated with a current block or a frame header, for example. This explanation assumes that the current block is inter-predicted. Otherwise, no reference frame is encoded into the bitstream in association with the current block, and the current block was intra-predicted.
[0081] Knowing the reference frame(s), the candidate motion vectors can be ranked in a similar manner as described with reference to the process 600 of FIG. 6. That is, the encoder and decoder can share rules regarding the generation of reference motion vector candidate lists so that the decoder, receiving header information related to which inter-prediction mode was used to encode the current block (e.g., NEWMV, NEARESTMV, NEARMV, etc.), is able to identify the same reference motion vector(s) used by the encoder. First, the candidate motion vectors can be identified from previously coded blocks at 804 in a like manner as they are identified at 602 in the process 600. While the process 600 may identify the candidate motion vectors for ranking using all available reference frames and combinations of reference frames in order to select the inter-prediction mode, the process 800 only needs to rank those candidate motion vectors for the reference frame(s) actually to encode the block.
[0082] After the candidate motion vectors are identified at 804, they are ranked at 806 and 808. More specifically, ranking the candidate motion vectors includes determining, for each candidate motion vector, the distance between the previously coded block that is the source of the motion vector and the current block at 806. This involves the same operations as those described above with respect to the determination at 604 in the process 600. The result of this operation is a list of candidate motion vectors grouped by the distance in an embodiment. Then, determining a respective popularity value for the candidate motion
vectors from previously coded blocks at 804 is performed the same as the determination at 606 in the process 600. The result of this operation is a ranked list of candidate motion vectors for the single reference frame or the combined reference frames used in the prediction of the current block. In one implementation, the highest ranked (e.g., most probable) motion vector is assigned to a NEWMV mode, and the next two motion vectors in the ranking are assigned respectively to the NEARESTMV and NEARMV reference motion vector modes of the dynamic reference motion vector (REFMV) mode. Any further reference motion vectors are assigned in sequence thereafter.
[0083] At 810, the inter-prediction mode that was used to encode the current block is identified. In one implementation, the inter-prediction mode is identified by decoding bits included within the bitstream that identify the inter-prediction mode. For example, the inter- prediction mode may be the new motion vector mode, the zero motion vector mode, or the dynamic reference motion vector mode. If the inter-prediction mode is the dynamic reference motion vector mode, the particular reference motion vector mode used can be similarly determined, e.g., from bits included within header(s) in the bitstream.
[0084] At 812, the inter-prediction mode identified at 810 is used to decode the current block at 812, such as through the decoding process described with reference to FIG. 5. When the inter-prediction mode involves a differentially- encoded motion vector, for example, the reference motion vector can be used to decode the motion vector used to predict the current block. Alternatively, the inter-prediction mode may indicate the motion vector by reference to the list. Regardless of the source of the one or more motion vectors, the prediction block is generated using the motion vector(s) and is added to the residual for the current block decoded from the bitstream.
[0085] The process 800 may be repeated for each block that is encoded using inter- prediction to generate a reconstructed block. The frame is reconstructed using the
reconstructed blocks and those reconstructed using intra-prediction. By decoding a plurality of frames, an output video stream, such as the output video stream 516 shown in FIG. 5, can be reconstructed.
[0086] Use of the syntax within the bitstream for the REFMV mode suggests that the effective motion vector comes from referencing neighboring blocks' coding information. Given the reference frame, a list of such possible reference motion vector candidates are ranked according to their relative distance to the current block and their relative use. This technique generalizes the REFMV modes (NEARESTMV and NEARMV, for example) and improves the efficiency of entropy coding. Further, the additional motion vector candidates
can result in further compression gains.
[0087] The aspects of encoding and decoding described above illustrate some encoding and decoding techniques. However, it is to be understood that encoding and decoding, as those terms are used in the claims, could mean compression, decompression, transformation, or any other processing or change of data.
[0088] The word "example," "aspect," or "implementation" is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as using one or more of these words is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather, use of the word "example," "aspect," or "implementation" is intended to present concepts in a concrete fashion. As used in this application, the term "or" is intended to mean an inclusive "or" rather than an exclusive "or". That is, unless specified otherwise, or clear from context, "X includes A or B" is intended to mean any of the natural inclusive permutations. That is, if X includes A; X includes B; or X includes both A and B, then "X includes A or B" is satisfied under any of the foregoing instances. In addition, the articles "a" and "an" as used in this application and the appended claims should generally be construed to mean "one or more" unless specified otherwise or clear from context to be directed to a singular form. Moreover, use of the term "an implementation" or "one implementation" throughout is not intended to mean the same embodiment, aspect or implementation unless described as such.
[0089] Implementations of transmitting station 102 and/or receiving station 106 (and the algorithms, methods, instructions, etc., stored thereon and/or executed thereby, including by encoder 400 and decoder 500) can be realized in hardware, software, or any combination thereof. The hardware can include, for example, computers, intellectual property (IP) cores, application-specific integrated circuits (ASICs), programmable logic arrays, optical processors, programmable logic controllers, microcode, microcontrollers, servers, microprocessors, digital signal processors or any other suitable circuit. In the claims, the term "processor" should be understood as encompassing any of the foregoing hardware, either singly or in combination. The terms "signal" and "data" are used interchangeably. Further, portions of transmitting station 102 and receiving station 106 do not necessarily have to be implemented in the same manner.
[0090] Further, in one aspect, for example, transmitting station 102 or receiving station 106 can be implemented using a general purpose computer or general purpose processor with a computer program that, when executed, carries out any of the respective methods, algorithms and/or instructions described herein. In addition or alternatively, for example, a
special purpose computer/processor can be utilized which can contain other hardware for carrying out any of the methods, algorithms, or instructions described herein.
[0091] Transmitting station 102 and receiving station 106 can, for example, be implemented on computers in a video conferencing system. Alternatively, transmitting station 102 can be implemented on a server and receiving station 106 can be implemented on a device separate from the server, such as a hand-held communications device. In this instance, transmitting station 102 can encode content using an encoder 400 into an encoded video signal and transmit the encoded video signal to the communications device. In turn, the communications device can then decode the encoded video signal using a decoder 500.
Alternatively, the communications device can decode content stored locally on the communications device, for example, content that was not transmitted by transmitting station 102. Other transmitting station 102 and receiving station 106 implementation schemes are available. For example, receiving station 106 can be a generally stationary personal computer rather than a portable communications device and/or a device including an encoder 400 may also include a decoder 500.
[0092] Further, all or a portion of implementations of the present disclosure can take the form of a computer program product accessible from, for example, a tangible computer- usable or computer-readable medium. A computer-usable or computer-readable medium can be any device that can, for example, tangibly contain, store, communicate, or transport the program for use by or in connection with any processor. The medium can be, for example, an electronic, magnetic, optical, electromagnetic, or a semiconductor device. Other suitable mediums are also available.
[0093] The above-described embodiments, implementations and aspects have been described in order to allow easy understanding of the present disclosure and do not limit the present disclosure. On the contrary, the disclosure is intended to cover various modifications and equivalent arrangements included within the scope of the appended claims, which scope is to be accorded the broadest interpretation so as to encompass all such modifications and equivalent structure as is permitted under the law.
Claims
1. A method for decoding a video stream including a processor, the method comprising:
identifying, for a current block, a reference frame used to encode the current block within a current frame;
creating a reference motion vector candidate list for the reference frame using reference blocks within at least one frame of the video stream;
ranking each motion vector within the reference motion vector candidate list by a distance from the current block to a reference block providing the motion vector, and by a popularity value of the motion vector that indicates a level of use of the motion vector by at least some of the reference blocks;
assigning the motion vectors to a plurality of inter-prediction modes based on the ranking;
selecting an inter-prediction mode for decoding the current block; and
decoding the current block using the inter-prediction mode.
2. The method of claim 1, wherein the larger a number of previously coded pixel values within the at least some of the reference blocks using a motion vector within the reference motion vector candidate list, the higher the popularity value of the motion vector.
3. The method of claim 1, wherein the popularity value comprises a raw number of previously coded pixels within the reference block using a motion vector within the reference motion vector candidate list.
4. The method of any preceding claim, further comprising:
determining whether the current block was encoded using single or compound prediction;
in response to determining that the current block was encoded using compound prediction:
identifying the reference frame used to encode the current block comprises identifying a first reference frame and a second reference frame used to encode the current block; and
creating the reference motion vector candidate list for the reference frame comprises creating a first reference motion vector candidate list for the first reference frame and creating a second reference motion vector list for the second reference frame using the reference blocks.
5. The method of any preceding claim, wherein assigning the motion vectors comprises:
assigning a motion vector having a highest popularity value in the ranking to an inter- prediction mode that includes differential coding of a new motion vector.
6. The method of claim 5, wherein assigning the motion vectors comprises: assigning a motion vector having a second highest popularity value to a dynamic reference motion vector inter-prediction mode as a first motion vector; and
assigning a motion vector having a third highest popularity value to the dynamic reference motion vector inter-prediction mode as a second motion vector.
7. The method of claim 6, wherein the first motion vector is assigned to a NEARESTMV mode, and the second motion vector is assigned to a NEARMV mode.
8. The method of any preceding claim, further comprising:
for each motion vector within the reference motion vector candidate list, determining the distance from the current block to the reference block providing the motion vector, wherein ranking each motion vector comprises:
grouping those of the motion vectors from any of the reference blocks in the current frame into a first category of candidate motion vectors; and
grouping any remaining motion vectors into a second category of candidate motion vectors; and
ranking the first category of candidate motion vectors ahead of the second category of candidate motion vectors in the reference motion vector candidate list.
9. The method of claim 8, wherein ranking each motion vector comprises:
within the first category of candidate motion vectors, ranking based on respective popularity values; and
within the second category of candidate motion vectors, ranking based on respective popularity values.
10. An apparatus for decoding a video stream, comprising:
a processor; and
a memory storing instructions that cause the processor to perform a method comprising:
identifying, for a current block, a reference frame used to encode the current block within a current frame;
creating a reference motion vector candidate list for the reference frame using reference blocks, the reference blocks including spatially adjacent blocks of the current frame, a collocated block within a previous frame, and spatially adjacent blocks of the collocated block within the previous frame;
ranking each motion vector within the reference motion vector candidate list by a distance from the current block to a reference block providing the motion vector, and by a popularity value of the motion vector that indicates a level of use of the motion vector by the reference blocks;
assigning the motion vectors to a plurality of inter-prediction modes based on the ranking;
selecting an inter-prediction mode for decoding the current block; and decoding the current block using the inter-prediction mode.
11. The apparatus of claim 10, wherein the instructions for decoding the current block comprise instructions for decoding the current block using a motion vector assigned to the inter-prediction mode to inter-predict the current block.
12. The apparatus of claim 10 or 11, wherein the popularity value comprises a percentage of a total number of previously coded pixels within the reference block using a motion vector within the reference motion vector candidate list.
13. The apparatus any of claims 10 to 12, wherein the reference frame is a first reference frame of at least two available reference frames, and the instructions for creating a reference motion vector candidate list for the reference frame comprise instructions for creating a single motion vector candidate list for the at least two available reference frames.
14. The apparatus of claim 13, wherein the instructions further comprise instructions for:
determining a first temporal difference between the current frame and the first reference frame;
determining a second temporal difference between the current frame and a second reference frame of the at least two available reference frames;
including a first motion vector associated with the first reference frame in the reference motion vector candidate list; and
responsive to the first temporal difference being longer than the second temporal difference, scaling up a magnitude of a second motion vector associated with the second reference frame for inclusion in the reference motion vector candidate list; and
responsive to the first temporal difference being shorter than the second temporal difference, scaling down a magnitude of a second motion vector associated with the second reference frame for inclusion in the reference motion vector candidate list.
15. The apparatus of any of claims 10 to 14, wherein the reference blocks include spatially adjacent blocks of the current frame, a collocated block within a previous frame, and spatially adjacent blocks of the collocated block within the previous frame.
16. The apparatus of claim 15, wherein the spatially adjacent blocks of the collocated block within the previous frame each comprise a smallest available prediction block size and are in contact with a respective corner of the collocated block.
17. The apparatus of any of claims 10 to 16, wherein the instructions further comprise instructions for calculating the popularity value for each motion vector within the reference motion vector candidate list.
18. The apparatus of any of claims 10 to 17, wherein the instructions for creating the reference motion vector candidate list comprises instructions for:
searching for a reference frame index of the reference frame for motion vectors used to inter-predict the reference blocks; and
including any of the motion vectors used to inter-predict the reference blocks having the reference frame index in the reference motion vector candidate list.
19. A method for encoding a video stream including a processor, the method comprising:
identifying, for each of a plurality of reference frames, candidate motion vectors for encoding a current block within a current frame using reference blocks, the reference blocks including spatially adjacent blocks of the current frame, a collocated block within a previous frame, and spatially adjacent blocks of the collocated block within the previous frame;
ranking the candidate motion vectors within a reference motion vector candidate list for a reference frame by a distance from the current block of a respective reference block providing a respective candidate motion vector, and by a popularity value of the respective candidate motion vector that indicates a level of use of the respective candidate motion vector by the reference blocks;
assigning the candidate motion vectors to a plurality of inter-prediction modes based on the ranking;
selecting an inter-prediction mode for encoding the current block; and
encoding the current block using the inter-prediction mode.
20. The method of claim 19, wherein encoding the current block using the inter- prediction mode comprises:
differentially encoding a motion vector used to inter-prediction the current block using a candidate motion vector assigned to the inter-prediction mode selected for encoding the current block; or
including at least one bit within a bitstream in association with the current block indicating that the current block was encoded using a candidate motion vector assigned to the inter-prediction mode selected for encoding the current block.
21. Apparatus for encoding a video stream including a processor, the apparatus being arranged to:
identify, for each of a plurality of reference frames, candidate motion vectors for encoding a current block within a current frame using reference blocks, the reference blocks including spatially adjacent blocks of the current frame, a collocated block within a previous frame, and spatially adjacent blocks of the collocated block within the previous frame;
rank the candidate motion vectors within a reference motion vector candidate list for a reference frame by a distance from the current block of a respective reference block
providing a respective candidate motion vector, and by a popularity value of the respective candidate motion vector that indicates a level of use of the respective candidate motion vector by the reference blocks;
assign the candidate motion vectors to a plurality of inter-prediction modes based on the ranking;
select an inter-prediction mode for encoding the current block; and
encode the current block using the inter-prediction mode.
Applications Claiming Priority (8)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201662288553P | 2016-01-29 | 2016-01-29 | |
US62/288,553 | 2016-01-29 | ||
US15/131,079 | 2016-04-18 | ||
US15/131,079 US10397600B1 (en) | 2016-01-29 | 2016-04-18 | Dynamic reference motion vector coding mode |
US201662330491P | 2016-05-02 | 2016-05-02 | |
US62/330,491 | 2016-05-02 | ||
US15/373,518 US10462457B2 (en) | 2016-01-29 | 2016-12-09 | Dynamic reference motion vector coding mode |
US15/373,518 | 2016-12-09 |
Publications (1)
Publication Number | Publication Date |
---|---|
WO2017131908A1 true WO2017131908A1 (en) | 2017-08-03 |
Family
ID=59398647
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
PCT/US2016/068472 WO2017131908A1 (en) | 2016-01-29 | 2016-12-23 | Dynamic reference motion vector coding mode |
Country Status (2)
Country | Link |
---|---|
CN (1) | CN107027038B (en) |
WO (1) | WO2017131908A1 (en) |
Cited By (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN110731082A (en) * | 2017-08-15 | 2020-01-24 | 谷歌有限责任公司 | Compressing groups of video frames using reverse ordering |
KR20200134219A (en) * | 2018-02-06 | 2020-12-01 | 텐센트 아메리카 엘엘씨 | Method and apparatus for video coding in merge mode |
CN113194314A (en) * | 2019-01-03 | 2021-07-30 | 深圳市大疆创新科技有限公司 | Video processing method, encoding end and decoding end |
US11303903B2 (en) * | 2019-12-03 | 2022-04-12 | Axis Ab | Method and system for encoding an image of a video sequence involving calculation of a cost for encoding a coherent region |
WO2023287418A1 (en) * | 2021-07-15 | 2023-01-19 | Google Llc | Reference motion vector candidate bank |
Families Citing this family (14)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
KR20230104771A (en) * | 2018-02-28 | 2023-07-10 | 삼성전자주식회사 | A method of image encoding and an apparatus therefor, a method of image decoding and an apparatus therefor |
CN111869215B (en) * | 2018-05-31 | 2023-06-06 | 华为技术有限公司 | Method and device for predicting limited long-distance motion vector |
TWI750486B (en) | 2018-06-29 | 2021-12-21 | 大陸商北京字節跳動網絡技術有限公司 | Restriction of motion information sharing |
US11089297B2 (en) * | 2018-08-31 | 2021-08-10 | Hulu, LLC | Historical motion vector prediction with reset list |
US10958932B2 (en) * | 2018-09-12 | 2021-03-23 | Qualcomm Incorporated | Inter-prediction coding of video data using generated motion vector predictor list including non-adjacent blocks |
CN114125467A (en) * | 2018-09-13 | 2022-03-01 | 华为技术有限公司 | Decoding method and device for predicting motion information |
WO2020113065A1 (en) * | 2018-11-27 | 2020-06-04 | Op Solutions, Llc | Adaptive block update of unavailable reference frames using explicit and implicit signaling |
WO2020143292A1 (en) * | 2019-01-09 | 2020-07-16 | 华为技术有限公司 | Inter-frame prediction method and apparatus |
CN111953997A (en) * | 2019-05-15 | 2020-11-17 | 华为技术有限公司 | Candidate motion vector list obtaining method and device and coder-decoder |
WO2021047631A1 (en) * | 2019-09-13 | 2021-03-18 | Beijing Bytedance Network Technology Co., Ltd. | Derivation of collocated motion vectors |
CN110572674B (en) * | 2019-09-27 | 2024-03-15 | 腾讯科技（深圳）有限公司 | Video encoding and decoding method and device, storage medium and electronic device |
CN110572672B (en) * | 2019-09-27 | 2024-03-15 | 腾讯科技（深圳）有限公司 | Video encoding and decoding method and device, storage medium and electronic device |
CN113382249B (en) * | 2021-04-21 | 2022-09-06 | 浙江大华技术股份有限公司 | Image/video encoding method, apparatus, system, and computer-readable storage medium |
CN116805968A (en) * | 2022-03-16 | 2023-09-26 | 腾讯科技（深圳）有限公司 | Video encoding and decoding method and device, computer readable medium and electronic equipment |
Citations (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2011095260A1 (en) * | 2010-02-05 | 2011-08-11 | Telefonaktiebolaget L M Ericsson (Publ) | Managing predicted motion vector candidates |
WO2011146451A1 (en) * | 2010-05-20 | 2011-11-24 | Thomson Licensing | Methods and apparatus for adaptive motion vector candidate ordering for video encoding and decoding |
Family Cites Families (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
ES2886357T3 (en) * | 2011-06-27 | 2021-12-17 | Samsung Electronics Co Ltd | Encoding and decoding of motion information |
US20130208795A1 (en) * | 2012-02-09 | 2013-08-15 | Google Inc. | Encoding motion vectors for video compression |
-
2016
- 2016-12-23 WO PCT/US2016/068472 patent/WO2017131908A1/en active Application Filing
- 2016-12-27 CN CN201611226103.5A patent/CN107027038B/en active Active
Patent Citations (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2011095260A1 (en) * | 2010-02-05 | 2011-08-11 | Telefonaktiebolaget L M Ericsson (Publ) | Managing predicted motion vector candidates |
WO2011146451A1 (en) * | 2010-05-20 | 2011-11-24 | Thomson Licensing | Methods and apparatus for adaptive motion vector candidate ordering for video encoding and decoding |
Non-Patent Citations (3)
Title |
---|
HAN JINGNING ET AL: "A dynamic motion vector referencing scheme for video coding", 2016 IEEE INTERNATIONAL CONFERENCE ON IMAGE PROCESSING (ICIP), IEEE, 25 September 2016 (2016-09-25), pages 2032 - 2036, XP033016873, DOI: 10.1109/ICIP.2016.7532715 * |
MUKHERJEE DEBARGHA ET AL: "The latest open-source video codec VP9 - An overview and preliminary results", 2013 PICTURE CODING SYMPOSIUM (PCS), IEEE, 8 December 2013 (2013-12-08), pages 390 - 393, XP032566964, DOI: 10.1109/PCS.2013.6737765 * |
PHILIPP HELLE ET AL: "Block Merging for Quadtree-Based Partitioning in HEVC", IEEE TRANSACTIONS ON CIRCUITS AND SYSTEMS FOR VIDEO TECHNOLOGY, IEEE SERVICE CENTER, PISCATAWAY, NJ, US, vol. 22, no. 12, 1 December 2012 (2012-12-01), pages 1720 - 1731, XP011487155, ISSN: 1051-8215, DOI: 10.1109/TCSVT.2012.2223051 * |
Cited By (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
CN110731082A (en) * | 2017-08-15 | 2020-01-24 | 谷歌有限责任公司 | Compressing groups of video frames using reverse ordering |
CN110731082B (en) * | 2017-08-15 | 2023-10-03 | 谷歌有限责任公司 | Compression of groups of video frames using reverse ordering |
KR20200134219A (en) * | 2018-02-06 | 2020-12-01 | 텐센트 아메리카 엘엘씨 | Method and apparatus for video coding in merge mode |
EP3750316A4 (en) * | 2018-02-06 | 2020-12-16 | Tencent America LLC | Method and apparatus for video coding in merge mode |
KR102442454B1 (en) * | 2018-02-06 | 2022-09-14 | 텐센트 아메리카 엘엘씨 | Method and apparatus for video coding in merge mode |
CN113194314A (en) * | 2019-01-03 | 2021-07-30 | 深圳市大疆创新科技有限公司 | Video processing method, encoding end and decoding end |
CN113194314B (en) * | 2019-01-03 | 2022-10-25 | 深圳市大疆创新科技有限公司 | Video processing method, encoding end and decoding end |
US11303903B2 (en) * | 2019-12-03 | 2022-04-12 | Axis Ab | Method and system for encoding an image of a video sequence involving calculation of a cost for encoding a coherent region |
WO2023287418A1 (en) * | 2021-07-15 | 2023-01-19 | Google Llc | Reference motion vector candidate bank |
Also Published As
Publication number | Publication date |
---|---|
CN107027038A (en) | 2017-08-08 |
CN107027038B (en) | 2020-01-10 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10462457B2 (en) | Dynamic reference motion vector coding mode | |
CN107027038B (en) | Dynamic reference motion vector coding mode | |
US10142652B2 (en) | Entropy coding motion vector residuals obtained using reference motion vectors | |
AU2016398050B2 (en) | Motion vector reference selection through reference frame buffer tracking | |
US10116957B2 (en) | Dual filter type for motion compensated prediction in video coding | |
US20190289319A1 (en) | Multi-level compound prediction | |
US10397600B1 (en) | Dynamic reference motion vector coding mode | |
US10390026B2 (en) | Smart reordering in recursive block partitioning for advanced intra prediction in video coding | |
EP3729810A1 (en) | Motion vector coding using residual block energy distribution | |
US10951894B2 (en) | Transform block-level scan order selection for video coding | |
US10419777B2 (en) | Non-causal overlapped block prediction in variable block size video coding | |
WO2019036080A1 (en) | Constrained motion field estimation for inter prediction | |
US10462482B2 (en) | Multi-reference compound prediction of a block using a mask mode | |
GB2547754A (en) | Dynamic reference motion vector coding mode | |
EP4352958A1 (en) | Reference motion vector candidate bank |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
121 | Ep: the epo has been informed by wipo that ep was designated in this application |
Ref document number: 16825988Country of ref document: EPKind code of ref document: A1 |
|
NENP | Non-entry into the national phase |
Ref country code: DE |
|
122 | Ep: pct application non-entry in european phase |
Ref document number: 16825988Country of ref document: EPKind code of ref document: A1 |