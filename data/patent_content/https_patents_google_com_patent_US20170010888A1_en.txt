US20170010888A1 - Automatic imports and dependencies in large-scale source code repositories - Google Patents
Automatic imports and dependencies in large-scale source code repositories Download PDFInfo
- Publication number
- US20170010888A1 US20170010888A1 US14/796,695 US201514796695A US2017010888A1 US 20170010888 A1 US20170010888 A1 US 20170010888A1 US 201514796695 A US201514796695 A US 201514796695A US 2017010888 A1 US2017010888 A1 US 2017010888A1
- Authority
- US
- United States
- Prior art keywords
- qualified
- name
- list
- source code
- names
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Granted
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
- G06F8/43—Checking; Contextual analysis
- G06F8/433—Dependency analysis; Data or control flow analysis
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/10—File systems; File servers
- G06F16/16—File or folder operations, e.g. details of user interfaces specifically adapted to file systems
- G06F16/164—File meta data generation
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/70—Software maintenance or management
-
- G06F17/3012—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F3/00—Input arrangements for transferring data to be processed into a form capable of being handled by the computer; Output arrangements for transferring data from processing unit to output unit, e.g. interface arrangements
- G06F3/01—Input arrangements or combined input and output arrangements for interaction between user and computer
- G06F3/048—Interaction techniques based on graphical user interfaces [GUI]
- G06F3/0481—Interaction techniques based on graphical user interfaces [GUI] based on specific properties of the displayed interaction object or a metaphor-based environment, e.g. interaction with desktop elements like windows or icons, or assisted by a cursor's changing behaviour or appearance
- G06F3/0482—Interaction with lists of selectable items, e.g. menus
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/30—Creation or generation of source code
- G06F8/33—Intelligent editors
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/70—Software maintenance or management
- G06F8/74—Reverse engineering; Extracting design information from source code
Definitions
- a developer may want to include a list of people in his application. Instead of defining his own list object, the developer may include a list class from an external package.
- the developer may include a list from a standard library in his code, such as “java.util.List.”
- the “java.util.List” is a class of ordered collection that is publically available through the java.util package.
- the developer may simply refer to the list with the simple name, “List,” without having to use the full, qualified name “java.util.List” everywhere a list is instantiated or used. For example, on line 3 of FIG. 1 , the code refers only to the simple name, “List,” and not the qualified name, “java.util.List.”
- This specification describes technologies relating to finding candidates of qualified names for at least one simple name in a source code file.
- An example system may include one or more processing devices and one or more storage devices storing instructions that implement an example method.
- An example method may include: receiving a source code file with at least one simple name for which a corresponding qualified name is required; parsing the source code file to determine the simple names in the file and qualified names in the file; for the at least one simple name for which a corresponding qualified name is required, searching a source code graph to find potential qualified names that correspond to the at least one simple name; and upon receipt of a list of potential candidate qualified names from the source code graph, outputting the list.
- the list of potential candidate qualified names may be filtered or enriched with additional information prior to outputting the list; build dependencies and build targets for specific qualified names may be determined once a qualified name is chosen; the list of potential candidate qualified names may be filtered based on a number of times a qualified name of a particular type has been used by other source code files prior to outputting the list; the list may be ranked based on the frequency in which a particular qualified name has been used in other parts of a source code repository; if the list only contains one potential qualified name, the name may be automatically chosen as the qualified name without user interaction; an interface may be provided for a user to receive a choice of a qualified name from the list of potential candidate qualified names; filtering may include determining whether a qualified name package is visible from the source code file in which a simple name potentially corresponding to the qualified name is currently being referenced and responsive to determining that the qualified name package is visible from the source code file, providing the qualified name package's name as a
- FIG. 1 is an example of source code including a qualified name and a simple name.
- FIG. 2 is a block diagram illustrating an example system for determining qualified names for simple names in a source code file.
- FIG. 3 is an example method for finding candidates of qualified names for at least one simple name in a source code file.
- FIG. 4 is a block diagram illustrating an example computing device.
- a large-scale graph in a distributed system representing all source code for a certain source code repository or repositories.
- Source code may be indexed to create the graph.
- this graph may exist on a machine or several machines that are remotely accessed by developers so that the graph is not run on an individual developer's machine and can be accessed by multiple developers at the same time.
- the graph may be two tables, one mapping simple names to qualified names and a second table mapping qualified names to build system dependencies.
- an integrated development environment (IDE) running on a developer's machine may have a parser ( 203 ) that may provide a list of simple names which are used in a particular source code file.
- the parser ( 203 ) may also provide a list of qualified names in the source code file.
- the list of simple names may be: [Foo, Bar].
- the list of qualified names may be: [com.sourcecode.Bar]. As illustrated, a qualified name corresponding to a simple name may not be provided.
- the source code graph ( 205 ) may be queried for possible expansions of the simple name into a qualified name.
- the source code graph ( 205 ) may be queried for the qualified name for “Foo” and build dependencies associated with “Foo.” If the qualified name is provided as an import such as “Bar” in this example, the build-system dependency may or may not be present. Therefore, the source code graph ( 205 ) may also be queried for the build-system dependencies even when the fully qualified name is provided in the source code.
- results may be filtered by how a simple name is used in code. For example, if a certain method of “Foo” is called, fully-qualified potential candidates for completion that do not contain the method may be filtered out of the potential candidate list. The query may then return a list of imports and build-system dependencies. There are various ways to order and filter this list as one of ordinary skill in the art can appreciate.
- the source code graph ( 205 ) may be traversed to obtain information such as the build system dependencies for simple names found in the files. For example, the source code graph may be able to provide the targets for the dependencies to the qualified name for the simple name “Foo” so that the source code can be compiled into object files.
- the list of potential qualified names for a given simple name obtained by traversing the source code graph ( 205 ) may be enriched with other data and further filtered ( 213 ).
- Enrichment data may include: the number of times the qualified name is used in the repository (to allow for ranking); whether the qualified-name is marked as deprecated, and if so what qualified-name should be used instead; whether the qualified-name package is visible from the source code in which it is currently being referenced (some classes may be intentionally restricted to certain software packages); and the amount of complication this qualified-name may add to the build process including the increase in time and/or resources in order to build the source code.
- the list may be filtered, for example, based on the number of times a qualified name of a particular type has been used by other source code files. Filtering may also include removing all non-visible classes or removing all classes that would not fit within the specific context in the code. For example, “Foo” may call a specific method in a source code file so all matching “Foo” libraries that do not have this method may be filtered out of the potential candidate list.
- an example system may rank returned results based on the frequency in which a particular qualified name has been used by other developers in other parts of the source code repository.
- heavily-used qualified names are the names most likely to be used by developers in their source code files.
- names may also be ranked by whether they are visible to the source code file in which they are being considered to be used. whether the class the name represents has a method being used in the source code file. and whether classes are deprecated. Classes that are deprecated may be demoted in name ranking.
- a user ( 215 ) may then be shown the enriched, filtered list of potential qualified name candidates for a specific simple name reference in the code and choose the most appropriate package, library, or other external code source for the simple named object.
- the chosen qualified names may then be sent to the source graph ( 205 ) again to acquire information about the build-system dependencies in order to manipulate build rule dependencies and build targets for specific qualified names.
- the list of potential candidates for completion and build-system dependencies may be filtered and for the query to only return the import and build-system dependencies that are the most likely matches.
- the qualified names may be added/imported into the file ( 201 ).
- the source graph may be re-generated periodically in order to determine which classes/build dependencies are used most often.
- An example method as shown in FIG. 3 begins with receiving a source code file with at least one simple name for which a corresponding qualified name should be found (or is required) ( 301 ).
- the source code file may then be parsed to find a list of the simple names used in the file and another list of all the qualified names in the file ( 303 ).
- the graph of all source code may be searched to find potential candidate qualified names for the simple name ( 305 ).
- the candidate list of names may be filtered or enriched with additional information.
- the list may be provided to a user for the user to choose the appropriate qualified name for a given simple name ( 309 ).
- a user may not need to choose the qualified name and the qualified name may be chosen automatically.
- a user may just confirm that the qualified name is the appropriate match for the simple name.
- an example method may determine build dependencies and build targets for specific qualified names. The qualified names matching the simple names in the source code file may be added to the source file. Then, the source code graph may be re-generated and information pertaining to simple name/qualified name/build dependency frequency may be used in future analysis to find qualified names and build dependencies.
- FIG. 4 is a high-level block diagram of an example computer ( 400 ) that is arranged for hosting and publishing software packages.
- the computing device ( 400 ) typically includes one or more processors ( 410 ) and system memory ( 420 ).
- a memory bus ( 430 ) can be used for communicating between the processor ( 410 ) and the system memory ( 420 ).
- the processor ( 410 ) can be of any type including but not limited to a microprocessor (IP), a microcontroller (pC), a digital signal processor (DSP), or any combination thereof
- the processor ( 410 ) can include one more levels of caching, such as a level one cache ( 411 ) and a level two cache ( 412 ), a processor core ( 413 ), and registers ( 414 ).
- the processor core ( 413 ) can include an arithmetic logic unit (ALU), a floating point unit (FPU), a digital signal processing core (DSP Core), or any combination thereof
- a memory controller ( 416 ) can also be used with the processor ( 410 ), or in some implementations the memory controller ( 415 ) can be an internal part of the processor ( 410 ).
- system memory ( 420 ) can be of any type including but not limited to volatile memory (such as RAM), non-volatile memory (such as ROM, flash memory, etc.) or any combination thereof.
- System memory ( 420 ) typically includes an operating system ( 421 ), one or more applications ( 422 ), and program data ( 424 ).
- the application ( 422 ) may include a method for hosting and publishing software packages.
- Program Data ( 424 ) includes storing instructions that, when executed by the one or more processing devices, implement a method for hosting and publishing software packages. ( 423 ).
- the application ( 422 ) can be arranged to operate with program data ( 424 ) on an operating system ( 421 ).
- the computing device ( 400 ) can have additional features or functionality, and additional interfaces to facilitate communications between the basic configuration ( 401 ) and any required devices and interfaces.
- System memory ( 420 ) is an example of computer storage media.
- Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device 400 . Any such computer storage media can be part of the device ( 400 ).
- the computing device ( 400 ) can be implemented as a portion of a small-form factor portable (or mobile) electronic device such as a cell phone, a smartphone, a personal data assistant (PDA), a personal media player device, a tablet computer (tablet), a wireless web-watch device, a personal headset device, an application-specific device, or a hybrid device that include any of the above functions.
- a small-form factor portable (or mobile) electronic device such as a cell phone, a smartphone, a personal data assistant (PDA), a personal media player device, a tablet computer (tablet), a wireless web-watch device, a personal headset device, an application-specific device, or a hybrid device that include any of the above functions.
- PDA personal data assistant
- the computing device ( 400 ) can also be implemented as a personal computer including both laptop computer and non-laptop computer configurations.
- non-transitory signal bearing medium examples include, but are not limited to, the following: a recordable type medium such as a floppy disk, a hard disk drive, a Compact Disc (CD), a Digital Video Disk (DVD), a digital tape, a computer memory, etc.; and a transmission type medium such as a digital and/or an analog communication medium. (e.g., fiber optics cable, a waveguide, a wired communications link, a wireless communication link, etc.)
Abstract
Description
- Developers often build complex software applications that incorporate external code or libraries. For example, a developer may want to include a list of people in his application. Instead of defining his own list object, the developer may include a list class from an external package. In this example as shown in
FIG. 1 , the developer may include a list from a standard library in his code, such as “java.util.List.” The “java.util.List” is a class of ordered collection that is publically available through the java.util package. Once the list has been imported into a developer's source code file, the developer may simply refer to the list with the simple name, “List,” without having to use the full, qualified name “java.util.List” everywhere a list is instantiated or used. For example, online 3 ofFIG. 1 , the code refers only to the simple name, “List,” and not the qualified name, “java.util.List.” - Although the process to import packages, libraries, or external code that defines the qualified names into a source code can be straightforward for small code bases using standard integrated development environments (IDEs), large-scale code bases have too many external dependencies for standard IDEs to efficiently find the appropriate full names, referred to as qualified names, or the appropriate build system constructs for the dependencies.
- Conventional systems attempt to find qualified names in real-time by looking at the entire code base and trying to determine the appropriate package, library, or other external code. This process is time-consuming. Large amounts of source code simply cannot be processed in a reasonable time using this approach.
- As recognized by the inventor, there should be a way to quickly find candidates of qualified names in order to import the appropriate package, library, or external code for simple name references that exist in source code and the build-system dependencies that provide the qualified names.
- This specification describes technologies relating to finding candidates of qualified names for at least one simple name in a source code file.
- In general, one aspect of the subject matter described in this specification can be embodied in a system for finding candidates of qualified names for at least one simple name in a source code file. An example system may include one or more processing devices and one or more storage devices storing instructions that implement an example method. An example method may include: receiving a source code file with at least one simple name for which a corresponding qualified name is required; parsing the source code file to determine the simple names in the file and qualified names in the file; for the at least one simple name for which a corresponding qualified name is required, searching a source code graph to find potential qualified names that correspond to the at least one simple name; and upon receipt of a list of potential candidate qualified names from the source code graph, outputting the list.
- These and other embodiments can optionally include one or more of the following features: the list of potential candidate qualified names may be filtered or enriched with additional information prior to outputting the list; build dependencies and build targets for specific qualified names may be determined once a qualified name is chosen; the list of potential candidate qualified names may be filtered based on a number of times a qualified name of a particular type has been used by other source code files prior to outputting the list; the list may be ranked based on the frequency in which a particular qualified name has been used in other parts of a source code repository; if the list only contains one potential qualified name, the name may be automatically chosen as the qualified name without user interaction; an interface may be provided for a user to receive a choice of a qualified name from the list of potential candidate qualified names; filtering may include determining whether a qualified name package is visible from the source code file in which a simple name potentially corresponding to the qualified name is currently being referenced and responsive to determining that the qualified name package is visible from the source code file, providing the qualified name package's name as a potential candidate qualified name; and filtering may include determining the amount of complication a qualified name package may add to the build process, including the increase in time or resources in order to build the source code file and responsive to determining that the amount of complication a qualified name package adds to the build process is a sustainable amount, adding the qualified name package's name to the list of potential candidate qualified names.
-
FIG. 1 is an example of source code including a qualified name and a simple name. -
FIG. 2 is a block diagram illustrating an example system for determining qualified names for simple names in a source code file. -
FIG. 3 is an example method for finding candidates of qualified names for at least one simple name in a source code file. -
FIG. 4 is a block diagram illustrating an example computing device. - According to an example embodiment, there may be a large-scale graph in a distributed system representing all source code for a certain source code repository or repositories. Source code may be indexed to create the graph. In some embodiments, this graph may exist on a machine or several machines that are remotely accessed by developers so that the graph is not run on an individual developer's machine and can be accessed by multiple developers at the same time. In the simplest form, the graph may be two tables, one mapping simple names to qualified names and a second table mapping qualified names to build system dependencies. By creating and accessing the graph in a distributed system or cloud environment, computations can be cached and reused among developers. In other embodiments, the graph may exist on the developer's own machine.
- As shown in
FIG. 2 , there are two simple names in an example source code file (201), “Bar” online 3 and “Foo” online 5. The qualified name for “Bar” is provided in the code as “com.sourcecode.Bar” online 1. However, the qualified name for “Foo” is not provided. - In an example system, an integrated development environment (IDE) running on a developer's machine may have a parser (203) that may provide a list of simple names which are used in a particular source code file. The parser (203) may also provide a list of qualified names in the source code file. For the source code file shown in
FIG. 2 , the list of simple names may be: [Foo, Bar]. The list of qualified names may be: [com.sourcecode.Bar]. As illustrated, a qualified name corresponding to a simple name may not be provided. In order to find the qualified name and the build-system construct that provides the qualified name for simple names in the source code for which the corresponding qualified name is not provided, the source code graph (205) may be queried for possible expansions of the simple name into a qualified name. In the given example, the source code graph (205) may be queried for the qualified name for “Foo” and build dependencies associated with “Foo.” If the qualified name is provided as an import such as “Bar” in this example, the build-system dependency may or may not be present. Therefore, the source code graph (205) may also be queried for the build-system dependencies even when the fully qualified name is provided in the source code. - For example, when looking for “Foo,” the search of the source code graph (205) may match classes and build system artifacts that contain the name “Foo.” In some embodiments, results may be filtered by how a simple name is used in code. For example, if a certain method of “Foo” is called, fully-qualified potential candidates for completion that do not contain the method may be filtered out of the potential candidate list. The query may then return a list of imports and build-system dependencies. There are various ways to order and filter this list as one of ordinary skill in the art can appreciate.
- The source code graph (205) may be traversed to obtain information such as the build system dependencies for simple names found in the files. For example, the source code graph may be able to provide the targets for the dependencies to the qualified name for the simple name “Foo” so that the source code can be compiled into object files.
- The list of potential qualified names for a given simple name obtained by traversing the source code graph (205) may be enriched with other data and further filtered (213). Enrichment data may include: the number of times the qualified name is used in the repository (to allow for ranking); whether the qualified-name is marked as deprecated, and if so what qualified-name should be used instead; whether the qualified-name package is visible from the source code in which it is currently being referenced (some classes may be intentionally restricted to certain software packages); and the amount of complication this qualified-name may add to the build process including the increase in time and/or resources in order to build the source code. The list may be filtered, for example, based on the number of times a qualified name of a particular type has been used by other source code files. Filtering may also include removing all non-visible classes or removing all classes that would not fit within the specific context in the code. For example, “Foo” may call a specific method in a source code file so all matching “Foo” libraries that do not have this method may be filtered out of the potential candidate list. When returning a list of possible candidates for completions and dependencies to a user (215) for consideration, an example system may rank returned results based on the frequency in which a particular qualified name has been used by other developers in other parts of the source code repository.
- In some embodiments, heavily-used qualified names are the names most likely to be used by developers in their source code files. Among other rankings, names may also be ranked by whether they are visible to the source code file in which they are being considered to be used. whether the class the name represents has a method being used in the source code file. and whether classes are deprecated. Classes that are deprecated may be demoted in name ranking. A user (215) may then be shown the enriched, filtered list of potential qualified name candidates for a specific simple name reference in the code and choose the most appropriate package, library, or other external code source for the simple named object. Once the user (215) chooses the correct qualified name for the simple name in the source code from the candidates of qualified names, the chosen qualified names may then be sent to the source graph (205) again to acquire information about the build-system dependencies in order to manipulate build rule dependencies and build targets for specific qualified names. In some embodiments, the list of potential candidates for completion and build-system dependencies may be filtered and for the query to only return the import and build-system dependencies that are the most likely matches.
- As shown in
FIG. 2 , once the unique qualified names (207, 209) have been found in the source code graph (205) or parsed from the file itself (203) and matched with the simple names used in the source code file (201), the qualified names may be added/imported into the file (201). The source graph may be re-generated periodically in order to determine which classes/build dependencies are used most often. - An example method as shown in
FIG. 3 begins with receiving a source code file with at least one simple name for which a corresponding qualified name should be found (or is required) (301). The source code file may then be parsed to find a list of the simple names used in the file and another list of all the qualified names in the file (303). For the at least one simple name for which a corresponding qualified name should be found, the graph of all source code may be searched to find potential candidate qualified names for the simple name (305). In some embodiments, the candidate list of names may be filtered or enriched with additional information. The list may be provided to a user for the user to choose the appropriate qualified name for a given simple name (309). In some embodiments, if there is only one candidate qualified name, a user may not need to choose the qualified name and the qualified name may be chosen automatically. In other embodiments, if there is only one candidate qualified name, a user may just confirm that the qualified name is the appropriate match for the simple name. Once the qualified name is chosen, an example method may determine build dependencies and build targets for specific qualified names. The qualified names matching the simple names in the source code file may be added to the source file. Then, the source code graph may be re-generated and information pertaining to simple name/qualified name/build dependency frequency may be used in future analysis to find qualified names and build dependencies. -
FIG. 4 is a high-level block diagram of an example computer (400) that is arranged for hosting and publishing software packages. In a very basic configuration (401), the computing device (400) typically includes one or more processors (410) and system memory (420). A memory bus (430) can be used for communicating between the processor (410) and the system memory (420). - Depending on the desired configuration, the processor (410) can be of any type including but not limited to a microprocessor (IP), a microcontroller (pC), a digital signal processor (DSP), or any combination thereof The processor (410) can include one more levels of caching, such as a level one cache (411) and a level two cache (412), a processor core (413), and registers (414). The processor core (413) can include an arithmetic logic unit (ALU), a floating point unit (FPU), a digital signal processing core (DSP Core), or any combination thereof A memory controller (416) can also be used with the processor (410), or in some implementations the memory controller (415) can be an internal part of the processor (410).
- Depending on the desired configuration, the system memory (420) can be of any type including but not limited to volatile memory (such as RAM), non-volatile memory (such as ROM, flash memory, etc.) or any combination thereof. System memory (420) typically includes an operating system (421), one or more applications (422), and program data (424). The application (422) may include a method for hosting and publishing software packages. Program Data (424) includes storing instructions that, when executed by the one or more processing devices, implement a method for hosting and publishing software packages. (423). In some embodiments, the application (422) can be arranged to operate with program data (424) on an operating system (421).
- The computing device (400) can have additional features or functionality, and additional interfaces to facilitate communications between the basic configuration (401) and any required devices and interfaces.
- System memory (420) is an example of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing
device 400. Any such computer storage media can be part of the device (400). - The computing device (400) can be implemented as a portion of a small-form factor portable (or mobile) electronic device such as a cell phone, a smartphone, a personal data assistant (PDA), a personal media player device, a tablet computer (tablet), a wireless web-watch device, a personal headset device, an application-specific device, or a hybrid device that include any of the above functions. The computing device (400) can also be implemented as a personal computer including both laptop computer and non-laptop computer configurations.
- The foregoing detailed description has set forth various embodiments of the devices and/or processes via the use of block diagrams, flowcharts, and/or examples. Insofar as such block diagrams, flowcharts, and/or examples contain one or more functions and/or operations, it will be understood by those within the art that each function and/or operation within such block diagrams, flowcharts, or examples can be implemented, individually and/or collectively, by a wide range of hardware, software, firmware, or virtually any combination thereof. In one embodiment, several portions of the subject matter described herein may be implemented via Application Specific Integrated Circuits (ASICs), Field Programmable Gate Arrays (FPGAs), digital signal processors (DSPs), other integrated formats, or as a web service. However, those skilled in the art will recognize that some aspects of the embodiments disclosed herein, in whole or in part, can be equivalently implemented in integrated circuits, as one or more computer programs running on one or more computers, as one or more programs running on one or more processors, as firmware, or as virtually any combination thereof, and that designing the circuitry and/or writing the code for the software and or firmware would be well within the skill of one of skill in the art in light of this disclosure. In addition, those skilled in the art will appreciate that the mechanisms of the subject matter described herein are capable of being distributed as a program product in a variety of forms, and that an illustrative embodiment of the subject matter described herein applies regardless of the particular type of non-transitory signal bearing medium used to actually carry out the distribution. Examples of a non-transitory signal bearing medium include, but are not limited to, the following: a recordable type medium such as a floppy disk, a hard disk drive, a Compact Disc (CD), a Digital Video Disk (DVD), a digital tape, a computer memory, etc.; and a transmission type medium such as a digital and/or an analog communication medium. (e.g., fiber optics cable, a waveguide, a wired communications link, a wireless communication link, etc.)
- With respect to the use of substantially any plural and/or singular terms herein, those having skill in the art can translate from the plural to the singular and/or from the singular to the plural as is appropriate to the context and/or application. The various singular/plural permutations may be expressly set forth herein for sake of clarity.
- Thus, particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.
Claims (18)
Priority Applications (9)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/796,695 US10120679B2 (en) | 2015-07-10 | 2015-07-10 | Automatic imports and dependencies in large-scale source code repositories |
CN201680037594.0A CN107810474B (en) | 2015-07-10 | 2016-06-27 | Automatic import and dependency in large-scale source code repository |
DE112016003130.0T DE112016003130T5 (en) | 2015-07-10 | 2016-06-27 | Automatic imports and dependencies in large-scale source code depots |
PCT/US2016/039561 WO2017011176A1 (en) | 2015-07-10 | 2016-06-27 | Automatic imports and dependencies in large-scale source code repositories |
KR1020177036265A KR101990603B1 (en) | 2015-07-10 | 2016-06-27 | Automatic imports and dependencies in large source code repositories |
JP2017564873A JP6568605B2 (en) | 2015-07-10 | 2016-06-27 | Automatic import and dependency in large source code repositories |
DE202016008044.0U DE202016008044U1 (en) | 2015-07-10 | 2016-06-27 | Automatic imports and dependencies in large-scale source code repositories |
GB1720895.0A GB2556481A (en) | 2015-07-10 | 2016-06-27 | Automatic imports and dependencies in large-scale source code repositories |
EP16735808.4A EP3320430B1 (en) | 2015-07-10 | 2016-06-27 | Automatic imports and dependencies in large-scale source code repositories |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US14/796,695 US10120679B2 (en) | 2015-07-10 | 2015-07-10 | Automatic imports and dependencies in large-scale source code repositories |
Publications (2)
Publication Number | Publication Date |
---|---|
US20170010888A1 true US20170010888A1 (en) | 2017-01-12 |
US10120679B2 US10120679B2 (en) | 2018-11-06 |
Family
ID=56360528
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US14/796,695 Active 2036-04-25 US10120679B2 (en) | 2015-07-10 | 2015-07-10 | Automatic imports and dependencies in large-scale source code repositories |
Country Status (8)
Country | Link |
---|---|
US (1) | US10120679B2 (en) |
EP (1) | EP3320430B1 (en) |
JP (1) | JP6568605B2 (en) |
KR (1) | KR101990603B1 (en) |
CN (1) | CN107810474B (en) |
DE (2) | DE202016008044U1 (en) |
GB (1) | GB2556481A (en) |
WO (1) | WO2017011176A1 (en) |
Cited By (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20190171444A1 (en) * | 2017-12-04 | 2019-06-06 | Oracle International Corporation | Inferring code deprecation from module deprecation |
US10437568B1 (en) * | 2017-05-18 | 2019-10-08 | Palantir Technologies Inc. | Real-time rendering based on efficient device and server processing of content updates |
US11062385B2 (en) * | 2018-08-21 | 2021-07-13 | International Business Machines Corporation | Providing code offerings inside code |
Citations (20)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20100042588A1 (en) * | 2008-08-15 | 2010-02-18 | Smyros Athena A | Systems and methods utilizing a search engine |
US20100146481A1 (en) * | 2008-12-09 | 2010-06-10 | Microsoft Corporation | Developing applications at runtime |
US20100185669A1 (en) * | 2009-01-09 | 2010-07-22 | Microsoft Corporation | Efficient incremental parsing of context sensitive programming languages |
US20100205563A1 (en) * | 2009-02-09 | 2010-08-12 | Nokia Corporation | Displaying information in a uni-dimensional carousel |
US20110167404A1 (en) * | 2010-01-06 | 2011-07-07 | Microsoft Corporation | Creating inferred symbols from code usage |
US20110296386A1 (en) * | 2010-05-28 | 2011-12-01 | Salesforce.Com, Inc. | Methods and Systems for Validating Changes Submitted to a Source Control System |
US20110302565A1 (en) * | 2010-06-07 | 2011-12-08 | Ferris Michael S | Implicit workspace dependencies |
US20120159420A1 (en) * | 2010-12-16 | 2012-06-21 | Sap Ag | Quality on Submit Process |
US20120259822A1 (en) * | 2009-12-22 | 2012-10-11 | Andreas Medgyesi | Method for compressing identifiers |
US20130326479A1 (en) * | 2012-06-01 | 2013-12-05 | Qnx Software Systems Limited | System and method for tracking compliance information for a build-system product |
US8635204B1 (en) * | 2010-07-30 | 2014-01-21 | Accenture Global Services Limited | Mining application repositories |
US20140359574A1 (en) * | 2013-06-04 | 2014-12-04 | Microsoft Corporation | Multi-step auto-completion model for software development environments |
US8972975B1 (en) * | 2013-04-01 | 2015-03-03 | Google Inc. | Bounded installation time optimization of applications |
US20150309813A1 (en) * | 2012-08-31 | 2015-10-29 | iAppSecure Solutions Pvt. Ltd | A System for analyzing applications in order to find security and quality issues |
US9244679B1 (en) * | 2013-09-12 | 2016-01-26 | Symantec Corporation | Systems and methods for automatically identifying changes in deliverable files |
US20160026443A1 (en) * | 2014-07-23 | 2016-01-28 | International Business Machines Corporation | Processing source file |
US20160063062A1 (en) * | 2014-08-26 | 2016-03-03 | Codota Dot Com Ltd. | Code searching and ranking |
US20160117154A1 (en) * | 2014-10-23 | 2016-04-28 | Telefonaktiebolaget L M Ericsson (Publ) | Automated software include graph and build environment analysis and optimization in compiled language |
US20160196204A1 (en) * | 2015-01-04 | 2016-07-07 | International Business Machines Corporation | Smart Validated Code Searching System |
US20170003948A1 (en) * | 2015-07-02 | 2017-01-05 | International Business Machines Corporation | Continuous deployment success prediction |
Family Cites Families (4)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8365153B2 (en) * | 2007-10-26 | 2013-01-29 | Qualcomm Incorporated | Server-based code compilation |
US8352913B2 (en) | 2009-08-07 | 2013-01-08 | Adobe Systems Incorporated | Generating and resolving component names in an integrated development environment |
CN101968736A (en) * | 2010-09-13 | 2011-02-09 | 杭州元睿信息技术有限公司 | Translation method for applying Java to external reference in C++ language program translation |
US20140201709A1 (en) * | 2013-01-15 | 2014-07-17 | Martin Carl Euerle | JavaScript™ Deployment Build Tool for software code that uses an object literal to define meta data and system code. |
-
2015
- 2015-07-10 US US14/796,695 patent/US10120679B2/en active Active
-
2016
- 2016-06-27 EP EP16735808.4A patent/EP3320430B1/en active Active
- 2016-06-27 DE DE202016008044.0U patent/DE202016008044U1/en active Active
- 2016-06-27 JP JP2017564873A patent/JP6568605B2/en active Active
- 2016-06-27 KR KR1020177036265A patent/KR101990603B1/en active IP Right Grant
- 2016-06-27 GB GB1720895.0A patent/GB2556481A/en not_active Withdrawn
- 2016-06-27 DE DE112016003130.0T patent/DE112016003130T5/en active Pending
- 2016-06-27 WO PCT/US2016/039561 patent/WO2017011176A1/en active Application Filing
- 2016-06-27 CN CN201680037594.0A patent/CN107810474B/en active Active
Patent Citations (20)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20100042588A1 (en) * | 2008-08-15 | 2010-02-18 | Smyros Athena A | Systems and methods utilizing a search engine |
US20100146481A1 (en) * | 2008-12-09 | 2010-06-10 | Microsoft Corporation | Developing applications at runtime |
US20100185669A1 (en) * | 2009-01-09 | 2010-07-22 | Microsoft Corporation | Efficient incremental parsing of context sensitive programming languages |
US20100205563A1 (en) * | 2009-02-09 | 2010-08-12 | Nokia Corporation | Displaying information in a uni-dimensional carousel |
US20120259822A1 (en) * | 2009-12-22 | 2012-10-11 | Andreas Medgyesi | Method for compressing identifiers |
US20110167404A1 (en) * | 2010-01-06 | 2011-07-07 | Microsoft Corporation | Creating inferred symbols from code usage |
US20110296386A1 (en) * | 2010-05-28 | 2011-12-01 | Salesforce.Com, Inc. | Methods and Systems for Validating Changes Submitted to a Source Control System |
US20110302565A1 (en) * | 2010-06-07 | 2011-12-08 | Ferris Michael S | Implicit workspace dependencies |
US8635204B1 (en) * | 2010-07-30 | 2014-01-21 | Accenture Global Services Limited | Mining application repositories |
US20120159420A1 (en) * | 2010-12-16 | 2012-06-21 | Sap Ag | Quality on Submit Process |
US20130326479A1 (en) * | 2012-06-01 | 2013-12-05 | Qnx Software Systems Limited | System and method for tracking compliance information for a build-system product |
US20150309813A1 (en) * | 2012-08-31 | 2015-10-29 | iAppSecure Solutions Pvt. Ltd | A System for analyzing applications in order to find security and quality issues |
US8972975B1 (en) * | 2013-04-01 | 2015-03-03 | Google Inc. | Bounded installation time optimization of applications |
US20140359574A1 (en) * | 2013-06-04 | 2014-12-04 | Microsoft Corporation | Multi-step auto-completion model for software development environments |
US9244679B1 (en) * | 2013-09-12 | 2016-01-26 | Symantec Corporation | Systems and methods for automatically identifying changes in deliverable files |
US20160026443A1 (en) * | 2014-07-23 | 2016-01-28 | International Business Machines Corporation | Processing source file |
US20160063062A1 (en) * | 2014-08-26 | 2016-03-03 | Codota Dot Com Ltd. | Code searching and ranking |
US20160117154A1 (en) * | 2014-10-23 | 2016-04-28 | Telefonaktiebolaget L M Ericsson (Publ) | Automated software include graph and build environment analysis and optimization in compiled language |
US20160196204A1 (en) * | 2015-01-04 | 2016-07-07 | International Business Machines Corporation | Smart Validated Code Searching System |
US20170003948A1 (en) * | 2015-07-02 | 2017-01-05 | International Business Machines Corporation | Continuous deployment success prediction |
Non-Patent Citations (5)
Title |
---|
Joel Ossher et al., "Automated dependency resolution for open source software," 2010, 7th IEEE Working Conference on Mining Software Repositories (MSR), pp. 130-140, downloaded from the Internet at <url>:http://ieeexplore.ieee.org. * |
Kuric et al., "Search in Source Code Based on Identifying Popular Fragments," 2013, Lecture Notes in Computer Science book series (LNCS, volume 7741), pp. 408-419. * |
Peter Weissgerber et al., "Identifying Refactorings from Source-Code Changes,"2006, 21st IEEE/ACM International Conference on Automated Software Engineering (ASE'06), pp. 1-10. * |
Ryan Hardt et al., "Ant build maintenance with Formiga," 2013, Proceedings of the 1st International Workshop on Release Engineering, pp. 13-16, downloaded from the Internet at <url>:https://dl.acm.org. * |
Sushil Bajracharya et al., "Sourcerer: An internet-scale software repository," 2009, Proceedings of the 2009 ICSE Workshop on Search-Driven Development-Users, Infrastructure, Tools and Evaluation, pp. 1-4, downloaded from the Internet at <url>:https://dl.acm.org. * |
Cited By (5)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10437568B1 (en) * | 2017-05-18 | 2019-10-08 | Palantir Technologies Inc. | Real-time rendering based on efficient device and server processing of content updates |
US20190171444A1 (en) * | 2017-12-04 | 2019-06-06 | Oracle International Corporation | Inferring code deprecation from module deprecation |
US10671383B2 (en) * | 2017-12-04 | 2020-06-02 | Oracle International Corporation | Inferring code deprecation from module deprecation |
US11366657B2 (en) * | 2017-12-04 | 2022-06-21 | Oracle International Corporation | Inferring code deprecation from module deprecation |
US11062385B2 (en) * | 2018-08-21 | 2021-07-13 | International Business Machines Corporation | Providing code offerings inside code |
Also Published As
Publication number | Publication date |
---|---|
GB201720895D0 (en) | 2018-01-31 |
DE202016008044U1 (en) | 2017-01-27 |
GB2556481A (en) | 2018-05-30 |
WO2017011176A1 (en) | 2017-01-19 |
JP2018519592A (en) | 2018-07-19 |
EP3320430B1 (en) | 2022-05-11 |
DE112016003130T5 (en) | 2018-03-22 |
KR101990603B1 (en) | 2019-06-18 |
US10120679B2 (en) | 2018-11-06 |
JP6568605B2 (en) | 2019-08-28 |
EP3320430A1 (en) | 2018-05-16 |
CN107810474B (en) | 2020-12-29 |
CN107810474A (en) | 2018-03-16 |
KR20180008709A (en) | 2018-01-24 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10169471B2 (en) | Generating and executing query language statements from natural language | |
Grainger et al. | Solr in action | |
US8122017B1 (en) | Enhanced retrieval of source code | |
US9146994B2 (en) | Pivot facets for text mining and search | |
KR20180032669A (en) | Callpath finder | |
US9135591B1 (en) | Analysis and assessment of software library projects | |
US20090030902A1 (en) | Schematized data intelligent assistance for development environments | |
US10019510B2 (en) | Indexing and searching log records using templates index and attributes index | |
US9195456B2 (en) | Managing a catalog of scripts | |
US20130086071A1 (en) | Augmenting search with association information | |
US20160132509A1 (en) | Complex query handling | |
EP3320430B1 (en) | Automatic imports and dependencies in large-scale source code repositories | |
EP3486798A1 (en) | Reporting and data governance management | |
US20140324839A1 (en) | Determining candidate scripts from a catalog of scripts | |
CN107391528B (en) | Front-end component dependent information searching method and equipment | |
US20130073511A1 (en) | Contextual feedback of rules proximity based upon co-occurence history in a collaborative rule editing system | |
RU2016147085A (en) | ACCESS TO SEMANTIC CONTENT IN THE DEVELOPMENT SYSTEM | |
CN113448562A (en) | Automatic logic code generation method and device and electronic equipment | |
US20150178075A1 (en) | Enhancing understandability of code using code clones | |
US9679066B2 (en) | Search results based on an environment context | |
US9286349B2 (en) | Dynamic search system | |
US20190147082A1 (en) | Reporting and data governance management | |
CN111898762B (en) | Deep learning model catalog creation | |
Alifi et al. | The relational data model on the university website with search engine optimization | |
Li et al. | CSlicerCloud: a web-based semantic history slicing framework |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:GRUSHKO, CARMI;REEL/FRAME:036091/0139Effective date: 20150710 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044129/0001Effective date: 20170929 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 4 |