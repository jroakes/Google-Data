US8849741B2 - NoGood generation based on search tree depth - Google Patents
NoGood generation based on search tree depth Download PDFInfo
- Publication number
- US8849741B2 US8849741B2 US13/358,335 US201213358335A US8849741B2 US 8849741 B2 US8849741 B2 US 8849741B2 US 201213358335 A US201213358335 A US 201213358335A US 8849741 B2 US8849741 B2 US 8849741B2
- Authority
- US
- United States
- Prior art keywords
- csp
- search
- binary tree
- depth
- nogood
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active, expires
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
- G06N5/02—Knowledge representation; Symbolic representation
- G06N5/022—Knowledge engineering; Knowledge acquisition
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N5/00—Computing arrangements using knowledge-based models
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06Q—INFORMATION AND COMMUNICATION TECHNOLOGY [ICT] SPECIALLY ADAPTED FOR ADMINISTRATIVE, COMMERCIAL, FINANCIAL, MANAGERIAL OR SUPERVISORY PURPOSES; SYSTEMS OR METHODS SPECIALLY ADAPTED FOR ADMINISTRATIVE, COMMERCIAL, FINANCIAL, MANAGERIAL OR SUPERVISORY PURPOSES, NOT OTHERWISE PROVIDED FOR
- G06Q10/00—Administration; Management
- G06Q10/06—Resources, workflows, human or project management; Enterprise or organisation planning; Enterprise or organisation modelling
- G06Q10/063—Operations research, analysis or management
- G06Q10/0631—Resource planning, allocation, distributing or scheduling for enterprises or organisations
- G06Q10/06316—Sequencing of tasks or work
Definitions
- the disclosure generally relates to operations research and particularly to constraint programming.
- CSP constraint satisfaction problem
- a number of variables of the problem are each assigned to a specific state, subject to a set of constraints that limit how variables may be assigned to states.
- the assignment of all variables to states represents a solution to the CSP.
- Each solution will have a cost associated with the assignment of each variable to a state.
- at least one of the variables is assigned a different state relative to the assigned states of the variables from every other solution.
- a constraint is the requirement that the salesman visit each city exactly once.
- An example of a variable is the order in which a given city is visited.
- the total cost for the salesman may vary.
- the cost is the total distance travelled by the salesman. For example, if the salesman were always to travel to the city furthest from his current location, the cost of travel might be higher than if the salesman always traveled to the closest city to their current location.
- CSPs sidestep the complex task of trying to come up with one optimal solution by instead searching through a number of the possible solutions by assigning variables to states and determining the costs associated with the solutions.
- One mechanism to do this is to construct a binary tree representing all of the possible assignments of variables to states, and consequently all of the possible solutions and their associated costs. By searching the tree from top to bottom, solutions can be associated with costs and the assignments of variables to states that make up the solution can be determined.
- Embodiments of the system and computer-readable medium include a non-transitory computer-readable storage medium storing executable computer program instructions.
- the instructions are executable to initialize the CSP and construct a binary tree using the CSP.
- the CSP models a real world problem in an application domain.
- the CSP comprises a plurality of variables, a plurality of states, and one or more constraints determining which states each variable is permitted to be assigned to in a CSP solution.
- a CSP solution models a real world solution to the real world problem.
- the instructions are further executable to iteratively search the binary tree to determine an efficient solution to the CSP.
- the searching comprises starting a new iteration of the search of the binary tree when a search depth is less than a restart depth.
- the restart depth is based on a deepest depth previously searched minus a restart value.
- the instructions are further executable to report the efficient solution.
- An embodiment of the system also includes a processor for executing the computer program instructions.
- An embodiment of the method comprises receiving a CSP input, the CSP input describing a real world problem in an application domain.
- the CSP input comprises a plurality of variables, a plurality of states, and one or more constraints determining which states each variable is permitted to be assigned to in a CSP solution.
- the CSP solution models a real world solution to the real world problem.
- the method further comprises initializing the CSP using the CSP input, the initializing comprising constructing a binary tree using the CSP input.
- the method additionally comprises searching, iteratively, the binary tree to determine an efficient solution to the CSP, the searching comprising starting a new iteration of the search of the binary tree when a search depth is less than a restart depth, the restart depth based on a deepest depth previously searched minus a restart value and reporting the efficient solution.
- FIG. 1 is a block diagram of a computing environment for solving constraint satisfaction problems (CSPs) using NoGood generation based on search tree depth, according to one embodiment.
- CSPs constraint satisfaction problems
- FIG. 2 is a high-level block diagram illustrating a computer for serving as a client or a CSP server.
- FIG. 3 is a block diagram illustrating modules within the CSP server, according to one embodiment.
- FIG. 4 is a flow diagram illustrating a process for determining efficient solutions to a CSP, according to one embodiment.
- FIG. 5 is a flow diagram further illustrating the search of a binary tree as discussed in FIG. 3 , according to one embodiment.
- FIG. 6 is an illustration of an example binary tree with NoGoods markers assigned, according to one embodiment.
- FIG. 1 is a block diagram of a computing environment for solving constraint satisfaction problems (CSPs) using NoGood generation based on search tree depth, according to one embodiment.
- the computing environment 100 includes a client 110 and a CSP server 120 connected through a network 130 . Only one of each entity is illustrated in order to simplify and clarify the present description. There can be other entities in the computing environment 100 as well.
- the client 110 is configured to interact with the CSP server 120 in order to specify CSPs, find efficient solutions to CSPs, and view the solutions.
- the client 110 is an electronic device that is operated by a user.
- the client 110 is a conventional computer system executing, for example, a Microsoft Windows-compatible OS, Apple OS X, and/or a Linux distribution.
- the client 110 may also be a mobile telephone executing, for example, a Google Android operating system (OS) or another device having computer functionality, such as a tablet computer, personal digital assistant (PDA), video game system, etc.
- OS Google Android operating system
- PDA personal digital assistant
- the user uses the client 110 to specify a particular CSP for which an efficient solution is sought.
- the client 110 may provide the user with tools with which the client may specify the CSP.
- the client 110 may execute software providing a graphical user interface (GUI) with which the user may specify the CSP, indicate the criteria for declaring a solution as “efficient” and/or define other aspects of the CSP.
- GUI graphical user interface
- the client 110 may then provide the specification of the CSP to the CSP server 120 .
- the client 110 may act as a conduit to the CSP server 120 , and the tools for specifying the CSP may reside on the CSP server.
- the CSP server 120 processes CSPs to find efficient solutions and reports the solutions to the user of the client 110 .
- the user may then implement one or more of the solutions.
- the CSP server 120 includes one or more computers.
- the CSP server 120 may include a distributed computing system having many individual computers working together to process the CSPs.
- the CSP server 120 , client 110 , and/or another computer system may be configured to implement a solution to the CSP found by the CSP server.
- supplemental information for a CSP description may be provided by the client 110 to the CSP server 120 after the CSP server 120 has already begun processing the received CSP.
- the CSP server 120 is configured to receive such supplemental information during processing, and to incorporate it into the description of the CSP.
- the supplemental information may be used to assist in the determination of efficient solutions to the CSP.
- the CSP server 120 formulates the CSP as a binary tree, and searches the binary tree to identify solutions. During the search, the CSP server 120 may stop the search, reconstruct the binary tree, and then restart the search on the reconstructed tree. An embodiment of the CSP server 120 determines when to restart the search based on a restart depth based in part on the deepest depth previously searched minus a restart value. When the CSP server 120 determines to restart a search, it generates a “NoGood” marker indicating a portion of the binary tree that has already been searched. When searching the reconstructed tree, the CSP server 120 uses the NoGood marker to identify portions of the tree that have already been searched for a solution and exclude those portions from additional searching.
- the quality (i.e., efficiency) of the searching for the solution is improved because portions of the tree that have already been searched are not searched again in future iterations of the search.
- the CSP server 120 accordingly devotes its resources to searching portions of the tree that have not yet been searched.
- This technique for creating NoGood markers results in the creation of fewer NoGood markers over the course of the entire search compared to creation of NoGood markers based on the number of nodes of the binary tree searched. This technique also comparatively decreases the extent to which portions of the tree are re-searched in future iterations of the search, thereby increasing the efficiency of the search.
- the CSP server 120 receives the specification of a CSP from a user in one embodiment.
- the specified CSP includes a number of different variables, states to which the variables may be assigned, and one or more constraints that restrict the states to which variables may be assigned. Each variable may be assigned to more than one possible state.
- a solution to the CSP is an assignment of variables to states that satisfies the constraints.
- a CSP may have one or more possible solutions, or it may not have any solution.
- An assignment of a variable to a state in a specified CSP may have an associated cost.
- the total cost of a solution to the CSP is derived from the costs of the individual assignments of the variables to the states. For example, the total cost of the solution may be the sum of the costs of the individual assignments. Since different solutions to the CSP have different assignments of variables to states, the different solutions also have different costs. Some solutions may have costs that effectively render the solutions infeasible, while other solutions may have lower costs that render the solutions feasible. The user may specify as part of the CSP which solutions have costs that render the solutions feasible. These solutions are referred to herein as being “efficient.” For example, an efficient solution may be a solution that has a cost below a threshold.
- the variables, states, constraints and costs of the CSP model one or more objects or activities in a real-world application domain.
- solutions to the CSP (CSP solutions) model solutions to the real-world problem described by the CSP (real world solutions).
- Real world solutions may be undertaken in the real world using the objects or activities designated by the states of variables from the CSP solutions.
- solutions refers to CSP solutions.
- the real-world application domain may be a scheduling project in which computer processing jobs are assigned to computers in a distributed computer system.
- FIG. 1 illustrates this example application domain in more detail.
- computer processing jobs 170 may be assigned to available time slots 160 on several computers 150 .
- the CSP variables include the possible time slots to which each job 170 may be assigned, the amount of time each job 170 takes to complete (e.g., a given job may take more than one time slot), and the computer 150 that will perform the job.
- the states of the CSP are the particular assignments of jobs 170 to time slots 160 and computers 150 .
- the constraints of the CSP may include, for example, that every job 170 must be assigned a computer 150 and a time slot 160 , that each job be assigned only once, and that some jobs 170 be completed before others.
- FIG. 1 illustrates one possible solution 140 to the example CSP determined by the CSP server 120 .
- this solution 140 all states have been assigned, which is illustrated by the assignment of all twelve jobs 170 to computers 150 and time slots 160 .
- costs associated with the solution may be, for example, capital costs such as the wear and tear on the computers 150 , the time cost of implementing the solution to get through processing all of the jobs, power costs associated with running the machines, opportunity costs due to computers idling while waiting for jobs etc.
- the solution 140 may be used by the client 110 to assign the user's computer processing jobs 170 to machines 1 - 4 150 a - d according to the time slots 160 designated by the solution 140 .
- a real-world application domain which may be formulated as a CSP is a construction project.
- the variables represent real-world entities such as a series of tasks and the workers who can perform the tasks.
- the constraints may include restrictions on the order that the tasks are performed.
- the solution is an ordered series of construction tasks.
- the costs in turn may include the labor costs of the workers and material costs for the construction.
- Still another example of a real-world application domain which may be formulated as a CSP is the assignment of crews to airline flights.
- the variables represent entities such as the airplanes, crews, airplane locations, and airplane routes.
- the constraints represent conditions such as each crew being assigned to only one flight and each flight leaving from an airport at which a flight previously arrived.
- the solution is an assignment of the crews to the flights, and the associated costs include aspects such as fuel costs and crew salaries.
- application domains in which solutions may be found using CSP formulations include aspects integrated circuit design, scheduling workers (e.g., assigning nurse shifts in a hospital), etc.
- real-world application domain refers to an environment like one of the examples described above where the variables, states, constraints, and costs describe entities that have a physical presence and/or meaning in the real world.
- the solution to the CSP problem output by the CSP server 120 likewise represents an assignment of variables to states that may be implemented in the physical world to solve the problem modeled by the CSP.
- the network 130 illustrated in FIG. 1 uses standard communications technologies and/or protocols to facilitate data transmission among the computer networks.
- the network 130 can include links using technologies such as Ethernet, 802.11, worldwide interoperability for microwave access (WiMAX), 3G, digital subscriber line (DSL), asynchronous transfer mode (ATM), InfiniBand, PCI Express Advanced Switching, etc.
- the networking protocols used on the network 130 can include multiprotocol label switching (MPLS), the transmission control protocol/Internet protocol (TCP/IP), the User Datagram Protocol (UDP), the hypertext transport protocol (HTTP), the simple mail transfer protocol (SMTP), the file transfer protocol (FTP), etc.
- MPLS multiprotocol label switching
- TCP/IP transmission control protocol/Internet protocol
- UDP User Datagram Protocol
- HTTP hypertext transport protocol
- SMTP simple mail transfer protocol
- FTP file transfer protocol
- the data exchanged over the network 130 can be represented using technologies and/or formats including the hypertext markup language (HTML), the extensible markup language (XML), JavaScript, VBScript, Flash, PDF, PostScript, etc.
- HTML hypertext markup language
- XML extensible markup language
- JavaScript JavaScript
- VBScript Flash
- PDF PostScript
- all or some of links can be encrypted using conventional encryption technologies such as secure sockets layer (SSL), transport layer security (TLS), virtual private networks (VPNs), Internet Protocol security (IPsec), etc.
- SSL secure sockets layer
- TLS transport layer security
- VPNs virtual private networks
- IPsec Internet Protocol security
- the entities can use custom and/or dedicated data communications technologies instead of, or in addition to, the ones described above.
- FIG. 2 is a high-level block diagram illustrating a computer 200 for serving as a client 110 or a CSP server 120 .
- the computer 200 includes at least one processor 202 coupled to a chipset 204 .
- the chipset 204 includes a memory controller hub 220 and an input/output (I/O) controller hub 222 .
- a memory 206 and a graphics adapter 212 are coupled to the memory controller hub 220 , and a display 218 is coupled to the graphics adapter 212 .
- a storage device 208 , keyboard 210 , pointing device 214 , and network adapter 216 are coupled to the I/O controller hub 222 .
- Other embodiments of the computer 200 have different architectures.
- the storage device 208 is a non-transitory computer-readable storage medium such as a hard drive, compact disk read-only memory (CD-ROM), DVD, or a solid-state memory device.
- the memory 206 holds instructions and data used by the processor 202 .
- the pointing device 214 is a mouse, track ball, or other type of pointing device, and is used in combination with the keyboard 210 to input data into the computer 200 .
- the graphics adapter 212 displays images and other information on the display 218 .
- the network adapter 216 couples the computer 200 to one or more computer networks 130 .
- the computer 200 is adapted to execute computer program modules for providing functionality described herein.
- module refers to computer program logic used to provide the specified functionality.
- a module can be implemented in hardware, firmware, and/or software.
- program modules are stored on the storage device 208 , loaded into the memory 206 , and executed by the processor 202 .
- the types of computers used by the entities of FIG. 1 can vary depending upon the embodiment and the processing power required by the entity.
- the CSP server 120 might comprise multiple blade servers working together to provide the functionality described herein.
- the client 110 may comprise a smartphone with limited processing power.
- the computer 200 can lack some of the components described above, such as keyboards 210 , graphics adapters 212 , and displays 218 .
- FIG. 3 is a block diagram illustrating modules within the CSP server 120 , according to one embodiment.
- the CSP server 120 includes a CSP initialization module 310 , a binary tree search module 320 , a solution reporting module 330 , and a CSP data store 340 .
- the CSP initialization module 310 is configured initialize CSPs. Initializing a CSP includes at least one of receiving previously created specifications for a CSP and defining (or specifying or creating) new a CSP. Initializing a CSP also includes building a binary tree that represents a CSP.
- the CSP initialization module 310 receives a CSP specification from the client 110 .
- the CSP specification may be received as a CSP digital file.
- the CSP digital file includes all of the necessary information for describing the CSP including, for example, states, variables, constraints, costs, and qualifications for what qualifies as an efficient solution.
- the CSP digital file is stored using an extensible, compact, binary file format.
- the file format allows for the exchange of CSPs between entities, for example an entity that needs a CSP solved (e.g., the user of the client 110 ), and the entity who will solve the CSP (e.g., the CSP server 120 ).
- the file format allows for convenient storage of the CSP. Further, the file format allows the CSP to be easily recognized by a wide range of CSP-solving software or hardware applications.
- the file format may be varied to be represented in an XML format.
- the file format may be a text file.
- the file format may be parsed by a parser configured to interpret the file format.
- the file format defines a number of expressions each including one or more arguments.
- Each expression may represent a constraint, variable, or qualification for an efficient solution.
- Expressions may include an index argument that is unique among all expressions, in order to uniquely identify each expression.
- Each efficient solution qualification expression includes arguments specifying the conditions necessary for a solution to be eligible as an efficient solution.
- the expression may also include arguments listing the variables or costs relevant to the determination of the whether or not a solution is efficient.
- Each constraint expression has a type argument, indicating the type of operation performed by the constraint.
- the constraint may be a difference type constraint indicating a limit on the difference between two possible states of two different variables.
- the constraint also includes other arguments for testing and validating the constraint during a search. Continuing with the difference constraint example, if the constraint is that variable A minus variable B be less than 2, then the other arguments of the constraint would specify the variables relevant to the constraint, in this case A and B, the operation of subtraction, and the permitted outcomes of the constraint, in this case a value of less than two.
- Each variable expression may have an argument identifying the type of the variable. For example, if variable X is an integer, a type argument may specify it as an integer.
- the variable expression may also have arguments identifying the possible states of the variable. For example, if the variable X may have a state that is a value between 1 and 126, then the argument may indicate the minimum and maximum values of the variable.
- the CSP initialization module 310 may receive inputs from the client 110 so that a user of the client 110 may create a CSP.
- the CSP initialization module 310 receives input from the client 110 regarding the variables, states, costs, constraints, and efficient solution qualifications that will make up the specification of the CSP.
- the CSP initialization module 310 compiles the received input and creates the CSP.
- the created CSP is stored as a digital CSP file using the file format described above.
- the CSP initialization module 310 stores received or created specifications for CSPs in a CSP data store 340 .
- the CSP data store 340 may include a database and/or a file system.
- the supplemental information may be added to the digital CSP file containing the description of the CSP.
- the CSP initialization module 310 is further configured to construct a binary tree representing the CSP.
- the binary tree is a set of linked nodes, where each node has at most two child nodes and only a single parent node.
- Each node in the tree represents a decision regarding the assignment of each of one or more of the variables of the CSP to a state.
- the node structure obeys the constraints imposed by the CSP, such that no variable may take a state that contradicts a constraint. Based on the constraints imposed on the CSP and the number of available states for each variable, some nodes will have no children as all variables in the CSP will have been assigned to states. These leaf nodes represent solutions to the CSP. A cost can be determined for each solution based on the assigned states of each variable.
- the CSP data store 340 is configured to store the binary tree representing the CSP.
- the binary tree has a height that is a distance, in terms of a number of nodes, between the root node at the top of the binary tree to the leaf nodes at the bottom of the binary tree.
- the height may vary between different leaf nodes, based on the number of available states for each variable.
- a binary tree may have as many heights as it does leaf nodes. Any given node has a depth determined by the distance, in terms of number of nodes, between itself and the root node.
- the binary tree search module 320 searches the binary tree to determine one or more efficient solutions for the CSP.
- the search module 320 searches a binary tree using depth first searching. In depth first searching, the search module 320 iteratively searches a binary tree starting from the root node and progressing from each parent node to its child nodes. Each time the search module 320 traverses from a parent node to a child node, one or more variables are assigned to states. The search module 320 keeps track of the assignment of variables to states as it progresses to each node. When the search module 320 arrives at a leaf node, the search module records the solution and the cost of the solution in the CSP data store 340 . Along with each solution, the search module 320 stores in the CSP data store 340 the assignments of variables to states that make up the solution.
- the solutions stored in the CSP data store 340 may also include information designating them as efficient solutions.
- the search module 320 is configured to mark a stored solution as an efficient solution if the cost of the solution meets the qualifications specified by the CSP specification. In one embodiment, only efficient solutions are stored in the CSP data store 340 .
- the search module 320 After reaching a leaf node, the search module 320 continues searching by backing up to the previous parent node above the leaf node, and searching the other child node of the parent node. This child node may or may not be a leaf node. If the child node is not a leaf node, the search continues down the binary tree from parent to child as before, until the search module 320 reaches another leaf node. If the next child node is a leaf node, the search module 320 records in the CSP data store 340 the solution, cost, and assignments of variables to states. This process continues, such that each time the search module 320 reaches a leaf node, the search module steps backwards up the binary tree until it finds a child node it has not yet explored. The search module then continues searching down the tree starting at the unexplored child node.
- the search module 320 is configured to periodically stop the search of the binary tree while the search is in progress and begin a new iteration of the search.
- the search module 320 restarts the search when backtracking up the binary tree to the point where the search depth is less than a restart depth.
- the restart depth is determined based on the deepest depth previously searched within the binary tree minus a restart value.
- the restart depth is determined based on the current size of the binary tree. The current size of the binary tree may be determined based on the product of all possible states of all variables in the CSP.
- the restart depth is determined based on the deepest depth previously searched minus the restart value
- the restart value may be user specified, predetermined, or determined dynamically. For example, if the binary tree is known to have a height of 20 such that the leaf nodes are at depth 20, and if the restart value is 5, the restart depth is 15.
- the deepest depth previously searched, and consequently the restart depth, are determined during the search of the binary tree by the search module 320 .
- the search module 320 searches the binary tree until it reaches a leaf node.
- the search module then records, in the CSP data store 340 , the depth of the leaf node.
- the leaf node depth serves at least as an initial deepest depth previously searched.
- a counter is increased. The counter increased by one each time the search module 320 backtracks up the binary tree from a child node to a parent node above the depth of the leaf node that started the counter.
- the search module 320 may end up searching child nodes at depths greater than the initial deepest depth previously searched.
- the binary tree may contain leaf nodes with depths greater than the initial deepest depth previously searched. If another leaf node is discovered with a depth greater than the initial deepest depth previously searched, the search module 320 may continue searching differently depending upon the implementation In one embodiment, the deepest depth previously searched is updated to the depth of the new, deeper leaf node. The counter is also restarted. In another embodiment, the deepest depth previously is not updated from its initial value, and the counter only resumes increasing when above the search module 320 is backtracking to find unsearched child nodes above the initial deepest depth previously searched.
- the search is restarted when the counter meets or exceeds the restart value. Another way to state this is that the search is restarted when the current depth of the search by the search module 320 is less than the restart depth, where the restart depth is the deepest depth previously searched minus the restart value.
- the search module 320 may instruct the CSP initialization module 310 to reconstruct the binary tree.
- the binary tree may be reconstructed as a matter of course, or alternatively if the search module 320 receives an indication from the CSP initialization module 310 that it has received supplemental information for the description of the CSP.
- Supplemental information may include, for example, the addition of variables, states, and/or constraints to the CSP, or alternatively the removal of variables, states, or constraints from the CSP.
- the supplemental information may also modify the costs of states for variables, and change the conditions for what qualifies as an efficient solution.
- the reconstruction of the binary tree incorporates any supplemental information that has been received.
- the search module 320 is configured to generate a NoGood marker indicating a portion of the binary tree beneath the restart node that has already been searched during the current iteration of the search.
- the NoGood marker is stored in the CSP data store 340 .
- the NoGood marker designates that the marked portion of the binary tree does not need to be searched after the restart of the search during subsequent iterations of the search because this portion of the tree has already been searched (i.e., the portion of the binary tree is “no good” for future searching). Re-searching this portion of this tree would not only be duplicative, but also a waste of searching time that is better spent on other portions of the tree that have not yet been searched.
- a NoGood marker includes the assignments of variables to states that define the restart node. Described differently, the NoGood marker includes all of the assignments of variables to states between the root node and the restart node in the binary tree. A NoGood marker may also include one or more constraints relevant to the variables that have been assigned states in the restart node. As a consequence even if the binary tree is different in future search iterations due to reconstruction, the NoGood marker is still applicable to the reconstructed version of the tree. A NoGood marker may also include information such as the depth of the restart node, the decision to be made in the restart node, the parent of the restart node, and the children of the restart node.
- the search module 320 After establishing a NoGood marker and during subsequent iterations of the search, the search module 320 skips searching all nodes that match the variable to state assignments of any NoGood markers stored in the CSP data store 340 . Thus, the search module 320 skips searching all restart nodes from previous iterations of the search, as well as all child nodes of the restart nodes. Even if the binary tree has changed due to the receipt of supplemental information for the CSP, the variable to state assignment information stored in the CSP data store 340 allow the search module 320 to skip the appropriate nodes despite the change in binary tree structure.
- each NoGood marker will include comparatively more child nodes.
- each iteration of the search will re-search comparatively fewer nodes before encountering a NoGood marker.
- Restarting the search based on the deepest depth previously searched and the restart value will generally reduce the number of NoGood markers generated during the search relative to a case where search restarts and NoGood marker creation is based solely on the number of nodes searched before restart.
- NoGood markers are created solely based on the number of nodes previously searched, generally NoGood markers will be created at many different depths within the binary tree. Generally, some of these NoGood markers will be created deeper in the binary tree than others. The deeper in the binary tree a NoGood marker is created, the fewer child nodes it will cover, and thus the less nodes it will prevent from being researched.
- NoGood creation is based on the number of nodes searched, the more re-searching of previously searched nodes is performed, the more often NoGood markers will be created that are at least partially redundant with other NoGood markers created deeper in the tree. As a consequence, generally more NoGood markers will need to be created to completely search the binary tree as compared to a case where NoGood marker creation is based on the deepest depth previously searched and a restart value.
- the restart value can be tuned to switch between creating fewer NoGood markers and having longer search iterations, or creating more NoGood markers and having shorter search iterations. As future iterations of the search will not need to re-search branches of the binary tree marked by NoGood markers, the closer to the root node the NoGood markers appear, the fewer nodes will need to be re-searched in future iterations of the search. This decreases the overall amount of time required to perform the search.
- the solution reporting module 330 reports one or more efficient solutions identified by the search module 320 and stored in the CSP data store 340 .
- the solution reporting module 330 may report the efficient solutions to the client 110 .
- the solution reporting module 330 may also store the efficient solutions in a non-transitory storage medium.
- the solution reporting module 330 may additionally be configured to implement the efficient solutions in the real world, for example by programming the behavior of the computers 150 illustrated in FIG. 1 .
- FIG. 6 is an illustration of an example binary tree 600 with NoGood markers assigned, according to one embodiment.
- the non-solution nodes of the binary tree are labeled 1 through 27 .
- the root node is node 1 .
- the leaf nodes, or solutions, are labeled A through P.
- the depth of the deepest node previously searched is six nodes from the root node.
- the height of the binary tree is also six nodes, though this is not necessarily the case in all binary trees.
- the restart value for establishing the restart depth is three nodes, and thus the restart depth is three nodes below from the root node.
- Dashed line 610 indicates the line above which the search depth is above the restart depth.
- Node 10 illustrates a restart node where a search is restarted and a NoGood marker 620 is created.
- the NoGood marker 620 indicates to the search module 320 that node 10 and all of its children, here nodes 16 , 17 , and 20 - 23 and solutions A-H, have already been searched for a possible efficient solution.
- the scope of the nodes skipped is illustrated by dotted line 630 .
- FIG. 4 is a flow diagram illustrating a process for determining efficient solutions to a CSP, according to one embodiment.
- a CSP is initialized 410 by the CSP server 120 . Initialization of the CSP may entail receiving a previously generated specification of a CSP, or generating a CSP specification based on inputs received from a client.
- the CSP server 120 constructs 420 the CSP as a binary tree.
- the CSP server 120 searches 430 the binary tree representing the CSP. During the course of the search, the search may be restarted multiple times, and each time a search is restarted a NoGood marker may be added to mark variable to state assignments (e.g., nodes) that do not need to be searched on future iterations of the search.
- the CSP server 120 determines 440 one or more efficient solutions to the CSP and stores them in the CSP data store 240 . The efficient solutions are then reported 450 out by the CSP server 120 .
- FIG. 5 is a flow diagram further illustrating the search of a binary tree as discussed in FIG. 3 , according to one embodiment.
- the CSP server 120 determines 510 the deepest depth previously searched in the binary tree.
- the CSP server 120 monitors the search depth relative to a restart depth using a counter, and may also update the deepest depth searched.
- the search module determines 520 a restart depth for when to restart the search based on the deepest depth previously search minus the restart value.
- the CSP server 120 creates a NoGood marker 540 and restarts the search 550 . If the current search depth is not greater than the restart depth, the search module 320 continues searching.
- any reference to “one embodiment” or “an embodiment” means that a particular element, feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment.
- the appearances of the phrase “in one embodiment” in various places in the specification are not necessarily all referring to the same embodiment.
- the terms “comprises,” “comprising,” “includes,” “including,” “has,” “having” or any other variation thereof, are intended to cover a non-exclusive inclusion.
- a process, method, article, or apparatus that comprises a list of elements is not necessarily limited to only those elements but may include other elements not expressly listed or inherent to such process, method, article, or apparatus.
- “or” refers to an inclusive or and not to an exclusive or. For example, a condition A or B is satisfied by any one of the following: A is true (or present) and B is false (or not present), A is false (or not present) and B is true (or present), and both A and B are true (or present).
Abstract
Description
Claims (22)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/358,335 US8849741B2 (en) | 2012-01-25 | 2012-01-25 | NoGood generation based on search tree depth |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/358,335 US8849741B2 (en) | 2012-01-25 | 2012-01-25 | NoGood generation based on search tree depth |
Publications (2)
Publication Number | Publication Date |
---|---|
US20130191317A1 US20130191317A1 (en) | 2013-07-25 |
US8849741B2 true US8849741B2 (en) | 2014-09-30 |
Family
ID=48798061
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US13/358,335 Active 2032-12-29 US8849741B2 (en) | 2012-01-25 | 2012-01-25 | NoGood generation based on search tree depth |
Country Status (1)
Country | Link |
---|---|
US (1) | US8849741B2 (en) |
Families Citing this family (8)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20170308903A1 (en) * | 2014-11-14 | 2017-10-26 | Hewlett Packard Enterprise Development Lp | Satisfaction metric for customer tickets |
US10178587B2 (en) * | 2014-12-02 | 2019-01-08 | Wipro Limited | System and method for traffic offloading for optimal network performance in a wireless heterogeneous broadband network |
US10657180B2 (en) * | 2015-11-04 | 2020-05-19 | International Business Machines Corporation | Building and reusing solution cache for constraint satisfaction problems |
US10496663B2 (en) * | 2016-06-16 | 2019-12-03 | International Business Machines Corporation | Search journaling for operations analysis |
US10459960B2 (en) | 2016-11-08 | 2019-10-29 | International Business Machines Corporation | Clustering a set of natural language queries based on significant events |
US10423614B2 (en) * | 2016-11-08 | 2019-09-24 | International Business Machines Corporation | Determining the significance of an event in the context of a natural language query |
JP7094839B2 (en) * | 2018-09-04 | 2022-07-04 | 株式会社日立製作所 | Solution search device |
CN114493056B (en) * | 2022-04-18 | 2022-06-21 | 小柿子(北京)汽车供应链管理有限公司 | Cargo transportation method, cargo transportation system, computer device, and storage medium |
-
2012
- 2012-01-25 US US13/358,335 patent/US8849741B2/en active Active
Non-Patent Citations (1)
Title |
---|
Katsirelos et al. "Unrestricted Nogood Recording in CSP search", In Principles and Practice of Constraint Programming, 2003, pp. 1-15. * |
Also Published As
Publication number | Publication date |
---|---|
US20130191317A1 (en) | 2013-07-25 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US8849741B2 (en) | NoGood generation based on search tree depth | |
JP6985350B2 (en) | Data system summary | |
Li et al. | An efficient recommendation method for improving business process modeling | |
US10756982B2 (en) | Machine learning microservice architecture design tools and methods | |
Hegedüs et al. | A model-driven framework for guided design space exploration | |
US9710525B2 (en) | Adaptive learning of effective troubleshooting patterns | |
Kourtesis et al. | Semantic-based QoS management in cloud systems: Current status and future challenges | |
US11256755B2 (en) | Tag mapping process and pluggable framework for generating algorithm ensemble | |
US10013238B2 (en) | Predicting elements for workflow development | |
US20130151536A1 (en) | Vertex-Proximity Query Processing | |
van der Aalst et al. | A tour in process mining: From practice to algorithmic challenges | |
US20190005005A1 (en) | Tag mapping process and pluggable framework for generating algorithm ensemble | |
US8935144B2 (en) | System and method for examining concurrent system states | |
US20230215061A1 (en) | Project visualization system | |
US10127024B2 (en) | Managing reuse of assets in a workflow management system | |
US20140089898A1 (en) | Using multiple technical writers to produce a specified software documentation package | |
Nur et al. | User scenario 2 seq: Automated system to generate sequence diagram from user stories scenario | |
Chen et al. | Efficient resource constrained scheduling using parallel structure-aware pruning techniques | |
Paschke et al. | Corporate semantic web: Towards the deployment of semantic technologies in enterprises | |
Steinberger et al. | A tool for analyzing variability based on functional requirements and testing artifacts | |
JP4895373B2 (en) | Software product reuse method and system | |
US20230125621A1 (en) | Generating visualizations for semi-structured data | |
DeLuca et al. | Understanding Data Centers from Logs: Leveraging External Knowledge for Distant Supervision | |
Qiu et al. | Map-Reduce for Multiprocessing Large Data and Multi-threading for Data Scraping | |
Nguyen et al. | Identification and Interpretation of Change Patterns in Semantic 3D City Models |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:PERRON, LAURENT;REEL/FRAME:027595/0050Effective date: 20120125 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044277/0001Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551)Year of fee payment: 4 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 8TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1552); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 8 |