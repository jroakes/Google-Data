CROSS-REFERENCE TO RELATED APPLICATIONS
The present application claims the benefit of priority under 35 U.S.C. ยง 120 as a continuation in part of U.S. patent application Ser. No. 15/772,998 filed May 2, 2018, which is the U.S. national phase of International Application No. PCT/US2018/030451, filed May 1, 2018, and claims priority to U.S. Provisional Patent Application No. 62/660,129, filed Apr. 19, 2018. Each of the foregoing applications are incorporated by reference herein in their entirety.
BACKGROUND
Users can provide commands, queries, and requests to computers. The computer can perform various tasks based on the commands, queries, or requests to the computers. Modeling the dialog between the computer and the user to receive the commands, queries, and requests can be complicated and labor intensive, and may necessitate substantial development overhead associated with handling all possible inputs and combinations and orderings thereof. Such complicated models can occupy a relatively large amount of space in computer memory and may also require updating over time to handle previously unforeseen inputs and combinations and orderings thereof.
SUMMARY
Techniques are described herein for modelling conversations using dependency graph data structures to facilitate the interaction of users with automated assistants when performing actions performed by computing services. An automated assistant may utilize a dependency graph data structure to guide or otherwise control a human-to-computer dialog session with a user, e.g., by generating one or more outputs or prompts that are presented to the user on a computing device operated by that user.
As will be explained in more detail below, the concepts described herein may enable an automated assistant to obtain selected, required information in an efficient manner and, in doing so, the concepts may allow the automated assistant to operate in an effective manner whilst also making efficient use of hardware resources on a user computing device (e.g. a client computing device). For example, the concepts described herein may allow the automated assistant to make most efficient use of microphone and/or speaker hardware on a user computing device so that power consumption on the device may be reduced.
Therefore, consistent with one aspect of the invention, a method implemented using one or more processors may include determining an action to be performed by a computing service for a user of a computing device in communication with an automated assistant implemented at least in part by the one or more processors, and with the automated assistant, causing the computing service to perform the action for the user of the computing device by accessing a dependency graph data structure for the action, the dependency graph data structure including a plurality of nodes and a plurality of directed edges, each node identifying an action method that accesses the computing service or an assistant method that collects one or more parameters for use in performing the action, and each directed edge connecting a respective pair of nodes from among the plurality of nodes and identifying at least one parameter generated by the action method or assistant method identified by one node among the respective pair of nodes and utilized by the action method or assistant method identified by the other node among the respective pair of nodes, conducting a human-to-computer dialog session between the user and the automated assistant to determine one or more parameters used to perform the action, including generating one or more natural language outputs for presentation by the computing device operated by the user using the dependency graph data structure and receiving one or more instances of free-form natural language input that are received at one or more input components of the computing device operated by the user, and initiating performance of the action by the computing service using the determined one or more parameters.
In some implementations, a first node among the plurality of nodes in the dependency graph data structure identifies a first action method that calls the computing service, and initiating performance of the action by the computing service includes executing the first action method. The first action method includes a call operation including a plurality of inputs, and executing the first action method includes executing the call operation using the determined one or more parameters as inputs among the plurality of inputs for the call operation.
The dependency graph data structure includes a specification that defines methods and dependencies therebetween, and the first action method is marked as indexable in the specification to indicate that the first action method calls the computing service to perform the action. The first action method calls the computing service to perform the action, and a second node among the plurality of nodes in the dependency graph data structure identifies a second action method that calls the computing service to obtain intermediate data for use in performing the action.
A first node among the plurality of nodes in the dependency graph data structure identifies a first assistant method that includes a first prompt that requests a first parameter, and generating the one or more natural language outputs includes executing the first assistant method to generate a first natural language output including the first prompt. Determining the action to be performed by the computing service is performed by the automated assistant and is based upon an initial natural language input received at the computing device of the user and specifying a first parameter identified by a first directed edge in the dependency graph data structure, the first directed edge connects a first node that identifies a first assistant method that generates the first parameter and a second node that identifies a first action method that utilizes the first parameter, and conducting the human-to-computer dialog session between the user and the automated assistant includes bypassing generation of a natural language output to request the first parameter in response to determining that the first parameter is specified in the initial natural language input.
A first parameter identified by a first directed edge in the dependency graph data structure connects a first node that identifies a first assistant method that generates the first parameter and a second node that identifies a first action method that utilizes the first parameter, and conducting the human-to-computer dialog session between the user and the automated assistant includes bypassing generation of a natural language output to request the first parameter in response to determining that the first parameter is determinable without requesting the first parameter from the user. Determining that the first parameter is determinable without requesting the first parameter from the user includes determining that the first parameter is determinable from stored data associated with the user.
Conducting the human-to-computer dialog session between the user and the automated assistant to determine the one or more parameters used to perform the action includes ordering the one or more generated natural language outputs using the dependency graph data structure. Some implementations may also include invalidating one or more of the determined one or more parameters during the human-to-computer dialog session in response to receiving a first instance of free-form natural language input among the one or more instances of free-form natural language input, accessing the dependency graph data structure to identify one or more action methods or assistant methods identified in the dependency graph data structure to re-execute in order to update the one or more invalidated parameters, and re-executing the one or more identified action methods or assistant methods to update the one or more invalidated parameters.
Invalidating the one or more parameters maintains one or more other parameters as valid such that re-execution of one or more action methods or assistant methods used to determine the one or more other parameters is bypassed when re-executing the one or more identified action methods or assistant methods. Determining the action is performed by the automated assistant and includes selecting the action from among a plurality of actions using the dependency graph data structure. The computing service is a third party computing service, and initiating performance of the action by the computing service using the determined one or more parameters includes calling the third party computing service using the determined one or more parameters.
The computing service is a cloud computing service, and the computing service is resident on the computing device operated by the user. The dependency graph data structure defines a directed acyclic graph. The action creates a reservation, a first node among the plurality of nodes identifies a first action method that calls the computing service to search for available time slots, and a second node among the plurality of nodes identifies a second action method that calls the computing service to reserve an available time slot. The action obtains a product or a ticket to an event.
Consistent with another aspect of the invention, a method implemented using one or more processors may include receiving through a computer interface a plurality of parameters to be used by an automated assistant to cause a computing service to perform an action for a user of a computing device in communication with the automated assistant, determining a plurality of dependencies between the plurality of parameters, building a dependency graph data structure for the action using the one or more processors, the dependency graph data structure configured for use in conducting a human-to-computer dialog session between the user and the automated assistant to determine one or more parameters used to perform the action, including for generating one or more natural language outputs for presentation by the computing device operated by the user, where building the dependency graph data structure for the action includes building a plurality of nodes for the dependency graph data structure using the received plurality of parameters, including building at least one node identifying an action method that accesses the computing service and building at least one assistant method that collects one or more parameters from among the received plurality of parameters, and building a plurality of directed edges for the dependency graph data structure using the determined plurality of dependencies, each directed edge connecting a respective pair of nodes from among the plurality of nodes and identifying at least one parameter from among the received plurality of parameters that is generated by the action method or assistant method identified by one node among the respective pair of nodes and utilized by the action method or assistant method identified by the other node among the respective pair of nodes, and generating a call operation in the action method that calls the computing service with one or more of the received plurality of parameters to perform the action.
The computing service is a third party computing service, and the call operation is configured to access the third party computing service. Determining the plurality of dependencies includes receiving the plurality of dependencies through the computer interface. Receiving the plurality of parameters includes receiving a plurality of action call definitions.
In addition, some implementations may include a system including one or more processors and memory operably coupled with the one or more processors, where the memory stores instructions that, in response to execution of the instructions by one or more processors, cause the one or more processors to perform any of the aforementioned methods. Some implementations also include at least one non-transitory computer-readable medium including instructions that, in response to execution of the instructions by one or more processors, cause the one or more processors to perform any of the aforementioned methods.
According to at least one aspect of the disclosure, a system to update response data in a networked system can include a data processing system. The data processing system can include one or more processors and memory. The one or more processors can execute a natural language processor, fulfillment engine, and a digital component selector. The data processing system can receive, by the natural language processor, a first input audio signal detected by a sensor at a first client device. The data processing system can parse, by the natural language processor component, the first input audio signal to identify a request in the first input audio signal. The data processing system can select, by the fulfillment engine, an action based on the request in the first input audio signal and a dependency graph data structure based on the action. The dependency graph data structure can include a first node and a second node each identifying a respective assistant method and including a parameter to fulfill the action. The dependency graph data structure can include a directed edge connecting the first node and the second node and identifying at least one parameter generated by the assistant method. The dependency graph data structure can include a digital component node comprising a digital component parameter. The data processing system can receive, by the natural language processor, a second input audio signal detected by the sensor at the first client device. The data processing system can parse, by the natural language processor component, the second input audio signal to identify a response parameter in the second input audio signal. The data processing system can update, by the fulfillment engine, the parameter of the first node based on the response parameter and the digital component parameter based on the response parameter. The data processing system can select, by the digital component selector, a digital component based on the digital component parameter of the at least one digital component node. The data processing system can transmit, via the interface, the digital component to the first client device and the dependency graph data structure to a computing service to fulfill the request based on the dependency graph data structure.
According to at least one aspect of the disclosure, a method to update response data in a networked system can include receiving, by a natural language processor, a first input audio signal detected by a sensor at a first client device. The method can include parsing, by the natural language processor component, the first input audio signal to identify a request in the first input audio signal. The method can include selecting, by the fulfillment engine, an action based on the request in the first input audio signal and a dependency graph data structure based on the action. The dependency graph data structure can include a first node and a second node each identifying a respective assistant method and including a parameter to fulfill the action, a directed edge connecting the first node and the second node and identifying at least one parameter generated by the assistant method, and a digital component node comprising a digital component parameter. The method can include receiving, by the natural language processor, a second input audio signal detected by the sensor at the first client device. The method can include parsing, by the natural language processor component, the second input audio signal to identify a response parameter in the second input audio signal. The method can include updating, by the fulfillment engine, the parameter of the first node based on the response parameter and the digital component parameter based on the response parameter. The method can include selecting, by the digital component selector, a digital component based on the digital component parameter of the at least one digital component node. The method can include transmitting, via the interface, the digital component to the first client device and the dependency graph data structure to a computing service to fulfill the request based on the dependency graph data structure.
It should be appreciated that all combinations of the foregoing concepts and additional concepts described in greater detail herein are contemplated as being part of the subject matter disclosed herein. For example, all combinations of claimed subject matter appearing at the end of this disclosure are contemplated as being part of the subject matter disclosed herein.
BRIEF DESCRIPTION OF THE DRAWINGS
FIG. 1 is a block diagram of an example computing environment in which implementations disclosed herein may be implemented.
FIG. 2 is a block diagram of an example dependency graph data structure for modeling a conversation for an example restaurant reservation booking action.
FIGS. 3A-3G illustrate example implementations of action and assistant methods represented in the dependency graph data structure of FIG. 2.
FIG. 4 is a block diagram of an example dependency graph data structure for modeling a conversation for an example event ticket purchasing action.
FIGS. 5A-5I illustrate example implementations of action and assistant methods represented in the dependency graph data structure of FIG. 4.
FIG. 6 is a flowchart illustrating an example sequence of operations for conducting a human-to-computer dialog session using a dependency graph data structure, in accordance with various implementations.
FIG. 7 depicts an example restaurant reservation booking dialog between a user and an automated assistant using a computing device of the user, in accordance with various implementations.
FIG. 8 depicts another example restaurant reservation booking dialog between a user and an automated assistant using a computing device of the user, in accordance with various implementations.
FIG. 9 depicts an example event ticket purchasing dialog between a user and an automated assistant using a standalone interactive speaker, in accordance with various implementations.
FIG. 10A is a flowchart illustrating an example sequence of operations for generating and deploying a dependency graph data structure, in accordance with various implementations.
FIG. 10B is a flowchart illustrating an example method to update response data, in accordance with various implementations.
FIG. 11 illustrates an example architecture of a computing device.
DETAILED DESCRIPTION
Humans may engage in human-to-computer dialogs with interactive software applications referred to herein as โautomated assistantsโ (also referred to as โchatbots,โ โinteractive personal assistants,โ โintelligent personal assistants,โ โpersonal voice assistants,โ โconversational agents,โ etc.). For example, humansโwhich when they interact with automated assistants may be referred to as โusersโโmay provide commands, queries, and/or requests using free-form natural language input. Free-form natural language may include vocal utterances converted into text using speech recognition and/or typed free-form natural language input.
Automated assistants enable users to obtain information, access services, and/or perform various tasks. For example, users are able to execute searches, get directions, and in some cases, interact with third party computing services. These third party computing service interactions, access to which may be facilitated using application programming interfaces (โAPIsโ) provided by automated assistants and/or the third party computing services, allow users to perform a variety of actions, such as calling cars from ride-sharing applications, ordering goods or services (e.g., pizza), making reservations, and so forth.
Automated assistants converse with users using voice recognition and natural language processing, with some also utilizing machine learning and other artificial intelligence technologies, for instance, to predict user intents. Automated assistants may be adept at holding conversations with users in natural, intuitive ways, in part because they understand dialog context. To utilize dialog context, an automated assistant may preserve recent inputs from the user, questions that came from the user, and/or responses/questions provided by the automated assistant. For example, the user might ask, โWhere is the closest coffee shop?โ, to which the automated assistant might reply, โTwo blocks east.โ The user might then ask, โHow late is it open?โ By preserving at least some form of dialog context, the automated assistant is able to determine that the pronoun โitโ refers to โcoffee shopโ (i.e., co-reference resolution).
However, with conventional automated assistants, particularly with respect to actions associated with third party and other computing services that require a number of input parameters in order to be performed effectively, modeling the conversations to collect the required input parameters can be complicated and labor intensive, and may necessitate substantial development overhead associated with handling all possible inputs and combinations and orderings thereof. Such complicated models can occupy a relatively large amount of space in computer memory and may also require updating over time to handle previously unforeseen inputs and combinations and orderings thereof. Conversations may also be constrained and inflexible to varying user inputs, resulting in a more robotic and less realistic interaction with an automated assistant.
Now turning to FIG. 1, an example system 100 in which techniques disclosed herein may be implemented is illustrated. The system 100 includes a plurality of client computing devices 106 1-N. Each client device 106 may execute a respective instance of an automated assistant client 118. One or more cloud-based automated assistant components 119, such as a natural language understanding engine 135, may be implemented on one or more computing systems (collectively referred to as a โcloudโ computing system) that are communicatively coupled to client devices 106 1-N via one or more local and/or wide area networks (e.g., the Internet) indicated generally at 110. The cloud-based automated assistant components 119 can include a content selector component 119 that receives digital components from a digital component provider 128.
An instance of an automated assistant client 118, by way of its interactions with one or more cloud-based automated assistant components 119, may form what appears to be, from the user's perspective, a logical instance of an automated assistant 120 with which the user may engage in a human-to-computer dialog. Two instances of such an automated assistant 120 are depicted in FIG. 1. A first automated assistant 120A encompassed by a dashed line serves a first user (not depicted) operating first client device 106 1 and includes automated assistant client 118 1 and one or more cloud-based automated assistant components 119. A second automated assistant 120B encompassed by a dash-dash-dot line serves a second user (not depicted) operating another client device 106 N and includes automated assistant client 118 N and one or more cloud-based automated assistant components 119.
Each user that engages with an automated assistant client 118 executing on a client device 106 may, in effect, engage with his or her own logical instance of an automated assistant 120. An โautomated assistantโ as used herein as โservingโ a particular user can refer to the combination of an automated assistant client 118 executing on a client device 106 operated by the user and one or more cloud-based automated assistant components 119 (which may be shared amongst multiple automated assistant clients 118). The automated assistant 120 may respond to a request from any user regardless of whether the user is actually โservedโ by that particular instance of automated assistant 120.
The client devices 106 1-N may include, for example, one or more of: a desktop computing device, a laptop computing device, a tablet computing device, a mobile phone computing device, a computing device of a vehicle of the user (e.g., an in-vehicle communications system, an in-vehicle entertainment system, an in-vehicle navigation system), a standalone interactive speaker, a smart appliance such as a smart television, and/or a wearable apparatus of the user that includes a computing device (e.g., a watch of the user having a computing device, glasses of the user having a computing device, a virtual or augmented reality computing device). Additional and/or alternative client computing devices may be provided.
Each of the client computing devices 106 1-N may operate a variety of different applications, such as a corresponding one of a plurality of message exchange clients 107 1-N. Message exchange clients 107 1-N may come in various forms and the forms may vary across the client computing devices 106 1-N and/or multiple forms may be operated on a single one of the client computing devices 106 1-N. One or more of the message exchange clients 107 1-N may come in the form of a short messaging service (โSMSโ) and/or multimedia messaging service (โMMSโ) client, an online chat client (e.g., instant messenger, Internet relay chat, or โIRC,โ etc.), a messaging application associated with a social network, a personal assistant messaging service dedicated to conversations with automated assistant 120, and so forth. One or more of the message exchange clients 107 1-N may be implemented via a webpage or other resources rendered by a web browser (not depicted) or other application of client computing device 106.
The automated assistant 120 engages in human-to-computer dialog sessions with one or more users via user interface input and output devices of one or more client devices 106 1-N. The automated assistant 120 may engage in a human-to-computer dialog session with a user in response to user interface input provided by the user via one or more user interface input devices of one of the client devices 106 1-N. In some of those implementations, the user interface input is explicitly directed to automated assistant 120. For example, one of the message exchange clients 107 1-N may be a personal assistant messaging service dedicated to conversations with automated assistant 120 and user interface input provided via that personal assistant messaging service may be automatically provided to automated assistant 120. Also, for example, the user interface input may be explicitly directed to automated assistant 120 in one or more of the message exchange clients 107 1-N based on particular user interface input that indicates automated assistant 120 is to be invoked. For instance, the particular user interface input may be one or more typed characters (e.g., @AutomatedAssistant), user interaction with a hardware button and/or virtual button (e.g., a tap, a long tap), an oral command (e.g., โHey Automated Assistantโ), and/or other particular user interface input.
The automated assistant 120 may engage in a human-to-computer dialog session in response to user interface input, even when that user interface input is not explicitly directed to automated assistant 120. For example, automated assistant 120 may examine the contents of user interface input and engage in a dialog session in response to certain terms being present in the user interface input and/or based on other cues. In many implementations, the user can utter commands, searches, etc., and automated assistant 120 may utilize speech recognition to convert the utterances into text, and respond to the text accordingly, e.g., by providing search results, general information, and/or taking one or more responsive actions (e.g., playing media, launching a game, ordering food, etc.). The automated assistant 120 can additionally or alternatively respond to utterances without converting the utterances into text. For example, the automated assistant 120 can convert voice input into an embedding, into entity representation(s) (that indicate entity/entities present in the voice input), and/or other โnon-textualโ representation and operate on such non-textual representation. Accordingly, implementations described herein as operating based on text converted from voice input may operate on the voice input directly and/or other non-textual representations of the voice input.
Each of the client computing devices 106 1-N and computing device(s) operating cloud-based automated assistant components 119 may include one or more memories for storage of data and software applications, one or more processors for accessing data and executing applications, and other components that facilitate communication over a network. The operations performed by one or more of the client computing devices 106 1-N and/or by automated assistant 120 may be distributed across multiple computer systems. Automated assistant 120 may be implemented as, for example, computer programs running on one or more computers in one or more locations that are coupled to each other through a network. In various implementations, for example, some or all of the functionality of an automated assistant may be distributed between multiple computer systems, or even to a client computing device. For example, the functionality discussed herein with respect to conducting human-to-dialog dialog sessions using dependency graph data structures and initiating performance of actions may be performed entirely within a client computing device, e.g., so that such functionality is available to a user even when no online connectivity exists.
As noted above, in various implementations, each of the client computing devices 106 1-N may operate an automated assistant client 118. In various embodiments, each automated assistant client 118 may include a corresponding speech capture/text-to-speech (โTTSโ)/speech-to-text (โSTTโ) module 114. In other implementations, one or more aspects of speech capture/TTS/STT module 114 may be implemented separately from automated assistant client 118. In various implementations, speech capture/TTS/STT module 114 may generate speech recognition output based on a vocal query.
Each speech capture/TTS/STT module 114 may be configured to perform one or more functions: capture a user's speech, e.g., via a microphone; convert that captured audio to text (and/or to other representations or embeddings); and/or convert text to speech. For example, because a client device 106 may be relatively constrained in terms of computing resources (e.g., processor cycles, memory, battery, etc.), the speech capture/TTS/STT module 114 that is local to each client device 106 may be configured to convert a finite number of different spoken phrasesโparticularly phrases that invoke automated assistant 120โto text (or to other forms, such as lower dimensionality embeddings). Other speech input may be sent to cloud-based automated assistant components 119, implemented at one or more remote cloud-based computer servers, which may include a cloud-based TTS module 116 and/or a cloud-based STT module 117.
Cloud-based STT module 117 may be configured to leverage the virtually limitless resources of the cloud to convert audio data captured by speech capture/TTS/STT module 114 into text (which may then be provided to natural language processor 122). Cloud-based TTS module 116 may be configured to leverage the virtually limitless resources of the cloud to convert textual data (e.g., natural language responses formulated by automated assistant 120) into computer-generated speech output. The TTS module 116 may provide the computer-generated speech output to client device 106 to be output directly, e.g., using one or more speakers. In other implementations, textual data (e.g., natural language responses) generated by automated assistant 120 may be provided to speech capture/TTS/STT module 114, which may then convert the textual data into computer-generated speech that is output locally.
Automated assistant 120 (and in particular, cloud-based automated assistant components 119) may include a natural language understanding engine 135, the aforementioned TTS module 116, the aforementioned STT module 117, and other components that are described in more detail below. One or more of the engines and/or modules of automated assistant 120 may be omitted, combined, and/or implemented in a component that is separate from automated assistant 120. To protect privacy, one or more of the components of automated assistant 120, such as natural language understand engine 135, speech capture/TTS/STT module 114, etc., may be implemented at least on part on client devices 106 (e.g., to the exclusion of the cloud).
The automated assistant 120 generates responsive content in response to various inputs generated by a user of one of the client devices 106 1-N during a human-to-computer dialog session with automated assistant 120. Automated assistant 120 may provide the responsive content (e.g., over one or more networks when separate from a client device of a user) for presentation to the user as part of the dialog session. For example, automated assistant 120 may generate responsive content in response to free-form natural language input provided via one of the client devices 106 1-N. As used herein, free-form natural language input is input that is formulated by a user and that is not constrained to a group of options presented for selection by the user.
As used herein, a โdialog sessionโ may include a logically-self-contained exchange of one or more messages between a user and automated assistant 120 (and in some cases, other human participants). Automated assistant 120 may differentiate between multiple dialog sessions with a user based on various signals, such as passage of time between sessions, change of user context (e.g., location, before/during/after a scheduled meeting, etc.) between sessions, detection of one or more intervening interactions between the user and a client device other than dialog between the user and the automated assistant (e.g., the user switches applications for a while, the user walks away from then later returns to a standalone voice-activated product), locking/sleeping of the client device between sessions, change of client devices used to interface with one or more instances of automated assistant 120, change of input/output (โI/Oโ) modalities employed by the user, and so forth.
Natural language processor 122 of natural language understanding engine 135 processes natural language input generated by users via client devices 106 1-N and may generate annotated output (e.g., in textual form) for use by one or more other components of automated assistant 120. For example, the natural language processor 122 may process natural language free-form input that is generated by a user via one or more user interface input devices of client device 106 1. The generated annotated output includes one or more annotations of the natural language input and optionally one or more (e.g., all) of the terms of the natural language input.
The natural language processor 122 is configured to identify and annotate various types of grammatical information in natural language input. For example, the natural language processor 122 may include a morphological engine that may separate individual words into morphemes and/or annotate the morphemes, e.g., with their classes. Natural language processor 122 may also include a part of speech tagger configured to annotate terms with their grammatical roles. For example, the part of speech tagger may tag each term with its part of speech such as โnoun,โ โverb,โ โadjective,โ โpronoun,โ etc. For example, the natural language processor 122 may include a dependency parser (not depicted) configured to determine syntactic relationships between terms in natural language input. For example, the dependency parser may determine which terms modify other terms, subjects and verbs of sentences, and so forth (e.g., a parse tree)โand may make annotations of such dependencies.
The natural language processor 122 may include an entity tagger (not depicted) configured to annotate entity references in one or more segments such as references to people (including, for instance, literary characters, celebrities, public figures, etc.), organizations, locations (real and imaginary), and so forth. Data about entities may be stored in one or more databases, such as in a knowledge graph (not depicted). The knowledge graph may include nodes that represent known entities (and in some cases, entity attributes), as well as edges that connect the nodes and represent relationships between the entities. For example, a โbananaโ node may be connected (e.g., as a child) to a โfruitโ node,โ which in turn may be connected (e.g., as a child) to โproduceโ and/or โfoodโ nodes. As another example, a restaurant called โHypothetical Cafรฉโ may be represented by a node that also includes attributes such as its address, type of food served, hours, contact information, etc. The โHypothetical Cafรฉโ node can be connected by an edge (e.g., representing a child-to-parent relationship) to one or more other nodes, such as a โrestaurantโ node, a node representing a city and/or state in which the restaurant is located, and so forth.
The entity tagger of the natural language processor 122 may annotate references to an entity at a high level of granularity (e.g., to enable identification of all references to an entity class such as people) and/or a lower level of granularity (e.g., to enable identification of all references to a particular entity such as a particular person). The entity tagger may rely on content of the natural language input to resolve a particular entity and/or may optionally communicate with a knowledge graph or other entity database to resolve a particular entity.
The natural language processor 122 may include a coreference resolver (not depicted) configured to group, or โcluster,โ references to the same entity based on one or more contextual cues. For example, the coreference resolver may be utilized to resolve the term โthereโ to โHypothetical Cafรฉโ in the natural language input โI liked Hypothetical Cafรฉ last time we ate there.โ
One or more components of the natural language processor 122 may rely on annotations from one or more other components of the natural language processor 122. For example, the named entity tagger may rely on annotations from the coreference resolver and/or dependency parser in annotating all mentions to a particular entity. Also, for example, the coreference resolver may rely on annotations from the dependency parser in clustering references to the same entity. In processing a particular natural language input, one or more components of the natural language processor 122 may use related prior input and/or other related data outside of the particular natural language input to determine one or more annotations.
Natural language understanding engine 135 may also include an intent matcher 136 that is configured to determine, based on the annotated output of natural language processor 122, an intent of a user engaged in a human-to-computer dialog session with automated assistant 120. While depicted separately from natural language processor 122 in FIG. 1, in other implementations, intent matcher 136 may be an integral part of natural language processor 122 (or more generally, of a pipeline that includes natural language processor 122). The natural language processor 122 and intent matcher 136 may collectively form the aforementioned โnatural language understandingโ engine 135.
Intent matcher 136 may use various techniques to determine an intent of the user. The intent matcher 136 may have access to one or more databases 137 that include, for instance, a plurality of mappings between grammars and responsive actions (or more generally, intents). One or more databases 137 may store one or more machine learning models that are trained to generate output indicative of user intent, based on the user's input.
Grammars may be selected, formulated (e.g., by hand), and/or learned over time, e.g., to represent the most common intents of users. For example, one grammar, โplay <artist>โ, may be mapped to an intent that invokes a responsive action that causes music by the <artist> to be played on the client device 106 operated by the user. Another grammar, โ[weather|forecast] today,โ may be match-able to user queries such as โwhat's the weather todayโ and โwhat's the forecast for today?โ As seen in the โplay <artist>โ example grammar, some grammars have slots (e.g., <artist>) that can be filled with slot values (or โparametersโ). Slot values may be determined in various ways. Often users will provide the slot values proactively. For example, for a grammar โOrder me a <topping> pizza,โ a user may likely speak the phrase โorder me a sausage pizza,โ in which case the slot <topping> is filled automatically. Additionally or alternatively, if a user invokes a grammar that includes slots to be filled with slot values, without the user proactively providing the slot values, automated assistant 120 may solicit those slot values from the user (e.g., โwhat type of crust do you want on your pizza?โ).
In contrast to many grammars (which may be created manually), machine learning models may be trained automatically, e.g., using logs of interactions between users and automated assistants. Machine learning models may take various forms, such as neural networks. They may be trained in various ways to predict user intent from user input. For example, training data may be provided that includes individual training examples. Each training example may include, for instance, free form input from a user (e.g., in textual or non-textual form) and may be labeled (e.g., by hand) with an intent. The training example may be applied as input across the machine learning model (e.g., a neural network) to generate output. The output may be compared to the label to determine an error. This error may be used to train the model, e.g., using techniques such as gradient descent (e.g., stochastic, batch, etc.) and/or back propagation to adjust weights associated with hidden layer(s) of the model. Once such a model is trained with a (usually large) number of training examples, it may be used to generate output that predicts intents from unlabeled free-form natural language inputs.
The system 100 can include the digital component provider device 128. The digital component provider device 128 can provide audio, visual, or multimedia based digital components (which can also be referred to as content) for presentation by the client device 106 as an audio output digital component or visual output digital component. The digital component can be or include other digital components. The digital component can be or include a digital object. The digital component can be configured for a parametrically driven text to speech technique. The digital component can be configured for text-to-speech (TTS) implementations that convert normal language text into speech. The digital component can be input to an application programming interface that utilizes a speech-synthesis capability to synthesize text into natural-sounding speech in a variety of languages, accents, and voices. The digital component can be coded as plain text or a speech synthesis markup language (SSML). SSML can include parameters that can be set to control aspects of speech, such as pronunciation, volume, pitch, or rate that can form an acoustic fingerprint or native voice.
The digital component provider device 128 can provide selection criteria for the digital component, such as a value, keyword, concept, or other metadata or information to facilitate a content selection process. The digital component provider device 128 can also provide audio based digital components (or other digital components) to the content selector component 129 where they can be stored in a data repository. The content selector component 129 can select the audio digital components (or digital components configured for a parametrically driven text, image, or video to speech technique) and provide (or instruct the digital component provider device 128 to provide) the audio digital components to the client device 106. The audio based digital components can be exclusively audio or can be combined with text, image, or video data.
The digital component provider device 128 can provide the digital component to the content selector component 129 for storage in the data repository in a content data structure. The content selector component 129 can retrieve the digital component responsive to a request for content from the client device 106 or otherwise determining to provide the digital component.
The digital component provider device 128 can establish a digital component campaign (or electronic content campaign). A digital component campaign can refer to one or more content groups that correspond to a common theme. A content campaign can include a hierarchical data structure that includes content groups, digital component data objects (e.g., digital components or digital objects), and content selection criteria. To create a digital component campaign, digital component provider device 128 can specify values for campaign level parameters of the digital component campaign. The campaign level parameters can include, for example, a campaign name, a preferred content network for placing digital component objects, a value of resources to be used for the digital component campaign, start and end dates for the content campaign, a duration for the digital component campaign, a schedule for digital component object placements, language, geographical locations, type of computing devices on which to provide digital component objects. In some cases, an impression can refer to when a digital component object is fetched from its source and is countable. Due to the possibility of click fraud, robotic activity can be filtered and excluded, as an impression. Thus, an impression can refer to a measurement of responses from a Web server to a page request from a browser, which is filtered from robotic activity and error codes, and is recorded at a point as close as possible to opportunity to render the digital component object for display on the computing device 104. In some cases, an impression can refer to a viewable or audible impression; e.g., the digital component object or digital component is at least partially (e.g., 20%, 30%, 30%, 40%, 50%, 60%, 70%, or more) viewable on a display device of the client device 106, or audible via a speaker of the client device 106. A click or selection can refer to a user interaction with the digital component object, such as a voice response to an audible impression, a mouse-click, touch interaction, gesture, shake, audio interaction, or keyboard click. A conversion can refer to a user taking a desired action with respect to the digital component objection; e.g., purchasing a product or service, completing a survey, visiting a physical store corresponding to the digital component, or completing an electronic transaction.
The digital component provider device 128 can establish one or more content groups for a digital component campaign. A content group includes one or more digital component objects and corresponding content selection criteria, such as keywords, words, terms, phrases, geographic locations, type of computing device, time of day, interest, topic, or vertical. Content groups under the same content campaign can share the same campaign level parameters, but may have tailored specifications for content group level parameters, such as keywords, negative keywords (e.g., that block placement of the digital component in the presence of the negative keyword on main content), or parameters associated with the content campaign.
To create a new content group, the digital component provider device 128 can provide values for the content group level parameters of the content group. The content group level parameters include, for example, a content group name or content group theme, and bids for different content placement opportunities (e.g., automatic placement or managed placement) or outcomes (e.g., clicks, impressions, or conversions). A content group name or content group theme can be one or more terms that the digital component provider device 128 can use to capture a topic or subject matter for which digital component objects of the content group is to be selected for display. For example, a food and beverage company can create a different content group for each brand of food or beverage it carries, and may further create a different content group for each model of vehicle it carries. Examples of the content group themes that the food and beverage company can use include, for example, โBrand A colaโ, โBrand B ginger ale,โ โBrand C orange juice,โ โBrand D sports drink,โ or โBrand E purified water.โ An example content campaign theme can be โsodaโ and include content groups for both โBrand A colaโ and โBrand B ginger aleโ, for example. The digital component (or digital component object or digital component) can include โBrand Aโ, โBrand Bโ, โBrand Cโ, โBrand Dโ or โBrand Eโ. The digital component object or digital component can refer to the digital component configured for a parametrically driven text to speech technique.
The digital component provider device 128 can provide one or more keywords and digital component objects to each content group. Keywords can include terms that are relevant to the product or services of associated with or identified by the digital component objects. A keyword can include one or more terms or phrases. For example, the food and beverage company can include โsoda,โ โcola,โ โsoft drink,โ as keywords for a content group or content campaign that can be descriptive of the goods or services the brand provides. In some cases, negative keywords can be specified by the content provider to avoid, prevent, block, or disable content placement on certain terms or keywords. The content provider can specify a type of matching, such as exact match, phrase match, or broad match, used to select digital component objects.
The digital component provider device 128 can provide the one or more keywords to be used by the content selector component 129 to select a digital component object provided by the digital component provider device 128. The digital component provider device 128 can provide additional content selection criteria to be used by the content selector component 129 to select digital component objects. The content selector component 129 can run a content selection process involving multiple content providers 128 responsive to receiving an indication of a keyword of an electronic message.
The digital component provider device 128 can provide one or more digital component objects for selection by the content selector component 129. The content selector component 129 can select the digital component objects when a content placement opportunity becomes available that matches the resource allocation, content schedule, maximum bids, keywords, and other selection criteria specified for the content group. The content selector component 129 can select the digital components based on keywords associated with the digital components. For example, the content selector component 129 can match digital component parameters to the keywords of one or more digital components to select the digital component.
Different types of digital component objects can be included in a content group, such as a voice digital component, audio digital component, a text digital component, an image digital component, video digital component, multimedia digital component, or digital component link. Upon selecting a digital component, the content selector component 129 can transmit the digital component object for presentation or rendering on a client device 106 or display device of the client device 106. Presenting or rendering can include displaying the digital component on a display device, or playing the digital component via a speaker of the client device 106. The content selector component 129 to present or render the digital component object. The content selector component 129 can instruct the client device 106 to generate audio signals, acoustic waves, or visual output. For example, the automated assistant client 108 can present the selected digital component via an audio output.
The natural language processor 122 can determine a request, such as a content request, within an audio input request received from the client device 106. The digital component selector 129 can be a part of the could-based automated assistant component 116 or separate from the could-based automated assistant component 116. The digital component selector 129 can receive the content request or an indication thereof. The content selector component 129 can receive prior audio inputs (or packaged data object) for the selection of a digital component based on the content request. The content selector component 129 execute a real-time digital component selection process to select the digital component. The content selector component 129 can select addition or supplemental digital components based on the input request.
The real-time digital component selection process can refer to, or include, selecting digital component objects (which may include sponsored digital component objects) provided by third party content providers 128. The real-time content selection process can include a service in which digital components provided by multiple content providers are parsed, processed, weighted, or matched based on the packaged data object in order to select one or more digital components to provide to the client device 106. The digital component selector 129 can perform the content selection process in real-time. Performing the content selection process in real-time can refer to performing the content selection process responsive to the request for content received via the client device 106. The real-time content selection process can be performed (e.g., initiated or completed) within a time interval of receiving the request (e.g., 5 seconds, 10 seconds, 20 seconds, 30 seconds, 1 minute, 2 minutes, 3 minutes, 5 minutes, 10 minutes, or 20 minutes). The real-time content selection process can be performed during a communication session with the client device 106, or within a time interval after the communication session is terminated.
For example, the digital component selector 129 can be designed, constructed, configured or operational to select digital component objects based on the content request in the input audio signal. The digital component selector 129 can identify, analyze, or recognize voice, audio, terms, characters, text, symbols, or images of the candidate digital components using an image processing technique, character recognition technique, natural language processing technique, or database lookup. The candidate digital components can include metadata indicative of the subject matter of the candidate digital components, in which case digital component selector 129 can process the metadata to determine whether the subject matter of the candidate digital component corresponds to the content request.
Responsive to the request identified in the input audio (or other) signal, the content selector component 129 can select a digital component object from a database associated with the digital component provider device 128 and provide the digital component for presentation via the client device 106. The digital component object can be provided by a digital component provider device 128. The content selector component 129 can select multiple digital components. The multiple digital components can be provided by different digital component provider devices 128. For example, a first digital component provider device 128 can provide a primary digital component responsive to the request and a second digital component provider device 128 can provide a supplemental digital component that is associated with or relates to the primary digital component. The client device 106 or a user thereof can interact with the digital component object. The client device 106 can receive an audio, touch, or other input response to the digital component. The client device 106 can receive an indication to select a hyperlink or other button associated with the digital component object that causes or allows the client device 106 to identify digital component provider device 128, request a service from the digital component provider device 128, instruct the digital component provider device 128 to perform a service, transmit information to the digital component provider device 128, or otherwise identify a good or service associated with digital component provider device 128.
The digital component selector 129 can select a digital component that includes text, strings, or characters that can be processed by a text to speech system or presentable via a display. The digital component selector 129 can select a digital component that is in a parameterized format configured for a parametrically driven text to speech technique. The digital component selector 129 can select a digital component that is in a format configured for display via client device 106. The digital component selector 129 can select a digital component that can be re-formatted to match a native output format of the client device 106 or application to which the digital component is transmitted. The digital component selector 129 can provide the selected digital component to the client device 106.
The automated assistant 120 may facilitate (or โbrokerโ) the performance of actions by computing services 150 on behalf of users. The actions, which are generally a type of intent capable of being identified or determined by intent matcher 136, generally issue requests to computing services, and generally do so in connection with providing one or more parameters to the computing services to instruct such computing services on how to perform the actions.
A computing service, in this regard, may be considered to include practically any type of computer functionality capable of being invoked to perform some activity on behalf of a user. A computing service may be implemented by one or more processors and may be resident on the same computer system as an automated assistant, or may be resident on a different computer system from the computer system hosting an automated assistant. Some computing services may be accessible over a network (e.g., as is the case for cloud-based computing services), while other computing services may be resident on a user's client computing device. Some computing services may also be considered to be third party computing services that are associated with different parties from that of the automated assistant and the user, irrespective of where those computing services are hosted (e.g., on a third party computer system, on an automated assistant computer system, on a user computing device, in a cloud computing system, etc.).
Accordingly, one kind of user intent that may be identified by intent matcher 136 is an action to cause a third party computing service to perform a transaction or other operation on behalf of a user. For example, automated assistant 120 may provide access to an application programming interface (โAPIโ) to a third party service such as a travel service. A user may invoke automated assistant 120 and provide a command such as โI'd like to order a vehicle with wheelchair space to the nearest metro station with step-free accessโ. Intent matcher 136 may map this command to a grammar (which may be added to database 137 in some cases by the third party) that triggers automated assistant 120 to engage with the third party travel service via one or more API calls to the travel service. In another example, the automated assistant 120 may provide access to an API to a different third party service, such as a pizza delivery service. A user may invoke automated assistant 120 and provide a command such as โI'd like to order a pizza.โ Intent matcher 136 may map this command to a grammar (which may be added to database 137 in some cases by the third party) that triggers automated assistant 120 to engage with the third party pizza delivery service via one or more API calls to the pizza delivery service. The third party service, such as the travel service or the pizza delivery service, may build a conversation for enabling an order, such as for ordering a suitable vehicle or for ordering a pizza to be delivered, using a dependency graph data structure that is created by the third party service or otherwise generated based upon user input provided by the third party service. The dependency graph data structure may provide a set of input parameters that need to be filled in order to fulfill, for example, an order for a suitable vehicle or a pizza delivery order. Automated assistant 120 may generate and provide to the user (via client device 106) natural language output that solicits input for any parameters that cannot be obtained from user data and/or input provided in connection with specifying an intent to the automated assistant. Automated assistant 120 may, in this manner, be configured to solicit input only for parameters that cannot be obtained from user data and/or input provided in connection with specifying an intent to the automated assistant. This allows the automated assistant 120 to efficiently identify and obtain selected missing information. In doing so, the automated assistant 120 makes efficient use of hardware resources, including for example the microphone resources and the speaker resources, on the client computing device. Power consumption at the device may be reduced in the process.
In particular, for soliciting input of parameters that cannot be obtained from user data and/or input provided in connection with specifying an intent to the automated assistant, a fulfillment engine 124 may be configured to receive the intent output by intent matcher 136, as well as any associated parameters (whether provided by the user proactively or solicited from the user) and fulfill the intent. In various embodiments, fulfillment of the user's intent may cause various fulfillment information to be generated/obtained. As will be described below, the fulfillment information may I be provided to a natural language generator (โNLGโ) 126, which may generate natural language output based on the fulfillment information.
Fulfillment information may take various forms because an intent can be fulfilled in a variety of ways. Suppose a user requests pure information, such as โWhere were the outdoor shots of โThe Shiningโ filmed?โ The intent of the user may be determined, e.g., by intent matcher 136, as being a search query. The intent and content of the search query may be provided to one or more search engines to search corpuses of documents and/or other data sources (e.g., knowledge graphs, etc.) for responsive information. Fulfillment engine 124 may provide data indicative of the search query (e.g., the text of the query, a reduced dimensionality embedding, etc.) to a search engine, which may in turn provide responsive information, such as GPS coordinates, or other more explicit information, such as โTimberline Lodge, Mt. Hood, Oreg.โ This responsive information may form part of the fulfillment information generated by fulfillment engine 124.
The fulfillment engine 124 may be configured to receive, e.g., from natural language understanding engine 135, a user's intent and in turn utilize a dialog engine 138 to conduct a human-to-computer dialog session with the user to perform an action associated with the intent, e.g., by calling or invoking the performance of one or more operations by a computing service 150. Responsive actions may include, for instance, ordering a good/service, purchasing an event ticket, booking a reservation to a restaurant, hotel, airplane, train, ordering a taxi or ride-share care, starting a timer, setting a reminder, initiating a phone call, playing media, sending a message, etc. In some such implementations, fulfillment information may include parameters associated with the action, confirmation responses (which may be selected from predetermined responses in some cases), etc.
As noted above, natural language generator 126 may be configured to generate and/or select natural language output (e.g., spoken words/phrases that are designed to mimic human speech) based on data obtained from various sources. The natural language generator 126 may be configured to receive, as input, fulfillment information associated with fulfillment of an intent by fulfillment engine 124, and to generate natural language output based on the fulfillment information. Additionally or alternatively, natural language generator 126 may receive information from other sources, such as third party computing services, and as will become more apparent below, from a dependency graph data structure, which it may use to formulate natural language output for the user.
A dialog engine 138 may be used to manage the conduct of a conversation associated with an action, and may use a dependency graph data structure associated with a particular action to control the interaction between a user and an automated assistant. As such, dialog engine 138 may store various dependency graph data structures associated with different actions or intents, e.g., with a database 142, and access those dependency graph data structures when interacting with users.
In addition, a conversation builder component 140 may also be supported to generate, modify, update, or otherwise manage dependency graph data structures. For example, conversation builder component 140 may provide a web-based user interface to enable internal and/or third party developers to create dependency graph data structures for particular actions and store those data structures in database 142 for later access by dialog engine 138.
Various components of FIG. 1, such as dialog engine 138 and conversation builder component 140, may be configured to perform selected aspects of the present disclosure for utilizing and/or generating dependency graph data structures for use in conducting human-to-computer dialog sessions with users to initiate the performance of actions by one or more computing services. The functionality disclosed herein may be implemented in an innumerable number of other manners, utilizing other combinations of computing devices, computer systems and/or software components, as will be apparent to those of ordinary skill having the benefit of the instant disclosure. Therefore, the invention is not limited to the particular implementations discussed herein.
Now turning to FIG. 2, this figure depicts an example dependency graph data structure 200 consistent with some implementations. As discussed above, building conversations for implementation by an automated assistant can be problematic in many instances. Conversation models based on forms and slot filling, for example, have been found to produce poor conversation flow, e.g., conversation flows that are robotic or otherwise not realistic simulations of human interactions.
For some types of conversations, such as conversations associated with actions that access a computing service, modelling such conversations may be particularly problematic. Consider, as an example, a โbook a tableโ conversation for making a restaurant reservation. A user is generally required to specify at least a number of people and a preferred time, and generally a computing service is called to obtain available dates and times from which the user can choose. The user may then be required to provide additional input such as contact information, and the computing service is called again to complete the reservation. In this process, various hardware elements of the client computing device, such as the speaker(s), microphone(s) and other user interface hardware, may be activated and deactivated as the user is prompted in various parts of the session, sometimes after a reasonable time delay, to provide information.
Form and slot filling models generally struggle to model these types of conversations, in part due to the fact that intermediate calls may need to be made prior to some user input, as well as the fact that some user input may be needed before such intermediate calls may be made. Such conversation flows are typical of many transactional use cases, such as the aforementioned reservation case, as well as various shopping, event ticket purchasing, and similar cases.
In the illustrated implementations, however, conversations are modelled with dependency graph data structures that define in part the dependencies between parameters and operations performed in the conversations. For example, a dependency graph data structure may be created based on an API of a computing service, and may be accessed during runtime to generate a conversation with a user that accesses the computing service.
A dependency graph data structure may be based in part upon methods and dependencies therebetween. In such implementations, a specification may be defined for a conversation that defines one or more objects that may be produced by certain methods and that may be consumed by other methods as parameters.
A first type of method that may be defined in a specification is referred to herein as an action method, which generally specifies a fulfilment by a computing service. In the case of a third party computing service, for example, an action method may be associated with an agent that accesses the third party computing service, e.g., an HTTPAgent that includes a URL and one or more parameters to make an HTTP call. A field may also be provided in a specification of an action method to specify whether a method is indexable, meaning that the method can be triggered by an agent to perform an action.
A second type of method that may be defined in a specification is referred to herein as an assistant method, which generally specifies how an automated assistant may obtain information from a user. An assistant method may specify user input, e.g., text input, selection of a date, etc., and an assistant method may be platform provided or provided by a third party.
Now with reference to FIG. 2, in the illustrated implementation, dependency graph data structure 200 is implemented as a directed acyclic graph (DAG) including a plurality of nodes 202-214 linked to one another through directed edges 216. Of note, FIG. 2 represents a simplified dependency graph data structure suitable for explanatory purposes, and not all relationships and parameters are represented in this figure for clarity.
The DAG is a type of graph in which edges have directions associated therewith (i.e., the edges are not bidirectional), as well as type of graph in which no directed cycles are defined (i.e., the edges do not form closed loops of nodes). In addition, and in contrast to a tree data structure, a DAG utilized may support directed edges defining multiple parent and/or child relationships for any given node. The other data structures may be used in other implementations, so the invention is not limited specifically to a DAG.
Each node 202-214 identifies either an action method that accesses a computing service or an assistant method that collects one or more parameters. Moreover, each directed edge 216 connects a respective pair of nodes from among nodes 202-214 and effectively identifies at least one parameter generated, produced or otherwise output by one node in the pair and consumed, received, or otherwise utilized by the other node in the pair. To represent this directed relationship, each directed edge 216 is represented in FIG. 2 with an arrow pointing to the node in the pair that utilizes an associated parameter.
Dependency graph data structure 200 models the aforementioned โbook a tableโ conversation, in this case for a hypothetical restaurant called โO'Briens,โ with each node 202-214 labelled with an associated action or assistant method and an object or parameter output by the associated method. For this conversation, four action methods are defined, and represented by blocks 202, 204, 208 and 210:
Reserve (block 202): makes a final reservation and produces a receipt object. In the illustrated implementation, this is the method that is indexed for a โbook a table at O'Briensโ use case.
SlotLock (block 204): locks an available time slot and produces a SlotLockID that is used by the Reserve action method.
SearchSlotsByPartySize (block 208): produces available time slots (represented by SearchSlotObjects) based upon a desired party size.
SearchSlots (block 210): produces available time slots (represented by SearchSlotObjects) based upon a desired party size and a preferred date and time.
Further, to model the conversation, three assistant methods are defined, and represented by blocks 206, 212 and 214:
SelectDateTime (block 206): prompts a user to select an available time slot returned by the SearchSlots action method.
GetPartySize (block 212): prompts a user to specify a desired party size and produces a PartySize object.
GetPreferredDateTime (block 214): prompts a user to specify a preferred data and time and produces a PreferredDateTime object.
It may be seen that directed edges 216 in FIG. 2 represent the parameters produced or output by the methods defined by certain nodes and consumed or utilized by other nodes. Thus, it should be apparent that the SearchSlotsByPartySize action method of node 208 uses as an input parameter the PartySize object produced by the GetPartySize method of node 212, while the SearchSlots action method of node 210 uses not only the PartySize object produced by the GetPartySize method of node 212 but also the PreferredDateTime object produced by the GetPreferredDateTime method of node 214. Likewise, the SelectDateTime method of node 206 may consume SearchSlotObjects produced by the methods of nodes 208 and 210, the SlotLock method of node 204 may consume a SelectedDateTime object produced by the SelectDateTime method of node 206, and the Reserve method of node 202 may consume the SlotLockID object produced by the SlotLock method of node 204.
As may be apparent from FIG. 2, a dependency graph data structure may support multiple alternative assistant methods, as is the case with the methods of nodes 208 and 210, which search for available slots based upon different input parameters and provide similar outputs to node 206. Likewise, the method of a node may consume input parameters produced by multiple other nodes, as is the case with the method of node 210, which uses parameters output by each of nodes 212 and 214.
FIGS. 3A-3G illustrate at 220-232 specifications for the action methods and assistant methods defined by blocks 202-214 of FIG. 2. FIG. 3A, for example, illustrates at 220 an example specification for the Reserve action method. The specification indicates, for example, that the method is indexable, and is thus callable to perform the intended action for the conversation. The specification defines an HTTP agent to make a call to a hypothetical third party computing service hosted at api.exampleagent.com, and specifies a number of parameters used by the call, as well as the source of each parameter. Of note, not all parameters used by the call are illustrated in FIG. 3A for the sake of simplifying the illustration.
As is also apparent from FIG. 3A, parameters may be provided not only by soliciting user input (e.g., user input provided with an initial natural language input or user input provided in the course of the conversation in response to a prompt generated by an assistant method), but also based upon stored user data that is not explicitly solicited from or provided by a user in connection with the conversation. One parameter illustrated in FIG. 3A, for example, is a โfirstnameโ parameter that may be provided by a user profile maintained for a user, since in many instances contact information for a user may be accessible by an automated assistant interacting with the user.
FIGS. 3B-3D likewise illustrate at 222-226 specifications for the SlotLock, SearchSlots and SearchSlotsByPartySize action methods, and each includes a reference to an HTTP agent to make a call to the hypothetical third party computing service. Each of these methods, however, generates intermediate data for use in performing the reservation action, so none of these methods is marked as indexable.
FIGS. 3E-3G illustrate at 228-232 specifications for the SelectDateTime, GetPartySize, and GetPreferredDateTime assistant methods. Each specification may include desired user input, as well as text or other data for use in generating a prompt to a user to provide the desired user input. While text for a prompt may be specified, in other implementations, other manners of representing a natural language output, e.g., grammars, may be defined for an assistant method, and in other implementations, prompts may be determined based upon the desired user input without any specific definition in the specification for that method.
FIG. 4 and FIGS. 5A-5I illustrate another example use case, that of a conversation for purchasing a ticket to an event. FIG. 4, in particular, illustrates an example dependency graph data structure 250 including nodes 252-270 and directed edges 272. Dependency graph data structure 250 is also used to perform an action with the same third party computing service used in the example use case of FIGS. 2 and 3A-3G, which is accessible at api.exampleagent.com.
Nodes 252, 256, 262 and 266 define action methods that invoke calls to the third party computing service:
BuyTicket (block 252): purchases a ticket based upon a user's authorized token, a SKU of the ticket to be purchased, and an input of a number of tickets to purchase. A specification of this action method is illustrated at 280 in FIG. 5A. The specification indicates, for example, that the method is indexable, and is thus callable to perform the intended action for the conversation.
GetTicketSku (block 256): obtains a SKU for a ticket based upon an event ID and a specified ticket type. A specification of this action method is illustrated at 282 in FIG. 5B.
GetAvailableTicketTypes (block 262): obtains the ticket types available for a given event ID. A specification of this action method is illustrated at 284 in FIG. 5C.
SearchEvents (block 266): searches for available events on a certain date and matching a desired keyword (or set of keywords). A specification of this action method is illustrated at 286 in FIG. 5D.
Nodes 254, 258, 260, 264, 268 and 270 define assistant methods that collect information usable in performing the action:
AssistantUser (block 254): obtains from stored user data an authorization token for the user. This assistant method merely accesses stored data for the user, and as such no specification of this method is illustrated.
SelectTicketType (block 258): prompts a user to select a ticket type among those retrieved by the GetAvailableTicketTypes action method and produces a SelectedTicketType object. A specification of this assistant method is illustrated at 288 in FIG. 5E.
GetNumTickets (block 260): prompts a user to specify a desired number of tickets and produces a NumTickets object. A specification of this assistant method is illustrated at 290 in FIG. 5F.
SelectEvent (block 264): prompts a user to select an event among those retrieved by the SearchEvents action method and produces a SelectedEventld object. A specification of this assistant method is illustrated at 292 in FIG. 5G.
GetPreferredDate (block 268): prompts a user to specify a preferred date and produces a Date object for use in searching for events. A specification of this assistant method is illustrated at 294 in FIG. 5H.
GetKeyword (block 270): prompts a user to specify one or more keywords for use in searching for events and produces a SearchKeyword object. A specification of this assistant method is illustrated at 296 in FIG. 5I.
In the aforementioned examples, all of the illustrated parameters are mandatory. In other implementations, however, parameters may be designated as optional, and may be supplied to a computing service when provided by a user or otherwise available, but otherwise omitted if not determined during a dialog session.
Now turning to FIG. 6, an example sequence of operations 300 for conducting a human-to-computer dialog session using a dependency graph data structure is illustrated. Sequence 300 may be implemented, for example, using one or more processors and using one or more of the various components illustrated in FIG. 1, e.g., under the control of dialog engine 138 and utilizing other automated assistant components 119. In block 302, for example, user input associated with an intent may be initially received, and in block 304, the intent may be determined, e.g., by intent matcher 136 of FIG. 1. In block 306, a determination may be made as to whether the intent is associated with an action for which a dependency graph data structure is associated, e.g., one of various use cases for which conversations have been modeled via dependency graph data structures. If not, control may pass to block 308 to handle the intent in a conventional manner.
Moreover, as also noted in block 304, a dependency graph data structure may also be used to determine an intent. For example, it may be desirable to model multiple types of actions in the same dependency graph, thereby enabling traversal of the dependency graph to be used to select from among multiple actions. As an example, where multiple actions are supported using similar types of input parameters, selection of an action from among multiple modeled actions may be based in part on the available parameters specified by a user in the initial input.
Returning to block 306, if the intent is determined to be associated with an action for which a dependency graph data structure exists for modeling a conversation, control may pass from block 306 to block 310 to access and traverse the dependency graph data structure and optionally set one or more parameters based upon prior user input and/or stored user data. For example, if an initial input from a user includes text that defines one or more parameters used by an action when requesting the action, there is generally no need to prompt a user for those parameters. Thus, if a user inputs โplease book a table for four at O'Briensโ the desired party size is known, so there is no need to ask the user to provide that data. Also, where a dependency graph data structure models a reservation conversation for multiple restaurants, the restaurant โO'Briensโ would already be known from the initial input. This may feed into the effects discussed above, resulting in more efficient overall usage of aspects of the hardware at the client computing device.
Likewise, where one or more parameters used by an action are available as stored data (e.g., from a user profile), it may also not be necessary to prompt the user for that data, or alternatively, to provide that data for the purposes of confirmation (e.g., โWould you like me to use your mobile number XXX-XXX-XXXX as your contact number?โ).
Next, in block 312 a determination is made as to whether any parameters needed to perform the action are unset, i.e., remain to be determined. A parameter may be unset, for example, if the user still needs to be prompted to provide that parameter. In addition, a parameter may be unset if an action method needs to be executed in order to generate some intermediate data that is needed prior to obtaining that parameter, e.g., a list of available time slots for booking a table from which the user may then select.
If any parameters remain unset, control passes to block 314 to select one or more unset parameters based upon the dependency graph data structure. For example, the order in which parameters are selected may be determined at least in part using the dependency graph data structure, e.g., by prioritizing parameters that are consumed by action methods that generate intermediate data that is later used as a parameter for another method.
In block 316, a prompt for the selected one or more parameters is generated and presented to the user, e.g., by executing one or more assistant methods associated with the selected parameters, and then in block 318 user input to the prompt is received and any parameters specified in the input are set. The generated prompts and responses in a dialog session may be in the form of natural language outputs that are presented in visual and/or audio form, while the user input may include instances of free-form natural language input received by one or more input components of a computing device (e.g., touchscreens, keyboards, microphones, etc.), although the invention is not so limited.
In block 320, it is determined whether the user input changes any parameter that has already been set, and if not, control passes to block 322, where a determination is made as to whether any intermediate action method is ready for execution (i.e., where all parameters for that action are set). If so, control passes to block 324 to execute the intermediate action method and return control to block 312 to continue the dialog session to determine any remaining unset parameters. If not, block 324 is bypassed and block 322 returns control directly to block 312. Then, once all parameters have been set, block 312 passes control to block 326 to execute the final action method, e.g., by executing a call operation to the computing service using the parameters determined during the dialog session as inputs to the call operation. A response is then generated and presented to a user in block 328 to report the outcome of the action, and the dialog session is complete.
Returning to block 320, as noted above, in some instances a user input in a dialog session may include a change to a parameter that has already been set. Thus, in such circumstances, control may be diverted to block 330 to invalidate one or more affected parameters. By doing so, subsequent operations in sequence 300 may re-execute one or more action or assistant methods to update any invalidated parameters. Of note, when one or more parameters is invalidated, one or more other parameters that are not affected by the change may be maintained as valid, and as a result re-execution of one or more action methods or assistant methods used to determine the unaffected parameters may be effectively bypassed when re-executing the one or more action methods or assistant methods associated with the invalidated parameters.
Now turning to FIG. 7, this figure illustrates an example dialog session between a user and an automated assistant 120 implemented at least in part on a computing device 340 operated by the user and including a touchscreen 342, various user interface buttons 344, 346, 348, a text input field 350, and a microphone icon 352. Microphone icon 352 may be operable to enable the user to provide voice input, which may be speech recognized, e.g., by speech capture/TTS/STT module 114, and used, for instance, to populate text input field 350.
In this dialog session, the user operating client device 340 (โYouโ) provides the following free-form natural language input (e.g., using input field 350): โHEY ASSISTANT, CAN YOU BOOK A DINNER RESERVATION AT O'BRIENS THIS WEEKEND?.โ An automated assistant, e.g., using intent matcher 136, may determine that this input is associated with an action to book at table at O'Briens, and that this action has an associated dependency graph data structure (e.g., as discussed above in connection with blocks 304-306 of FIG. 6). The dependency graph data structure for this example may be similar to dependency graph data structure 200 discussed above in connection with FIGS. 2 and 3A-3G.
Moreover, by accessing and traversing the dependency graph data structure as discussed above in connection with block 310 of FIG. 6, it may be determined that input data has been provided relating to the PreferredDateTime parameter (โdinnerโ and โthis weekendโ), but no input data has been provided relating to the PartySize parameter, and that the SearchSlots action method cannot be executed without both parameters. As such, a prompt such as โSURE, FOR HOW MANY PEOPLE?โ may be generated and presented to the user as discussed above in connection with blocks 314 and 316 of FIG. 6. The efficiency of this process and relevancy of the prompt generated enables efficient use of hardware resources at the client computing device, as previously discussed.
The user may then respond with a number such as โFOURโ, which is then used to set the PartySize Parameter. Then, it may be determined that sufficient data exists to execute the SearchSlots action method to generate intermediate data (here, available time slots), and the SearchSlots action method may be executed, e.g., as discussed above in connection with blocks 322-324 of FIG. 6. It should be noted that either the SearchSlots action method itself, or the automated assistant, may be configured to determine appropriate inputs for the SearchSlots call to the computing service. For example, assuming the user input of โdinnerโ and โthis weekend,โ a time range such as 5:00 pm to 10:00 pm and a date range including the next Friday, Saturday and Sunday may be used. In some instances, multiple calls to the computing service may be made, e.g., one for each day in the date range.
Once available time slots are returned from the computing service, one or more of the available time slots may be presented to the user with a prompt to select a time slot to reserve (โRESERVATIONS ARE AVAILABLE AT 7:00 PM ON FRIDAY AND 8:00 PM ON SATURDAY. WOULD YOU LIKE TO MAKE A RESERVATION AT ONE OF THOSE TIMES?โ). In some instances, a list of all available time slots may be presented, or alternatively, as illustrated in FIG. 7, only one or more preferred time slots (e.g., time slots selected based upon user history, restaurant history, etc.) may be presented.
Then, based on a user response selecting a time slot (โYES. LET'S DO SATURDAY AT 8:00 PMโ) the automated assistant may determine that the parameters necessary to execute the SlotLock action method are now set, thereby executing the SlotLock action method to lock to the slot, which then provides all necessary parameters for the Reserve action method. Execution of the Reserve action method may result in the return of a ReceiptObject, which may then be processed by the automated assistant to output a confirmatory response (โYOUR RESERVATION IS CONFIRMED. YOU SHOULD RECEIVE A CONFIRMATION EMAIL SHORTLYโ).
FIG. 8 illustrates another example dialog session with a user of computing device 340, which begins with an initial input of โHEY ASSISTANT, CAN YOU BOOK A RESERVATION FOR FOUR AT O'BRIENS?โ Traversal of the dependency graph may determine that the PartySize parameter is not set, thereby resulting in a prompt of โWHAT DAY AND TIME ARE YOU LOOKING FOR?โ In response to a user input of โTONIGHT AT 7:00 PM,โ the automated assistant may execute the SearchSlots action method to call the computing service using a party size of four and a preferred date and time of the current day and 7:00 PM.
Assuming that the response of the call to the computing service only returns an available time slot of 6:00 PM, a response such as โTHE ONLY AVAILABLE RESERVATION TONIGHT IS AT 6:00 PM. SHOULD I BOOK IT FOR YOU?โ may be returned. Also assuming that this time is unacceptable to the user, the user may response with an input such as โNO. WHAT ABOUT TOMORROW NIGHT?,โ which may be detected by the automated assistant as changing the PreferredDateTime parameter, resulting in this parameter, as well as the SearchSlotsObject previously generated by the SearchSlots action method being invalidated and the SearchSlots action method being re-executed to generate a new set of available time slots (e.g., as discussed above in connection with blocks 320 and 330 of FIG. 6). The automated assistant may then generate a new prompt such as โ7:00 PM IS AVAILABLE TOMORROW NIGHT. SHOULD I BOOK IT FOR YOU?โ and assuming this time slot is acceptable to the user, the booking may then be completed in a similar manner to that described above in connection with FIG. 7.
FIG. 9 next depicts an example dialog session between a user 360 and automated assistant 120 by way of a standalone interactive speaker 362 operated by the user 360, in accordance with various implementations. In this dialog session, an initial input of โANY THEATER PERFORMANCES TONIGHT?โ may result in an intent determination of an action that is associated with dependency graph data structure 250 of FIGS. 4 and 5A-5I.
Initial analysis of the dependency graph data structure may determine values for both the SearchKeyword parameter (โtheaterโ) and Date parameter (โtonightโ), and thus the SearchEvents action method may be executed prior to prompting the user for any additional parameters. Consequently, the automated assistant may execute the SelectEvent assistant method to output one or more possible events to the user (โSHAKESPEARE IN THE PARK IS PLAYING TONIGHT, WOULD YOU LIKE TO GO?โ), and assuming the user responds in the affirmative, the automated assistant may execute the GetAvailableTicketTypes action method to determine one or more TicketTypeObjects (which may include, for example, both location and pricing information, e.g., โORCHESTRA SEATS ARE AVAILABLE FOR $25. WOULD YOU LIKE TO PURCHASE THESE TICKETS?โ). Assume also that the user responds โYES, I'D LIKE TO BUY THREE,โ the GetTicketSku action method may be executed to determine a SKU for the selected ticket. Moreover, because the user input specifies a number of tickets, the automated assistant may bypass execution of the GetNumTickets assistant method, and the BuyTicket action method may be executed to call the computing service using inputs of the ticket SKU and the number of tickets, as well as authentication information provided by the automated assistant, and a response such as โOK, I'VE PURCHASED THE TICKETS. YOU SHOULD RECEIVE A CONFIRMATION EMAIL SHORTLYโ may be generated and presented to the user.
A dependency graph data structure may be generated in a number of manners in different implementations, and using a number of different graphical, visual and/or textual programming interfaces. FIG. 10A, for example, illustrates on example sequence of operations 370 for generating a dependency graph data structure. In block 372, for example, a computer system may generate a programming user interface and present that interface to a user (e.g., a developer). The computer system may then receive one or more action call definitions in block 374, corresponding, for example, to a third party agent API. Then, in block 376, one or more parameters may be received and/or determined. Received parameters, for example, may be supplied manually by the user, while determined parameters may be derived, for example, from analysis of the action call definitions.
Next, in block 378, dependencies may be received and/or determined. Dependencies may be received, for example, based upon user input linking the outputs of some action calls to the inputs of other action calls, while dependencies may be determined based upon programmatic analysis of the inputs and outputs of those action calls. Then, in block 380, one or more assistant methods and/or parameter prompts may be received and/or determined. For example, a user may manually input prompts for particular parameters or draft program code for various assistant methods. As another example, the computer system may determine what parameters require user input and may derive assistant methods, assistant method templates and/or prompts for collecting that user input.
Next, in block 382, the computer system creates an action method node for each action call definition, and in block 384, the computer system creates an assistant method node for each assistant method. Then, in block 386, directed edges are created to link together the various nodes according to the determined dependencies. As shown in blocks 388 and 390, a specification similar to those illustrated in FIGS. 3A-3G and 5A-5I may be generated and program code for each method may be determined, e.g., using automated code generation, or alternatively, a specification may be drafted manually by a user, or by some combination of both approaches.
The computer system may then index all action methods identified as indexable in the specification in block 392, thereby registering the action methods with the automated assistant. Then in block 394, the dependency graph data structure may be deployed and made available for use by the automated assistant.
A wide variety of programming models, languages, and interfaces, including different levels of automated code generation and manual input from a user, may be used in various implementations, so the invention is not limited to the particular implementations discussed herein. For example, automation may be used to generate or suggest data types, dependencies, authorization or authentication methods, etc., and may, in some instances, perform verification of a dependency graph data structure, e.g., to confirm that each parameter used by each method has a corresponding directed edge from another method that outputs that parameter. The methods and/or portions of dependency graph data structures may be stored and/or reused for other dependency graph data structures, e.g., as may be provided by a third party computing service provider, by an assistant provider, via a community repository, etc.
The aforementioned use of a dependency graph data structure provides a number of technical benefits in different implementations. For example, as compared to some low level APIs or form filling approaches, more realistic and less robotic conversations may be supported, and an automated assistant may have greater flexibility in deciding the order in which parameters may be requested and what action methods may be executed. Moreover, machine learning techniques may be used by an automated assistant to optimize the use of a dependency graph data structure to provide more realistic conversations, as well as conversations that are better adapted to particular users. The approach may also be adaptable to multiple use cases and may be extendible to additional use cases with little or no additional programming. Furthermore, the need for a developer to anticipate all possible inputs and combinations of input parameters may be avoided.
The computing resources may be conserved through the ability to dynamically invalidate parameters while maintaining other parameters valid, thereby avoiding the need to restart a conversation.
FIG. 10B illustrates a method 500 to update response data. The method 500 can include receiving an input audio signal (ACT 501). The method 500 can include parsing the input audio signal (ACT 502). The method 500 can include selecting an action (ACT 503). The method 500 can include receiving a second input audio signal (ACT 504) and parsing the second input audio signal (ACT 505). The method 500 can include updating a parameter (ACT 506). The method 500 can include selecting a digital component (ACT 507). The method can include transmitting the digital component (ACT 508).
The method 500 can include receiving an input audio signal (ACT 501). The method can include receiving the first input audio signal from a client device. The input audio signal can be detected at the client device by a sensor, such as a microphone. The data processing system can receive the audio input for a session corresponding to the conversation. The system can receive the audio input in one or more portions or as a bulk or batch upload (e.g., multiple portions of the conversations uploaded in a single transmission to reduce the number of transmissions).
The method 500 can include parsing the input signal (ACT 502). The method can include parsing the first input audio signal, by the natural language processor, to identify a request in the input audio signal. The natural language processor can parse the input signal to identify a request and one or more keywords. The request can be a request for an action to be completed. The action can be, for example, to make a reservation at a restaurant.
The method 500 can include selecting an action (ACT 503). The method 500 can include selecting, by a fulfilment engine, an action based on the request in the first input audio signal. The fulfilment engine can also select a dependency graph data structure based on the action. The dependency graph data structure may include a plurality of nodes. For example, the dependency graph data structure can include a first node and a second node. Each of the nodes can identify a respective assistant method. Each of the nodes can include a parameter to fulfill the action. The dependency graph data structure can include directed edges that connect nodes in the digital component. For example, a directed edge can link the first node with the second node. Each directed edge can identify at least one parameter generated by an assistant method. The digital component can include one or more digital component nodes that can each include a digital component parameter. The digital component parameter can be included as a parameter in one or more of the nodes, for example the above first and second node, of the digital component. The digital component selector can use the digital component parameter to select one or more digital components. For example, each of the digital components can be associated with one or more keywords. The digital component selector can match the digital component parameter to the keywords of the digital component.
Selecting an action can include determining an intent with, for example the intent matcher. Based on the intent, the fulfillment engine can select an action. The fulfillment engine can select the action based on the request parsed from the input signal. For example, the fulfillment engine can select an action to fulfill the request. Based on the action, the fulfillment engine can select a dependency graph data structure exists for modeling a conversation.
The method 500 can include reciting an input audio signal (ACT 504). The method can include receiving a second input audio signal from the client device. The input audio signal can be detected at the client device by a sensor, such as a microphone. The second input audio signal can be received as part of a conversation. For example, the second input audio signal can be received in response to a prompt from the natural language generator. The digital component can include a node that identifies an assistant method. The assistant method can include or cause the natural language generator to generate the prompt.
The method 500 can include parsing the input signal (ACT 505). The method can include parsing the first input audio signal, by the natural language processor, to identify a response parameter. The response parameter can be a response to the question or request in the prompt to which the second input audio signal was received. For example, the prompt can be for additional parameters or information the fulfillment engine needs to fulfill the action. For example, the request parsed at ACT 502 can be to make a reservation at a restaurant. Execution of the assistant method can cause the natural language generator to generate an audio prompt that requests the user provide the number of people in the reservation party. The response parameter, for this example, can be 4 indicating that the user indicated that 4 people will be in the reservation party.
The method 500 can include updating a parameter (ACT 506). The method 500 can include updating the parameter of a node in the digital component based on the received response parameter. Updating the parameter can include adding the response parameter to the node in an example where the node's parameter was empty. Updating the parameter can include replacing or updating the node's parameter with the response parameter. For example, and continuing the above example, the node associated with the size of the reservation party can include a default parameter of 2. Responsive to receiving the response parameter, the fulfillment engine can set the parameter to 4. The fulfillment engine can update or set the digital component parameter based on the response parameter. For example, the response parameter of โa Mexican restaurantโ can be received in response to the prompt โwhere would you like me to make the reservation.โ The keyword or phrase โMexican restaurantโ or a related phrase, such as, โMexican foodโ can be saved as the digital component parameter.
The method 500 can include selecting a digital component (ACT 507). The method 500 can include selecting the digital component based on the digital component parameter. The digital component selector can select a plurality of candidate digital components based on the digital component parameter. The digital component selector can select the digital component with a real-time digital component selection process. The digital component selector can use the digital component parameter as a keyword for selecting the digital component. For example, and continuing the above example, the digital component selector can use the digital component parameter โMexican foodโ to select a digital component associated with Mexican food. For example, the selected digital component can be an ad for a Mexican food restaurant.
The method 500 can include transmitting the digital component (ACT 508). The digital component selector component can transmit the selected digital component to the client device for presentation to the user of the client device. The client device can display or render the digital component with the result of the action. The dependency graph data structure can be transmitted to the computing service, which can fulfill the action.
FIG. 11 is a block diagram of an example computing device 400. Computing device 400 typically includes at least one processor 402 that communicates with a number of peripheral devices via bus subsystem 404. These peripheral devices may include a storage subsystem 406, including, for example, a memory subsystem 408 and a file storage subsystem 410, user interface input devices 412, user interface output devices 414, and a network interface subsystem 416. The input and output devices allow user interaction with computing device 400. Network interface subsystem 416 provides an interface to outside networks and is coupled to corresponding interface devices in other computing devices.
User interface input devices 412 may include a keyboard, pointing devices such as a mouse, trackball, touchpad, or graphics tablet, a scanner, a touchscreen incorporated into the display, audio input devices such as voice recognition systems, microphones, and/or other types of input devices. In general, use of the term โinput deviceโ is intended to include all possible types of devices and ways to input information into computing device 400 or onto a communication network.
User interface output devices 414 may include a display subsystem, a printer, a fax machine, or non-visual displays such as audio output devices. The display subsystem may include a cathode ray tube (CRT), a flat-panel device such as a liquid crystal display (LCD), a projection device, or some other mechanism for creating a visible image. The display subsystem may also provide non-visual display such as via audio output devices. In general, use of the term โoutput deviceโ is intended to include all possible types of devices and ways to output information from computing device 400 to the user or to another machine or computing device.
Storage subsystem 406 stores programming and data constructs that provide the functionality of some or all of the modules described herein. For example, the storage subsystem 406 may include the logic to perform selected aspects of the sequence of FIG. 6 and/or the sequence of FIG. 10A.
These software modules are generally executed by processor 402 alone or in combination with other processors. Memory 408 used in the storage subsystem 406 can include a number of memories including a main random access memory (RAM) 418 for storage of instructions and data during program execution and a read only memory (ROM) 420 in which fixed instructions are stored. A file storage subsystem 410 can provide persistent storage for program and data files, and may include a hard disk drive, a floppy disk drive along with associated removable media, a CD-ROM drive, an optical drive, or removable media cartridges. The modules implementing the functionality of certain implementations may be stored by file storage subsystem 410 in the storage subsystem 406, or in other machines accessible by the processor(s) 402.
Bus subsystem 404 provides a mechanism for enabling the various components and subsystems of computing device 400 to communicate with each other as intended. Although bus subsystem 404 is shown schematically as a single bus, alternative implementations of the bus subsystem may use multiple busses.
Computing device 400 can be of varying types including a mobile device, a smartphone, a tablet, a laptop computer, a desktop computer, a wearable computer, a programmable electronic device, a set top box, a workstation, a server, a computing cluster, a blade server, a server farm, or any other data processing system or computing device. Due to the ever-changing nature of computers and networks, the description of computing device 400 depicted in FIG. 11 is intended only as a specific example for purposes of illustrating some implementations. Many other configurations of computing device 400 are possible having more or fewer components than computing device 400 depicted in FIG. 11.
In situations in which the systems described herein collect personal information about users, or may make use of personal information, the users may be provided with an opportunity to control whether programs or features collect user information (e.g., information about a user's social network, social actions or activities, profession, a user's preferences, or a user's current geographic location), or to control whether and/or how to receive content from the content server that may be more relevant to the user. Also, certain data may be treated in one or more ways before it is stored or used, so that personal identifiable information is removed. For example, a user's identity may be treated so that no personal identifiable information can be determined for the user, or a user's geographic location may be generalized where geographic location information is obtained (such as to a city, ZIP code, or state level), so that a particular geographic location of a user cannot be determined. Thus, the user may have control over how information is collected about the user and/or used.
While several implementations have been described and illustrated herein, a variety of other means and/or structures for performing the function and/or obtaining the results and/or one or more of the advantages described herein may be utilized, and each of such variations and/or modifications is deemed to be within the scope of the implementations described herein. More generally, all parameters, dimensions, materials, and configurations described herein are meant to be exemplary and that the actual parameters, dimensions, materials, and/or configurations will depend upon the specific application or applications for which the teachings is/are used. Those skilled in the art will recognize, or be able to ascertain using no more than routine experimentation, many equivalents to the specific implementations described herein. It is, therefore, to be understood that the foregoing implementations are presented by way of example only and that, within the scope of the appended claims and equivalents thereto, implementations may be practiced otherwise than as specifically described and claimed. Implementations of the present disclosure are directed to each individual feature, system, article, material, kit, and/or method described herein. In addition, any combination of two or more such features, systems, articles, materials, kits, and/or methods, if such features, systems, articles, materials, kits, and/or methods are not mutually inconsistent, is included within the scope of the present disclosure.