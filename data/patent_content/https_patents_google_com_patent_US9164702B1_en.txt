TECHNICAL FIELD
This disclosure relates to distributed cache systems.
BACKGROUND
A distributed system generally includes many loosely coupled computers, each of which typically include a computing resource (e.g., processor(s)) and storage resources (e.g., memory, flash memory, and/or disks). A distributed storage system overlays a storage abstraction (e.g., key/value store or file system) on the storage resources of a distributed system. In the distributed storage system, a server process running on one computer can export that computer's storage resources to client processes running on other computers. Remote procedure calls (RPC) may transfer data from server processes to client processes.
A remote procedure call is a two-sided software operation initiated by client software executing on a first machine and serviced by server software executing on a second machine. Servicing storage system requests (e.g., read data) in software may require an available processor, which may place a significant limitation on a distributed storage system. In the case of a distributed storage system, this means a client process cannot access a remote computer's storage resources unless the remote computer has an available processor to service the client's request. Moreover, the demand for processor resources and storage resources in a distributed system often do not match. In particular, computing resource (i.e., processors) may have heavy and/or unpredictable usage patterns, while storage resources may have light and very predictable usage patterns.
Typical logic implementing a distributed cache system can be divided between client and server jobs. Server jobs placed on machines across a cluster respond to remote procedure calls (RPC) from clients instructing the server jobs to store or retrieve cache data on the corresponding machines on which the jobs reside. The server jobs may require access not only to low latency storage capacity but also to computation time of a central processing unit (CPU). The CPU time is required to process RPCs, compute cache placement policies (mappings from cache blocks to local storage addresses), manage cache eviction policies (in order to manage limited cache storage space), and provide concurrency control amongst many concurrent requests (server jobs are often multi-threaded in order to provide low latency and high throughput).
This coupling of storage and computation requirements for cache server jobs can cause low utilization and/or high latency in general-purpose computing clusters (where server jobs are co-located with other jobs on the cluster's nodes), which is counter to the very purpose of the distributed cache. For example, nodes in the cluster with unused random access memory (RAM) that could be used by cache servers may not have any spare CPU cycles with which to serve cache requests. In this case, the “stranded” RAM goes unused. On the other hand, nodes with spare CPU cycles can experience contention for those cycles, which leads to high latencies for the cache server's RPCs. In this case, the only remedy may be to accept the high latencies or run the nodes at lower CPU utilization.
SUMMARY
One aspect of the disclosure provides a distributed cache system that includes a data storage portion, a data control portion, and a cache logic portion in communication with the data storage and data control portions. The data storage portion includes memory hosts, each having non-transitory memory and a network interface controller in communication with the memory for servicing remote direct memory access requests. The data control portion includes a curator in communication with the memory hosts. The curator manages striping of data across the memory hosts. The cache logic portion executes at least one memory access request to implement a cache operation. In response to each memory access request, the curator provides the cache logic portion a file descriptor mapping data stripes and data stripe replications of a file on the memory hosts for remote direct memory access of the file on the memory hosts through the corresponding network interface controllers.
Implementations of the disclosure may include one or more of the following features. In some implementations, the cache logic portion includes a cache service having a cache data layer storing cache data in files and a cache indexing layer indexing the cache data stored in the files. Each data storing file may implement a fixed size, first-in-first-out queue having a front and a back, with a tail pointer providing an offset to the front of the queue, referred to as a circular data file. Other replacement polices, such as least recently used (LRU), random, not most recently used, etc. may be used as well. The cache service may shard the data into a set of data files (e.g., circular data files), each file storing cache entries, each cache entry comprising cache data, a cache tag, and a cache fingerprint.
The cache indexing layer may include a set associative tag map indexing the cache data stored in the data files. The set associative tag map maps cache tag fingerprints to locations of the corresponding cache data in the data files.
In some implementations, the cache logic portion includes a transaction interface and a cache interface. The transaction interface executes an atomic transaction including at least one of a read operation or a write operation on files stored on the memory hosts. The cache interface interfaces between a client and the transaction interface for executing at least one of a look up operation, an insert operation, or a remove operation. The transaction executes a commit operation. For data chunks of a read set of the transaction, the commit operation includes reading data of the data chunks of the read set through remote direct memory access and determining a validity of the read data by evaluating a version and a lock of each data chunk of the read set. For data chunks of a write set of the transaction, the commit operation includes setting locks on the data chunks of the write set, writing data to the locked data chunks through remote direct memory access, releasing the locks of the locked data chunks, and incrementing a version number of each released data chunk.
In some implementations, the transaction aborts the commit operation when at least one data chunk of the write set fails to receive a lock or when the read data is invalid. For any data chunks having an unreleased lock, the curator may reset those data chunks to an uninitialized state and releases their locks. The commit operation may include rereading the data of the data chunks of the read set when the previous read is invalid.
To allow a durable transaction, the commit operation may include reading existing data of the data chunks of the write set before writing new data to the data chunks of the write set, and writing the existing data of the data chunks of the write set to a durable intent log. The commit operation may include aborting the transaction when at least one data chunk of the write set fails to receive a lock or when the read data is invalid. For any data chunks having an unreleased lock, the method includes retrieving their data stored in the durable intent log, writing the retrieved data to the corresponding data chunks (e.g., to reconstruct the data), and releasing the locks of those data chunks.
In some implementations, the curator returns location information of data on the memory hosts in response to the client memory access request. The curator may return a key to allow access to data on the memory hosts in response to the client memory access request. The curator may allocate storage of a data stripe on the memory hosts. Each file stored on the memory hosts may be divided into data stripes and each data stripe may be replicated into multiple storage locations of the memory hosts. In some implementations, the curator stores a file map mapping files to file descriptors.
The file descriptor may include at least one of the following: a file state attribute providing a state of a file, a data chunks attribute providing a number of stripe replicas per stripe, a stripe length attribute providing a number of bytes per stripe, and a sub-stripe length attribute providing a number of bytes per sub-stripe. In some examples, the file descriptor includes an array of stripe protocol buffers, each describing a data stripe replica within a data stripe. Each stripe protocol buffer may include at least one of a stripe replica handle, an identity of the memory host holding the stripe replica, and a current state of the stripe replica.
Another aspect of the disclosure provides a method of accessing a distributed cache system. The method includes receiving a cache operation from a client, executing at least one memory access request, and for each memory access request, returning a file descriptor mapping data stripes and data stripe replications of a file on memory hosts for remote direct memory access of the file on the memory hosts. The method also includes executing on a computing processor a transaction comprising at least one of a read operation or a write operation on files stored on the memory hosts to implement the cache operation.
In some implementations, the cache operation includes at least one of a look up operation, an insert operation, or a remove operation. The method may include storing data in files on the memory hosts and indexing the data stored in the files. The method may include sharding the data into a set of data files. Each file stores cache entries, and each cache entry includes cache data, a cache tag, and a cache fingerprint. In some examples, the method includes mapping cache tag fingerprints to locations of the corresponding cache data in the data files.
The insert operation may include receiving data, receiving a cache tag associated with the data, selecting a data file for insertion of the data, and executing a push back operation to add a cache entry including the data and the cache tag at a back of a queue of the selected circular file. The queue has a first-in-first-out eviction policy.
The push back operation may include reading an offset of a back of the queue of the data file from a corresponding tail pointer, writing the cache entry to the data file at the offset, and updating the offset in the tail pointer. The method may also include reading a region of the data file being overwritten to identify overwritten cache tags, and updating a set associative tag map.
Updating the set associative tag map may include reading a set of the tag map corresponding to the cache tag of the written cache entry, inserting an entry corresponding to the tag at a back of the set, and dropping an entry at a front of the set. Additionally or alternatively, updating the set associative tag map may include reading a set of the tag map corresponding to the evicted cache tags and removing entries from the set corresponding to the evicted cache tags. The method may include receiving a cache tag, reading a set of a tag map containing a fingerprint of the cache tag, and removing an entry from the set of the tag map corresponding to the fingerprint.
In some implementations, the method includes accessing a file map mapping files to file descriptors to return the file descriptor in response to the memory access request. The method may include returning location information of data on the memory hosts in response to the client memory access request. The method may include returning a key to allow access to data on the memory hosts in response to the client memory access request. In some examples, the method includes allocating storage of a data stripe on the memory hosts. The method may include dividing the file into data stripes and replicating each data stripe into multiple storage locations of the memory hosts.
For data chunks of a read set of the transaction, the method may include reading data of the data chunks of the read set through remote direct memory access and determining a validity of the read data by evaluating a version and a lock of each data chunk of the read set. For data chunks of a write set of the transaction, the method may include setting locks on the data chunks of the write set, writing data to the locked data chunks through remote direct memory access, releasing the locks of the locked data chunks, and incrementing a version number of each released data chunk.
In some implementations, the method includes aborting the transaction when at least one data chunk of the write set fails to receive a lock or when the read data is invalid. For any data chunks having an unreleased lock, the method may include resetting those data chunks to an uninitialized state and releasing their locks (e.g., for a non-durable transaction). The method may include rereading the data of the data chunks of the read set when the previous read is invalid.
To allow a durable transaction, the method may include reading existing data of the data chunks of the write set before writing new data to the data chunks of the write set, and writing the existing data of the data chunks of the write set to a durable intent log. The method may include aborting the transaction when at least one data chunk of the write set fails to receive a lock or when the read data is invalid. For any data chunks having an unreleased lock, the method includes retrieving their data stored in the durable intent log, writing the retrieved data to the corresponding data chunks (e.g., to reconstruct the data), and releasing the locks of those data chunks.
The details of one or more implementations of the disclosure are set forth in the accompanying drawings and the description below. Other aspects, features, and advantages will be apparent from the description and drawings, and from the claims.
DESCRIPTION OF DRAWINGS
FIG. 1A is a schematic view of an exemplary distributed cache system.
FIG. 1B is a schematic view of an exemplary distributed cache system having a cell of memory hosts managed by a curator.
FIG. 1C is a schematic view of an exemplary cell of a distributed cache system.
FIG. 2A is a schematic view of an exemplary curator for a distributed storage system.
FIG. 2B is a schematic view of establishing a connection between a client and memory host of an exemplary distributed storage system.
FIG. 2C is a schematic view of clients sending memory access requests to a memory host of an exemplary distributed storage system.
FIG. 3A is a schematic view of an exemplary file split into replicated stripes.
FIG. 3B is a schematic view of an exemplary file descriptor.
FIG. 3C is a schematic view of an exemplary cache service.
FIG. 3D is a schematic view of an exemplary tap map and associated circular data files.
FIG. 3E is a schematic view of an exemplary circular data file before and after a push back operation.
FIG. 3F is a schematic view of an exemplary tag map before insertion of an entry.
FIG. 3G is a schematic view of an exemplary tag map after insertion of an entry.
FIG. 4A is a schematic view of an exemplary application programming interface.
FIG. 4B is a schematic view of an exemplary transaction writing data to a file stored in a distributed storage system.
FIG. 4C is a schematic view of an exemplary transaction reading data from a file stored in a distributed storage system.
FIG. 4D is a schematic view of a client reading and writing data in an exemplary distributed storage system.
FIG. 5 is a schematic view of an exemplary arrangement of operations for a method of controlling access in a distributed storage system.
FIG. 6 is a schematic view of an exemplary flow chart illustrating a method of accessing data stored on a distributed storage system.
FIG. 7 is a schematic view of an exemplary arrangement of operations for a method of providing access to data stored on a distributed storage system.
FIG. 8 is a schematic view of an exemplary flow chart for a method of managing read/write requests in a distributed data storage system.
FIGS. 9A and 9B provide schematic views of an exemplary arrangement of operations for a method executing a transaction in a distributed storage system.
Like reference symbols in the various drawings indicate like elements.
DETAILED DESCRIPTION
A caching system may store the results of high latency computational operations (e.g., disk seeks, database query results, etc.) in storage devices with significantly lower latency (e.g., dynamic random access memory (DRAM) or flash storage) for later retrieval. A distributed cache system may store its data across remote resources of an entire computer cluster. The computer cluster may reduce the latency of computational tasks by serving as many results as possible from low latency storage, and increase the utilization of these resources throughout the cluster by putting otherwise unused resources to work as cache storage.
Referring to FIGS. 1A-1C, in some implementations, a distributed cache system 100 includes loosely coupled memory hosts 110, 110 a-n (e.g., computers or servers), each having a computing resource 112 (e.g., one or more processors or central processing units (CPUs)) in communication with storage resources 114 (e.g., memory, flash memory, dynamic random access memory (DRAM), phase change memory (PCM), and/or disks) that may be used for caching data. A storage abstraction (e.g., key/value store or file system) overlain on the storage resources 114 allows scalable use of the storage resources 114 by one or more clients 120, 120 a-n. The clients 120 may communicate with the memory hosts 110 through a network 130 (e.g., via RPC).
The single-sided distributed cache system 100 may eliminate the need for any cache server jobs for responding to remote procedure calls (RPC) from clients 120 to store or retrieve cache data on their corresponding memory hosts 110 and may rely on specialized hardware (e.g., network interface controllers 116) to process remote requests 122 instead. “Single-sided” refers to the method by which most of the request processing on the memory hosts 110 may be done in hardware rather than by software executed on CPUs 112 of the memory hosts 110. Rather than having a processor 112 of a memory host 110 (e.g., a server) execute a server process that exports access of the corresponding storage resource 114 (e.g., non-transitory memory) to client processes executing on the clients 120, the clients 120 may directly access the storage resource 114 through a network interface controller (NIC) 116 of the memory host 110. In other words, a client process executing on a client 120 may directly interface with one or more storage resources 114 without requiring execution of a routine of any server processes executing on the computing resources 112. This offers a single-sided distributed storage architecture that offers relatively high-throughput and low latency, since clients 120 can access the storage resources 114 without interfacing with the computing resources 112 of the memory hosts 110. This has the effect of decoupling the requirements for storage 114 and CPU cycles that typical two-sided distributed cache systems carry. The single-sided distributed cache system 100 can utilize remote storage resources 114 regardless of whether there are spare CPU cycles on that memory host 110; furthermore, since single-sided operations do not contend for server CPU resources, a single-sided system can serve cache requests 122 with very predictable, low latency, even when memory hosts 110 are running at high CPU utilization. Thus, the single-sided distributed cache system 100 allows higher utilization of both cluster storage 114 and CPU resources 112 than traditional two-sided systems, while delivering predictable, low latency.
In some implementations, the distributed cache system 100 includes a cache logic portion 102, a data control portion 104, and a data storage portion 106. The cache logic portion 102 may include a cache application programming interface (API) 400 a (e.g., software library) that lies between a client application/process 128 executing on a client 120 accessing a distributed cache 150 (e.g., storage resources 114) on the memory hosts 110 and a transaction API 400 b (e.g., a single-sided transactional system client library) that is responsible for accessing the underlying data via single-sided operations. The data control portion 104 may manage allocation and access to cache storage 114 with tasks such as allocating cache storage 114, registering cache storage 114 with the corresponding network interface controller 116, setting up connections between the client(s) 120 and the memory hosts 110, handling errors in case of machine failures, etc. The data storage portion 106 may include the loosely coupled memory hosts 110, 110 a-n.
In some implementations, the distributed cache system 100 stores cache data 312 in dynamic random access memory (DRAM) 114 and serves the cache data 312 from the remote hosts 110 via remote direct memory access (RDMA)-capable network interface controllers (NICs) 116. A network interface controller 116 (also known as a network interface card, network adapter, or LAN adapter) may be a computer hardware component that connects a computing resource 112 to the network 130. The network controller 116 implements communication circuitry using a specific physical layer (OSI layer 1) and data link layer (layer 2) standard, such as Ethernet, Wi-Fi, or Token Ring. This provides a base for a full network protocol stack, allowing communication among small groups of computers on the same LAN and large-scale network communications through routable protocols, such as Internet Protocol (IP). Both the memory hosts 110 a-n and the client 120 may each have a network interface controller 116 for network communications. A host process 118 executing on the computing processor 112 of the memory host 110 registers a set of remote direct memory accessible regions 114 a-n of the memory 114 with the network interface controller 116. The host process 118 may register the remote direct memory accessible regions 114 a-n of the memory 114 with a permission of read-only or read/write. The network interface controller 216 of the memory host 110 creates a client key 321 for each registered memory region 114 a-n.
In some implementations, the network 130 is an InfiniBand network, which is a switched fabric communications link generally used in high-performance computing and enterprise data centers. It features high throughput, low latency, quality of service, failover, and scalability. The InfiniBand architecture specification defines a connection between processor nodes and high performance I/O nodes such as storage devices. The InfiniBand network 130 conveys remote direct memory access (RDMA) requests 122 from a client 120 to a memory host 110. At the memory host 110, an RDMA-capable InfiniBand network interface controller (NIC) 116 performs reads and writes of the storage resource 114 (e.g., DRAM). RDMA uses zero-copy, OS-bypass to provide high throughput, low latency access to data (e.g., 4 GB/s of bandwidth and 5 microsecond latency). The distributed storage system 100 may use RDMA, remote procedure calls, or other data access methods to access data.
The single-sided operations performed by the network interface controllers 116 may be limited to simple reads, writes, and compare-and-swap operations, none of which may be sophisticated enough to act as a drop-in replacement for the software logic implemented by a traditional cache server job to carry out cache requests and manage cache policies. The cache API 400 a translates commands, such a look up or insert data commands, into sequences of primitive NIC operations that correctly implements a desired caching policies (e.g., placement and replacement). The cache API 400 a interfaces with the transaction API 400 b to interact with the data control and data storage portions 104, 106 of the distributed cache system 100. For data structures that would implement a cache in the memory of a single, isolated machine, the distributed cache system 100 lays out these data structures across the address spaces of the memory hosts 110 (rather than in the virtual address space of a single machine). The client(s) 120 may access and mutate the data structures following the same algorithms as if they were local to their own machine, allowing the cache API 400 a translate the requested reads and writes into remote memory accesses.
The distributed cache system 100 may include a co-located software process to register memory 114 for remote access with the network interface controllers 116 and set up connections 250 (FIG. 2B) with client processes 128. Once the connections 250 are set up, client processes 128 can access the registered memory 114 via engines in hardware of the network interface controllers 116 without any involvement from software on the local CPUs 112 of the corresponding memory hosts 110.
Referring to FIGS. 1B and 1C, in some implementations, the distributed cache system 100 includes multiple cells 200, each cell 200 including memory hosts 110 and a curator 210 in communication with the memory hosts 110. The curator 210 (e.g., process) may execute on a computing processor 202 (e.g., server) connected to the network 130 and manages the data storage (e.g., manages a file system stored on the memory hosts 110), controls data placements, and/or initiates data recovery. Moreover, the curator 210 may track an existence and storage location of data on the memory hosts 110. Redundant curators 210 are possible. In some implementations, the curator(s) 210 track the striping of data across multiple memory hosts 110 and the existence and/or location of multiple copies of a given stripe for redundancy and/or performance. In computer data storage, data striping is the technique of segmenting logically sequential data, such as a file, in a way that accesses of sequential segments are made to different physical storage devices (e.g., cells 200 and/or memory hosts 110). Striping is useful when a processing device requests access to data more quickly than a storage device can provide access. By performing segment accesses on multiple devices, multiple segments can be accessed concurrently. This provides more data access throughput, which avoids causing the processor to idly wait for data accesses.
In some implementations, the transaction API 400 b interfaces between a client 120 (e.g., the cache API 400 a, which interfaces with the client process 128) and the curator 210. In some examples, the client 120 communicates with the curator 210 through one or more remote procedure calls (RPC). In response to a client request 122, the transaction API 400 b may find the storage location of certain data on memory host(s) 110, and obtain a key 321 that allows access to the data. The transaction API 400 b communicates directly with the appropriate memory hosts 110 (via the network interface controllers 216) to read or write the data (e.g., using remote direct memory access). In the case that a memory host 110 is non-operational, or the data was moved to a different memory host 110, the client request 122 fails, prompting the client 120 to re-query the curator 210.
Referring to FIG. 2A, in some implementations, the curator 210 stores and manages file system metadata 212. The metadata 212 includes a file map 214 that maps files 310 1, to file descriptors 300 1-n. The curator 210 may examine and modify the representation of its persistent metadata 212. The curator 210 may use three different access patterns for the metadata 212: read-only, file transactions, and stripe transactions. Read-only access allows the curator 210 to examine a state of the metadata 212 with minimal contention. A read-only request returns the most recent state of a file 310, but with no synchronization with concurrent updates. The read-only access may be used to respond to lookup requests from clients 120 (e.g., for internal operations, such as file scanning).
Referring also to FIGS. 3A and 3B, in some implementations, the memory hosts 110 store file data 312. The curator 210 may divide each file 310 (and its data 312) into stripes 320 a-n and replicate the stripes 320 a-n for storage in multiple storage locations. A stripe replica 320 n k is also referred to as a chunk or data chunk 320 n k. Mutable files may have additional metadata stored on the memory host(s) 110, such as lock words and version numbers. The lock words and versions numbers may be used to implement a distributed transaction commit protocol.
File descriptors 300 stored by the curator 210 contain metadata, such as the file map 214, that maps the stripes 320 a-n to data chunks 320 n k (i.e., stripe replicas) stored on the memory hosts 110. To open a file 310, a client 120 sends a request 122 to the curator 210, which returns a file descriptor 300. The client 120 uses the file descriptor 300 to translate file chunk offsets to remote memory locations 114 a-n. After the client 120 loads the file descriptor 300, the client 120 may access the file's data via RDMA or another data retrieval method.
Referring to FIGS. 2B and 2C, RDMA is a connection-based process-to-process communication mechanism, so RDMA connections typically do not support authentication or encryption by themselves. As a result, the distributed storage system 100 may treat the RDMA connections 250 as secure resources. In order for a client process 128 to access the memory 114 of a host process 118 through RDMA, the network interface controller 116 of the memory host 110 executes a connection handshake with a network interface controller 116 of the client process 128 to establish the RDMA capable connection 250 between the host process 118 and the client process 128. The RDMA connection handshake may implement a higher-level secure protocol that evaluates the identities of the host and client processes 118, 128 as known at the time of creation of the trusted RDMA connection 250. After an RDMA-capable connection 250 is established, the client process 128 or the host process 118 can unilaterally break the connection 250. If either the client process 128 or the host process 118 dies, the client 120 and/or the memory host 110 (via operating systems) can tear down the corresponding RDMA connection(s) 250.
Access to file data 312 (e.g., data chunks 320 n k) stored in remote memory locations 114 a-n may be controlled by access control lists 260. Each access control list 260 may have a unique name, a list of data chunks 320 n k, and a list of clients 120 a-n that have permission to read and write the data chunks 320 n k associated with that access control list 260. In some examples, the access control list 260 provides an access permission level for each associated client 120 or each associated data chunk 320 n k. The memory hosts 110 may receive the access control lists 260 through a secure communication channel and can be enforced by the memory hosts 110 using protection domains 270. Each RDMA accessible memory region 114 a-n registered with the network interface controller 116 of each memory host 110 is associated with a protection domain 270. In some implementations, when the curator 210 allocates memory 114 for the data chunks 320 n k, it associates the allocated memory regions 114 a-n of the data chunks 320 n k with one or more protection domains 270. A memory host 110 may have many protection domains 270 associated with various regions 114 a-n of its memory 114. Each protection domain 270 may also have one or more associated connections 250.
When a client 120 instantiates a memory access request 122 for a file 310 stored on one or more of the memory hosts 110, the client 120 requests a file descriptor 300 from the curator 210 to identify which memory host(s) 110 store the data chunks 320 n k of the file 310. In addition to mapping data chunks 320 n k of the file 310 to memory regions 114 a-n of memory hosts 110, the file descriptor 300 may also include a client key 321 for accessing those data chunks 320 n k. The client 120 then searches a connection cache 252 for any open RMDA capable connections 250 to the identified memory hosts 110. If each memory host 110 fails to have an open connection 250 with the client 120 that is in the same protection domain 270 as the requested data chunk(s) 320 n k, the client 120 sends a connection request 254 to any memory hosts 110 not having the necessary open connection(s) 250.
In response to receiving a connection request 254 from a client process 128 of a client 120 to access a data chunk 320 n k (e.g., to access a memory region 114 a-n storing the data chunk 320 n k), the host process 128 may establish a remote direct memory access capable connection 250 with the client process 128 when both the client 120 and the requested data chunk 320 n k are associated with the same access control list 260 received by the memory host 110. The client process 128 may include the access control list 260 in the connection request 254. The host process 118 may associate the established open connection 250 with a protection domain 270 and the client process 128 may store the open connection 250 in the connection cache 252. The connection 250 is capable of accessing (via RDMA) only the memory regions 114 a-n associated with its protection domain 270. The network interface controller 216 of the memory host 110 may tear down the connection upon receiving an RDMA request having an address for unregistered memory 114.
In the example shown in FIG. 2C, first and second clients 120 a, 120 b send memory access requests 122 to a memory host 110 n over respective first and second RDMA connections 250 a, 250 b. The memory host 110 n has first and second protection domains 270 a, 270 b associated with its memory 114. The first protection domain 270 a is associated with first and second memory regions 114 a, 114 b (e.g., storing corresponding first and second data chunks 320 n 1, 320 n 2) and the first RDMA connection 250 a, while the second protection domain 270 b is associated with a third memory region 114 c (e.g. storing a corresponding third data chunks 320 n 3) and only the second RDMA connection 250 a.
The first client 120 a sends first and second memory access requests 122 a, 122 b over the first RMDA connection 250 a to the memory host 110 n. The first memory access request 122 a is for accessing the second memory region 114 b for the second data chunk 320 n 2 and the second memory access request 122 b is for accessing the third memory region 114 c for the third data chunk 320 n 3. The first memory access request 122 a succeeds, because the second memory region 114 b belongs to the same protection domain 270 a as the first connection 250 a. The second memory access request 122 b fails, because the third memory region 114 c belongs to a different protection domain 270, the second protection domain 270 b, rather than the protection domain 270 of the second memory access request 122 b (i.e., the first protection domain 270 a).
The second client 120 b sends third and fourth memory access requests 122 c, 122 d over the second RDMA connection to the memory host 110 n. The third memory access request 122 c is for accessing the first memory region 114 a for the first data chunk 320 n 1 and the fourth memory access request 122 d is for accessing the third memory region 114 c for the third data chunk 320 n 3. In this case, both memory access requests 122 c, 122 d succeed, because the RDMA connection 250 b of the second client 120 b belongs to the protection domains 270 a, 270 b of both the first memory region 114 a and the third memory region 114 c.
Referring again to FIG. 2C, in some implementations, the curator 210 can create, copy, resize, and delete files 310. Other operations are possible as well. To service a copy request 122 cr from a client 120, the curator 210 creates a new file descriptor 300 having a state initially set to COPY_PENDING. The curator 210 may set/initialize one or more of the following fields: size, owner, group, permissions, and/or backing file. The curator 210 populates a stripes array 325 of the file descriptor 300 (FIG. 3B) with empty stripes 320 n and then commits the file descriptor 300 to its file map 214. Committing this information to the file map 214 allows the curator 210 to restart a resize operation if the curator 210 crashes or a tablet containing the file system metadata 212 migrates to another curator 210. Once the curator 210 commits the file descriptor 300 to the file map 214, the curator 210 responds to the client copy request 122 cr by informing the client 120 that the copy operation has been initiated. The curator 210 initiates memory-host-pull-chunk operations, which instruct memory hosts 110 to allocate a new chunk 320 n k and to read chunks 320 n k of the backing file into the memory 114 of the memory hosts 110. When a pull-chunk operation returns successfully, the curator 210 adds the new chunk 320 n k to the appropriate stripe 320 n in the file descriptor 300. The curator 210 commits the stripe 320 n with the new chunk 320 n k to the file map 214.
In the case of a crash or a migration, incrementally updating the file descriptors 300 allows a new curator 210 to restart a copy operation from the location the prior curator 210 stopped. This also allows clients 120 to check the status of a copy operation by retrieving the file descriptor 300 (e.g., via a lookup method) and inspecting the number of stripes 320 n in the file descriptor 300 populated with chunks 320 n k. Once all chunks 320 n k have been copied to the memory hosts 110, the curator 210 transitions the state of the file descriptor 300 to READ and commits it to the file map 214.
The curator 210 may maintain status information for all memory hosts 110 that are part of the cell 200. The status information may include capacity, free space, load on the memory host 110, latency of the memory host 110 from a client's point of view, and a current state. The curator 210 may obtain this information by querying the memory hosts 110 in the cell 200 directly and/or by querying a client 120 to gather latency statistics from a client's point of view. In some examples, the curator 210 uses the memory host status information to make rebalancing, draining, recovery decisions, and allocation decisions.
The curator(s) 210 may allocate chunks 320 n k in order to handle client requests 122 for more storage space in a file 310 and for rebalancing and recovery. The curator 210 may maintain a load map 216 of memory host load and liveliness. In some implementations, the curator 210 allocates a chunk 320 n k by generating a list of candidate memory hosts 110 and sends an allocate chunk request to each of the candidate memory hosts 110. If the memory host 110 is overloaded or has no available space, the memory host 110 can deny the request. In this case, the curator 210 selects a different memory host 110. Each curator 210 may continuously scan its designated portion of the file namespace, examining all the metadata 212 every minute or so. The curator 210 may use the file scan to check the integrity of the metadata 212, determine work that needs to be performed, and/or to generate statistics. The file scan may operate concurrently with other operations of the curator 210. The scan itself may not modify the metadata 212, but schedules work to be done by other components of the system and computes statistics.
For each file descriptor 300, the file scan may: ensure that the file descriptor 300 is well formed (e.g., where any problems may indicate a bug in either the curator or in the underlying storage of the metadata); update various statistics, such as the number of files 310, stripes 320 n, chunks 320 n k, and the amount of storage used; look for stripes 320 n that need recovery; determine if the file descriptor 300 contains chunks 320 n k that are candidates for rebalancing from overfull memory hosts 110; determine if there are chunks 320 n k on draining memory hosts 110; determine if there are chunks 320 n k that are candidates for rebalancing to under-full memory hosts 110; determine chunks 320 n k that can be deleted; and/or determine if the file descriptor 300 has a pending resize or copy operation, but there is no active task within the curator 210 working on the operation.
In some implementations, the distributed storage system 100 supports two types of files: immutable and mutable. Immutable files rely on a disk-based file system for persistence and fault-tolerance. A client 120 may copy immutable files into the file system of the distributed storage system 100. On the other hand, a client 120 may write mutable files into the file system of the distributed storage system 100 using the transaction application programming interface (API) 400 b. The storage system 100 may or may not be durable. The distributed storage system 100 may have strict data loss service level objectives (SLOs) that depend on the files' level of replication. When a stripe 320 n is lost, the curator 210 may allocate new storage for the lost stripe 320 n and mark the data as uninitialized. A client 120 attempting to read an uninitialized stripe 320 n receives an uninitialized data error. At this point, the client 120 can reinitialize the stripe's data.
The file descriptor 300 may provide the state of a file 310. A file 310 can be in one of the following states: READ, READ_WRITE, DELETED, or {CREATE, COPY, RESIZE}_PENDING. In the READ state, clients 120 can read the file 310, but not write to the file 310. Read-only files 310 are read-only for the entire life-time of the file 310, i.e., read-only files 310 are never written to directly. Instead, read-only files 310 can be copied into the file system from another file system. A backing file 310 may be used to restore data when a memory host 110 crashes; consequently, the backing file 310 persists for the entire life-time of the file 310. In the READ_WRITE state, clients 120 with the appropriate permissions can read and write a mutable file's contents. Mutable files 310 support concurrent, fine grain, random writes. Random and sequential write performance may be comparable. Writes are strongly consistent; that is, if any client 120 can observe the effect of a write, then all clients 120 can observe the effect of a write. Writes can also be batched into transactions. For example, a client 120 can issue a batch of asynchronous writes followed by a sync operation. Strong consistency and transactional semantics ensure that if any client 120 can observe any write in a transaction, then all clients 120 can observe all writes in a transaction. In the DELETED state, the file 310 has been deleted. The chunks 320 n k belonging to the file 310 are stored in a deleted chunks field and wait for garbage collection. The {CREATE, COPY, RESIZE}_PENDING state denotes a file 310 has a create, copy, or resize operation pending on the file.
An encoding specified by a file encoding protocol buffer of the file descriptor 300 may be used for all the stripes 320 a-n within a file 310. In some examples, the file encoding contains the following fields: “data chunks,” which provides a number of data chunks 320 n k per stripe 320 n; “stripe length,” which provides a number of bytes per stripe 320 n; and “sub-stripe length,” which provides a number of bytes per sub-stripe. The sub-stripe length may be only valid for READ_WRITE files. The data 312 for a file 310 may be described by an array of stripe protocol buffers 325 in the file descriptor 300. Each stripe 320 n represents a fixed region of the file's data, identified by an index within the array. The contents of a stripe 320 n may include an array of chunk protocol buffers 327, each describing a chunk 320 n k within the stripe 320 n, including a chunk handle, an identity of the memory host 110 holding the chunk 320 n k, and a current state of the chunk 320 n k. For RDMA purposes, the chunk protocol buffers 327 may also store a virtual address of the chunk 320 n k in the memory host 110 and a client key 321 (e.g., a 32-bit key. The client key 321 is unique to a chunk 320 n k on a memory host 110 and is used to RDMA-read that chunk 320 n k.
Stripes 320 n can be further divided into sub-stripes 322 n with associated sub-stripe metadata 324. Each sub-stripe 322 n may include an array of sub-chunks 326 a-n, each having corresponding associated sub-chunk metadata 328.
Chunks 320 n k can be in one of the following states: OK, Recovering, Migrating Source, and Migrating Destination. In the OK state, the contents are valid and the chunk 320 n k contributes to the replication state of the corresponding stripe 320 n. Clients 120 may update all chunks 320 n k in a good state. In the Recovering state, the chunk Recovering is in the process of being recovered. The chunk Recovering does not count towards the replicated state of the corresponding stripe 320 n and the data in the chunk 320 n k is not necessarily valid. Therefore, clients 120 cannot read data from chunks 320 n k in the Recovering state. However, all transactions not reaching their commit point at the time a chunk state changes to the Recovering state must include the Recovering chunk in the transaction in order to ensure that the chunk's data is kept up to date during recovery.
In the Migrating Source state, the chunk 320 n k is in the process of migrating. A migrating source attribute may provide a location from which the chunk 320 n k is migrating. The source chunk 320 n k counts towards the replication of the stripe 320 n and the data in the chunk 320 n k is valid and can be read. In the Migrating Destination state, the chunk is in the process of migrating. A Migrating Destination attribute provides the location to which the chunk 320 n k is migrating. The source chunk 320 n k does not count towards the replicated state of the stripe 320 n and the chunk 320 n k is not necessarily valid. Therefore, clients 120 cannot read from chunks 320 n k in the Migrating Destination state. However, all transactions not reaching their commit point at the time a chunk's state changes to the Migrating Destination state must include the Migrating Destination chunk 320 n k in the transaction in order to ensure the chunk's data is kept up to date as it is being migrated.
Each file descriptor 300 may have a dead chunks array. The dead chunks array holds additional chunks 320 n k that are no longer needed, such as the chunks 320 n k that made up a file 310 that has since been deleted, or made up previous instances of the file 310. When the file 310 is deleted or truncated, the chunks 320 n k from all the stripes 320 n are moved into this dead chunks array and the stripes 320 n are cleared. The chunks 320 n k in the dead chunks array are reclaimed in the background.
The transaction API 400 b may facilitate transactions having atomicity, consistency, isolation, durability (to a degree), such that the transaction may be serializable with respect to other transactions. ACID (atomicity, consistency, isolation, durability) is a set of properties that guarantee that database transactions are processed reliably. In the context of databases, a single logical operation on the data is called a transaction. Atomicity requires that each transaction is “all or nothing”: if one part of the transaction fails, the entire transaction fails, and the database state is left unchanged. An atomic system guarantees atomicity in each and every situation, including power failures, errors, and crashes. Consistency ensures that any transaction brings the database from one valid state to another. Any data written to the database must be valid according to all defined rules, including but not limited to constraints, cascades, triggers, and any combination thereof. Isolation ensures that no transaction should be able to interfere with another transaction. One way of achieving this is to ensure that no transactions that affect the same rows can run concurrently, since their sequence, and hence the outcome, might be unpredictable. This property of ACID may be partly relaxed due to the huge speed decrease this type of concurrency management entails. Durability means that once a transaction has been committed, it will remain so, even in the event of power loss, crashes, or errors. In a relational database, for instance, once a group of SQL statements execute, the results need to be stored permanently. If the database crashes immediately thereafter, it should be possible to restore the database to the state after the last transaction committed.
Referring to FIGS. 3C and 3D, in some implementations, a cache service instance 350 includes a set of files 310 1-n contained within a directory of the file system of the distributed cache system 100. Thus, a cache service instance 350 can be identified by a file path 352 containing the files 310 (e.g., passing a cache path parameter to open a handle to a cache instance). The cache service 350 may include two caching layers: a cache data layer 354 and a cache indexing layer 356. The cache data layer 354 stores cache data 312 in data files 310 and the cache indexing layer 356 indexes the cache data 312 stored in the data files 310. The cache indexing layer 356 may have a set associative placement policy and a first in/first out (FIFO) replacement policy within each set 362 of a tag map 360. The cache data layer 354 may be sharded into many separate files 310 (e.g., circular data files). An instance of a cache service 350 may include two types of data structures laid out in the files 310 of the distributed storage system 100: a set 315 of circular data files 310 and a set associative tag map 360. Moreover, the cache service 350 may be associated with a cell 200 of distributed cache system 100.
The cache data layer 354 includes circular data files 310, which contain the actual cached data 312. Each cache entry 370 in the circular data files 310 may contain the corresponding cache data 312, a cache tag 372, and a fingerprint 374 to aid in identifying the cache data entry 370 during look up and insert operations, for example. The circular data files 310 may have a fixed size and evictions may occur in a first-in-first-out (FIFO) order when additional space is needed. Each circular data file 310 includes a FIFO queue 380 having a front 382 and a back 384. An offset 392 to the front 382 of the FIFO queue 380 of the circular data file 310 can be stored in an auxiliary tail pointer file 390. Thus, the construct of a circular data file 310 may actually include two physical files. The caching service 350 may shard the cache data 312 into a set 315 of many circular data files 310 via consistent hashing. This allows tuning of the cache for contention, as concurrent insertion operations to the data files 310 may contend for the back 384 of the queue 380. Circular data files 310 in a given cache file path 352 may be identified by a 32-bit integer identifier so that pointers to data files 310 can be limited to a fixed, small size.
The set associative tag map 360 may function as an index of the cache data 312 stored in the data files 310. The set associative tag map 360 maps cache tag fingerprints 374 to locations of the corresponding cache data 312 in the circular data files 310 (i.e., a struct containing a data file id, offset 392, and size of the cache entry 370). The caching service 350 may implement the mapping as a set associative cache, where the cache tags 372 are 64-bit fingerprints and the data payloads 312 are pointers to regions 310 r of circular data files 310 (e.g., memory regions 114 a-n). Eviction within each set 362 of the tag map 360 may be handled in a FIFO order. In practice, the tag map 360 can be sized to ensure that conflict misses caused by its restrictive placement policy are rare, so that the tag map 360 can be considered a mostly-complete index for the data 312 contained in the circular data files 310. Moreover, the tag map 360 may be stored in a file 310.
In some implementations, the cache API 400 a implements cache operations including look up, insert, and remove operations. The cache look up operation of a cache tag 372 identifies the cache tag 372 in the tag map 360 by fingerprinting the cache tag 372 to obtain a corresponding fingerprint 374 and then applying a mapping function to map the fingerprint 374 to a set 362 in the tag map 360. The client 120 may read the set 362 from the cache 150 and search for a cache entry 370 matching the fingerprint 374. If a result is not found, the look up operation reports a cache miss; if the result is found, the look up operation reads a region 310 r of the corresponding circular data file 310 pointed to by the cache entry 370. The look up operation checks that the data 312 read actually corresponds to the cache tag 372, and returns a hit with the corresponding data 312, as illustrated in FIG. 3C. In some implementations, the cache look up operation does not need to modify any globally shared state (e.g., book-keeping of most recently used timestamps), but rather can be a read-only operation. Alternatively, cache look up operation may modify some shared space, shared statistics, counters, or states that may help implement some other caching policy, such as least recently used (LRU), random, not most recently used, etc. File access may be implemented with a transactional protocol that ensures that a cache access is atomic and serializable with respect to concurrent mutations.
Referring to FIG. 3E, in some implementations, the cache insert operation receives a cache tag 372 with the data 312 and selects a circular data file 310 for insertion of the data 312 by taking a consistent hash of the cache tag 372. The cache insert operation executes a push back operation to add a cache entry 370 containing the cache tag 372 and the data 312 to the back 384 of the FIFO queue 380 of the selected circular data file 310. The push back operation includes reading an offset 392 of the back 384 of the FIFO queue 380 of the circular data file 310 from a corresponding tail pointer file 390. If there is not enough room between the offset 392 and an end of the circular data file 310 to store the cache entry 370, the push back operation wraps around to the beginning (i.e., the front 382) of the circular data file 310 by taking the offset 392 to be zero. The push back operation also includes reading a region 310 r of the circular data file 310 that will be overwritten and parsing out a set of cache tags 372 being evicted. The push back operation includes writing the cache entry 370 (the cache tag and data pair) to the circular data file 310 at the offset 392 and writing a new offset 392 to the tail pointer 390 (e.g., the previous offset 392+a size of the cache entry 370).
Referring to FIGS. 3F and 3G, in some implementations, after inserting the cache entry 370 (i.e., the tag and data pair) into the circular data file 310, the insert operation updates the tag map 360 by reading the set 362 corresponding to the tag 372 (e.g., as in the look up operation), inserting an entry 364 (e.g., a pointer) for the tag 372 at the back 362 b of that set 362 (removing an existing entry 364 for the cache tag 372, if it already exists), and dropping the entry 364 at the front 362 f of the FIFO order in the set 362. The new entry 364 may point to the offset 392 of the circular data file 310.
The insert operation may read the tag map sets 362, look for cache tags 372 evicted from the circular data file 310, and remove the corresponding entries 364 from their corresponding sets 362. The insert operation may use the transaction API 400 b so that all writes are applied atomically upon successfully committing the transaction. The transaction commit protocol ensures that the operations are serializable with respect to other concurrent mutations.
The remove operation may receive a cache tag 372 and read the tag map set 362 containing the fingerprint 374 for the cache tag 372. If the cache tag fingerprint 374 is in the set 362, the remove operation removes the corresponding entry 364 from that set 362, adjusting the FIFO ordering to fill the resulting hole. The remove operation may not do anything to the corresponding bytes in the circular data file 310. Instead, those bytes may be left stranded until reclaimed by a subsequent insert operation pushing the front 382 of the FIFO queue 380 past this range of the circular data file 310.
The cache service 350 may check accesses to the underlying files 310 for uninitialized data 312 resulting from a data loss event (e.g., a memory host going down). The granularity at which uninitialized data 312 occurs may be at the set level for the tag map 360, the entire pointer for the circular data file's tail pointer 390, or a single sub-stripe for the circular data file 310.
For handling uninitialized data encountered on any reads executed during the look up operation, the cache service 350 may return a miss to the client 120, since the requested data 312 either no longer exists (if the data loss occurred in the desired region of the circular data file 310) or cannot be readily found (if the data loss occurred in the set 362 that the tag fingerprint 374 should reside in). The client 120 may insert the data 312 back into the cache 150 after reading it from a backing data source.
For data loss encountered while executing the insert operation, the cache service 350 may ensure that the data structures are restored to a valid state during the operation so that future operations work as intended. To do so, the cache service 350 may handle data loss encountered in each stage of the insert operation. When encountering a data loss while reading the tail pointer 390 of the circular file 310, the cache service 350 resets the tail pointer 390 to zero (e.g., essentially starting over the FIFO ordering at the beginning of the circular data file 310). As result, future insert operations remove some elements out of FIFO order within that circular data file 310.
When encountering a data loss while reading the region 310 r of circular data file 310 into which the inserted data 312 will be written, it is not possible to parse out the cache tags 372 that will be evicted, nor is it possible to know where is the next cache entry 370 to be evicted after the uninitialized region 310 r lies (which is necessary to process the next insert operation). In some implementations, the cache service 350 scans forward, looking for a “magic number,” to identify the beginning of a cache entry 370. In other implementations, the cache service 350 sets the tail pointer 390 to the end of the cache entry 370 being written, stops processing overwritten entries 370 for eviction until the circular data file 310 is filled and wraps around to the beginning 382 of the FIFO queue 380 of the circular data file 310 once more. This has the effect of leaving invalid pointers (i.e., set entries 364) in the tag map 360 due to leaving overwritten cache tags 372 in the tag map 360. The cache service 350 addresses this possibility in the look up operation by validating the data 312 read from the circular data files 310, and reporting a miss if the read data 312 does not match the requested tag 372. In this manner, the cache service 350 lazily evicts the invalid set entries 364 (pointers) from the tag map 360.
When encountering a data loss while reading the tag map set 360, in order to push the new tag 372 to the back 384 of the FIFO queue 380 of the circular data file 310, the cache service 310 may treat the set 362 as empty. This strands the cache entries 370 in the circular data file 310 pointed to by the lost set entries 364 (pointers), but the capacity can be reclaimed once the front 382 of the FIFO queue 380 of the circular data file 310 reaches those bytes.
A client 120 may instantiate a cache service 350 with parameters, such as a file path 352 in which the circular data files 310 are created, a cache size (e.g., a total size of the circular data files 310 in bytes), a number of shards (e.g., a number of circular data files to create), and an average block size (e.g., an average size of a cache access in bytes). The average block size may be used to choose the number of tag map entries 364 based on the expected number of tags 372 that the cache 150 has capacity to store (adjusted by a multiple to accommodate conflict misses). A client 120 may reconfigure the cache service 350 as well. For example, the client 120 may adjust the cache size, number of shards, block size, and/or a number of tag map entries 364. The client 120 may reconfigure the cache service 350 during active use by client applications. A client 120 may delete a cache service 350 using its file path 352.
For tuning the cache service 350, the client 120 may consider the following parameters: 1) total cache data size (equal to number of data files times size per data file); 2) number of data files 310; 3) number of entries 364 in the tag map 360; and 4) set associativity of the tag map 360.
Capacity misses can occur in both the tag map 360 or in the data file 310. The latter may occur when the total size (in bytes) of the data files 310 is less than that of the working set 362. The former may occur when the number of tags 372 accessed by the working set 362 is greater than the maximum number of entries 364 in the tag map 360.
Conflict misses may occur in the tag map 360 due to its bounded set associativity and FIFO replacement policy. To mitigate these conflict misses, the client 120 may increase the set associativity. The tradeoff for increasing the set associativity is an increase in bandwidth (since reads may execute on an entire set at a time), increased processing time (to search a set 362 for a tag's fingerprint 374), and increased probability of transactional conflicts (since transactional read and write sets become larger). In some implementations, to mitigate the number of conflict misses in the tag map, the client 120 may increase the number of sets 362 while holding the set associativity constant.
Conflict misses can also occur in the data files 310 due to their FIFO replacement policy, as well as the placement policy of sharding entries 370 to the set 315 of many circular data files 310. Since data 312 may be assigned to data files 310 via consistent hashing, the load may be reasonably well-distributed amongst the circular data files 310. Provided that each data file 310 has enough capacity to store a reasonably large number of entries 370, the effects of these conflict misses may be small.
Increasing the number of data files 310 reduces write contention for the front 382 of each of the FIFO queues 380. A client 120 accessing a cache service 350 with too few data files 310 may see a large number of transactional conflicts when trying to insert values into the cache 150 (i.e., non-ok status on calling transaction commit). On the other hand, if the cache 150 is sized to require very few insertions (or only a few tasks actually perform insertions), then the need for many data files 310 is lessened.
Referring to FIGS. 4A-4C, in some implementations, a client 120 may use a transaction object 420 a to read from or write to the cache 150. In some examples, the transaction 420 a must be active (i.e., started but not committed or in an error state) when passed to a cache service method. No mutations caused by calls to these methods may be visible to other tasks accessing the cache 150 until the client 120 successfully commits the transaction 420 a, at which point the distributed cache system 100 may check the transaction 420 a for serializability with respect to other concurrent transactions 420 a.
The transaction application programming interface (API) 400 b includes a reader class 410 and a transaction class 420. A client 120 may instantiate a reader 410 a inheriting the reader class 410 to execute a read or batches of reads on the memory hosts 110 in a cell 200. Moreover, the client 120 may instantiate a transaction 420 a inheriting the transaction class 420 to execute one or more reads and/or writes. The reads and writes in a transaction 420 a may be to different files 310 in a cell 200, but in some implementations, all reads and writes in a transaction must be to files 310 in the same cell 200. Executed reads may be “snapshot consistent,” meaning that all reads in a transaction 420 a can see a snapshot of the file 310 at a logical instant in time. Writes can be buffered until the client 120 tries to commit the transaction 420 a.
Referring to FIG. 4B, in response to receiving a write memory access request 122 w for a file 310, a transaction 420 a may (acting as a writer) write or modify data 312 of the file 310 (e.g., of chunks 320 n k and/or sub-chunks 326 a-n). After the write operation, the transaction 420 a may compute a checksum 314 of the modified data 312 and associate the checksum 314 with the modified data 312 (e.g., with the chunks 320 n k and/or sub-chunks 326 a-n). In some examples, the transaction 420 a stores the checksum 314 in the sub-chunk metadata 328 for the modified sub-chunk 326 n. The transaction 420 a may execute a hash function, such as a cryptographic hash function, to compute the checksum 314. Moreover, the hash function may be configured for randomization. Each checksum 314 may be a word having at least 64 bits. A network interface controller 116 servicing the remote direct memory access requests 122 on a corresponding memory host 110 may determine the checksum 314 of any data accessed on its memory host 110.
When a client 120 adds a file read request 122 r to the reader 410 a (e.g., via a transaction 420 a), the reader 410 a translates the read request 122 r into a RDMA read network operation and stores a state of the network operation in memory allocated for the reader 410 a. Reads that cross chunk boundaries get translated into multiple RDMA operations.
In some implementations, to translate a file read request 122 r into a RDMA read network operation, the reader 410 a computes a target stripe number from a file offset of the read request 122 r. The reader 410 a may use the stripe number to index into a chunk handle cache. The chunk handle cache returns a network channel to access the corresponding chunk 320 n k and a virtual address and r-key 321 of the chunk 320 n k. The reader 410 a stores the network channel and r-key 321 directly in an operation state of the RDMA read. The reader 410 a uses the virtual address of the chunk 320 n k and the file offset to compute the virtual address within the chunk 320 n k to read. The reader 410 a computes the offset into a memory block supplied by the client 120 (e.g., a receiving memory block for each RDMA read operation). The reader 410 a may then initialize an operation status.
While buffering new reads, the reader 410 a may calculate and store a running sum of the amount of metadata that will be retrieved to complete the read. This allows metadata buffer space to be allocated in one contiguous block during execution, minimizing allocation overhead.
In response to receiving a memory access request 122 from the client 120, the transaction 420 a may retrieve a file descriptor 300 from the curator 210 that maps requested data chunks 320 n k of a file 310 on memory hosts 110 for remote direct memory access of those data chunks 320 n k on the memory hosts 110. The file descriptor 300 may include a client key 321 for each data chunk 320 n k of the file 310. Moreover, each client key 321 allows access to the corresponding data chunk 320 n k on its memory host 110.
Referring to FIG. 4C, in some implementations, the reader 410 a executes a read operation in two phases. In the first phase, the reader 410 a reads the data 312 and associated metadata 324, 328 of a file 310. In the second phase, the reader 410 a validates that the data 312 read in the first phase satisfies data consistency constraints of the reader 410 a. In the first phase, the reader 410 a identifies one or more memory locations corresponding to the data 312 and transmits its RDMA read operations. While iterating through and transmitting RDMA reads, the reader 410 a initializes and transmits RDMA reads to read sub-chunk metadata 328 and to read data 312 needed to compute checksums 314 of the sub-chunks 326 a-n, such as of the first and last sub-chunks 326 a, 326 n in an unaligned file access. After the data 312 and metadata 328 are received, the reader 410 a may check lock-words in the sub-chunk metadata 328 to ensure that the sub-chunks 326 a-n were not locked while the data 312 was being read. If a sub-chunk 326 a-n was locked, the reader 410 a rereads the sub-chunk 326 a-n and its corresponding metadata 328. Once the reader 410 a finds (reads) all of the sub-chunk locks in an unlocked state, the reader 410 a computes the sub-chunk checksums 314 and compares the computed checksums 314 with the checksums 314 read from the sub-chunk metadata 328.
In other words, for detecting read/write conflicts, the reader 410 a, in response to receiving a read memory access request 122 r for data 312 of a file 310 stored in the memory hosts 110 of a cell 200, may compute a first checksum 314 a of the data 312, compare the first checksum 314 a with a second checksum 314 b associated with the data 312 (e.g., stored in the metadata 328 of the corresponding sub-chunk 326 n), and allow a read operation on the data 312 when the first and second checksums 314 a, 314 b match. The reader 410 a may execute a hash function, such as a cryptographic hash function, to compute the checksums 314. The reader 410 a may read the data 312 and metadata 328 associated with the data 312 after receiving the read/write request 122 and before processing the read/write request 122. Moreover, the reader 410 a may determine whether the data 312 was locked while reading the data 312, for example, by evaluating a lock word and/or a version number stored in the metadata 328. The reader 410 a rereads the data 312 and associated metadata 328 when the data 312 was locked while previously reading the data 312.
While checksums are commonly used to guard against hardware error, or even software error, using it to guard against what is actually normal operation poses certain additional requirements. Since a conflict may not be a rare event, the chance of getting a coincidentally-matching checksum can be minimized by having checksum size large enough to provide a relatively small probability of a coincidental match. In some examples, a 64-bit checksum is sufficient, since checking a random bad checksum every nanosecond may produce a false positive less than once every five centuries, which is much less frequent than the rates of other types of system failures. Additionally, a hash function for computing the checksum 314 may produce different numbers for all common modifications of the data. For example, simply adding up all the data would not suffice, since a change that simply re-ordered some of the data would not change the checksum. However, a cryptographic hash functions which, by design, does not allow simple modifications of the data to produce any predictable checksum, may be sufficient.
A sub-chunk checksum 314 may fail a compare for one of three reasons: 1) the data read was corrupted by a concurrent write; 2) the data was corrupted while in transit to the client; or 3) the data stored in the memory host is corrupt. Cases 1 and 2 are transient errors. Transient errors are resolved by retrying the sub-chunk read. Case 3 is a permanent error that may require the client to notify the curator of a corrupt sub-stripe 322 n.
To differentiate between a transient error and a permanent error, the client 120 may re-read the sub-chunk data 312 and the sub-chunk metadata 328. The reader 410 a then checks a sub-chunk lock-word 316 and re-computes and compares the sub-chunk checksum 314. If the checksum error still exists and a sub-chunk version number 318 has changed since the sub-chunk 326 n was initially read, then the checksum compare failure was likely caused by a concurrent write so the reader 410 a retries the sub-chunk read. If the version number 318 has not changed since the sub-chunk 326 n was initially read, then the error is permanent and the reader 410 a notifies the curator 210, and the curator 210 tries to reconstruct the data of the chunk 320 n k. If the curator 210 is unable to reconstruct the chunk data, the curator 210 replaces the old chunk 320 n k with a new uninitialized chunk 320 n k.
Unlike locking, the checksum compare method for detecting read/write conflicts does not actually care if a conflicting write existed, as long as the data is consistent. For example, if the data is being overwritten with identical data, or if a write is preparing to start, but has not actually begun, or has just finished, the locking method will cause the read to fail unnecessarily, while the checksum compare will allow the read to succeed. Since the time between locking and unlocking may be much greater than the duration of an actual write, this can be a significant improvement.
The reader 410 a does not know which version 318 of the data 312 it has read, and it may not matter. If it is advantageous to have the read obtain a version number 318, this may be done without an additional round-trip latency penalty if the version number 318 itself is covered by the checksum 314. Although computing checksums 314 may incur a nontrivial penalty in processor time, both for the reader 410 a and the writer 420 a, a checksum 314 may be necessary anyway to guard against hardware errors, depending on the implementation.
Sub-chunk locks may become stuck due to a client 120 trying to execute a transaction 420 a but crashing during a commit protocol of the transaction 420 a. A reader 410 a can detect a stuck lock by re-reading the sub-chunk lock-word 316 and version number 318. If a sub-chunk lock-word 316 and version number 318 do not change during some time out period, then the sub-chunk lock is likely stuck. When the reader 410 a detects a stuck lock, it notifies the curator 210 of the stuck lock and the curator 210 recovers the sub-stripe 322 n and resets the stuck lock.
Referring also to FIGS. 4A and 4D, in some implementations, after the reader 410 a validates each sub-chunk lock-word 316 and/or checksum 314, the reader 410 a may proceed to the second phase of executing the read operation (i.e., the validation phase). To validate the values, the reader 410 a rereads sub-chunk metadata 328 and rechecks if the sub-chunk lock-words 316 are unlocked and the sub-chunk version numbers 318 have not changed since the version numbers 318 were initially read during the first phase of the read operation. In other words, the reader 410 a may read an initial version number 318 a and an initial lock value 316 a associated with each data chunk 320 n k of a read set 402 of the transaction 420 a. After reading the data 312, the reader 410 a reads a final version number 318 b and a final lock value 316 b associated with each data chunk 320 n k of the read set 402 and determines the read data as valid when the initial version number 318 a matches the final version number 318 b and the initial lock value 316 a matches the final lock value 316 b.
If the reader 410 a is associated with a transaction 420 a, the reader 410 a may reread the metadata 328 associated with all sub-chunks 326 n read by the transaction 420 a. If a single sub-chunk version number 318 mis-compares, the reader 410 a returns an error. If all sub-chunk version numbers 318 are the same, the reader 410 a discards the prefix and suffix of the reader memory block in order to trim extraneous data read to compute the checksum 314 of the first and last sub-chunks 326 a, 326 n in the read. The reader 410 a may set a status to OK and returns to the client 120.
If the reader 410 a encounters an error on a network channel while reading data or metadata of a chunk, the reader 410 a may select a different chunk 320 n k from the chunk handle cache and notifies the curator 210 of a bad memory host. If no other good chunks 320 n k exist from which the reader 410 a can read, the reader 410 a may wait to receive a response to the error notification it sent to the curator 210. The response from the curator 210 may contain an updated file descriptor 300 that contains a new good chunk 320 n k to read from.
In some implementations, the transaction class 420 uses validation sets 422 to track which sub-stripes 322 n have been read by the transaction 420 a. Each read of a transaction 420 a adds the version numbers 318 of all sub-stripes 322 n read to a validation set 422 of the transaction 420 a. The transaction 420 a may validate the validation set 422 in two cases: 1) as part of the commit protocol and 2) the validation phase of reads of a transaction 420 a. A transaction 420 a may fail to commit if the commit protocol finds that any sub-stripe version number 318 differs from the number recorded in the validation set 422. Validation of the full validation set 422 before data is returned to the client 120 allows early detection (e.g., before the commit phase) of a doomed transaction 420 a. This validation also prevents the client 120 from getting an inconsistent view of file data.
A transaction 420 a may provide a synchronous, serializable read operation (e.g., using a reader). In some examples, a reader 410 a is instantiated and associated with the transaction 420 a. Read results of the reader 410 a return the latest committed data. As such, uncommitted writes of the same transaction 420 a are not seen by a read of that transaction 420 a.
A transaction 420 a may buffer data for a later transaction commit. The transaction class 420 translates a buffer write request into one or more ‘prepare write’ network operations. One network operation is needed for each stripe 320 n touched by the write operation. Processing a buffer write request may involve preparing ‘sub-stripe lock’ network operations. One lock operation is needed for each sub-stripe 322 n touched by the requested write. These operations are buffered for transmission during the transaction commit. The transaction 420 a may translate buffer write requests into network operations and execute identify or coalesce writes that affect the same region of a file 310. The transaction 420 a may apply write operations in the same order by the memory hosts 110 for all chunks 320 n k to ensure that all replicas are consistent.
The transaction 420 a may provide a commit operation that results in all reads and writes in the transaction 420 a being schedulable as a single atomic, serializable operation. In some implementations, the transaction commit protocol proceeds through a lock phase, a validate phase, a write phase, and an unlock phase. During the lock phase, the sub-stripe lock network operations which were created in response to buffer write requests are sent. Each sub-stripe lock operation executes an atomic compare-and-swap operation on the lock-word in all replicas 320 nk. If the contents of the lock-word match the specified compare data (e.g., a client identifier), the lock-word is written with the specified swap data, and the previous contents of the word are returned. If the client 120 succeeds in writing its unique client ID into the metadata lock-word, it has successfully taken the lock. If the transaction 420 a fails to take the lock for any sub-stripe 322 n in the write set, the commit fails and is aborted. The commit protocol proceeds to the validate phase once all sub-stripe locks are held.
During the validate phase, the transaction 420 a may read the version number 318 out of the metadata 324 for all sub-stripes 322 n referenced in the validation set and comparing the version numbers 318 to the version numbers 318 recorded in the validation set. If a version number 318 does not match, the sub-stripe 322 n was written by another transaction 420 a after it was read by this transaction 420 a, so the transaction 420 a fails. In this case, the reader 410 a releases the locks it holds and returns a transaction conflict error to the client 120. Once all version numbers 318 in the validation set have been validated, the client 120 writes the buffered write data of the transaction 420 a to each replica 320 n k and updates the metadata 324 associated with each sub-stripe 322 n written by the transaction 420 a, during the write phase. Updating metadata 324 of a sub-stripe 322 n may include computing and writing a new check- word 314, 316 and incrementing the version number 318 of the sub-stripe 322 n. Once all data 312 and metadata 324, 328 has been updated, the transaction 420 a releases the locks that it holds, during the unlock phase.
File transaction access may provide exclusive read/write access to the state of a file descriptor 300. Updates to the file state may be applied at the end of a transaction 420 a and are atomic. File transaction access can be used for operations such as creating, finalizing, and deleting a file 310. These operations may require the curator 210 to communicate with other components such as memory hosts and thus a file transaction access may last for several seconds or more. While active, the file transaction access blocks any other operations that need to modify the state of the file descriptor 300. Read access may not be blocked.
To reduce contention, stripe transaction access may provide relatively finer grain synchronization for operations that only need to modify the state of a single stripe 320 n with the file descriptor 300. This mode can be used for stripe operations such as opening, closing, rebalancing, and recovering. There can be many concurrent stripe transactions for different stripes 320 n within a file 310, but stripe transactions and file transactions are mutually exclusive. Within a stripe transaction, the curator 210 may examine the state of a stripe 320 n and various fields of the file descriptor 300 that remain immutable for the duration of the transaction 420 a, such as the file encoding and instance identifier. The stripe transaction access does not provide access to fields that can change underfoot, such as the state of other stripes 320 n. Operations may hold only one active transaction 420 a at a time to avoid deadlock. Moreover, transactions 420 a may only atomically commit on a single file 310.
FIG. 5 provides an exemplary arrangement 500 of operations for a method of controlling access in a distributed storage system 100. The method includes receiving 502 an access control list 260 that has at least one associated client 120 and at least one at least one associated data chunk 320 n k, receiving 504 a connection request 254 from a client 120 to access a data chunk 320 n k stored in non-transitory memory 114 of a memory host 110, and establishing 506 a remote direct memory access capable connection 250 with the client 120 when both the client 120 and the requested data chunk 320 n k are associated with the same access control list 260.
In some implementations, the method includes associating 508 the established connection 250 with a protection domain 270 having an associated memory region 114 n storing the data chunk 320 n k. The connection 250 is capable of accessing only memory regions 114 a-n associated with its protection domain 270. Moreover, the protection domain 270 is capable of being associated with one or more connections 250. The method may include allocating memory 114 for the data chunk 320 n k (e.g., via the curator 210) and associating the allocated memory 114 with the protection domain 270.
The method may include executing a connection handshake with the client 120 to establish the remote direct memory access capable connection 250. In some examples, the method includes evaluating an identity of the client 120, such as by executing a client authentication routine. If a received remote direct memory access request 122 includes an address for unregistered memory 114, the method may include tearing down the connection 250.
The method may include registering remote direct memory accessible regions 114 a-n of memory 114 with a network interface controller 116 of the memory host 110. The remote direct memory accessible memory regions 114 a-n may be registered with a permission of read-only or read/write.
In some implementations, the method includes allocating memory 114 for the data chunk 320 n k (e.g., via the curator 210) and associating the data chunk 320 n k with the access control list 260. The method may include assigning an access permission for each client or each data chunk 320 n k associated with the access control list 260.
In response to receiving a memory access request 122 from the client 120, the method may include returning a file descriptor 300 that maps data chunks 320 n k of the file 310 on memory hosts 110 for remote direct memory access of the data chunks 320 n k on the memory hosts 110. The file descriptor 300 may include a client key 321 for each data chunk 320 n k of the file 310. Moreover, each client key 321 allows access to the corresponding data chunk 320 n k on its memory host 110.
FIG. 6 provides an exemplary flow chart 600 illustrating a method of accessing data stored on a distributed storage system 100. In some implementations, the method includes instantiating a memory access request 122 for a data chunk 320 n k stored in non-transitory memory 114 of a memory host 110 of the distributed storage system 100 and searching a connection cache 252 for an open remote direct memory access capable connection 250 to the memory host 110 that is associated with a protection domain 270 of the memory 114 storing the requested data chunk 320 n k. If the connection cache 252 fails to contain the open connection 250, the method includes sending a connection request 254 to the memory host 110. The memory host 110 establishes the remote direct memory access capable connection 250 when both a client 120 instantiating the connection request 254 and the requested data chunk 320 n k are associated with the same access control list 260. The connection request 254 may include the access control list 260. The method includes sending the memory access request 122 to the memory host 110 over the open connection 250 and storing the open connection 250 in the connection cache 252. The method may include executing a connection handshake with a network interface controller 116 of the memory host 110 to establish the remote direct memory access capable connection 250.
The method may include receiving a file descriptor 300 mapping data chunk 320 n k to the memory hosts 110. The file descriptor 300 may include a client key 321 allowing access to the corresponding data chunk 320 n k on its memory host 110. The method may include sending a memory access request 122 for multiple data chunks 320 n k stored in the memory 110 of the memory host 110, where two or more of the data chunks 320 n k are associated with different access control lists 260.
FIG. 7 provides an exemplary arrangement 700 of operations for a method of providing access to data stored on a distributed storage system 100. The method includes electronically receiving 702 a memory access request 122 from a client 120 and returning a file descriptor 300 mapping data stripes 320 n and data stripe replications 320 n k of a file 310 on memory hosts 110 for remote direct memory access (RDMA) of the file 310 on the memory hosts 110.
In some implementations, the method includes accessing 706 a file map 214 mapping files 310 to file descriptors 300 to return the file descriptor 300 in response to the memory access request 122. The method may include returning 708 location information of data 312 on the memory hosts 110 in response to the client memory access request 122. The method may include returning a key to allow access to data on the memory hosts 110 in response to the client memory access request 122. In some examples, the method includes allocating storage of a data stripe 320 n on the memory hosts 110. The method may include dividing the file 310 into data stripes 320 n and replicating each data stripe 320 n into multiple storage locations of the memory hosts 110.
In some implementations, the method includes providing at least one of a file state attribute providing a state of a file, a data chunks attribute providing a number of stripe replicas 320 n k per stripe 320 n, a stripe length attribute providing a number of bytes per stripe 320 n, and a sub-stripe length attribute providing a number of bytes per sub-stripe 322 n in the file descriptor 300. The method may include providing 710 in the file descriptor 300 an array of stripe protocol buffers 325, each describing a data stripe replica 320 n k within a data stripe 320 n.
Servicing storage requests 122 in hardware provides a number of advantages, such as having relatively simple storage requests (e.g., read, write). Implementing such functionality in an application specific integrated circuit (ASIC) can be much more efficient than implementing the functionality in software running on a general-purpose processor. This efficiency improvement means storage requests 122 can be serviced in less time and occupy fewer circuits when compared to implementing the same functionality in software running on a general-purpose processor. In turn, this improvement means a distributed storage system 100 can achieve lower latency and higher throughput without increasing the cost of the system.
Servicing storage requests 122 in the network interface hardware (e.g., NIC) decouples processor resources 112 and storage resources 114. A client 120 can access storage resources 114 on a memory host 110 without available processor resources 112. This allows system builders and administrators to operate a distributed storage system 100 with high processor utilization, with low and predictable latencies, and without stranding storage resources. In some implementations, the distributed storage system 100 can provide an average read latency of less than 10 microseconds, an average read throughput of greater than 2 million operations per second per client, and average write latency of less than 50 microseconds, and/or an average write throughput of greater than 500 thousand operations per second per client.
FIG. 8 provides an exemplary flow chart 800 illustrating a method of managing read/write requests 122 in a non-transitory data storage system 100. The method includes receiving a read/write request 122 for data 312 stored in the data storage system 100 and processing the read/write request 122 on at least one computing processor 112, 202. For a read request 122 r, the method includes computing a first checksum 314 a (e.g., a word having at least 64 bits) of the data 312 (e.g., a sub-chunk 326 n), comparing the first checksum 314 a with a second checksum 314 b associated with the data 312, 326 n, and allowing a read operation of the read/write request 122 r on the data 312, 326 n when the first and second checksums 314, 314 b match. For a write request 122 w, the method includes allowing a write operation of the read/write request 122 w on the data 312, 326 n, computing a third checksum 314 c of the modified data 312, 326 n, and associating the third checksum 314 c with the modified data 312, 326 n.
In some implementations, the method includes executing a hash function, such as a cryptographic hash function, to compute at least one of the checksums 314 a-c. The method may include associating metadata 324, 328 with the data 312, 326 n (e.g., the sub-chunk 326 n), where the metadata 324, 328 includes a checksum word containing the checksum 314 associated with the data 312, 326 n. In some examples, the method includes reading the data 312, 326 n and metadata 328 associated with the data 312, 326 n after receiving the read/write request 122 and before processing the read/write request 122. The method may include determining whether the data 312, 326 n was locked while reading the data 312, 326 n and/or evaluating a lock word and a version number stored in the metadata 328. When the data 312, 326 n was locked while previously reading the data 312, 326 n, the method may include rereading the data 312, 326 n and associated metadata 328.
The method may include identifying one or more memory locations 114 a-n corresponding to the data 312, 326 n and transmitting remote direct memory access requests 122 to each identified memory location 114 a-n. Moreover, the method may include receiving a file descriptor 300 of a file 310 containing the data 312, 326 n. The file descriptor 300 maps data stripes 320 a-n and data stripe replications 320 n 1-k of the file 310 on memory hosts 110 for remote direct memory access. The method may include accessing a file map 214 mapping files 310 to file descriptors 300 to return the file descriptor 300. In some examples, the method includes receiving a key 321 (e.g., in the file descriptor 300) allowing access to the data 312, 326 n on the memory hosts 110.
FIGS. 9A and 9B provide exemplary arrangements 900 a, 900 b of operations for a method executing a transaction 420 a in a distributed storage system 100. With additional reference to FIG. 4D, for data chunks 320 n k of a read set 402 of the transaction 420 a, the method includes reading 902 data 312 of the data chunks 320 n k of the read set 402 through remote direct memory access and determining 904 a validity of the read data 312 by evaluating a lock 316 and a version 318 of each data chunk 320 n k of the read set 402. For data chunks 320 n k of a write set 404 of the transaction 420 a, the method includes setting 906 locks 316 on the data chunks 320 n k of the write set 404, writing 908 data 312 to the locked data chunks 320 n k through remote direct memory access, releasing 910 the locks 316 of the locked data chunks 320 n k, and incrementing 912 a version number 318 of each released data chunk 320 n k.
In some implementations, the method includes aborting the transaction 420 a when at least one data chunk 320 n k of the write set fails to receive a lock or when the read data 312 is invalid. For any data chunks 320 n k having an unreleased lock 316, the method may include resetting (e.g., via the curator 210) those data chunks 320 n k to an uninitialized state and releasing their locks 316. The method may include rereading the data 312 of the data chunks 320 n k of the read set 402 when the previous read is invalid. In some examples, the method includes reading existing data 312 of the data chunks 320 n k of the write set 404 before writing new data 312 to those data chunks 320 n k, and writing the existing data 312 of the data chunks 320 n k of the write set 404 to a durable intent log 406 to allow later reconstruction of the data 312 if the write operation fails, so as to provide a durable transaction 420 a.
The method may include aborting the transaction 420 a when at least one data chunk 320 n k of the write set 404 fails to receive a lock 316 or when the read data 312 is invalid. For any data chunks 320 n k having an unreleased lock 316, the method may include marking the data 312 as uninitialized and releasing the lock 316 for non-durable transactions 420 a or retrieving their existing data 312 stored in the durable intent log 406, writing the retrieved data 312 to the corresponding data chunks 320 n k to reconstruct the data 312, and the releasing the locks 316 of those data chunks 320 n k to provide a durable transaction 420 a.
The method may include reading an initial version number 318 a and an initial lock value 316 a associated with each data chunk 320 n k of the read set 402. After reading the data 312, the method includes reading a final version number 318 b and a final lock value 316 b associated with each data chunk 320 n k of the read set 402 and determining the read data as valid when the initial version number 318 a matches the final version number 318 b and the initial lock value 316 a matches the final lock value 316 b. Setting locks on the data chunks 320 n k of the write set 404 may include, for each data chunk 320 n k, retrieving a lock word 316 associated with the data chunk 320 n k, comparing data of the lock word 316 with compare data, and writing swap data (e.g., a unique client identifier) to the lock word 316 when the lock word data and the compare data match. The method may include accessing metadata 324, 328 associated with each data chunk 320 n k that includes a version number 318 and a lock word 316 containing a lock value.
Various implementations of the systems and techniques described here can be realized in digital electronic circuitry, integrated circuitry, specially designed ASICs (application specific integrated circuits), computer hardware, firmware, software, and/or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
These computer programs (also known as programs, software, software applications or code) include machine instructions for a programmable processor, and can be implemented in a high-level procedural and/or object-oriented programming language, and/or in assembly/machine language. As used herein, the terms “machine-readable medium” and “computer-readable medium” refer to any computer program product, apparatus and/or device (e.g., magnetic discs, optical disks, memory, Programmable Logic Devices (PLDs)) used to provide machine instructions and/or data to a programmable processor, including a machine-readable medium that receives machine instructions as a machine-readable signal. The term “machine-readable signal” refers to any signal used to provide machine instructions and/or data to a programmable processor.
Implementations of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Moreover, subject matter described in this specification can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions encoded on a computer readable medium for execution by, or to control the operation of, data processing apparatus. The computer readable medium can be a machine-readable storage device, a machine-readable storage substrate, a memory device, a composition of matter effecting a machine-readable propagated signal, or a combination of one or more of them. The terms “data processing apparatus”, “computing device” and “computing processor” encompass all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them. A propagated signal is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus.
A computer program (also known as an application, program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio player, a Global Positioning System (GPS) receiver, to name just a few. Computer readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, one or more aspects of the disclosure can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube), LCD (liquid crystal display) monitor, or touch screen for displaying information to the user and optionally a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's client device in response to requests received from the web browser.
One or more aspects of the disclosure can be implemented in a computing system that includes a backend component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a frontend component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such backend, middleware, or frontend components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).
The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some implementations, a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) can be received from the client device at the server.
While this specification contains many specifics, these should not be construed as limitations on the scope of the disclosure or of what may be claimed, but rather as descriptions of features specific to particular implementations of the disclosure. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely, various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable sub-combination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a sub-combination or variation of a sub-combination.
Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multi-tasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
A number of implementations have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the disclosure. Accordingly, other implementations are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results.