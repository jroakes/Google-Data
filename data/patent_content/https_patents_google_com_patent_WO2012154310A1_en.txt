WO2012154310A1 - Development architecture for cloud-based applications - Google Patents
Development architecture for cloud-based applications Download PDFInfo
- Publication number
- WO2012154310A1 WO2012154310A1 PCT/US2012/030340 US2012030340W WO2012154310A1 WO 2012154310 A1 WO2012154310 A1 WO 2012154310A1 US 2012030340 W US2012030340 W US 2012030340W WO 2012154310 A1 WO2012154310 A1 WO 2012154310A1
- Authority
- WO
- WIPO (PCT)
- Prior art keywords
- application
- script
- widget
- model
- widgets
- Prior art date
Links
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/30—Creation or generation of source code
- G06F8/38—Creation or generation of source code for implementing user interfaces
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/21—Design, administration or maintenance of databases
- G06F16/211—Schema design and management
Definitions
- Cloud-based computing generally refers to networked computer architectures in which application execution and storage are divided, to some extent, between client and server devices.
- a cloud-based application may store copies of data and/or executable program logic at remote server devices, while allowing client devices to download at least some of this data and program logic as needed for execution at the client device.
- An advantage of this approach is that the downloaded data and program logic can be tailored to the capabilities of the specific client device (e.g., a personal computer, tablet, or mobile phone) accessing the cloud based application.
- An example class of application that can exploit the benefits of cloud-based computing is data-driven web-based services. Included in this class of applications are, for example, email, office productivity suites, blogs, online stores, games, as well as other types of networked applications.
- email office productivity suites
- blogs online stores
- games as well as other types of networked applications.
- development of these data-driven cloud-based applications often requires complex and time consuming programming and database design.
- RAD tools are typically integrated development environments that assist a designer (e.g., a software architect and/or a programmer) in developing software applications by generating program logic based on high-level descriptions of what the designer wants to achieve.
- a designer e.g., a software architect and/or a programmer
- GUI graphical user interface
- the same software architecture may be used for both development and execution of cloud-based applications in order to minimize any discrepancies between the interfaces and functions as developed by their designer and those provided to the end-user application executing in the cloud.
- the software architecture may be divided into components that are placed in a client software platform (e.g., a web browser) and those that are placed in a cloud-based server device.
- Designer interactions with the software architecture may occur via a client- based execution platform that may include a development environment GUI.
- This development environment GUI allows cloud-based applications to be developed in a what- you-see-is-what-you-get (WYSIWYG) fashion.
- Each cloud-based application may be represented as a "stack" of related pages.
- Each page may contain metadata (e.g., one or more names, keywords, identifiers, etc.), one or more widgets (each of which may be associated with a size, a spatial location, a color, a font, an image, an identifier, an action, and/or other characteristics), and a set of scripts.
- metadata e.g., one or more names, keywords, identifiers, etc.
- widgets each of which may be associated with a size, a spatial location, a color, a font, an image, an identifier, an action, and/or other characteristics
- the client platform may represent this information, as well as any other information associated with each page, in an abstraction called the application model.
- Data associated with the cloud-based application may be stored in a database model.
- the database model may consist of a database schema including at least one database table per page, with each unit of page metadata or widget associated with an automatically typed field in the database table.
- the database model can also be extended by the scripts.
- the designer can create and update the database substantially in real-time by using the development environment GUI to modify the cloud-based application. Further, the designer need not be aware of the database or its structure during cloud-based application development.
- the designer may use a design mode of the execution platform.
- the execution platform may periodically or from time to time contact the server device to update representations of the application model and/or the data model that are stored at the server device.
- the server device may
- a cloud-based application's user interface design and program logic (as represented in the application model) and database schema and content (as represented in the database model) may be stored on the server device.
- the server device may deliver copies of at least part of these models to the execution platform on the client device for interpretation and/or execution.
- the designer may switch from the design mode to a preview mode. Unlike traditional software development tools, the designer may not be required to first compile, link, and distribute the cloud-based application before previewing its operation in the preview mode. Since the application model and data model are automatically stored on the server device, the designer can switch back and forth from design mode to preview mode while the cloud-based application is running. Any changes made in design mode may be reflected in near real-time in the previewed cloud-based application.
- the designer can further publish the cloud-based application to a public or private Uniform Resource Locator (URL) so that users can access the published cloud-based application in run mode.
- URL Uniform Resource Locator
- changes made in design mode may be subsequently reflected in near real-time in instances of the cloud-based application that are in run mode.
- a computing device may display, via a graphical development environment, a user interface of an application.
- the graphical development environment may have access to an application model and a data model.
- the application model may include program logic of the application and a representation of the user interface of the application, while the data model may include a database schema for storing data used by the application.
- the computing device may receive a change to the application.
- the computing device may apply modifications to at least one of the application model and the data model to incorporate the change.
- the computing device may automatically transmit a representation of at least some of the modifications to a server device for storage.
- the cloud-based application's designer- created application GUI may form the basis for an automatically created database schema for the cloud-based application.
- a computing device may display at least part of the application GUI.
- the application GUI may include a page, and the page may include a widget.
- the computing device may create a database schema, based on the application GUI, such that the database schema includes data defining a relationship between the page and the widget.
- the database schema may include a database table for the page, and the database table may include a field for the widget.
- a computing device may receive a cloud-based application.
- the cloud-based application may include a stack with one or more pages for a user interface for the application and a database.
- the computing device may execute the application by locating a compiled script for the application based on a global identifier assigned to the compiled script.
- the global identifier may include an application identifier for specifically identifying the application in a plurality of applications and an object identifier for specifically identifying an object of a computational model.
- the computational model may be either the stack or the database.
- the compiled script may include a scripting language instruction for the application, and may inject the compiled script into the application. Then, the injected script may be executed as part of the application to perform at least one transaction of the computational model.
- a script containing scripting language instructions may be created via a computing device using a guided script editor.
- the guided script editor may include a statement control, a variable control, and a script area.
- the guided script editor may be configured to generate one or more conversational statements of a non- programming language that are equivalent to the generated scripting language instruction.
- the generated scripting language instruction may be added to the script of scripting language instructions.
- the script of scripting language instructions, including the added scripting language instruction may be stored via the computing device.
- an editor window may be displayed via a computing device.
- the editor window may include an editing area and an assistance button.
- the editor window may be configured to allow for editing a script including one or more scripting language instructions.
- the computing device may determine that the assistance button has been selected by the designer to request assistance with a particular scripting- language instruction, and an assistance display may be displayed as a result.
- the assistance display may be related to the particular scripting language instruction.
- Input may be received at the computing device via the assistance display and the particular scripting language instruction may be generated in response to the received input.
- the particular scripting language instruction may be added to the script, and the script may be stored.
- a graphical development environment may depict a representation of one or more pages and a plurality of widgets, each of the widgets including one or more graphical display sub-components (e.g., visual characteristics) and a computer-executable functional characteristic.
- a compound widget Responsive to receiving a first instruction, a compound widget may be created from a plurality of selected widgets, and may incorporate one or more graphical display sub-components of each selected widget and one or more functional characteristics of each selected widget. Responsive to receiving a second instruction, the compound widget may be instantiated a plurality of times in the
- Each of the instantiated compound widgets includes at least one characteristic that is shared across all instances of the compound widget such that an update to one instantiation of the compound widget updates all instantiations of the compound widget.
- Each of the instantiated compound widgets may also include at least one characteristic that is specific to a particular instance of the compound widget.
- a graphical development environment may depict a representation of one or more pages and a plurality of widgets, each widget including one or more graphical display sub-components and a computer executable functional characteristic.
- Layout tools may be provided to aid a designer in laying out and defining inter-relationships of widgets (including compound widgets) and groups of widgets for each page.
- a most significant sub-component border determination may be made for each widget.
- a grouping relationship determined between each of a plurality of the widgets may be aligned based on the determined most significant sub-component border of each widget in the group.
- a first set of connections is identified.
- This first set may include (i) connections between pairs of widgets that do not belong to a group of widgets, (ii) connections between groups of widgets and widgets that do not belong to a group of widgets, and (iii) connections between groups of widgets.
- Each connection in the first set is then assigned a default connection weight.
- Each connection that attaches to a group of widgets, as opposed to a single widget, has its relative assigned weight raised. Then, a multiplier is applied to each connection in the first set relative to a distance that the connection travels.
- each connection in the second set is stored as either one of (i) a fixed distance connection that does not vary based on a size of the screen or window on which the representation of the page is rendered or (ii) a proportional distance connection that does vary based on a size of the screen or window on which the representation of the page is rendered.
- Figure 1 depicts a distributed computing architecture in accordance with an example embodiment.
- Figure 2A is a block diagram of a computing device in accordance with an example embodiment.
- Figure 2B depicts a cloud-based server system in accordance with an example embodiment.
- Figure 3 is a block diagram of a distributed software architecture, in accordance with an example embodiment.
- Figure 4 depicts a development environment in accordance with an example embodiment.
- Figure 5 is a ladder diagram in accordance with an example embodiment.
- Figure 6 is a ladder diagram in accordance with another example embodiment.
- Figure 7 is a flow chart in accordance with an example embodiment.
- Figure 8 depicts a development environment in accordance with an example embodiment.
- Figure 9 is flow chart in accordance with an example embodiment.
- Figure 10 depicts a script compilation in accordance with an example embodiment.
- Figure 11 is a ladder diagram in accordance with an example embodiment.
- Figure 12 is flow chart in accordance with an example embodiment.
- Figure 13 is flow chart in accordance with another example embodiment.
- Figure 14 depicts a window in accordance with an example embodiment.
- Figure 15A depicts a dialog in accordance with an example embodiment.
- Figure 15B depicts a dialog in accordance with another example embodiment.
- Figure 15C depicts a window for an enhanced standard editor in accordance with another example embodiment.
- Figure 16A depicts a window for an enhanced standard editor in accordance with another embodiment.
- Figure 16B depicts a dialog in accordance with another example embodiment.
- Figure 16C depicts a window in accordance with another example embodiment.
- Figure 17A depicts a guided script editor in accordance with an example embodiment.
- Figure 17B depicts a dialog in accordance with another example embodiment.
- Figure 17C depicts a guided script editor in accordance with another example embodiment.
- Figure 17D depicts a guided script editor in accordance with another example embodiment.
- Figure 17E depicts a guided script editor in accordance with another example embodiment.
- Figure 17F depicts a dialog in accordance with another example embodiment.
- Figure 18 is a flow chart in accordance with an example embodiment.
- Figure 19 is a flow chart in accordance with another example embodiment.
- Figure 20 depicts a development environment in accordance with an example embodiment.
- Figure 21 depicts an example option dialog box in accordance with an example embodiment.
- Figure 22 depicts an example completed option dialog box in accordance with an example embodiment.
- Figure 23 depicts an example development environment in which a compound widget has been instantiated twice, in accordance with an example embodiment.
- Figure 24 is a flow chart in accordance with an example embodiment.
- Figure 25 depicts a development environment in accordance with an example embodiment.
- Figure 26 depicts a development environment in accordance with another example embodiment.
- Figure 27 depicts a development environment in accordance with another example embodiment.
- Figure 28 is a flow chart in accordance with an example embodiment.
- Figure 29 is a flow chart in accordance with another example embodiment.
- Figure 30 depicts a development environment in accordance with an example embodiment.
- a distributed computing system may allow two or more distributed or co- located computing devices to coordinate their activities in order to achieve a particular goal or result. This coordination may occur via a network (e.g., a local area network, a wide area network, and/or the Internet) or some other form of communicative coupling.
- a network e.g., a local area network, a wide area network, and/or the Internet
- networking computing devices e.g., personal computers (PCs), laptops, tablet devices, and cell phones
- cloud-based computing is a term that can refer to distributed computing architectures in which the data and program logic for a cloud-based application are shared between one or more client devices and server devices on a near real-time basis. Parts of this data and program logic may be dynamically delivered, as needed or otherwise, to various clients accessing the cloud-based application. Details of the architecture may be transparent to the users of client devices. Thus, a PC user accessing a cloud-based application may not be aware that the PC downloads program logic and/or data from the server devices, or that the PC offloads processing or storage functions to the server devices.
- the cloud-based application may execute primarily or entirely in a web browser already installed on the client device.
- the web browser may be a standard web browser that is capable of executing program logic consistent with one or more scripting and/or markup languages such as the JAVASCRIPT® scripting language, the HyperText Markup Language (HTML) version 3, 4, and/or 5, the extended Markup Language (XML), and so on.
- the web browser could be capable of supporting other scripting languages and/or markup languages.
- a cloud-based application can be illustrated in the following example of a cloud-based email application.
- a user with an email account at a service provider may be able to log on to that email account from a PC web browser.
- the web browser can contact a cloud-based server device.
- This server device stores the user's email spool (e.g., the user's email messages, including new messages and old messages stored for potential later use).
- the server device may also store the user's email settings, such as the email application's configuration options that the user has selected.
- the web browser may download, from the server device, at least some of the messages in the user's email spool.
- the web browser may also download, from the server device, a portion of the email application's program logic and settings so that the web browser can display the email messages according to user-selected settings.
- the web browser in accordance with user-selected settings, may display the user's email folders on the left side column of the browser's window, and display a listing of the email messages in main portion of the browser's window.
- the web browser may execute (or dynamically download and then execute) program logic to display the selected email message.
- the web browser may execute program logic to download this message from the server device. If the user composes and sends an email message, the web browser may transmit a copy of the message to the server device, and the server device may, in turn, transmit the message towards its destination. The web browser may also store a copy of the message, locally or remotely, in a folder for sent mail.
- the same user may also access the email application from his or her cell phone.
- the cell phone may also download, from the server device, application program logic and data in order to facilitate this access.
- cell phones usually have smaller screens than PCs, and usually access networks using lower-capacity wireless links than PCs (e.g., compared to wired links).
- the server device may determine that a cell phone is communicating with the server device, and consequently may transmit a different version of the program logic and data to the cell phone than was transmitted to the PC.
- This version of the program logic may use fewer communication resources (e.g., less network capacity) between the cell phone and the server device and/or have a simpler user interface designed for the cell phone's smaller screen and user interface.
- An advantage of cloud-based applications is that copies of the program logic and data are stored at the server device (e.g., in the cloud).
- the user can switch between client devices without having to manually download and configure a client application at each client device from which the user accesses the cloud-based application.
- the user may be able to access the email application from any device with a web browser.
- the user's client device is lost, stolen, or becomes unusable, the user's email is still stored at the server device, and can be accessed from any other supported client device.
- the user may be able to use any PC- based operating system (e.g., MICROSOFT WINDOWS®, LINUX®, or MAC OS®), any mobile operating system (e.g., IPHONE® IOS, ANDROID®, WINDOWS MOBILE®, or BLACKBERRY® OS), and/or any other computing platform now known or developed in the future to access cloud-based applications without fear of losing their data.
- PC- based operating system e.g., MICROSOFT WINDOWS®, LINUX®, or MAC OS®
- any mobile operating system e.g., IPHONE® IOS, ANDROID®, WINDOWS MOBILE®, or BLACKBERRY® OS
- any other computing platform now known or developed in the future to access cloud-based applications without fear of losing their data.
- the program logic that executes on the client device may enable offline access to the cloud-based application.
- the user could download the email application's program logic and data, and then disconnect from the network(s) connecting the client device to the server device (e.g., the Internet and/or any other intervening network(s) used to access the server device). Then the user could use the email application for some time while in the offline mode.
- Offline mode use may allow, for example, filing of email messages in folders, replying to email messages, composing new email messages, and deleting email messages.
- the email application program logic on the client device may synchronize the changes with the server device.
- the client device may inform the server device of the filed, replied to, composed, and/or deleted email messages.
- the server device may update its copy of this data accordingly.
- the email application described above is just one example of a cloud-based application.
- Other types of cloud-based applications may include office productivity suites, blogs, online stores, and/or multimedia applications.
- various types of functionality included in these applications, or used to facilitate the design and execution of these applications may also be distributed across multiple software modules and/or hardware platforms.
- Figure 1 depicts a distributed computing architecture in accordance with an example embodiment.
- a server device 101 is configured to communicate, via a network
- the server device 101 also has access to an application model datastore 102 and a data model datastore 103.
- the server device 101 may communicate with the application model datastore 102 and/or data model datastore 103 via a network 106, as shown.
- the network 106 may correspond to a local area network, a wide area network, a corporate intranet, the public Internet, combinations thereof, or any other type of network(s) configured to provide communication between networked computing devices.
- the application model datastore 102 and/or data model datastore 103 may be co-located with the server device 101, or may be accessible via a network separate from the network 106.
- FIG. 1 Although Figure 1 only shows three client devices, cloud-based server devices may serve hundreds or thousands of client devices.
- the client devices 104a, 104b, and 104c may be any sort of computing device, such as an ordinary laptop computer, desktop computer, network terminal, wireless communication device (e.g., a cell phone or smart phone), and so on.
- the client devices 104a, 104b, and 104c may be dedicated to the design and use of cloud-based applications.
- the client devices 104a, 104b, and 104c may be general purpose computers that are not necessarily dedicated to cloud-based applications.
- the server device 101 may include more than one computing device.
- a computing device may be based on PC hardware, rack-mounted hardware, blade-based hardware, or other types of hardware configurations.
- FIG. 2A is a block diagram of a computing device in accordance with an example embodiment.
- a computing device 200 shown in Figure 2A can be configured to perform one or more functions of the server device 101, application model datastore 102, data model datastore 103, and/or client devices 104a, 104b, and 104c.
- the computing device 200 may include a user interface module 201, a network-communication interface module 202, one or more processors 203, and data storage 204, all of which may be linked together via a system bus, network, or other connection mechanism 205.
- the user interface module 201 may be operable to send data to and/or receive data from external user input/output devices.
- the user interface module 201 may be configured to send/receive data to/from user input devices such as a keyboard, a keypad, a touch screen, a computer mouse, a track ball, a joystick, and/or other similar devices, now known or later developed.
- the user interface module 201 may also be configured to provide output to user display devices, such as one or more cathode ray tubes
- the user interface module 201 may also be configured to generate audible output(s), such as a speaker, speaker jack, audio output port, audio output device, earphones, and/or other similar devices, now known or later developed.
- the network-communications interface module 202 may include one or more wireless interfaces 207 and/or wireline interfaces 208 that are configurable to communicate via a network, such as the network 106 shown in Figure 1.
- the wireless interfaces 207 may include one or more wireless transceivers, such as a Bluetooth transceiver, a Wi-Fi transceiver perhaps operating in accordance with an IEEE 802.11 standard (e.g., 802.11a,
- 802.11b 802. l lg
- WiMAX transceiver perhaps operating in accordance with an IEEE
- the wireline interfaces 208 may include one or more wireline transceivers, such as an Ethernet transceiver, a Universal Serial Bus (USB) transceiver, or similar transceiver configurable to communicate via a twisted pair wire, a coaxial cable, a fiber-optic link or other physical connection to a wireline network.
- the network communications interface module 202 may be configured to provide reliable, secured, and/or authenticated communications.
- information for ensuring reliable communications can be provided, perhaps as part of a message header and/or footer (e.g., packet/message sequencing information, encapsulation header(s) and/or footer(s), size/time information, and transmission verification information such as cyclic redundancy check (CRC) and/or parity check values).
- Communications can be made secure (e.g., be encoded or encrypted) and/or decrypted/decoded using one or more cryptographic protocols and/or algorithms, such as, but not limited to, DES, AES, RSA, Diffie-Hellman, and/or DSA. Other cryptographic protocols and/or algorithms may be used as well or in addition to those listed herein to secure (and then decrypt/decode) communications.
- the one or more processors 203 may include one or more general purpose processors and/or one or more special purpose processors (e.g., digital signal processors, application specific integrated circuits, etc.).
- the one or more processors 203 may be configured to execute computer-readable program instructions 206 that are contained in the data storage 204 and/or other instructions as described herein.
- the data storage 204 may include one or more computer-readable storage media that can be read or accessed by at least one of the processors 203.
- the one or more computer-readable storage media may include volatile and/or non- volatile storage
- the data storage 204 may be implemented using a single physical device (e.g., one optical, magnetic, organic or other memory or disc storage unit), while in other embodiments, the data storage 204 may be implemented using two or more physical devices.
- the data storage 204 may include computer-readable program instructions 206 and perhaps additional data.
- the data storage 204 may additionally include storage required to perform at least part of the herein-described techniques and/or at least part of the functionality of the herein-described devices and networks.
- the server device 101, application model datastore 102, and data model datastore 103 may be cloud-based devices that store program logic and data of cloud-based applications.
- the server device 101, application model datastore 102, and data model datastore 103 may be a single computing device residing in a single computing center.
- the server device 101, application model datastore 102, and data model datastore 103 may include multiple computing devices in a single computing center, or even multiple computing devices located in multiple computing centers located in diverse geographic locations.
- Figure 1 depicts each of the server device 101, application model datastore 102, and data model datastore 103 residing in a different physical location.
- data stored at the server device 101, application model datastore 102, and/or data model datastore 103 may be encoded as computer readable information stored in tangible computer readable media (or computer readable storage media) and accessible by the client devices 104a, 104b, and 104c, and/or other computing devices.
- the application model datastore 102 and/or data model datastore 103 may be a single disk drive or other tangible storage media, or for large cloud-based systems, the application model datastore 102 and/or data model datastore 103 may be implemented on multiple disk drives or other tangible storage media located at one or more diverse geographic locations.
- Figure 2B depicts a cloud-based server system in accordance with an example embodiment.
- the computing cluster 209a may include one or more computing devices 200a, cluster storage arrays 210a, and cluster routers 211a connected by a local cluster network 212a.
- the computing cluster 209b may include one or more computing devices 200b, cluster storage arrays 210b, and cluster routers 211b connected by a local cluster network 212b.
- the computing cluster 209c may include one or more computing devices 200c, cluster storage arrays 210c, and cluster routers 211c connected by a local cluster network 212c.
- each of the computing clusters 209a, 209b, and 209c may have an equal number of computing devices, an equal number of cluster storage arrays, and an equal number of cluster routers. In other embodiments, however, some or all of the computing clusters 209a, 209b, and 209c may have different numbers of computing devices, different numbers of cluster storage arrays, and/or different numbers of cluster routers. The number of computing devices, cluster storage arrays, and cluster routers in each computing cluster may depend on the computing task or tasks assigned to each computing cluster.
- the computing devices 200a can be configured to perform various computing tasks of the server device 101.
- the various functionalities of the server device 101 can be distributed among one or more of the computing devices 200a.
- some of these computing devices may be configured to operate as a web server, and other computing devices may be configured to execute program logic defined by a cloud-based application.
- Still other computing devices of the computing cluster 209a may be configured to communicate with the application model datastore 102 and data model datastore 103.
- the computing devices 200b and 200c in the computing clusters 209b and 209c may be configured the same or similarly to the computing devices 200a in the computing cluster 209a.
- the computing devices 200a, 200b, and 200c each may be configured to perform different functions.
- the computing devices 200a may be configured to perform one or more functions of the server device 101
- the computing devices 200b may be configured to perform one or more functions of the application model datastore 102
- the computing devices 200c may be configured to perform one or more functions of the data model datastore 103.
- 209a, 209b, and 209c may be data storage arrays that include disk array controllers configured to manage read and write access to groups of hard disk drives.
- the disk array controllers alone or in conjunction with their respective computing devices, may also be configured to manage backup or redundant copies of the data stored in the cluster storage arrays to protect against disk drive or other cluster storage array failures and/or network failures that prevent one or more computing devices from accessing one or more cluster storage arrays.
- cluster storage arrays 210a, 210b, and 210c Similar to the manner in which the functions of the server device 101, application model datastore 102, and/or data model datastore 103 can be distributed across the computing devices 200a, 200b, and 200c of the respective computing clusters 209a, 209b, and 209c, various active portions and/or backup/redundant portions of these components can be distributed across the cluster storage arrays 210a, 210b, and 210c.
- some cluster storage arrays may be configured to store the data of the server device 101, while other cluster storage arrays may store the application model datastore 102, and/or data model datastore 103. Additionally, some cluster storage arrays may be configured to store backup versions of data stored in other cluster storage arrays.
- the cluster routers 211a, 211b, and 211c in the computing clusters 209a, 209b, and 209c may include networking equipment configured to provide internal and external communications for the computing clusters.
- the cluster routers 21 la in the computing cluster 209a may include one or more internet switching and/or routing devices configured to provide (i) local area network communications between the computing devices 200a and the cluster storage arrays 201a via the local cluster network 212a, and/or (ii) wide area network communications between the computing cluster 209a and the computing clusters 209b and 209c via the wide area network connection 213a to the network 106.
- the cluster routers 211b and 211c can include network equipment similar to the cluster routers 211a, and the cluster routers 211b and 211c can perform similar networking functions for the computing clusters 209b and 209b that the cluster routers 211a perform for the computing cluster 209a.
- computing tasks and stored data associated with server device 101, application model datastore 102, and/or data model datastore 103 can be distributed across the computing devices 200a, 200b, and 200c.
- the distribution of tasks and stored data may be based at least in part on (i) the processing requirements of the server device 101, application model datastore 102, and/or data model datastore 103 functions, (ii) the processing capabilities of the computing devices 200a, 200b, and 200c, (iii) the latency of the local cluster networks 212a, 212b, and 212c and/or of the wide area network connections 213a, 213b, and 213c, and/or (iv) other factors that may contribute to the cost, speed, fault- tolerance, resiliency, efficiency, and/or other design goals of the overall system architecture.
- the configuration of the cluster routers 211 a, 21 lb, and 211c can be based at least in part on the data communication requirements of the computing devices and cluster storage arrays, the data communications capabilities of the network equipment in the cluster routers 211a, 211b, and 211c, the latency and throughput of the local cluster networks 212a, 212b, 212c, the latency, throughput, and cost of the wide area network connections 213a, 213b, and 213c, and/or other factors that may contribute to the cost, speed, fault-tolerance, resiliency, efficiency and/or other design goals of the system architecture. 4. Distributed Development Architecture
- Figure 3 is a block diagram of a development architecture, in accordance with an example embodiment.
- Figure 3 shows a distributed software architecture
- the distributed software architecture 300 may include software components that reside on either a client device, such as one or more of the client devices 104a, 104b, and
- the cloud-based server devices may include multiple hardware components, and may be arranged according to the system depicted in Figure 2B, or in other ways.
- An execution platform 308, script callbacks 310, an application model 312, a database model 314, and a compiled scripts module 316 may reside on a client device. In some embodiments, some or all of these software components may execute within a web browser or some other type of client platform (e.g., an operating system).
- the application model datastore 102, data model datastore 103, and script compiler 318, as well as an authentication module 320, a dynamic feed module 322, a media handler module 324, and an email handler module 326 may reside on one or more cloud-based server devices.
- any of these software components may be stored and/or execute on either a client device or on one or more cloud-based server devices.
- the execution platform 308 may support multiple modes, such as a design mode 302, a preview mode 304, and a run mode 306.
- the design mode 302 may visually present a GUI-based development environment. This development environment may allow a designer to develop cloud-based applications in a substantially what-you-see-is-what-you-get (WYSIWYG) fashion.
- WYSIWYG substantially what-you-see-is-what-you-get
- the preview mode 304 may allow the designer to at least partially execute a cloud-based application, and to view the executing cloud-based application similar to how a user would see it.
- the cloud-based application can be tested and debugged before being released for general use.
- the preview mode 304 may enable setting breakpoints in the cloud-based application and/or enable monitoring data during execution of the cloud-based application.
- the design mode 302 and preview mode 304 may be able to execute in parallel.
- a cloud-based application executing in the preview mode 304 may automatically be updated to reflect any changes made in the design mode 302 to the cloud-based application.
- the run mode 306 may allow users to execute, or otherwise interact with, the cloud-based application.
- the designer may publish the cloud- based application for user access via a URL, perhaps a public URL on the Internet.
- any changes to the cloud-based application made using the design mode 302 may be reflected in the run mode 306 in a near real-time fashion. Alternatively, these changes may not be immediately reflected in the run mode 306. For example, instances of the cloud-based application executing in the run mode 306 may continue to execute without these changes, perhaps until reloaded or refreshed by a web browser executing the cloud-based application.
- the design mode 302 may be substantially the same as the preview mode 304 and the run mode 306, except with the menus 402, stack toolbar 404, page toolbar 406, database toolbar 408, widget palette 410, and configuration palette 412 removed.
- the differences between the design mode 302, the preview mode 304, and the run mode 306 may be limited to the state of the development environment GUI and the widgets. As a result, the designer may be able to switch between the modes in a substantially instantaneous fashion, as compilation and linking of the program logic may not be necessary.
- each of the design mode 302, preview mode 304, and run mode 306 may include different GUI-based representations of the cloud-based application, and each of these modes may provide different types of functionality and interactivity to the designer or user.
- the design mode 302 may display the development environment GUI, with its associated menus and palettes, while the preview mode 304, and run mode 306 may display the application GUI without these menus and widgets.
- the development environment may support other modes of operation not described herein.
- the execution platform 308 may load and store cloud-based applications and their associated data.
- the execution platform 308 may also render and execute these cloud- based applications.
- the execution platform 308 may be a script-based virtual machine that operates in a web browser.
- some web browsers support JAVASCRIPT® to facilitate dynamic web pages and web-based user interfaces. Accordingly, the execution platform 308 may be based on pre-provided and/or designer-provided
- the execution platform 308 may use one or more different scripting languages, such as but not limited to PHP, PERL®, JAVA®, AWK, Tcl/Tk, Python, and/or various shell scripting languages. Any or all of these scripting languages may execute inside or outside of a web browser.
- the application model 312 may be an abstract representation of the cloud- based application.
- the cloud-based application may be a data-driven application that includes several pages.
- the pages of such an application may be organized into a "stack" of pages, and each stack of pages may be referenced by a unique URL. Alternatively or additionally, each page within the stack may be associated with a unique URL.
- Data-driven applications may include, for instance, applications that use the values of stored data to influence how the application presents itself to the user, how generated or input data and/or objects are stored, or to otherwise influence the behavior of the application.
- Each of these pages may include one or more widgets (e.g., images, text boxes, menus, dialogs, etc.).
- the application model 312 may include a representation of pages and widgets.
- This representation may include, for example, the names of each page and widget, relationships between pages, relationships between pages and widgets, references to any data associated with each widget, metadata associated with pages and/or widgets, names of scripts associated with pages and/or widgets, names of scripts associated with the cloud-based application as a whole, and so on.
- these items of the application model 312 may form a partially- complete or complete representation of the cloud-based application executable by the execution platform 308.
- information in the application model 312 may specify the cloud-based application's user interface and behavior of the cloud-based application.
- the database model 314 may represent the data associated with various aspects of the application model 312.
- the database model 314 may include a database schema that defines the data stored on behalf of the cloud-based application. This data may include information associated with the cloud-based application's pages and widgets.
- the database schema and the data stored in the database schema may be automatically generated by the execution platform 308 based on the defined pages and widgets. Additional scripts may extend the database schema and control the data stored in this schema.
- the compiled scripts module 316 may be compiled versions of additional scripts provided by the designer or a third party to enhance the program logic of cloud-based applications or the program logic of the execution platform 308.
- the compiled scripts module 316 may include processed scripts, object code, machine code, or byte-code representations of program logic written in a scripting language.
- the use of the compiled scripts module 316 may be facilitated by the script callbacks 310, which may be used to include the compiled scripts module 316 into the execution platform 308.
- the execution platform 308 may provide a number of insertion interfaces for injecting the compiled scripts module 316 into the execution platform 308.
- the script callbacks 310 may provide stub functions for one or more script names.
- the execution platform 308 may assign each compiled script a unique script name in accordance with one or more of these stub functions, such that when a stub function is invoked, the script associated with this stub function is executed.
- Scripts and their respective script names may be stored in the application model 312.
- Software components on the client device may interact with software components on cloud-based server devices (e.g., the server device 101).
- cloud-based server devices e.g., the server device 101
- one or more cloud-based server devices may provide software modules and storage to further facilitate the development of cloud-based applications.
- the cloud-based server devices may include, and/or have access to, the application model datastore 102 and database model datastore 103.
- the application model datastore 102 may include a database component for storing a representation of the application model 312.
- the execution platform 308 may transmit near real-time updates to the application model datastore 102 to reflect these changes.
- the application model datastore 102 may provide parts of the application model 312 to the execution platform 308 on demand.
- the execution platform 308 may request portions of the application model 312 from the application model datastore 102 on an as needed basis.
- the execution platform 308 may only request portions of the application model 312 related to the first page. Then, to generate a display of the second page, the execution platform 308 may request portions of the application model 312 related to the second page.
- the database model datastore 103 may include a database component for storing a representation of the database model 314.
- the database model datastore 103 may use a database schema defined by the execution platform 308 (and possibly enhanced by the compiled scripts module 316) to store data associated with the cloud-based application.
- This database schema may be arranged so that each page in the application model 312 is represented by a database table, and each widget on a given page is represented by a field in the database table.
- other arrangements of the database schema are also possible.
- the databases in the database model datastore 103 may include a relational database, perhaps supporting a structured query language (SQL). Alternatively, these databases may include other types of computer file(s) arranged in one or more file systems. Various types of data structures may store the information in such a database, including but not limited to tables, arrays, lists, trees, fields, and tuples. These data structures may be defined using one or more data schemas. Furthermore, these databases may be monolithic (e.g., stored on a single physical device) or, as described in reference to Figure 2B, distributed across multiple devices in a network.
- SQL structured query language
- a database schema may include a structure of a database, where this structure defines the objects in the database.
- a database schema may be defined using a formal language. Some of the information defined by a database schema may include tables, fields within the tables, types of data stored in the tables and fields, and relationships between tables, between fields, and between tables and fields.
- a database schema may also include indexes, program logic, event triggers, links, and other components.
- the script compiler 318 may be a software module that receives scripts from the execution platform 308, and compiles these scripts into an executable representation.
- the script compiler 318 may transmit these executable representations of the scripts to the compiled scripts module 316.
- the script compiler 318 may include functionality that translates script-based program logic in the form of JAVASCRIPT® code, PHP code, PERL® code, JAVA® code, AWK code, Tcl/Tk code, Python code, various types of shell scripting code, and/or other types of program logic into some form of object code, machine code, and/or byte code.
- the script-based program logic may be expressed using a superset (e.g., extensions or add-ons) of an existing scripting language. Additional details about script compilation are set forth in more detail in Section 6.
- the authentication module 320 may ensure that designers and users accessing cloud-based applications are properly logged into the system.
- the authentication module 320 may also control access to individual application models and database models.
- the application model 312 and/or database model 314 may have an access control list that defines the designers and users that are authorized to use the model.
- the execution platform 308 may allow or deny a particular designer or user access to a particular application model or database model.
- the designer or user may be required to provide representations of their userid and/or password to the authentication module 320.
- Some or all users may only have access to certain modes of the distributed software architecture 300. For example, some users may only be able to access the run mode 306.
- a database can only be read from and written to by the cloud-based application that created the database. However, the designer can override this behavior and allow other applications to access the database. For example, the designer may allow any cloud-based application that uses the server device 101 to access the database.
- the dynamic feed module 322 may provide a way for a designer or user to access and parse one or more feeds.
- a feed may be, for example, a Really Simple
- RSS Really Simple Syndication
- Atom feed that is published on the Internet or a private network.
- Feeds may be used to provide frequently updated works, such as blog entries and online news sites, to readers in a standardized format.
- Some feeds may include a series of entries in chronological order, with each entry containing a headline, author, date of publication, and some content (e.g., text, hypertext, images, audio, video, etc.).
- Feeds may take the form of an extensible Markup Language (XML) file. These feeds may be used for rapidly populating a data model for a cloud-based application, so that the cloud-based application can be tested.
- XML extensible Markup Language
- the media handler module 324 may facilitate the uploading of image files, audio files, video files, and so on by the designer or user. Such media may be added to the design of the cloud-based application by designers, or to the content of a running cloud-based application by users.
- the media handler module 324 may generate a unique identifier for the file. This identifier may be stored in the application model 312.
- the execution platform 308 renders a cloud-based application containing a media file, the execution platform 308 may retrieve the media file via the media handler module 324.
- the email handler module 326 may provide a service that allows executing cloud-based applications to send emails.
- the email handler 326 may provide
- Simple Mail Transfer Protocol mail transfer agent functions for one or more of the cloud-based server devices.
- the email handler 326 may use the Domain Name System (DNS) to look up the outgoing email message's destination, and then transmit the outgoing email message to this destination.
- DNS Domain Name System
- FIG. 3 may be software, hardware, or some combination of software and hardware. These components may be collocated with one another or distributed across two or more physically distinct computing devices. Further, a distributed development architecture may have more or fewer components, and may arrange these components in a different fashion than shown in Figure 3.
- Figure 4 depicts a development environment in accordance with an example embodiment.
- a development environment 400 represents a possible
- development environment GUI that could be presented to a designer using the distributed software architecture 300.
- development environment 400 may be a visual representation of the execution platform 308 in the design mode 302, preview mode 304, and/or run mode 306.
- execution platform 308 may include program logic and media files that facilitate the presentation of the development environment 400.
- the designer may be able to design, test, and execute a cloud-based application.
- the development environment 400 may include a number of menus, palettes, toolbars, and/or workspaces.
- menus 402 include a set of drop-down menus, including a "File” drop-down menu, a "Mode” drop-down menu, a "Help” drop-down menu, and a "Widget” drop-down menu. More or fewer drop-down menus may be included in the development environment 400. Also, it should be understood that each of the drop-down menus in the menus 402 are shown in their non-dropped-down state. Thus, by hovering a cursor or pointer over a particular drop-down menu, or by selecting a drop-down menu, among other possibilities, the respective drop-down menu's items may be displayed.
- selecting the "File” drop-down menu may result in options being displayed for creating a new cloud-based application, loading a cloud-based application from storage, saving a currently-loaded cloud-based application, and/or printing the development environment GUI, database schema, or scripts of a currently-loaded cloud-based application.
- selecting the "Mode” drop-down menu may result in options being displayed for switching between the design mode 302, preview mode 304, and run mode 306.
- selecting the "Help" drop-down menu may result in options being displayed for assisting the designer in using the development environment 400.
- the development environment 400 may also include a stack toolbar 404, a page toolbar 406, and a database toolbar 408.
- the stack toolbar 404 may allow the designer to switch between different stacks, where each stack represents a series of related pages that are part of a cloud-based application.
- the page toolbar 406 may allow the designer to select for display one or more pages that are part of a stack in the cloud-based application.
- the page toolbar 406 may include a menu or a substantially equivalent mechanism to allow the designer to switch between these pages.
- the stack toolbar 404 and page toolbar 406 may allow a designer to select a specific page of a specific cloud-based application, and this selected page may be displayed in the development environment 400. For example, as shown in Figure 4, the designer has selected "test5" on the stack toolbar 404, and "Page 1" on the page toolbar 406.
- the development environment 400 may display, in the application workspace 414, a representation of the selected page of the selected stack (e.g., Page 1 of the test5 stack).
- the database toolbar 408 may allow the designer to name and/or control the database schema used to store the cloud-based application's data model. For example, in Figure 4, schema "test5db" is being used. In some embodiments, the database toolbar 408 may allow this schema to be changed or renamed. In other embodiments, the development environment 400 may hide this detail from the designer, so that the database and its schema are named, created, and updated automatically.
- a page of the cloud-based application may include zero or more widgets that are displayed representatively in the application workspace 414.
- Development environment 400 may allow a designer to drag and drop widgets from the widget palette 410 into the application workspace 414. The designer may then position and/or further configure these widgets. The act of placing a widget in the application workspace 414 may result in the widget being added to the page being displayed in the application workspace 414, and the execution platform 308 updating the database model to reflect the addition of this widget.
- the widget palette 410 includes several examples of widgets that may be used on a page.
- the widgets in the widget palette 410 may include a field widget, an image widget, a button widget, a test widget, a menu widget, a color widget, a list widget, and a select widget.
- a field widget an image widget
- a button widget a test widget
- a menu widget a color widget
- a list widget a select widget
- the field widget may allow the designer to add a field for data entry, for instance a text box (e.g., a graphical display sub-component) and an associated label (e.g., another graphical display sub-component), to a page.
- the media widget and the button widget may respectively allow the designer to select and add an image or other type of media, or to place a button on the page.
- the text widget may allow the designer add text to the page.
- the menu widget may allow the designer to add a menu to the page, and to specify the items in the menu.
- the color widget may allow the designer to add a particular color to a section of the page.
- the list widget may allow the designer to add a list to the page, and to specify the entries in the list.
- the select widget may allow the designer to add a check-box to the page.
- Other widgets may provide additional functionality.
- buttons 416 For purposes of illustration, an example of widget selection and placement is shown in a dialog box 416.
- the dialog box 416 combines three widgets: a text widget 418, a button widget 420, and a button widget 422.
- the text widget 418 includes the text string "Press OK to continue", while the button widgets 420 and 422 include the names "OK” and "Cancel” respectively.
- Individual widgets from the widget palette 410 may also be combined to form a compound widget, as set forth in more detail in Section 8.
- Each widget on a page may be further configured.
- the configuration palette 412 as shown in Figure 4 indicates the configuration of the, perhaps currently selected, button widget 420.
- the button widget 420 includes the name "OK", and this name is selected to be displayed.
- the configuration palette 412 also specifies the location of the button widget 420 in terms of x and y coordinates on the page, as well as the width and height of the button widget 420. These x and y coordinates, as well as width and height specifications may be in pixels, inches, centimeters, or some other unit of measure.
- Automatic layout tools may simplify the process of determining layout relationships between widgets and perhaps between widgets and edges of the client web browser or device display, as set forth in more detail in Section 9.
- the configuration palette 412 enables assigning an action to the button widget 420.
- An action for a button may be specified using the "When", “Do”, and “Page” menus that appear toward the bottom of the configuration palette 412.
- Figure 4 shows that the configuration palette 412 indicates that, when the button widget 420 is clicked, the cloud-based application can switch to a different page, "Page 2".
- Other button options could also be provided.
- An advantage of the development environment 400 is that it allows individuals with little or no computer programming, web development, or database experience to design and deploy cloud-based applications. For instance, these individuals need only drag and drop widgets on to the application workspace 414 in order to create a cloud-based application. Any database used by this cloud-based application may be automatically and transparently created, without requiring input from the individual.
- more experienced computer programmers, web developers, and/or database designers can find the development environment 400 useful, as the development environment 400 provides a simple interface to a rich set of features, facilitating rapid prototyping and development of cloud-based applications.
- Figures 5 and 6 depict examples, in the form of ladder diagrams 500 and 600, of how information could flow through the distributed software architecture 300 in order to facilitate the development of cloud based applications.
- an entity e.g., a designer, remote computer, etc.
- the execution platform 308 may transmit an authentication request to the authentication module 320.
- the authentication request may include, for example, a representation of the entity's account or credentials (e.g., a userid and/or password).
- the authentication module 320 may determine that the entity is authorized to create a cloud-based application via the software architecture 300. This authorization may involve, for example, the authentication module 320 looking up the entity's credentials in a credential repository. Based on information associated with the credentials, the authentication module 320 may determine that the entity has been granted the ability to create the cloud-based application. Accordingly, at a block 508, the authentication module 320 may transmit an authentication approval to the execution platform 308. [00134] In response to the authentication approval, the execution platform 308 may allow the entity to begin building the cloud-based application. For example, the entity may add one or more pages to the cloud-based application, and may also add one or more widgets to at least some of these pages. At a block 510, the execution platform 308 may receive a representation of these pages, widgets, and any other information (e.g., names, identifiers, metadata, and/or scripts) related to the design of the cloud-based application.
- the execution platform 308 may receive a representation of these pages, widgets, and any
- the execution platform 308 may transmit an update to the application model 312.
- This update may include specifications of the pages, widgets, and/or other information.
- the application model 312 may transmit the update (and/or information derived from information in the update) to the application model datastore 102.
- the application model datastore 102 may store the information in the update.
- the application model 312 may also maintain a copy of the representation.
- the execution platform 308 may transmit an update to the database model 314.
- This update may include data representing a database schema, and/or data associated with the pages, widgets, and other information that was transmitted to the application model 312.
- the database model 314 may transmit the update (and/or information derived from information in the update) to the database model datastore 103.
- the database model datastore 103 may store the data in the update.
- the database model 314 may also maintain a copy of the data.
- the execution platform 308 may continue to make updates to the application model 312 and database model 314 as the entity modifies the cloud-based application.
- the application model 312 and database model 314 may, in turn, continue to update the application model datastore 102 and database model datastore 103.
- Figure 6 is another ladder diagram in accordance with a further example embodiment.
- an entity e.g., a designer, remote computer, etc.
- the execution platform 308 may transmit a script compilation request, along with a copy of the script, to the script compiler 318.
- the script compiler 318 may compile the script.
- the script compiler 318 may transmit the compiled script to the execution platform 308.
- the execution platform 308 may transmit a request to add the compiled script, along with a copy of the compiled script, to the compiled scripts module 316.
- the compiled scripts module 316 may store the compiled script.
- the execution platform 308 may transmit a request to add a reference to the compiled script to the script callbacks 310.
- the script callbacks 310 may use this reference to link to the compiled script as stored in the compiled scripts module 316.
- the execution environment may be able to execute the linked, compiled script during the execution of the cloud-based application.
- the execution platform 308 may transmit an update to the application model 312. This update may include a copy of the compiled script.
- the application model 312 may transmit the copy of the script to the application model datastore 102.
- the application model datastore 102 may store the script.
- the application model 312 may also maintain a copy of the script. Additional details about script compilation are set forth in more detail in Section 6.
- Figure 7 is a flow chart in accordance with an example embodiment.
- the flow chart illustrates a possible method 700 through which the application model 312 and the database model 314 can be created and populated based on a cloud-based application developed in development environment 400.
- a computing device may display, via a graphical development environment (e.g., the development environment 400), a user interface of an application (e.g., a cloud based application).
- the graphical development environment may have access to an application model (e.g., the application model 312) and a data model (e.g., database model 314) of the application.
- the application model may include program logic of the application and a representation of the user interface of the application, while the data model may include a database schema for storing data used by the application.
- the representation of the user interface in turn, may include a representation of a page, and the representation of the page may include a representation of a widget.
- the widget may contain text and graphical content, and use of the widget may trigger execution of a script.
- the graphical development environment may be controlled by a script-based execution platform operating on the computing device.
- the computing device may receive a change to the application.
- This change may be, for example, an edit to the application user interface or program logic made by a designer of the application.
- Some possible changes include adding a new widget to the application, removing a widget from the application, associating a widget with data, adding a new script to the application, removing a script from the application, associating a script with a widget and/or data, and changing the attributes of a widget.
- Receiving the change to the application may occur while the graphical development environment is in a design mode. Further, the change may be received while the application is executing in a preview mode or a run mode. Responsive to receiving the change to the application in the design mode, the computing device may automatically update an instance of the application executing in the preview mode or run mode. Alternatively, the computing device may refrain from updating the instance of the application executing in the run mode.
- the computing device may (i) apply a modification to the application model and the data model (or, modifications may be applied to only the application model or only the data model) to incorporate the change, and transmit a representation of the modification to a server device.
- the server device may store copies of the application model and the data model.
- the transmission may occur automatically in response to applying the modification. Additionally, the representation of the modification may include a
- the representation of the modification may include a
- the change to the application may involve adding a script to the application.
- the computing device may receive the script, and in response to receiving the script, transmit the script to the server device for compilation.
- the computing device may receive a complied version of the script from the server device, and then add the compiled version of the script to the program logic of the application.
- the computing device may store a copy of the compiled script in a compiled scripts module (e.g., compiled scripts module 316) and link the program logic of the application to the compiled script via a script callbacks module (e.g., script callbacks 310).
- the script may contain logic that interacts with a widget, or acts independently from widgets, to control values of at least one unit of data stored in the database schema.
- a database schema can be automatically created and populated based on the layout and content of the application GUI created by the designer. For example, when the designer adds an application GUI element to a page, the execution platform 308 may instruct the database model 314 to create a database schema based on the application GUI. Then, the database model 314 may in turn instruct the database model datastore 103 to create the database schema.
- One way in which the database schema may be based on the application GUI is to create a database table in the database schema for each page in the application GUI. Then, when a widget is added to a given page, a field is added to the database table to represent the widget.
- the execution platform 308 may update the database model 314, and in turn the database model may update the database model datastore 103 to add a field for the widget. Further, as the designer defines the name, position, size, shape, and/or actions associated with the widget, this information may also be stored in the database.
- the database model 314 and the database model datastore 103 may be updated to incorporate these changes.
- the field associated with the widget may be removed from the database table associated with the page.
- the database table associated with the page may be removed from the database schema.
- the field associated with a removed widget or the database table associated with the removed page contains user data
- one of the following actions may occur: (i) the field / table is removed from the database along with all data associated with that field / table, (ii) the application designer is notified that the field / table contains data, and is asked to confirm that they want to remove the field / table from the database, or (iii) the widget / page is removed from the application model but the field / table and any associated data are not removed from the database.
- option (ii) or (iii) may be preferable, because it is generally desirable to preserve user data, and scripts associated with the application may refer to the field / table.
- a given page may be associated with more than one database table, or a given database table may be associated with more than one page.
- a given widget may be associated with more than one given field in a given database table, or a given field in a database table may be associated with more than one widget.
- Figure 8 depicts the development environment 400 in accordance with an example embodiment. While the overall development environment GUI depicted in Figure 8 is substantially similar to that of Figure 4, Figure 8 also includes a set of widgets configured on a page. These widgets may combine, for example, to form page that facilitates calendar scheduling.
- application workspace 414 includes a field widget "Name” 802, a field widget “Email” 804, a calendar widget 806, a menu widget "Time” 808, and a button widget 810.
- the calendar widget 806 is not shown in the widget palette 410, and is representative of the many possible widgets not appearing in the widget palette 410 that could be defined by a designer.
- the page represented in the application workspace 414 may allow a user to enter their name in the field widget "Name” 802, their email address in the field widget "Email” 804, specify a date in the calendar widget 806, and specify a time on the menu widget "Time” 808. Then, the user may click (e.g., activate) the button widget 810 to "book” or schedule an event at the specified date and time for an individual with the specified name and email address. In particular, given the values of the calendar widget 806 and the menu widget "Time” 808, the event would be set at the specified time and date of 7:00 on August 30, 2010.
- the configuration palette 412 shows the configuration of the button widget
- the configuration palette 412 also shows an action specified for the button widget 810.
- the button widget 810 When the button widget 810 is clicked, the execution platform 308 may be instructed to save the values entered into widgets on the page to the database.
- data into this page e.g., a name, an email address, a date and a time
- clicks on the button widget 816 the entered data may be stored in the database.
- execution platform 308 may create a database schema to store information about the page and widgets included on the page.
- An example database schema, expressed in a pseudo-SQL format, for the page and widgets in Figure 8 is shown below. CREATE TABLE pagel (
- the example database schema includes a database table, pagel, containing information related to the data-driven widgets included on the associated page.
- a data-driven widget is a widget that is associated with a particular unit of data.
- each of the field widget "Name” 802, the field widget "Email” 804, the calendar widget 806, and the menu widget "Time” 808 may be data-driven widgets.
- the respective units of data associated with each of these widgets may be expressed as a field in the database table.
- Each of these fields may be considered variables that can take on different values.
- the label of each widget may be used to automatically name the associated database field.
- the database field associated with the field widget "Name” 802 may be labeled “Name”
- the database field associated with the field widget "Email” 804 may be labeled “Email”
- the calendar widget 806 a default database field label of "Date” may be used. Nonetheless, the designer may be able to override these automatic naming conventions.
- field may be used herein to refer to a type of widget (e.g., the field widget "Name” 802 and the field widget "Email” 804) or to a field in a database table.
- a field in a database table that stores the data associated with a field widget.
- the appropriate interpretation of this term can be made.
- a widget added to a cloud-based application may have both a name and a widget identification number (ID).
- ID may be automatically generated and may also be unique for the cloud-based application (e.g., IDs may be generated by using an automatic scheme to generate monotonically increasing (or decreasing) IDs).
- the fields in the database may be referenced by widget ID instead of by name.
- a separate database may be automatically maintained to provide mappings from widget IDs to widget names.
- An advantage of using IDs is that if the designer changes the name of a widget, the database does not have to change. This allows, for example, scripts that reference the database to remain unchanged when widget names change. It also facilitates uniqueness of database field references while allowing widgets of the same name to appear on different pages of the cloud-based application.
- the execution platform 308 may determine the data format of each field in a database table based on a data type of the field's associated widget. Thus, for example, the execution platform 308 may determine the data format for database table fields associated with the field widget "Name" 802 and the field widget "Email" 804 to be VARCHARs (e.g., variable length character strings). The execution platform 308 may also determine the data format for the database fields associated with the calendar widget 806 to be DATE (e.g., a calendar date expressed in YYYY-MM-DD format).
- DATE e.g., a calendar date expressed in YYYY-MM-DD format
- the execution platform 308 may determine the data format of the database fields associated with menu widgets to be VARCHARs.
- the data format of the database field associated with the menu widget "Time" 808 is TIME (e.g., a time or time offset represented in HH:MM:SS format).
- the designer may, via configuration palette 412, specify the data type of the menu widget "Time” 808 to be TIME (note that this option is not shown in Figure 8). Then the execution platform 308 may define the data format of the database field associated with the menu widget "Time” 808 to be the same as this user-specified data type. In other embodiments, the designer may use the compound widget feature (see Section 8) of the development environment 400 to define a new type of widget that include a menu widget but exhibits a data type of TIME.
- the data type of the menu widget "Time" 808 may be
- VARCHAR VARCHAR
- custom program logic e.g., in the form of a script
- the custom program logic may only accept VARCHAR values representing a time between that of 09:00 and 17:00 (9AM to 5PM).
- Custom program logic can be used in a similar fashion to control values of data associated with any widget in a cloud-based application.
- the execution platform 308 may create a database schema based on a page and widgets in application workspace 414.
- database creation based on the application GUI of a cloud-based application can occur in ways different than that set forth above. For instance, a given page may be associated with more than one database table, and/or a given widget may be associated with more than one field in a database table.
- FIG. 9 is flow chart 900 in accordance with an example embodiment.
- a computing device may display at least part of an application GUI.
- the application GUI may include a page, and the page may include a widget.
- the computing device may create a database schema based on the application GUI.
- the database schema may include data defining a relationship between the page and the widget.
- the database schema may include a database table for the page, and the database table may include a field for the widget.
- the database table may define the page and the field may define the widget.
- creating the database schema may include creating the database table, and adding the field to the database table.
- the database schema may have one table per page.
- the page's table may include a field for each widget.
- a widget may have a data type and a field associated with the widget may have a data format. Accordingly, when creating the database schema, the computing device may set the data format of the field based on the data type of the widget. Further, the widget may be associated with a text string, and the field may have a name. Consequently, when creating the database schema the computing device may set the name of the field based on the text string.
- the values that a field may take on can be limited to a particular range or set of values, and this limitation may be enforced through scripts. These scripts may include program logic that operates on a widget, or in conjunction with the widget, to store only particular values in the field.
- the application GUI may change. Therefore, in response to determining that the application GUI has changed, the computing device may update the database schema to incorporate the change. For example, in response to determining that a new widget has been added to the application GUI, the computing device may update the database schema to incorporate the change. Additionally, in response to determining that an existing widget has been removed from the application GUI, the computing device may remove an existing field from the database table.
- the database schema may reside on a server device. Therefore, when creating the database schema, the computing device may transmit a representation of the database schema to the server device. Also, when updating the database schema to incorporate changes, the computing device may transmit a representation of the change to the server device.
- cloud-based applications can include one or more scripts.
- Each script in turn can contain one or more scripting language instructions.
- the scripting language instructions may be instructions in a scripting language, such as JAVASCRIPT®, PHP, PERL®, JAVA®, AWK, Tcl/Tk, Python, and/or various shell scripting languages.
- Each script may be associated with a computational item of the cloud-based application, such as a page, widget, or non-user-interface (non-UI) item.
- a computational item of the cloud-based application such as a page, widget, or non-user-interface (non-UI) item.
- computational items may include, for example, data and/or executable instructions.
- a page script may be associated with a page, and may execute when the page loads (e.g., is displayed) and/or unloads (e.g., is no longer displayed).
- a page script associated with a given page could set up a background image for use on the given page when the given page loads. Additionally, the page script could save a copy of the background image when the page unloads.
- Page scripts may use a page model to represent pages of the application model
- the page model may include information about base attributes that affect the page as a whole. These base attributes may include page identifiers, related application identifiers, page size information, background/foreground color information, storage allocation information, and/or page title(s) or name(s).
- the page model may also include various widget-specific attributes for each widget associated with the page. These widget-specific attributes may include a name, an identifier, a color, a size, text, a font, and/or storage allocation information. Other base and/or widget-specific attributes are possible as well. As such, the page script may interact with the page model by accessing and/or modifying base and/or widget-specific attributes of the page model.
- a widget script may be associated with a given widget, and may execute when the given widget receives an event from the cloud-based application.
- Example events for a given widget include: activating the given widget, selecting the given widget, entering data via the given widget, an exception or other type of error for the given widget, and deactivating the given widget.
- the widget script may interact with the widget by accessing and/or modifying widget-specific attributes for the widget. For example, a widget script can be used to change a given widget's font, size, text, foreground, and/or background colors. Other events and widget-specific attributes may be manipulated by widget scripts as well.
- a non-UI computational item script may be associated with a non-UI computational item of the application, and may similarly execute upon creation and/or instantiation of the computational item, when the computational item is loaded (e.g., is displayed) and/or unloaded (e.g., is no longer displayed), and/or when the computational item receives an event (e.g., an exception or another type of event).
- the non-UI computational item script may interact with the computational item by accessing and/or modifying computational-item-specific attributes for the computational item. For example, a script attached to a stack, or group of related pages, may be executed when at least part of the stack is first loaded, perhaps before the first page of the stack is loaded.
- Non-UI computational item scripts could be attached to the database model 314 as well. For example, a script could update and/or initialize a database of a cloud-based application when the cloud-based application is loaded and/or unloaded.
- a script may include one or more script extensions. Such script extensions may permit a script to access and/or modify a computational model, such as the application model 312 or the database model 314. Script extensions may follow a standard syntax. By following the standard syntax, the script extensions can be readily identified by a script compiler. In an example syntax for script extensions, each script extension may begin with a key character (e.g., a dollar sign) followed by an identifier of the computational model. For examples, the script extension "$Database" may be used to access the database model and the script extension "$Name" may be used to access the Name variable of the application model. By accessing the application model 312 and/or database model 314 via script extensions, the script may be permitted to use data and and/or program logic maintained by the respective model.
- a key character e.g., a dollar sign
- a script may access a specific program logic method of the computational model via a method extension.
- a method extension For example, suppose the database model 314 can be accessed via a script extension and that the database model 314 includes a program logic method called "initialize()" to set up the database model 314. Then, the "initialize()" program logic method can be accessed via a statement such as "$Database.initialize()" which includes both a script extension of "$Database” to access the database model 314, and a method extension of ".initialize()" to access the "initialize()" program logic method of the database model 314. Many other examples of script extensions and/or method extensions are possible as well.
- $Name.getText(); can retrieve text from a computational item of the application model, such as a widget, identified by use of the "$Name” script extension and the corresponding ".getText()" method extension for text retrieval.
- the retrieved text may be stored in a variable called "Name”.
- $Age.getText(); can retrieve text from a widget identified by use of the "$Age” script extension and the ".getText()" method extension.
- the retrieved text may be stored in a variable called "Age”.
- This conditional statement determines whether data stored in the database model 314 contains specified Name and Age data as indicated by the "$Database.contains("Name, Age", Name+”,"+Age)" script and method extensions.
- the "contains” method takes two parameters: a string indicating a comma-separated list of fields to be searched (e.g., the "Name,Age” sub-statement) and a comma-separated list of data items to search for. This comma-separated list of data items is generated by the
- Scripts may include features of an underlying scripting language, such as
- the second scripting language instruction incorporates features of a scripting language (JAVASCRIPT®) in the second method name to assemble a valid method name.
- JAVASCRIPT® a scripting language
- Many other scripts using one or more underlying scripting languages with script extensions and/or method extensions are possible as well.
- the script compiler mentioned above may include an extension compiler.
- the extension compiler can receive a script with one or more scripting language instructions, possibly containing script extensions and/or method extensions, and generate corresponding scripting language instructions without the script extensions and/or method extensions.
- the use of the extension compiler enables free use of script language instructions, script extensions, and/or method extensions.
- the extension compiler may use one or more identifiers for use translating script extensions and/or method extensions into corresponding scripting language instructions.
- FIG 10 depicts an example script compilation for an example cloud-based application 1020 in an example set of cloud-based applications 1000.
- Each cloud-based application may be associated with different application models and database models, and may be assigned or otherwise associated with an application identifier (ID) to identify the respective cloud-based application in a plurality of applications.
- ID application identifier
- a cloud-based application 1010 has an application ID of 1 and the cloud-based application 1020 has an application ID of 47.
- application IDs may have other formats than the numeric formats shown in Figure 1.
- application IDs may alternatively or additionally be alphabetic, alphanumeric, or binary, or may use some other way of specifying cloud-based applications in a plurality of applications.
- Each computational item within a cloud-based application may also be assigned a computational item ID.
- the computational item ID can specifically identify the computational item within a computational model and can be combined with the application
- the database 1012 for the cloud-based application 1010 has a computational item ID of "0" and can be combined with the application ID of "1" to form a corresponding global ID of "1.0".
- the computational items 1014, 1016, and 1018 have respective computational item IDs of "1", “2", and "3” with corresponding respective global IDs of "1.1”, “1.2”, and "1.3.”
- Scripts associated with a cloud-based application can be assigned respective global IDs as well.
- Figure 10 shows a script 1028 associated with the cloud- based application 1020 having an application ID of 47.
- the script 1028 has a computational item ID of "3", and therefore a global ID of "47.3".
- Other formats for computational item IDs and global IDs may be used as well, such as those discussed above for application IDs.
- the global IDs and other attributes of a computational item can be stored in one or more computational item descriptions.
- a computational item description may include a table, database, and/or another type of data structure. Searches for global IDs, application IDs, computational item names, computational item addresses, and/or by other criteria of the computational item descriptions may be enabled to track the various attributes of the computational item.
- a computational item description for a computational item may include one or more identifiers for the computational item, perhaps including a computational item name, one or more types for the computational item, a storage location of the computational item, and/or a list of zero or more methods defined for the computational item.
- Table 1 shows an example set of computational item descriptions for the computational items shown in Figure 10.
- a computational item Iteml 1014 of the application 1020 has an application ID of 1, and a computational item ID of 1. This application ID and computational item ID may combine to form a global ID of 1.1, as shown in Figure 10.
- Computational item Iteml 1014 also has a name of "Iteml", is of type integer, is stored in location OxdOOO, and can be used with a given list of numerical functions (e.g., addition, subtraction, multiplication, division, comparison operators, etc.).
- Table 1 also includes additional aspects of computational items, in particular a script ID and an item ID.
- the script ID may store an identifier of a script associated with the computational item. For example, “Iteml” (computational ID 1) of application ID 1 does not have an associated script, and thus the corresponding script ID is set to "-1" (which indicates that there is no associated script). However, “Item2” (computational ID 2) of application ID 47 does have an associated script, and this script has a computational item ID of "3", and thus the corresponding script ID for "Item2" is set to "3".
- the item ID may store an identifier of another item associated with a computational item. For example, "Iteml” of application ID 1 is not associated with another computational item, and thus the corresponding item ID is set to -1 (which indicates that there is no additional associated computational item). However, "Script" (computational ID 3) of application 47 does have an associated computational item, and thus the corresponding item ID is set to "2", which is the computational ID of the computational item associated with the script. In this fashion, a script ID may indicate an association from a computational item to a script and an item ID may indicate an association between one computational item (such as a script) and another computation item. In some embodiments, multiple script IDs and/or item IDs may be associated with a computational item.
- the extension compiler may use a one or more method descriptions.
- Each method description may represent a method extension.
- Each method description may also include a method name, a set of applicable computational item types, a list of zero or more parameters used by an associated computational item, a type of a return value, and a function name corresponding to the method name.
- method descriptions that relate to the database model 314 could specify method extensions and corresponding function names to: (i) read the database schema of the database model 314, (ii) add a table (e.g., layout of a database record) to the database schema, (iii) add a field to a table in the database schema, (iv) delete a table from the database schema, (v) list all records stored using a specified table of the database schema, (vi) add a database record to the database schema, (vii) read data from a database record of the database schema, (viii) write data to a database record of the database schema, (ix) delete a database record of the database schema, and/or (x) search the records of the database schema.
- Other method extensions and corresponding function names are possible as well, including but not limited to database-related method extensions and corresponding function names.
- Table 2 shows three example time-related method descriptions.
- the following example script based on the example method descriptions of Table 2, uses method extensions to set three variables h, m, and s from an application model computational item called "TheDate".
- the example script utilizes JAVASCRIPT® as an underlying scripting language to which scripting language of the development environment 400 is translated.
- scripting languages other than
- JAVASCRIPT® could be used.
- var h $TheDate.Hours();
- the method descriptions may be part of the application model 312 and/or the database model 314. Thus, the method descriptions can be used by a cloud-based application in any of design mode 302, preview mode 304, and/or run mode 306.
- a script compiler can use the identifiers, computational item descriptors, and method descriptors discussed above to translate script extensions and method extensions into scripting language instructions.
- script compiler 1030 can parse the scripting language instruction quoted above to determine that a script extension of "$Item2" is used based on the presence of the above-mentioned "$" delimiting character and a ".” preceding a method extension "getSecs().”
- the script compiler 1030 can parse the scripting language instruction quoted above to determine that a script extension of "$Item2" is used based on the presence of the above-mentioned "$" delimiting character and a ".” preceding a method extension "getSecs().”
- the 1030 can determine a global ID corresponding to the computational item specified in the script extension for the cloud-based application.
- the computational item is
- the script compiler 1030 may query the example set of computational item IDs shown in Table 1, with the computational item name of "Item2" and the application ID of 47 to determine the corresponding computational item ID of 2.
- the access sub-instruction may receive a global ID (or other identifier) and/or a type.
- the access sub-instruction may query a set of computational item identifiers based on the identifier. For example, if a global ID is used, the query may involve using the application ID and computational item ID specified in the global ID to find a corresponding storage location for a computational item. If the query is successful, an interface to the computational item is returned.
- This interface may be the corresponding storage location (e.g., a pointer to the computational item), a handle to the computational item (e.g., a pointer to a pointer to the computational item), a copy of the computational item found at the corresponding storage location, and/or another interface to the computational item.
- the access sub-instruction may return an error value and/or invoke an error handler (e.g., throw an exception) if the global ID does not refer to a computational item of a cloud-based application and/or if the type does not match the type of the computational item identified by the global ID.
- the script compiler 1030 can generate part or all of a scripting language instruction that corresponds to a method extension. For example, to process the above- mentioned "getSecsO" method extension, the script compiler 1030 can query the set of method extensions for a function name corresponding to the "getSecs()" method extension. Using the example set of method extensions shown in Table 2, the script compiler 1030 can find a function name of "getSeconds" corresponding to the "getSecs()" method extension and further determine that the "getSeconds" function has no parameters. In some scenarios, the script compiler 1030 can compare the returned function with a list of functions associated with the computational item and verify that the function is in the list, and is thus actually associated with the computational item.
- the two example scripting language instructions shown in the compiled script 1032 correspond to the scripting language instruction shown in the application script 1028.
- Other application scripts and corresponding compiled scripts are possible as well.
- the compiled script 1032 may be further improved.
- the call to the "access" function may be combined with a call to a function corresponding to method extension, thereby eliminating use of the temporary variable "tmpltem2".
- One or more scripts may be installed or "injected” into the execution platform
- the one or more scripts may be injected using a live injection technique that installs the one or more scripts during execution of the associated cloud-based application. Live injection of scripts may ensure the WYSIWYG behavior of cloud-based applications containing scripts by automatically and/or dynamically modifying the behavior of the cloud- based applications to reflect changes made to the cloud-based application.
- the execution platform 308 may use one or more script callbacks 310 to support live injection of compiled scripts.
- script callbacks Several example script callbacks are described below. However, other script callbacks may be defined and used in addition to or in place of these examples.
- a possible script callback may be an "add script" callback to install scripts.
- the "add script" callback may include functionality for locating a script (e.g., locating a script stored in application model 312, database model 314, application model datastore 102, or database model datastore 103) based on one or more identifiers. These identifiers may include global IDs and/or computational item IDs. Also, the add script callback may ensure that the script has been recently compiled.
- the add script callback can provide the requested compiled script to the execution platform 308.
- the add script call back may store a compiled script (e.g., in application model 312, database model 314, application model datastore 102, and/or database model datastore 103) after requesting compilation as well.
- An "execute script" callback may execute a compiled script associated with a cloud-based application.
- the execution platform 308 finds a script function name, as generated above, the execution platform 308 may call the execute script callback with the function name.
- the compiled JAVASCRIPT® associated with the function name may then be run.
- a "remove script" callback may delete a previously installed compiled script from the execution platform 308.
- the remove script callback may ensure the script is stored in the application model datastore 102 just prior to removal thus ensuring the stored script is the most recent copy of the script.
- FIG 11 is a ladder diagram illustrating an example scenario 1100 involving live script injection.
- an entity e.g., a user, remote computer, etc.
- the execution platform 308 may transmit a locate application request 1104 to the application model datastore 102 to retrieve the requested application.
- the locate application request 1104 may also traverse the application model 312, and may include a name and/or other identifier(s) of the requested application.
- the application model datastore 102 may retrieve one or more computational items related to the requested application, and communicate the requested application to the execution platform 308 using a requested application response 1106.
- the execution platform 308 may execute the requested application.
- a script associated with the application may be invoked during execution of the requested application.
- the execution platform 308 may transmit a locate script request 1110 to the application model datastore 102 (possibly via the application model 312).
- the locate script request 1110 may include a name, a global ID, and/or other identifiers of the requested script.
- the requested script may include one or more scripting-language instructions.
- the application model datastore 102 may find and retrieve the requested script and transmit the requested script to the execution platform 308 using a requested script response 1112.
- the execution platform 308 may determine that the requested script is to be compiled. To compile the requested script, execution platform 308 may invoke the script compiler 318 via a compile script request 1114.
- the compile script request 1114 may include a copy of the script to be compiled, or a reference with which the script compiler 318 can locate the script to be compiled in the application model datastore 102.
- the script compiler 318 may generate a compiled script by compiling the requested script.
- the script compiler 318 may then transmit the compiled script to the execution platform 308 using a compile script response 1118.
- the execution platform 308 may then add the compiled script to compiled scripts module 316 (not shown) and add a link to the compiled script to the script callbacks 310 (not shown).
- These transactions are not shown in Figure 11, but may be the same as or similar to the blocks 610- 616 of Figure 6. In this way, the execution platform 308 may perform a live injection of the compiled script into the execution platform 308.
- the execution platform 318 may not need to have the script compiled (e.g., the script may already be compiled), and the blocks 1114-1118 may be omitted.
- the execution platform 308 may execute the compiled script to perform one or more transactions of a computational model. As part of executing the compiled script at block 1122, the execution platform 308 may execute one or more application model transactions 1124 with the application model datastore 102 and/or database model transactions 1126 with the database model datastore 103. These application model and database model transactions 1124, 1126 may include one or more operations that read, write, insert, and/or delete data in the application model datastore 102 and/or database model datastore 103.
- the execution platform 308 may store the compiled script in application model database 102. A possible advantage of doing this is to avoid having to recompile the script again in the future. Additionally, and not shown in Figure 11, the execution platform 308 may act to remove the compiled script from the compiled scripts module 316, and to remove the link to the compiled script from the script callbacks 310.
- Figure 12 is a flow chart 1200 according to an example embodiment.
- a script is received at a script compiler.
- the script may include at least one scripting language instruction for an application, such as a cloud-based application.
- the scripting language instruction(s) of the script may include a script extension, and the script extension may specify use of a computational model, which may be an application model or a database model.
- the script extension may include a character and an identifier of the computational model. The identifier of the computational model may specify a
- example computational items of the application include databases, pages, widgets, and/or other computational items of the application.
- the script compiler may locate or identify the script extension of the at least one scripting language instruction of the script.
- the script extension may include a key character, and as such, the script compiler may identify or locate the script extension within the script based on the key character; e.g., a beginning of the script extension can be located by finding the key character that begins the script extension.
- the script compiler may determine an identifier of the computational model specified by the script extension.
- the script compiler may query for a computational item among a set of computational item identifiers and receive an interface to the computational item specified by the script extension.
- the script compiler may generate a compiled script
- the compiled script may include scripting language code that replaces the script extension where the scripting language code is configured to access the computational item identified by the identifier of the computational model.
- the scripting language code may include a call to an access sub-instruction that permits access to the computational model (e.g., the database model) identified by the identifier associated with the access sub-instruction.
- the least one scripting language instruction includes a method extension that corresponds to an invocation of a function of the computational model.
- the script compiler may be configured to generate additional scripting language code to replace the method extension with the invocation of the function of the computational model. For example, the script compiler may query a set of method descriptors to determine a function of either the database model or the application model that corresponding to the method extension. In some of these embodiments, a return value of the function can be determined based on the set of method descriptors.
- Figure 13 depicts a flow chart 1300 of an example embodiment. At a block
- an application may be received at a computing device.
- the application may include a stack and a database.
- the stack may include one or more pages for a user interface.
- the application may be a cloud-based application.
- the application may be executed using the computing device. Executing the application may include locating a compiled script for the application, injecting the compiled script into the application, and executing the injected script in the application.
- the injected script may be configured to access the stack and/or the database.
- the compiled script may be located based on an identifier assigned to the compiled script, and may include a scripting language instruction for the application.
- locating the compiled script may include locating a script based on the identifier, determining that the script is to be compiled, requesting that the script be compiled, and receiving the compiled script, wherein the compiled script corresponds to the script.
- the functionality of flow chart may include locating a script based on the identifier, determining that the script is to be compiled, requesting that the script be compiled, and receiving the compiled script, wherein the compiled script corresponds to the script.
- executing the application may include removing the application script from the application.
- adding a script, compiling the script, injecting the compiled script, and/or removing the script may performed by use of one or more callbacks (e.g., use of an add-script callback to add a script).
- the identifier may include an application identifier and a computational-item identifier.
- Figure 14 shows an example window for a standard editor 1400 with a compile button 1402 and a script development assistance button 1404.
- the standard editor 1400 may be configured for editing of a script and, via the compile button 1402, compiling the edited script.
- the standard editor 1400 may be suitable for experienced software developers, who may have used similar editors for script and/or program logic development.
- Script development assistance can be provided by the "Add Item” button 1404 shown enhancing the standard editor window 1400 of Figure 14.
- Figure 15A depicts an example "Widget Chooser” dialog 1500.
- the "Widget Chooser” dialog 1500 may be displayed upon selection of the "Add Item” button 1404.
- the "Widget Chooser” dialog 1500 may display some or all computational items of a cloud-based application under development and/or enable assisted addition of script commands to perform operations on the
- the Widget Chooser dialog 1500 includes three sections: a page selection section 1502, a computational item choice section 1506, and an instruction section 1516.
- the page selection section 1502 may allow selection of a page of the cloud-based application.
- computational items for the current page of the cloud-based application are shown in the Widget Chooser dialog 1500 by default.
- a page selector 1504 provides for selection of a different (non-default) page of the cloud-based application for assistance, e.g., a page other than the current page.
- the computational item choice section 1506 may include a list 1508 of the computational items on the selected page of the cloud-based application.
- the list 1508 can include a computational item name, computational item type, and one or more identifiers.
- one computational item 1510 in the list 1508 has a computational item name of "Date of birth,” a computational item type of "Date,” and a global ID of "71.3.”
- additional "pseudo-items” can be shown in the list 1508 to represent the database model 314 (e.g., the computational item "Database” 1512) and/or the application model 312 (e.g., the
- An instruction section 1516 may instruct the designer about how to add a method to a script (e.g., "click on a method to add it to your script.”).
- the instruction section 1516 section can list methods for a selected computational item of the list 1506 that are available for use an edited script.
- the "Widget Chooser" dialog 1500 can populate the instruction section 1516 of the dialog with a list of methods applicable for the selected computational item.
- Figure 15B shows an example "Widget Chooser" dialog 1500 with the instruction section 1516 populated with methods for a selected computational item 1520.
- the selected computational item 1520 is a "Name" computational item, which is shown as selected in Figure 15B using a bold and underlined font.
- Figure 15B also shows the instruction section 1516 populated with a list of methods 1522 applicable to the selected
- the list of methods 1522 may be a partial list of methods applicable to the selected computational item, as shown in Figure 15B, or a complete list of methods.
- the Move(x,y) method 1524 is shown in a bold and underlined font in Figure 15B.
- a corresponding block of code may be inserted into the standard editor 1400.
- Figure 15C shows the editor window of standard editor
- the line of code 1526 shown in standard editor 1400 of Figure 15C is a syntactically-correct new scripting language code of "$Name.move(X,Y);" that corresponds to the selected "Move(x,y)” method 1524.
- Figure 15C also shows the line of code 1526 inserted into the existing script after the "Move(x,y)" computational item 1524 was selected as indicated in Figure 15B and the corresponding line of code 1526 was appended to the script after the two lines of the existing script.
- Many other computational items, method, and inserted lines of code are possible as well.
- the script, including any inserted lines of code can be stored, retrieved, and/or edited via the standard editor 1400 and/or via other types of editors.
- Figures 16A through 16C show a scenario 1600 for providing another example level of assistance to aid with programming of JAVASCRIPT® syntax (e.g., "if...else” statements and “for” loops). This assistance technique is not restricted to helping with
- Figure 16A shows a standard editor 1602 enhanced with an "Add Statement” button 1604. Once selected, the Add Statement button 1604 may cause a menu of statements to be displayed (not shown in Figure 16A) for selection.
- This menu of statements may include if...else statements, loops, and/or other types of statements (e.g., a "switch" statement) used in the scripting language, perhaps along with statements used in other languages.
- FIG. 16B shows an example dialog 1610 for adding an "if...else" statement as part of scenario 1600.
- dialogs for other types of statements may be displayed based on a corresponding selection in the menu of statements.
- the dialog 1610 may permit selections related to the "if...else" statement, such as radio buttons 1612 and 1614 related to conditions and check box 1620 related to the else sub-statement. Selection of the radio button 1612 may permit entry of a user-added condition, while selection of the radio button 1614 may permit entry of a pre-defined
- database contains" condition related data stored in the database model 314.
- scenario 1600 the radio button 1614 is selected.
- possible fields used by the "database contains” condition may be displayed as part of dialog 1610.
- Figure 16B shows the dialog 1610 displaying two example fields for the database contains statement, a "Name” field 1616 and an "Age” field 1618.
- an "else” statement may be added to the "if statement by selection of "else” selector 1620.
- both the "Name" field 1616 and “Age” field 1618 are selected from the dialog of Figure 16B prior to selection of an "OK" button 1622.
- Figure 16C shows the example standard editor 1602 with a corresponding syntactically-correct new block of scripting language code 1624 for an "if...else" statement.
- the new block of scripting-language code 1624 may be inserted into a script in response to selection of the OK button 1622 of the dialog 1610. As shown in Figure 16C, the new block of scripting-language code 1624 is:
- the new block of scripting-language code 1624 may, upon execution, permit querying of the database model 314 of the cloud-based application for based on a combination of "Name" and "Age” data, which corresponds to the selections of the Name field 1616 and the Age field 1618 in dialog 1610 as shown in Figure 16B.
- code to be executed when the database contains condition is true may be added as well via the dialog 1610 and/or the standard editor 1602.
- the inserted new block of scripting language code 1624 may include syntactically-correct definition of the Name and Age variables, such as shown above the "if statement in the editor window 1602 of Figure 16C.
- the script including any new blocks of code, can be stored, retrieved, and/or edited via the standard editor 1400, the standard editor 1602 and/or the guided script editor 1702 described below.
- Figures 17A through 17F show a scenario 1700 using a guided script editor
- Figure 17A shows an example window for the guided script editor 1702.
- the guided script editor 1702 may be configured to define one or more scripts using a simplified, visually-enhanced syntax. For example, instead of using the standard JAVASCRIPT® " ⁇ ... ⁇ " notation for blocks of statements, the guided script editor 1702 can use defined screen areas to show control blocks. To aid comprehension, the guided script editor 1702 can use one or more conversational statements made in a non-programming language that are equivalent to one or more scripting-language statements.
- non-programming languages include English, Spanish, French, German, Italian, Chinese, Japanese, Korean, Russian, Hindi, Urdu, and Greek; many other examples of non-programming languages are possible as well.
- the conversational statement is simpler to read and understand, especially for a user without detailed knowledge of scripting languages.
- a user of the guided script editor 1702 would not need detailed knowledge of scripting language syntax to write scripts.
- the script generated by the guided script editor 1702 may be stored as a standard scripting language script.
- the generated script may be edited using the above- mentioned standard editor to enhance the capabilities of the script and/or learn how the underlying scripting language works.
- some of the capabilities of the scripting language are not available via the guided script editor 1702. Rather, the guided script editor 1702 can provide a simplified version of a scripting language to support common scripting language operations without overwhelming a novice designer with options.
- the guided script editor 1702 may have two or more modes accounting for different levels of programming skill.
- the two or more modes may include a "novice” mode that permits use of a very simplified version of a scripting language, a "moderate” mode that permits use of more functionality of the scripting language than the novice mode, and an "expert” mode that permits use of most (if not all) functionality of the scripting language.
- the guided script editor 1702 can provide conversational statements equivalent to statements in one or more non-scripting-language programming languages, such as but not limited to, C, C++, FORTRAN, Pascal, and other non-scripting-language programming languages.
- Figure 17A shows the example guided script editor window 1702 may be divided into areas. These areas may include a script element controls area 1704, a variables area 1706, and a script area 1708.
- the script elements controls area 1704 includes elements that can be assembled into a script.
- Figure 17A shows the script element controls area 1704 divided into three sections corresponding to different elements of the script. These controls may include a "Statements" area 1710 for "if...else” statements and loop statements, an "Actions" area 1712 to show, hide, get, and set pages and/or widgets, and a "Database" area 1714 for database search and database contains statements.
- Each section of script elements area 1704 may be collapsible to allow hiding of unneeded sections.
- Other script element controls and/or sections of script element controls can be shown in the script elements controls area 1704 of guided script editor 1702 as well.
- variables area 1706 of the guided script editor permits addition of variables into the script by selecting an "Add" button 1716.
- the variables area 1706 can have an additional button to delete a variable and/or other buttons for other variable operations (e.g., grouping variables into a computational item or data structure).
- Additional help on an element-by-element basis can be provided by the guided script editor. For example, clicking on a control in the script element controls area can cause a dialog to be displayed with an explanation of what the control does in a script and any expected parameters for the control.
- the script area 1708 is shown in Figure 17A as a relatively-large blank box.
- a user of the guided script editor 1702 can drag a button representing the corresponding script element from the script elements controls area 1704 into the script area 1708.
- Figure 17B shows an example "Add Variable” dialog 1720 for the guided script editor 1702 as part of the scenario 1700.
- the designer may use the "Add Variable” dialog 1720 to name a variable to be added to the script via a "Variable Name” text box 1722.
- a user may type in "Name” into the "Variable Name” text box 1722.
- the "Add Variable" dialog 1720 may permit initialization of the added variable in one of two fashions.
- the added variable can be explicitly initialized by entering an initial value for the variable using an initial-variable-value entry box 1724. For example, to initialize the newly-added variable to a value of 6, a user may type in a "6" into the initial- variable-value entry box 1724.
- the "Add Variable" dialog 1720 may also permit initializing the newly-added variable to a value of a widget by choosing one of the widgets listed in a widget-value section of the "Add variable” dialog 1720.
- Figure 17B shows that values of the "Name", "Age", or
- FIG. 1730 shows the newly-added variable Upon selection of a respective radio button corresponding to a widget, the newly-added variable may be initialized to the corresponding widget's value at the time the script executes. For example, if the "Name" radio button 1728 is selected, the newly-added variable may be initialized to the value of a "Name” widget.
- Figure 17C shows the example guided script editor window 1702 after addition of two variables as part of the scenario 1700. Once defined, each newly-added variable is included in the variables section 1706 of the guided script editor 1702 and the appropriate conversation statement is displayed in the script area 1708. In the scenario 1700, the variables "Name" and "Date of birth" have been added.
- Figure 17C shows a button for "Name” variable 1734 and a button for the "Date of Birth” variable 1736 in the variables area 1706.
- clicking a variable button may cause the guided script editor 1702 to generate and display an "Update variable” dialog (not shown in Figures 17A-17F) similar to the "Add variable” dialog 1720.
- the update variable dialog may be configured to permit changing the name and/or initial value of a selected variable.
- FIG. 17D shows an example guided script editor window 1702 with a script area 1708 for adding an "if...else" statement to the script.
- the guided script editor 1702 includes a condition box 1740.
- the condition box 1740 may be populated by dragging a condition element onto it.
- Figure 17D shows the text of a "contains" condition 1742 of the database operations area 1714 in bold to represent selection of the "contains” condition 1742.
- the "contains" selection 1742 may be selected and then dragged into the condition subsection 1740.
- Figure 17E shows an example guided script editor window 1702 after the
- variable button such as the "Name” button
- the guided script editor 1702 may display a dialog that allows a designer to add a condition.
- Figure 17F shows an example "Add Condition” dialog 1746.
- the "Add Condition" dialog 1746 may permit addition of a condition.
- the "Add Condition" dialog 1746 includes a left-hand-side entry box 1748, a comparison- operation menu 1750, and a right-hand-side entry box 1752.
- Each sub-section of the condition can be completed by dragging a script element control into an empty sub-section of the condition.
- a script element control As an example, suppose the desired condition is to test the "Name" variable as not being equal to the string "Mikey Moose.” Then, a user could drag the "Name" variable button 1734 into the left-hand-side entry box 1748 to fill the left-hand-side entry box 1748 with "Name".
- a user could type "Name” into the left-hand-side entry box 1748 instead of dragging the "Name” variable button 1734.
- the user may click on the "Does not Equal” radio button of comparison- selection menu 1750.
- the user may type "Mikey Moose” into right-hand-side entry box 1752 and then click "OK” button 1754.
- Many other comparisons can be entered as well are possible as well using the guided script editor 1702.
- the guided script editor can generate a corresponding if...else statement to be added to the script.
- the script including any added scripting language instructions, can be stored, retrieved, and/or edited using the guided script editor 1702 and/or using a standard editor (e.g., standard editor 1400 or standard editor 1600) or another type of editor.
- Figure 18 shows a flow chart 1800 according to an example embodiment for adding a scripting language instruction to a script of scripting language instructions and storing the script.
- a script of scripting language instructions is created, possibly via a computing device.
- a scripting language instruction is generated using a guided script editor of the computing device.
- the guided script editor may include a statement control, a variable control, and a script area.
- the guided script editor may be configured to generate a conversational statement equivalent to the generated scripting language instruction.
- the conversational statement may be made in a non-programming language, such as English, or in a non-scripting-language programming language, such as C++.
- the scripting language instruction is added to the script of scripting language instructions.
- the script of scripting language instructions including the added scripting language instruction, is stored via the computing device.
- the statement control may include an if...else control.
- generating the scripting language instruction may include receiving a selection of the if...else control, receiving condition input to complete a condition sub-section of the if...else control, receiving parameter input to complete parameters of the if...else control, and generating an if...else statement based on the condition input and the parameter input.
- generating the scripting language instruction may include receiving a selection of the variable control and generating a variable statement based on the selection.
- Receiving the selection of the variable control can include receiving a name input and an initialization input for a variable.
- Generating the variable statement can include generating the variable statement based on the name input and the initialization input.
- Figure 19 shows a flow chart 1900 according to another method for adding a scripting language instruction to a script of scripting language instructions and storing the script.
- an editor window is displayed, possibly via a computing device.
- the editor window may include an editing area and an assistance button.
- the editor window may be configured for editing a script that includes one or more scripting language instructions.
- the computing device may determine that the assistance button has been selected.
- the assistance button may be selected to request assistance with a particular scripting language instruction.
- the computing device may generate an assistance display related to the particular scripting language instruction of the one or more scripting language instructions based on, and perhaps in response to selection of the selected assistance button.
- the computing device may display the assistance display.
- the computing device may receive input via the assistance display.
- the input may specify a variable name, a variable value, a computational item, a scripting language method, part or all of a scripting language instruction, and/or other types of input.
- the computing device may generate the particular scripting language instruction based on, and perhaps in response to, the received input.
- the scripting language instruction may include a variable assignment statement, an "if...else" statement, a looping statement (e.g., for loop, repeat loop, while loop), an invocation of a scripting- language method, and/or other types of statements.
- the computing device may add the particular scripting language instruction to the script.
- the script is stored via the computing device.
- the script may be stored on the computing device and/or communicated to another computing device for storage.
- the assistance button includes an add-statement button and the assistance display includes an add-statement display.
- receiving input via the assistance display may include receiving a statement- selection input via the add-statement display to select a statement, and receiving a parameter- selection input via the add-statement display to select a parameter related to the statement.
- generating the scripting language instruction based on the received input may include generating the scripting language instruction based on the statement-selection input and the parameter-selection input.
- the assistance button includes an add-computational-item button and the assistance display includes an add-computational-item display.
- receiving input via the assistance display may include receiving a computational-item-selection input via the add-statement display to select a computational item, and receiving a method-selection input via the add-statement display to select a method related to the computational item.
- generating the scripting language instruction based on the received input may include generating the scripting language instruction based on the computational-item-selection input and the method-selection input.
- individual widgets from the widget palette 410 of development environment 400 may be combined to form a compound widget.
- the ability to quickly and easily create compound, re-usable widgets may reduce the time and complexity required to develop and maintain cloud-based applications. For example, there are many instances where it may be beneficial for a particular set of widgets, with shared and/or custom behavior, to appear more than once on a particular page, stack, or application.
- the compound widget may be promoted to a first class widget (e.g., available in the widget palette 410 for further instantiation of a same or similar set), making it easier to recreate, share, manipulate, and maintain particularly defined sets of widgets.
- a first class widget e.g., available in the widget palette 410 for further instantiation of a same or similar set
- first-class widgets may be loaded by the development environment 400 and made available for a designer to drag and drop into the application workspace 414 to form a part of a cloud- based application.
- first-class widgets may include, for example, a field widget, a media widget, a button widget, a test widget, a menu widget, a color widget, a list widget, and a select widget.
- an advantage of compound widgets is that, once created, they can be added to the widget palette 410 as a first-class widget that can be similarly instantiated in the future by simply dragging the compound widget from the widget palette 410 to the application workspace 414.
- the compound widget may be accessible via either (or both) of the development environment 400 and/or the application model datastore 102.
- the compound widget may be loaded by the development environment 400 and made available for a designer to drag and drop into the application workspace 414 on different pages of the current stack or in a new stack of a new cloud-based application.
- the created compound widget may also be made available to other designers, perhaps in accordance with an access control list, and in a similar manner to that set forth above with respect to application models and database models.
- Figures 20-23 illustrate examples of creating a compound widget in the development environment 400.
- a compound widget may be created from a set of already- existing first-class widgets.
- a user may drag and drop a plurality of first-class widgets, including, for example, a color widget 2002, a button widget 2004, a media widget 2006, and a text widget 2008, from the widget palette 410 to the application workspace 414. While this example uses a particular set and arrangement of first-class widgets as illustrated in Figure 20, any other types of widgets, and any other arrangement of the widgets, could additionally or alternatively be used.
- the widgets may be selected via an input selection process, illustrated in Figure 20 as a dashed selection line box 2010.
- the dashed selection line box 2010 may be created by a designer dragging a cursor across the selection of first-class widgets 2002-2008.
- the selection of the first-class widgets may result in a Crosshatch, highlight, change in color, or other mechanism applied to the first-class widgets 2002-2008 to provide visual feedback to the designer of the selected first-class widgets that will form a part of the compound widget.
- the designer may generate an instruction to create a compound widget from the selected first-class widgets.
- the instruction may be provided in any number of ways. For example, a "click" on an input device having input buttons, such as a mouse, may display a menu from which the designer may select a menu item entitled "Create Compound Widget.”
- Figure 21 depicts an example option dialog box 2100 for use in creating a compound widget that may appear responsive to the designer selecting the "Create
- the option dialog box 2100 allows a user to set values for a compound widget name 2102, a current compound widget instance name 2104, color widget options 2106-2108, media widget options 2110-2112, text field widget options 2114-2116, button widget options 2118-2124, compound widget script options 2126-2128, shared/specific settings 2130, an identification of the most significant graphical display sub-component 2132, and most significant graphical display subcomponent border options 2134-2136. Nonetheless, the option dialog box 2100 is just one example, and in other embodiments, more or fewer options may be provided to configure the compound widget. These options may change depending on the particular set of first class widgets selected to form member widgets of the compound widget.
- the compound widget options 2102 and 2104 may allow the designer to set the compound widget name 2102 (which may identify the compound widget type and be shared across all instances of that compound widget), and the widget instance name 2104 (which may be the name of the current instance of the compound widget, and may be unique to each instance of that compound widget).
- the color widget options 2106 and 2108 may allow the designer to set options for the color widget, which was selected as a member of the compound widget. In an embodiment in which the color widget was not selected, the color widget options 2106 and
- the color widget options 2108 may include, for example, a color button that may be used to select a particular color for a corresponding color swatch of the color widget (such as red, blue, or white), and a border button that may be used to select a particular border (or lack thereof) to appear at outer edges of the corresponding color swatch of the color widget.
- the color selected for the color widget is one example of a graphical display sub-component of the color widget, which may be incorporated into the compound widget. Other options could also be provided, or a subset of the example options provided.
- the media widget options 2110 and 2112 may allow the designer to set options for the media widget, which was selected as a member of the compound widget. In the event that the media widget was not selected, the media widget options 2110 and 2112 may, for example, not be displayed or may be grayed out. Additionally or alternatively, the media widget check box 2110 may be used to add or remove the media widget from the current compound widget. Checking the media widget check box 2110 may add the media widget to the current compound widget, while un-checking the media widget check box 2110 may remove the media widget from the current compound widget.
- 2112 may include, for example, an image path text box and a browse button for interactively identifying an associated image via a graphical file-system display.
- Other options could also be provided, or a subset of the example options provided.
- other types of media could be selected for the media widget, such as video, audio, flash animation, etc., and other respective types of options could be provided, such as volume for sound, and auto-start for video and animations. All of these media options may comprise another graphical display sub-component of the media widget, which may be incorporated into the compound widget.
- the text field widget options 2114 and 2116 may allow the designer to set options for the text field widget, which was selected as a member of the compound widget.
- the text field widget options 2114 and 2116 may, for example, not be displayed or may be grayed out. Additionally or alternatively, the text field widget check box 2114 may be used to add or remove the text field widget from the current compound widget. Checking the text field widget check box 2114 may add the text field widget to the current compound widget, while un-checking the text field widget check box 2114 may remove the text field widget from the current compound widget.
- the text box widget options 2116 may include, for example, a text field for entering the text to appear in the corresponding text field of the text field widget. Other options could also be provided, or a subset of the example options provided.
- options could be provided to determine whether a text-scroll box is provided in the corresponding text field, or perhaps whether the corresponding text field created by the widget is scaled to accommodate the amount of text entered into the corresponding text field.
- the text selected for the text field widget is one example of a graphical display sub-component of the text widget, which may be incorporated into the compound widget.
- the button widget options 2118, 2120, 2122, and 2124 may allow the designer to set options for the button widget, which was selected as a member of the compound widget.
- the button widget options 2118-2124 may, for example, not be displayed or may be grayed out. Additionally or alternatively, the button widget check box 2118 may be used to add or remove the button widget from the current compound widget. Checking the button widget check box 2118 may add the button widget to the current compound widget, while un-checking the button widget check box 2118 may remove the button widget from the current compound widget.
- the button widget options 2120 may include, for example, identifying a particular script to execute when the corresponding button is activated. A complied script identifier may be entered into the text box of button widget options 2120.
- the compiled script identifier may be automatically populated into the text box of button widget options 2120 when a corresponding script or scripts that reference the button widget are created and/or stored by the designer.
- the button widget options 2122 may specify, in addition to or alternative to executing a script, a new page in the current stack to switch to when the corresponding button is activated.
- the button widget options 2124 may specify a button text to include within the borders of the corresponding button.
- the text and color elements of the button widget are examples of graphical display sub-components of the button widget, which may be incorporated into the compound widget.
- the script associated with the button widget is an example of a functional characteristic of the button widget that may be incorporated into the compound widget. Other options could also be provided, or a subset of the example options provided.
- the compound widget script options 2126 and 2128 may allow the designer to specify a compound widget script that may be associated with the compound widget.
- the compound widget script may control over-all interactions between member widgets, for example, or could be used to initialize or modify behavior of member widgets, among other possibilities.
- a complied script identifier may be entered into the text box of the compound widget script options 2128. Additionally or alternatively, the compiled script identifier may be automatically populated into the text box of the compound widget script options 2128 when a corresponding script or scripts that reference the compound widget are created and/or stored by the designer. Other options could also be provided, or a subset of the example options provided.
- the shared/specific widget options 2130 may allow the designer to specify whether each of the widget options 2108, 2112, 2116, 2120/2122, and/or 2124 are to be shared across all instances of the compound widget, or are to be set specifically for each instance of the compound widget.
- Shared options e.g., characteristics
- additional shared options may be added to the compound widget.
- specific options e.g., characteristics
- Particular widgets and/or particular widget options may be set to always be one of a shared characteristic or a specific characteristic. In some embodiments, widgets and/or widget options may default to one or the other of the shared and specific characteristic, but then allow the designer to modify that default characteristic.
- the most significant graphical display sub-component widget option 2132 may allow a designer to explicitly identify the most significant graphical display subcomponent (e.g., member widget or member widget component) of the compound widget. This information may be used to determine how best to align the compound widget with other widgets on the current page of the stack, in the design mode 302, preview mode 304, or run mode 306.
- the most significant graphical display sub-component widget option 2132 may be used in combination with the most significant graphical display sub-component border widget options 2134 and 2136.
- the most significant graphical display sub-component border widget options 2134 and 2136 may be used to set what particular border of the identified most significant graphical display sub-component should be used in arranging the compound widget relative to other widgets on the current page of the stack.
- Selectable entries for the most significant graphical display sub-component border option 2136 may include, for example, top, left, right, bottom, and center, among other possibilities.
- An "Ok” button 2138 may complete the creation of the compound widget with the widget options selected in dialog box 2100. Selecting the "Ok” button 2138 may also execute validation program logic to ensure that there are no errors in the widget option boxes set forth in the dialog box 2100. For example, such validation may include ensuring that only one most significant graphical display sub-component via most significant graphical display sub-component widget option 2132 box is selected out of the plurality of available boxes, and/or that the compound widget name 2102 and widget instance name 2104 are completed and are different from one another. Other validation procedures are possible as well. And other actions responsive to execution of the "Ok” button 2138 and/or other validation functions are possible as well. Selecting the "Cancel” button 2140 may allow the designer to refrain from creating the compound widget, and may remove the dialog box 2100 from the screen. Other actions responsive to execution of the "Cancel” button 2140 are possible as well.
- Figure 22 sets forth an example of a completed compound widget dialog box
- Figure 22 illustrates particular options that have been completed and/or modified relative to Figure 21, which may be discussed here, in other embodiments, more or fewer of the options 2102-2136 of Figure 21 may be completed, and or a different selection, arrangement, or contents of options may be completed.
- the compound widget name 2202 has been set to "Search Sports Scores.” This name can be set to a general name and may be used to describe the overall functionality of the compound widget in general, instead of the particular function of an instantiated copy of the compound widget.
- the compound widget name 2202 may be associated with all instances of the compound widget.
- the widget instance name 2204 has been set to a more specific title "Search Football Scores.” This name may be used to describe the particular functionality of a particular instance of the compound widget, and should be unique across all instances of the same compound widget [00289] Because a color widget was included in the compound widget selection, the check box option 2206 is selected.
- De-selecting the check box option 2206 may remove the color widget from the compound widget (and perhaps any instances of the compound widget already created). Additionally, the color widget option 2208 "Color" has been set to the color "Red” in this example. The lack of a selection for the "Border" option may mean that no separate border is provided, or that a default border is provided.
- the check box option 2210 is selected. De-selecting the check box option 2210 may remove the media widget from the compound widget (and perhaps any instances of the compound widget already created). Additionally, the media widget option 2212 "Image Path" has been set to "WFootball.png" in this example to reference a stored image of a football at the indicated file system path.
- check box option 2214 is selected. De-selecting the check box option 2214 may remove the text field widget from the compound widget (and perhaps any instances of the compound widget already created). Additionally, text field widget option 2216 "Text" has been set to the text string "Enter Football Team Name.”
- the check box option 2218 is selected. De-selecting the check box option 2218 may remove the button widget from the compound widget (and perhaps any instances of the compound widget already created). Additionally, the button widget option 2222 "Page to Load" has been set to reference the page "Page 2" in the application stack. Accordingly, activation of the button may cause the application to proceed from the current page in the stack to page 2 of the stack. On page 2, for example, a text field may be disposed that is populated with the results of the football scores search.
- the Script ID/Path option 2220 could identify a script that provides functionality similar to that of the option 2222, but may or may not require the loading of a new page in the stack.
- the button widget option 2224 "Button Text" is set to the text string "Search Scores.”
- the compound widget script option 2226 has been checked to indicate that a compound widget script exists and is associated with the current compound widget, and the option 2228 "Script ID/Path" has been set to "scores. scriptl23" to identify a script that defines interactions between member widgets of the compound widget.
- the scores. scriptl23 script may provide a link between, for example, the button widget and the text field widget members of the compound widget, such that when the corresponding button is activated, text in the text field is pulled and used to conduct a database search, and in one embodiment, place the results in a text field on page 2 of the stack.
- the button widget and the text field widget members of the compound widget
- scriptl23 is stored with the compound widget in the application model datastore 102.
- the "Edit Script” button may open the script editor feature described above to allow the designer to create or edit the script.
- the shared/specific compound widget options 2230 are set so that the color widget settings are set to shared (and thus may be the same across all instances of the compound widget), the media widget settings are set to specific (and thus may be specifically set for each instance of the compound widget), the text field widget settings are set to specific (and thus may be specifically set for each instance of the compound widget), the button widget "Page” setting is set to specific (and thus may be specifically set for each instance of the compound widget), and the button widget "Button Text” setting is set to shared (and thus may be the same across all instances of the compound widget).
- the most significant graphical display sub-component option 2232 is identified to be the button widget in this compound widget.
- the specific part of the button widget that may be used as the most significant graphical display sub-component border is set in the most significant graphical display sub-component border option 2236 to be the "Left" edge of the button widget.
- Failure to select the enabling check-box 2234 may result in a default selection of the most significant graphical display sub-component border for the compound widget, which may be, for example, left, right, top, bottom, or center.
- Selecting the "Cancel” button 2240 may erase all of the settings set forth in the dialog box 2200 and prevents the creation of a corresponding compound widget "Search Sports Scores.” Selecting the “Ok” button 2238 completes the configuration of the compound widget "Search Sports Scores” and at the same time creates a first instance of the “Search Sports Scores” compound widget entitled “Search Football Scores.” The "Search Sports Scores” compound widget may also then be placed in the widget palette 410 so that further instances of the "Search Sports Scores” compound widget may be placed on a page in the stack by simply dragging the "Search Sports Scores" compound widget from the widget palette 410 to the application workspace 414.
- Figure 23 illustrates a corresponding instantiation of the "Search Football
- the compound widget 2302 includes a "Red" background color swatch 2306 created commensurate with the color widget settings 2206, a text field 2308 created commensurate with the text field widget settings 2216, a football image 2310 created commensurate with the media widget settings 2212, and a search button 2312 created commensurate with the button widget settings 2222 and 2224.
- a "Search Sports Scores" first-class widget 2300 is created in the widget palette 410 such that additional instances of the "Search Sports Scores" compound widget can be added to the pages in the stack by simply dragging and dropping the (now) first class widget 2300 to the application workspace 414.
- An additionally-instantiated compound widget 2304 illustrates an example of dragging and dropping the newly created first-class compound widget 2300 to create a second instance of the "Search Sports Scores" compound widget.
- only those compound widget options set as specific characteristics via options 2230 are displayed in the configuration palette 412.
- the shared characteristics may be automatically set and updateable only via a separate menu option.
- the compound widget name option 2202 is not shown in the configuration palette 412 as it is a shared characteristic.
- the widget instance name option 2204 is displayed in the configuration palette 412 as this value is individually set for each instance of the "Search Sports Scores" compound widget.
- all compound widget options may be displayed in the configuration palette 412, but may be displayed in such a manner that shared options, such as the color widget option "Red” 2208, are displayed in a "grayed out” or other visual manner to demonstrate that they are shared characteristics and any change to them may be propagated to all other instances of the compound widget.
- an additional confirmation dialog box may be displayed requesting confirmation whenever a designer attempts to make a change to a shared characteristic, in order to prevent accidental side-effects of the change to other instances of the compound widget.
- the compound widget 2304 includes a "Red" background color swatch 2314 created commensurate with the shared color widget settings 2206, a text field 2316 created commensurate with the specific text field widget settings entered into the configuration palette 412, a basketball image 2318 created commensurate with the specific media widget settings entered into the configuration palette 412, and a search button 2320 created commensurate with the shared button widget settings 2224 and the specific search button widget settings entered into the configuration palette 412 (e.g., "Page 3").
- a search button 2320 created commensurate with the shared button widget settings 2224 and the specific search button widget settings entered into the configuration palette 412 (e.g., "Page 3").
- Figure 24 is a flow chart 2400 of an example embodiment for creating and maintaining a compound widget.
- a graphical development environment 400 is provided depicting a representation of one or more pages and a plurality of user-selectable data-capable widgets, each widget including one or more graphical display characteristics (e.g., sub-components) and a computer-executable functional characteristic.
- a first instruction is received to create a compound widget from a plurality of selected widgets.
- the selection could be effected by dragging an input device such as a mouse across the desired widgets to create a selection group 2010.
- Other methods of selecting widgets for inclusion in a compound widget could be used as well.
- the instruction to create the compound widget may be provided in any number of ways.
- a "click" on an input device having input buttons may display a menu from which the designer may select a menu item entitled “Create Compound Widget.”
- the designer may access the "Widget” drop-down menu in the menus 402 toolbar, and similarly select a menu item entitled “Create Compound Widget” from the list of menu items in the drop-down menu.
- Other methods could be used as well.
- a second instruction is received to place (e.g., instantiate) the compound widget a plurality of times in the representation of the one or more pages in the stack.
- the creation of the compound widget may also create the first instance of the compound widget in the stack.
- the creation of the compound widget may only add a corresponding first-class widget in the widget palette 410, and not create an instance of the compound widget in the stack, such as compound widget 2302 in Figure 23, perhaps requiring further instances to be created by placing a compound widget from the widget palette 410 to the application workspace 414.
- Other methods of creating multiple instances of the compound widget are possible as well.
- an update is detected to one of the shared characteristics of one of the placed compound widgets.
- the update may be a change of the color of the shared color widget option 2208 of the "Search Sports Scores" compound widget from “Red” to "Blue.”
- the update to the shared characteristic is propagated to each of the other instances of the compound widget. For example, this update is propagated to each of the other instantiated "Search Sports Scores" compound widgets, such as the second instantiated "Search Sports Scores" compound widget 2304.
- the block 2408 may entail storing the change to the compound widget at the application model datastore 102, which may cause instantiated copies of the "Search Sports Scores" compound widget to also be changed in other applications that reference the application model and/or compound widget that at the application model datastore 102.
- versioning can be applied so that other designers can subscribe to a particular version of the application model and/or compound widget stored in the application model datastore 102, such that updates to shared characteristics in one instance of the compound widget do not cause problems in other instances of the compound widget.
- the designer making the change to the shared characteristic may have control over whether to apply the update to the current version of the compound widget, or increment the version of the compound widget prior to applying the change.
- Designers subscribed to a particular version of the compound widget may be notified, or may be able to determine, that an updated version is available. The subscribed designers could then, perhaps after reviewing notes regarding the changes made to the compound widget, determine whether to update their own instances of the compound widget to the newest version.
- the development environment may provide one or more ways of sharing compound widgets between designers of a cloud-based application.
- compound widget definitions may be exported via the "Widget" drop-down menu in the menus 402 toolbar, and transmitted to another designer by, for example, e-mail, instant message, or some other mechanism.
- a menu option may provide the designer with access to a central repository of compound widgets, perhaps stored at server 101, or at some other remote computing device. Similarly, the designer may access the remote repository and select compound widgets to download and add to the widget palette 410, which may then be stored within the development environment 400 and/or application model datastore 102 for use in designing current or future applications.
- a common database of shared widgets may be maintained to which all instances of the cloud-based application have access, and to which designers can "subscribe" to receive notifications of updates and/or modifications to particular shared widgets.
- subscribed designers may be notified within their version of the design environment.
- automatic layout tools may be used to simplify the process of determining layout relationships between widgets, groups of widgets, and/or edges of the screen.
- Traditional tools use explicit layout managers to specify how the components of the user- interface (UI) align with one other and to the application window in which they are currently displayed.
- Layout managers are a complex abstraction that can be difficult to learn and hard to combine to achieve a desired layout. They typically require a designer to draft textual descriptions of relationships between different elements of the UI components in view of unknown and/or changing window sizes. Creating such rules places a significant burden on the designer.
- the disclosed automatic layout tools can be used to aid the designer in layout of elements of a cloud-based application as the designer places widgets, and can also be used to determine relationships between widgets that help an execution platform determine how to render a page of widgets when the screen is first drawn, and/or when it is re-sized.
- the first of these tools to be discussed is a smart alignment tool, and the second is an implicit layout specification tool.
- the smart alignment tool aids the designer in aligning widgets during the design phase (e.g., in the design mode 302 of Figure 3).
- the development environment 400 may align widgets dragged and dropped into the application workspace 414 to a visible or invisible grid.
- the (x,y) coordinates of the widget may be set to a nearest point on the grid (for example, a 100x100 grid relative to where the widget is placed by the designer).
- Figure 25 illustrates an example group of widgets that have been instantiated in the application workspace 414 by dragging and dropping three text field widgets (e.g., consisting of label and text field graphical display sub-components) and two button widgets (e.g., consisting of border and label graphical display sub-components) from the widget palette 410. Additionally, the settings of these widgets have been populated.
- three text field widgets e.g., consisting of label and text field graphical display sub-components
- two button widgets e.g., consisting of border and label graphical display sub-components
- a widget 2504 is a text field widget populated with the label "Name”
- a widget 2506 is a text field widget populated with the label “Age”
- a widget 2508 is a text field widget populated with the label “Date of birth”
- a widget 2510 is a button widget with a label name populated with the text string “Cancel”
- a widget 2512 is a button widget with a label name populated with the text string "Ok.”
- Each of these widgets has been selected via an input selection process, illustrated in Figure 25 as a dashed selection line box 2514 created, perhaps, by dragging a cursor across the selection of the first-class widgets 2504-2512.
- the selection of the first-class widgets 2504-2512 may result in a Crosshatch, highlight, change in color, or other mechanism applied to the first-class widgets 2504-2512 to provide visual feedback to the designer of the selected first-class widgets that will form a part of a "group of widgets.”
- a group of widgets may be a designer-defined group that indicates that the members (or sub-components) of the selected group are intended to have some relationship between them.
- the widgets 2504-2512 may form part of a "Personal Information Data Entry" tool that retrieves user information to use in a data lookup or, perhaps, as part of a method to determine whether a user is of a proper age to further access the designed application. Other uses are possible as well.
- the grouping of the widgets 2504-2512 lets the development environment 400 know that it should pay particular attention to the selected widgets (and not widgets outside of the selection, which may exist but are not shown in Figure 25) in determining an alignment between the selected widgets. Additionally, knowledge of widget groupings may be used by the implicit layout tool, discussed further below, in determining how to re-arrange widgets when the page screen or window, on which the application is being rendered, changes.
- the designer may select the widgets 2504-2512, select the
- selecting widgets 2504-2512 may automatically cause the
- the widgets 2504-2512 may not be automatically grouped until a subsequent "Align" operation is performed on the selected widgets.
- the designer may execute a smart-alignment process that will determine the type of widgets in the group, and align the widgets with respect to one another taking into account knowledge of the sub-components of each widget.
- An instruction to execute the smart-alignment process may be provided by the designer in any number of ways.
- a "click" on an input device having input buttons may display a menu from which the designer may select a menu item entitled “Align Grouped Widgets.”
- the designer may access the "Widget” drop-down menu in the Menus 402 toolbar, and similarly select a menu item entitled “Align Grouped Widgets" from the list of menu items in the drop-down menu.
- Other methods could be used as well.
- Figure 25 illustrates a rough positioning of the five widgets, meant to model the positioning of the widgets after a designer imprecisely drags the widgets into the application workspace 414 from the widget palette 410.
- Figure 26 illustrates one aligning process, which may be executed by an automatic layout tool to align widgets on a screen.
- the tool can use a "right, left, or center” alignment to left- align widgets along a vertical line on the left side of the screen, right-align widgets along a vertical line on the right side of the screen, or center-align widgets along a vertical line at the center of the screen.
- a left-align process is applied to selected widgets 2604-2612, without using knowledge of the most significant graphical display subcomponents of the selected widgets 2604-2612, a visually undesirable arrangement of user interface elements results.
- the smart-alignment tool can obtain information about the first- class widgets dragged from the widget palette 410 that informs the tool of the most significant graphical display sub-component border in each widget, and use this information, perhaps along with information regarding the dimensions of a designer-provided selection 2614, to automatically and intelligently align the selected widgets.
- This information may already be set in widgets provided by the creator of the development environment 400, or, as disclosed above, may be set by a designer of additional widgets such as compound widgets.
- Such information may be stored in widget metadata, and made available to the development environment 400 upon loading or instantiation of each widget.
- the information may be accessible via some other manner, such as a separate list or database of widget parameters available locally or at a remote computing device. Other possibilities exist as well.
- information regarding the border of the most significant graphical display subcomponent may also be defined within the first-class widget.
- the text box may be defined as the most significant graphical display subcomponent of the text field widget, as detailed above with respect to the example set forth in Figure 22.
- the left-side border of the text box may be defined as the most significant graphical display sub-component of the text field widget.
- a checkbox widget may include a square check-box and a label (adjacent the checkbox in the vertical or horizontal direction). In the event the label appears to the left of the check-box, the square check-box may be identified as the most significant graphical display sub-component, and the left-side border of the square check-box identified as the most significant graphical display sub-component border.
- each widget may contain more than one identified most significant graphical display sub-component border, to allow for alignment in both the horizontal and vertical direction.
- the top-border of the square check-box may be additionally or alternatively indicated as a most significant graphical display sub-component border of the checkbox widget to allow automatic relative vertical alignment of the horizontally-disposed check-box widgets by the development environment 400.
- compound widgets created in accordance with the above may have most significant graphical display sub-component and most significant graphical display sub-component border information set by the designer, and available for the development environment 400 to use in aligning compound widgets with one another, with non-compound widgets, and with groups of widgets. Other possibilities exist as well.
- Figure 27 illustrates an example of an automatic alignment process executed by the smart-align process having access to most significant graphical display sub-component of widgets 2704-2712.
- the widgets 2704-2708 identify the text box as their most significant graphical display sub-component, and the left-side of the text box as their most significant graphical display sub-component.
- the widgets 2710 and 2712 identify their most significant graphical display sub-component as the outer border, and their most significant graphical display sub-component border as the right side of the border (and perhaps the bottom-side of the border for vertical alignment).
- such most significant graphical display sub-component may not be provided for buttons, but instead may be automatically inferred by the smart-align tool once the type of widget (button) is determined by the smart-align tool.
- the smart-align tool may align the widgets 2704- 2708 to ensure that an even amount of white-space is included between the widgets in the vertical direction.
- the smart alignment tool may calculate a total amount of space between the top of the top-most widget 2704 and the bottom of the bottom- most widget 2708, and redistribute the total amount of free space evenly in the vertical direction. A similar white space redistribution process could be applied to horizontally-aligned widgets.
- a variable set by a designer or the development environment 400 may determine a desired inter-widget white space, and the smart alignment tool may apply the white space requirement automatically between the selected widgets (all selected widgets, or just the selected widgets of the same type, among other possibilities).
- the smart align tool may utilize the most significant graphical display sub-component and most significant graphical display subcomponent border information stored in the widgets 2710 and 2712, and right-align them to the right-most side of the selection 2702 dimensions.
- the smart-align tool may determine a right-most position of the remaining widgets within the selection 2702 (e.g. the widgets 2704-2708), and align a right-most side of the widgets 2710 and 2712 with the right-most side of the widgets 2704-2708. In the example of Figure 27, this rule would shift the widgets 2710 and 2712 slightly to the left.
- the smart alignment tool may be configured to locate all buttons in a grouped selection that are on approximately the same horizontal axis, automatically align them among one another by their middle points, and then right-align them to the right-most edge of the selection 2702 or the right-most edge of the right-most widget (besides the buttons) in the selection, without considering most significant graphical display sub-component or most significant graphical display sub-component border information that may be available with respect to the button widgets. Applying such a process to the buttons 2610 and 2612 in Figure 26 would result in an arrangement of buttons similar to that shown by buttons 2710 and 2712 in Figure 27.
- the alignment information generated by the smart-align tool may be stored in the development environment 400 and/or stored in the application model datastore 102.
- FIG. 28 is a flow chart according to an example method 2800 for aligning widgets within a grouping in accordance with the currently disclosed alignment method.
- a most significant graphical display sub-component is determined for each widget in a selection or perhaps on a page in the stack. This information could be stored in the development environment 400, the application model datastore 102, or in widget or compound widget metadata.
- a respective most significant graphical display sub-component border is determined for each widget in a selection or perhaps on a page in the stack.
- This information could be stored in the development environment 400, the application model datastore 102, or in widget or compound widget metadata.
- a grouping relationship between each of the widgets is determined. The grouping relationship could be based on a selection of widgets by a designer, or the existence of the widgets on a same page of the application stack, among other possibilities.
- the development environment 400 may create additional sub-groupings within a designer- selected group or within a page. For example, referring to Figure 27, the development environment may create a sub-group of the widgets 2704-2708 as related widget types despite the fact that the selection 2702 also included widgets 2710 and 2712.
- sub-groups may be selected based on similar most significant graphical display sub-component and/or most significant graphical display sub-component border information and aligned relative to one another based on such characteristics.
- the smart alignment tool may align the widgets in each group based on the most significant graphical display sub-component and most significant graphical display subcomponent border information for each widget in the group.
- the implicit layout specification tool may aid the designer by automatically analyzing relationships between widgets, groups of widgets, and perhaps screen edges, and determine how the spacing between these elements should be modified during the preview mode 304 and/or run mode 306 to more intelligently display the designed application on an ever varying number of different screen and window sizes.
- an implicit layout algorithm is applied to a page in the stack to automatically determine whether widgets, groups of widgets, and/or edges of the screen or window should have a proportional or a fixed relationship (if any) to one another.
- Figure 29 is a flow chart describing one example of such a method 2900.
- a first set of connections is identified including (i) each connection between each pair of widgets that do not belong to a group of widgets, (ii) each connection between each group of widgets and each widget that does not belong to a group of widgets, and (iii) each connection between groups of widgets.
- the first set may be stored as a comma separated value (CSV) list, a graph, or any other representation capable of identifying such links.
- the block 2902 may also include identifying connections between widgets and first and second edges of the page, and between groups of widgets and first and second edges of the page.
- a default weight is assigned to each connection in the first set of connections identified in the block 2902.
- a default weight may be a rational number between 1 and 10, such as 3.0.
- the default weight may be some other integer, decimal, fractional, real, or imaginary value.
- each default weight in the first set is raised or lowered dependent upon whether the widget in question is part of a group or is not part of a group. If the widget is part of a group, the default weight is raised, otherwise, it is lowered (or vice versa, depending on the implementation). For example, if the default weight is 3.0 and the widget is part of a group, the connection weight may be raised by 1.0 (approximately 1/3 of the default weight). Otherwise, if the widget is not part of a group, the weight may be lowered by 0.6 (approximately 1/5 of the default weight). Other weighting values could also be applied.
- the block 2906 may also include raising the default weight of each connection in the first set dependent upon whether one end of the connection is connected to the first or second edge of the page, assuming that such connections were identified in the block 2902. For example, if one of the connections is attached to a page edge, the connection weight may be raised by, for example, 0.8 (approximately 4/15 of the default weight). Other weighting values could also be applied.
- a distance multiplier is applied to each connection in the first set relative to the lay-out distance between each endpoint in the connection.
- the weight of each connection may be divided by the square root of the lay-out distance.
- a cubed root may be used as the distance multiplier. Other possibilities exist as well.
- the calculated weight for each connection in the first set is compared to a threshold value to determine if there is a threshold minimum relationship between the end-points of the connection.
- the first threshold may be within the range of 0.7-0.9, such as 0.8.
- Other threshold values could alternatively be used, including other integer, decimal, fractional, real, or imaginary values. Connections in the first set that do not meet the first threshold value may be discarded and not considered any further (e.g., they will have neither a fixed nor proportional relationship). In one example, those connections having a calculated weight less than (or less than or equal to) the first threshold value may be discarded. Other relative relationships could be used as well.
- a second set of connections is identified including those from the first set that meet (or, in another embodiment, do not meet) the first threshold value.
- the weights of a connection in the second set are compared to a second threshold value to determine whether the connection should be one of a fixed or proportional distance connection.
- the second threshold value may be, for example, within the range of 1.0- 1.2, such as 1.1.
- Other threshold values could alternatively be used, including other integer, decimal, fractional, real, or imaginary values.
- connection if the second threshold is met, the connection is identified as a fixed-distance connection, and if the second threshold is not met, the connection is identified as a proportional-distance connection. In other embodiments, if the second threshold is met, the connection is identified as a proportional-distance connection, and if the second threshold is not met, the connection is identified as a fixed-distance connection. Connections that have a weight substantially equal to the threshold value could alternatively be identified as a proportional-distance connection or a fixed-distance connection.
- the connection may be identified as a fixed-distance connection at the block 2916.
- the connection may be identified as a proportional- distance connection at the block 2918.
- a development environment implicit layout tool can implicitly and automatically determine how widgets (and groups of widgets) on a page should be laid out relative to one another (on initial screen-layout or upon a resizing of the window by a user or designer), by taking into consideration the original layout by the designer, and the characteristics of the widgets with respect to one another, and/or the edges of the page. This process advantageously relieves the designer of explicitly specifying all such relationships and manually defining each relationship.
- a visual representation of the implicit layout results of the flow chart 2900 may be provided to the designer.
- Figure 30 illustrates an example of such a result in the development environment 400.
- the designer may use the visual representation to edit or fine-tune the constraints automatically determined during implicit layout generation.
- connections between widgets are visualized.
- a widget group 3002 including the widgets 2704, 2706, and 2708 from Figure 27, and a widget group 3008, including the widgets 2710 and 2712 from Figure 27, are illustrated.
- the widget group 3002 is shown connected to a first screen edge (the top edge) via a vertical constraint line 3004 and to a second screen edge (the left edge) via a horizontal constraint line
- the widget group 3002 is further connected to the widget group 3008 via a vertical constraint line 3010.
- the visual style of the constraint lines may be used to illustrate the type of line.
- the dashed vertical constraint line 3004 and horizontal constraint line 3006 may represent a proportional-distance connection
- the separately-styled vertical constraint line 3010 may represent a fixed-distance connection.
- each block may represent a processing of information and/or a transmission of information in accordance with example embodiments.
- Alternative embodiments are included within the scope of these example embodiments.
- functions described as blocks, transmissions, communications, requests, responses, and/or message may be executed out of order from that shown or discussed, including substantially concurrent or in reverse order, depending on the functionality involved.
- more or fewer blocks and/or functions may be used with any of the ladder diagrams, message flows, and flow charts discussed herein, and these ladder diagrams, message flows, and flow charts may be combined with one another, in part or in whole.
- a block that represents a processing of information may correspond to circuitry that can be configured to perform the specific logical functions of a herein-described method or technique.
- a block that represents a processing of information may correspond to a module, a segment, or a portion of program code (including related data), and the program code may include one or more instructions executable by a processor for implementing specific logical functions or actions in the method or technique.
- the program code and/or related data may be stored on any type of computer readable medium such as a storage device including a disk or hard drive or other storage medium.
- the computer readable medium may also include non-transitory computer readable media such as computer-readable media that stores data for short periods of time like register memory, processor cache, and random access memory (RAM).
- the computer readable media may also include non-transitory computer readable media that stores program code and/or data for longer periods of time, such as secondary or persistent long term storage, like read only memory (ROM), optical or magnetic disks, compact-disc read only memory (CD-ROM), for example.
- the computer readable media may also be any other volatile or non-volatile storage systems.
- the computer readable medium may be considered a computer readable storage medium, for example, or a tangible storage device.
- a block that represents one or more information transmissions may correspond to information transmissions between software and/or hardware modules in the same physical device. However, other information transmissions may be between software modules and/or hardware modules in different physical devices.
Abstract
Systems, devices, and methods for providing a development environment for cloud-based, data-driven software applications are presented. On a client device, an execution platform may provide a graphical user interface (GUI) through which a software designer can visually develop an application. The execution platform may represent the application as an application model and a data model. The application model may contain information related to pages and program logic that make up the application, and the data model may contain information stored and used by the application. Both the application model and the data model may be updated, in near real-time, as the software designer makes changes to the application.
Description
Development Architecture for Cloud-Based Applications
BACKGROUND
[0001] Cloud-based computing generally refers to networked computer architectures in which application execution and storage are divided, to some extent, between client and server devices. In contrast to a predominately client-based or server-based application, a cloud-based application may store copies of data and/or executable program logic at remote server devices, while allowing client devices to download at least some of this data and program logic as needed for execution at the client device. An advantage of this approach is that the downloaded data and program logic can be tailored to the capabilities of the specific client device (e.g., a personal computer, tablet, or mobile phone) accessing the cloud based application.
[0002] An example class of application that can exploit the benefits of cloud-based computing is data-driven web-based services. Included in this class of applications are, for example, email, office productivity suites, blogs, online stores, games, as well as other types of networked applications. However, the development of these data-driven cloud-based applications often requires complex and time consuming programming and database design.
[0003] Attempts have been made to simplify the development of cloud-based applications. For example, rapid application development (RAD) tools have been offered.
RAD tools are typically integrated development environments that assist a designer (e.g., a software architect and/or a programmer) in developing software applications by generating program logic based on high-level descriptions of what the designer wants to achieve.
However, existing RAD tools used to develop data-driven cloud-based applications require designers to be proficient in computer programming and know how to design and manage databases. Additionally, these existing RAD tools often take the form of large, complex client-based applications that a designer must download and install on his or her computer.
Furthermore, once the designer completes a version of the cloud-based application, the designer still has to move the cloud-based application to a web site for testing and public use.
SUMMARY
[0004] In order to simplify rapid application development (RAD) tools for cloud- based data-driven application, systems, devices, and methods for a software architecture and development environment that facilitates rapid development of data-driven cloud-based applications are presented herein. Through the use of graphical user interface (GUI) functions, individuals with little or no computer programming experience can develop dynamic web sites with persistent data storage. However, there is no limit to the complexity of web sites that could be developed with these tools. Thus, even more experienced designers could find these development environment GUI functions useful and time-saving.
Additionally, the same software architecture may be used for both development and execution of cloud-based applications in order to minimize any discrepancies between the interfaces and functions as developed by their designer and those provided to the end-user application executing in the cloud.
[0005] The software architecture may be divided into components that are placed in a client software platform (e.g., a web browser) and those that are placed in a cloud-based server device. Designer interactions with the software architecture may occur via a client- based execution platform that may include a development environment GUI. This development environment GUI allows cloud-based applications to be developed in a what- you-see-is-what-you-get (WYSIWYG) fashion.
[0006] Each cloud-based application may be represented as a "stack" of related pages.
Each page may contain metadata (e.g., one or more names, keywords, identifiers, etc.), one or more widgets (each of which may be associated with a size, a spatial location, a color, a font, an image, an identifier, an action, and/or other characteristics), and a set of scripts. From design mode, the designer may drag and drop widgets on a page, assign functions to these widgets, and associate the page metadata, widgets, and scripts with one another to form a
cloud-based application. The client platform may represent this information, as well as any other information associated with each page, in an abstraction called the application model.
[0007] Data associated with the cloud-based application may be stored in a database model. The database model may consist of a database schema including at least one database table per page, with each unit of page metadata or widget associated with an automatically typed field in the database table. The database model can also be extended by the scripts. Advantageously, the designer can create and update the database substantially in real-time by using the development environment GUI to modify the cloud-based application. Further, the designer need not be aware of the database or its structure during cloud-based application development.
[0008] When developing the cloud-based application, the designer may use a design mode of the execution platform. The execution platform, in turn, may periodically or from time to time contact the server device to update representations of the application model and/or the data model that are stored at the server device. The server device may
automatically store copies of the application model and data model. Thus, a cloud-based application's user interface design and program logic (as represented in the application model) and database schema and content (as represented in the database model) may be stored on the server device. When needed by a client device, the server device may deliver copies of at least part of these models to the execution platform on the client device for interpretation and/or execution.
[0009] When the designer wishes to test the cloud-based application, the designer may switch from the design mode to a preview mode. Unlike traditional software development tools, the designer may not be required to first compile, link, and distribute the cloud-based application before previewing its operation in the preview mode. Since the application model and data model are automatically stored on the server device, the designer
can switch back and forth from design mode to preview mode while the cloud-based application is running. Any changes made in design mode may be reflected in near real-time in the previewed cloud-based application.
[0010] The designer can further publish the cloud-based application to a public or private Uniform Resource Locator (URL) so that users can access the published cloud-based application in run mode. Like in preview mode, changes made in design mode may be subsequently reflected in near real-time in instances of the cloud-based application that are in run mode.
[0011] Accordingly, in an example embodiment, a computing device may display, via a graphical development environment, a user interface of an application. The graphical development environment may have access to an application model and a data model. The application model may include program logic of the application and a representation of the user interface of the application, while the data model may include a database schema for storing data used by the application.
[0012] Perhaps via the graphical development environment, the computing device may receive a change to the application. In response to the change, the computing device may apply modifications to at least one of the application model and the data model to incorporate the change. Then, the computing device may automatically transmit a representation of at least some of the modifications to a server device for storage.
[0013] In another example embodiment, the cloud-based application's designer- created application GUI may form the basis for an automatically created database schema for the cloud-based application. Thus, a computing device may display at least part of the application GUI. The application GUI may include a page, and the page may include a widget. The computing device may create a database schema, based on the application GUI, such that the database schema includes data defining a relationship between the page and the
widget. For instance, the database schema may include a database table for the page, and the database table may include a field for the widget.
[0014] In still another example embodiment, a computing device may receive a cloud-based application. The cloud-based application may include a stack with one or more pages for a user interface for the application and a database. The computing device may execute the application by locating a compiled script for the application based on a global identifier assigned to the compiled script. The global identifier may include an application identifier for specifically identifying the application in a plurality of applications and an object identifier for specifically identifying an object of a computational model. The computational model may be either the stack or the database. The compiled script may include a scripting language instruction for the application, and may inject the compiled script into the application. Then, the injected script may be executed as part of the application to perform at least one transaction of the computational model.
[0015] In an additional example embodiment, a script containing scripting language instructions may be created via a computing device using a guided script editor. The guided script editor may include a statement control, a variable control, and a script area. The guided script editor may be configured to generate one or more conversational statements of a non- programming language that are equivalent to the generated scripting language instruction. The generated scripting language instruction may be added to the script of scripting language instructions. The script of scripting language instructions, including the added scripting language instruction, may be stored via the computing device.
[0016] In a further example embodiment, an editor window may be displayed via a computing device. The editor window may include an editing area and an assistance button.
The editor window may be configured to allow for editing a script including one or more scripting language instructions. The computing device may determine that the assistance
button has been selected by the designer to request assistance with a particular scripting- language instruction, and an assistance display may be displayed as a result. The assistance display may be related to the particular scripting language instruction. Input may be received at the computing device via the assistance display and the particular scripting language instruction may be generated in response to the received input. The particular scripting language instruction may be added to the script, and the script may be stored.
[0017] In another example embodiment, a graphical development environment may depict a representation of one or more pages and a plurality of widgets, each of the widgets including one or more graphical display sub-components (e.g., visual characteristics) and a computer-executable functional characteristic. Responsive to receiving a first instruction, a compound widget may be created from a plurality of selected widgets, and may incorporate one or more graphical display sub-components of each selected widget and one or more functional characteristics of each selected widget. Responsive to receiving a second instruction, the compound widget may be instantiated a plurality of times in the
representation of the one or more pages. Each of the instantiated compound widgets includes at least one characteristic that is shared across all instances of the compound widget such that an update to one instantiation of the compound widget updates all instantiations of the compound widget. Each of the instantiated compound widgets may also include at least one characteristic that is specific to a particular instance of the compound widget. When an update to the widget is received, a determination may be made of whether the update is to a shared characteristic (and thus might be propagated to all other instances) or whether the update is to a specific characteristic (and thus might not be propagated to all other instances).
[0018] In still another example embodiment, a graphical development environment may depict a representation of one or more pages and a plurality of widgets, each widget including one or more graphical display sub-components and a computer executable
functional characteristic. Layout tools may be provided to aid a designer in laying out and defining inter-relationships of widgets (including compound widgets) and groups of widgets for each page. In one example, a most significant sub-component border determination may be made for each widget. Then, a grouping relationship determined between each of a plurality of the widgets. Finally, for each widget in each determined group, the widgets may be aligned based on the determined most significant sub-component border of each widget in the group.
[0019] In an additional example embodiment, a first set of connections is identified.
This first set may include (i) connections between pairs of widgets that do not belong to a group of widgets, (ii) connections between groups of widgets and widgets that do not belong to a group of widgets, and (iii) connections between groups of widgets. Each connection in the first set is then assigned a default connection weight. Each connection that attaches to a group of widgets, as opposed to a single widget, has its relative assigned weight raised. Then, a multiplier is applied to each connection in the first set relative to a distance that the connection travels. The resulting weights of the connections in the first set are compared to a first threshold value, and a second set of connections identified including those connections from the first set having a weight that meets the first threshold (or, in another embodiment, does not meet the first threshold). The remaining connections in the second set are then compared to a second threshold value. Based on the relationship between the weight of each connection in the second set and the second threshold value, each connection in the second set is stored as either one of (i) a fixed distance connection that does not vary based on a size of the screen or window on which the representation of the page is rendered or (ii) a proportional distance connection that does vary based on a size of the screen or window on which the representation of the page is rendered.
[0020] These and other aspects and advantages will become apparent to those of ordinary skill in the art by reading the following detailed description, with reference where appropriate to the accompanying drawings. Further, it should be understood that this overview and other description throughout this document is merely for purposes of example and is not intended to limit the scope of the invention as claimed.
BRIEF DESCRIPTION OF THE DRAWINGS
[0021] Figure 1 depicts a distributed computing architecture in accordance with an example embodiment.
[0022] Figure 2A is a block diagram of a computing device in accordance with an example embodiment.
[0023] Figure 2B depicts a cloud-based server system in accordance with an example embodiment.
[0024] Figure 3 is a block diagram of a distributed software architecture, in accordance with an example embodiment.
[0025] Figure 4 depicts a development environment in accordance with an example embodiment.
[0026] Figure 5 is a ladder diagram in accordance with an example embodiment.
[0027] Figure 6 is a ladder diagram in accordance with another example embodiment.
[0028] Figure 7 is a flow chart in accordance with an example embodiment.
[0029] Figure 8 depicts a development environment in accordance with an example embodiment.
[0030] Figure 9 is flow chart in accordance with an example embodiment.
[0031] Figure 10 depicts a script compilation in accordance with an example embodiment.
[0032] Figure 11 is a ladder diagram in accordance with an example embodiment.
[0033] Figure 12 is flow chart in accordance with an example embodiment.
[0034] Figure 13 is flow chart in accordance with another example embodiment.
[0035] Figure 14 depicts a window in accordance with an example embodiment.
[0036] Figure 15A depicts a dialog in accordance with an example embodiment.
[0037] Figure 15B depicts a dialog in accordance with another example embodiment.
[0038] Figure 15C depicts a window for an enhanced standard editor in accordance with another example embodiment.
[0039] Figure 16A depicts a window for an enhanced standard editor in accordance with another embodiment.
[0040] Figure 16B depicts a dialog in accordance with another example embodiment.
[0041] Figure 16C depicts a window in accordance with another example embodiment.
[0042] Figure 17A depicts a guided script editor in accordance with an example embodiment.
[0043] Figure 17B depicts a dialog in accordance with another example embodiment.
[0044] Figure 17C depicts a guided script editor in accordance with another example embodiment.
[0045] Figure 17D depicts a guided script editor in accordance with another example embodiment.
[0046] Figure 17E depicts a guided script editor in accordance with another example embodiment.
[0047] Figure 17F depicts a dialog in accordance with another example embodiment.
[0048] Figure 18 is a flow chart in accordance with an example embodiment.
[0049] Figure 19 is a flow chart in accordance with another example embodiment.
[0050] Figure 20 depicts a development environment in accordance with an example embodiment.
[0051] Figure 21 depicts an example option dialog box in accordance with an example embodiment.
[0052] Figure 22 depicts an example completed option dialog box in accordance with an example embodiment.
[0053] Figure 23 depicts an example development environment in which a compound widget has been instantiated twice, in accordance with an example embodiment.
[0054] Figure 24 is a flow chart in accordance with an example embodiment.
[0055] Figure 25 depicts a development environment in accordance with an example embodiment.
[0056] Figure 26 depicts a development environment in accordance with another example embodiment.
[0057] Figure 27 depicts a development environment in accordance with another example embodiment.
[0058] Figure 28 is a flow chart in accordance with an example embodiment.
[0059] Figure 29 is a flow chart in accordance with another example embodiment.
[0060] Figure 30 depicts a development environment in accordance with an example embodiment.
DETAILED DESCRIPTION
[0061] The following detailed description describes various features and functions of the disclosed systems, devices, and methods with reference to the accompanying figures. However, the illustrative embodiments described herein are not meant to be limiting. It will be readily understood that certain aspects of the disclosed systems, devices, and methods can be arranged and combined in a wide variety of different configurations, all of which are contemplated herein.
1. Distributed Computing Architecture Overview
[0062] A distributed computing system may allow two or more distributed or co- located computing devices to coordinate their activities in order to achieve a particular goal or result. This coordination may occur via a network (e.g., a local area network, a wide area network, and/or the Internet) or some other form of communicative coupling. With the continued reduction in costs of computer storage (e.g., random access memory, solid state memory, and hard drives) and always-on, networking computing devices (e.g., personal computers (PCs), laptops, tablet devices, and cell phones), new techniques can be employed to take advantage of distributed computing systems.
[0063] In particular, cloud-based computing is a term that can refer to distributed computing architectures in which the data and program logic for a cloud-based application are shared between one or more client devices and server devices on a near real-time basis. Parts of this data and program logic may be dynamically delivered, as needed or otherwise, to various clients accessing the cloud-based application. Details of the architecture may be transparent to the users of client devices. Thus, a PC user accessing a cloud-based application may not be aware that the PC downloads program logic and/or data from the server devices, or that the PC offloads processing or storage functions to the server devices.
[0064] Advantageously, the cloud-based application may execute primarily or entirely in a web browser already installed on the client device. Thus, the user may not need to download, install, and manage client software for the cloud-based application in a traditional manner. The web browser may be a standard web browser that is capable of executing program logic consistent with one or more scripting and/or markup languages such as the JAVASCRIPT® scripting language, the HyperText Markup Language (HTML) version 3, 4, and/or 5, the extended Markup Language (XML), and so on. Alternatively or additionally, the web browser could be capable of supporting other scripting languages and/or markup languages.
[0065] Some advantages of a cloud-based application can be illustrated in the following example of a cloud-based email application. In this example, a user with an email account at a service provider may be able to log on to that email account from a PC web browser. As part of the process of logging on, or soon thereafter, the web browser can contact a cloud-based server device. This server device stores the user's email spool (e.g., the user's email messages, including new messages and old messages stored for potential later use). The server device may also store the user's email settings, such as the email application's configuration options that the user has selected.
[0066] The web browser may download, from the server device, at least some of the messages in the user's email spool. The web browser may also download, from the server device, a portion of the email application's program logic and settings so that the web browser can display the email messages according to user-selected settings. For example, the web browser, in accordance with user-selected settings, may display the user's email folders on the left side column of the browser's window, and display a listing of the email messages in main portion of the browser's window. When the user selects one of these email messages for display, the web browser may execute (or dynamically download and then execute)
program logic to display the selected email message. If the selected email message has not already been downloaded, the web browser may execute program logic to download this message from the server device. If the user composes and sends an email message, the web browser may transmit a copy of the message to the server device, and the server device may, in turn, transmit the message towards its destination. The web browser may also store a copy of the message, locally or remotely, in a folder for sent mail.
[0067] The same user may also access the email application from his or her cell phone. The cell phone may also download, from the server device, application program logic and data in order to facilitate this access. However, cell phones usually have smaller screens than PCs, and usually access networks using lower-capacity wireless links than PCs (e.g., compared to wired links). Thus, the server device may determine that a cell phone is communicating with the server device, and consequently may transmit a different version of the program logic and data to the cell phone than was transmitted to the PC. This version of the program logic may use fewer communication resources (e.g., less network capacity) between the cell phone and the server device and/or have a simpler user interface designed for the cell phone's smaller screen and user interface.
[0068] An advantage of cloud-based applications, such as this example email application, is that copies of the program logic and data are stored at the server device (e.g., in the cloud). Thus, the user can switch between client devices without having to manually download and configure a client application at each client device from which the user accesses the cloud-based application. For example, the user may be able to access the email application from any device with a web browser. Further, if the user's client device is lost, stolen, or becomes unusable, the user's email is still stored at the server device, and can be accessed from any other supported client device. Thus, the user may be able to use any PC- based operating system (e.g., MICROSOFT WINDOWS®, LINUX®, or MAC OS®), any
mobile operating system (e.g., IPHONE® IOS, ANDROID®, WINDOWS MOBILE®, or BLACKBERRY® OS), and/or any other computing platform now known or developed in the future to access cloud-based applications without fear of losing their data.
[0069] Additionally, the program logic that executes on the client device may enable offline access to the cloud-based application. Thus, for example, the user could download the email application's program logic and data, and then disconnect from the network(s) connecting the client device to the server device (e.g., the Internet and/or any other intervening network(s) used to access the server device). Then the user could use the email application for some time while in the offline mode. Offline mode use may allow, for example, filing of email messages in folders, replying to email messages, composing new email messages, and deleting email messages. When the client device is once again able to communicate with the server device, the email application program logic on the client device may synchronize the changes with the server device. Thus, the client device may inform the server device of the filed, replied to, composed, and/or deleted email messages. Then, the server device may update its copy of this data accordingly.
[0070] The email application described above is just one example of a cloud-based application. Other types of cloud-based applications may include office productivity suites, blogs, online stores, and/or multimedia applications. Given the distributed nature of cloud- based applications, various types of functionality included in these applications, or used to facilitate the design and execution of these applications, may also be distributed across multiple software modules and/or hardware platforms. To illustrate such a possible arrangement, Figure 1 depicts a distributed computing architecture in accordance with an example embodiment.
[0071] In Figure 1, a server device 101 is configured to communicate, via a network
106, with client devices 104a, 104b, and 104c. The server device 101 also has access to an
application model datastore 102 and a data model datastore 103. The server device 101 may communicate with the application model datastore 102 and/or data model datastore 103 via a network 106, as shown. The network 106 may correspond to a local area network, a wide area network, a corporate intranet, the public Internet, combinations thereof, or any other type of network(s) configured to provide communication between networked computing devices. Alternatively, the application model datastore 102 and/or data model datastore 103 may be co-located with the server device 101, or may be accessible via a network separate from the network 106.
[0072] Although Figure 1 only shows three client devices, cloud-based server devices may serve hundreds or thousands of client devices. Moreover, the client devices 104a, 104b, and 104c (or any additional client devices) may be any sort of computing device, such as an ordinary laptop computer, desktop computer, network terminal, wireless communication device (e.g., a cell phone or smart phone), and so on. In some embodiments, the client devices 104a, 104b, and 104c may be dedicated to the design and use of cloud-based applications. In other embodiments, the client devices 104a, 104b, and 104c may be general purpose computers that are not necessarily dedicated to cloud-based applications.
[0073] Similarly, as discussed below in reference to Figure 2B, the server device 101 may include more than one computing device. Such a computing device may be based on PC hardware, rack-mounted hardware, blade-based hardware, or other types of hardware configurations.
2. Computing Device Architecture
[0074] Figure 2A is a block diagram of a computing device in accordance with an example embodiment. In particular, a computing device 200 shown in Figure 2A can be configured to perform one or more functions of the server device 101, application model datastore 102, data model datastore 103, and/or client devices 104a, 104b, and 104c. The
computing device 200 may include a user interface module 201, a network-communication interface module 202, one or more processors 203, and data storage 204, all of which may be linked together via a system bus, network, or other connection mechanism 205.
[0075] The user interface module 201 may be operable to send data to and/or receive data from external user input/output devices. For example, the user interface module 201 may be configured to send/receive data to/from user input devices such as a keyboard, a keypad, a touch screen, a computer mouse, a track ball, a joystick, and/or other similar devices, now known or later developed. The user interface module 201 may also be configured to provide output to user display devices, such as one or more cathode ray tubes
(CRT), liquid crystal displays (LCD), light emitting diodes (LEDs), displays using digital light processing (DLP) technology, printers, light bulbs, and/or other similar devices, now known or later developed. The user interface module 201 may also be configured to generate audible output(s), such as a speaker, speaker jack, audio output port, audio output device, earphones, and/or other similar devices, now known or later developed.
[0076] The network-communications interface module 202 may include one or more wireless interfaces 207 and/or wireline interfaces 208 that are configurable to communicate via a network, such as the network 106 shown in Figure 1. The wireless interfaces 207 may include one or more wireless transceivers, such as a Bluetooth transceiver, a Wi-Fi transceiver perhaps operating in accordance with an IEEE 802.11 standard (e.g., 802.11a,
802.11b, 802. l lg), a WiMAX transceiver perhaps operating in accordance with an IEEE
802.16 standard, and/or other types of wireless transceivers configurable to communicate via a wireless network. The wireline interfaces 208 may include one or more wireline transceivers, such as an Ethernet transceiver, a Universal Serial Bus (USB) transceiver, or similar transceiver configurable to communicate via a twisted pair wire, a coaxial cable, a fiber-optic link or other physical connection to a wireline network.
[0077] In some embodiments, the network communications interface module 202 may be configured to provide reliable, secured, and/or authenticated communications. For each communication described herein, information for ensuring reliable communications (e.g., guaranteed message delivery) can be provided, perhaps as part of a message header and/or footer (e.g., packet/message sequencing information, encapsulation header(s) and/or footer(s), size/time information, and transmission verification information such as cyclic redundancy check (CRC) and/or parity check values). Communications can be made secure (e.g., be encoded or encrypted) and/or decrypted/decoded using one or more cryptographic protocols and/or algorithms, such as, but not limited to, DES, AES, RSA, Diffie-Hellman, and/or DSA. Other cryptographic protocols and/or algorithms may be used as well or in addition to those listed herein to secure (and then decrypt/decode) communications.
[0078] The one or more processors 203 may include one or more general purpose processors and/or one or more special purpose processors (e.g., digital signal processors, application specific integrated circuits, etc.). The one or more processors 203 may be configured to execute computer-readable program instructions 206 that are contained in the data storage 204 and/or other instructions as described herein.
[0079] The data storage 204 may include one or more computer-readable storage media that can be read or accessed by at least one of the processors 203. The one or more computer-readable storage media may include volatile and/or non- volatile storage
components, such as optical, magnetic, organic or other memory or disc storage, which can be integrated in whole or in part with at least one of the one or more processors 203. In some embodiments, the data storage 204 may be implemented using a single physical device (e.g., one optical, magnetic, organic or other memory or disc storage unit), while in other embodiments, the data storage 204 may be implemented using two or more physical devices.
[0080] The data storage 204 may include computer-readable program instructions 206 and perhaps additional data. In some embodiments, the data storage 204 may additionally include storage required to perform at least part of the herein-described techniques and/or at least part of the functionality of the herein-described devices and networks.
3. Cloud-Based Servers, Application Model, and Data Model
[0081] The server device 101, application model datastore 102, and data model datastore 103 may be cloud-based devices that store program logic and data of cloud-based applications. In some embodiments, the server device 101, application model datastore 102, and data model datastore 103 may be a single computing device residing in a single computing center. In another embodiment, the server device 101, application model datastore 102, and data model datastore 103 may include multiple computing devices in a single computing center, or even multiple computing devices located in multiple computing centers located in diverse geographic locations. For example, Figure 1 depicts each of the server device 101, application model datastore 102, and data model datastore 103 residing in a different physical location.
[0082] In some embodiments, data stored at the server device 101, application model datastore 102, and/or data model datastore 103 may be encoded as computer readable information stored in tangible computer readable media (or computer readable storage media) and accessible by the client devices 104a, 104b, and 104c, and/or other computing devices. In some embodiments, the application model datastore 102 and/or data model datastore 103 may be a single disk drive or other tangible storage media, or for large cloud-based systems, the application model datastore 102 and/or data model datastore 103 may be implemented on multiple disk drives or other tangible storage media located at one or more diverse geographic locations.
[0083] Figure 2B depicts a cloud-based server system in accordance with an example embodiment. In Figure 2B, functions of the server device 101, application model datastore 102, and data model datastore 103 may be distributed among three computing clusters 209a, 209b, and 208c. The computing cluster 209a may include one or more computing devices 200a, cluster storage arrays 210a, and cluster routers 211a connected by a local cluster network 212a. Similarly, the computing cluster 209b may include one or more computing devices 200b, cluster storage arrays 210b, and cluster routers 211b connected by a local cluster network 212b. Likewise, the computing cluster 209c may include one or more computing devices 200c, cluster storage arrays 210c, and cluster routers 211c connected by a local cluster network 212c.
[0084] In some embodiments, each of the computing clusters 209a, 209b, and 209c may have an equal number of computing devices, an equal number of cluster storage arrays, and an equal number of cluster routers. In other embodiments, however, some or all of the computing clusters 209a, 209b, and 209c may have different numbers of computing devices, different numbers of cluster storage arrays, and/or different numbers of cluster routers. The number of computing devices, cluster storage arrays, and cluster routers in each computing cluster may depend on the computing task or tasks assigned to each computing cluster.
[0085] In the computing cluster 209a, for example, the computing devices 200a can be configured to perform various computing tasks of the server device 101. In one embodiment, the various functionalities of the server device 101 can be distributed among one or more of the computing devices 200a. For example, some of these computing devices may be configured to operate as a web server, and other computing devices may be configured to execute program logic defined by a cloud-based application. Still other computing devices of the computing cluster 209a may be configured to communicate with the application model datastore 102 and data model datastore 103. The computing devices
200b and 200c in the computing clusters 209b and 209c may be configured the same or similarly to the computing devices 200a in the computing cluster 209a.
[0086] On the other hand, in some embodiments, the computing devices 200a, 200b, and 200c each may be configured to perform different functions. For example, the computing devices 200a may be configured to perform one or more functions of the server device 101, the computing devices 200b may be configured to perform one or more functions of the application model datastore 102, and the computing devices 200c may be configured to perform one or more functions of the data model datastore 103.
[0087] The cluster storage arrays 210a, 210b, and 210c of the computing clusters
209a, 209b, and 209c may be data storage arrays that include disk array controllers configured to manage read and write access to groups of hard disk drives. The disk array controllers, alone or in conjunction with their respective computing devices, may also be configured to manage backup or redundant copies of the data stored in the cluster storage arrays to protect against disk drive or other cluster storage array failures and/or network failures that prevent one or more computing devices from accessing one or more cluster storage arrays.
[0088] Similar to the manner in which the functions of the server device 101, application model datastore 102, and/or data model datastore 103 can be distributed across the computing devices 200a, 200b, and 200c of the respective computing clusters 209a, 209b, and 209c, various active portions and/or backup/redundant portions of these components can be distributed across the cluster storage arrays 210a, 210b, and 210c. For example, some cluster storage arrays may be configured to store the data of the server device 101, while other cluster storage arrays may store the application model datastore 102, and/or data model datastore 103. Additionally, some cluster storage arrays may be configured to store backup versions of data stored in other cluster storage arrays.
[0089] The cluster routers 211a, 211b, and 211c in the computing clusters 209a, 209b, and 209c may include networking equipment configured to provide internal and external communications for the computing clusters. For example, the cluster routers 21 la in the computing cluster 209a may include one or more internet switching and/or routing devices configured to provide (i) local area network communications between the computing devices 200a and the cluster storage arrays 201a via the local cluster network 212a, and/or (ii) wide area network communications between the computing cluster 209a and the computing clusters 209b and 209c via the wide area network connection 213a to the network 106. The cluster routers 211b and 211c can include network equipment similar to the cluster routers 211a, and the cluster routers 211b and 211c can perform similar networking functions for the computing clusters 209b and 209b that the cluster routers 211a perform for the computing cluster 209a.
[0090] In some embodiments, computing tasks and stored data associated with server device 101, application model datastore 102, and/or data model datastore 103 can be distributed across the computing devices 200a, 200b, and 200c. The distribution of tasks and stored data may be based at least in part on (i) the processing requirements of the server device 101, application model datastore 102, and/or data model datastore 103 functions, (ii) the processing capabilities of the computing devices 200a, 200b, and 200c, (iii) the latency of the local cluster networks 212a, 212b, and 212c and/or of the wide area network connections 213a, 213b, and 213c, and/or (iv) other factors that may contribute to the cost, speed, fault- tolerance, resiliency, efficiency, and/or other design goals of the overall system architecture.
[0091] Additionally, the configuration of the cluster routers 211 a, 21 lb, and 211c can be based at least in part on the data communication requirements of the computing devices and cluster storage arrays, the data communications capabilities of the network equipment in the cluster routers 211a, 211b, and 211c, the latency and throughput of the local cluster
networks 212a, 212b, 212c, the latency, throughput, and cost of the wide area network connections 213a, 213b, and 213c, and/or other factors that may contribute to the cost, speed, fault-tolerance, resiliency, efficiency and/or other design goals of the system architecture. 4. Distributed Development Architecture
[0092] Figure 3 is a block diagram of a development architecture, in accordance with an example embodiment. In particular, Figure 3 shows a distributed software architecture
300 that can be used for efficient and rapid development of cloud-based applications. At a high level, the distributed software architecture 300 may include software components that reside on either a client device, such as one or more of the client devices 104a, 104b, and
104c, or on one or more cloud-based server devices. The cloud-based server devices may include multiple hardware components, and may be arranged according to the system depicted in Figure 2B, or in other ways.
4.1 Client Software Architecture
[0093] An execution platform 308, script callbacks 310, an application model 312, a database model 314, and a compiled scripts module 316 may reside on a client device. In some embodiments, some or all of these software components may execute within a web browser or some other type of client platform (e.g., an operating system). The application model datastore 102, data model datastore 103, and script compiler 318, as well as an authentication module 320, a dynamic feed module 322, a media handler module 324, and an email handler module 326 may reside on one or more cloud-based server devices.
Nonetheless, it is possible for any of these software components to be stored and/or execute on either a client device or on one or more cloud-based server devices.
[0094] Interactions with the distributed software architecture 300 may occur via the execution platform 308. To facilitate these interactions, the execution platform 308 may support multiple modes, such as a design mode 302, a preview mode 304, and a run mode
306. In the design mode 302, the execution platform 308 may visually present a GUI-based development environment. This development environment may allow a designer to develop cloud-based applications in a substantially what-you-see-is-what-you-get (WYSIWYG) fashion. Figure 4, discussed in more detail below, provides an example view of the design mode 302.
[0095] The preview mode 304 may allow the designer to at least partially execute a cloud-based application, and to view the executing cloud-based application similar to how a user would see it. In the preview mode 304, the cloud-based application can be tested and debugged before being released for general use. For example, the preview mode 304 may enable setting breakpoints in the cloud-based application and/or enable monitoring data during execution of the cloud-based application. The design mode 302 and preview mode 304 may be able to execute in parallel. Thus, a cloud-based application executing in the preview mode 304 may automatically be updated to reflect any changes made in the design mode 302 to the cloud-based application.
[0096] The run mode 306 may allow users to execute, or otherwise interact with, the cloud-based application. To establish the run mode 306, the designer may publish the cloud- based application for user access via a URL, perhaps a public URL on the Internet. As previously discussed with respect to the preview mode 304, any changes to the cloud-based application made using the design mode 302 may be reflected in the run mode 306 in a near real-time fashion. Alternatively, these changes may not be immediately reflected in the run mode 306. For example, instances of the cloud-based application executing in the run mode 306 may continue to execute without these changes, perhaps until reloaded or refreshed by a web browser executing the cloud-based application. Alternatively or additionally, whether and when the changes take place in the cloud-based application may be under control of the application designer.
[0097] One way in which the appearance and behavior of the cloud-based application can be synchronized across the design mode 302, the preview mode 304, and the run mode 306 is for these modes to share the same program logic while executing. Thus, for example, the design mode 302 may be substantially the same as the preview mode 304 and the run mode 306, except with the menus 402, stack toolbar 404, page toolbar 406, database toolbar 408, widget palette 410, and configuration palette 412 removed. Thus, in some embodiments, the differences between the design mode 302, the preview mode 304, and the run mode 306 may be limited to the state of the development environment GUI and the widgets. As a result, the designer may be able to switch between the modes in a substantially instantaneous fashion, as compilation and linking of the program logic may not be necessary.
[0098] It should be understood that each of the design mode 302, preview mode 304, and run mode 306 may include different GUI-based representations of the cloud-based application, and each of these modes may provide different types of functionality and interactivity to the designer or user. For example, the design mode 302 may display the development environment GUI, with its associated menus and palettes, while the preview mode 304, and run mode 306 may display the application GUI without these menus and widgets. Additionally, the development environment may support other modes of operation not described herein.
[0099] The execution platform 308 may load and store cloud-based applications and their associated data. The execution platform 308 may also render and execute these cloud- based applications. In some embodiments, the execution platform 308 may be a script-based virtual machine that operates in a web browser. For example, some web browsers support JAVASCRIPT® to facilitate dynamic web pages and web-based user interfaces. Accordingly, the execution platform 308 may be based on pre-provided and/or designer-provided
JAVASCRIPT® modules and functions. On the other hand, the execution platform 308 may
use one or more different scripting languages, such as but not limited to PHP, PERL®, JAVA®, AWK, Tcl/Tk, Python, and/or various shell scripting languages. Any or all of these scripting languages may execute inside or outside of a web browser.
[00100] The application model 312 may be an abstract representation of the cloud- based application. For instance, the cloud-based application may be a data-driven application that includes several pages. The pages of such an application may be organized into a "stack" of pages, and each stack of pages may be referenced by a unique URL. Alternatively or additionally, each page within the stack may be associated with a unique URL. Data-driven applications may include, for instance, applications that use the values of stored data to influence how the application presents itself to the user, how generated or input data and/or objects are stored, or to otherwise influence the behavior of the application. Each of these pages may include one or more widgets (e.g., images, text boxes, menus, dialogs, etc.). Accordingly, the application model 312 may include a representation of pages and widgets. This representation may include, for example, the names of each page and widget, relationships between pages, relationships between pages and widgets, references to any data associated with each widget, metadata associated with pages and/or widgets, names of scripts associated with pages and/or widgets, names of scripts associated with the cloud-based application as a whole, and so on.
[00101] Together, these items of the application model 312 may form a partially- complete or complete representation of the cloud-based application executable by the execution platform 308. For example, information in the application model 312 may specify the cloud-based application's user interface and behavior of the cloud-based application.
[00102] The database model 314 may represent the data associated with various aspects of the application model 312. For example, the database model 314 may include a database schema that defines the data stored on behalf of the cloud-based application. This
data may include information associated with the cloud-based application's pages and widgets. The database schema and the data stored in the database schema may be automatically generated by the execution platform 308 based on the defined pages and widgets. Additional scripts may extend the database schema and control the data stored in this schema.
[00103] To that point, the compiled scripts module 316 may be compiled versions of additional scripts provided by the designer or a third party to enhance the program logic of cloud-based applications or the program logic of the execution platform 308. The compiled scripts module 316 may include processed scripts, object code, machine code, or byte-code representations of program logic written in a scripting language. The use of the compiled scripts module 316 may be facilitated by the script callbacks 310, which may be used to include the compiled scripts module 316 into the execution platform 308.
[00104] To that end, the execution platform 308 may provide a number of insertion interfaces for injecting the compiled scripts module 316 into the execution platform 308. For instance, the script callbacks 310 may provide stub functions for one or more script names. The execution platform 308 may assign each compiled script a unique script name in accordance with one or more of these stub functions, such that when a stub function is invoked, the script associated with this stub function is executed. Scripts and their respective script names may be stored in the application model 312.
4.2 Server Software Architecture
[00105] Software components on the client device may interact with software components on cloud-based server devices (e.g., the server device 101). As shown in Figure 3, one or more cloud-based server devices may provide software modules and storage to further facilitate the development of cloud-based applications. Particularly, the cloud-based
server devices may include, and/or have access to, the application model datastore 102 and database model datastore 103.
[00106] The application model datastore 102 may include a database component for storing a representation of the application model 312. When the execution platform 308 makes changes to the application model 312, the execution platform 308 may transmit near real-time updates to the application model datastore 102 to reflect these changes.
Additionally, the application model datastore 102 may provide parts of the application model 312 to the execution platform 308 on demand. The execution platform 308 may request portions of the application model 312 from the application model datastore 102 on an as needed basis.
[00107] For example, suppose that a cloud-based application consists of two pages. To generate a display of the first page, the execution platform 308 may only request portions of the application model 312 related to the first page. Then, to generate a display of the second page, the execution platform 308 may request portions of the application model 312 related to the second page.
[00108] The database model datastore 103 may include a database component for storing a representation of the database model 314. The database model datastore 103 may use a database schema defined by the execution platform 308 (and possibly enhanced by the compiled scripts module 316) to store data associated with the cloud-based application. This database schema may be arranged so that each page in the application model 312 is represented by a database table, and each widget on a given page is represented by a field in the database table. However, other arrangements of the database schema are also possible.
[00109] The databases in the database model datastore 103 may include a relational database, perhaps supporting a structured query language (SQL). Alternatively, these databases may include other types of computer file(s) arranged in one or more file systems.
Various types of data structures may store the information in such a database, including but not limited to tables, arrays, lists, trees, fields, and tuples. These data structures may be defined using one or more data schemas. Furthermore, these databases may be monolithic (e.g., stored on a single physical device) or, as described in reference to Figure 2B, distributed across multiple devices in a network.
[00110] Additionally, it should be understood that a database schema may include a structure of a database, where this structure defines the objects in the database. A database schema may be defined using a formal language. Some of the information defined by a database schema may include tables, fields within the tables, types of data stored in the tables and fields, and relationships between tables, between fields, and between tables and fields. A database schema may also include indexes, program logic, event triggers, links, and other components.
[00111] The script compiler 318 may be a software module that receives scripts from the execution platform 308, and compiles these scripts into an executable representation.
Then, the script compiler 318 may transmit these executable representations of the scripts to the compiled scripts module 316. The script compiler 318 may include functionality that translates script-based program logic in the form of JAVASCRIPT® code, PHP code, PERL® code, JAVA® code, AWK code, Tcl/Tk code, Python code, various types of shell scripting code, and/or other types of program logic into some form of object code, machine code, and/or byte code. In some embodiments, the script-based program logic may be expressed using a superset (e.g., extensions or add-ons) of an existing scripting language. Additional details about script compilation are set forth in more detail in Section 6.
[00112] The authentication module 320 may ensure that designers and users accessing cloud-based applications are properly logged into the system. The authentication module 320 may also control access to individual application models and database models. For example,
the application model 312 and/or database model 314 may have an access control list that defines the designers and users that are authorized to use the model. Via the authentication module 320, the execution platform 308 may allow or deny a particular designer or user access to a particular application model or database model. In order for a designer or user to be authenticated, the designer or user may be required to provide representations of their userid and/or password to the authentication module 320. These representations may be provided directly, or through a web authentication method such as OAuth, OpenID, the Security Assertion Markup Language (SAML), and/or X.509, among other possibilities. In some embodiments, some or all users may only have access to certain modes of the distributed software architecture 300. For example, some users may only be able to access the run mode 306.
[00113] In some embodiments, a database can only be read from and written to by the cloud-based application that created the database. However, the designer can override this behavior and allow other applications to access the database. For example, the designer may allow any cloud-based application that uses the server device 101 to access the database.
[00114] The dynamic feed module 322 may provide a way for a designer or user to access and parse one or more feeds. A feed may be, for example, a Really Simple
Syndication (RSS) feed or Atom feed that is published on the Internet or a private network. Feeds may be used to provide frequently updated works, such as blog entries and online news sites, to readers in a standardized format. Some feeds may include a series of entries in chronological order, with each entry containing a headline, author, date of publication, and some content (e.g., text, hypertext, images, audio, video, etc.). Feeds may take the form of an extensible Markup Language (XML) file. These feeds may be used for rapidly populating a data model for a cloud-based application, so that the cloud-based application can be tested.
[00115] The media handler module 324 may facilitate the uploading of image files, audio files, video files, and so on by the designer or user. Such media may be added to the design of the cloud-based application by designers, or to the content of a running cloud-based application by users. When a media file is uploaded, the media handler module 324 may generate a unique identifier for the file. This identifier may be stored in the application model 312. When the execution platform 308 renders a cloud-based application containing a media file, the execution platform 308 may retrieve the media file via the media handler module 324.
[00116] The email handler module 326 may provide a service that allows executing cloud-based applications to send emails. For example, the email handler 326 may provide
Simple Mail Transfer Protocol (SMTP) mail transfer agent functions for one or more of the cloud-based server devices. For a given outgoing email message, the email handler 326 may use the Domain Name System (DNS) to look up the outgoing email message's destination, and then transmit the outgoing email message to this destination.
[00117] It should be understood that the components depicted in Figure 3 may be software, hardware, or some combination of software and hardware. These components may be collocated with one another or distributed across two or more physically distinct computing devices. Further, a distributed development architecture may have more or fewer components, and may arrange these components in a different fashion than shown in Figure 3.
4.3 Development Environment Graphical User Interface
[00118] Figure 4 depicts a development environment in accordance with an example embodiment. In particular, a development environment 400 represents a possible
development environment GUI that could be presented to a designer using the distributed software architecture 300. For example, development environment 400 may be a visual representation of the execution platform 308 in the design mode 302, preview mode 304,
and/or run mode 306. To that end, execution platform 308 may include program logic and media files that facilitate the presentation of the development environment 400. Regardless, through the use of the development environment 400, the designer may be able to design, test, and execute a cloud-based application.
[00119] To enable these features, the development environment 400 may include a number of menus, palettes, toolbars, and/or workspaces. For instance, menus 402 include a set of drop-down menus, including a "File" drop-down menu, a "Mode" drop-down menu, a "Help" drop-down menu, and a "Widget" drop-down menu. More or fewer drop-down menus may be included in the development environment 400. Also, it should be understood that each of the drop-down menus in the menus 402 are shown in their non-dropped-down state. Thus, by hovering a cursor or pointer over a particular drop-down menu, or by selecting a drop-down menu, among other possibilities, the respective drop-down menu's items may be displayed.
[00120] For example, selecting the "File" drop-down menu may result in options being displayed for creating a new cloud-based application, loading a cloud-based application from storage, saving a currently-loaded cloud-based application, and/or printing the development environment GUI, database schema, or scripts of a currently-loaded cloud-based application. In another example, selecting the "Mode" drop-down menu may result in options being displayed for switching between the design mode 302, preview mode 304, and run mode 306. In yet another example, selecting the "Help" drop-down menu may result in options being displayed for assisting the designer in using the development environment 400. In still another example, selecting the "Widget" drop-down menu may result in options being displayed for manipulating widgets that are including in the cloud-based application, or that are being considered for inclusion in the cloud-based application.
[00121] The development environment 400 may also include a stack toolbar 404, a page toolbar 406, and a database toolbar 408. The stack toolbar 404 may allow the designer to switch between different stacks, where each stack represents a series of related pages that are part of a cloud-based application. The page toolbar 406 may allow the designer to select for display one or more pages that are part of a stack in the cloud-based application. The page toolbar 406 may include a menu or a substantially equivalent mechanism to allow the designer to switch between these pages.
[00122] In combination, the stack toolbar 404 and page toolbar 406 may allow a designer to select a specific page of a specific cloud-based application, and this selected page may be displayed in the development environment 400. For example, as shown in Figure 4, the designer has selected "test5" on the stack toolbar 404, and "Page 1" on the page toolbar 406. Thus, the development environment 400 may display, in the application workspace 414, a representation of the selected page of the selected stack (e.g., Page 1 of the test5 stack).
[00123] The database toolbar 408 may allow the designer to name and/or control the database schema used to store the cloud-based application's data model. For example, in Figure 4, schema "test5db" is being used. In some embodiments, the database toolbar 408 may allow this schema to be changed or renamed. In other embodiments, the development environment 400 may hide this detail from the designer, so that the database and its schema are named, created, and updated automatically.
[00124] A page of the cloud-based application may include zero or more widgets that are displayed representatively in the application workspace 414. Development environment 400 may allow a designer to drag and drop widgets from the widget palette 410 into the application workspace 414. The designer may then position and/or further configure these widgets. The act of placing a widget in the application workspace 414 may result in the
widget being added to the page being displayed in the application workspace 414, and the execution platform 308 updating the database model to reflect the addition of this widget.
[00125] The widget palette 410 includes several examples of widgets that may be used on a page. The widgets in the widget palette 410 may include a field widget, an image widget, a button widget, a test widget, a menu widget, a color widget, a list widget, and a select widget. However, it should be understood that more or fewer widgets may be included in the widget palette 410, and other types of widgets may be included in the widget palette 410, or otherwise provided to the designer.
[00126] The field widget may allow the designer to add a field for data entry, for instance a text box (e.g., a graphical display sub-component) and an associated label (e.g., another graphical display sub-component), to a page. The media widget and the button widget may respectively allow the designer to select and add an image or other type of media, or to place a button on the page. The text widget may allow the designer add text to the page. The menu widget may allow the designer to add a menu to the page, and to specify the items in the menu. The color widget may allow the designer to add a particular color to a section of the page. The list widget may allow the designer to add a list to the page, and to specify the entries in the list. The select widget may allow the designer to add a check-box to the page. Other widgets may provide additional functionality.
[00127] For purposes of illustration, an example of widget selection and placement is shown in a dialog box 416. The dialog box 416 combines three widgets: a text widget 418, a button widget 420, and a button widget 422. The text widget 418 includes the text string "Press OK to continue", while the button widgets 420 and 422 include the names "OK" and "Cancel" respectively. Individual widgets from the widget palette 410 may also be combined to form a compound widget, as set forth in more detail in Section 8.
[00128] Each widget on a page may be further configured. For example, the configuration palette 412 as shown in Figure 4 indicates the configuration of the, perhaps currently selected, button widget 420. As shown in the dialog box 416, the button widget 420 includes the name "OK", and this name is selected to be displayed. The configuration palette 412 also specifies the location of the button widget 420 in terms of x and y coordinates on the page, as well as the width and height of the button widget 420. These x and y coordinates, as well as width and height specifications may be in pixels, inches, centimeters, or some other unit of measure. Automatic layout tools may simplify the process of determining layout relationships between widgets and perhaps between widgets and edges of the client web browser or device display, as set forth in more detail in Section 9.
[00129] Further, the configuration palette 412 enables assigning an action to the button widget 420. An action for a button may be specified using the "When", "Do", and "Page" menus that appear toward the bottom of the configuration palette 412. For example, Figure 4 shows that the configuration palette 412 indicates that, when the button widget 420 is clicked, the cloud-based application can switch to a different page, "Page 2". Other button options could also be provided.
[00130] It should be understood that different sets of widgets can be placed on various pages. These widgets may, alone or in combination with one another, exhibit different characteristics and functionality than shown in the configuration palette 412. It should also be understood that Figure 4 is intended to depict an illustrative example of one or more embodiments of a development environment. Thus, Figure 4 and the accompanying description of Figure 4 should not be viewed as limiting.
[00131] An advantage of the development environment 400 is that it allows individuals with little or no computer programming, web development, or database experience to design and deploy cloud-based applications. For instance, these individuals need only drag and drop
widgets on to the application workspace 414 in order to create a cloud-based application. Any database used by this cloud-based application may be automatically and transparently created, without requiring input from the individual. However, more experienced computer programmers, web developers, and/or database designers can find the development environment 400 useful, as the development environment 400 provides a simple interface to a rich set of features, facilitating rapid prototyping and development of cloud-based applications.
4.4 Information Flow Examples
[00132] Figures 5 and 6 depict examples, in the form of ladder diagrams 500 and 600, of how information could flow through the distributed software architecture 300 in order to facilitate the development of cloud based applications. At a block 502, an entity, (e.g., a designer, remote computer, etc.) uses the software architecture 300 to create a cloud-based application. This block may involve the entity providing at least some information regarding the cloud-based application to the execution platform 308. At a block 504, in response to this information, the execution platform 308 may transmit an authentication request to the authentication module 320. The authentication request may include, for example, a representation of the entity's account or credentials (e.g., a userid and/or password).
[00133] At a block 506, after receiving the authentication request, the authentication module 320 may determine that the entity is authorized to create a cloud-based application via the software architecture 300. This authorization may involve, for example, the authentication module 320 looking up the entity's credentials in a credential repository. Based on information associated with the credentials, the authentication module 320 may determine that the entity has been granted the ability to create the cloud-based application. Accordingly, at a block 508, the authentication module 320 may transmit an authentication approval to the execution platform 308.
[00134] In response to the authentication approval, the execution platform 308 may allow the entity to begin building the cloud-based application. For example, the entity may add one or more pages to the cloud-based application, and may also add one or more widgets to at least some of these pages. At a block 510, the execution platform 308 may receive a representation of these pages, widgets, and any other information (e.g., names, identifiers, metadata, and/or scripts) related to the design of the cloud-based application.
[00135] At a block 512, in response to receiving the representation, the execution platform 308 may transmit an update to the application model 312. This update may include specifications of the pages, widgets, and/or other information. At a block 514, the application model 312 may transmit the update (and/or information derived from information in the update) to the application model datastore 102. At a block 516, the application model datastore 102 may store the information in the update. The application model 312 may also maintain a copy of the representation.
[00136] At a block 518, also in response to receiving the representation, the execution platform 308 may transmit an update to the database model 314. This update may include data representing a database schema, and/or data associated with the pages, widgets, and other information that was transmitted to the application model 312. At a block 520, the database model 314 may transmit the update (and/or information derived from information in the update) to the database model datastore 103. At a block 522, the database model datastore 103 may store the data in the update. The database model 314 may also maintain a copy of the data. By this use of substantially simultaneous updates, application model updates and data model updates can be coordinated.
[00137] In addition to the updates shown in Figure 5, the execution platform 308 may continue to make updates to the application model 312 and database model 314 as the entity modifies the cloud-based application. The application model 312 and database model 314
may, in turn, continue to update the application model datastore 102 and database model datastore 103.
[00138] Figure 6 is another ladder diagram in accordance with a further example embodiment. At a block 602, an entity, (e.g., a designer, remote computer, etc.) uses the software architecture 300 to add a script to a cloud-based application. This block may involve the designer providing the script to the execution platform 308. Additional details about adding and creating scripts using various editing tools are set forth in more detail in Section 7.
[00139] At a block 604, in response to this representation, the execution platform 308 may transmit a script compilation request, along with a copy of the script, to the script compiler 318. At a block 606, in response to the script compilation request, the script compiler 318 may compile the script. Then, at a block 608, the script compiler 318 may transmit the compiled script to the execution platform 308.
[00140] At a block 610, in response to receiving the compiled script, the execution platform 308 may transmit a request to add the compiled script, along with a copy of the compiled script, to the compiled scripts module 316. At a block 612, the compiled scripts module 316 may store the compiled script.
[00141] At a block 614, also in response to receiving the compiled script, the execution platform 308 may transmit a request to add a reference to the compiled script to the script callbacks 310. At a block 616, the script callbacks 310 may use this reference to link to the compiled script as stored in the compiled scripts module 316. After loading the linked, compiled script, the execution environment may be able to execute the linked, compiled script during the execution of the cloud-based application.
[00142] At a block 618, also in response to receiving the compiled script, the execution platform 308 may transmit an update to the application model 312. This update may include
a copy of the compiled script. At a block 620, the application model 312 may transmit the copy of the script to the application model datastore 102. At a block 622, the application model datastore 102 may store the script. The application model 312 may also maintain a copy of the script. Additional details about script compilation are set forth in more detail in Section 6.
4.5 Methods for Cloud-Based Application Development
[00143] Figure 7 is a flow chart in accordance with an example embodiment. The flow chart illustrates a possible method 700 through which the application model 312 and the database model 314 can be created and populated based on a cloud-based application developed in development environment 400.
[00144] At a block 702, a computing device may display, via a graphical development environment (e.g., the development environment 400), a user interface of an application (e.g., a cloud based application). The graphical development environment may have access to an application model (e.g., the application model 312) and a data model (e.g., database model 314) of the application. The application model may include program logic of the application and a representation of the user interface of the application, while the data model may include a database schema for storing data used by the application. The representation of the user interface, in turn, may include a representation of a page, and the representation of the page may include a representation of a widget. The widget may contain text and graphical content, and use of the widget may trigger execution of a script. In some embodiments, the graphical development environment may be controlled by a script-based execution platform operating on the computing device.
[00145] At a block 704, the computing device may receive a change to the application.
This change may be, for example, an edit to the application user interface or program logic made by a designer of the application. Some possible changes include adding a new widget
to the application, removing a widget from the application, associating a widget with data, adding a new script to the application, removing a script from the application, associating a script with a widget and/or data, and changing the attributes of a widget.
[00146] Receiving the change to the application may occur while the graphical development environment is in a design mode. Further, the change may be received while the application is executing in a preview mode or a run mode. Responsive to receiving the change to the application in the design mode, the computing device may automatically update an instance of the application executing in the preview mode or run mode. Alternatively, the computing device may refrain from updating the instance of the application executing in the run mode.
[00147] At a block 706, in response to the change, the computing device may (i) apply a modification to the application model and the data model (or, modifications may be applied to only the application model or only the data model) to incorporate the change, and transmit a representation of the modification to a server device. The server device may store copies of the application model and the data model.
[00148] The transmission may occur automatically in response to applying the modification. Additionally, the representation of the modification may include a
representation of the difference between the application model and/or the data model without the changes incorporated and the application model and/or the data model with the changes incorporated. Alternatively, the representation of the modification may include a
representation of the application model and/or the data model with the changes incorporated.
[00149] In some embodiments, the change to the application may involve adding a script to the application. Thus, the computing device may receive the script, and in response to receiving the script, transmit the script to the server device for compilation. The computing device may receive a complied version of the script from the server device, and
then add the compiled version of the script to the program logic of the application. For instance, the computing device may store a copy of the compiled script in a compiled scripts module (e.g., compiled scripts module 316) and link the program logic of the application to the compiled script via a script callbacks module (e.g., script callbacks 310). The script may contain logic that interacts with a widget, or acts independently from widgets, to control values of at least one unit of data stored in the database schema.
5. Automatic Creation of a Database Schema Based on Application GUI
Characteristics
[00150] In an additional example embodiment, a database schema can be automatically created and populated based on the layout and content of the application GUI created by the designer. For example, when the designer adds an application GUI element to a page, the execution platform 308 may instruct the database model 314 to create a database schema based on the application GUI. Then, the database model 314 may in turn instruct the database model datastore 103 to create the database schema. One way in which the database schema may be based on the application GUI is to create a database table in the database schema for each page in the application GUI. Then, when a widget is added to a given page, a field is added to the database table to represent the widget.
[00151] Accordingly, as the designer adds widgets to a page, the execution platform 308 may update the database model 314, and in turn the database model may update the database model datastore 103 to add a field for the widget. Further, as the designer defines the name, position, size, shape, and/or actions associated with the widget, this information may also be stored in the database.
[00152] Moreover, if the designer removes widgets from a page, or pages from the application GUI, the database model 314 and the database model datastore 103 may be updated to incorporate these changes. In particular, when a widget is removed from a page,
the field associated with the widget may be removed from the database table associated with the page. Further, when a page is removed from the application GUI, the database table associated with the page may be removed from the database schema. On the other hand, if the field associated with a removed widget or the database table associated with the removed page contains user data, one of the following actions may occur: (i) the field / table is removed from the database along with all data associated with that field / table, (ii) the application designer is notified that the field / table contains data, and is asked to confirm that they want to remove the field / table from the database, or (iii) the widget / page is removed from the application model but the field / table and any associated data are not removed from the database. In some embodiments, option (ii) or (iii) may be preferable, because it is generally desirable to preserve user data, and scripts associated with the application may refer to the field / table.
[00153] It should be understood that the relationship between pages and database tables, as well as the relationship between widgets and fields in a database table, need not be one-to-one. Therefore, a given page may be associated with more than one database table, or a given database table may be associated with more than one page. Further, a given widget may be associated with more than one given field in a given database table, or a given field in a database table may be associated with more than one widget.
[00154] Figure 8 depicts the development environment 400 in accordance with an example embodiment. While the overall development environment GUI depicted in Figure 8 is substantially similar to that of Figure 4, Figure 8 also includes a set of widgets configured on a page. These widgets may combine, for example, to form page that facilitates calendar scheduling.
[00155] Particularly, and as illustrated in Figure 8, application workspace 414 includes a field widget "Name" 802, a field widget "Email" 804, a calendar widget 806, a menu
widget "Time" 808, and a button widget 810. The calendar widget 806 is not shown in the widget palette 410, and is representative of the many possible widgets not appearing in the widget palette 410 that could be defined by a designer.
[00156] In some embodiments, the page represented in the application workspace 414 may allow a user to enter their name in the field widget "Name" 802, their email address in the field widget "Email" 804, specify a date in the calendar widget 806, and specify a time on the menu widget "Time" 808. Then, the user may click (e.g., activate) the button widget 810 to "book" or schedule an event at the specified date and time for an individual with the specified name and email address. In particular, given the values of the calendar widget 806 and the menu widget "Time" 808, the event would be set at the specified time and date of 7:00 on August 30, 2010.
[00157] The configuration palette 412 shows the configuration of the button widget
816, including this widget's x and y coordinates, with and height. The configuration palette 412 also shows an action specified for the button widget 810. When the button widget 810 is clicked, the execution platform 308 may be instructed to save the values entered into widgets on the page to the database. Thus, when a user enters data into this page (e.g., a name, an email address, a date and a time) from the run mode 306 and clicks on the button widget 816, the entered data may be stored in the database.
[00158] Based on the application GUI, execution platform 308 may create a database schema to store information about the page and widgets included on the page. An example database schema, expressed in a pseudo-SQL format, for the page and widgets in Figure 8 is shown below.
CREATE TABLE pagel (
Name VARCHAR,
Email VARCHAR,
Date DATE,
Time TIME
)
[00159] The example database schema includes a database table, pagel, containing information related to the data-driven widgets included on the associated page. It should be understood that a data-driven widget is a widget that is associated with a particular unit of data. For example, each of the field widget "Name" 802, the field widget "Email" 804, the calendar widget 806, and the menu widget "Time" 808 may be data-driven widgets. Thus, the respective units of data associated with each of these widgets may be expressed as a field in the database table. Each of these fields may be considered variables that can take on different values.
[00160] Further, the label of each widget may be used to automatically name the associated database field. Thus, the database field associated with the field widget "Name" 802 may be labeled "Name", the database field associated with the field widget "Email" 804 may be labeled "Email", and so on. For the calendar widget 806 a default database field label of "Date" may be used. Nonetheless, the designer may be able to override these automatic naming conventions.
[00161] It should be understood that the term "field" may be used herein to refer to a type of widget (e.g., the field widget "Name" 802 and the field widget "Email" 804) or to a field in a database table. For example, there may be a field in a database table that stores the data associated with a field widget. By considering the context of any instance of the term "field", the appropriate interpretation of this term can be made. Alternatively, a widget added to a cloud-based application may have both a name and a widget identification number (ID). The widget ID may be automatically generated and may also be unique for the cloud-based
application (e.g., IDs may be generated by using an automatic scheme to generate monotonically increasing (or decreasing) IDs). The fields in the database may be referenced by widget ID instead of by name. A separate database may be automatically maintained to provide mappings from widget IDs to widget names. An advantage of using IDs is that if the designer changes the name of a widget, the database does not have to change. This allows, for example, scripts that reference the database to remain unchanged when widget names change. It also facilitates uniqueness of database field references while allowing widgets of the same name to appear on different pages of the cloud-based application.
[00162] The execution platform 308 may determine the data format of each field in a database table based on a data type of the field's associated widget. Thus, for example, the execution platform 308 may determine the data format for database table fields associated with the field widget "Name" 802 and the field widget "Email" 804 to be VARCHARs (e.g., variable length character strings). The execution platform 308 may also determine the data format for the database fields associated with the calendar widget 806 to be DATE (e.g., a calendar date expressed in YYYY-MM-DD format).
[00163] By default, the execution platform 308 may determine the data format of the database fields associated with menu widgets to be VARCHARs. However, in the example database schema shown above, the data format of the database field associated with the menu widget "Time" 808 is TIME (e.g., a time or time offset represented in HH:MM:SS format).
There may be several ways to override this default behavior of the execution platform 308.
[00164] In some embodiments, the designer may, via configuration palette 412, specify the data type of the menu widget "Time" 808 to be TIME (note that this option is not shown in Figure 8). Then the execution platform 308 may define the data format of the database field associated with the menu widget "Time" 808 to be the same as this user-specified data type. In other embodiments, the designer may use the compound widget feature (see Section
8) of the development environment 400 to define a new type of widget that include a menu widget but exhibits a data type of TIME.
[00165] Alternatively, the data type of the menu widget "Time" 808 may be
VARCHAR, but the designer may provide custom program logic (e.g., in the form of a script) that limits values that the data associated with the menu widget "Time" 808 can take on. For example, the custom program logic may only accept VARCHAR values representing a time between that of 09:00 and 17:00 (9AM to 5PM). Custom program logic can be used in a similar fashion to control values of data associated with any widget in a cloud-based application.
[00166] Regardless of whether the data format of the database field associated with the menu widget "Time" 808 is determined by default, with input from the designer, or via custom program logic, the execution platform 308 may create a database schema based on a page and widgets in application workspace 414. However, it should be understood that database creation based on the application GUI of a cloud-based application can occur in ways different than that set forth above. For instance, a given page may be associated with more than one database table, and/or a given widget may be associated with more than one field in a database table.
[00167] Figure 9 is flow chart 900 in accordance with an example embodiment. At a block 902, a computing device may display at least part of an application GUI. The application GUI may include a page, and the page may include a widget. At a block 904, the computing device may create a database schema based on the application GUI. The database schema may include data defining a relationship between the page and the widget.
[00168] For instance, the database schema may include a database table for the page, and the database table may include a field for the widget. The database table may define the page and the field may define the widget. Thus, creating the database schema may include
creating the database table, and adding the field to the database table. For cloud-based applications that include multiple pages, the database schema may have one table per page. Similarly, for a page that includes multiple widgets, the page's table may include a field for each widget.
[00169] Additionally, a widget may have a data type and a field associated with the widget may have a data format. Accordingly, when creating the database schema, the computing device may set the data format of the field based on the data type of the widget. Further, the widget may be associated with a text string, and the field may have a name. Consequently, when creating the database schema the computing device may set the name of the field based on the text string.
[00170] In some embodiments, the values that a field may take on can be limited to a particular range or set of values, and this limitation may be enforced through scripts. These scripts may include program logic that operates on a widget, or in conjunction with the widget, to store only particular values in the field.
[00171] As the designer specifies the cloud-based application, the application GUI may change. Therefore, in response to determining that the application GUI has changed, the computing device may update the database schema to incorporate the change. For example, in response to determining that a new widget has been added to the application GUI, the computing device may update the database schema to incorporate the change. Additionally, in response to determining that an existing widget has been removed from the application GUI, the computing device may remove an existing field from the database table.
[00172] The database schema may reside on a server device. Therefore, when creating the database schema, the computing device may transmit a representation of the database schema to the server device. Also, when updating the database schema to incorporate
changes, the computing device may transmit a representation of the change to the server device.
6. Using Scripts with Cloud-Based Applications
[00173] As mentioned above, cloud-based applications can include one or more scripts. Each script in turn can contain one or more scripting language instructions. The scripting language instructions may be instructions in a scripting language, such as JAVASCRIPT®, PHP, PERL®, JAVA®, AWK, Tcl/Tk, Python, and/or various shell scripting languages.
[00174] Each script may be associated with a computational item of the cloud-based application, such as a page, widget, or non-user-interface (non-UI) item. These
computational items may include, for example, data and/or executable instructions.
[00175] A page script may be associated with a page, and may execute when the page loads (e.g., is displayed) and/or unloads (e.g., is no longer displayed). For example, a page script associated with a given page could set up a background image for use on the given page when the given page loads. Additionally, the page script could save a copy of the background image when the page unloads.
[00176] Page scripts may use a page model to represent pages of the application model
312. The page model may include information about base attributes that affect the page as a whole. These base attributes may include page identifiers, related application identifiers, page size information, background/foreground color information, storage allocation information, and/or page title(s) or name(s).
[00177] The page model may also include various widget-specific attributes for each widget associated with the page. These widget-specific attributes may include a name, an identifier, a color, a size, text, a font, and/or storage allocation information. Other base and/or widget-specific attributes are possible as well. As such, the page script may interact with the
page model by accessing and/or modifying base and/or widget-specific attributes of the page model.
[00178] A widget script may be associated with a given widget, and may execute when the given widget receives an event from the cloud-based application. Example events for a given widget include: activating the given widget, selecting the given widget, entering data via the given widget, an exception or other type of error for the given widget, and deactivating the given widget. The widget script may interact with the widget by accessing and/or modifying widget-specific attributes for the widget. For example, a widget script can be used to change a given widget's font, size, text, foreground, and/or background colors. Other events and widget-specific attributes may be manipulated by widget scripts as well.
[00179] A non-UI computational item script may be associated with a non-UI computational item of the application, and may similarly execute upon creation and/or instantiation of the computational item, when the computational item is loaded (e.g., is displayed) and/or unloaded (e.g., is no longer displayed), and/or when the computational item receives an event (e.g., an exception or another type of event). The non-UI computational item script may interact with the computational item by accessing and/or modifying computational-item-specific attributes for the computational item. For example, a script attached to a stack, or group of related pages, may be executed when at least part of the stack is first loaded, perhaps before the first page of the stack is loaded. Non-UI computational item scripts could be attached to the database model 314 as well. For example, a script could update and/or initialize a database of a cloud-based application when the cloud-based application is loaded and/or unloaded.
[00180] A script may include one or more script extensions. Such script extensions may permit a script to access and/or modify a computational model, such as the application model 312 or the database model 314. Script extensions may follow a standard syntax. By
following the standard syntax, the script extensions can be readily identified by a script compiler. In an example syntax for script extensions, each script extension may begin with a key character (e.g., a dollar sign) followed by an identifier of the computational model. For examples, the script extension "$Database" may be used to access the database model and the script extension "$Name" may be used to access the Name variable of the application model. By accessing the application model 312 and/or database model 314 via script extensions, the script may be permitted to use data and and/or program logic maintained by the respective model.
[00181] A script may access a specific program logic method of the computational model via a method extension. For example, suppose the database model 314 can be accessed via a script extension and that the database model 314 includes a program logic method called "initialize()" to set up the database model 314. Then, the "initialize()" program logic method can be accessed via a statement such as "$Database.initialize()" which includes both a script extension of "$Database" to access the database model 314, and a method extension of ".initialize()" to access the "initialize()" program logic method of the database model 314. Many other examples of script extensions and/or method extensions are possible as well.
[00182] In the example script below, a dollar sign is used as the delimiting character for script extensions:
var Name = $Name.getText();
var Age = $Age.getText();
if ($Database.contains("Name, Age", Name+","+Age)) {
var FoundName = Name;
}
[00183] In this example script, the first scripting language instruction "var Name =
$Name.getText();" can retrieve text from a computational item of the application model, such as a widget, identified by use of the "$Name" script extension and the corresponding
".getText()" method extension for text retrieval. The retrieved text may be stored in a variable called "Name". The second scripting language instruction "var Age =
$Age.getText();" can retrieve text from a widget identified by use of the "$Age" script extension and the ".getText()" method extension. The retrieved text may be stored in a variable called "Age". The third scripting language instruction is a compound conditional statement: "if ($Database.contains("Name, Age", Name+","+Age)) { var FoundName = Name; } ". This conditional statement determines whether data stored in the database model 314 contains specified Name and Age data as indicated by the "$Database.contains("Name, Age", Name+","+Age)" script and method extensions. In this scripting language, the "contains" method takes two parameters: a string indicating a comma-separated list of fields to be searched (e.g., the "Name,Age" sub-statement) and a comma-separated list of data items to search for. This comma-separated list of data items is generated by the
'Name+","Age' sub-statement, which takes the value of the Name variable, appends (using the first "+" operator) a comma (the ",") to the Name value, and then appends (using the second "+" operator) the value of an Age variable. If the comma-separated list of data items is found in the database model 314, the variable "FoundName" is set to the value of the previously defined "Name" variable.
[00184] Scripts may include features of an underlying scripting language, such as
JAVASCRIPT®, PHP, PERL®, JAVA®, AWK, Tcl/Tk, Python, and/or various shell scripting languages. In the example script shown above, the second scripting language instruction incorporates features of a scripting language (JAVASCRIPT®) in the second method name to assemble a valid method name. Many other scripts using one or more underlying scripting languages with script extensions and/or method extensions are possible as well.
6.1 Script Compilation
[00185] The script compiler mentioned above may include an extension compiler. The extension compiler can receive a script with one or more scripting language instructions, possibly containing script extensions and/or method extensions, and generate corresponding scripting language instructions without the script extensions and/or method extensions. The use of the extension compiler enables free use of script language instructions, script extensions, and/or method extensions. The extension compiler may use one or more identifiers for use translating script extensions and/or method extensions into corresponding scripting language instructions.
[00186] Figure 10 depicts an example script compilation for an example cloud-based application 1020 in an example set of cloud-based applications 1000. Each cloud-based application may be associated with different application models and database models, and may be assigned or otherwise associated with an application identifier (ID) to identify the respective cloud-based application in a plurality of applications. As shown in Figure 10, a cloud-based application 1010 has an application ID of 1 and the cloud-based application 1020 has an application ID of 47. In other embodiments, application IDs may have other formats than the numeric formats shown in Figure 1. For example, application IDs may alternatively or additionally be alphabetic, alphanumeric, or binary, or may use some other way of specifying cloud-based applications in a plurality of applications.
[00187] Each computational item within a cloud-based application may also be assigned a computational item ID. The computational item ID can specifically identify the computational item within a computational model and can be combined with the application
ID for the computational item to form a global ID. For example, as shown in Figure 1, the database 1012 for the cloud-based application 1010 has a computational item ID of "0" and can be combined with the application ID of "1" to form a corresponding global ID of "1.0".
Similarly, the computational items 1014, 1016, and 1018 have respective computational item IDs of "1", "2", and "3" with corresponding respective global IDs of "1.1", "1.2", and "1.3."
[00188] Scripts associated with a cloud-based application can be assigned respective global IDs as well. For example, Figure 10 shows a script 1028 associated with the cloud- based application 1020 having an application ID of 47. The script 1028 has a computational item ID of "3", and therefore a global ID of "47.3". Other formats for computational item IDs and global IDs may be used as well, such as those discussed above for application IDs.
[00189] The global IDs and other attributes of a computational item can be stored in one or more computational item descriptions. A computational item description may include a table, database, and/or another type of data structure. Searches for global IDs, application IDs, computational item names, computational item addresses, and/or by other criteria of the computational item descriptions may be enabled to track the various attributes of the computational item. For example, a computational item description for a computational item may include one or more identifiers for the computational item, perhaps including a computational item name, one or more types for the computational item, a storage location of the computational item, and/or a list of zero or more methods defined for the computational item.
Application Computational Computational Computational Storage Functions Script Item ID Item ID Item Name Item Type Location ID ID
1 0 Database Database OxcOOO <list of -1 -1 database
functions
>
1 1 Iteml Integer OxdOOO <list of -1 -1 numerical
functions
>
1 2 Item2 Text OxeOOO <list of -1 -1 text
functions
>
1 3 Item3 Text OxfOOO <list of -1 -1 text
functions
>
47 0 Database Database 0x10000 <list of -1 -1 database
functions
>
47 1 Iteml Text 0x11000 <list of -1 -1 text
functions
>
47 2 Item2 Date 0x12000 <list of 3 -1 date
functions
>
47 3 Script Script 0x13000 <list of -1 2 script
functions
>
Table 1
[00190] Table 1 shows an example set of computational item descriptions for the computational items shown in Figure 10. In Table 1, a computational item Iteml 1014 of the application 1020 has an application ID of 1, and a computational item ID of 1. This application ID and computational item ID may combine to form a global ID of 1.1, as shown in Figure 10. Computational item Iteml 1014 also has a name of "Iteml", is of type integer, is stored in location OxdOOO, and can be used with a given list of numerical functions (e.g., addition, subtraction, multiplication, division, comparison operators, etc.).
[00191] Table 1 also includes additional aspects of computational items, in particular a script ID and an item ID. The script ID may store an identifier of a script associated with the
computational item. For example, "Iteml" (computational ID 1) of application ID 1 does not have an associated script, and thus the corresponding script ID is set to "-1" (which indicates that there is no associated script). However, "Item2" (computational ID 2) of application ID 47 does have an associated script, and this script has a computational item ID of "3", and thus the corresponding script ID for "Item2" is set to "3".
[00192] The item ID may store an identifier of another item associated with a computational item. For example, "Iteml" of application ID 1 is not associated with another computational item, and thus the corresponding item ID is set to -1 (which indicates that there is no additional associated computational item). However, "Script" (computational ID 3) of application 47 does have an associated computational item, and thus the corresponding item ID is set to "2", which is the computational ID of the computational item associated with the script. In this fashion, a script ID may indicate an association from a computational item to a script and an item ID may indicate an association between one computational item (such as a script) and another computation item. In some embodiments, multiple script IDs and/or item IDs may be associated with a computational item.
[00193] Other attributes of computational items can be part of a computational item identifier as well. Any of the identifiers in Table 1 (e.g., application ID, computational item ID, computational item name, etc.) may be used to search for a particular computational item or computational items.
[00194] In order to translate script extensions and method extensions from the development environment 400 into scripting language instructions (e.g., JAVASCRIPT® instructions), the extension compiler may use a one or more method descriptions. Each method description may represent a method extension. Each method description may also include a method name, a set of applicable computational item types, a list of zero or more
parameters used by an associated computational item, a type of a return value, and a function name corresponding to the method name.
[00195] As an example, method descriptions that relate to the database model 314 could specify method extensions and corresponding function names to: (i) read the database schema of the database model 314, (ii) add a table (e.g., layout of a database record) to the database schema, (iii) add a field to a table in the database schema, (iv) delete a table from the database schema, (v) list all records stored using a specified table of the database schema, (vi) add a database record to the database schema, (vii) read data from a database record of the database schema, (viii) write data to a database record of the database schema, (ix) delete a database record of the database schema, and/or (x) search the records of the database schema. Other method extensions and corresponding function names are possible as well, including but not limited to database-related method extensions and corresponding function names.
Table 2
[00196] As another example, Table 2 shows three example time-related method descriptions. The following example script, based on the example method descriptions of Table 2, uses method extensions to set three variables h, m, and s from an application model computational item called "TheDate". The example script utilizes JAVASCRIPT® as an underlying scripting language to which scripting language of the development environment 400 is translated. Of course, in other embodiments, scripting languages other than
JAVASCRIPT® could be used.
var h = $TheDate.Hours();
var m = $TheDate.Minutes();
var s = $TheDate.Secs();
[00197] The method descriptions may be part of the application model 312 and/or the database model 314. Thus, the method descriptions can be used by a cloud-based application in any of design mode 302, preview mode 304, and/or run mode 306.
[00198] A script compiler can use the identifiers, computational item descriptors, and method descriptors discussed above to translate script extensions and method extensions into scripting language instructions. For example, Figure 10 shows the application 1020 with a script 1028 having a scripting language instruction of "var s = $Item2.getSecs();".
[00199] When script 1028 is sent to a script compiler 1030 for compilation, the script compiler 1030 can parse the scripting language instruction quoted above to determine that a script extension of "$Item2" is used based on the presence of the above-mentioned "$" delimiting character and a "." preceding a method extension "getSecs()." The script compiler
1030 can determine a global ID corresponding to the computational item specified in the script extension for the cloud-based application. In this example, the computational item is
"$Item2" (whose corresponding computational item ID is 2) of the cloud-based application with application ID 47. Thus, the global ID corresponding to "$Item2" is 47.2. The script compiler 1030 may query the example set of computational item IDs shown in Table 1, with the computational item name of "Item2" and the application ID of 47 to determine the corresponding computational item ID of 2.
[00200] The script compiler 1030 can generate part or all of a scripting language instruction that permits access to a computational item specified via a script extension. For example, as shown in compiled script 1032, the script compiler 1030 may generate a scripting language instruction "var tmpltem2 = access(47.2, Date)" that creates a variable "tmpltem2", accesses a computational item based on a global ID of type "Date" via the "access(47.2,
Date)" sub-instruction, and then sets the "tmpltem2" variable to the accessed computational item.
[00201] In particular, the access sub-instruction may receive a global ID (or other identifier) and/or a type. The access sub-instruction may query a set of computational item identifiers based on the identifier. For example, if a global ID is used, the query may involve using the application ID and computational item ID specified in the global ID to find a corresponding storage location for a computational item. If the query is successful, an interface to the computational item is returned. This interface may be the corresponding storage location (e.g., a pointer to the computational item), a handle to the computational item (e.g., a pointer to a pointer to the computational item), a copy of the computational item found at the corresponding storage location, and/or another interface to the computational item. In some scenarios, the access sub-instruction may return an error value and/or invoke an error handler (e.g., throw an exception) if the global ID does not refer to a computational item of a cloud-based application and/or if the type does not match the type of the computational item identified by the global ID.
[00202] The script compiler 1030 can generate part or all of a scripting language instruction that corresponds to a method extension. For example, to process the above- mentioned "getSecsO" method extension, the script compiler 1030 can query the set of method extensions for a function name corresponding to the "getSecs()" method extension. Using the example set of method extensions shown in Table 2, the script compiler 1030 can find a function name of "getSeconds" corresponding to the "getSecs()" method extension and further determine that the "getSeconds" function has no parameters. In some scenarios, the script compiler 1030 can compare the returned function with a list of functions associated with the computational item and verify that the function is in the list, and is thus actually associated with the computational item.
[00203] As shown in the compiled script 1032, the script compiler 1030 may generate a scripting language instruction "var s = tmpItem2.getSeconds()", which creates a variable "s" and assigns the variable "s" to the value of a result of an invocation of the "getSeconds()" function on the "tmpltem2" computational item. Thus, the two example scripting language instructions shown in the compiled script 1032 correspond to the scripting language instruction shown in the application script 1028. Other application scripts and corresponding compiled scripts are possible as well.
[00204] In further embodiments, not shown in Figure 10, the compiled script 1032 may be further improved. As one example improvement, the call to the "access" function may be combined with a call to a function corresponding to method extension, thereby eliminating use of the temporary variable "tmpltem2". The resulting improved scripting language instruction may include or be similar to the following example statement "var s =
(access(47.2, Date)).getSeconds();". Other improvements are possible as well.
6.2 Script Injection and Script Callbacks
[00205] One or more scripts may be installed or "injected" into the execution platform
308 in order to execute a cloud-based application associated with or including the one or more scripts. The one or more scripts may be injected using a live injection technique that installs the one or more scripts during execution of the associated cloud-based application. Live injection of scripts may ensure the WYSIWYG behavior of cloud-based applications containing scripts by automatically and/or dynamically modifying the behavior of the cloud- based applications to reflect changes made to the cloud-based application.
[00206] The execution platform 308 may use one or more script callbacks 310 to support live injection of compiled scripts. Several example script callbacks are described below. However, other script callbacks may be defined and used in addition to or in place of these examples.
[00207] A possible script callback may be an "add script" callback to install scripts. The "add script" callback may include functionality for locating a script (e.g., locating a script stored in application model 312, database model 314, application model datastore 102, or database model datastore 103) based on one or more identifiers. These identifiers may include global IDs and/or computational item IDs. Also, the add script callback may ensure that the script has been recently compiled. After locating and perhaps compiling a requested script, the add script callback can provide the requested compiled script to the execution platform 308. The add script call back may store a compiled script (e.g., in application model 312, database model 314, application model datastore 102, and/or database model datastore 103) after requesting compilation as well.
[00208] An "execute script" callback may execute a compiled script associated with a cloud-based application. When the execution platform 308 finds a script function name, as generated above, the execution platform 308 may call the execute script callback with the function name. The compiled JAVASCRIPT® associated with the function name may then be run.
[00209] A "remove script" callback may delete a previously installed compiled script from the execution platform 308. In some embodiments, the remove script callback may ensure the script is stored in the application model datastore 102 just prior to removal thus ensuring the stored script is the most recent copy of the script.
[00210] Figure 11 is a ladder diagram illustrating an example scenario 1100 involving live script injection. At a block 1102, an entity (e.g., a user, remote computer, etc.) provides an execute application request to the execution platform 308. At a block 1104, the execution platform 308 may transmit a locate application request 1104 to the application model datastore 102 to retrieve the requested application. The locate application request 1104 may also traverse the application model 312, and may include a name and/or other identifier(s) of
the requested application. In response to receiving the locate application request 1104, the application model datastore 102 may retrieve one or more computational items related to the requested application, and communicate the requested application to the execution platform 308 using a requested application response 1106.
[00211] At a block 1108, the execution platform 308 may execute the requested application. A script associated with the application may be invoked during execution of the requested application. Thus, the execution platform 308 may transmit a locate script request 1110 to the application model datastore 102 (possibly via the application model 312). The locate script request 1110 may include a name, a global ID, and/or other identifiers of the requested script. The requested script may include one or more scripting-language instructions. The application model datastore 102 may find and retrieve the requested script and transmit the requested script to the execution platform 308 using a requested script response 1112.
[00212] Upon receiving the requested script, the execution platform 308 may determine that the requested script is to be compiled. To compile the requested script, execution platform 308 may invoke the script compiler 318 via a compile script request 1114. The compile script request 1114 may include a copy of the script to be compiled, or a reference with which the script compiler 318 can locate the script to be compiled in the application model datastore 102.
[00213] At a block 1116, the script compiler 318 may generate a compiled script by compiling the requested script. The script compiler 318 may then transmit the compiled script to the execution platform 308 using a compile script response 1118. The execution platform 308 may then add the compiled script to compiled scripts module 316 (not shown) and add a link to the compiled script to the script callbacks 310 (not shown). These transactions are not shown in Figure 11, but may be the same as or similar to the blocks 610-
616 of Figure 6. In this way, the execution platform 308 may perform a live injection of the compiled script into the execution platform 308. In an alternative embodiment, the execution platform 318 may not need to have the script compiled (e.g., the script may already be compiled), and the blocks 1114-1118 may be omitted.
[00214] Once the compiled script is arranged with respect to the script callbacks 310 and the compiled script module 316, at a block 1122, the execution platform 308 may execute the compiled script to perform one or more transactions of a computational model. As part of executing the compiled script at block 1122, the execution platform 308 may execute one or more application model transactions 1124 with the application model datastore 102 and/or database model transactions 1126 with the database model datastore 103. These application model and database model transactions 1124, 1126 may include one or more operations that read, write, insert, and/or delete data in the application model datastore 102 and/or database model datastore 103.
[00215] After execution of the compiled script, at a block 1128 the execution platform 308 may store the compiled script in application model database 102. A possible advantage of doing this is to avoid having to recompile the script again in the future. Additionally, and not shown in Figure 11, the execution platform 308 may act to remove the compiled script from the compiled scripts module 316, and to remove the link to the compiled script from the script callbacks 310.
[00216] It should be understood that in various alternative embodiments, different modules may participate in the transactions shown Figure 11. For example, either of the script callbacks 310 and the compiled script module 316 may interact with the execution platform 308 to facilitate and/or perform the techniques described above for one or more of the blocks/communications 1110, 1112, 1114, 1118, 1124, 1126, and 1128.
6.3 Example Methods for Script Compilation and Injection
[00217] Figure 12 is a flow chart 1200 according to an example embodiment. At a block 1210, a script is received at a script compiler. The script may include at least one scripting language instruction for an application, such as a cloud-based application. The scripting language instruction(s) of the script may include a script extension, and the script extension may specify use of a computational model, which may be an application model or a database model. The script extension may include a character and an identifier of the computational model. The identifier of the computational model may specify a
computational item. As discussed, example computational items of the application include databases, pages, widgets, and/or other computational items of the application.
[00218] At a block 1212, the script compiler may locate or identify the script extension of the at least one scripting language instruction of the script. As mentioned above, the script extension may include a key character, and as such, the script compiler may identify or locate the script extension within the script based on the key character; e.g., a beginning of the script extension can be located by finding the key character that begins the script extension.
[00219] At a block 1214, the script compiler may determine an identifier of the computational model specified by the script extension. The script compiler may query for a computational item among a set of computational item identifiers and receive an interface to the computational item specified by the script extension.
[00220] At block 1216, the script compiler may generate a compiled script
corresponding to the script. The compiled script may include scripting language code that replaces the script extension where the scripting language code is configured to access the computational item identified by the identifier of the computational model. For example, the scripting language code may include a call to an access sub-instruction that permits access to the computational model (e.g., the database model) identified by the identifier associated with
the access sub-instruction.
[00221] In some embodiments, the least one scripting language instruction includes a method extension that corresponds to an invocation of a function of the computational model. In these embodiments, the script compiler may be configured to generate additional scripting language code to replace the method extension with the invocation of the function of the computational model. For example, the script compiler may query a set of method descriptors to determine a function of either the database model or the application model that corresponding to the method extension. In some of these embodiments, a return value of the function can be determined based on the set of method descriptors.
[00222] Figure 13 depicts a flow chart 1300 of an example embodiment. At a block
1310, an application may be received at a computing device. The application may include a stack and a database. The stack may include one or more pages for a user interface. For example, the application may be a cloud-based application.
[00223] At a block 1312, the application may be executed using the computing device. Executing the application may include locating a compiled script for the application, injecting the compiled script into the application, and executing the injected script in the application. The injected script may be configured to access the stack and/or the database. The compiled script may be located based on an identifier assigned to the compiled script, and may include a scripting language instruction for the application.
[00224] In some embodiments, locating the compiled script may include locating a script based on the identifier, determining that the script is to be compiled, requesting that the script be compiled, and receiving the compiled script, wherein the compiled script corresponds to the script. In particular of these embodiments, the functionality of flow chart
1200 can be invoked in requesting that the script be compiled. In other embodiments, executing the application may include removing the application script from the application.
In still other embodiments, adding a script, compiling the script, injecting the compiled script, and/or removing the script may performed by use of one or more callbacks (e.g., use of an add-script callback to add a script). In even other embodiments, the identifier may include an application identifier and a computational-item identifier.
7. Script Development Assistance
[00225] A range of tools may be provided to assist with cloud-based-application script development. Figure 14 shows an example window for a standard editor 1400 with a compile button 1402 and a script development assistance button 1404. The standard editor 1400 may be configured for editing of a script and, via the compile button 1402, compiling the edited script. The standard editor 1400 may be suitable for experienced software developers, who may have used similar editors for script and/or program logic development.
7.1 Assistance for Adding Computational Items with Standard Editors
[00226] Script development assistance can be provided by the "Add Item" button 1404 shown enhancing the standard editor window 1400 of Figure 14. Figure 15A depicts an example "Widget Chooser" dialog 1500. The "Widget Chooser" dialog 1500 may be displayed upon selection of the "Add Item" button 1404. The "Widget Chooser" dialog 1500 may display some or all computational items of a cloud-based application under development and/or enable assisted addition of script commands to perform operations on the
computational items.
[00227] As shown in Figure 15 A, the Widget Chooser dialog 1500 includes three sections: a page selection section 1502, a computational item choice section 1506, and an instruction section 1516. The page selection section 1502 may allow selection of a page of the cloud-based application. By default, computational items for the current page of the cloud-based application are shown in the Widget Chooser dialog 1500 by default. A page
selector 1504 provides for selection of a different (non-default) page of the cloud-based application for assistance, e.g., a page other than the current page.
[00228] The computational item choice section 1506 may include a list 1508 of the computational items on the selected page of the cloud-based application. As shown in Figure 15 A, the list 1508 can include a computational item name, computational item type, and one or more identifiers. For example, one computational item 1510 in the list 1508 has a computational item name of "Date of Birth," a computational item type of "Date," and a global ID of "71.3." Along with the computational items on the selected page, additional "pseudo-items" can be shown in the list 1508 to represent the database model 314 (e.g., the computational item "Database" 1512) and/or the application model 312 (e.g., the
computational item "Stack" 1514).
[00229] An instruction section 1516 may instruct the designer about how to add a method to a script (e.g., "click on a method to add it to your script."). The instruction section 1516 section can list methods for a selected computational item of the list 1506 that are available for use an edited script. In response to selection of a page and a computational item via the "Widget Chooser" dialog 1500, the "Widget Chooser" dialog 1500 can populate the instruction section 1516 of the dialog with a list of methods applicable for the selected computational item.
[00230] Figure 15B shows an example "Widget Chooser" dialog 1500 with the instruction section 1516 populated with methods for a selected computational item 1520. The selected computational item 1520 is a "Name" computational item, which is shown as selected in Figure 15B using a bold and underlined font. Figure 15B also shows the instruction section 1516 populated with a list of methods 1522 applicable to the selected
Name object 1518. The list of methods 1522 may be a partial list of methods applicable to the selected computational item, as shown in Figure 15B, or a complete list of methods.
[00231] As an example, suppose a "Move(x,y)" method 1524 is selected from the list of methods 1522. To indicate this selection, the Move(x,y) method 1524 is shown in a bold and underlined font in Figure 15B. Upon selection of the Move(x,y) method 1524 in the Widget Chooser dialog 1500, a corresponding block of code may be inserted into the standard editor 1400.
[00232] To illustrate that point, Figure 15C shows the editor window of standard editor
1400 with an inserted line of code 1526. Figure 15C shows two lines of the existing script shown in Figure 14 (e.g., the "var date = ..." and "var Time = ..." lines of code are shown in both Figures 14 and 15C).
[00233] The line of code 1526 shown in standard editor 1400 of Figure 15C is a syntactically-correct new scripting language code of "$Name.move(X,Y);" that corresponds to the selected "Move(x,y)" method 1524. Figure 15C also shows the line of code 1526 inserted into the existing script after the "Move(x,y)" computational item 1524 was selected as indicated in Figure 15B and the corresponding line of code 1526 was appended to the script after the two lines of the existing script. Many other computational items, method, and inserted lines of code are possible as well. The script, including any inserted lines of code, can be stored, retrieved, and/or edited via the standard editor 1400 and/or via other types of editors.
7.2 Assistance for Adding Statements with Standard Editors
[00234] Figures 16A through 16C show a scenario 1600 for providing another example level of assistance to aid with programming of JAVASCRIPT® syntax (e.g., "if...else" statements and "for" loops). This assistance technique is not restricted to helping with
JAVASCRIPT® syntax and is applicable to any supported scripting language. Figure 16A shows a standard editor 1602 enhanced with an "Add Statement" button 1604. Once selected, the Add Statement button 1604 may cause a menu of statements to be displayed (not shown
in Figure 16A) for selection. This menu of statements may include if...else statements, loops, and/or other types of statements (e.g., a "switch" statement) used in the scripting language, perhaps along with statements used in other languages.
[00235] In the example scenario 1600, an "if...else" statement is selected from the menu of statements. Figure 16B shows an example dialog 1610 for adding an "if...else" statement as part of scenario 1600. In other scenarios not shown in Figures 16A-C, dialogs for other types of statements may be displayed based on a corresponding selection in the menu of statements.
[00236] To aid discussion, a prototypical "if...else" statement is shown below to illustrate the roles of a "condition" and the optional "else" sub-statement.
if (condition)
{
code to be executed when the condition is true;
}
else
{
code to be executed when the condition is false;
}
[00237] The dialog 1610 may permit selections related to the "if...else" statement, such as radio buttons 1612 and 1614 related to conditions and check box 1620 related to the else sub-statement. Selection of the radio button 1612 may permit entry of a user-added condition, while selection of the radio button 1614 may permit entry of a pre-defined
"database contains" condition related data stored in the database model 314.
[00238] In scenario 1600, the radio button 1614 is selected. Upon selection of the radio button 1614, possible fields used by the "database contains" condition may be displayed as part of dialog 1610. Figure 16B shows the dialog 1610 displaying two example fields for the database contains statement, a "Name" field 1616 and an "Age" field 1618. In scenarios not shown in Figure 16B, an "else" statement may be added to the "if statement by selection
of "else" selector 1620. In scenario 1600, both the "Name" field 1616 and "Age" field 1618 are selected from the dialog of Figure 16B prior to selection of an "OK" button 1622.
[00239] Figure 16C shows the example standard editor 1602 with a corresponding syntactically-correct new block of scripting language code 1624 for an "if...else" statement.
The new block of scripting-language code 1624 may be inserted into a script in response to selection of the OK button 1622 of the dialog 1610. As shown in Figure 16C, the new block of scripting-language code 1624 is:
if ($Database.contains("Name,Age", Name+","+Age)) {
}
[00240] The new block of scripting-language code 1624 may, upon execution, permit querying of the database model 314 of the cloud-based application for based on a combination of "Name" and "Age" data, which corresponds to the selections of the Name field 1616 and the Age field 1618 in dialog 1610 as shown in Figure 16B. In scenarios other than scenario 1600, code to be executed when the database contains condition is true may be added as well via the dialog 1610 and/or the standard editor 1602.
[00241] In some embodiments, the inserted new block of scripting language code 1624 may include syntactically-correct definition of the Name and Age variables, such as shown above the "if statement in the editor window 1602 of Figure 16C. The script, including any new blocks of code, can be stored, retrieved, and/or edited via the standard editor 1400, the standard editor 1602 and/or the guided script editor 1702 described below.
7.3 The Guided Script Editor
[00242] Figures 17A through 17F show a scenario 1700 using a guided script editor
1702 that provides another level of assistance for guided scripting language programming. Programming of many other computer programming and scripting languages could be guided using the guided script editor 1702 as well.
[00243] Figure 17A shows an example window for the guided script editor 1702. The guided script editor 1702 may be configured to define one or more scripts using a simplified, visually-enhanced syntax. For example, instead of using the standard JAVASCRIPT® "{...}" notation for blocks of statements, the guided script editor 1702 can use defined screen areas to show control blocks. To aid comprehension, the guided script editor 1702 can use one or more conversational statements made in a non-programming language that are equivalent to one or more scripting-language statements. Some example non-programming languages include English, Spanish, French, German, Italian, Chinese, Japanese, Korean, Russian, Hindi, Urdu, and Greek; many other examples of non-programming languages are possible as well. For example, the guided script editor 1702 can display an English-language conversational statement of "set name to the value of Name" to represent an underlying scripting language statement, such as "var name = $Name.getText();". In at least some cases, the conversational statement is simpler to read and understand, especially for a user without detailed knowledge of scripting languages. As such, a user of the guided script editor 1702 would not need detailed knowledge of scripting language syntax to write scripts.
[00244] The script generated by the guided script editor 1702 may be stored as a standard scripting language script. The generated script may be edited using the above- mentioned standard editor to enhance the capabilities of the script and/or learn how the underlying scripting language works. In some embodiments, some of the capabilities of the scripting language are not available via the guided script editor 1702. Rather, the guided script editor 1702 can provide a simplified version of a scripting language to support common scripting language operations without overwhelming a novice designer with options.
[00245] In some embodiments, the guided script editor 1702 may have two or more modes accounting for different levels of programming skill. For example, the two or more modes may include a "novice" mode that permits use of a very simplified version of a
scripting language, a "moderate" mode that permits use of more functionality of the scripting language than the novice mode, and an "expert" mode that permits use of most (if not all) functionality of the scripting language. In other embodiments and scenarios, the guided script editor 1702 can provide conversational statements equivalent to statements in one or more non-scripting-language programming languages, such as but not limited to, C, C++, FORTRAN, Pascal, and other non-scripting-language programming languages.
[00246] Figure 17A shows the example guided script editor window 1702 may be divided into areas. These areas may include a script element controls area 1704, a variables area 1706, and a script area 1708. The script elements controls area 1704 includes elements that can be assembled into a script. Figure 17A shows the script element controls area 1704 divided into three sections corresponding to different elements of the script. These controls may include a "Statements" area 1710 for "if...else" statements and loop statements, an "Actions" area 1712 to show, hide, get, and set pages and/or widgets, and a "Database" area 1714 for database search and database contains statements. Each section of script elements area 1704 may be collapsible to allow hiding of unneeded sections. Other script element controls and/or sections of script element controls can be shown in the script elements controls area 1704 of guided script editor 1702 as well.
[00247] The variables area 1706 of the guided script editor permits addition of variables into the script by selecting an "Add" button 1716. In embodiments not shown in Figure 17A, the variables area 1706 can have an additional button to delete a variable and/or other buttons for other variable operations (e.g., grouping variables into a computational item or data structure).
[00248] Additional help on an element-by-element basis can be provided by the guided script editor. For example, clicking on a control in the script element controls area can cause
a dialog to be displayed with an explanation of what the control does in a script and any expected parameters for the control.
[00249] The script area 1708 is shown in Figure 17A as a relatively-large blank box.
To add a script element to a script, a user of the guided script editor 1702 can drag a button representing the corresponding script element from the script elements controls area 1704 into the script area 1708.
[00250] Upon selection of the "Add" button 1716, a dialog to add variables can be generated and displayed by the guided script editor 1702. Figure 17B shows an example "Add Variable" dialog 1720 for the guided script editor 1702 as part of the scenario 1700. The designer may use the "Add Variable" dialog 1720 to name a variable to be added to the script via a "Variable Name" text box 1722. For example, to add a variable named "Name", a user may type in "Name" into the "Variable Name" text box 1722.
[00251] The "Add Variable" dialog 1720 may permit initialization of the added variable in one of two fashions. The added variable can be explicitly initialized by entering an initial value for the variable using an initial-variable-value entry box 1724. For example, to initialize the newly-added variable to a value of 6, a user may type in a "6" into the initial- variable-value entry box 1724.
[00252] The "Add Variable" dialog 1720 may also permit initializing the newly-added variable to a value of a widget by choosing one of the widgets listed in a widget-value section of the "Add variable" dialog 1720. Figure 17B shows that values of the "Name", "Age", or
"Date of Birth" widgets can be selected for initialization via respective radio buttons 1728,
1730, and 1732. Upon selection of a respective radio button corresponding to a widget, the newly-added variable may be initialized to the corresponding widget's value at the time the script executes. For example, if the "Name" radio button 1728 is selected, the newly-added variable may be initialized to the value of a "Name" widget.
[00253] Figure 17C shows the example guided script editor window 1702 after addition of two variables as part of the scenario 1700. Once defined, each newly-added variable is included in the variables section 1706 of the guided script editor 1702 and the appropriate conversation statement is displayed in the script area 1708. In the scenario 1700, the variables "Name" and "Date of Birth" have been added. Correspondingly, Figure 17C shows a button for "Name" variable 1734 and a button for the "Date of Birth" variable 1736 in the variables area 1706. In some embodiments, clicking a variable button may cause the guided script editor 1702 to generate and display an "Update variable" dialog (not shown in Figures 17A-17F) similar to the "Add variable" dialog 1720. The update variable dialog may be configured to permit changing the name and/or initial value of a selected variable.
[00254] Continuing the scenario 1700, elements of a script other than variables can be added to a script via the guided script editor 1702. Figure 17D shows an example guided script editor window 1702 with a script area 1708 for adding an "if...else" statement to the script. The guided script editor 1702 includes a condition box 1740.
[00255] The condition box 1740 may be populated by dragging a condition element onto it. Figure 17D shows the text of a "contains" condition 1742 of the database operations area 1714 in bold to represent selection of the "contains" condition 1742. As part of scenario 1700, the "contains" selection 1742 may be selected and then dragged into the condition subsection 1740.
[00256] Figure 17E shows an example guided script editor window 1702 after the
"contains" condition 1742 has been dragged into the condition box 1740. The condition box 1740 of Figure 17E is populated with the database contains element. Additionally, in Figure 17E, a pop-up 1744 is displayed that allows setting of parameters for testing with the database "contains" element. For scenario 1700, the parameters for testing can include
widgets in the current application model page that can store data. Figure 17E shows the selection of "Name", "Age" and "Date of Birth" widgets in pop-up 1744.
[00257] In another possible selection, a variable button, such as the "Name" button
1734 can be selected and dragged into the condition box 1740. In response to dragging a variable button into the condition box 1740, the guided script editor 1702 may display a dialog that allows a designer to add a condition.
[00258] Figure 17F shows an example "Add Condition" dialog 1746. The "Add
Condition" dialog 1746 may permit addition of a condition. As shown in Figure 17F, the "Add Condition" dialog 1746 includes a left-hand-side entry box 1748, a comparison- operation menu 1750, and a right-hand-side entry box 1752. Each sub-section of the condition can be completed by dragging a script element control into an empty sub-section of the condition. As an example, suppose the desired condition is to test the "Name" variable as not being equal to the string "Mikey Moose." Then, a user could drag the "Name" variable button 1734 into the left-hand-side entry box 1748 to fill the left-hand-side entry box 1748 with "Name". In other scenarios, a user could type "Name" into the left-hand-side entry box 1748 instead of dragging the "Name" variable button 1734. To use the desired not equals comparison operator, the user may click on the "Does not Equal" radio button of comparison- selection menu 1750. To complete the comparison, the user may type "Mikey Moose" into right-hand-side entry box 1752 and then click "OK" button 1754. Many other comparisons can be entered as well are possible as well using the guided script editor 1702.
[00259] Once the condition statement and any code to be executed when the condition is true and/or false is completed, the guided script editor can generate a corresponding if...else statement to be added to the script. The script, including any added scripting language instructions, can be stored, retrieved, and/or edited using the guided script editor
1702 and/or using a standard editor (e.g., standard editor 1400 or standard editor 1600) or another type of editor.
7.4 Example Methods for Script Assistance
[00260] Figure 18 shows a flow chart 1800 according to an example embodiment for adding a scripting language instruction to a script of scripting language instructions and storing the script. At a block 1810, a script of scripting language instructions is created, possibly via a computing device. At a block 1812, a scripting language instruction is generated using a guided script editor of the computing device. The guided script editor may include a statement control, a variable control, and a script area. The guided script editor may be configured to generate a conversational statement equivalent to the generated scripting language instruction. The conversational statement may be made in a non-programming language, such as English, or in a non-scripting-language programming language, such as C++.
[00261] At block 1814, the scripting language instruction is added to the script of scripting language instructions. At block 1816, the script of scripting language instructions, including the added scripting language instruction, is stored via the computing device. In some embodiments, the statement control may include an if...else control. In particular, generating the scripting language instruction may include receiving a selection of the if...else control, receiving condition input to complete a condition sub-section of the if...else control, receiving parameter input to complete parameters of the if...else control, and generating an if...else statement based on the condition input and the parameter input.
[00262] In other embodiments, generating the scripting language instruction may include receiving a selection of the variable control and generating a variable statement based on the selection. Receiving the selection of the variable control can include receiving a name
input and an initialization input for a variable. Generating the variable statement can include generating the variable statement based on the name input and the initialization input.
[00263] Figure 19 shows a flow chart 1900 according to another method for adding a scripting language instruction to a script of scripting language instructions and storing the script. At a block 1910, an editor window is displayed, possibly via a computing device. The editor window may include an editing area and an assistance button. The editor window may be configured for editing a script that includes one or more scripting language instructions.
[00264] At a block 1912, the computing device may determine that the assistance button has been selected. The assistance button may be selected to request assistance with a particular scripting language instruction. At a block 1914, the computing device may generate an assistance display related to the particular scripting language instruction of the one or more scripting language instructions based on, and perhaps in response to selection of the selected assistance button. At a block 1916, the computing device may display the assistance display.
[00265] At a block 1918, the computing device may receive input via the assistance display. The input may specify a variable name, a variable value, a computational item, a scripting language method, part or all of a scripting language instruction, and/or other types of input.
[00266] At a block 1920, the computing device may generate the particular scripting language instruction based on, and perhaps in response to, the received input. The scripting language instruction may include a variable assignment statement, an "if...else" statement, a looping statement (e.g., for loop, repeat loop, while loop), an invocation of a scripting- language method, and/or other types of statements.
[00267] At a block 1922, the computing device may add the particular scripting language instruction to the script. At a block 1924, the script is stored via the computing
device. The script may be stored on the computing device and/or communicated to another computing device for storage.
[00268] In some embodiments of flow chart 1900, the assistance button includes an add-statement button and the assistance display includes an add-statement display. In these embodiments, receiving input via the assistance display may include receiving a statement- selection input via the add-statement display to select a statement, and receiving a parameter- selection input via the add-statement display to select a parameter related to the statement. In these embodiments, generating the scripting language instruction based on the received input may include generating the scripting language instruction based on the statement-selection input and the parameter-selection input.
[00269] In other embodiments of flow chart 1900, the assistance button includes an add-computational-item button and the assistance display includes an add-computational-item display. In these other embodiments, receiving input via the assistance display may include receiving a computational-item-selection input via the add-statement display to select a computational item, and receiving a method-selection input via the add-statement display to select a method related to the computational item. In these other embodiments, generating the scripting language instruction based on the received input may include generating the scripting language instruction based on the computational-item-selection input and the method-selection input.
8. Creation and Configuration of Compound Widgets
[00270] As briefly described in Section 4.3, individual widgets from the widget palette 410 of development environment 400 may be combined to form a compound widget. The ability to quickly and easily create compound, re-usable widgets may reduce the time and complexity required to develop and maintain cloud-based applications. For example, there
are many instances where it may be beneficial for a particular set of widgets, with shared and/or custom behavior, to appear more than once on a particular page, stack, or application.
[00271] Through the use of compound widgets, this shared and/or custom behavior need only be defined once. Additionally, any changes to one instantiated compound widget may be automatically propagated to the other instantiations of the compound widget.
Furthermore, the compound widget may be promoted to a first class widget (e.g., available in the widget palette 410 for further instantiation of a same or similar set), making it easier to recreate, share, manipulate, and maintain particularly defined sets of widgets.
[00272] Returning to Figure 4 and as shown in the widget palette 410, a plurality of first-class widgets may be loaded by the development environment 400 and made available for a designer to drag and drop into the application workspace 414 to form a part of a cloud- based application. As mentioned above and as illustrated in Figure 4, first-class widgets may include, for example, a field widget, a media widget, a button widget, a test widget, a menu widget, a color widget, a list widget, and a select widget. As mentioned above, an advantage of compound widgets is that, once created, they can be added to the widget palette 410 as a first-class widget that can be similarly instantiated in the future by simply dragging the compound widget from the widget palette 410 to the application workspace 414.
[00273] Additionally, the compound widget may be accessible via either (or both) of the development environment 400 and/or the application model datastore 102. Thus, the compound widget may be loaded by the development environment 400 and made available for a designer to drag and drop into the application workspace 414 on different pages of the current stack or in a new stack of a new cloud-based application. The created compound widget may also be made available to other designers, perhaps in accordance with an access control list, and in a similar manner to that set forth above with respect to application models and database models.
[00274] Figures 20-23 illustrate examples of creating a compound widget in the development environment 400. A compound widget may be created from a set of already- existing first-class widgets. As illustrated in Figure 20, a user may drag and drop a plurality of first-class widgets, including, for example, a color widget 2002, a button widget 2004, a media widget 2006, and a text widget 2008, from the widget palette 410 to the application workspace 414. While this example uses a particular set and arrangement of first-class widgets as illustrated in Figure 20, any other types of widgets, and any other arrangement of the widgets, could additionally or alternatively be used.
[00275] After placing the first-class widgets that form the compound widget in the application workspace 414 and arranging them in a desired relationship relative to one another, the widgets may be selected via an input selection process, illustrated in Figure 20 as a dashed selection line box 2010. The dashed selection line box 2010 may be created by a designer dragging a cursor across the selection of first-class widgets 2002-2008. The selection of the first-class widgets may result in a Crosshatch, highlight, change in color, or other mechanism applied to the first-class widgets 2002-2008 to provide visual feedback to the designer of the selected first-class widgets that will form a part of the compound widget.
[00276] Once the designer arranges and selects the desired first-class widgets, the designer may generate an instruction to create a compound widget from the selected first- class widgets. The instruction may be provided in any number of ways. For example, a "click" on an input device having input buttons, such as a mouse, may display a menu from which the designer may select a menu item entitled "Create Compound Widget."
Alternatively or additionally, the designer may access the "Widget" drop-down menu in the menus 402 toolbar, and similarly select a menu item entitled "Create Compound Widget" from the list of menu items in the resulting drop-down menu. Other methods could be used as well.
[00277] Figure 21 depicts an example option dialog box 2100 for use in creating a compound widget that may appear responsive to the designer selecting the "Create
Compound Widget" menu selection. As shown in Figure 21, the option dialog box 2100 allows a user to set values for a compound widget name 2102, a current compound widget instance name 2104, color widget options 2106-2108, media widget options 2110-2112, text field widget options 2114-2116, button widget options 2118-2124, compound widget script options 2126-2128, shared/specific settings 2130, an identification of the most significant graphical display sub-component 2132, and most significant graphical display subcomponent border options 2134-2136. Nonetheless, the option dialog box 2100 is just one example, and in other embodiments, more or fewer options may be provided to configure the compound widget. These options may change depending on the particular set of first class widgets selected to form member widgets of the compound widget.
[00278] The compound widget options 2102 and 2104 may allow the designer to set the compound widget name 2102 (which may identify the compound widget type and be shared across all instances of that compound widget), and the widget instance name 2104 (which may be the name of the current instance of the compound widget, and may be unique to each instance of that compound widget).
[00279] The color widget options 2106 and 2108 may allow the designer to set options for the color widget, which was selected as a member of the compound widget. In an embodiment in which the color widget was not selected, the color widget options 2106 and
2108 may, for example, not be displayed or may be grayed out. Additionally or alternatively, the color widget check box 2106 may be used to add or remove the color widget from the current compound widget. Checking the color widget check box 2106 may add the color widget to the current compound widget, while un-checking the color widget check box 2106 may remove the color widget from the current compound widget. The color widget options
2108 may include, for example, a color button that may be used to select a particular color for a corresponding color swatch of the color widget (such as red, blue, or white), and a border button that may be used to select a particular border (or lack thereof) to appear at outer edges of the corresponding color swatch of the color widget. The color selected for the color widget is one example of a graphical display sub-component of the color widget, which may be incorporated into the compound widget. Other options could also be provided, or a subset of the example options provided.
[00280] The media widget options 2110 and 2112 may allow the designer to set options for the media widget, which was selected as a member of the compound widget. In the event that the media widget was not selected, the media widget options 2110 and 2112 may, for example, not be displayed or may be grayed out. Additionally or alternatively, the media widget check box 2110 may be used to add or remove the media widget from the current compound widget. Checking the media widget check box 2110 may add the media widget to the current compound widget, while un-checking the media widget check box 2110 may remove the media widget from the current compound widget. The media widget options
2112 may include, for example, an image path text box and a browse button for interactively identifying an associated image via a graphical file-system display. Other options could also be provided, or a subset of the example options provided. For example, other types of media could be selected for the media widget, such as video, audio, flash animation, etc., and other respective types of options could be provided, such as volume for sound, and auto-start for video and animations. All of these media options may comprise another graphical display sub-component of the media widget, which may be incorporated into the compound widget.
[00281] The text field widget options 2114 and 2116 may allow the designer to set options for the text field widget, which was selected as a member of the compound widget.
In the event that the text field widget was not selected, the text field widget options 2114 and
2116 may, for example, not be displayed or may be grayed out. Additionally or alternatively, the text field widget check box 2114 may be used to add or remove the text field widget from the current compound widget. Checking the text field widget check box 2114 may add the text field widget to the current compound widget, while un-checking the text field widget check box 2114 may remove the text field widget from the current compound widget. The text box widget options 2116 may include, for example, a text field for entering the text to appear in the corresponding text field of the text field widget. Other options could also be provided, or a subset of the example options provided. For example, options could be provided to determine whether a text-scroll box is provided in the corresponding text field, or perhaps whether the corresponding text field created by the widget is scaled to accommodate the amount of text entered into the corresponding text field. The text selected for the text field widget is one example of a graphical display sub-component of the text widget, which may be incorporated into the compound widget.
[00282] The button widget options 2118, 2120, 2122, and 2124 may allow the designer to set options for the button widget, which was selected as a member of the compound widget.
In the event that the button widget was not selected, the button widget options 2118-2124 may, for example, not be displayed or may be grayed out. Additionally or alternatively, the button widget check box 2118 may be used to add or remove the button widget from the current compound widget. Checking the button widget check box 2118 may add the button widget to the current compound widget, while un-checking the button widget check box 2118 may remove the button widget from the current compound widget. The button widget options 2120 may include, for example, identifying a particular script to execute when the corresponding button is activated. A complied script identifier may be entered into the text box of button widget options 2120. Additionally or alternatively, the compiled script identifier may be automatically populated into the text box of button widget options 2120
when a corresponding script or scripts that reference the button widget are created and/or stored by the designer. The button widget options 2122 may specify, in addition to or alternative to executing a script, a new page in the current stack to switch to when the corresponding button is activated. The button widget options 2124 may specify a button text to include within the borders of the corresponding button. The text and color elements of the button widget are examples of graphical display sub-components of the button widget, which may be incorporated into the compound widget. The script associated with the button widget is an example of a functional characteristic of the button widget that may be incorporated into the compound widget. Other options could also be provided, or a subset of the example options provided.
[00283] The compound widget script options 2126 and 2128 may allow the designer to specify a compound widget script that may be associated with the compound widget. The compound widget script may control over-all interactions between member widgets, for example, or could be used to initialize or modify behavior of member widgets, among other possibilities. A complied script identifier may be entered into the text box of the compound widget script options 2128. Additionally or alternatively, the compiled script identifier may be automatically populated into the text box of the compound widget script options 2128 when a corresponding script or scripts that reference the compound widget are created and/or stored by the designer. Other options could also be provided, or a subset of the example options provided.
[00284] The shared/specific widget options 2130 may allow the designer to specify whether each of the widget options 2108, 2112, 2116, 2120/2122, and/or 2124 are to be shared across all instances of the compound widget, or are to be set specifically for each instance of the compound widget. Shared options (e.g., characteristics) may be automatically set and populated when a compound widget is instantiated (e.g., they may be incorporated
from the individual widgets from which the compound widget is created). In some embodiments, additional shared options may be added to the compound widget. In contrast to the shared options, specific options (e.g., characteristics) may be required to be set to some value each time the compound widget is instantiated, although default values may be provided in one embodiment. Particular widgets and/or particular widget options may be set to always be one of a shared characteristic or a specific characteristic. In some embodiments, widgets and/or widget options may default to one or the other of the shared and specific characteristic, but then allow the designer to modify that default characteristic.
[00285] The most significant graphical display sub-component widget option 2132 may allow a designer to explicitly identify the most significant graphical display subcomponent (e.g., member widget or member widget component) of the compound widget. This information may be used to determine how best to align the compound widget with other widgets on the current page of the stack, in the design mode 302, preview mode 304, or run mode 306. The most significant graphical display sub-component widget option 2132 may be used in combination with the most significant graphical display sub-component border widget options 2134 and 2136. Once a particular graphical display sub-component is identified as the most significant graphical display sub-component via most significant graphical display sub-component widget option 2132, the most significant graphical display sub-component border widget options 2134 and 2136 may be used to set what particular border of the identified most significant graphical display sub-component should be used in arranging the compound widget relative to other widgets on the current page of the stack. Selectable entries for the most significant graphical display sub-component border option 2136 may include, for example, top, left, right, bottom, and center, among other possibilities.
[00286] An "Ok" button 2138 may complete the creation of the compound widget with the widget options selected in dialog box 2100. Selecting the "Ok" button 2138 may also
execute validation program logic to ensure that there are no errors in the widget option boxes set forth in the dialog box 2100. For example, such validation may include ensuring that only one most significant graphical display sub-component via most significant graphical display sub-component widget option 2132 box is selected out of the plurality of available boxes, and/or that the compound widget name 2102 and widget instance name 2104 are completed and are different from one another. Other validation procedures are possible as well. And other actions responsive to execution of the "Ok" button 2138 and/or other validation functions are possible as well. Selecting the "Cancel" button 2140 may allow the designer to refrain from creating the compound widget, and may remove the dialog box 2100 from the screen. Other actions responsive to execution of the "Cancel" button 2140 are possible as well.
[00287] Figure 22 sets forth an example of a completed compound widget dialog box
2200. While Figure 22 illustrates particular options that have been completed and/or modified relative to Figure 21, which may be discussed here, in other embodiments, more or fewer of the options 2102-2136 of Figure 21 may be completed, and or a different selection, arrangement, or contents of options may be completed.
[00288] As set forth in Figure 22, the compound widget name 2202 has been set to "Search Sports Scores." This name can be set to a general name and may be used to describe the overall functionality of the compound widget in general, instead of the particular function of an instantiated copy of the compound widget. The compound widget name 2202 may be associated with all instances of the compound widget. In contrast, the widget instance name 2204 has been set to a more specific title "Search Football Scores." This name may be used to describe the particular functionality of a particular instance of the compound widget, and should be unique across all instances of the same compound widget
[00289] Because a color widget was included in the compound widget selection, the check box option 2206 is selected. De-selecting the check box option 2206 may remove the color widget from the compound widget (and perhaps any instances of the compound widget already created). Additionally, the color widget option 2208 "Color" has been set to the color "Red" in this example. The lack of a selection for the "Border" option may mean that no separate border is provided, or that a default border is provided.
[00290] Because a media widget was included in the compound widget selection, the check box option 2210 is selected. De-selecting the check box option 2210 may remove the media widget from the compound widget (and perhaps any instances of the compound widget already created). Additionally, the media widget option 2212 "Image Path" has been set to "WFootball.png" in this example to reference a stored image of a football at the indicated file system path.
[00291] Because a text field widget was included in the compound widget selection, the check box option 2214 is selected. De-selecting the check box option 2214 may remove the text field widget from the compound widget (and perhaps any instances of the compound widget already created). Additionally, text field widget option 2216 "Text" has been set to the text string "Enter Football Team Name."
[00292] Because a button widget was included in the compound widget selection, the check box option 2218 is selected. De-selecting the check box option 2218 may remove the button widget from the compound widget (and perhaps any instances of the compound widget already created). Additionally, the button widget option 2222 "Page to Load" has been set to reference the page "Page 2" in the application stack. Accordingly, activation of the button may cause the application to proceed from the current page in the stack to page 2 of the stack. On page 2, for example, a text field may be disposed that is populated with the results of the football scores search. Alternatively or additionally, and although not illustrated
in Figure 22, the Script ID/Path option 2220 could identify a script that provides functionality similar to that of the option 2222, but may or may not require the loading of a new page in the stack. The button widget option 2224 "Button Text" is set to the text string "Search Scores."
[00293] The compound widget script option 2226 has been checked to indicate that a compound widget script exists and is associated with the current compound widget, and the option 2228 "Script ID/Path" has been set to "scores. scriptl23" to identify a script that defines interactions between member widgets of the compound widget. The scores. scriptl23 script may provide a link between, for example, the button widget and the text field widget members of the compound widget, such that when the corresponding button is activated, text in the text field is pulled and used to conduct a database search, and in one embodiment, place the results in a text field on page 2 of the stack. In one embodiment, the
scores. scriptl23 is stored with the compound widget in the application model datastore 102. The "Edit Script" button may open the script editor feature described above to allow the designer to create or edit the script.
[00294] The shared/specific compound widget options 2230 are set so that the color widget settings are set to shared (and thus may be the same across all instances of the compound widget), the media widget settings are set to specific (and thus may be specifically set for each instance of the compound widget), the text field widget settings are set to specific (and thus may be specifically set for each instance of the compound widget), the button widget "Page" setting is set to specific (and thus may be specifically set for each instance of the compound widget), and the button widget "Button Text" setting is set to shared (and thus may be the same across all instances of the compound widget).
[00295] The most significant graphical display sub-component option 2232 is identified to be the button widget in this compound widget. The specific part of the button
widget that may be used as the most significant graphical display sub-component border is set in the most significant graphical display sub-component border option 2236 to be the "Left" edge of the button widget. Failure to select the enabling check-box 2234 may result in a default selection of the most significant graphical display sub-component border for the compound widget, which may be, for example, left, right, top, bottom, or center.
[00296] Selecting the "Cancel" button 2240 may erase all of the settings set forth in the dialog box 2200 and prevents the creation of a corresponding compound widget "Search Sports Scores." Selecting the "Ok" button 2238 completes the configuration of the compound widget "Search Sports Scores" and at the same time creates a first instance of the "Search Sports Scores" compound widget entitled "Search Football Scores." The "Search Sports Scores" compound widget may also then be placed in the widget palette 410 so that further instances of the "Search Sports Scores" compound widget may be placed on a page in the stack by simply dragging the "Search Sports Scores" compound widget from the widget palette 410 to the application workspace 414.
[00297] Figure 23 illustrates a corresponding instantiation of the "Search Football
Scores" compound widget 2302 in accordance with the settings set forth in the dialog box 2200 of Figure 22. As illustrated in Figure 23, the compound widget 2302 includes a "Red" background color swatch 2306 created commensurate with the color widget settings 2206, a text field 2308 created commensurate with the text field widget settings 2216, a football image 2310 created commensurate with the media widget settings 2212, and a search button 2312 created commensurate with the button widget settings 2222 and 2224. Additionally, a "Search Sports Scores" first-class widget 2300 is created in the widget palette 410 such that additional instances of the "Search Sports Scores" compound widget can be added to the pages in the stack by simply dragging and dropping the (now) first class widget 2300 to the application workspace 414.
[00298] An additionally-instantiated compound widget 2304 illustrates an example of dragging and dropping the newly created first-class compound widget 2300 to create a second instance of the "Search Sports Scores" compound widget. Once the first-class widget 2300 is dragged onto the application workspace 414, the configuration palette 412 is loaded with one or more of the "Search Sports Scores" compound widget options 2104, 2108, 2112, and 2122 to allow configuration of the second instance. Fewer or additional compound widget options than those shown in Figure 23 could be displayed in the configuration palette 412.
[00299] In some embodiments, only those compound widget options set as specific characteristics via options 2230 are displayed in the configuration palette 412. The shared characteristics, in contrast, may be automatically set and updateable only via a separate menu option. For example, as shown in Figure 23, the compound widget name option 2202 is not shown in the configuration palette 412 as it is a shared characteristic. In contrast, the widget instance name option 2204 is displayed in the configuration palette 412 as this value is individually set for each instance of the "Search Sports Scores" compound widget.
[00300] In another embodiment, all compound widget options may be displayed in the configuration palette 412, but may be displayed in such a manner that shared options, such as the color widget option "Red" 2208, are displayed in a "grayed out" or other visual manner to demonstrate that they are shared characteristics and any change to them may be propagated to all other instances of the compound widget. In one embodiment, an additional confirmation dialog box may be displayed requesting confirmation whenever a designer attempts to make a change to a shared characteristic, in order to prevent accidental side-effects of the change to other instances of the compound widget.
[00301] As shown in Figure 23, the compound widget 2304 includes a "Red" background color swatch 2314 created commensurate with the shared color widget settings
2206, a text field 2316 created commensurate with the specific text field widget settings entered into the configuration palette 412, a basketball image 2318 created commensurate with the specific media widget settings entered into the configuration palette 412, and a search button 2320 created commensurate with the shared button widget settings 2224 and the specific search button widget settings entered into the configuration palette 412 (e.g., "Page 3").
[00302] Additional instances of the "Search Sports Scores" compound widget could be made on the page illustrated in Figure 23, on a separate page in the stack (not shown), or in a separate application (not shown) by sharing the "Search Sports Scores" compound widget with other designers or with other applications by the same designer.
[00303] Figure 24 is a flow chart 2400 of an example embodiment for creating and maintaining a compound widget. At a block 2402, a graphical development environment 400 is provided depicting a representation of one or more pages and a plurality of user-selectable data-capable widgets, each widget including one or more graphical display characteristics (e.g., sub-components) and a computer-executable functional characteristic.
[00304] At a block 2404, a first instruction is received to create a compound widget from a plurality of selected widgets. As set forth in Figure 20, the selection could be effected by dragging an input device such as a mouse across the desired widgets to create a selection group 2010. Other methods of selecting widgets for inclusion in a compound widget could be used as well. The instruction to create the compound widget may be provided in any number of ways. For example, a "click" on an input device having input buttons, such as a mouse, may display a menu from which the designer may select a menu item entitled "Create Compound Widget." Alternatively or additionally, the designer may access the "Widget" drop-down menu in the menus 402 toolbar, and similarly select a menu item entitled "Create
Compound Widget" from the list of menu items in the drop-down menu. Other methods could be used as well.
[00305] At a block 2406, a second instruction is received to place (e.g., instantiate) the compound widget a plurality of times in the representation of the one or more pages in the stack. As set forth with respect to Figures 22 and 23, the creation of the compound widget may also create the first instance of the compound widget in the stack. In one embodiment, the creation of the compound widget may only add a corresponding first-class widget in the widget palette 410, and not create an instance of the compound widget in the stack, such as compound widget 2302 in Figure 23, perhaps requiring further instances to be created by placing a compound widget from the widget palette 410 to the application workspace 414. Other methods of creating multiple instances of the compound widget are possible as well.
[00306] At a block 2408, an update is detected to one of the shared characteristics of one of the placed compound widgets. For example, with respect to Figures 22 and 23, the update may be a change of the color of the shared color widget option 2208 of the "Search Sports Scores" compound widget from "Red" to "Blue." At a block 2410, the update to the shared characteristic is propagated to each of the other instances of the compound widget. For example, this update is propagated to each of the other instantiated "Search Sports Scores" compound widgets, such as the second instantiated "Search Sports Scores" compound widget 2304. In addition, the block 2408 may entail storing the change to the compound widget at the application model datastore 102, which may cause instantiated copies of the "Search Sports Scores" compound widget to also be changed in other applications that reference the application model and/or compound widget that at the application model datastore 102.
[00307] Additionally, versioning can be applied so that other designers can subscribe to a particular version of the application model and/or compound widget stored in the
application model datastore 102, such that updates to shared characteristics in one instance of the compound widget do not cause problems in other instances of the compound widget. The designer making the change to the shared characteristic may have control over whether to apply the update to the current version of the compound widget, or increment the version of the compound widget prior to applying the change. Designers subscribed to a particular version of the compound widget may be notified, or may be able to determine, that an updated version is available. The subscribed designers could then, perhaps after reviewing notes regarding the changes made to the compound widget, determine whether to update their own instances of the compound widget to the newest version.
[00308] In some embodiments, the development environment may provide one or more ways of sharing compound widgets between designers of a cloud-based application. In one embodiment, compound widget definitions may be exported via the "Widget" drop-down menu in the menus 402 toolbar, and transmitted to another designer by, for example, e-mail, instant message, or some other mechanism. Additionally or alternatively, a menu option may provide the designer with access to a central repository of compound widgets, perhaps stored at server 101, or at some other remote computing device. Similarly, the designer may access the remote repository and select compound widgets to download and add to the widget palette 410, which may then be stored within the development environment 400 and/or application model datastore 102 for use in designing current or future applications.
[00309] In further embodiments, a common database of shared widgets may be maintained to which all instances of the cloud-based application have access, and to which designers can "subscribe" to receive notifications of updates and/or modifications to particular shared widgets. When a widget is added, deleted, or updated in the common widget database, subscribed designers may be notified within their version of the design
environment. These in-application notification methods may be combined with or substituted by other methods, such as email, instance messaging, and so on.
9. Layout Management
[00310] As mentioned above, automatic layout tools may be used to simplify the process of determining layout relationships between widgets, groups of widgets, and/or edges of the screen. Traditional tools use explicit layout managers to specify how the components of the user- interface (UI) align with one other and to the application window in which they are currently displayed. Layout managers, however, are a complex abstraction that can be difficult to learn and hard to combine to achieve a desired layout. They typically require a designer to draft textual descriptions of relationships between different elements of the UI components in view of unknown and/or changing window sizes. Creating such rules places a significant burden on the designer.
[00311] The disclosed automatic layout tools, however, can be used to aid the designer in layout of elements of a cloud-based application as the designer places widgets, and can also be used to determine relationships between widgets that help an execution platform determine how to render a page of widgets when the screen is first drawn, and/or when it is re-sized. The first of these tools to be discussed is a smart alignment tool, and the second is an implicit layout specification tool.
9.1 Smart Alignment
[00312] The smart alignment tool aids the designer in aligning widgets during the design phase (e.g., in the design mode 302 of Figure 3). By default, the development environment 400 may align widgets dragged and dropped into the application workspace 414 to a visible or invisible grid. The (x,y) coordinates of the widget may be set to a nearest point on the grid (for example, a 100x100 grid relative to where the widget is placed by the designer).
[00313] Figure 25 illustrates an example group of widgets that have been instantiated in the application workspace 414 by dragging and dropping three text field widgets (e.g., consisting of label and text field graphical display sub-components) and two button widgets (e.g., consisting of border and label graphical display sub-components) from the widget palette 410. Additionally, the settings of these widgets have been populated. For example, a widget 2504 is a text field widget populated with the label "Name," a widget 2506 is a text field widget populated with the label "Age," a widget 2508 is a text field widget populated with the label "Date of Birth," a widget 2510 is a button widget with a label name populated with the text string "Cancel," and a widget 2512 is a button widget with a label name populated with the text string "Ok."
[00314] Each of these widgets has been selected via an input selection process, illustrated in Figure 25 as a dashed selection line box 2514 created, perhaps, by dragging a cursor across the selection of the first-class widgets 2504-2512. The selection of the first- class widgets 2504-2512 may result in a Crosshatch, highlight, change in color, or other mechanism applied to the first-class widgets 2504-2512 to provide visual feedback to the designer of the selected first-class widgets that will form a part of a "group of widgets."
[00315] A group of widgets may be a designer-defined group that indicates that the members (or sub-components) of the selected group are intended to have some relationship between them. Here, for example, the widgets 2504-2512 may form part of a "Personal Information Data Entry" tool that retrieves user information to use in a data lookup or, perhaps, as part of a method to determine whether a user is of a proper age to further access the designed application. Other uses are possible as well.
[00316] The grouping of the widgets 2504-2512 lets the development environment 400 know that it should pay particular attention to the selected widgets (and not widgets outside of the selection, which may exist but are not shown in Figure 25) in determining an alignment
between the selected widgets. Additionally, knowledge of widget groupings may be used by the implicit layout tool, discussed further below, in determining how to re-arrange widgets when the page screen or window, on which the application is being rendered, changes.
[00317] In this case, the designer may select the widgets 2504-2512, select the
"Widget" menu option from the menu toolbar 402, and select "Group Selected Widgets" to specify that the selected widgets 2504-2512 should be stored as related widgets (in the development environment 400 or the application model datastore 102, for example). In at least one embodiment, selecting widgets 2504-2512 may automatically cause the
development environment to group the selected widgets. In another embodiment, the widgets 2504-2512 may not be automatically grouped until a subsequent "Align" operation is performed on the selected widgets.
[00318] After selecting the widgets to be grouped together, the designer may execute a smart-alignment process that will determine the type of widgets in the group, and align the widgets with respect to one another taking into account knowledge of the sub-components of each widget. An instruction to execute the smart-alignment process may be provided by the designer in any number of ways. For example, a "click" on an input device having input buttons, such as a mouse, may display a menu from which the designer may select a menu item entitled "Align Grouped Widgets." Alternatively or additionally, the designer may access the "Widget" drop-down menu in the Menus 402 toolbar, and similarly select a menu item entitled "Align Grouped Widgets" from the list of menu items in the drop-down menu. Other methods could be used as well.
[00319] Figure 25 illustrates a rough positioning of the five widgets, meant to model the positioning of the widgets after a designer imprecisely drags the widgets into the application workspace 414 from the widget palette 410. For comparison purposes, Figure 26 illustrates one aligning process, which may be executed by an automatic layout tool to align
widgets on a screen. For example, the tool can use a "right, left, or center" alignment to left- align widgets along a vertical line on the left side of the screen, right-align widgets along a vertical line on the right side of the screen, or center-align widgets along a vertical line at the center of the screen. As shown in Figure 26, when a left-align process is applied to selected widgets 2604-2612, without using knowledge of the most significant graphical display subcomponents of the selected widgets 2604-2612, a visually undesirable arrangement of user interface elements results.
[00320] The smart-alignment tool, however, can obtain information about the first- class widgets dragged from the widget palette 410 that informs the tool of the most significant graphical display sub-component border in each widget, and use this information, perhaps along with information regarding the dimensions of a designer-provided selection 2614, to automatically and intelligently align the selected widgets. This information may already be set in widgets provided by the creator of the development environment 400, or, as disclosed above, may be set by a designer of additional widgets such as compound widgets. Such information may be stored in widget metadata, and made available to the development environment 400 upon loading or instantiation of each widget. In some embodiments, the information may be accessible via some other manner, such as a separate list or database of widget parameters available locally or at a remote computing device. Other possibilities exist as well.
[00321] In addition to identifying the most significant graphical display subcomponent, information regarding the border of the most significant graphical display subcomponent may also be defined within the first-class widget. For example, in the case of the text field widget 2604, which is includes a label "Name" and a text box disposed to the right of the label, the text box may be defined as the most significant graphical display subcomponent of the text field widget, as detailed above with respect to the example set forth in
Figure 22. Furthermore, the left-side border of the text box may be defined as the most significant graphical display sub-component of the text field widget. The development environment 400 could then use this information, and similar information stored in the text field widgets 2606 and 2608, to automatically align the widgets relative to one another, with minimal input from the designer.
[00322] Other widgets may similarly contain most significant graphical display subcomponent and most significant graphical display sub-component border information. For example, a checkbox widget may include a square check-box and a label (adjacent the checkbox in the vertical or horizontal direction). In the event the label appears to the left of the check-box, the square check-box may be identified as the most significant graphical display sub-component, and the left-side border of the square check-box identified as the most significant graphical display sub-component border. Similar to the text- field widget, this would allow the square check-box sub-component of vertically-disposed checkbox widgets to all be aligned in a visually -pleasing manner, regardless of the length of the text label appearing to the left of each checkbox widget.
[00323] In some cases, each widget may contain more than one identified most significant graphical display sub-component border, to allow for alignment in both the horizontal and vertical direction. Taking the checkbox widgets for example, if instead the labels appeared below the checkboxes, and the checkboxes were all disposed to appear horizontally adjacent one another, the top-border of the square check-box may be additionally or alternatively indicated as a most significant graphical display sub-component border of the checkbox widget to allow automatic relative vertical alignment of the horizontally-disposed check-box widgets by the development environment 400.
[00324] In some embodiments, compound widgets created in accordance with the above may have most significant graphical display sub-component and most significant
graphical display sub-component border information set by the designer, and available for the development environment 400 to use in aligning compound widgets with one another, with non-compound widgets, and with groups of widgets. Other possibilities exist as well.
[00325] Figure 27 illustrates an example of an automatic alignment process executed by the smart-align process having access to most significant graphical display sub-component of widgets 2704-2712. In this example, it is assumed that the widgets 2704-2708 identify the text box as their most significant graphical display sub-component, and the left-side of the text box as their most significant graphical display sub-component. It is further assumed that the widgets 2710 and 2712 identify their most significant graphical display sub-component as the outer border, and their most significant graphical display sub-component border as the right side of the border (and perhaps the bottom-side of the border for vertical alignment). In some embodiments, however, such most significant graphical display sub-component may not be provided for buttons, but instead may be automatically inferred by the smart-align tool once the type of widget (button) is determined by the smart-align tool.
[00326] As shown in Figure 27, by taking into consideration most significant graphical display sub-component information of the widgets 2704-2708, these widgets are
automatically left-aligned with on another based on the left-side border of the text field subcomponent of each widget. In addition, the smart-align tool may align the widgets 2704- 2708 to ensure that an even amount of white-space is included between the widgets in the vertical direction. For example, the smart alignment tool may calculate a total amount of space between the top of the top-most widget 2704 and the bottom of the bottom- most widget 2708, and redistribute the total amount of free space evenly in the vertical direction. A similar white space redistribution process could be applied to horizontally-aligned widgets. In at least one embodiment, a variable set by a designer or the development environment 400 may determine a desired inter-widget white space, and the smart alignment tool may apply
the white space requirement automatically between the selected widgets (all selected widgets, or just the selected widgets of the same type, among other possibilities).
[00327] In regard to the widgets 2710 and 2712, the smart align tool may utilize the most significant graphical display sub-component and most significant graphical display subcomponent border information stored in the widgets 2710 and 2712, and right-align them to the right-most side of the selection 2702 dimensions. In at least one embodiment, instead of using the selection 2702 dimensions, the smart-align tool may determine a right-most position of the remaining widgets within the selection 2702 (e.g. the widgets 2704-2708), and align a right-most side of the widgets 2710 and 2712 with the right-most side of the widgets 2704-2708. In the example of Figure 27, this rule would shift the widgets 2710 and 2712 slightly to the left.
[00328] In at least one embodiment, the smart alignment tool may be configured to locate all buttons in a grouped selection that are on approximately the same horizontal axis, automatically align them among one another by their middle points, and then right-align them to the right-most edge of the selection 2702 or the right-most edge of the right-most widget (besides the buttons) in the selection, without considering most significant graphical display sub-component or most significant graphical display sub-component border information that may be available with respect to the button widgets. Applying such a process to the buttons 2610 and 2612 in Figure 26 would result in an arrangement of buttons similar to that shown by buttons 2710 and 2712 in Figure 27.
[00329] The alignment information generated by the smart-align tool may be stored in the development environment 400 and/or stored in the application model datastore 102.
Accordingly, alignment information and widget groupings can be preserved in future instances of the cloud-based application or application model 312, and available to the designer for use in future cloud-based applications.
[00330] Figure 28 is a flow chart according to an example method 2800 for aligning widgets within a grouping in accordance with the currently disclosed alignment method. At a block 2802, a most significant graphical display sub-component is determined for each widget in a selection or perhaps on a page in the stack. This information could be stored in the development environment 400, the application model datastore 102, or in widget or compound widget metadata. At a block 2803, a respective most significant graphical display sub-component border is determined for each widget in a selection or perhaps on a page in the stack. This information could be stored in the development environment 400, the application model datastore 102, or in widget or compound widget metadata. At a block 2804, a grouping relationship between each of the widgets is determined. The grouping relationship could be based on a selection of widgets by a designer, or the existence of the widgets on a same page of the application stack, among other possibilities. In some instances, the development environment 400 may create additional sub-groupings within a designer- selected group or within a page. For example, referring to Figure 27, the development environment may create a sub-group of the widgets 2704-2708 as related widget types despite the fact that the selection 2702 also included widgets 2710 and 2712. In at least one embodiment, sub-groups may be selected based on similar most significant graphical display sub-component and/or most significant graphical display sub-component border information and aligned relative to one another based on such characteristics. Returning to Figure 28, at a block 2806, the smart alignment tool may align the widgets in each group based on the most significant graphical display sub-component and most significant graphical display subcomponent border information for each widget in the group.
9.2 Implicit Layout Specification
[00331] In contrast to the smart alignment tool, the implicit layout specification tool may aid the designer by automatically analyzing relationships between widgets, groups of
widgets, and perhaps screen edges, and determine how the spacing between these elements should be modified during the preview mode 304 and/or run mode 306 to more intelligently display the designed application on an ever varying number of different screen and window sizes.
[00332] There are at least two types of relationships between widgets in the disclosed development environment that will determine how spacing between them will be modified due to differences in screen and window sizes: fixed and proportional. When two widgets (or groups of widgets) have a fixed relationship, these two widgets remain the same distance apart, regardless of the size of the screen (or window) that they are rendered on. On the other hand, when two widgets (or groups of widgets) have a proportional relationship, the distance between these two widgets is varied proportional with the size of the screen (or window) that they are rendered on. Traditionally, these relationships are manually specified one by one by designers using textual constructs consistent with a particular layout markup language. An automatic implicit layout tool that could automatically determine such constructs via inferred relationships between widgets (including compound widgets), groups of widgets, and/or edges of the screen or window would save designers significant time and reduce the complexity of user interface development.
[00333] In one embodiment an implicit layout algorithm is applied to a page in the stack to automatically determine whether widgets, groups of widgets, and/or edges of the screen or window should have a proportional or a fixed relationship (if any) to one another.
Figure 29 is a flow chart describing one example of such a method 2900. At a block 2902 a first set of connections is identified including (i) each connection between each pair of widgets that do not belong to a group of widgets, (ii) each connection between each group of widgets and each widget that does not belong to a group of widgets, and (iii) each connection between groups of widgets. The first set may be stored as a comma separated value (CSV)
list, a graph, or any other representation capable of identifying such links. In one embodiment, the block 2902 may also include identifying connections between widgets and first and second edges of the page, and between groups of widgets and first and second edges of the page.
[00334] At a block 2904, a default weight is assigned to each connection in the first set of connections identified in the block 2902. For example, in one embodiment, a default weight may be a rational number between 1 and 10, such as 3.0. In another embodiment, the default weight may be some other integer, decimal, fractional, real, or imaginary value.
[00335] At a block 2906, each default weight in the first set is raised or lowered dependent upon whether the widget in question is part of a group or is not part of a group. If the widget is part of a group, the default weight is raised, otherwise, it is lowered (or vice versa, depending on the implementation). For example, if the default weight is 3.0 and the widget is part of a group, the connection weight may be raised by 1.0 (approximately 1/3 of the default weight). Otherwise, if the widget is not part of a group, the weight may be lowered by 0.6 (approximately 1/5 of the default weight). Other weighting values could also be applied.
[00336] In one embodiment, the block 2906 may also include raising the default weight of each connection in the first set dependent upon whether one end of the connection is connected to the first or second edge of the page, assuming that such connections were identified in the block 2902. For example, if one of the connections is attached to a page edge, the connection weight may be raised by, for example, 0.8 (approximately 4/15 of the default weight). Other weighting values could also be applied.
[00337] At a block 2908, a distance multiplier is applied to each connection in the first set relative to the lay-out distance between each endpoint in the connection. In one embodiment where a square root operation acts as the distance multiplier, the weight of each
connection may be divided by the square root of the lay-out distance. In another embodiment, a cubed root may be used as the distance multiplier. Other possibilities exist as well.
[00338] At a block 2910, the calculated weight for each connection in the first set is compared to a threshold value to determine if there is a threshold minimum relationship between the end-points of the connection. In one embodiment, the first threshold may be within the range of 0.7-0.9, such as 0.8. Other threshold values could alternatively be used, including other integer, decimal, fractional, real, or imaginary values. Connections in the first set that do not meet the first threshold value may be discarded and not considered any further (e.g., they will have neither a fixed nor proportional relationship). In one example, those connections having a calculated weight less than (or less than or equal to) the first threshold value may be discarded. Other relative relationships could be used as well. At a block 2912, a second set of connections is identified including those from the first set that meet (or, in another embodiment, do not meet) the first threshold value.
[00339] At a block 2914, the weights of a connection in the second set are compared to a second threshold value to determine whether the connection should be one of a fixed or proportional distance connection. The second threshold value may be, for example, within the range of 1.0- 1.2, such as 1.1. Other threshold values could alternatively be used, including other integer, decimal, fractional, real, or imaginary values.
[00340] In some embodiments, if the second threshold is met, the connection is identified as a fixed-distance connection, and if the second threshold is not met, the connection is identified as a proportional-distance connection. In other embodiments, if the second threshold is met, the connection is identified as a proportional-distance connection, and if the second threshold is not met, the connection is identified as a fixed-distance connection. Connections that have a weight substantially equal to the threshold value could
alternatively be identified as a proportional-distance connection or a fixed-distance connection.
[00341] As shown in Figure 29, in one example, if the calculated weight is greater than the second threshold (e.g., 1.1), the connection may be identified as a fixed-distance connection at the block 2916. On the other hand, if the calculated weight is greater than (or equal to) the second threshold value, the connection may be identified as a proportional- distance connection at the block 2918.
[00342] In this manner, a development environment implicit layout tool can implicitly and automatically determine how widgets (and groups of widgets) on a page should be laid out relative to one another (on initial screen-layout or upon a resizing of the window by a user or designer), by taking into consideration the original layout by the designer, and the characteristics of the widgets with respect to one another, and/or the edges of the page. This process advantageously relieves the designer of explicitly specifying all such relationships and manually defining each relationship.
[00343] In some embodiments, a visual representation of the implicit layout results of the flow chart 2900 may be provided to the designer. Figure 30 illustrates an example of such a result in the development environment 400. The designer may use the visual representation to edit or fine-tune the constraints automatically determined during implicit layout generation.
In this mode, connections between widgets (and groups of widget) are visualized. For example, a widget group 3002, including the widgets 2704, 2706, and 2708 from Figure 27, and a widget group 3008, including the widgets 2710 and 2712 from Figure 27, are illustrated.
The widget group 3002 is shown connected to a first screen edge (the top edge) via a vertical constraint line 3004 and to a second screen edge (the left edge) via a horizontal constraint line
3006. The widget group 3002 is further connected to the widget group 3008 via a vertical constraint line 3010. The visual style of the constraint lines may be used to illustrate the type
of line. For example, the dashed vertical constraint line 3004 and horizontal constraint line 3006 may represent a proportional-distance connection, while the separately-styled vertical constraint line 3010 may represent a fixed-distance connection. Other possibilities exist as well. In this mode, the designer could also add new layout relationships between widgets and remove existing (or implicitly created) relationships between widgets.
10. Conclusion
[00344] With respect to any or all of the ladder diagrams, message flows, and flow charts in the figures and as discussed herein, each block may represent a processing of information and/or a transmission of information in accordance with example embodiments. Alternative embodiments are included within the scope of these example embodiments. In these alternative embodiments, for example, functions described as blocks, transmissions, communications, requests, responses, and/or message may be executed out of order from that shown or discussed, including substantially concurrent or in reverse order, depending on the functionality involved. Further, more or fewer blocks and/or functions may be used with any of the ladder diagrams, message flows, and flow charts discussed herein, and these ladder diagrams, message flows, and flow charts may be combined with one another, in part or in whole.
[00345] A block that represents a processing of information may correspond to circuitry that can be configured to perform the specific logical functions of a herein-described method or technique. Alternatively or additionally, a block that represents a processing of information may correspond to a module, a segment, or a portion of program code (including related data), and the program code may include one or more instructions executable by a processor for implementing specific logical functions or actions in the method or technique.
The program code and/or related data may be stored on any type of computer readable medium such as a storage device including a disk or hard drive or other storage medium.
[00346] The computer readable medium may also include non-transitory computer readable media such as computer-readable media that stores data for short periods of time like register memory, processor cache, and random access memory (RAM). The computer readable media may also include non-transitory computer readable media that stores program code and/or data for longer periods of time, such as secondary or persistent long term storage, like read only memory (ROM), optical or magnetic disks, compact-disc read only memory (CD-ROM), for example. The computer readable media may also be any other volatile or non-volatile storage systems. The computer readable medium may be considered a computer readable storage medium, for example, or a tangible storage device.
[00347] Moreover, a block that represents one or more information transmissions may correspond to information transmissions between software and/or hardware modules in the same physical device. However, other information transmissions may be between software modules and/or hardware modules in different physical devices.
[00348] While various aspects and embodiments have been disclosed herein, other aspects and embodiments will be apparent to those skilled in the art. The various aspects and embodiments disclosed herein are for purposes of illustration and are not intended to be limiting, with the true scope and spirit being indicated by the following claims.
Claims
1. A method, performed by a computing device, the method comprising:
displaying on the computing device, via a graphical development environment, a user interface of an application, wherein the graphical development environment has access to an application model and a data model, wherein the application model includes program logic of the application and a representation of the user interface of the application, wherein the data model includes a database schema for storing data used by the application, and wherein the graphical development environment is controlled by a script-based execution platform operating on the computing device;
the computing device receiving a change to the user interface of the application; and in response to receiving the change, the computing device (i) applying a modification to the application model and the data model to incorporate the change, and (ii) automatically transmitting a representation of the modification to a server device, wherein the server device stores copies of the application model and the data model.
2. The method of claim 1, wherein the representation of the user interface comprises a representation of a web page that includes a widget.
3. The method of claim 2, wherein the widget contains text and graphical content, and wherein use of the widget triggers execution of a script.
4. The method of claim 1, wherein an instance of the graphical development environment is in a design mode, wherein the instance of the graphical development environment receives the change to the application, the method further comprising:
based on receiving the change to the user interface of the application, the computing device (i) automatically updating a first instance of the application executing in a preview mode to incorporate the change, and (ii) refraining from updating a second instance of the application executing in a run mode.
5. The method of claim 1, wherein receiving the change to the user interface of the application comprises:
the computing device receiving a script containing additional program logic, wherein the script is associated with a new widget added to the user interface of the application by the change;
in response to receiving the script, the computing device transmitting the script to the server device;
after transmitting the script to the server device, the computing device receiving a compiled version of the script from the server device; and
in response to receiving the compiled version of the script from the server device, the computing device adding the compiled version of the script to the program logic of the application.
6. The method of claim 5, wherein the script controls a value of at least one unit of data stored in the database schema.
7. The method of claim 5, wherein adding the compiled version of the script to the program logic of the application comprises:
the computing device storing the compiled version of the script in a compiled scripts module of the application; and
the computing device linking the program logic of the application to the additional program logic of the compiled script via a script callbacks module.
8. An article of manufacture including a non-transitory computer-readable medium, having stored thereon program instructions that, if executed by a computing device, cause the computing device to perform operations comprising:
displaying, via a graphical development environment, a user interface of an application, wherein the graphical development environment has access to an application model and a data model, wherein the application model includes program logic of the application and a representation of the user interface of the application, wherein the data model includes a database schema for storing data used by the application, and wherein the graphical development environment is controlled by a script-based execution platform operating on the computing device;
receiving a change to the user interface of the application; and
in response to receiving the change, (i) applying a modification to the application model and the data model to incorporate the change, and (ii) automatically transmitting a representation of the modification to a server device, wherein the server device stores copies of the application model and the data model.
9. The article of manufacture of claim 8, wherein the representation of the user interface comprises a representation of a web page that includes a widget.
10. The article of manufacture of claim 9, wherein the widget contains text and graphical content, and wherein use of the widget triggers execution of a script.
11. The article of manufacture of claim 8, wherein an instance of the graphical development environment is in a design mode, wherein the instance of the graphical development environment receives the change to the user interface of the application, the computer-readable medium, having further stored thereon program instructions that, if executed by a computing device, cause the computing device to perform operations comprising:
based on receiving the change to the user interface of the application, (i) automatically updating a first instance of the application executing in a preview mode to incorporate the change, and (ii) refraining from updating a second instance of the application executing in a run mode.
12. The article of manufacture of claim 8, wherein receiving the change to the user interface of the application comprises:
receiving a script containing additional program logic, wherein the script is associated with a new widget added to the user interface of the application by the change;
in response to receiving the script, transmitting the script to the server device;
after transmitting the script to the server device, receiving a compiled version of the script from the server device; and
in response to receiving the compiled version of the script from the server device, adding the compiled version of the script to the program logic of the application.
I l l
13. The article of manufacture of claim 12, wherein the script controls a value of at least one unit of data stored in the database schema.
14. The article of manufacture of claim 12, wherein adding the compiled version of the script to the program logic of the application comprises:
storing the compiled version of the script in a compiled scripts module of the application; and
linking the program logic of the application to the additional program logic of the compiled script via a script callbacks module.
15. A system comprising:
means for displaying on a computing device, via a graphical development environment, a user interface of an application, wherein the graphical development environment has access to an application model and a data model, wherein the application model includes program logic of the application and a representation of the user interface of the application, wherein the data model includes a database schema for storing data used by the application, and wherein the graphical development environment is controlled by a script- based execution platform operating on the computing device;
means for receiving a change to the user interface of the application; and
means for, in response to receiving the user interface of the application, (i) applying a modification to the application model and the data model to incorporate the change, and (ii) automatically transmitting a representation of the modification to a server device, wherein the server device stores copies of the application model and the data model.
16. The system of claim 15, wherein an instance of the graphical development environment is in a design mode, wherein the instance of the graphical development environment receives the change to the user interface of the application, the system further comprising:
means for, based on receiving the change to the user interface of the application, (i) automatically updating a first instance of the application executing in a preview mode to incorporate the change, and (ii) refraining from updating a second instance of the application executing in a run mode.
17. The system of claim 15, wherein receiving the change to the application comprises:
means for receiving a script containing additional program logic, wherein the script is associated with a new widget added to the user interface of the application by the change; means for, in response to receiving the script, transmitting the script to the server device;
means for, after transmitting the script to the server device, receiving a compiled version of the script from the server device; and
means for, in response to receiving the compiled version of the script from the server device, adding the compiled version of the script to the program logic of the application.
18. The system of claim 17, wherein the script controls a value of at least one unit of data stored in the database schema.
19. The system of claim 17, wherein adding the compiled version of the script to the program logic of the application comprises: means for storing the compiled version of the script in a compiled scripts module of the application; and
means for linking the program logic of the application to the program logic of the compiled script via a script callbacks module.
20. A computing device comprising:
a script-based execution platform providing and controlling a graphical development environment;
an application model including (i) program logic of an application presented in the graphical development environment, and (ii) a representation of a user interface of the application; and
a data model including a database schema for storing data used by the application, wherein the execution platform (i) receives a change to the user interface of the application, (ii) in response to receiving the change, applies a modification to the application model and the data model to incorporate the change, and automatically transmits a representation of the modification to a server device, wherein the server device stores copies of the application model and the data model.
Applications Claiming Priority (12)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US13/106,134 | 2011-05-12 | ||
US13/106,170 US9141346B2 (en) | 2011-05-12 | 2011-05-12 | Layout management in a rapid application development tool |
US13/106,212 | 2011-05-12 | ||
US13/106,112 US8806348B2 (en) | 2011-05-12 | 2011-05-12 | Data model generation based on user interface specification |
US13/106,212 US20120291011A1 (en) | 2011-05-12 | 2011-05-12 | User Interfaces to Assist in Creating Application Scripts |
US13/106,112 | 2011-05-12 | ||
US13/106,214 | 2011-05-12 | ||
US13/106,214 US20120291006A1 (en) | 2011-05-12 | 2011-05-12 | Development Architecture for Cloud-Based Applications |
US13/106,191 | 2011-05-12 | ||
US13/106,191 US8671387B2 (en) | 2011-05-12 | 2011-05-12 | Compilation and injection of scripts in a rapid application development |
US13/106,134 US8788955B2 (en) | 2011-05-12 | 2011-05-12 | Creation and configuration of compound widgets |
US13/106,170 | 2011-05-12 |
Publications (1)
Publication Number | Publication Date |
---|---|
WO2012154310A1 true WO2012154310A1 (en) | 2012-11-15 |
Family
ID=45922851
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
PCT/US2012/030340 WO2012154310A1 (en) | 2011-05-12 | 2012-03-23 | Development architecture for cloud-based applications |
Country Status (1)
Country | Link |
---|---|
WO (1) | WO2012154310A1 (en) |
Cited By (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP2735977A1 (en) * | 2012-11-21 | 2014-05-28 | Alcatel-Lucent | Media cloud copyless message passing |
US10216503B2 (en) | 2013-03-13 | 2019-02-26 | Elasticbox Inc. | Deploying, monitoring, and controlling multiple components of an application |
Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2001002928A2 (en) * | 1999-07-01 | 2001-01-11 | Bigstep.Com, Inc. | An integrated platform and data model for developing and maintaining a distributed multiapplication online presence |
US20070005634A1 (en) * | 2005-06-29 | 2007-01-04 | Microsoft Corporation | Templates in a schema editor |
US20100146481A1 (en) * | 2008-12-09 | 2010-06-10 | Microsoft Corporation | Developing applications at runtime |
-
2012
- 2012-03-23 WO PCT/US2012/030340 patent/WO2012154310A1/en active Application Filing
Patent Citations (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2001002928A2 (en) * | 1999-07-01 | 2001-01-11 | Bigstep.Com, Inc. | An integrated platform and data model for developing and maintaining a distributed multiapplication online presence |
US20070005634A1 (en) * | 2005-06-29 | 2007-01-04 | Microsoft Corporation | Templates in a schema editor |
US20100146481A1 (en) * | 2008-12-09 | 2010-06-10 | Microsoft Corporation | Developing applications at runtime |
Cited By (2)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP2735977A1 (en) * | 2012-11-21 | 2014-05-28 | Alcatel-Lucent | Media cloud copyless message passing |
US10216503B2 (en) | 2013-03-13 | 2019-02-26 | Elasticbox Inc. | Deploying, monitoring, and controlling multiple components of an application |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US10740072B2 (en) | Layout management in a rapid application development tool | |
US9465822B2 (en) | Data model generation based on user interface specification | |
US8671387B2 (en) | Compilation and injection of scripts in a rapid application development | |
US8788955B2 (en) | Creation and configuration of compound widgets | |
US20120291011A1 (en) | User Interfaces to Assist in Creating Application Scripts | |
US20120291006A1 (en) | Development Architecture for Cloud-Based Applications | |
US11461545B2 (en) | Grid data management | |
US8584082B2 (en) | System for dynamic discovery, configuration, and development of process-bound widgets | |
US10088980B2 (en) | Method and system for providing menu data for mobile applications | |
US8499286B2 (en) | Module testing adjustment and configuration | |
US11797273B2 (en) | System and method for enhancing component based development models with auto-wiring | |
US11468229B2 (en) | Describing changes in a workflow based on changes in structured documents containing workflow metadata | |
US11194450B2 (en) | Definition of a graphical user interface dashboard created with manually input code and user selections | |
JP2023070148A (en) | Systems and methods for dynamically binding robotic process automation (RPA) robots to resources | |
US20220067272A1 (en) | Robotic Process Automation Systems and Methods Using A Helper Spreadsheet | |
WO2012154310A1 (en) | Development architecture for cloud-based applications | |
US11294644B2 (en) | Inversion of control framework for multiple behaviors on top of a process | |
US20230051662A1 (en) | Custom components in a data-agnostic dashboard runtime | |
US20240129402A1 (en) | Customization framework for native mobile applications | |
Mertic | The Definitive Guide to SugarCRM |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
121 | Ep: the epo has been informed by wipo that ep was designated in this application |
Ref document number: 12711542Country of ref document: EPKind code of ref document: A1 |
|
NENP | Non-entry into the national phase |
Ref country code: DE |
|
122 | Ep: pct application non-entry in european phase |
Ref document number: 12711542Country of ref document: EPKind code of ref document: A1 |