US5710719A - Apparatus and method for 2-dimensional data compression - Google Patents
Apparatus and method for 2-dimensional data compression Download PDFInfo
- Publication number
- US5710719A US5710719A US08/545,513 US54551395A US5710719A US 5710719 A US5710719 A US 5710719A US 54551395 A US54551395 A US 54551395A US 5710719 A US5710719 A US 5710719A
- Authority
- US
- United States
- Prior art keywords
- pixel
- prior
- matching
- scanned
- pixels
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime
Links
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL
- G06T9/00—Image coding
- G06T9/40—Tree coding, e.g. quadtree, octree
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/50—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding
- H04N19/593—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using predictive coding involving spatial prediction techniques
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/10—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding
- H04N19/102—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using adaptive coding characterised by the element, parameter or selection affected or controlled by the adaptive coding
- H04N19/13—Adaptive entropy coding, e.g. adaptive variable length coding [AVLC] or context adaptive binary arithmetic coding [CABAC]
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/60—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using transform coding
-
- H—ELECTRICITY
- H04—ELECTRIC COMMUNICATION TECHNIQUE
- H04N—PICTORIAL COMMUNICATION, e.g. TELEVISION
- H04N19/00—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals
- H04N19/90—Methods or arrangements for coding, decoding, compressing or decompressing digital video signals using coding techniques not provided for in groups H04N19/10-H04N19/85, e.g. fractals
- H04N19/91—Entropy coding, e.g. variable length coding [VLC] or arithmetic coding
Definitions
- This invention relates to data compression systems, and more particularly to an apparatus and method for compressing image data into a compressed form and for decompressing the compressed form.
- data compression refers to any process in which data in a given format is converted into an alternative format, in which the alternative format has fewer bits than the original format.
- Data compression systems are well known in the art and are used to encode an original stream of digital data signals into compressed digital data signals and to decode the compressed digital data signals back into the original data signals.
- data compression is advantageous because it provides a savings in the amount of time required to transmit a given body of digital information and in the amount of storage required to hold digital information.
- redundancy compression methods have been used to compress data files so that they will occupy less space on a storage device or so that they can be transmitted in less time over a communications channel.
- a text file is a data file that contains a series of textual characters, such as letters of the alphabet, numbers, and/or punctuation marks.
- an initial target character in the series of textual characters is located.
- the characters prior to the initial target character are then searched (or traversed) in a reverse direction, beginning at the character immediately preceding the initial target character, until a prior character is located that matches the target character.
- an initial matching prior character is located, an attempt is made to extend the match beyond the target character to identify a matching "character string" of prior characters.
- the search moves "forward" to a new target character immediately following the initial target character and also moves "forward” to a next prior character immediately following the initial matching prior character, and the system determines whether the succeeding target and prior characters match. If so, the process continues along the string of succeeding prior characters until a matching fails. The matching character string is then defined from the initial matching prior character to the last matching prior character.
- the matching character string may be represented by two data items: (1) the beginning point of the string of matching prior characters (i.e., the location within the series of characters of the initial matching prior character); and (2) the length of the string of matching prior characters.
- the string of target characters that matches the prior characters is represented simply as data indicating (1) the initial position of the matching data string and (2) the length of the string.
- a string of target characters having a matching prior character string is represented by fewer bits than if each target character were independently encoded.
- a "longest matching data string" is sought.
- the process does not stop when a first matching data string is located. Instead, the search continues in a reverse direction back through the prior characters, beginning with the prior character immediately preceding the initial matching prior character. The process continues until a longest matching data string is located (which may be the initial matching data string). By locating the longest matching data string, rather than merely stopping at the first matching data string, further compression of the data text may be accomplished.
- redundancy compression is illustrated.
- the first character, "T” is encoded as a "literal” code, meaning that it is uncompressed (and indeed may be slightly expanded by a flag bit indicating that it is a literal code).
- the second character, "H” then becomes the target character, and the previously encoded characters are searched in an attempt to find a match.
- the only preceding character that has been encoded is the initial "T,” which does not match the next character, "H.” Accordingly, the "H” character is encoded as a literal code.
- Each succeeding character after "H” then becomes the target character, and the previously encoded characters are searched for a match. Discounting, for this example, the blank space between “RAIN” and “IN,” the first character match occurs at the “T” in the first occurrence of the word “IN,” which matches the "T” in the word “RAIN.”
- the search for a matching string then begins, and the new target character becomes the "N” in "IN.”
- the character immediately following the matching "T” in the word "RAIN” is thus compared to the new target character to determine if a match exists. As can be seen, a match does exist, because the new target character and the character immediately following the preceding matching character are both an "N.” The process continues until a match does not occur.
- the matching data string located by this redundancy technique is “IN” (with the blank space following the "N” also having a matching previous blank space).
- the matching data string, i.e., "IN” is then compressed by encoding it as the initial location of the initial character in the matching data string (i.e., the "T” in "RAIN") and the length of the matching data string (in this case, three characters “T", "N", and "blank space”). This process is continued throughout the text file until the entire file is compressed and encoded. As described above, the process could continue after a first matching string is located in an effort to locate a longest matching string.
- Image data includes a two-dimensional array of pixels. Each pixel may be considered to be the equivalent of a character in a text file. Each pixel represents a point in the image and includes data representing, for example, the color and intensity of the pixel.
- images may have entire areas that are uniform or quite similar in appearance (for example, a blue ocean constituting a large area of the image), pixel data may be extensively replicated in a patterned manner within the image. Thus, redundant pixels may be more likely to occur in certain positions relative to a target pixel than in other positions relative to that pixel.
- the search for a prior pixel that matches the target pixel is performed by traversing "backward," one pixel at a time and in order, through the prior pixels.
- the pixels are simply traversed linearly backward through the prior pixels until a match, if any, is located. Accordingly, using the linear traversing method to compress image data is inefficient and fails to achieve high-speed image data compression. Because it is extremely important in data compression systems to maximize the speed at which image data is compressed (or decompressed), the relatively slow speed of the linear traversing method degrades system performance, making the method disadvantageous for compressing and decompressing image data.
- a "history array,” “history array pointer,” “hash table,” and “offset array” are used to search back through prior pixels to locate matching pixel strings.
- the history array contains a number of entries, each entry for storing a portion of the input data stream of prior pixels.
- the history array pointer points to the latest entry in the hash array.
- the hash table contains a series of entries that contain history array pointers.
- the offset array (or hash link table) points to the previous entry in the history array that corresponds to a particular hash value, and another item in the offset array points to the oldest entry in the history array associated with this hash value.
- the history array pointer, hash table, and offset array constitute a "hash data structure.”
- the history array pointer, hash table, and offset array are used to find specified strings stored in the history array, which is searched for a longest matching pixel string that matches a string of pixels in the input data stream.
- a hashing function must be performed, which includes several steps. First, the results of a hashing function must be obtained, which function provides a pointer to one of the entries in the hash table. Second, the pointer stored in the hash table that is pointed to by the result of the hash function is obtained.
- systems that employ the hashing method for data compression are complex and resource intensive.
- systems employing the hashing method for compressing image data are difficult and expensive to implement and are slowed by their computation requirements for carrying out the hashing method.
- the present invention is a method and apparatus for compressing a stream of data and for decompressing previously compressed data.
- the data may represent an image that is either two-dimensional or three-dimensional. It should be recognized, however, that the present invention could be used to compress any type of data, including character data.
- the present invention takes advantage of the observation that image data may have redundancy in two dimensions, with large areas of the same or similar color.
- the present invention uses this fact to traverse image pixels in a predetermined pattern designed to minimize the number of prior pixels that must be traversed to find the longest matching string of prior pixels.
- an incoming stream includes a plurality of incoming data pixels, of which two or more constitute an incoming data string.
- the method includes several steps.
- the incoming data stream is initially read to obtain prior data, which includes prior data strings.
- the prior data is then searched in a predetermined non-linear traversing pattern for longest matching prior data strings that match incoming target data strings. If any longest matching data strings are found, they are compressed and encoded into copy tokens. Any incoming target data pixels that have no matching prior pixel are encoded as literal tokens.
- the copy and literal tokens are then entropy coded and output to storage or for transmission.
- a target pixel is compared to prior pixels in a pixel array to determine whether any of the prior pixels matches the target pixel.
- the prior pixels are searched in an empirically predetermined non-linear two-dimensional traversing pattern that traverses the prior pixels in a manner designed to minimize the time it takes to locate matching prior pixels and thereby optimize the compression rate.
- the non-linear traversing pattern may be held constant throughout the process of compressing an entire image, or may vary to accommodate "boundary" conditions (e.g., edges of an image) or in response to "learned" or heuristically determined characteristics of a particular image.
- non-linear pixel offset refers to the number of pixels, in the non-linear traversing pattern, lying between the initial target pixel and the initial matching prior pixel.
- the process continues until a next prior pixel does not match a corresponding next target pixel.
- the number of matching prior pixels constitutes a string length for the matching data string, and the location of the initial matching prior pixel in the non-linear traversing pattern becomes the non-linear pixel offset for the matching data string.
- the "linear pixel offset" of the initial matching pixel can be generated from the non-linear pixel offset and from the position of the target pixel within the array of pixels.
- linear pixel offset means the number of pixels, in linear order within the array of pixels, lying between the target pixel and the initial matching pixel.
- the process continues, using the predetermined non-linear traversing pattern to locate additional matching prior pixel strings, if any. Any longer match replaces an earlier, shorter match.
- the method includes a reasonable limit on the number of prior pixels searched via the traversing pattern.
- the process of searching for matching prior pixel strings may stop before reaching the beginning of all prior pixels.
- the longest matching string is then encoded as a "copy token," which includes data indicating the non-linear pixel offset of the longest matching string and its string length.
- the unmatched target pixel is encoded as a "literal token.”
- the process of searching for matching strings continues to the end of the pixels comprising the image, thereby locating all copy tokens and all literal tokens to form a token set.
- the token set is then further globally encoded (preferably using a Huffman data compression algorithm) to obtain a stream of encoded compressed image data.
- This stream of encoded compressed image data is then transmitted or stored. If transmitted, when the stream of encoded compressed image data is received, it is decoded using a decoding algorithm to obtain a decoded stream of compressed image data. If stored, when the stream of encoded image data is retrieved, it is decoded using a decoding algorithm (e.g., Huffman decoding), also thereby obtaining a decoded stream of compressed image data.
- a decoding algorithm e.g., Huffman decoding
- pixels are considered to be "matching" only if the pixels being compared contain identical data.
- the target pixel if a target pixel does not identically match any of the prior pixels traversed by the non-linear traversing pattern, the target pixel will be encoded as a literal token, and the process will continue throughout the array of pixels in an attempt to find strings of identically matching pixels.
- a target pixel and prior pixel are considered to be a "match” even if they are not identical, provided the prior pixel falls within a preset tolerance of the target pixel.
- the prior pixel is compared to the target pixel, and if the prior pixel falls within the preset tolerance of the target pixel, the prior pixel is considered a "match.”
- similar but non-identical colors can be deemed to "match.”
- target pixels following an initial target pixel are compared to corresponding prior pixels following the initial matching prior pixel, and in each case the preset tolerance is applied to the target pixels.
- This embodiment permits higher compression ratios, but results in "lossy" compression.
- the present invention overcomes disadvantages and drawbacks of prior art compression methods.
- the nonlinear traversing pattern has been empirically determined so that it locates longest matching data strings much more quickly and with less pixel traversing than is required with the linear traversing method of the prior art. Accordingly, compression speed is substantially increased.
- the present invention eliminates the need for complex circuitry and time-consuming computations required in the hashing method. Thus, the present invention is less costly, less complex, and faster than hashing.
- FIG. 1 is block diagram of a programmable computer system for implementing the compression and decompression method of the present invention.
- FIG. 2 is a flow diagram showing the basic method of the preferred embodiment of the present invention.
- FIG. 3 is a flow diagram showing in detail the process for locating and tokenizing longest matching data strings and unmatched target pixels in accordance with the present invention.
- FIG. 4 is a flow diagram showing a more detailed version of the entire compression/decompression process of the preferred embodiment of the present invention.
- the following describes a procedure, preferably implemented as a computer program stored on a storage media or device (e.g., ROM or magnetic diskette) readable by a general purpose computer or programmable processing system, for configuring and operating the computer or processing system when the storage media or device is read by the computer or processing system, the computer or processing system being operated to perform the functions described below.
- a storage media or device e.g., ROM or magnetic diskette
- a general purpose computer or programmable processing system for configuring and operating the computer or processing system when the storage media or device is read by the computer or processing system, the computer or processing system being operated to perform the functions described below.
- FIG. 1 shows a block diagram of a typical programmable processing system 10 which may be used for implementing the compression and decompression system of the present invention.
- the processing system 10 preferably includes a CPU 12, RAM 14, ROM 16 (which may be writable, such as a flash ROM), an I/O controller 18, and an optional storage device 19, such as a magnetic disk, coupled by a CPU bus as shown. Coupled to the I/O bus are input and/or output devices, such as a display 20, a keyboard 22, and a communication port 24, as well as the I/O controller 18.
- the display 20 may be used to display an original image to be compressed.
- the programmable processing system 10 may be pre-programmed, or may be programmed (and reprogrammed) by downloading a program from another source (e.g., another computer).
- the CPU 12 must have a comparator circuit or be programmable to compare one data value to another data value to determine identity or difference between the data values, and optionally to compare the difference between two data values to a third value (e.g., a threshold value).
- the programmable processing system 10 may be coupled via a communication link 26 to a remote processing system 30. Data may be communicated over the communication link 26 between the programmable processing system 10 and the second programmable processing system 30.
- an original image may be compressed and encoded to obtain a compressed image.
- the compressed image may then be transmitted over the communication link 26 and, upon receipt, may be decoded and decompressed to obtain the original image.
- the original image may be compressed and encoded and stored in, for example, the storage device 19 to obtain a stored compressed image.
- the stored compressed image may later be retrieved by the CPU 12 and decoded and decompressed to obtain the original image, which can again be displayed on the display 20.
- the CPU 12 may house the hardware and software used to compress, encode, decode, and decompress the original image1, or such hardware and software may be resident in a remote computer or in a separate module of the programmable processing system 10.
- FIG. 2 is a flow diagram of the basic method of the present invention.
- the method shown in FIG. 2 is used for compressing an incoming data stream, which includes a plurality of incoming data pixels, of which a group of two or more comprise an incoming data stream.
- pixel means any data segment, data structure, or set of bits that define a picture element of an image regardless of color depth or colorspace model used, and includes character data.
- the method begins at a Start state 202.
- An incoming data stream (e.g., a data file or transmitted image) is read into a computer memory to obtain initial image data (Step 204).
- the data stream may represent an entire image or blocks defining a portion of an image if memory resources are exceeded. In this latter case, the blocks may be treated as "subimages" and separately compressed in accordance with the present invention.
- the present invention normally would be applied to compress a "moving window" of data representing portions of an image, such that the entire image is processed.
- an image being compressed is represented as a data file that describes an image in terms of a rectangular array of pixels, regardless of the shape of the original image (e.g., rectangular, circular, etc.). Nevertheless, images having other array configurations, such as hexagonal, may also be compressed using the procedure described below. No matter the image represented by a pixel array, however, the array has a beginning and an end, with a first "prior" pixel being located at the beginning of the pixel array and thus being the first pixel in the array.
- each longest matching prior data string comprises a prior data string that matches a data string from the incoming data stream.
- the predetermined non-linear traversing pattern has a fixed length for a single image. That is, for each target pixel, the predetermined non-linear traversing pattern has a fixed number of prior pixels that it traverses, and, for each image, the traversing pattern ceases at a predetermined number of prior pixels that are searched.
- an advantage may be gained by varying the length of the traversing pattern within a single image.
- the length of the traverse pattern may be dynamically altered within a single image.
- a fully variable (i.e., optimal) pattern may be calculated for a single image. That is, the traversing pattern may vary from image to image.
- the extent and path of the non-linear traversing pattern may be limited by the configuration of the data to be compressed.
- an image to be compressed is made up of an array of pixels having borders or limits, and the traversing pattern may include segments that fall outside the limits of the pixel array.
- the segments that fall outside the limits of the pixel array may be dynamically removed, for example, at the edges of the array.
- the removed segments are not represented in the vector comprising the longest matching data string; i.e., the removed segments are treated as if they never existed in the traversing pattern. This speeds processing, since such segment(s) are not useful in locating longest matching pixel strings.
- the predetermined non-linear traversing pattern may be determined empirically.
- a large number of test images are exhaustively scanned (in a linear fashion, as described in the background section) for prior pixels that match target pixels.
- a histogram is then calculated, revealing the frequency of matches in prior pixel locations.
- This histogram is then sorted in a descending order, and the relative pixel offsets corresponding to the sorted frequencies of matches become the preferred non-linear traversing pattern.
- a pixel offset is defined as the location in a two-dimensional array, relative to a target pixel, of a prior pixel being searched for a match with the target pixel.
- the first 24 relative pixel offsets are scanned (by default) in the following order:
- the "#" symbol represents the target pixel, or the position being encoded for which a matching prior pixel is being searched.
- the numbers 1-24 represent the first 24 relative pixel offsets, in order, in the traversing pattern.
- offsets 1-5 may be given slightly preferential treatment when encoding the pixels as tokens.
- the token scheme is described in detail below.
- offsets 1-5 are assigned unique tokens without appending additional token flag bits, which are appended to non-preferential tokens. Because of this, after an image is encoded as tokens, the five most frequently occurring of the above 24 relative offsets are identified, and all of the first 24 offsets are permuted just enough so that the five most frequently occurring offsets are assigned the optimal 1-5 token positions. This permutation is reversed during the decoding process and has no affect on other parts of the encoding/decoding process, which will be described in detail below.
- the purpose of giving slightly preferential treatment to the most frequently occurring offsets is to increase bit-packing efficiency.
- the five offsets of the highest frequency from the first 24 offsets are called the "most popular" offsets.
- the next 41 offsets are scanned in the following order:
- the "#" symbol represents the target pixel for which a matching prior pixel is sought.
- the number of locations in the non-linear traversing pattern is limited to some reasonable number to balance depth of searching (which might result in longer matches) with speed of compression.
- some of the above offsets may produce redundancies by "wrapping around" from the first to the last column, or from the last to the first column. As embodied herein, such wrapping around is allowed. Wrapping around simplifies implementation of the compression scheme. It also results in a compression increase, because colors occurring at the border of an image are often related.
- the remaining relative offsets are scanned in a linear pattern backward from the target pixel position, disregarding any offsets already considered from a prior scanning stage. For example (assuming a 16-column image), the scanning continues as follows:
- Step 210 if a longest matching prior data string is found, the corresponding matching target data string is compressed by encoding it (i.e., replacing it) with a "copy token" (Step 210). If no longest matching prior data string is found, each unmatched pixel from the incoming data stream is encoded as a "literal token" (Step 212).
- the encoding process is performed as the longest matching prior data strings and unmatched pixels are encountered.
- encoding may occur in a step-wise manner; that is, the method may be implemented such that it does not require that all located longest matching prior data strings and unmatched pixels be encoded after the entire image has been scanned.
- the encoding step may occur after the entire image has been scanned and all unmatched pixels and longest matching prior pixel strings have been located.
- the copy tokens and literal tokens are output and the process repeated (Step 214) until all pixels have been encoded, at which point the basic process ends (Step 216).
- the copy tokens and literal tokens may then be transmitted over a communication link (as illustrated in FIG. 1) to another data processing system 30. Because the incoming data stream (or image) has been compressed using the method of FIG. 2, fewer bits need be transmitted over the communication link 26 to the data processing system 30. Alternatively, the compressed data can be stored in the storage device 19, requiring less storage space than would otherwise be required if the data or image were not compressed.
- FIG. 3 illustrates Steps 204-214 of FIG. 2 in greater detail to show the preferred method of compressing an image.
- the first step in FIG. 4 is to select a "next" target pixel to be processed (Step 302). (This "next" target pixel may be the first pixel processed.) Once the target pixel is selected, prior pixels (i.e., those pixels located at prior positions within the pixel array relative to the initial target pixel) are traversed in the predetermined non-linear traversing pattern (Step 304).
- the target pixel is compared to each prior pixel encountered in the traversing pattern to determine whether any such prior pixel matches the target pixel (Step 306). If no match is found (Step 308), a test is made to see if the non-linear traversing pattern has been exhausted (Step 3 18). If not, processing continues at Step 306.
- Step 308 If a match is found (Step 308), thereby locating an initial matching prior pixel, an attempt is made to extend the match. Accordingly, target pixels following the initial target pixel and prior pixels following the initial matching prior pixel are traversed in a forward linear pattern to try to extend the initial match (Step 310). Thus, the linear traversing pattern moves toward the end of the pixel array (i.e., away from the first prior pixel).
- each target pixel following the initial target pixel has a corresponding next prior pixel.
- each target pixel following the initial target pixel is compared to its corresponding prior pixel (Step 312). If it is found that the corresponding target and prior pixels being compared match one another, Step 310 is repeated to determine whether the next corresponding target and prior pixels match one another. This process continues until a match is not found (Step 312), indicating the termination point of the current matching string of prior pixels.
- the length of the current matching string is compared to any prior saved string length for the initial target pixel currently being processed (Step 314). If the current string is the first to be found, or the current string is longer than the previously saved string, the relative offset and string length of the current matching string represent a "current" longest match and are stored (Step 316). (Preferably, as defined in the summary section, the non-linear pixel offset is stored, from which, together with the position of the target pixel, the linear pixel offset can be generated. It should be recognized, however, that the linear pixel offset alternatively could be stored.) Otherwise, the current match is discarded, and processing continues at Step 318. Alternatively, the offset and length information is immediately replaced with a copy token (see below).
- Step 308 processing repeats at Step 306 until the image pattern is exhausted.
- the non-linear traverse has a predetermined termination point, so that each and every prior pixel is not traversed.
- the non-linear traverse pattern of the present invention a determination is made as to how many prior pixels should be traversed to optimize not only compression speed, but also the amount of bit reduction. This is done by correlating the length of the non-linear traversing pattern with the likelihood of locating a longer matching string by traversing farther backward through the prior pixels.
- the point at which compression is optimized, as explained above, may be empirically determined.
- the continuation of the traversing pattern begins with the prior pixel immediately preceding, in accordance with the traverse pattern, the initial matching prior pixel of the most recent matching string.
- the next prior pixel traversed may not necessarily be the prior pixel immediately preceding, in the pixel array, such initial matching prior pixel. Rather, because the traverse pattern is non-linear, the next prior pixel to be compared to the initial target pixel may be located at a position within the pixel array that is far removed from the initial matching prior pixel. (For the preferred non-linear traversing pattern, see the above diagrams illustrating the empirically determined "pixel offsets" comprising the traversing pattern.) The process then continues in an attempt to locate another matching string of prior pixels and to determine whether such string is the longest matching string.
- Step 308 If the non-linear traverse pattern is exhausted (Step 318), either no match will have been found for the initial target pixel, or a longest string will have been found. In the former case, the target pixel is replaced with a literal token; in the latter case, the matching target string will be replaced with a copy token (Step 320). The token is then output.
- Step 304 The next initial target pixel is located at a position immediately following the last target pixel for which a matching prior pixel was sought. If, during the process of traversing the prior pixels in the non-linear traverse pattern, no prior pixel was located that matched the initial target pixel, then the next initial target pixel is the target pixel immediately following the previous initial target pixel for which no match was found. If, however, a matching string of prior pixels was located, the next initial target pixel is the target pixel immediately following the last target pixel in the string of matched target pixels.
- Step 306 the prior pixels, relative to the current target pixel (i.e., a "moving window"), are again traversed in the predetermined non-linear traversing pattern, this time searching for an initial matching prior pixel that matches the next initial target pixel.
- the method of the present invention can provide for lossy as well as lossless compression.
- lossless compression two pixels are considered “matching” only if they are identical.
- lossy compression two pixels are considered “matching” even if they are not identical, provided they fall within a preset tolerance (which may be pre-programmed, or user-definable to allow for variable degrees of compression).
- the degree of comparison between a target pixel and prior pixel may vary by the preset tolerance. If a target pixel is within the tolerance of a prior pixels, the target and prior pixels are deemed a match, and the process of matching target and prior pixels to locate matching prior pixel strings continues, until the longest string within the tolerance is found in the prior pixels.
- a variable tolerance can be used to control the degree of loss. This tolerance can be variable from image-to-image or within a single image.
- the method can be modified, such that, when searching for matches within the tolerance and an out-of-tolerance miss occurs, the matching process can continue for the string being searched to determine if additional subsequent pixels in the string are within the tolerance. If so, the "out-of-tolerance" miss can be considered a "match” anyway.
- a variation of this scheme is to have a second order tolerance indicating the average quality of hits in a string comparison.
- the total error over a matching string can be monitored, stopping the matching process if the "error” exceeds a certain threshold value ("error” referring to the difference between the prior and target pixels).
- error referring to the difference between the prior and target pixels. This can be used to minimize “streaking,” which can result from a small error (that is still within the tolerance) repeated over a large count of pixels, for example, in a background color.
- tolerance comparisons are employed in locating matching prior pixel strings, the prior pixels being scanned (or searched) are the reconstructed versions, not the original source image pixels. This is because the scanning process must take place against the same pixels that are provided to a decoder when it reconstructs the image being compressed; otherwise, the tolerance comparisons would be inaccurate. Moreover, if tolerance comparison is employed, a step can be added to produce the reconstructed pixel versions, in which matched target pixels are replaced with their matching prior pixels (from the already reconstructed image). The matching prior pixels may differ from the target pixels they are replacing, because the matching process potentially produces non-identical matches.
- the original pixel value of the target pixel is tokenized as a literal token and output.
- the decoder or decoding step responds to such literal tokens by inserting this single pixel value into the reconstructed image.
- the literal pixel may not exactly match its original, however, if it is convenient to modify the pixel later (within tolerance) to improve (e.g., lengthen or reduce total error of) a subsequent match.
- tokens greater than 255 are copy strings (or copy elements). Tokens 255 or below map directly to the literal pixel value that the tokens represent.
- copy elements may be grouped into blocks of 16, with token bits 7 through 4 determining the block. Within each block, the pixel offset meaning is identical; the lower 4 token bits define the offset and/or how many extra bits follow the token to further define the offset.
- token bits 7 through 4 for each copy block determine the copy string length and/or how many extra bits follow the token to further define the length.
- extra length bits (if any) precede extra offset bits (if any).
- Fifth, for tokens 416-431 which represent copy tokens having an extended length), two bits precede the extra length bits to indicate how many extra length bits follow.
- FIG. 4 illustrates a more detailed version of the entire compression/decompression process of the preferred embodiment of the present invention, applying the method illustrated in FIG. 2.
- the colorspace of the image data optionally may be changed, in known fashion (Step 402).
- the color space in which to encode the image data is conventional YCrCb.
- a source (or original) image is in a non-preferred colorspace (e.g., RGB)
- the image may first be converted to the preferred colorspace (i.e., YCrCb).
- CCIR International Radio Consultative Committee
- lossless conversion may only be done in cases where it is not critical for the decoded image to exactly match the source (or original) image.
- the image being compressed optionally is subsampled to reduce the value range of the image data, in known fashion (Step 406).
- the degree of subsampling may vary by the color in the image. If subsampling (Step 406) is performed, each color in the image may first optionally have a filter applied to it, in known fashion, after changing the colorspace (Step 404).
- the preferred filter uses a three-element kernel of 1, 2, 1. For a two-dimensional image, this filter is applied along both dimensions of the image. Even if the colorspace is not changed (Step 402), the image may optionally be filtered (Step 404) before subsampling (Step 406).
- the image data is prefiltered with one or more dynamically selected DPCM (differential pulse-code modulation) algorithms (Step 407).
- DPCM dynamic pulse-code modulation
- An inverse DPCM algorithm is applied when the data is decoded (Step 426), which adds no loss to the encode/decode process.
- X represents the target pixel
- B is the prior pixel directly above X in the pixel array
- C is the prior pixel immediately preceding (or to the left of) X in the pixel array.
- DPCM algorithm (1) is always used
- DPCM algorithm (2) is always used.
- no DPCM is used in the preferred embodiment.
- the image is compressed by traversing the image, pixel-by-pixel, in the predetermined non-linear traversing pattern, using the basic algorithm described in FIG. 2 and FIG. 3 (Step 408).
- an attempt is made to match each target pixel to a prior pixel encountered in the predetermined non-linear traversing pattern.
- an attempt is made to extend each match to locate the longest string of prior pixels that match a current string of target pixels.
- either palettized (8-bit) or 24-bit image data can be compressed.
- the data may be compressed and separated per-component, i.e., as if the 24-bit data were three 8-bit images without palettes.
- the data may be interleaved components, i.e., as if the image were a single component image with three times the number of columns.
- the compressed data consists of a sequence of elements, each element either representing a literal pixel (e.g., transferred verbatim from the uncompressed source image) or a "copy" invocation.
- a copy invocation is a data pair offset, length! that points back into the previously encoded image data to identify a string of matching prior pixels that is to be copied, upon decoding, to the current location of the data pair.
- the pixel string may be as follows (assuming the digits below represent pixel values):
- lossless compression is an example of lossless compression, but it should be understood that the present invention can be used for lossy compression as well.
- lossy compression for an image being compressed, the matching strings are allowed to be inexact but visually close matches. This "lossiness" does not affect the operation of the decoder, because the decoder has no concern that the encoder has matched strings in a lossy or lossless manner.
- the literal and copy elements are re-mapped into a defined set of tokens, as described above. To achieve further compression, these tokens are histogrammed and Huffman coded in the preferred embodiment. The resulting codewords make up the majority of the output data stream. Extra non-Huffman'd bits may be placed between the Huffman codewords. These extra bits are interposed when the Huffman codeword is insufficient to carry all the information needed. For example, copy elements with very large copy lengths or copy elements with very large offsets will frequently require extra bits to follow the token to describe the high-order bits of the larger value. The existence of these extra bits is implied by the definition of the token that precedes the bits.
- the resulting data stream is preferably encoded using Huffman coding (Step 410).
- Huffman coding the classical Huffman algorithm is used to create an optimal Huffman tree for the set of tokens.
- the Huffman tree is itself encoded in a compressed format at the beginning of the file containing the compressed image.
- the output of this step is a compressed Huffman stream consisting of Huffman codewords of lengths 1-16 bits, optionally interspersed with additional codeword dependent data.
- the Huffman tree is encoded in the following manner.
- the Huffman tree is represented by a vector of 432 integers corresponding positionally to all possible tokens, each holding a value from 0 to 16. These are termed "tokenlengths.”
- the tokenlengths vector fully encodes the Huffman tree shape and indicates which tokens correspond to its leaves.
- the 0 to 16 tokenlengths values represent the token binary codeword length in bits.
- the tokenlengths vector is first reduced in size by removing any positions known to hold zeros, due to the encoding parameters for the image being processed. For instance, if the maximum offset (a user-tunable encoding parameter) is 65 or less, all token positions which represent offsets greater than 65 are removed, shrinking the vector.
- tokenlengths vector is itself tokenized and bit-packed in the preferred embodiment.
- the following tokens are defined for use in compression of tokenlengths (in which the following text is interpreted as if the tokens were being decoded):
- Delta 1 add ⁇ 1 (using modulus-16 arithmetic to keep within range 1 to 16) to the previously decoded non-zero value, and output it once. Following the packed token is a single bit indicating the sign of the delta:
- Delta 2 identical to Delta 1, except with a value of 2.
- Delta 3 identical to Delta 1, except with a value of 3.
- Delta 4 identical to Delta 1, except with a value of 4.
- Delta 5-8 Larger delta coding. Immediately following the delta token, 2 additional bits follow to indicate the magnitude of the delta. Following these 2 bits, a sign bit exists as with the smaller deltas. NOTE: Delta +8 is illegal, and reserved. Since delta arithmetic is performed modulus-16, Delta +8 is equivalent to Delta -8. Delta -8 must be used in both cases.!
- Repeat previous three times (a repeat-twice is coded via a pair of repeat-once's) ("R3") output the previously decoded value three times.
- repeat three token takes on additional meaning it if is preceded by one or more repeat-once tokens. For every consecutive repeat-once that immediately precedes a repeat three token, an additional bit (up to a max of 8) follows the repeat-three token, indicating longer repeats as follows (with R1 n! representing n consecutive repeat-once tokens):
- Hard 0 Output a single 0 (indicating an unused token position). This does not change the "previously decoded value” field. (See the description below regarding the definition of the "previously decoded value.")
- Hard 0's Output 2 or more hard 0's.
- the count of hard 0's to output is determined by extension bits immediately following the token:
- the Huffman tree for the tokens used to model input tokenlengths must itself be described. This is done in bits 0-n of the stream.
- the following static Huffman code is used to encode the values from 0 to 8:
- This value is then used to index a lookup table initialized as follows: (1, 2, 3, 4, 5, 6, 7, 8, 0). This represents the potential "dctokenlengths" (which are called dctokenlengths to distinguish from the main tokenlengths), along with a zero to designate unused codes. As encoding/decoding progresses, dctokenlengths that are no longer possible because their tree level has been fully committed are removed from the lookup table.
- trailing zero dctokenlengths exist they are not stored. Rather, the decoder senses them automatically, because the Huffman tree will be exactly filled at the point the zeros begin. Also, the final dctokenlengths position is never stored; the decoder can always determine what it must be from examining the Huffman tree.
- the encoded image may optionally be segmented into blocks before storing or transmission of the compressed and encoded image (Step 412).
- Step 412 a structure is imposed on the Huffman-encoded copy and literal tokens. This structure segments the token file into blocks (e.g., 16 blocks) of rows, allowing the decoder to display, or "paint", partial sections of the image as it arrives at the decoder. (See below for the preferred file format.)
- a "splash" version of the image may optionally be prepended to the beginning of the data stream before transmitting or storing the compressed and encoded image (Step 414).
- the splash image is a greatly reduced (in size) version of the original image, which is reduced by decimation/filtering
- the splash image is encoded using the same compression scheme as the main image that follows the splash image in the data stream.
- the splash image is received, it is decoded, scaled up, and painted into, for example, the screen display window. This provides the viewer of the image with an approximate rendering of the main image before that image arrives.
- the main image arrives after the splash image in segments (blocks of rows, as described above) and overlays the splash image.
- the splash image preferably is not used in decoding the main image. This allows the splash image to be removed from the data file without affecting the ability to decode the main image. It should be recognized, however, that the splash image may be used in decoding the main image. Moreover, the splash image may be used to reduce the size of the main encoded image by using the information in the splash image, for example, by differential pulse-code modulating the main image data against the splash image before encoding the main image.
- a "presplash” code may also be employed.
- a presplash code represents the most "popular” or predominant color within the splash image.
- the presplash code can be used as a background color for the area where the splash image is to be displayed to frame the splash image.
- Another display option involves placing a "transparency" color in the file being transmitted or stored.
- the calling application can specify a transparency replacement color. This color is placed in the palette atop the file transparency color, effectively "painting-in” the transparent areas with the replacement color.
- the main compressed and encoded image i.e., the token set
- the image may be transmitted from one computer system another, such as from system 10 to system 30 in FIG. 1, or the image may be stored in a memory device, such as the storage device 19 in FIG. 1. In either case, an advantage is obtained by compressing the image. If transmitted, the compressed image reaches its destination more quickly than if uncompressed and uses less bandwidth. If stored, the compressed image occupies less space in the memory device than the uncompressed image.
- the transmitted compressed image When the transmitted compressed image is received, or the stored compressed image is retrieved, it is decoded (Step 418) by a decoder, preferably using a Huffman decoding algorithm that reverses the encoding process, in known fashion.
- the image is then decompressed (or expanded) to obtain a representation of the original image (Step 420), again in known fashion.
- a decoder preferably using a Huffman decoding algorithm that reverses the encoding process, in known fashion.
- the image is then decompressed (or expanded) to obtain a representation of the original image (Step 420), again in known fashion.
- Decompressing the image at this point restores the image as it was input into the compression stage at Step 408 of FIG. 4.
- decompression tokens defining the compressed image are converted into pixel component values.
- the tokens are 24-bit, the tokens are interleaved with other color components to form output colors. If, on the other hand, the tokens are 8-bit, the image palette is indexed to form 24-bit output colors.
- decoding (Step 418) and decompression (Step 420) are performed simultaneously, thereby simplifying the design, reducing memory requirements, and increasing time-efficiency. Decoding and decompression are logically distinct, however, and can therefore be implemented as independent steps performed at different times.
- the decoded and decompressed image may be filtered to enhance the image (Step 422).
- an enhancement filter is applied to the pixel component values resulting from the decompression step and is used before the decompressed rows and columns are scaled up to the output (or viewing) dimensions.
- the filter may be applied to the decompressed pixel component values.
- the filter can be enabled by value, e.g., to enhance only the Y-component or only the X-component.
- the preferred FIR filter is 7-tap, with coefficients of: 0.0625, -0.3125, 1.5, -0.3125, 0.0625. This is an approximated implementation of the filter disclosed in U.S.
- the decoded and expanded image is then reinterpolated, in known fashion (Step 424).
- the reinterpolation step preferably is a linear interpolation in both dimensions, as required.
- Each color component in a 24-bit encoding can be scaled individually. Thus, some components may be reinterpolated and others not, on an image-by-image basis.
- the preferred data format is known as the "GT art" format. This comprises a data stream that includes a header followed by a variable number of segments in the following format: ##STR2##
- the Header Format is 8 bytes long in the preferred embodiment.
- the first two bytes (0 and 1) form a signature to identify the data as a GT art data stream.
- Bytes 2 and 3 identify the version of the stream.
- Typical decoders can decode a major version and a range of minor versions.
- Bytes 4, 5, 6 are reserved.
- Byte 7 identifies the encoder that created the stream. In summary, these bytes are:
- Each Segment consists of a Prefix and Data section.
- the Prefix consists of Tag and Size fields, which are each encoded using one of three formats, depending on their values.
- the Data section is a string of arbitrary bytes, whose byte count is encoded in the Prefix as the Size field.
- the Segment Prefix is a sequence of one, two, or three bytes, which are used to encode the "segment type,” called Tag, and a count called Size of the Data bytes that follow.
- the 1-byte format allows a Tag value of 0-63 and 0 bytes of Data.
- the 2-byte format allows Tag values of 0-31 and 0-511 bytes of Data.
- the 3-byte format allows Tag values of 0-255 and 0-32767 bytes of Data. This encoder selects the shortest encoding for the values Tag and Size.
- the Data section contains data bytes of a format specific to the Tag identifier.
- the contents and preferred order of segments types are given below (with the value in hexadecimal of all tags and fields being beside the name):
- Segment Type (1) defines the dimension of the output image and the colorspace and is formed by the following six bytes:
- Each flag contains a single field identical in size, position, and meaning to JG -- GTFLAG -- CLR -- xxx field in the GT -- INSTANCE -- INFO Segment. (See below.) This field determines the colorspace of the image. (See Segment Type JG -- SEG -- GTI -- INFO described below.)
- Segment Type (2) defines the transparent color of an image and is formed by the following four bytes:
- Segment Type (3) defines the preferred 3-color palette to use when displaying the image in a palettized mode.
- Palettized (8-bit) image instances may reference this palette as the Stream Palette.
- the three components color 0-C0, color 1-C1, color 2-C2) are in order: Green (CO), then Blue (C1), then Red (C2).
- the packed format of the palette is:
- Bits are ordered from high to low order in ascending address bytes. Fields are stored from high to low order bit.
- Color 0 is stored raw (always raw if 0/1 bit quantizing), contiguous n-bit (depending on Color 0 quantizing factor) fields are provided holding all Color 0 values.
- Color 0 is stored compressed (which only occurs with at least 8 values, although more than 8 values may still be stored raw)
- the first 16 bits are the delta mask, selecting which delta tokens are in use, as follows: The first bit is a 1 if a delta of 0 is coded; the 2nd bit is a 1 for a delta of 1; . . . ; the last (16th) bit is 1 if a delta of 15 is coded.
- the meaning of the delta tokens is as follows.
- the delta tokens indicate the amount of change from the previous sample to the next. Delta values from 0 to 14 generate the next sample directly (via one token).
- a delta of 15 is a special case, indicating the delta is 15+ the following data.
- Many delta-15 tokens can appear in a row to code a large delta. There will always be a delta token of less than 15 to terminate one or more occurrences of delta-15.
- the delta values are unsigned, meaning they can only move the current value in one direction.
- the preferred implementation starts out by sorting the palette via the first component in descending order.
- the delta tokens for the first color represent a negative change (i.e., are subtracted from the current first-color-value during decoding).
- delta codeword length nibbles each 4 bits.
- One nibble exists for every 1 bit in the delta mask. (That is, the codeword length nibbles and bits in the delta mask correspond positionally; thus the first nibble would represent the codeword length for delta-0, if it was used.)
- the Huffman length for the codeword is 1+the value stored in the nibble.
- the next n bits hold the first color value in its raw form. Following the initial raw token are the variable length codewords for the delta tokens that define the remaining first color values.
- color 1 is stored raw (always raw if 0/1 bit quantizing), the following results: continuous n-bit (depending on Color 1 quantizing factor) fields are provided holding all Color 1 values. Otherwise Color 1 is stored compressed, which always occurs with at least 8 values. If compressed, the compressed representation is identical to Color 0, except for the definition of the delta-15 code, which is redefined to flag an escape-to-raw definition, indicating that the next n-bits (depending on the color's quantizing value) hold the color value as a raw value.
- Color 2 is stored raw (always raw if 0/1 bit quantizing), the following results: contiguous n-bit (depending on Color 2 quantizing factor) fields are provided holding all Color 2 values. Otherwise, Color 2 is stored compressed, which is always the case with at least 8 values, and the compressed representation is identical to Color 1.
- Segment Type (4) is used to flood an image window with a color prior to painting or paneling in splash or image data.
- the Segment has the following four bytes:
- An optional Splash instance may be placed here. If so, it would be composed of the segments JG -- SEG -- GTI -- INFO through JG -- SEG -- GTI -- DATA, exactly as would the main image instance (which follows in the data stream).
- Segment Type (5) is required for each color component. If an image is 24-bit (3 component), three consecutive JG -- SEG -- GTI -- INFO segments are required before any other segment. The format counts consecutive JG -- SEG -- GTI -- INFO segments to determine the number of components in an image. The components are numbered 0, 1, 2 (as they appear in order).
- Flag (1) is set if the maximum number of image rows packed per segment is 32. If Flag (1) is not set, the maximum number of rows stored per segment is 16.
- Flag (2) is set to indicate the image instance is a splash.
- Flag (3) is a 4-bit field that determines the pixel format of the instance. It may take any of the following six values:
- An 8-bit palettized instance refers to the variable (encoder-defined) stream palette.
- VALUE (2) #define JG -- GTFLAG -- PXF -- RGB332 (1 ⁇ 8) // 332 RGB indexes
- indexes encoded in the instance refer to a preset 256-entry palette, where 3 bits are allocated for red, 3 bits for green, and 2 bits for blue.
- VALUE (3) #define JG -- GTFLAG -- PXF -- MONO (2 ⁇ 8) // monochrome 8-bit
- indexes encoded in the instance refer to a preset linear monochrome (gray-scale) palette, with 0 indicating black and 0 ⁇ ff indicating white.
- indexes encoded in the instance refer to a variable (encoder-defined) palette, which will immediately follow the Info Segment.
- VALUE (5) #define JG -- GTFLAG -- PXF -- SEP24 (4 ⁇ 8) // 24-bit separated A 24-bit instance. Three adjacent info segments must be present. Compressed image data consists of color component values, instead of indexes to a palette.
- VALUE (6) #define JG -- GTFLAG -- PXF -- INT24 (5 ⁇ 8) // 24-bit interleaved A 24-bit instance. In this case, only a single Info Segment and set of encoded data is present. The three color components are left interleaved together (in B, G, R order) and encoded as if they were a single image with three times the number of columns.
- Flag (4) is a 4-bit field that determines the colorspace of the instance (either the compressed data itself, if 24-bit, or the palette of an 8-bit palettized instance). It may take either of the following two values:
- the colorspace is RGB (the use of BGR in the name having no meaning).
- VALUE (2) #define JG -- GTFLAG -- CLR -- YUV (1 ⁇ 4) // YUV The colorspace is YUV.
- Flags (5) and (6) control whether or not the enhancement filter (described above) is engaged.
- the enhancement is individually controllable for rows and columns.
- Flags (7) and (8) cause the scaled image to be increased in size by replication of the entire image an appropriate number of times. If the image is decreasing in size, its bottom rows and right columns are clipped instead of scaling the entire range.
- Segment Type (5) i.e., the JG -- SEG -- GTI -- INFO Segment
- Fields (1) and (2) hold the number of rows and columns of compressed image data. If these values differ from those recorded in the JG -- SEG -- WINDOW -- INFO segment, the image will be scaled to the JG -- SEG -- WINDOW -- INFO segment dimensions.
- Field (3) holds the color weights that are applied during the encoding process to the color component differences, as follows:
- Field (3) holds the DPCM algorithm that was used during encoding, and that will need to be inverted during decode:
- the DPCM algorithm is dynamically chosen on a per-row basis, and the algorithm type is recorded at the beginning of each compressed row. (See the above discussion of DPCM algorithms.)
- Fields (4) and (5) represent the minimum and maximum length copy strings, as programmed at encoding time. Both fields are 4-bits. The maximum length is stored in the high order four bits. The four bit code indexes the following vector to produce the actual minimum length: 0, 1, 2, 3, 4, 5, 6, 7, 9, 13, 21, 37, 69, 133, 261, 517, 1029. The four bit code indexes the following vector to produce the actual maximum length: 0, 1, 2, 3, 4, 5, 6, 8, 12, 20, 37460, 37460, 37460, 37460, 37460, 37460, 37460. After indexing the maximum length table, the minimum copy length is added to the result to create the final maximum copy length.
- Fields (6) and (7) are the maximum offset sizes for length 2 and length greater than 2 copies, set at encoding time. Both fields are 4-bits. The length 2 search size is stored in the high order bits. These fields control the maximum allowed offset a copy string may take (for length 2 copies and all copies greater than length 2).
- the four bit code indexes the following vector to produce the actual length 2 copy max offset size: 1, 2, 3, 4, 5, 9, 17, 33, 65, 129, 257, 513, 1025, 2049, 4097, 8193.
- the four bit code indexes the following vector to produce the actual length greater than 2 copy max offset size: 1, 2, 3, 4, 5, 9, 17, 33, 65, 129, 257, 513, 1025, 2049, 4097, 8193.
- Field (8) is the tolerance applied to the numeric difference between pixels at encode time to determine whether or not they are close enough to be considered equal.
- a "DifTol" of zero allows no pixels to be considered equal, inhibiting any matches from occurring.
- this field is simply compared to the absolute value of the difference between pixel values.
- palettized (8-bit) encodings the pixels to be compared are first de-palettized (indexes are looked-up in the palette). Then, the color vectors are differenced (subtracted from one another), the absolute values are taken, weighted as per CxWeights. Then, the result vector elements are squared and summed. This value is compared against "DifTol" to determine equality.
- Segment Type (6) represents the local or de-palettizing palette. This Segment is optional and is only used with 8 bit palettized image. It is stored in the same format as the stream palette. (See Segment Type JG -- SEG -- GTI -- PALETTE.)
- the Huffman Segments are optional. If a Huffman Segment (Type (7)) is not received for a component, the data must be raw (stored without compression). If decoding a multiple color component (24-bit) image, the JG -- SEG -- GTI -- HUFFMAN Segments must be ordered corresponding to the color components 0, 1, 2.
- the first 1-3 bytes of the Huffman Segment define the "most popular" mask. (See above.) The count of stored bytes is determined by the number of bytes required to output 5 one bits. If less than 3 bytes are required, the trailing 1 or 2 bytes are assumed to be zero. The three bytes logically stored represent a 24-bit mask.
- JG -- SEG -- GTI -- DATA Segments are ordered as sequential blocks of rows, starting from the top of the image, and may contain an arbitrary number (up to the maximum specified within the JG -- SEG -- WINDOW -- INFO Segment (i.e., Segment Type (1))) of image rows. Sufficient Data segments exist to store all image rows. If the image has multiple components, JG -- SEG -- GTI -- DATA Segments (i.e., Segment Type (8)) for each component are interleaved such that a new data segment for each component is available as the decoding process requires it. This relieves the decoder from having to cache component data segments.
- the component segments are interleaved 0, 1, 2, 0, 1, 2, . . . If the last two components were subsampled at half the rate of the first component (typical for YUV instances), the ordering of the components would be 0, 0, 1, 2, 0, 0, 1, 2, . . . This is because there is twice as much component 0 data as component 1 and 2 data.
- the first byte of a GT image data segment holds:
- bits 6-5 reserved, must be 0
- bits 4-0 count of component rows stored in segment-1
- bit stream begins. Data is stored on bit boundaries. Bits are ordered from high to low order in ascending address bytes. Fields are stored from high to low order bit.
- the compressed bits for each data row are stored contiguously (with no byte boundaries between rows).
- the bits represent the GT tokens, as described above, converted to codewords using the Huffman tree for that component.
- a variable (auto) DPCM mode a 1 or 2 bit DPCM-type codeword is stored at the beginning of each row, as follows:
- Segment Type (9) indicates at what point in the stream enough data has been received to produce an acceptable "miniature" form of the image.
- the flag may be placed following the splash image, if the splash image is deemed acceptable for use to create a miniature, or the flag may be placed after the main image.
- Segment Type (10) indicates the end of the formatted stream.
- the preceding Segments, Flags, and Values define the format for transmitting image data compressed and encoded in accordance with the present invention.
- the preceding format may be modified or that alternative formats may be employed.
- some of the Segments are optional and thus need not be used.
- the "required” Segments may be modified or replaced, if a substitute is provided.
- the Huffman Segment can be modified or replaced, if an alternative form of encoding other than Huffman encoding.
- the present invention overcomes disadvantages and drawbacks of prior art compression methods. Compression speed is substantially increased, and the present invention eliminates the need for complex circuitry and time-consuming computations required in prior art hashing methods.
Abstract
Description
______________________________________ 23 18 16 7 17 19 24 21 14 6 3 9 15 22 11 8 4 1 5 10 20 12 13 2 # ______________________________________
______________________________________ 46 47 48 49 50 51 52 53 54 55 56 65 45 29 30 31 32 33 34 35 36 37 57 64 44 28 . . . . . . . . . . . . . . 38 58 63 43 27 . . . . . . . . . . . . . . 39 59 62 42 26 . . . . . . . . . . . . . . 40 60 61 41 25 . . . . . . # ______________________________________
__________________________________________________________________________ 99 98 97 95 95 94 93 92 91 90 89 88 87 86 . . . . . . . . . . . . . . . . . . . . . . 85 84 83 82 . . . . . . . . . . . . . . . . . . . . . . . . 81 80 79 78 . . . . . . . . . . . . . . . . . . . . . . . . 77 76 75 74 . . . . . . . . . . . . . . . . . . . . . . . . 73 72 71 70 . . . . . . . . . . . . . . . . . . . . . . . . 69 68 67 66 . . . . . . . . # __________________________________________________________________________
______________________________________ Range Meaning Extra Bits Offset(s) ______________________________________ 0-255 Literal pixels n/a n/a 256-260 ML copy 0 1-5 261 ML copy 2 6-9 (6+Extra Bits) 262 ML copy 3 10-17 (10+Extra Bits) 263 ML copy 4 18-33 " 264 ML copy 5 34-65 " 265 ML copy 6 66-129 " 266 ML copy 7 130-257 " 267 ML copy 8 258-513 " 268 ML copy 9 514-1025 " 269 ML copy 10 1026-2049 " 270 ML copy 11 2050-4097 " 271 ML copy 12 4098-8193 " 272-287 ML+1 copy <same Extra Bits/Offsets as 256-271> 288-303 ML+2 copy <same> 304-319 ML+3 copy " 320-335 ML+4 copy " 336-351 ML+5 copy " 352-367 ML+6 copy " 368-383 ML+7 ..+8 1+" (length +1 extra length bit) 384-399 ML+9 ..+12 2+<same>(length +2 extra length bits) 400-415 ML+13 ..+20 3+<same>(length +3 extra length bits) 416-431 ML+21 ..+37460 n+<same>(n==2+ 6/9/12/15 bits): 00+<6 bits>==ML +21 .. ML +84 01+<9 bits>==ML +85 .. ML +596 10+<12 bits>==ML +597 .. ML +4694 11+<15 bits>==ML +4695 .. ML +37460 ______________________________________
X=X-B; (1)
X=X-C; or (2)
X=X-((B+C+1)/2), (3)
______________________________________ row (n - 2) . . . . row (n - 1) . B . . row (n) C X . . ______________________________________
43210210321098798711111
.4.3.2.1.0 3,3! 7,4! .9.8.7 3,3! .1 1,4!
______________________________________ Bits Output Count (n x! == x n's) ______________________________________ +0: 2 (2) +10n: 3+n 1! (3-4) +110nn: 5+n 2! (5-8) +1110nnn: 9+n 3! (9-16) +11110nnnn: 17+n 4! (17-32) +111110nnnnn: 33+n 5! ((33-64) +1111110nnnnnn: 65+n 6! (65-128) +11111110nnnnnnn: 129+n 7! (129-256) +11111111nnnnnnnn: 257+n 8! (257-512) ______________________________________
______________________________________ Bits: ______________________________________ 0..N: Packed delta code tokenlengths (see below) n+1..: Bit-stream of encoded tokenlengths ______________________________________
______________________________________ 0:00 3:1010 6:1101 1:01 4:1011 7:1110 2:100 5:1100 8:1111 ______________________________________
__________________________________________________________________________ Format byte Bit: 7 6 5 4 3 2 1 0 __________________________________________________________________________ 1 byte 0 1 1 -----------------Tag----------------------! 2 byte 0 1 0 -----------------Size Low---------------! 1 ----Size Hi-----! -------------Tag-----------------! 3 byte 0 0 -------------------Size Low----------------------! 1 -------------------------Size Hi----------------------------! 2 ----------------------------Tag-----------------------------! __________________________________________________________________________
Segment Type: JG.sub.-- SEG.sub.-- WINDOW.sub.-- INFO (0×20)-Required(1)
______________________________________ byte ______________________________________ 0 Flags low btye 1 Flags high byte 2 Rows low byte 3 Rows high byte 4 Cols low byte 5 Cols high byte ______________________________________
Segment Type: JG.sub.-- SEG.sub.-- TRANSPARENCY (0×1b)-Optional(2)
______________________________________ byte ______________________________________ 0 0x01 1 blue value of transparent color (0-0xff) 2 green value of transparent color (0-xff) 3 red value of transparent color (0-0xff) ______________________________________
Segment Type: JG.sub.-- SEG.sub.-- GTI.sub.-- PALETTE (0×17)-Optional(3)
______________________________________ Byte 0 - Count of entries in palette minus 1 (0 to 255). 1 - Flag byte: Bit(s) 7-4: Reserved, always 0 3: 1=Colors may be quantized to less than 8 bits, and 2nd and 3rd colors may be compressed. (If 0, all raw elements are stored in 8-bit fields, and 2nd and 3rd are always stored all raw). 2: 1=Color 0 stored raw (always set if less than 8 entries present) 1: 1=Color 1 stored raw (always set if less than 8 entries present) 0: 1=Color 2 stored raw (always set if less than 8 entries present) ______________________________________
Segment Type: JG.sub.-- SEG.sub.-- PRE.sub.-- SPLASH (0×1c)-Optional(4)
______________________________________ byte ______________________________________ 0 0x01 1 blue value of PreSplash color 2 green value of PreSplash color 3 red value of PreSplash color ______________________________________
Segment Type: JG.sub.-- SEG.sub.-- GTI.sub.-- INFO (0×16)-Required(5)
__________________________________________________________________________ TYPEDEF STRUCT { UINT8 Flags 2!; // various flags UINT8 ActualRows 2!; // actual rows of image data UINT8 ActualCols 2!; // actual cols of image data UINT8 CxWeights 2!; // color 0-2 4-bit weights; or DPCM type UINT8 MaxMinLen 1!; // max and minimum string length UINT8 MaxOffsets 2!; // len 2 and other max copy offsets UINT8 DifTol 2!; // different tolerance } JG.sub.-- PACKED.sub.-- GT.sub.-- INSTANCE.sub.-- INFO; __________________________________________________________________________
RedWeight*1024+GreenWeight*32+BlueWeight*1
______________________________________ #define JG.sub.-- DPCM.sub.-- NONE 0 // none (DPCM not used) #define JG.sub.-- DPCM.sub.-- AUTO 1 // auto (row-by-row selection) #define JG.sub.-- DPCM.sub.-- BB2 2 // X - (B + B)/2 (X - B) #define JG.sub.-- DPCM.sub.-- CC2 3 // X - (C + C)/2 (X - C) #define JG.sub.-- DPCM.sub.-- BC2 4 // X - (B + C)/2 ______________________________________
______________________________________ . . B . C X (where X is the target pixel) ______________________________________
Segment Type: JG.sub.-- SEG.sub.-- GTI.sub.-- PALETTE (0×17)-Optional(6)
Segment Type: JG.sub.-- SEG.sub.-- GTI.sub.-- HUFFMAN (0×18)-Optional(7)
0×0 0×0 0×1F
Segment Type: JG.sub.-- SEG.sub.-- GTI.sub.-- DATA (0×19)-Required(8)
Segment Type (9): JG.sub.-- SEG.sub.-- MINIATURE (0×7), segment length 0 (9)
Segment Type (10): JG.sub.-- SEG.sub.-- EOF (0×b), segment length 0-Required (10 )
Claims (121)
______________________________________ 23 18 16 7 17 19 24 21 14 6 3 9 15 22 11 8 4 1 5 10 20 12 13 2 # ______________________________________
______________________________________ 23 18 16 7 17 19 24 21 14 6 3 9 15 22 11 8 4 1 5 10 20 12 13 2 # ______________________________________
______________________________________ 46 47 48 49 50 51 52 53 54 55 56 65 45 29 30 31 32 33 34 35 36 37 57 64 44 28 . . . . . . . . . . . . . . 38 58 63 43 27 . . . . . . . . . . . . . . 39 59 62 42 26 . . . . . . . . . . . . . . 40 60 61 41 25 . . . . . . # ______________________________________
______________________________________ 23 18 16 7 17 19 24 21 14 6 3 9 15 22 11 8 4 1 5 10 20 12 13 2 # ______________________________________
______________________________________ 46 47 48 49 50 51 52 53 54 55 56 65 45 29 30 31 32 33 34 35 36 37 57 64 44 28 . . . . . . . . . . . . . . 38 58 63 43 27 . . . . . . . . . . . . . . 39 59 62 42 26 . . . . . . . . . . . . . . 40 60 61 41 25 . . . . . . # ______________________________________
______________________________________ 23 18 16 7 17 19 24 21 14 6 3 9 15 22 11 8 4 1 5 10 20 12 13 2 # ______________________________________
______________________________________ 23 18 16 7 17 19 24 21 14 6 3 9 15 22 11 8 4 1 5 10 20 12 13 2 # ______________________________________
Priority Applications (8)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US08/545,513 US5710719A (en) | 1995-10-19 | 1995-10-19 | Apparatus and method for 2-dimensional data compression |
PCT/US1996/016909 WO1997015014A1 (en) | 1995-10-19 | 1996-10-21 | Apparatus and method for two-dimensional data compression |
BR9611056-2A BR9611056A (en) | 1995-10-19 | 1996-10-21 | Device and method for compression of two-dimensional data |
EP96936828A EP0870251B1 (en) | 1995-10-19 | 1996-10-21 | Apparatus and method for two-dimensional data compression |
AU74654/96A AU713756B2 (en) | 1995-10-19 | 1996-10-21 | Apparatus and method for two-dimensional data compression |
CA002235249A CA2235249C (en) | 1995-10-19 | 1996-10-21 | Apparatus and method for 2-dimensional data compression |
JP51609297A JP3233410B2 (en) | 1995-10-19 | 1996-10-21 | Two-dimensional data compression apparatus and method |
DE69631792T DE69631792T2 (en) | 1995-10-19 | 1996-10-21 | APPARATUS AND METHOD FOR THE TWO-DIMENSIONAL DATA COMPRESSION |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US08/545,513 US5710719A (en) | 1995-10-19 | 1995-10-19 | Apparatus and method for 2-dimensional data compression |
Publications (1)
Publication Number | Publication Date |
---|---|
US5710719A true US5710719A (en) | 1998-01-20 |
Family
ID=24176548
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US08/545,513 Expired - Lifetime US5710719A (en) | 1995-10-19 | 1995-10-19 | Apparatus and method for 2-dimensional data compression |
Country Status (8)
Country | Link |
---|---|
US (1) | US5710719A (en) |
EP (1) | EP0870251B1 (en) |
JP (1) | JP3233410B2 (en) |
AU (1) | AU713756B2 (en) |
BR (1) | BR9611056A (en) |
CA (1) | CA2235249C (en) |
DE (1) | DE69631792T2 (en) |
WO (1) | WO1997015014A1 (en) |
Cited By (55)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5987459A (en) * | 1996-03-15 | 1999-11-16 | Regents Of The University Of Minnesota | Image and document management system for content-based retrieval |
US6031914A (en) * | 1996-08-30 | 2000-02-29 | Regents Of The University Of Minnesota | Method and apparatus for embedding data, including watermarks, in human perceptible images |
US6061793A (en) * | 1996-08-30 | 2000-05-09 | Regents Of The University Of Minnesota | Method and apparatus for embedding data, including watermarks, in human perceptible sounds |
US6061398A (en) * | 1996-03-11 | 2000-05-09 | Fujitsu Limited | Method of and apparatus for compressing and restoring data |
US6226387B1 (en) | 1996-08-30 | 2001-05-01 | Regents Of The University Of Minnesota | Method and apparatus for scene-based video watermarking |
US6268809B1 (en) * | 1997-12-05 | 2001-07-31 | Kabushiki Kaisha Toshiba | Data compression method for efficiently compressing data based on data periodicity |
US6272634B1 (en) | 1996-08-30 | 2001-08-07 | Regents Of The University Of Minnesota | Digital watermarking to resolve multiple claims of ownership |
US6282299B1 (en) | 1996-08-30 | 2001-08-28 | Regents Of The University Of Minnesota | Method and apparatus for video watermarking using perceptual masks |
US20010039552A1 (en) * | 2000-02-04 | 2001-11-08 | Killi Tom E. | Method of reducing the size of a file and a data processing system readable medium for performing the method |
US20010046318A1 (en) * | 1999-12-30 | 2001-11-29 | Suk-Joong Lee | Compressing image data |
US20010055124A1 (en) * | 2000-05-16 | 2001-12-27 | International Business Machines Corporation | System and method for merging line work objects using tokenization and selective compression |
US6393154B1 (en) | 1999-11-18 | 2002-05-21 | Quikcat.Com, Inc. | Method and apparatus for digital image compression using a dynamical system |
EP1258998A2 (en) * | 2000-03-16 | 2002-11-20 | Lucent Technologies Inc. | Method and apparatus for data compression of network packets employing per-packet hash tables |
US6501395B1 (en) * | 2002-04-10 | 2002-12-31 | Hewlett-Packard Company | System, method and computer readable medium for compressing a data sequence |
EP1320196A2 (en) * | 2001-09-06 | 2003-06-18 | Xerox Corporation | Data compression method |
US6622248B1 (en) * | 1998-06-25 | 2003-09-16 | Sharp Kabushiki Kaisha | File data retrieving device and recording medium containing computer program for controlling the same |
US6741368B1 (en) * | 1999-05-25 | 2004-05-25 | Adobe Systems, Incorporated | Method and apparatus for reducing storage requirements for display data |
US20040202326A1 (en) * | 2003-04-10 | 2004-10-14 | Guanrong Chen | System and methods for real-time encryption of digital images based on 2D and 3D multi-parametric chaotic maps |
US20050100224A1 (en) * | 2002-09-25 | 2005-05-12 | Cannon Kabushiki Kaisha | Transcoding of digital data |
US20060001557A1 (en) * | 2003-11-24 | 2006-01-05 | Tom Dong Shiang | Computer-implemented method for compressing image files |
US20060285756A1 (en) * | 2005-06-15 | 2006-12-21 | Fuji Photo Film Co., Ltd. | Data compression apparatus and data compression program storage medium |
US7450134B2 (en) * | 2004-11-18 | 2008-11-11 | Time Warner Cable Inc. | Methods and apparatus for encoding and decoding images |
US20090034025A1 (en) * | 2007-08-03 | 2009-02-05 | Canon Kabushiki Kaisha | Image reading apparatus and image reading method |
US20090049529A1 (en) * | 1996-06-05 | 2009-02-19 | Fraud Control System.Com | Method Of Billing A Purchase Made Over A Computer Network |
US20090048975A1 (en) * | 1996-06-05 | 2009-02-19 | Fraud Control System.Com | Method Of Billing A Purchase Made Over A Computer Network |
US20090213935A1 (en) * | 2002-12-10 | 2009-08-27 | Van Der Laan Roger | System and Method For Compressing Video By Allocating Bits To Image Tiles Based On Detected Intraframe Motion Or Scene Complexity |
US20090220002A1 (en) * | 2002-12-10 | 2009-09-03 | Laan Roger Van Der | System and method for compressing video based on detected intraframe motion |
US20090225863A1 (en) * | 2002-12-10 | 2009-09-10 | Perlman Stephen G | Video Compression System and Method for Reducing the Effects of Packet Loss Over a Communciation Channel |
US20090225220A1 (en) * | 2002-12-10 | 2009-09-10 | Van Der Laan Roger | System and Method For Compressing Video By Adjusting Tile Size Based On Detected Intraframe Motion Or Scene Complexity |
AU2005248949B2 (en) * | 2005-12-23 | 2010-04-01 | Canon Kabushiki Kaisha | Efficient Halftone Image Compression |
US20100166066A1 (en) * | 2002-12-10 | 2010-07-01 | Steve Perlman | System and Method for Video Compression Using Feedback Including Data Related to the Successful Receipt of Video Content |
US20100166063A1 (en) * | 2002-12-10 | 2010-07-01 | Perlman Steve G | System and method for compressing video frames or portions thereof based on feedback information from a client device |
US20100166064A1 (en) * | 2002-12-10 | 2010-07-01 | Perlman Steve G | System and Method for Utilizing Forward Error Correction with Video Compression |
US20100167816A1 (en) * | 2002-12-10 | 2010-07-01 | Perlman Stephen G | System and Method for Multi-Stream Video Compression |
US20110007796A1 (en) * | 2009-07-07 | 2011-01-13 | Fujifilm Corporation | Moving picture compression transmission apparatus, moving picture compression transmission program storage medium and moving picture compression transmission method |
US20110016096A1 (en) * | 2009-07-16 | 2011-01-20 | Teerlink Craig N | Optimal sequential (de)compression of digital data |
US20110173166A1 (en) * | 2010-01-08 | 2011-07-14 | Teerlink Craig N | Generating and merging keys for grouping and differentiating volumes of files |
US20110225659A1 (en) * | 2010-03-10 | 2011-09-15 | Isaacson Scott A | Semantic controls on data storage and access |
US20110299791A1 (en) * | 2010-06-02 | 2011-12-08 | Altek Corporation | Lossless image compression method |
US8229844B2 (en) | 1996-06-05 | 2012-07-24 | Fraud Control Systems.Com Corporation | Method of billing a purchase made over a computer network |
US20130159387A1 (en) * | 2011-12-16 | 2013-06-20 | Microsoft Corporation | Referencing change(s) in data utilizing a network resource locator |
US8711923B2 (en) | 2002-12-10 | 2014-04-29 | Ol2, Inc. | System and method for selecting a video encoding format based on feedback data |
US8832103B2 (en) | 2010-04-13 | 2014-09-09 | Novell, Inc. | Relevancy filter for new data based on underlying files |
US8964830B2 (en) | 2002-12-10 | 2015-02-24 | Ol2, Inc. | System and method for multi-stream video compression using multiple encoding formats |
US9061207B2 (en) | 2002-12-10 | 2015-06-23 | Sony Computer Entertainment America Llc | Temporary decoder apparatus and method |
US20150188566A1 (en) * | 2013-12-31 | 2015-07-02 | SK Hynix Inc. | Apparatus and method for processing data |
US9084936B2 (en) | 2002-12-10 | 2015-07-21 | Sony Computer Entertainment America Llc | System and method for protecting certain types of multimedia data transmitted over a communication channel |
US9138644B2 (en) | 2002-12-10 | 2015-09-22 | Sony Computer Entertainment America Llc | System and method for accelerated machine switching |
US9168457B2 (en) | 2010-09-14 | 2015-10-27 | Sony Computer Entertainment America Llc | System and method for retaining system state |
US9192859B2 (en) | 2002-12-10 | 2015-11-24 | Sony Computer Entertainment America Llc | System and method for compressing video based on latency measurements and other feedback |
US9446305B2 (en) | 2002-12-10 | 2016-09-20 | Sony Interactive Entertainment America Llc | System and method for improving the graphics performance of hosted applications |
CN108028663A (en) * | 2015-09-15 | 2018-05-11 | 英特尔公司 | Error checking is carried out to the compressed stream in isomery compression acceleration device |
CN110168611A (en) * | 2017-03-22 | 2019-08-23 | 惠普发展公司，有限责任合伙企业 | The compressed version of image data based on data relationship |
CN112383780A (en) * | 2013-08-16 | 2021-02-19 | 上海天荷电子信息有限公司 | Encoding and decoding method and device for point matching reference set and index back-and-forth scanning string matching |
US11064214B2 (en) * | 2001-07-10 | 2021-07-13 | The Directv Group, Inc. | System and methodology for video compression |
Families Citing this family (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6130630A (en) * | 1998-10-27 | 2000-10-10 | Hewlett-Packard Company | Apparatus and method for compressing Huffman encoded data |
US20120082395A1 (en) * | 2010-09-30 | 2012-04-05 | Microsoft Corporation | Entropy Coder for Image Compression |
CN116506629B (en) * | 2023-06-27 | 2023-08-25 | 上海伯镭智能科技有限公司 | Road condition data compression method for mine unmanned mine car cooperative control |
Citations (20)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US3656178A (en) * | 1969-09-15 | 1972-04-11 | Research Corp | Data compression and decompression system |
US3675211A (en) * | 1970-09-08 | 1972-07-04 | Ibm | Data compaction using modified variable-length coding |
US3694813A (en) * | 1970-10-30 | 1972-09-26 | Ibm | Method of achieving data compaction utilizing variable-length dependent coding techniques |
US3701108A (en) * | 1970-10-30 | 1972-10-24 | Ibm | Code processor for variable-length dependent codes |
US3717851A (en) * | 1971-03-03 | 1973-02-20 | Ibm | Processing of compacted data |
US4021782A (en) * | 1974-01-07 | 1977-05-03 | Hoerning John S | Data compaction system and apparatus |
US4412306A (en) * | 1981-05-14 | 1983-10-25 | Moll Edward W | System for minimizing space requirements for storage and transmission of digital signals |
US4464650A (en) * | 1981-08-10 | 1984-08-07 | Sperry Corporation | Apparatus and method for compressing data signals and restoring the compressed data signals |
US4491934A (en) * | 1982-05-12 | 1985-01-01 | Heinz Karl E | Data compression process |
US4558302A (en) * | 1983-06-20 | 1985-12-10 | Sperry Corporation | High speed data compression and decompression apparatus and method |
US4612532A (en) * | 1984-06-19 | 1986-09-16 | Telebyte Corportion | Data compression apparatus and method |
US4730348A (en) * | 1986-09-19 | 1988-03-08 | Adaptive Computer Technologies | Adaptive data compression system |
US4814746A (en) * | 1983-06-01 | 1989-03-21 | International Business Machines Corporation | Data compression method |
US4853696A (en) * | 1987-04-13 | 1989-08-01 | University Of Central Florida | Code converter for data compression/decompression |
US4876541A (en) * | 1987-10-15 | 1989-10-24 | Data Compression Corporation | Stem for dynamically compressing and decompressing electronic data |
US4906991A (en) * | 1988-04-29 | 1990-03-06 | Xerox Corporation | Textual substitution data compression with finite length search windows |
US5146857A (en) * | 1988-10-18 | 1992-09-15 | Saarberg-Interplan Gesellschaft Fur Rohstoff-, Energie- Und Ingenieurtechnik Mbh | Process for the production of electrical energy and/or heating and process heat |
US5247357A (en) * | 1989-05-31 | 1993-09-21 | Scientific Atlanta, Inc. | Image compression method and apparatus employing distortion adaptive tree search vector quantization with avoidance of transmission of redundant image data |
US5267334A (en) * | 1991-05-24 | 1993-11-30 | Apple Computer, Inc. | Encoding/decoding moving images with forward and backward keyframes for forward and reverse display |
US5466918A (en) * | 1993-10-29 | 1995-11-14 | Eastman Kodak Company | Method and apparatus for image compression, storage, and retrieval on magnetic transaction cards |
Family Cites Families (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
GB2267624B (en) * | 1992-05-05 | 1995-09-20 | Acorn Computers Ltd | Image data compression |
EP0582907A3 (en) * | 1992-08-10 | 1995-05-10 | Stac Electronics Inc | Data compression apparatus and method using matching string searching and Huffman encoding. |
US5416857A (en) * | 1992-10-21 | 1995-05-16 | International Business Machines Corporation | Apparatus and method for compressing data while retaining image integrity |
-
1995
- 1995-10-19 US US08/545,513 patent/US5710719A/en not_active Expired - Lifetime
-
1996
- 1996-10-21 AU AU74654/96A patent/AU713756B2/en not_active Ceased
- 1996-10-21 DE DE69631792T patent/DE69631792T2/en not_active Expired - Lifetime
- 1996-10-21 EP EP96936828A patent/EP0870251B1/en not_active Expired - Lifetime
- 1996-10-21 CA CA002235249A patent/CA2235249C/en not_active Expired - Fee Related
- 1996-10-21 BR BR9611056-2A patent/BR9611056A/en not_active IP Right Cessation
- 1996-10-21 WO PCT/US1996/016909 patent/WO1997015014A1/en active IP Right Grant
- 1996-10-21 JP JP51609297A patent/JP3233410B2/en not_active Expired - Fee Related
Patent Citations (21)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US3656178A (en) * | 1969-09-15 | 1972-04-11 | Research Corp | Data compression and decompression system |
US3675211A (en) * | 1970-09-08 | 1972-07-04 | Ibm | Data compaction using modified variable-length coding |
US3694813A (en) * | 1970-10-30 | 1972-09-26 | Ibm | Method of achieving data compaction utilizing variable-length dependent coding techniques |
US3701108A (en) * | 1970-10-30 | 1972-10-24 | Ibm | Code processor for variable-length dependent codes |
US3717851A (en) * | 1971-03-03 | 1973-02-20 | Ibm | Processing of compacted data |
US4021782A (en) * | 1974-01-07 | 1977-05-03 | Hoerning John S | Data compaction system and apparatus |
US4412306A (en) * | 1981-05-14 | 1983-10-25 | Moll Edward W | System for minimizing space requirements for storage and transmission of digital signals |
US4464650A (en) * | 1981-08-10 | 1984-08-07 | Sperry Corporation | Apparatus and method for compressing data signals and restoring the compressed data signals |
US4491934A (en) * | 1982-05-12 | 1985-01-01 | Heinz Karl E | Data compression process |
US4814746A (en) * | 1983-06-01 | 1989-03-21 | International Business Machines Corporation | Data compression method |
US4558302A (en) * | 1983-06-20 | 1985-12-10 | Sperry Corporation | High speed data compression and decompression apparatus and method |
US4558302B1 (en) * | 1983-06-20 | 1994-01-04 | Unisys Corp | |
US4612532A (en) * | 1984-06-19 | 1986-09-16 | Telebyte Corportion | Data compression apparatus and method |
US4730348A (en) * | 1986-09-19 | 1988-03-08 | Adaptive Computer Technologies | Adaptive data compression system |
US4853696A (en) * | 1987-04-13 | 1989-08-01 | University Of Central Florida | Code converter for data compression/decompression |
US4876541A (en) * | 1987-10-15 | 1989-10-24 | Data Compression Corporation | Stem for dynamically compressing and decompressing electronic data |
US4906991A (en) * | 1988-04-29 | 1990-03-06 | Xerox Corporation | Textual substitution data compression with finite length search windows |
US5146857A (en) * | 1988-10-18 | 1992-09-15 | Saarberg-Interplan Gesellschaft Fur Rohstoff-, Energie- Und Ingenieurtechnik Mbh | Process for the production of electrical energy and/or heating and process heat |
US5247357A (en) * | 1989-05-31 | 1993-09-21 | Scientific Atlanta, Inc. | Image compression method and apparatus employing distortion adaptive tree search vector quantization with avoidance of transmission of redundant image data |
US5267334A (en) * | 1991-05-24 | 1993-11-30 | Apple Computer, Inc. | Encoding/decoding moving images with forward and backward keyframes for forward and reverse display |
US5466918A (en) * | 1993-10-29 | 1995-11-14 | Eastman Kodak Company | Method and apparatus for image compression, storage, and retrieval on magnetic transaction cards |
Non-Patent Citations (4)
Title |
---|
Memon et al.; "Lossless Image Compression with a Codebook of Block Scans"; IEEE Journal On Selected Areas in Communications, vol. 13, No. 1, pp. 24-30, Jan. |
Memon et al.; Lossless Image Compression with a Codebook of Block Scans ; IEEE Journal On Selected Areas in Communications, vol. 13, No. 1, pp. 24 30, Jan. * |
Ziv and Lempel, A Universal Algorithm for Sequential Data Compression , IEEE Transaction Information Theory, 23(3):337, 1977. * |
Ziv and Lempel, A Universal Algorithm for Sequential Data Compression, IEEE Transaction Information Theory, 23(3):337, 1977. |
Cited By (109)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6061398A (en) * | 1996-03-11 | 2000-05-09 | Fujitsu Limited | Method of and apparatus for compressing and restoring data |
US5987459A (en) * | 1996-03-15 | 1999-11-16 | Regents Of The University Of Minnesota | Image and document management system for content-based retrieval |
US20090048975A1 (en) * | 1996-06-05 | 2009-02-19 | Fraud Control System.Com | Method Of Billing A Purchase Made Over A Computer Network |
US20090049529A1 (en) * | 1996-06-05 | 2009-02-19 | Fraud Control System.Com | Method Of Billing A Purchase Made Over A Computer Network |
US8190513B2 (en) | 1996-06-05 | 2012-05-29 | Fraud Control Systems.Com Corporation | Method of billing a purchase made over a computer network |
US8229844B2 (en) | 1996-06-05 | 2012-07-24 | Fraud Control Systems.Com Corporation | Method of billing a purchase made over a computer network |
US8630942B2 (en) | 1996-06-05 | 2014-01-14 | Fraud Control Systems.Com Corporation | Method of billing a purchase made over a computer network |
US6282299B1 (en) | 1996-08-30 | 2001-08-28 | Regents Of The University Of Minnesota | Method and apparatus for video watermarking using perceptual masks |
US6031914A (en) * | 1996-08-30 | 2000-02-29 | Regents Of The University Of Minnesota | Method and apparatus for embedding data, including watermarks, in human perceptible images |
US6272634B1 (en) | 1996-08-30 | 2001-08-07 | Regents Of The University Of Minnesota | Digital watermarking to resolve multiple claims of ownership |
US6226387B1 (en) | 1996-08-30 | 2001-05-01 | Regents Of The University Of Minnesota | Method and apparatus for scene-based video watermarking |
US6061793A (en) * | 1996-08-30 | 2000-05-09 | Regents Of The University Of Minnesota | Method and apparatus for embedding data, including watermarks, in human perceptible sounds |
US6268809B1 (en) * | 1997-12-05 | 2001-07-31 | Kabushiki Kaisha Toshiba | Data compression method for efficiently compressing data based on data periodicity |
US6622248B1 (en) * | 1998-06-25 | 2003-09-16 | Sharp Kabushiki Kaisha | File data retrieving device and recording medium containing computer program for controlling the same |
US6741368B1 (en) * | 1999-05-25 | 2004-05-25 | Adobe Systems, Incorporated | Method and apparatus for reducing storage requirements for display data |
US7212313B1 (en) | 1999-05-25 | 2007-05-01 | Adobe Systems Incorporated | Reducing storage requirements for display data |
US7630099B1 (en) * | 1999-05-25 | 2009-12-08 | Adobe Systems Incorporated | Reducing storage requirements for display data |
US6393154B1 (en) | 1999-11-18 | 2002-05-21 | Quikcat.Com, Inc. | Method and apparatus for digital image compression using a dynamical system |
US20010046318A1 (en) * | 1999-12-30 | 2001-11-29 | Suk-Joong Lee | Compressing image data |
US20010039552A1 (en) * | 2000-02-04 | 2001-11-08 | Killi Tom E. | Method of reducing the size of a file and a data processing system readable medium for performing the method |
EP1258998A2 (en) * | 2000-03-16 | 2002-11-20 | Lucent Technologies Inc. | Method and apparatus for data compression of network packets employing per-packet hash tables |
EP1258998A3 (en) * | 2000-03-16 | 2005-03-09 | Lucent Technologies Inc. | Method and apparatus for data compression of network packets employing per-packet hash tables |
US20010055124A1 (en) * | 2000-05-16 | 2001-12-27 | International Business Machines Corporation | System and method for merging line work objects using tokenization and selective compression |
US7167259B2 (en) * | 2000-05-16 | 2007-01-23 | International Business Machines Corporation | System and method for merging line work objects using tokenization and selective compression |
US11064214B2 (en) * | 2001-07-10 | 2021-07-13 | The Directv Group, Inc. | System and methodology for video compression |
EP1320196A3 (en) * | 2001-09-06 | 2004-04-07 | Xerox Corporation | Data compression method |
EP1320196A2 (en) * | 2001-09-06 | 2003-06-18 | Xerox Corporation | Data compression method |
US6501395B1 (en) * | 2002-04-10 | 2002-12-31 | Hewlett-Packard Company | System, method and computer readable medium for compressing a data sequence |
US20050100224A1 (en) * | 2002-09-25 | 2005-05-12 | Cannon Kabushiki Kaisha | Transcoding of digital data |
US9084936B2 (en) | 2002-12-10 | 2015-07-21 | Sony Computer Entertainment America Llc | System and method for protecting certain types of multimedia data transmitted over a communication channel |
US9446305B2 (en) | 2002-12-10 | 2016-09-20 | Sony Interactive Entertainment America Llc | System and method for improving the graphics performance of hosted applications |
US20090213927A1 (en) * | 2002-12-10 | 2009-08-27 | Perlman Stephen G | System and Method for Compressing Video Based on Detected Data Rate of a Communication Channel |
US20090220001A1 (en) * | 2002-12-10 | 2009-09-03 | Van Der Laan Roger | Tile-Based System and method For Compressing Video |
US20090220002A1 (en) * | 2002-12-10 | 2009-09-03 | Laan Roger Van Der | System and method for compressing video based on detected intraframe motion |
US20090225863A1 (en) * | 2002-12-10 | 2009-09-10 | Perlman Stephen G | Video Compression System and Method for Reducing the Effects of Packet Loss Over a Communciation Channel |
US20090225828A1 (en) * | 2002-12-10 | 2009-09-10 | Perlman Stephen G | Video Compression System and Method for Compensating for Bandwidth Limitations of a Communication Channel |
US20090225220A1 (en) * | 2002-12-10 | 2009-09-10 | Van Der Laan Roger | System and Method For Compressing Video By Adjusting Tile Size Based On Detected Intraframe Motion Or Scene Complexity |
US8953675B2 (en) * | 2002-12-10 | 2015-02-10 | Ol2, Inc. | Tile-based system and method for compressing video |
US8964830B2 (en) | 2002-12-10 | 2015-02-24 | Ol2, Inc. | System and method for multi-stream video compression using multiple encoding formats |
US20100166066A1 (en) * | 2002-12-10 | 2010-07-01 | Steve Perlman | System and Method for Video Compression Using Feedback Including Data Related to the Successful Receipt of Video Content |
US20100166063A1 (en) * | 2002-12-10 | 2010-07-01 | Perlman Steve G | System and method for compressing video frames or portions thereof based on feedback information from a client device |
US20100166064A1 (en) * | 2002-12-10 | 2010-07-01 | Perlman Steve G | System and Method for Utilizing Forward Error Correction with Video Compression |
US20100167816A1 (en) * | 2002-12-10 | 2010-07-01 | Perlman Stephen G | System and Method for Multi-Stream Video Compression |
US8769594B2 (en) | 2002-12-10 | 2014-07-01 | Ol2, Inc. | Video compression system and method for reducing the effects of packet loss over a communication channel |
US8711923B2 (en) | 2002-12-10 | 2014-04-29 | Ol2, Inc. | System and method for selecting a video encoding format based on feedback data |
US9061207B2 (en) | 2002-12-10 | 2015-06-23 | Sony Computer Entertainment America Llc | Temporary decoder apparatus and method |
US8606942B2 (en) | 2002-12-10 | 2013-12-10 | Ol2, Inc. | System and method for intelligently allocating client requests to server centers |
US10201760B2 (en) | 2002-12-10 | 2019-02-12 | Sony Interactive Entertainment America Llc | System and method for compressing video based on detected intraframe motion |
US10130891B2 (en) | 2002-12-10 | 2018-11-20 | Sony Interactive Entertainment America Llc | Video compression system and method for compensating for bandwidth limitations of a communication channel |
US20090213935A1 (en) * | 2002-12-10 | 2009-08-27 | Van Der Laan Roger | System and Method For Compressing Video By Allocating Bits To Image Tiles Based On Detected Intraframe Motion Or Scene Complexity |
US8881215B2 (en) | 2002-12-10 | 2014-11-04 | Ol2, Inc. | System and method for compressing video based on detected data rate of a communication channel |
US9420283B2 (en) | 2002-12-10 | 2016-08-16 | Sony Interactive Entertainment America Llc | System and method for selecting a video encoding format based on feedback data |
US9314691B2 (en) | 2002-12-10 | 2016-04-19 | Sony Computer Entertainment America Llc | System and method for compressing video frames or portions thereof based on feedback information from a client device |
US9272209B2 (en) | 2002-12-10 | 2016-03-01 | Sony Computer Entertainment America Llc | Streaming interactive video client apparatus |
US9192859B2 (en) | 2002-12-10 | 2015-11-24 | Sony Computer Entertainment America Llc | System and method for compressing video based on latency measurements and other feedback |
US9155962B2 (en) | 2002-12-10 | 2015-10-13 | Sony Computer Entertainment America Llc | System and method for compressing video by allocating bits to image tiles based on detected intraframe motion or scene complexity |
US9077991B2 (en) | 2002-12-10 | 2015-07-07 | Sony Computer Entertainment America Llc | System and method for utilizing forward error correction with video compression |
US8526490B2 (en) | 2002-12-10 | 2013-09-03 | Ol2, Inc. | System and method for video compression using feedback including data related to the successful receipt of video content |
US9138644B2 (en) | 2002-12-10 | 2015-09-22 | Sony Computer Entertainment America Llc | System and method for accelerated machine switching |
US8366552B2 (en) | 2002-12-10 | 2013-02-05 | Ol2, Inc. | System and method for multi-stream video compression |
US20040202326A1 (en) * | 2003-04-10 | 2004-10-14 | Guanrong Chen | System and methods for real-time encryption of digital images based on 2D and 3D multi-parametric chaotic maps |
US20060001557A1 (en) * | 2003-11-24 | 2006-01-05 | Tom Dong Shiang | Computer-implemented method for compressing image files |
US7450134B2 (en) * | 2004-11-18 | 2008-11-11 | Time Warner Cable Inc. | Methods and apparatus for encoding and decoding images |
US7864190B2 (en) | 2004-11-18 | 2011-01-04 | Time Warner Cable Inc. | Methods and apparatus for encoding and decoding images |
US20090060356A1 (en) * | 2004-11-18 | 2009-03-05 | Maynard Stephen L | Methods and apparatus for encoding and decoding images |
US20060285756A1 (en) * | 2005-06-15 | 2006-12-21 | Fuji Photo Film Co., Ltd. | Data compression apparatus and data compression program storage medium |
US7826670B2 (en) * | 2005-06-15 | 2010-11-02 | Fujifilm Corporation | Data compression apparatus and data compression program storage medium |
AU2005248949B2 (en) * | 2005-12-23 | 2010-04-01 | Canon Kabushiki Kaisha | Efficient Halftone Image Compression |
US20090034025A1 (en) * | 2007-08-03 | 2009-02-05 | Canon Kabushiki Kaisha | Image reading apparatus and image reading method |
US8149469B2 (en) * | 2007-08-03 | 2012-04-03 | Canon Kabushiki Kaisha | Image reading apparatus and image reading method |
US20110007796A1 (en) * | 2009-07-07 | 2011-01-13 | Fujifilm Corporation | Moving picture compression transmission apparatus, moving picture compression transmission program storage medium and moving picture compression transmission method |
US20110013777A1 (en) * | 2009-07-16 | 2011-01-20 | Teerlink Craig N | Encryption/decryption of digital data using related, but independent keys |
US20110016136A1 (en) * | 2009-07-16 | 2011-01-20 | Isaacson Scott A | Grouping and Differentiating Files Based on Underlying Grouped and Differentiated Files |
US20110016096A1 (en) * | 2009-07-16 | 2011-01-20 | Teerlink Craig N | Optimal sequential (de)compression of digital data |
US8811611B2 (en) | 2009-07-16 | 2014-08-19 | Novell, Inc. | Encryption/decryption of digital data using related, but independent keys |
US10528567B2 (en) | 2009-07-16 | 2020-01-07 | Micro Focus Software Inc. | Generating and merging keys for grouping and differentiating volumes of files |
US8983959B2 (en) | 2009-07-16 | 2015-03-17 | Novell, Inc. | Optimized partitions for grouping and differentiating files of data |
US9053120B2 (en) | 2009-07-16 | 2015-06-09 | Novell, Inc. | Grouping and differentiating files based on content |
US8676858B2 (en) * | 2009-07-16 | 2014-03-18 | Novell, Inc. | Grouping and differentiating volumes of files |
US20110016135A1 (en) * | 2009-07-16 | 2011-01-20 | Teerlink Craig N | Digital spectrum of file based on contents |
US8566323B2 (en) | 2009-07-16 | 2013-10-22 | Novell, Inc. | Grouping and differentiating files based on underlying grouped and differentiated files |
US8874578B2 (en) | 2009-07-16 | 2014-10-28 | Novell, Inc. | Stopping functions for grouping and differentiating files based on content |
US20110016098A1 (en) * | 2009-07-16 | 2011-01-20 | Teerlink Craig N | Grouping and differentiating volumes of files |
US20110016138A1 (en) * | 2009-07-16 | 2011-01-20 | Teerlink Craig N | Grouping and Differentiating Files Based on Content |
US9390098B2 (en) | 2009-07-16 | 2016-07-12 | Novell, Inc. | Fast approximation to optimal compression of digital data |
US9348835B2 (en) | 2009-07-16 | 2016-05-24 | Novell, Inc. | Stopping functions for grouping and differentiating files based on content |
US20110016124A1 (en) * | 2009-07-16 | 2011-01-20 | Isaacson Scott A | Optimized Partitions For Grouping And Differentiating Files Of Data |
US9298722B2 (en) | 2009-07-16 | 2016-03-29 | Novell, Inc. | Optimal sequential (de)compression of digital data |
US20110173166A1 (en) * | 2010-01-08 | 2011-07-14 | Teerlink Craig N | Generating and merging keys for grouping and differentiating volumes of files |
US9438413B2 (en) | 2010-01-08 | 2016-09-06 | Novell, Inc. | Generating and merging keys for grouping and differentiating volumes of files |
US20110225659A1 (en) * | 2010-03-10 | 2011-09-15 | Isaacson Scott A | Semantic controls on data storage and access |
US8782734B2 (en) | 2010-03-10 | 2014-07-15 | Novell, Inc. | Semantic controls on data storage and access |
US8832103B2 (en) | 2010-04-13 | 2014-09-09 | Novell, Inc. | Relevancy filter for new data based on underlying files |
US8559741B2 (en) * | 2010-06-02 | 2013-10-15 | Altek Corporation | Lossless image compression method |
US20110299791A1 (en) * | 2010-06-02 | 2011-12-08 | Altek Corporation | Lossless image compression method |
US9168457B2 (en) | 2010-09-14 | 2015-10-27 | Sony Computer Entertainment America Llc | System and method for retaining system state |
US10574792B2 (en) * | 2011-12-16 | 2020-02-25 | Microsoft Technology Licensing, Llc | Referencing change(s) in data utilizing a network resource locator |
US9537977B2 (en) * | 2011-12-16 | 2017-01-03 | Microsoft Technology Licensing, Llc | Referencing change(s) in data utilizing a network resource locator |
US20160072926A1 (en) * | 2011-12-16 | 2016-03-10 | Microsoft Technology Licensing, Llc | Referencing change(s) in data utilizing a network resource locator |
US20130159387A1 (en) * | 2011-12-16 | 2013-06-20 | Microsoft Corporation | Referencing change(s) in data utilizing a network resource locator |
US10320949B2 (en) * | 2011-12-16 | 2019-06-11 | Microsoft Technology Licensing, Llc | Referencing change(s) in data utilizing a network resource locator |
US20190245946A1 (en) * | 2011-12-16 | 2019-08-08 | Microsoft Technology Licensing, Llc | Referencing change(s) in data utilizing a network resource locator |
US9208244B2 (en) * | 2011-12-16 | 2015-12-08 | Microsoft Technology Licensing, Llc | Referencing change(s) in data utilizing a network resource locator |
CN112383780A (en) * | 2013-08-16 | 2021-02-19 | 上海天荷电子信息有限公司 | Encoding and decoding method and device for point matching reference set and index back-and-forth scanning string matching |
US9509338B2 (en) * | 2013-12-31 | 2016-11-29 | SK Hynix Inc. | Apparatus and method for processing data |
US20150188566A1 (en) * | 2013-12-31 | 2015-07-02 | SK Hynix Inc. | Apparatus and method for processing data |
CN108028663A (en) * | 2015-09-15 | 2018-05-11 | 英特尔公司 | Error checking is carried out to the compressed stream in isomery compression acceleration device |
CN108028663B (en) * | 2015-09-15 | 2021-11-26 | 英特尔公司 | Error checking compressed streams in heterogeneous compression accelerators |
CN110168611A (en) * | 2017-03-22 | 2019-08-23 | 惠普发展公司，有限责任合伙企业 | The compressed version of image data based on data relationship |
Also Published As
Publication number | Publication date |
---|---|
AU713756B2 (en) | 1999-12-09 |
CA2235249C (en) | 2005-03-29 |
AU7465496A (en) | 1997-05-07 |
JP2000509212A (en) | 2000-07-18 |
DE69631792D1 (en) | 2004-04-08 |
EP0870251A4 (en) | 2000-07-26 |
EP0870251A1 (en) | 1998-10-14 |
JP3233410B2 (en) | 2001-11-26 |
WO1997015014A1 (en) | 1997-04-24 |
BR9611056A (en) | 1999-09-28 |
CA2235249A1 (en) | 1997-04-24 |
DE69631792T2 (en) | 2005-03-10 |
EP0870251B1 (en) | 2004-03-03 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US5710719A (en) | Apparatus and method for 2-dimensional data compression | |
US6054943A (en) | Multilevel digital information compression based on lawrence algorithm | |
US6219457B1 (en) | Method and system for decoding data encoded in a variable length code word | |
US6008847A (en) | Temporal compression and decompression for video | |
US7991052B2 (en) | Variable general purpose compression for video images (ZLN) | |
US5227789A (en) | Modified huffman encode/decode system with simplified decoding for imaging systems | |
EP1285399B1 (en) | Enhanced compression of gray-level images | |
US6639945B2 (en) | Method and apparatus for implementing motion detection in video compression | |
US6124811A (en) | Real time algorithms and architectures for coding images compressed by DWT-based techniques | |
AU684013B2 (en) | Compact source coding tables for encoder/decoder system | |
US6008745A (en) | Variable length decoding using lookup tables | |
US7016417B1 (en) | General purpose compression for video images (RHN) | |
JPH07212242A (en) | Variable-length decoder | |
JPH07123407A (en) | Hdtv decoder | |
US6584226B1 (en) | Method and apparatus for implementing motion estimation in video compression | |
US6094151A (en) | Apparatus and method for finite state machine coding of information selecting most probable state subintervals | |
EP1324618A2 (en) | Encoding method and arrangement | |
US5838266A (en) | Data processing apparatus and method using data compression | |
US6947606B2 (en) | Skim encoding method for compression of a two dimensional array of data | |
EP1217827A1 (en) | Image encoding device and method therefor, image decoding method and method therefor, and computer-readable recorded medium on which image encoding program and image decoding program are recorded | |
US20030219167A1 (en) | Method and system for forming HCVQ vector library | |
WO2005074146A1 (en) | Data encoding using multi-dimensional redundancies | |
JP2817843B2 (en) | Image coding method | |
Cheung et al. | Locally adaptive vector quantization: Data compression with feature preservation | |
Moreira et al. | Addressing Image Compression Techniques on current Internet Technologies |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: JOHNSON-GRACE COMPANY, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:HOULE, PAUL;REEL/FRAME:007741/0679Effective date: 19951017 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: CHASE MANHATTAN BANK, THE, AS COLLATERAL AGENT, NEFree format text: SECURITY INTEREST;ASSIGNOR:AMERICA ONLINE, INC.;REEL/FRAME:008989/0408Effective date: 19971125 |
|
AS | Assignment |
Owner name: AMERICA ONLINE, INC., VIRGINIAFree format text: MERGER;ASSIGNOR:JOHNSON-GRACE COMPANY;REEL/FRAME:010719/0825Effective date: 19960327 |
|
FEPP | Fee payment procedure |
Free format text: PAT HLDR NO LONGER CLAIMS SMALL ENT STAT AS INDIV INVENTOR (ORIGINAL EVENT CODE: LSM1); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
FPAY | Fee payment |
Year of fee payment: 4 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
FPAY | Fee payment |
Year of fee payment: 12 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYFree format text: PAYER NUMBER DE-ASSIGNED (ORIGINAL EVENT CODE: RMPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
AS | Assignment |
Owner name: BANK OF AMERICAN, N.A. AS COLLATERAL AGENT,TEXASFree format text: SECURITY AGREEMENT;ASSIGNORS:AOL INC.;AOL ADVERTISING INC.;BEBO, INC.;AND OTHERS;REEL/FRAME:023649/0061Effective date: 20091209Owner name: BANK OF AMERICAN, N.A. AS COLLATERAL AGENT, TEXASFree format text: SECURITY AGREEMENT;ASSIGNORS:AOL INC.;AOL ADVERTISING INC.;BEBO, INC.;AND OTHERS;REEL/FRAME:023649/0061Effective date: 20091209 |
|
AS | Assignment |
Owner name: AOL LLC,VIRGINIAFree format text: CHANGE OF NAME;ASSIGNOR:AMERICA ONLINE, INC.;REEL/FRAME:023723/0585Effective date: 20060403Owner name: AOL INC.,VIRGINIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:AOL LLC;REEL/FRAME:023723/0645Effective date: 20091204Owner name: AOL LLC, VIRGINIAFree format text: CHANGE OF NAME;ASSIGNOR:AMERICA ONLINE, INC.;REEL/FRAME:023723/0585Effective date: 20060403Owner name: AOL INC., VIRGINIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:AOL LLC;REEL/FRAME:023723/0645Effective date: 20091204 |
|
AS | Assignment |
Owner name: SPHERE SOURCE, INC, VIRGINIAFree format text: TERMINATION AND RELEASE OF SECURITY INTEREST IN PATENT RIGHTS;ASSIGNOR:BANK OF AMERICA, N A;REEL/FRAME:025323/0416Effective date: 20100930Owner name: AOL ADVERTISING INC, NEW YORKFree format text: TERMINATION AND RELEASE OF SECURITY INTEREST IN PATENT RIGHTS;ASSIGNOR:BANK OF AMERICA, N A;REEL/FRAME:025323/0416Effective date: 20100930Owner name: AOL INC, VIRGINIAFree format text: TERMINATION AND RELEASE OF SECURITY INTEREST IN PATENT RIGHTS;ASSIGNOR:BANK OF AMERICA, N A;REEL/FRAME:025323/0416Effective date: 20100930Owner name: MAPQUEST, INC, COLORADOFree format text: TERMINATION AND RELEASE OF SECURITY INTEREST IN PATENT RIGHTS;ASSIGNOR:BANK OF AMERICA, N A;REEL/FRAME:025323/0416Effective date: 20100930Owner name: QUIGO TECHNOLOGIES LLC, NEW YORKFree format text: TERMINATION AND RELEASE OF SECURITY INTEREST IN PATENT RIGHTS;ASSIGNOR:BANK OF AMERICA, N A;REEL/FRAME:025323/0416Effective date: 20100930Owner name: LIGHTNINGCAST LLC, NEW YORKFree format text: TERMINATION AND RELEASE OF SECURITY INTEREST IN PATENT RIGHTS;ASSIGNOR:BANK OF AMERICA, N A;REEL/FRAME:025323/0416Effective date: 20100930Owner name: NETSCAPE COMMUNICATIONS CORPORATION, VIRGINIAFree format text: TERMINATION AND RELEASE OF SECURITY INTEREST IN PATENT RIGHTS;ASSIGNOR:BANK OF AMERICA, N A;REEL/FRAME:025323/0416Effective date: 20100930Owner name: TACODA LLC, NEW YORKFree format text: TERMINATION AND RELEASE OF SECURITY INTEREST IN PATENT RIGHTS;ASSIGNOR:BANK OF AMERICA, N A;REEL/FRAME:025323/0416Effective date: 20100930Owner name: TRUVEO, INC, CALIFORNIAFree format text: TERMINATION AND RELEASE OF SECURITY INTEREST IN PATENT RIGHTS;ASSIGNOR:BANK OF AMERICA, N A;REEL/FRAME:025323/0416Effective date: 20100930Owner name: YEDDA, INC, VIRGINIAFree format text: TERMINATION AND RELEASE OF SECURITY INTEREST IN PATENT RIGHTS;ASSIGNOR:BANK OF AMERICA, N A;REEL/FRAME:025323/0416Effective date: 20100930Owner name: GOING INC, MASSACHUSETTSFree format text: TERMINATION AND RELEASE OF SECURITY INTEREST IN PATENT RIGHTS;ASSIGNOR:BANK OF AMERICA, N A;REEL/FRAME:025323/0416Effective date: 20100930 |
|
AS | Assignment |
Owner name: AOL INC., NEW YORKFree format text: RELEASE BY SECURED PARTY;ASSIGNOR:JPMORGAN CHASE BANK, N.A.;REEL/FRAME:027981/0275Effective date: 20100702 |
|
AS | Assignment |
Owner name: BRIGHT SUN TECHNOLOGIES, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:MARATHON SOLUTIONS LLC;REEL/FRAME:030091/0483Effective date: 20130312 |
|
XAS | Not any more in us assignment database |
Free format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:MARATHON SOLUTIONS LLC;REEL/FRAME:030091/0483 |
|
AS | Assignment |
Owner name: BRIGHT SUN TECHNOLOGIES, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:MARATHON SOLUTIONS LLC;REEL/FRAME:031900/0494Effective date: 20130312 |
|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:BRIGHT SUN TECHNOLOGIES;REEL/FRAME:033147/0587Effective date: 20140129 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044144/0001Effective date: 20170929 |