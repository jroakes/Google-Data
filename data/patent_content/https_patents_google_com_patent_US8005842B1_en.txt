BACKGROUND
This disclosure relates to inferring attributes from search queries.
An attribute is a property, feature, or characteristic of an entity. For example, individuals have a name, a height, and a weight, a city has a geographic location, a mayor, and a population, and a product can have model name and a year. Since there are many different entities and entities can have a wide variety of attributes, enumerating the attributes of an entity can be a daunting task.
SUMMARY
This specification describes technologies relating to analysis of search queries to to infer attributes of different entities. In general, in one aspect, a method includes receiving a description of a collection of search queries, inferring attributes of entities from the description of the collection of search queries, associating the inferred attributes with identifiers of entities characterized by the attributes, and making the associations of the attributes and entities available.
This and other aspects can include one or more of the following features. The attributes inferred from the description of the collection of search queries can be refined. For example, the attributes can be refined by identifying proper name attributes and discarding the proper name attributes. As another example, the attributes can be refined by identifying generic attributes and discarding the generic attributes. As another example, the attributes can be refined by identifying semantically-related attributes and combining a number count of the semantically-related attributes. As another example, the attributes can be refined by discarding entities that characterize undesirable entities.
The entities for which attributes are inferred can be instances. The inferred attributes can be associated with identifiers by associating the inferred attributes with identifiers of categories to which the instances belong. The inferred attributes can be associated with identifiers by representing a system of entities using the inferred attributes. The description of the collection of search queries can include a log of search queries. The inferred attributes can be associated with identifiers by weighting the inferred attributes and scoring the inferred attributes based, at least in part, on the weighting.
In another aspect, an article includes one or more machine-readable media storing instructions operable to cause one or more data processing devices to perform operations. The operations can include receiving a collection of search queries, examining the search queries to identify instance entities and attributes that characterize the instance entities, associating the attributes of the instance entities with categories to which the instance entities belong, and making the associations of the attributes and the categories available.
This and other aspects can include one or more of the following features. The operations can include refining the identified instance entities and attributes. For example, a number of instance entities and attributes can be reduced. As another example, the instance entities and attributes can be refined by identifying proper name attributes and generic attributes and discarding the proper name attributes and the generic attributes.
The operations can include scoring the attributes associated with a category. For example, the attributes can be weighted based on a parsing of the search query or a weighting of the attributes can be smoothed to avoid over-emphasis of rare attributes. The attributes can be associated with categories by storing identifiers of the attributes in association with identifiers of the categories and/or by comparing the identified instance entities to definitions of the categories. Examining the search queries can include inferring the instance entities and the attributes using an extract pattern.
Particular implementations of the subject matter described in this specification can realize one or more of the following advantages. The search queries formulated by a set of diverse users can be used to identify attributes of entities, along with the relative importance of those attributes. This can be done automatically, without bias from a human user who is overseeing the identification of attributes.
The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages will be apparent from the description and drawings, and from the claims.
BRIEF DESCRIPTION OF DRAWINGS
FIGS. 1, 6, 9 are flowcharts of processes for inferring attributes of entities from search queries.
FIG. 2 shows a search query log.
FIG. 3 is a schematic representation of a collection of linguistic patterns that can be used to infer entity attributes.
FIG. 4 is an example of a data object that represents an entity using attributes of the entity.
FIG. 5 is an example of a data structure that embodies the association of entity attributes with entities characterized by the attributes.
FIGS. 7, 8 are flowcharts of processes for refining a collection of attributes.
FIG. 10 shows a collection of predefined category definitions.
FIG. 11 is a schematic representation of a collection of assignments of instance attributes to categories.
FIG. 12 is a schematic representation of the collection of FIG. 11 after refining by identifying and discarding proper name attributes.
FIG. 13 is a schematic representation of the collection of FIG. 12 after refining by identifying and discarding generic attributes.
FIG. 14 is a schematic representation of the collection of FIG. 13 after refining by identifying and combining semantically-related attributes.
FIG. 15 is a representation of a collection of associations of refined instance attributes with categories.
FIG. 16 is a graph that illustrates the precision of attributes inferred from search queries and associated with the category “city.”
FIG. 17 is a graph that illustrates the precision of attributes inferred from search queries and associated with the category “drug.”
Like reference symbols in the various drawings indicate like elements.
DETAILED DESCRIPTION
FIG. 1 is a flowchart of a process 100 for inferring attributes of entities from search queries. Process 100 can be performed by a system of one or more data processing devices performing operations in accordance with the logic of a set of machine-readable instructions. For example, process 100 can be performed by a computer that runs software.
The system performing process 100 receives a description of a collection of search queries (105). A search query is a collection of one or more constraints that identify a subset of a larger collection of information for retrieval. For example, a search query can include a string of text that is provided to a search engine by a human user for searching the Internet for resources that are related to the text in the search query.
The search queries can be described in a number of ways. For example, the description can include a redaction or other summary of a collection of search queries. As another example, a list of search queries in a collection and a number count identifying the number of times that the search queries appear in the collection can be received. FIG. 2 shows yet another example of a description of a collection of search queries, namely, a search query log 200. Search query log 200 is a record of strings of text 205, 210, 215, 220 that a human user has provided to a search engine for searching the Internet.
Returning to FIG. 1, the system performing process 100 infers entity attributes from the description of the search queries (110). Attributes can be inferred by identifying entities, attributes, and relationships between the entities and attributes in the described search queries. For example, language or other text in search queries can be examined to identify entities, attributes, and their associations. As discussed further below, the entities characterized by the inferred attributes can be instances or categories of instances.
FIG. 3 is a schematic representation of a collection 300 of linguistic patterns that can be used to infer entity attributes from a description of search queries. In particular, collection 300 includes extract patterns 305, 310, 315, 320, 325, 330 that can be used to identify entities, attributes, and relationships between the entities and attributes in a log of search queries, such as search query log 200 (FIG. 2).
Extract pattern 305 can be used to scan keyword-based queries for text that matches the format “what is the <attribute> of <entity>.” Examples of such text includes “what is the capital of Brazil” and “what is the airspeed velocity of an unladen swallow.” Extract pattern 310 can be used to scan keyword-based queries for text that matches the format “who is the <attribute> of <entity>.” Examples of such text includes “who is the mayor of Chicago” and “who is the CEO of Google.”
Extract pattern 315 can be used to scan keyword-based queries for text that matches the format “the <attribute> of <entity>.” Examples of such text includes “the capital of France” and “the manager of the Yankees.” Extract pattern 320 can be used to scan keyword-based queries for text that matches the format “who is the <entity>'s <attribute>.” Examples of such text includes “who is the Yankees' manager” and “who is the airplane's pilot.” Extract pattern 325 can be used to scan keyword-based queries for text that matches the format “<entity>'s<attribute>.” Examples of such text includes “Rosemary's baby” and “Michelangelo's David.”
A subset of the extract patterns in collection 300 can be used to infer entity attributes from a description of search queries. Moreover, collection 300 is not an exhaustive list of extract patterns. For example, other extract patterns, extract patterns in different tenses (e.g., “what was the <attribute> of <entity>” or “who will be the <attribute> of <entity>”), and extract patterns with different numbers (e.g., “what are the <attributes> of <entity>” and “who are the <attributes> of <entity>”) can also be used.
Returning to FIG. 1, the system performing process 100 associates the entity attributes with the entities for which the entity attribute is a property, feature, or characteristic (115). Such associations can be embodied in a representation of the entities in the logic of a set of data processing activities. For example, the entities can be represented in data that characterizes the attributes of the entities. As another example, the entities can be represented in one or more discrete data structures that include information describing associated attributes and embodies the association between entities and attributes.
FIG. 4 is an example of a data object 400 that represents an entity using attributes of the entity. Data object 400 can represent an instance (e.g., France, Atlanta, Warhol) and/or a category of instances (e.g., companies, countries, opiates). In some implementations, multiple data objects can be used to define a system of entities using relations between entities, attribute inheritance, and the like.
The representation of an entity by data object 400 can include an object name 405 and a collection of entity attributes 410. Object name 405 is the name of the entity represented by object 400. Attribute collection 410 includes attributes that are properties, features, or characteristics of the entity represented by object 400. In some implementations, entity attributes in collection 410 can have associated values that further define the entity. For example, an object class 400 that represents left-handed relief pitchers can have the value “left-handed” associated with a handedness attribute in collection 410.
FIG. 5 is an example of a data structure 500 that embodies the association of entity attributes with entities characterized by the attributes. Data structure 500 includes a data table 505 and a collection of linked lists 510, 515, 520, 525, 530.
Data table 505 includes a collection of entries 535, 540, 545, 550, 555. Entries 535, 540, 545, 550, 555 each include an identifier of an entity along with a pointer to an associated linked list 510, 515, 520, 525, 530. In particular, entry 535 includes an identifier of the entity “France” along with a pointer to linked list 510, entry 540 includes an identifier of the entity “opiates” along with a pointer to linked list 515, entry 545 includes an identifier of the entity “company” along with a pointer to linked list 520, entry 550 includes an identifier of the entity “Atlanta” along with a pointer to linked list 525, and entry 555 includes an identifier of the entity “Warhol” along with a pointer to linked list 530. The entities identified in entries 535, 540, 545, 550, 555 can be instances (e.g., France, Atlanta, Warhol) and/or categories of instances (e.g., companies, teams, opiates). The identifiers in entries 535, 540, 545, 550, 555 can be a name, a numeric or other identifier associated with the entity, a hash value, or the like.
Linked lists 510, 515, 520, 525, 530 each include a collection of entity attributes that are a property, feature, or characteristic of the entities identified in entries 535, 540, 545, 550, 555 of data table 505. For example, linked list 510 includes the entity attributes “capital,” “population,” and “currency” that are associated with the entity “France” by virtue of the pointer from entry 535. As another example, linked list 515 includes the entity attributes “side effects” and “cost” that are associated with the entity “opiates” by virtue of the pointer from entry 540.
In some implementations, entity attributes in linked lists 510, 515, 520, 525, 530 can have associated values that further define the entity. For example, the entity attribute “currency” in linked list 510 can be associated with the value “Euro.”
Returning to FIG. 1, the system performing process 100 makes the associations of entity attributes and entities available (120). The associations can be made available to a human user and/or to one or more sets of data processing activities performed in accordance with the logic of machine-readable instructions. For example, the associations can be output on a display. As another example, access to a data structure that embodies the association of entity attributes with entities can be granted to a set of data processing activities.
In some implementations, the associations of entity attributes and entities can be made available for associating values with the entity attributes. For example, the values can be identified using answer extraction systems and techniques.
In some implementations, the associations of entity attributes and entities, along with values associated with entity attributes, can be made available to a search engine or an allied set of data processing activities. In response to receipt of a search query that names an entity, the search engine can augment a set of responsive search results with a compilation of facts regarding the named entity. The facts can be based on the values associated with attributes associated with the entity named in the search query.
Moreover, in some implementations, the associations of entity attributes and entities can be made available to a search engine or allied set of data processing activities for identifying keyword-based queries that request factual information. For example, queries that include both an entity and an attribute of that entity (e.g., “altitude Helsinki” or “capital Peru”) can by identified as requests for factual information by comparing the queries to associations of entity attributes and entities. Moreover, in some implementations, values that are associated with entity attributes can be used to generate a factual response to such queries.
FIG. 6 is a flowchart of a process 600 for inferring attributes of entities from search queries. Process 600 can be performed by a system of one or more data processing devices performing operations in accordance with the logic of a set of machine-readable instructions.
In addition to receiving a description of search queries (105) and inferring entity attributes from the description of search queries (110), the system performing process 600 refines the entity attributes inferred from the description of search queries (605). Refining the entity attributes can generally improve the quality of the entity attributes for a selected purpose. For example, refining entity attributes can improve the precision of the entity attributes, as discussed further below. Improved precision can be useful in, e.g., augmenting a set of responsive search results with a compilation of facts regarding an entity named in the search query, identifying keyword-based queries that request factual information, and generating factual response to such keyword-based queries. Such improvements in quality can result from a reduction in the number of entity attributes by, e.g., eliminating undesirable attributes and/or merging related attributes.
The system performing process 600 associates the refined entity attributes with entities (610). Such associations can be embodied in a representation of the entities in the logic of a set of data processing activities. The associations of the entity attributes and entities can be made available (120).
FIG. 7 is a flowchart of a process 700 for refining a collection of attributes. Process 700 can be performed in isolation or in conjunction with one or more other processes. For example, process 700 can be performed (605) in process 600 (FIG. 6) by the same system that performs process 600 or by an allied system.
The system performing process 700 identifies and assembles attributes that are to be associated with desirable entities (705). For example, the system can receive a list or other collection of desirable entities and then determine which attributes in the collection are to be associated with listed entities. As another example, the system can apply a rule or other logic to determine which attributes are to be associated with desirable entities.
The system performing process 700 discards any remaining attributes (710). For example, the discarded attributes can be deleted from memory or otherwise omitted from further processing of attributes.
FIG. 8 is a flowchart of a process 800 for refining a collection of attributes. Process 800 can be performed in isolation or in conjunction with one or more other processes. For example, process 800 can be performed (605) in process 600 (FIG. 6), alone or in conjunction with process 700, by the same system or by an allied system.
The system performing process 800 identifies and discards proper name attributes (805). Proper names denote particular people, places, or things. In English, proper names are properly capitalized. Proper name attributes are identified as attributes using extract patterns or other approaches but are proper names or parts of proper names. For example, the extract pattern “the <attribute> of <entity>” identifies “battle” as an attribute of “Midway” in the phrase “the Battle of Midway.” As another example, the extract pattern “what is the <attribute> of <entity>” identifies “Archdiocese” as an attribute of “New York” in the phrase “what is the Archdiocese of New York.” As another example, the extract pattern “the <attribute> of <entity>” identifies “Commonwealth” as an attribute of “Virginia” in the phrase “the Commonwealth of Virginia.” As yet another example, the extract pattern “<entity's><attribute>” identifies “Rome” as an attribute of “Texas” in the phrase “Texas' Rome.” In these cases, the entity attributes are part of proper names (i.e., “The Battle of Midway,” “The Archdiocese of New York,” “The Commonwealth of Virginia,” and “Rome, Texas,” respectively).
Proper name attributes can be identified in a number of ways. For example, the case of an attribute in a search query can be used to identify proper name attributes. However, with many search queries failing to include proper capitalization, this approach can be problematic.
As another example, proper name attributes can be identified by recovering case information from a more reliable source. For example, dictionaries, encyclopedia, or the Internet can be scanned to recover case information for attributes. The case information can be used to identify proper name attributes. In some implementations, the Internet can be scanned and a heuristic rule used to identify proper name attributes. For example, if an attribute is capitalized more than 50% of the time in a certain pattern, then the attribute can be identified as a proper name attribute in that pattern.
Proper name attributes can be discarded, e.g., by deleting them from memory or otherwise omitting them from further processing of attributes.
The system performing process 800 identifies and discards generic attributes (810). Generic attributes are attributes that are properties, features, or characteristics of so many different entities that they do little to characterize different entities. For example, the extract pattern “the <attribute> of <entity>” identifies “middle” as an attribute of “France,” “Atlanta,” “summer,” “life,” and “nowhere” in the phrases “the middle of France,” “the middle of Atlanta,” “the middle of summer,” “the middle of life,” and “the middle of nowhere.” As another example, the extract pattern “the <attribute> of <entity>” identifies “meaning” as an attribute of “life,” “food,” “this,” “privatization,” and “freedom” in the phrases “the meaning of life,” “the meaning of food,” “the meaning of this,” “the meaning of privatization,” and “the meaning of freedom.” Other generic entity attributes include “picture,” “story,” “summary,” “beginning,” “end,” “top,” “bottom,” and the like.
Generic attributes can be identified based on the number of different entities with which they are to be associated. For example, a heuristic rule (such as, e.g., an entity attribute that is to be associated with more than 30% of the desirable entities) can be used to identify generic attributes. Generic attributes can be discarded, e.g., by deleting them from memory or otherwise omitting them from further processing of attributes.
The system performing process 800 identifies and combines the number counts of semantically-related attributes (815). Semantically-related attributes are attributes that are to be associated with a single entity but characterize the same or a similar property, feature, or characteristic of that entity. For example, the attributes “czar” and “tsar” can characterize the same property, feature, or characteristic of an entity, as can the attributes “colour” and “color.” Attributes that are misspellings or abbreviations are other examples of semantically-related attributes. For example, the “prezident” of Brazil is semantically-related to the “president” of Brazil and the “pres.” of Brazil. Semantically-related attributes can be identified using, e.g., a thesaurus, heuristics based on the edit distance between attributes, and/or heuristics based on shared head words of attributes.
A number count of an attribute embodies the frequency of the attribute's use in characterizing an entity. For example, a number count can be a uniformly-incremented tally of the number of times that an attribute is inferred from different queries in association with an entity. As another example, each inference of an attribute in association with an entity can be weighted, e.g., based on the search query from which the attribute is inferred. The weights can be summed to embody the frequency of the attribute's use. As discussed farther below, such number counts can be used to score and/or rank the attributes of an entity.
FIG. 9 is a flowchart of a process 900 for inferring attributes of a type of entity, namely, categories of instances, from search queries. Process 900 can be performed by a system of one or more data processing devices performing operations in accordance with the logic of a set of machine-readable instructions.
In addition to receiving a description of search queries (105), the system performing process 900 infers instance attributes from the description of the search queries (905). An instance is an entity that falls within a category. Instances within a category share common attributes that define that category. For example, the instances “France,” “England,” and “Sweden” all fall within the category “countries.” As another example, the instances “countries,” “states,” and “counties” all fall within the category “administrative units.” Thus, an entity can be an instance in one context and a category in another context. Instance attributes can be inferred, e.g., by parsing language or other text in search queries using extract patterns 305, 310, 315, 320, 325 (FIG. 3).
The system performing process 600 assigns the instance attributes to one or more categories into which the instance falls (910). The assignments can be based on the presence of an instance characterized by that attribute in a category. In some implementations, the presence of an instance in a category can be determined by comparing the attributes of different instances and grouping the instances with similar or identical attributes into a category. In this manner, categories can be defined based on the entities and attributes inferred from search queries.
In other implementations, the presence of an instance in a category can be predefined. FIG. 10 shows a collection 1000 of example category definitions 1005, 1010, 1015, 1020, 1025, 1030 that are predefined, e.g., by a human user. Each definition 1005, 1010, 1015, 1020, 1025, 1030 includes an identifier of a category (such as the identifiers “C1,” “C2,” “C3,” “C4,” “C5,” “C6” in column 1035) and identifiers of instances within that category (shown in lists 1040).
In operation, after a system infers an instance attribute from a description of search queries, the system can compare the instance characterized by that attribute with the instances identified in lists 1040 of collection 1000. When one or more matches are found, the system can assign the instance attribute to the categories defined in definitions 1005, 1010, 1015, 1020, 1025, 1030.
FIG. 11 is a schematic representation of a collection 1100 of assignments of instance attributes to categories. In particular, collection 1100 represents assignments of the attributes inferred from search query log 200 (FIG. 2) to the categories defined in category definition collection 1000.
As shown, collection 1100 includes a series of category/attribute pairs 1105, 1110, 1115, 1120, 1125, 1130, 1135, 1140, 1145, 1150 . . . , which are denoted as (category identifier, attribute). For example, category/attribute pair 1105 embodies the assignment of the attribute “fuel economy” to category C2. Category C2 is defined in definition 1010 (FIG. 10) as including the instance “Honda Civic.” The attribute “fuel economy” was inferred from the query described in string of text 205 in query log 200 (FIG. 2) as characterizing the instance “Honda Civic.” As another example, category/attribute pair 1110 embodies the assignment of the attribute “maker” to category C4. Category C4 is defined in definition 1020 (FIG. 10) as including the instance “Solaris.” The attribute “maker” was inferred from the query described in string of text 210 in query log 200 (FIG. 2) as characterizing the instance “Solaris.”
Returning to FIG. 9, the system performing process 900 refines the instance attributes (915). Refining the instance attributes can generally reduce the number of instance attributes assigned to each category by, e.g., eliminating undesirable attributes and/or merging related attributes. For example, the system performing process 900 can discard instance attributes that are to be associated with undesirable instances, such as those not found in a predefined category, using process 700 (FIG. 7). As another example, the system performing process 900 can identify and discard proper name attributes and generic attributes, or identify and combine semantically-related attributes, using process 800 (FIG. 8).
FIG. 12 is a schematic representation of assignment collection 1100 after refining by identifying and discarding proper name attributes. In particular, category/attribute pairs 1125, 1130 (along with other category/attribute pairs) have been discarded as proper name attributes and hence removed from collection 1100.
FIG. 13 is another schematic representation of assignment collection 1100 after refining by identifying and discarding generic attributes. In particular, category/attribute pairs 1135, 1140 (along with other category/attribute pairs) have been discarded as generic attributes and hence removed from collection 1100.
FIG. 14 is a schematic representation of assignment collection 1100 after refining by identifying and combining semantically-related attributes. In particular, category/attribute pairs 1145, 1150 have been discarded as semantically-related to other attributes and hence removed from collection 1100.
Returning to FIG. 9, the system performing process 900 associates the refined entity attributes with categories (920). Such associations can be embodied in a representation of the categories in the logic of a set of data processing activities.
FIG. 15 is a representation of a collection 1500 of associations 1505, 1510, 1515, 1520 of refined instance attributes with categories C1, C2, C3, C4. The associations can be embodied in a representation of the categories (such as a representation of a data object class) and/or a data structure (such as a data structure 500 (FIG. 5)).
Returning to FIG. 9, the system performing process 900 scores the instance attributes associated with each category (925). Such scorings can be based on the extent to which an instance attribute is relevant to characterizing the category. The scorings can be used to rank the instance attributes, and the rankings can be embodied in a representation of the entities in the logic of a set of data processing activities, e.g., by the order in which instance attributes are listed in a data structure.
The instance attributes associated with each category can be scored in a variety of different ways. For example, the instance attributes can be scored based on a number count that embodies the frequency that the instance attributes appear in the description of search queries.
In some implementations, an inference of an instance attribute can be weighted based on the extract pattern used to identify the instance attribute from a description of search queries. The weighting can reflect the nature of the extract pattern. For example, whole sentence, natural language extract patterns (e.g., “What is the capital of Brazil?”) can be weighted more heavily than other extract patterns (e.g., “Brazil's capital”). The weighting can be used to calculate a number count that embodies both the rate that the instance attribute appears in a description of search queries and the nature of the search queries in which the instance attribute appears. Instance attributes can be scored based on such number counts.
In some implementations, an inference of an instance attribute can be weighted using the score Score (C, A) calculated using Equation 1, where Wf (C, A) is the weighted frequency of the attribute A in the category C, N is the total frequency over all pairs, Sf (C, A) is a smoothing factor that avoids over-emphasis of rare attributes, Wf (C) is the weighted frequency of the category C, and Wf (A) is the weighted frequency of the attribute A in all categories.
The system performing process 900 can make the scored associations of instance attributes and entities available (930). The associations can be made available to a human user and/or to one or more sets of data processing activities performed in accordance with the logic of machine-readable instructions. For example, the associations of entity attributes and entities can be made available to a search engine for augmenting search results and/or for identifying keyword-based queries that request factual information.
In one implementation, a random sample of around 50 million unique search queries was assembled from query logs collected by the GOOGLE search engine in the first few months of 2006. The queries were all in English and were accompanied by a description of their frequency of submission within the logs.
A test set of five categories, namely “drug,” “company,” painter,” “city,” and “country,” were initially targeted. Each of these classes was defined as a set of representative instances, as shown in Table 1.
Each of the first 100 attributes associated with each category was manually assigned a correctness label to reflect the precision of associating the attribute with the category. Attributes labeled “vital” were thought to be indispensable from a list of attributes of a target category. Attributes labeled “okay” were thought to provide useful, if non-essential, information characterizing a target category. Attributes labeled “wrong”
| TABLE 1 |
| |
| CLASS | SIZE | EXAMPLE INSTANCES |
| |
| Drug | 346 | Ibuprofen, Tobradex, Prilosec |
| Company | 738 | Ford, Xerox, Longs Drug Stores |
| Painter | 1011 | Georgia O'Keefe, Ossip Zadkine |
| City | 591 | Hyderabad, Albuquerque, Tokyo |
| Country | 265 | Yemen, India, Paraguay, Egypt |
| |
were thought to be useful in characterizing a target category. These labels, and a numeric value that reflects the precision of the attributes, are presented in Table 2.
TABLE 2 |
|
LABEL |
VALUE |
EXAMPLE ATTRIBUTES |
|
Vital |
1.0 |
(country, president), (drug, cost) |
Okay |
0.5 |
(city, restaurant), (company, strengths) |
Wrong |
0 |
(painter, diary), (drug, users) |
|
Using these numeric values, the precision at a “rank n” in a given list of attributes is the sum of the assigned values for the first number n attributes divided by the number n itself. Table 3 provides examples of the precision at various ranks.
|
TABLE 3 |
|
|
|
|
PRECISION AT RANK |
|
10 |
20 |
30 |
40 |
50 |
|
|
|
Drug |
0.90 |
0.93 |
0.90 |
0.89 |
0.82 |
|
Company |
0.90 |
0.93 |
0.83 |
0.79 |
0.79 |
|
Painter |
0.95 |
0.93 |
0.85 |
0.84 |
0.75 |
|
City |
0.85 |
0.73 |
0.72 |
0.66 |
0.65 |
|
Country |
0.95 |
0.93 |
0.90 |
0.89 |
0.82 |
|
|
FIG. 16 is a graph 1600 that illustrates the precision of attributes inferred from search queries and associated with the category “city.” Graph 1600 includes an X-axis 1605, a Y-axis 1610, and a number of traces 1615, 1620, 1625, 1630. Position along X-axis 1605 reflects the scoring of the attribute the collection of attributes associated with the category “city.” Position along Y-axis 1610 embodies the precision of the attribute, calculated as the sum of the assigned values for the first number n attributes divided by the number n itself.
Four distinct lists of attributes were evaluated for the category “city,” corresponding to the use of two different approaches to scoring the instance attributes and two different approaches to refining the attributes after inferring. In particular, the instance attributes were scored based on a weighting 1) calculated by summing the products of the frequency of the attribute and a factor embodying the strength of the extract pattern used to infer the attribute or 2) calculated using Equation 1. As for refining, the inferred attributes were refined 1) using process 700 (FIG. 2) or 2) using both process 700 (FIG. 2) and process 800 (FIG. 8).
Thus, trace 1615 shows the precision of attributes as a function of rank for attributes scored based on a weighting calculated using Equation 1 and refined using both process 700 (FIG. 2) and process 800 (FIG. 8). Trace 1620 shows the precision of attributes as a function of rank for attributes scored based on a weighting calculated by summing the products of the frequency of the attribute and a factor embodying the strength of the extract pattern and refined using both process 700 (FIG. 2) and process 800 (FIG. 8). Trace 1625 shows the precision of attributes as a function of rank for attributes scored based on a weighting calculated using Equation 1 and refined using process 700 (FIG. 2). Trace 1630 shows the precision of attributes as a function of rank for attributes scored based on a weighting calculated by summing the products of the frequency of the attribute and a factor embodying the strength of the extract pattern and refined using process 700 (FIG. 2). As can be seen, filtering has a stronger impact on precision than the approach used to calculate the weighting.
FIG. 17 is a graph 1700 that illustrates the precision of attributes inferred from search queries and associated with the category “drug.” Graph 1700 includes an X-axis 1705, a Y-axis 1710, and a number of traces 1715, 1720, 1725, 1730. Position along X-axis 1705 embodies the ranking of the attribute the collection of attributes associated with the category “drug.” Position along Y-axis 1710 embodies the precision of the attribute, calculated as the sum of the assigned values for the first number n attributes divided by the number n itself.
Four distinct lists of attributes were evaluated for the category “drug,” corresponding to the use of two different approaches to scoring the instance attributes and two different approaches to refining the attributes after inferring. In particular, trace 1715 shows the precision of attributes as a function of rank for attributes scored based on a weighting calculated using Equation 1 and refined using both process 700 (FIG. 2) and process 800 (FIG. 8). Trace 1720 shows the precision of attributes as a function of rank for attributes scored based on a weighting calculated by summing the products of the frequency of the attribute and a factor embodying the strength of the extract pattern and refined using both process 700 (FIG. 2) and process 800 (FIG. 8). Trace 1725 shows the precision of attributes as a function of rank for attributes scored based on a weighting calculated using Equation 1 and refined using process 700 (FIG. 2). Trace 1730 shows the precision of attributes as a function of rank for attributes scored based on a weighting calculated by summing the products of the frequency of the attribute and a factor embodying the strength of the extract pattern and refined using process 700 (FIG. 2). As can be seen, filtering has a stronger impact on precision than the approach used to calculate the weighting.
Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions encoded on a computer-readable medium for execution by, or to control the operation of, data processing apparatus. The computer-readable medium can be a machine-readable storage device, a machine-readable storage substrate, a memory device, a composition of matter effecting a machine-readable propagated signal, or a combination of one or more of them. The term “data processing apparatus” encompasses all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them. A propagated signal is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus.
A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.
The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special to purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).
Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio player, a Global Positioning System (GPS) receiver, to name just a few. Computer-readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.
To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.
Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described is this specification, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (“LAN”) and a wide area network (“WAN”), e.g., the Internet.
The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
While this specification contains many specifics, these should not be construed as limitations on the scope of the invention or of what may be claimed, but rather as descriptions of features specific to particular embodiments of the invention. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.
Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.
A number of implementations have been described. Nevertheless, it will be understood that various modifications may be made. For example, process steps can be omitted and/or performed in different order and yet meaningful results achieved. For example, the identification and discard of generic attributes in process 800 (FIG. 8) can be omitted but the precision of a collection of entity attributes nevertheless improved. Accordingly, other implementations are within the scope of the following claims.