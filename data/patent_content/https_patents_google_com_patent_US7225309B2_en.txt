US7225309B2 - Method and system for autonomic performance improvements in an application via memory relocation - Google Patents
Method and system for autonomic performance improvements in an application via memory relocation Download PDFInfo
- Publication number
- US7225309B2 US7225309B2 US10/682,436 US68243603A US7225309B2 US 7225309 B2 US7225309 B2 US 7225309B2 US 68243603 A US68243603 A US 68243603A US 7225309 B2 US7225309 B2 US 7225309B2
- Authority
- US
- United States
- Prior art keywords
- instructions
- memory
- performance
- instruction
- data
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related, expires
Links
- 230000015654 memory Effects 0.000 title claims abstract description 240
- 238000000034 method Methods 0.000 title claims abstract description 234
- 230000002567 autonomic effect Effects 0.000 title description 6
- 230000006872 improvement Effects 0.000 title description 3
- 238000012545 processing Methods 0.000 claims abstract description 62
- 238000004590 computer program Methods 0.000 claims abstract description 9
- 230000006399 behavior Effects 0.000 abstract description 21
- 230000008569 process Effects 0.000 description 184
- 238000010586 diagram Methods 0.000 description 44
- 238000012544 monitoring process Methods 0.000 description 38
- 230000004044 response Effects 0.000 description 31
- 239000000872 buffer Substances 0.000 description 22
- 238000004458 analytical method Methods 0.000 description 17
- 230000007246 mechanism Effects 0.000 description 17
- 230000006870 function Effects 0.000 description 16
- 238000012986 modification Methods 0.000 description 10
- 230000004048 modification Effects 0.000 description 10
- 238000003860 storage Methods 0.000 description 10
- 230000009471 action Effects 0.000 description 8
- 230000008859 change Effects 0.000 description 8
- 230000014509 gene expression Effects 0.000 description 7
- 238000013507 mapping Methods 0.000 description 7
- 102100034013 Gamma-glutamyl phosphate reductase Human genes 0.000 description 6
- 230000008901 benefit Effects 0.000 description 6
- 238000004891 communication Methods 0.000 description 6
- 238000005070 sampling Methods 0.000 description 6
- 238000001514 detection method Methods 0.000 description 5
- 238000012805 post-processing Methods 0.000 description 5
- 238000013519 translation Methods 0.000 description 5
- 239000008186 active pharmaceutical agent Substances 0.000 description 3
- 230000005540 biological transmission Effects 0.000 description 3
- 230000000903 blocking effect Effects 0.000 description 3
- 238000005457 optimization Methods 0.000 description 3
- 230000002093 peripheral effect Effects 0.000 description 3
- 238000012360 testing method Methods 0.000 description 3
- 238000012546 transfer Methods 0.000 description 3
- 230000004075 alteration Effects 0.000 description 2
- 238000013459 approach Methods 0.000 description 2
- 230000002708 enhancing effect Effects 0.000 description 2
- 238000011156 evaluation Methods 0.000 description 2
- 230000009191 jumping Effects 0.000 description 2
- 101150055094 PMC1 gene Proteins 0.000 description 1
- 102100038208 RNA exonuclease 4 Human genes 0.000 description 1
- 101150073729 Rexo4 gene Proteins 0.000 description 1
- 101100290680 Schizosaccharomyces pombe (strain 972 / ATCC 24843) med1 gene Proteins 0.000 description 1
- 101100400958 Schizosaccharomyces pombe (strain 972 / ATCC 24843) med14 gene Proteins 0.000 description 1
- 230000002411 adverse Effects 0.000 description 1
- 230000004931 aggregating effect Effects 0.000 description 1
- 238000010420 art technique Methods 0.000 description 1
- 230000000593 degrading effect Effects 0.000 description 1
- 230000001419 dependent effect Effects 0.000 description 1
- 238000009826 distribution Methods 0.000 description 1
- 230000007717 exclusion Effects 0.000 description 1
- 230000002401 inhibitory effect Effects 0.000 description 1
- 230000002452 interceptive effect Effects 0.000 description 1
- 238000012423 maintenance Methods 0.000 description 1
- 238000004519 manufacturing process Methods 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 230000002829 reductive effect Effects 0.000 description 1
- 238000001228 spectrum Methods 0.000 description 1
- 238000009987 spinning Methods 0.000 description 1
- 238000002198 surface plasmon resonance spectroscopy Methods 0.000 description 1
- 230000001360 synchronised effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/34—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment
- G06F11/3466—Performance evaluation by tracing or monitoring
- G06F11/348—Circuit details, i.e. tracer hardware
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/30—Monitoring
- G06F11/34—Recording or statistical evaluation of computer activity, e.g. of down time, of input/output operation ; Recording or statistical evaluation of user activity, e.g. usability assessment
- G06F11/3466—Performance evaluation by tracing or monitoring
- G06F11/3471—Address tracing
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2201/00—Indexing scheme relating to error detection, to error correction, and to monitoring
- G06F2201/86—Event-based monitoring
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2201/00—Indexing scheme relating to error detection, to error correction, and to monitoring
- G06F2201/88—Monitoring involving counting
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
Definitions
- the present invention is related to the following applications: “Method and Apparatus for Selectively Counting Instructions and Data Accesses”, Ser. No. 10/674,604, “Method and Apparatus for Generating Interrupts Upon Execution of Marked Instructions and Upon Access to Marked Memory Locations”, Ser. No. 10/675,831, “Method and Apparatus for Counting Data Accesses and Instruction Executions that Exceed a Threshold”, Ser. No. 10/675,778, “Method and Apparatus for Counting Execution of Specific Instructions and Accesses to Specific Data Locations”, Ser. No.
- the present invention relates generally to an improved data processing system.
- the present invention provides a method and apparatus for obtaining performance data in a data processing system.
- the present invention provides a method and apparatus for hardware assistance to software tools in obtaining performance data in a data processing system.
- Performance tools are used to monitor and examine a data processing system to determine resource consumption as various software applications are executing within the data processing system. For example, a performance tool may identify the most frequently executed modules and instructions in a data processing system, or may identify those modules which allocate the largest amount of memory or perform the most I/O requests. Hardware performance tools may be built into the system or added at a later point in time.
- a trace tool may use more than one technique to provide trace information that indicates execution flows for an executing program.
- One technique keeps track of particular sequences of instructions by logging certain events as they occur, a so-called event-based profiling technique.
- a trace tool may log every entry into, and every exit from, a module, subroutine, method, function, or system component.
- a trace tool may log the requester and the amounts of memory allocated for each memory allocation request. Typically, a time-stamped record is produced for each such event.
- Corresponding pairs of records similar to entry-exit records, also are used to trace execution of arbitrary code segments, starting and completing I/O or data transmission, and for many other events of interest.
- Another trace technique involves periodically sampling a program's execution flows to identify certain locations in the program in which the program appears to spend large amounts of time.
- This technique is based on the idea of periodically interrupting the application or data processing system execution at regular intervals, so-called sample-based profiling.
- information is recorded for a predetermined length of time or for a predetermined number of events of interest.
- the program counter of the currently executing thread which is an executable portion of the larger program being profiled, may be recorded during the intervals.
- the application is modified by a software developer during a post-processing phase in accordance with the insights that have been gained through a post-processing analysis of the information that was gather during the execution of an application.
- Performance indicators are associated with instructions or memory locations, and processing of the performance indicators enables counting of events associated with execution of those instructions or events associated with accesses to those memory locations.
- the performance information that has been dynamically gathered from the assisting hardware is available to the software application during runtime in order to autonomically affect the behavior of the software application, particularly to enhance its performance. For example, the counted events may be used to autonomically improve the performance of the execution of an application by relocating code segments and data areas.
- FIG. 1 is a block diagram of a data processing system in which the present invention may be implemented
- FIG. 2 is a block diagram of a processor system for processing information according to a preferred embodiment of the present invention
- FIG. 3 is a diagram illustrating components used in processing instructions associated with indicators in accordance with a preferred embodiment of the present invention
- FIG. 4 is a diagram illustrating one mechanism for associating a performance indicator with an instruction or memory location in accordance with a preferred embodiment
- FIG. 5 is a diagram illustrating a bundle in accordance with a preferred embodiment of the present invention.
- FIG. 6 is a diagram of a subroutine containing performance indicators in accordance with a preferred embodiment of the present invention.
- FIG. 7 is a flowchart of a process for processing instructions containing performance indicators in accordance with a preferred embodiment of the present invention.
- FIG. 8 is a flowchart of a process for selectively sending instructions to an interrupt unit in accordance with a preferred embodiment of the present invention.
- FIG. 9 is a flowchart of a process for generating an interrupt in response to an access of a memory location associated with a performance indicator in accordance with a preferred embodiment of the present invention.
- FIG. 10 is a flowchart of a process for counting events in accordance with a preferred embodiment of the present invention.
- FIG. 11 is a flowchart of a process for selective counting of instructions in accordance with a preferred embodiment of the present invention.
- FIG. 12 is a flowchart of a process for selective counting of instructions in accordance with a preferred embodiment of the present invention.
- FIG. 13 is a flowchart of a process for identifying instructions exceeding a threshold in accordance with a preferred embodiment of the present invention.
- FIG. 14 is a flowchart of a process for accesses to a memory location in accordance with a preferred embodiment of the present invention.
- FIG. 15 is a block diagram illustrating components used for generating meta data, such as performance indicators, in accordance with a preferred embodiment of the present invention.
- FIG. 16 is a diagram illustrating meta data in accordance with a preferred embodiment of the present invention.
- FIG. 17 is a diagram illustrating components involved in loading and maintaining a performance instrumentation shadow cache in accordance with a preferred embodiment of the present invention.
- FIG. 18 is a flowchart of a process for generating meta data for instructions in accordance with a preferred embodiment of the present invention.
- FIG. 19 is a flowchart of a process for generating meta data for memory locations in accordance with a preferred embodiment of the present invention.
- FIG. 20 is a flowchart of a process for counting execution for particular instructions in accordance with a preferred embodiment of the present invention.
- FIG. 21 is a flowchart of a process for counting accesses to a particular memory location in accordance with a preferred embodiment of the present invention.
- FIG. 22 is a diagram illustrating components used in accessing information collected with respect to the execution of instructions or the access of memory locations in accordance with a preferred embodiment of the present invention.
- FIG. 23 is a block diagram of components used in autonomically modifying code in a program to allow selective counting or profiling of sections of code in accordance with a preferred embodiment of the present invention
- FIG. 24 is a flowchart of a process for dynamically adding or associating performance indicators to an instruction in accordance with a preferred embodiment of the present invention.
- FIG. 25 is a diagram illustrating components used to scan pages through associating performance indicators with instructions in a page in accordance with a preferred embodiment of the present invention.
- FIG. 26 is a flowchart of a process for associating indicators to instructions in a page in accordance with a preferred embodiment of the present invention.
- FIG. 27 is a diagram depicting call stack containing stack frames in accordance with a preferred embodiment of the present invention.
- FIG. 28 is a flowchart of a process for identifying events associated with call and return instructions in which data is collected from a performance monitor unit in accordance with a preferred embodiment of the present invention
- FIG. 29 is a flowchart of a process for identifying instructions that have been executed more than a selected number of times in accordance with a preferred embodiment of the present invention.
- FIG. 30 is a flowchart of a process for examining a call stack and identifying a caller of a routine when a particular instruction is executed more than some selected number of times in accordance with a preferred embodiment of the present invention
- FIG. 31 is a diagram illustrating ranges of instructions and data that has been selected for monitoring in accordance with a preferred embodiment of the present invention.
- FIG. 32 is a flowchart of a process for counting the number of visits to a set range as well as the number of instructions executed within a set range in accordance with a preferred embodiment of the present invention
- FIG. 33 depicts a flowchart that shows a process by which an execution path within software is autonomically selected based on the detection of hardware events, wherein the events have been enabled through performance indicators as described above;
- FIG. 34 depicts a block diagram that shows a representation of object code for a subroutine that implements a process, such as that shown in FIG. 33 , by which an execution path within software is autonomically selected based on the detection of hardware events, wherein the events have been enabled through performance indicators as described above;
- FIG. 35 depicts a diagram that represents a set of pseudocode statements that autonomically alter the behavior of a software application through the use of the performance indicators that have previously been described;
- FIG. 36 depicts a diagram that represents a set of pseudocode statements that autonomically alter the behavior of a software application through the use of performance indicators that are generated in accordance with compiler directives that are placed into the source code of the software application;
- FIG. 37 depicts a flowchart that shows a process within a compiler by which the compiler configures the software application to dynamically change its behavior based on real-time performance information through the use of multiple alternative versions of object code for subroutines;
- FIG. 38 depicts a block diagram that shows an application with multiple subroutines that call a given subroutine
- FIG. 39 depicts a block diagram that shows an application with multiple subroutines that selectively call one of the multiple alternative versions of object code of a subroutine that have been generated by a compiler;
- FIG. 40 depicts a block diagram that shows a representation of object code for a selective or conditional call of one of multiple alternative versions of object code for a given subroutine
- FIG. 41 depicts a diagram that represents an example of a set of pseudocode statements that may be used by a compiler to generate the appropriate autonomic alteration in the behavior of a software application for selecting one of multiple alternative versions of object code for a subroutine;
- FIG. 42 depicts a typical implementation of a spin lock mutex
- FIG. 43 depicts a set of pseudocode instructions that represents typical logic for acquiring a semaphore
- FIG. 44 depicts a flowchart that shows a process for associating performance indicators with semaphores in accordance with an embodiment of the present invention
- FIG. 45 depicts a flowchart that shows a process during which performance indicators are used to gather statistical information about the use of semaphores in accordance with an embodiment of the present invention
- FIG. 46 depicts a set of performance indicators that is associated with a set of pseudocode instructions that represents logic for acquiring a semaphore
- FIG. 47 depicts a flowchart that shows a process by which a memory manager determines hot spots using performance indicators in accordance with an embodiment of the present invention
- FIG. 48 depicts a flowchart that shows a process by which a scanning daemon assists in the determination of hot spots within an application by placing performance indicators at particular locations as requested by a memory manager;
- FIG. 49 depicts a block diagram that shows the modification of an application through memory relocation during runtime in accordance with information that has been gathered through the use of performance indicators.
- Client 100 is an example of a computer, in which code or instructions implementing the processes of the present invention may be located.
- Client 100 employs a peripheral component interconnect (PCI) local bus architecture.
- PCI peripheral component interconnect
- AGP Accelerated Graphics Port
- ISA Industry Standard Architecture
- Processor 102 and main memory 104 are connected to PCI local bus 106 through PCI bridge 108 .
- PCI bridge 108 also may include an integrated memory controller and cache memory for processor 102 . Additional connections to PCI local bus 106 may be made through direct component interconnection or through add-in boards.
- local area network (LAN) adapter 110 small computer system interface SCSI host bus adapter 112 , and expansion bus interface 114 are connected to PCI local bus 106 by direct component connection.
- audio adapter 116 graphics adapter 118 , and audio/video adapter 119 are connected to PCI local bus 106 by add-in boards inserted into expansion slots.
- Expansion bus interface 114 provides a connection for a keyboard and mouse adapter 120 , modem 122 , and additional memory 124 .
- SCSI host bus adapter 112 provides a connection for hard disk drive 126 , tape drive 128 , and CD-ROM drive 130 .
- Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.
- An operating system runs on processor 102 and is used to coordinate and provide control of various components within data processing system 100 in FIG. 1 .
- the operating system may be a commercially available operating system such as Windows XP, which is available from Microsoft Corporation.
- An object oriented programming system such as Java may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on client 100 . “Java” is a trademark of Sun Microsystems, Inc. Instructions for the operating system, the object-oriented programming system, and applications or programs are located on storage devices, such as hard disk drive 126 , and may be loaded into main memory 104 for execution by processor 102 .
- FIG. 1 may vary depending on the implementation.
- Other internal hardware or peripheral devices such as flash read-only memory (ROM), equivalent nonvolatile memory, or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in FIG. 1 .
- the processes of the present invention may be applied to a multiprocessor data processing system.
- client 100 if optionally configured as a network computer, may not include SCSI host bus adapter 112 , hard disk drive 126 , tape drive 128 , and CD-ROM 130 .
- the computer to be properly called a client computer, includes some type of network communication interface, such as LAN adapter 110 , modem 122 , or the like.
- client 100 may be a stand-alone system configured to be bootable without relying on some type of network communication interface, whether or not client 100 comprises some type of network communication interface.
- client 100 may be a personal digital assistant (PDA), which is configured with ROM and/or flash ROM to provide non-volatile memory for storing operating system files and/or user-generated data.
- PDA personal digital assistant
- processor 102 uses computer implemented instructions, which may be located in a memory such as, for example, main memory 104 , memory 124 , or in one or more peripheral devices 124 – 130 .
- FIG. 2 a block diagram of a processor system for processing information is depicted in accordance with a preferred embodiment of the present invention.
- Processor 210 may be implemented as processor 102 in FIG. 1 .
- processor 210 is a single integrated circuit superscalar microprocessor. Accordingly, as discussed further herein below, processor 210 includes various units, registers, buffers, memories, and other sections, all of which are formed by integrated circuitry. Also, in the preferred embodiment, processor 210 operates according to reduced instruction set computer (“RISC”) techniques. As shown in FIG. 2 , system bus 211 is connected to a bus interface unit (“BIU”) 212 of processor 210 . BIU 212 controls the transfer of information between processor 210 and system bus 211 .
- BIU bus interface unit
- BIU 212 is connected to an instruction cache 214 and to data cache 216 of processor 210 .
- Instruction cache 214 outputs instructions to sequencer unit 218 .
- sequencer unit 218 selectively outputs instructions to other execution circuitry of processor 210 .
- the execution circuitry of processor 210 includes multiple execution units, namely a branch unit 220 , a fixed-point unit A (“FXUA”) 222 , a fixed-point unit B (“FXUB”) 224 , a complex fixed-point unit (“CFXU”) 226 , a load/store unit (“LSU”) 228 , and a floating-point unit (“FPU”) 230 .
- FXUA 222 , FXUB 224 , CFXU 226 , and LSU 228 input their source operand information from general-purpose architectural registers (“GPRs”) 232 and fixed-point rename buffers 234 .
- GPRs general-purpose architectural registers
- FXUA 222 and FXUB 224 input a “carry bit” from a carry bit (“CA”) register 239 .
- FXUA 222 , FXUB 224 , CFXU 226 , and LSU 228 output results (destination operand information) of their operations for storage at selected entries in fixed-point rename buffers 234 .
- CFXU 226 inputs and outputs source operand information and destination operand information to and from special-purpose register processing unit (“SPR unit”) 237 .
- SPR unit special-purpose register processing unit
- FPU 230 inputs its source operand information from floating-point architectural registers (“FPRs”) 236 and floating-point rename buffers 238 .
- FPU 230 outputs results (destination operand information) of its operation for storage at selected entries in floating-point rename buffers 238 .
- LSU 228 In response to a Load instruction, LSU 228 inputs information from data cache 216 and copies such information to selected ones of rename buffers 234 and 238 . If such information is not stored in data cache 216 , then data cache 216 inputs (through BIU 212 and system bus 211 ) such information from a system memory 239 connected to system bus 211 . Moreover, data cache 216 is able to output (through BIU 212 and system bus 211 ) information from data cache 216 to system memory 239 connected to system bus 211 . In response to a Store instruction, LSU 228 inputs information from a selected one of GPRs 232 and FPRs 236 and copies such information to data cache 216 .
- Sequencer unit 218 inputs and outputs information to and from GPRs 232 and FPRs 236 .
- branch unit 220 inputs instructions and signals indicating a present state of processor 210 .
- branch unit 220 outputs (to sequencer unit 218 ) signals indicating suitable memory addresses storing a sequence of instructions for execution by processor 210 .
- sequencer unit 218 inputs the indicated sequence of instructions from instruction cache 214 . If one or more of the sequence of instructions is not stored in instruction cache 214 , then instruction cache 214 inputs (through BIU 212 and system bus 211 ) such instructions from system memory 239 connected to system bus 211 .
- sequencer unit 218 In response to the instructions input from instruction cache 214 , sequencer unit 218 selectively dispatches the instructions to selected ones of execution units 220 , 222 , 224 , 226 , 228 , and 230 .
- Each execution unit executes one or more instructions of a particular class of instructions.
- FXUA 222 and FXUB 224 execute a first class of fixed-point mathematical operations on source operands, such as addition, subtraction, ANDing, ORing and XORing.
- CFXU 226 executes a second class of fixed-point operations on source operands, such as fixed-point multiplication and division.
- FPU 230 executes floating-point operations on source operands, such as floating-point multiplication and division.
- rename buffers 234 As information is stored at a selected one of rename buffers 234 , such information is associated with a storage location (e.g. one of GPRs 232 or carry bit (CA) register 242 ) as specified by the instruction for which the selected rename buffer is allocated. Information stored at a selected one of rename buffers 234 is copied to its associated one of GPRs 232 (or CA register 242 ) in response to signals from sequencer unit 218 . Sequencer unit 218 directs such copying of information stored at a selected one of rename buffers 234 in response to “completing” the instruction that generated the information. Such copying is called “writeback.”
- a storage location e.g. one of GPRs 232 or carry bit (CA) register 242
- rename buffers 238 As information is stored at a selected one of rename buffers 238 , such information is associated with one of FPRs 236 . Information stored at a selected one of rename buffers 238 is copied to its associated one of FPRs 236 in response to signals from sequencer unit 218 . Sequencer unit 218 directs such copying of information stored at a selected one of rename buffers 238 in response to “completing” the instruction that generated the information.
- Processor 210 achieves high performance by processing multiple instructions simultaneously at various ones of execution units 220 , 222 , 224 , 226 , 228 , and 230 . Accordingly, each instruction is processed as a sequence of stages, each being executable in parallel with stages of other instructions. Such a technique is called “pipelining.” In a significant aspect of the illustrative embodiment, an instruction is normally processed as six stages, namely fetch, decode, dispatch, execute, completion, and writeback.
- sequencer unit 218 selectively inputs (from instruction cache 214 ) one or more instructions from one or more memory addresses storing the sequence of instructions discussed further hereinabove in connection with branch unit 220 , and sequencer unit 218 .
- sequencer unit 218 decodes up to four fetched instructions.
- sequencer unit 218 selectively dispatches up to four decoded instructions to selected (in response to the decoding in the decode stage) ones of execution units 220 , 222 , 224 , 226 , 228 , and 230 after reserving rename buffer entries for the dispatched instructions' results (destination operand information).
- operand information is supplied to the selected execution units for dispatched instructions.
- Processor 210 dispatches instructions in order of their programmed sequence.
- execution units execute their dispatched instructions and output results (destination operand information) of their operations for storage at selected entries in rename buffers 234 and rename buffers 238 as discussed further hereinabove. In this manner, processor 210 is able to execute instructions out-of-order relative to their programmed sequence.
- sequencer unit 218 indicates an instruction is “complete.”
- Processor 210 “completes” instructions in order of their programmed sequence.
- sequencer 218 directs the copying of information from rename buffers 234 and 238 to GPRs 232 and FPRs 236 , respectively. Sequencer unit 218 directs such copying of information stored at a selected rename buffer.
- processor 210 updates its architectural states in response to the particular instruction.
- Processor 210 processes the respective “writeback” stages of instructions in order of their programmed sequence. Processor 210 advantageously merges an instruction's completion stage and writeback stage in specified situations.
- each instruction requires one machine cycle to complete each of the stages of instruction processing. Nevertheless, some instructions (e.g., complex fixed-point instructions executed by CFXU 226 ) may require more than one cycle. Accordingly, a variable delay may occur between a particular instruction's execution and completion stages in response to the variation in time required for completion of preceding instructions.
- Completion buffer 248 is provided within sequencer 218 to track the completion of the multiple instructions which are being executed within the execution units. Upon an indication that an instruction or a group of instructions have been completed successfully, in an application specified sequential order, completion buffer 248 may be utilized to initiate the transfer of the results of those completed instructions to the associated general-purpose registers.
- processor 210 also includes performance monitor unit 240 , which is connected to instruction cache 214 as well as other units in processor 210 . Operation of processor 210 can be monitored utilizing performance monitor unit 240 , which in this illustrative embodiment is a software-accessible mechanism capable of providing detailed information descriptive of the utilization of instruction execution resources and storage control. Although not illustrated in FIG.
- performance monitor unit 240 is coupled to each functional unit of processor 210 to permit the monitoring of all aspects of the operation of processor 210 , including, for example, reconstructing the relationship between events, identifying false triggering, identifying performance bottlenecks, monitoring pipeline stalls, monitoring idle processor cycles, determining dispatch efficiency, determining branch efficiency, determining the performance penalty of misaligned data accesses, identifying the frequency of execution of serialization instructions, identifying inhibited interrupts, and determining performance efficiency.
- the events of interest also may include, for example, time for instruction decode, execution of instructions, branch events, cache misses, and cache hits.
- Performance monitor unit 240 includes an implementation-dependent number (e.g., 2–8) of counters 241 – 242 , labeled PMC1 and PMC2, which are utilized to count occurrences of selected events. Performance monitor unit 240 further includes at least one monitor mode control register (MMCR). In this example, two control registers, MMCRs 243 and 244 are present that specify the function of counters 241 – 242 . Counters 241 – 242 and MMCRs 243 – 244 are preferably implemented as SPRs that are accessible for read or write via MFSPR (move from SPR) and MTSPR (move to SPR) instructions executable by CFXU 226 .
- MFSPR move from SPR
- MTSPR move to SPR
- counters 241 – 242 and MMCRs 243 – 244 may be implemented simply as addresses in I/O space.
- control registers and counters may be accessed indirectly via an index register. This embodiment is implemented in the IA-64 architecture in processors from Intel Corporation.
- processor 210 also includes interrupt unit 250 , which is connected to instruction cache 214 . Additionally, although not shown in FIG. 2 , interrupt unit 250 is connected to other functional units within processor 210 . Interrupt unit 250 may receive signals from other functional units and initiate an action, such as starting an error handling or trap process. In these examples, interrupt unit 250 is employed to generate interrupts and exceptions that may occur during execution of a program.
- a spare field may be used to hold an indicator that identifies the instruction or memory location as one that is to be monitored by a performance monitor unit or by some other unit in a processor.
- the indicator may be stored in another location in association with the instruction or memory location.
- a spare field is typically used, but in some cases the instruction may be extended to include the space needed for the indicator.
- the architecture of the processor may require changes. For example, a 64 bit architecture may be changed to a 65 bit architecture to accommodate the indicator.
- an indicator may be associated with the data or memory locations in which the data is located.
- Instruction cache 300 receives bundles 302 .
- Instruction cache 300 is an example of instruction cache 214 in FIG. 2 .
- a bundle is a grouping of instructions. This type of grouping of instructions is typically found in an IA-64 processor, which is available from Intel Corporation.
- Instruction cache 300 processes instructions for execution.
- instruction cache 300 determines which instructions are associated with indicators. These indicators also are referred to as “performance indicators” in these examples. Signals 304 have been associated with performance indicators. As a result, signals 304 for the instructions are sent to performance monitor unit 306 .
- Performance monitor unit 306 is an example of performance monitor unit 240 in FIG. 2 .
- a signal is sent to indicate that a marked instruction is being executed.
- a marked instruction is an instruction associated with a performance indicator.
- a performance indicator may indicate that all items or instructions in a bundle are marked to be counted.
- signals for these instructions are sent by instruction cache 300 to the appropriate functional unit.
- a functional unit other than performance monitor unit 306 may count execution of instructions.
- the cache unit, instruction cache 300 detects the indicators and sends signals to performance monitor unit 306 .
- performance monitor unit 306 When signals for these instructions are received by performance monitor unit 306 , performance monitor unit 306 counts events associated with execution of instructions 304 . As illustrated, performance monitor unit 306 is programmed only to count events for instructions associated with performance indicators. In other words, an indicator associated with a instruction or memory location is used to enable counting of events associated with the instruction or memory location by performance monitor unit 306 . If an instruction is received by instruction cache 300 without a performance indicator, then events associated with that instruction are not counted. In summary, the performance indicators enable the counting on a per instruction or per memory location basis in a processor.
- Performance monitor unit 306 counts events for instructions associated with performance indicators, if performance monitor unit 306 is set in a mode to count metrics enabled for these types of marked instructions. In some cases, performance monitor unit 306 may be set to perform some other type of counting, such as counting execution of all instructions, which is a currently available function.
- the data and indicators are processed by a data cache, such as data cache 216 in FIG. 2 , rather than by an instruction cache.
- the data cache sends signals indicating that marked memory locations are being accessed to performance monitor unit 306 .
- Marked memory locations are similar to marked instructions. These types of memory locations are ones associated with a performance indicator.
- FIG. 4 a diagram illustrating one mechanism for associating a performance indicator with an instruction or memory location is depicted in accordance with a preferred embodiment of the present invention.
- Processor 400 receives instructions from cache 402 .
- the indicators are not stored with the instructions or in the memory locations in which data is found. Instead, the indicators are stored in a separate area of storage, performance instrumentation shadow cache 404 .
- the storage may be any storage device, such as, for example, a system memory, a flash memory, a cache, or a disk.
- processor 400 When processor 400 receives an instruction from cache 402 , processor 400 checks performance instrumentation shadow cache 404 to see whether a performance indicator is associated with the instruction. A similar check is made with respect to accesses of memory locations containing data. In one embodiment, a full shadow word is provided for each corresponding word that does not affect the actual data segments. In other words, processor 400 allows for the architecture or configuration of cache 402 to remain unchanged. In these examples, the mapping described is word for word. However, some other type of mapping may be used, such as a shadow bit per data word in which a bit in performance instrumentation shadow cache 404 corresponds to one word of data.
- the compilers using this feature, create the debug information in a separate work area from the data area themselves in a manner similar to debug symbols.
- the extra information is prepared by the loader so that it will be available to incorporate into performance instrumentation shadow cache 404 when instructions are loaded into cache 402 .
- These cache areas may be intermingled and either marked as such or understood by the mode of operation.
- Processor 400 uses the performance indicators to determine how the related data accesses and instruction executions are to be counted or made to take exceptions. In these examples, the process is programmed by a debugger or a performance analysis program to know whether to use the shadow information while it is executing instructions.
- Bundle 500 contains instruction slot 502 , instruction slot 504 , instruction slot 506 and template 508 . As illustrated, bundle 500 contains 128 bits. Each instruction slot contains 41 bits, and template 508 contains 5 bits. Template 508 is used to identify stops within the current bundle and to map instructions within the slots to different types of execution units.
- Spare bits within bundle 500 are used to hold indicators of the present invention.
- indicators 510 , 512 , and 514 are located within instruction slots 502 , 504 , and 506 , respectively. These indicators may take various forms and may take various sizes depending on the particular implementation.
- Indicators may use a single bit or may use multiple bits. A single bit may be used to indicate that events are to be counted in response to execution of that instruction. Multiple bits may be used to identify a threshold, such as a number of processor or clock cycles for instruction execution that may pass before events should be counted. Further, these bits may even be used as a counter for a particular instruction. A similar use of fields may be used for indicators that mark data or memory locations.
- template 508 may be used to contain a bundle of related indicators, so that one bit is used to identify all of the instructions in a bundle.
- the bundle itself could be extended to be 256 bits or some other number of bits to contain the extra information for the performance indicators.
- subroutine 600 in FIG. 6A includes a number of instructions in which instructions 602 , 604 , and 606 are associated with performance indicators. These instructions also are referred to as marked instructions. When these instructions are executed, events associated with those instructions are counted to obtain data for software tools to analyze the performance of a data processing system executing a subroutine 600 .
- Data or memory locations containing data may be marked with indicators in a similar manner. These indicators are used in counting accesses to the data or memory locations in these examples.
- data 610 includes data associated with performance indicators.
- Data 612 and data 614 are sections of data 610 that are associated with performance indicators. These sections of data, which are associated with performance indicators, also are referred to as marked data.
- FIG. 7 a flowchart of a process for processing instructions containing performance indicators is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 7 may be implemented in an instruction cache, such as instruction cache 214 in FIG. 2 .
- the process begins by receiving a bundle (step 700 ).
- each bundle has a format similar to bundle 500 in FIG. 5 .
- An instruction in the bundle is identified (step 702 ).
- a determination is made as to whether a performance indicator associated with the instruction is present (step 704 ). This determination may be made by examining an appropriate field in the instruction or bundle. Alternatively, a performance instrumentation shadow cache, such as performance instrumentation shadow cache 404 in FIG. 4 may be checked to see if a performance indicator is associated with the instruction.
- a signal is sent to a performance monitor unit (step 706 ). Upon receiving this signal, the performance monitor unit will count events associated with the execution of the instruction. Additionally, the instruction is processed (step 708 ). Processing of the instruction includes, for example, sending the instruction to the appropriate functional unit for execution.
- step 710 a determination is made as to whether additional unprocessed instructions are present in the bundle. If additional unprocessed instructions are present in the bundle, the process returns to step 702 as described above. Otherwise, the process terminates. Turning back to step 704 , if the performance indicator is not present, the process proceeds directly to step 708 .
- FIG. 8 a flowchart of a process for selectively sending signals to an interrupt unit is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 8 may be implemented in an instruction cache, such as instruction cache 242 in FIG. 2 .
- This process is employed in cases in which monitoring events using a performance monitor unit may miss certain events. For example, a performance monitor unit counts events. When a cache miss occurs, a signal is sent to the performance monitor unit. When the meta data for a corresponding cache line is loaded into the cache, the appropriate signal or signals also are raised. If the meta data indicates that an exception is to be raised, then a signal is sent to the interrupt unit in which the signal indicates that an exception is to be raised.
- the process begins by receiving a bundle (step 800 ).
- An instruction in the bundle is identified (step 802 ).
- a determination is made as to whether a performance indicator associated with the instruction is present (step 804 ).
- the signal sent to the interrupt unit to indicate an exception is to be raised is different from the signal sent to the performance monitor unit.
- an instruction may be associated with a specific performance indicator having a first value that causes a signal to be sent to the interrupt unit.
- a second value for a performance indicator may be used to send a different signal to the performance monitor unit.
- the signal is sent to an interrupt unit (step 806 ).
- the interrupt unit Upon receiving this signal, the interrupt unit initiates appropriate call flow support to process this interrupt.
- the call flow support may, for example, record cache misses that may be missed by a functional unit trying to access instructions or data in a cache.
- processing of the instruction includes, for example, sending the instruction to the appropriate functional unit for execution.
- step 810 a determination is made as to whether additional unprocessed instructions are present in the bundle. If additional unprocessed instructions are present in the bundle, the process returns to step 802 as described above. Otherwise, the process terminates. Turning back to step 804 , if the performance indicator is not present, the process proceeds directly to step 808 .
- FIG. 9 a flowchart of a process for generating an interrupt in response to an access of a memory location associated with a performance indicator is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 9 may be implemented in a data cache, such as data cache 246 in FIG. 2 .
- the process begins by identifying a request to access a memory location (step 900 ). In response to identifying this request, a determination is made as to whether a performance indicator is associated with the memory location (step 902 ). If a performance indicator is associated with the memory location, an interrupt is generated by sending a signal to the interrupt unit (step 904 ). Thereafter, the access to the memory location is processed (step 906 ) with the process terminating thereafter.
- FIG. 10 a flowchart of a process for counting events is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 10 may be implemented in a performance monitor unit, such as performance monitor unit 240 in FIG. 2 .
- the process begins by receiving a signal from an instruction cache indicating that an instruction with a performance indicator is being processed (step 1000 ). Next, events associated with the instruction being processed are counted (step 1002 ) with the process terminating thereafter. The counting of events may be stored in a counter, such as counter 241 in FIG. 2 .
- FIG. 11 a flowchart of a process for selective counting of instructions is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 11 may be implemented in an instruction cache, such as instruction cache 214 in FIG. 2 .
- the process begins by determining whether an instruction associated with a performance indicator has been received (step 1100 ).
- the indicator causes counting of events for this instruction and all subsequent instructions executed by the processor.
- the indicator could be an instruction itself which indicates the new mode of counting is to be started. If an instruction with an indicator has been received, a flag is set to start counting events for instructions (step 1102 ). This flag indicates that counting events for instructions should start.
- step 1104 a determination is made as to whether an instruction with an indicator has been received.
- the indicator could be an instruction itself which indicates the new mode of counting is to be stopped. If an instruction with an indicator is received, the flag is unset to stop counting the events (step 1106 ) with the process terminating thereafter.
- the indicator in step 1100 and step 1104 may be the same indicator in which the indicator toggles the setting and unsetting of the flag. In another implementation, two different indicators may be used in which a first indicator only sets the flag. A second indicator is used to unset the flag. Communication between a cache unit, such as an instruction cache or a data cache, and the performance monitor unit to indicate a mode of counting may be implemented simply with a high signal when counting is to occur and a low signal when counting is no longer enabled.
- FIG. 12 a flowchart of a process for selective counting of instructions is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 12 may be implemented in an instruction cache, such as instruction cache 214 in FIG. 2 .
- the process begins by checking a flag (step 1200 ). A determination is made as to whether the flag is set (step 1202 ). If the flag is set, a signal is sent to the performance monitor unit to enable this unit to count events (step 1204 ) with the process terminating thereafter. Otherwise, a signal is sent to the performance monitor unit to disable the counting of events (step 1206 ) with the process terminating thereafter.
- FIGS. 11 and 12 count events for all instructions after an instruction is associated with a performance indicator. In this manner, fewer bits may be used to toggle counting of events. Further, with the counting of all instructions, events associated with calls to external subroutines may be counted.
- FIG. 13 a flowchart of a process for identifying instructions exceeding a threshold is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 13 may be implemented in an instruction cache, such as instruction cache 214 in FIG. 2 .
- the process begins by receiving an instruction associated with a performance indicator (step 1300 ).
- a threshold is identified for the instruction (step 1302 ).
- the threshold relates to a number of processor or clock cycles needed to complete an instruction. If the cache latency or amount of time needed to access the cache exceeds the threshold value, that event is counted.
- the threshold value is set within the indicator in these examples.
- the meaning of the bits may also be controlled through an interface, such as a set of registers that may be used to set the meaning of each of the bits. These registers are ones that are added to the processor architecture for this specific purpose.
- Cycles for executing the instruction are monitored (step 1304 ).
- a determination is made as to whether the threshold has been exceeded for this instruction (step 1306 ). If the threshold has been exceeded, then a selected action is performed (step 1308 ).
- This selected action may take different forms depending on the particular implementation. For example, a counter may be incremented each time the threshold is exceeded. Alternatively, an interrupt may be generated. The interrupt may pass control to another process to gather data. For example, this data may include a call stack and information about the call stack.
- a stack is a region of reserved memory in which a program or programs store status data, such as procedure and function call addresses, passed parameters, performance monitor counter values, and sometimes local variables.
- Step 1310 may be implemented one instruction at a time.
- a signal is sent.
- execution of a single instruction results in one signal being sent.
- multiple signals may be needed to indicate the execution of each instruction.
- a sampling approach may be supported, where the threshold is only supported for one instruction at a time. This may be done by only supporting thresholds for those instructions that are in a particular position in the processor's instruction queue.
- one signal may be sent if at least one of the marked instructions exceeds the threshold. For each instruction in which a threshold is exceeded, a separate signal is raised or generated for that instruction.
- step 1312 the collected information is sent to a monitoring program (step 1312 ), with the process terminating thereafter. Otherwise, the process returns to step 1304 as described above. In step 1306 , if the threshold is not exceeded for the instruction, the process proceeds directly to step 1310 .
- a similar process may be implemented in a data cache, such as data cache 216 in FIG. 2 to monitor accesses to memory locations.
- the process illustrated in FIG. 13 may be adapted to identify the cycles needed to access data in a memory location. As with the execution of instructions, counting occurs or an interrupt is generated when the amount of time needed to access the data in a memory location exceeds a specified threshold.
- these indicators may be included as part of the instruction or with the data in a memory location. Alternatively, these indicators may be found in a performance instrumentation shadow cache or memory in association with the instruction or data.
- FIG. 14 a flowchart of a process for monitoring accesses to a memory location is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 14 may be implemented in a data cache, such as data cache 216 in FIG. 2 . This process is used to count accesses to data in a memory location.
- the process begins by receiving data associated with a performance indicator (step 1400 ). A determination is made as to whether a memory location for the data has been accessed (step 1402 ). If the memory location has been accessed, then a counter is incremented (step 1404 ). A determination is made as to whether monitoring is to end (step 1406 ). If monitoring of the memory location is to end, the process terminates. Otherwise, the process returns to step 1402 . In step 1402 , if the memory location is not accessed, then the process proceeds to step 1406 .
- FIG. 15 a block diagram illustrating components used for generating meta data, such as performance indicators, is depicted in accordance with a preferred embodiment of the present invention.
- the compiler supports directives embedded in the source that indicate the meta data to be generated.
- Compiler 1500 may generate instructions 1502 for execution and meta data for monitoring.
- the operating system program loader/linker and/or the performance monitoring program reads the meta data generated by compiler 1500 and loads the meta data into memory, such as performance monitor section 1506 , in these examples.
- the section itself is marked as meta data 1504 .
- the processor may accept meta data 1504 in the format of the compiler generated section data in performance monitor section 1506 and populate processor's internal performance instrumentation shadow cache with the data.
- a block oriented approach is described with reference to FIG. 17 below.
- the format simply has a performance instrumentation shadow cache entry for each of its block or sector references and moves meta data 1504 to its corresponding shadow entry or entries.
- the internal format of the cache itself may be modified to contain meta data 1504 .
- the loader updates the instruction stream to contain the appropriate indicators and work areas or compiler 1500 has generated the code to contain meta data 1504 .
- the processor receives the meta data 1504 .
- meta data 1504 may be placed into performance instrumentation shadow memory 1505 in association with instructions 1502 .
- Compiler 1500 produces information in a table or debug data section. The performance monitoring program loads this information into shadow data areas in performance instrumentation shadow memory 1505 .
- the debug areas may be automatically populated by the operating system and the processor working together.
- Instructions 1502 may then be executed by processor 1508 .
- Compiler 1500 may set a register such as mode register 1510 in processor 1508 . When this register is set, processor 1508 looks at meta data 1504 in performance instrumentation shadow memory 1505 when executing instructions 1502 to determine whether performance indicators in meta data 1504 are associated with instructions that are being executed in instructions 1502 . These performance indicators are handled using processes, such as those described above with reference to FIGS. 2–14 . If mode register 1510 is not set, then meta data 1504 is ignored when instructions 1502 are executed.
- meta data 1504 may be placed within the instruction or within the data, rather than in performance instrumentation shadow memory 1505 . However, by placing meta data 1504 in performance instrumentation shadow memory 1505 , the generation of meta data 1504 may be performed dynamically when meta data 1504 is placed in performance instrumentation shadow memory 1505 .
- compiler 1500 may generate meta data 1504 after instructions 1502 have been compiled for execution by processor 1508 .
- Setting mode register 1510 causes processor 1508 to look for meta data 1504 in performance instrumentation shadow memory 1505 without having to modify instructions 1502 .
- meta data 1504 take the form of performance indicators that tell processor 1508 how to handle the execution of instructions 1502 and/or data accesses to memory location 1512 .
- Meta data 1600 is an example of meta data 1504 in FIG. 15 .
- This meta data is generated by a compiler, such as compiler 1500 .
- meta data 1600 includes 5 entries, entry 1602 , 1604 , 1606 , 1608 , and 1610 as indicated by line 1612 in meta data 1600 .
- Each of these entries includes an offset, a length, and a flag for describing the instrumentation of code in this example.
- Entry 1602 has an offset of 0 with an entry length of 120 bytes.
- Flag 1614 indicates that all instructions within the range indicated by entry length 1616 need to be counted. In these examples, each instruction has a length of 4 bytes.
- Entry 1604 has an entry length of 4 bytes, which corresponds to an instruction.
- Flag 1618 indicates that an exception should be generated upon execution of this instruction.
- an instruction beginning at an offset of 160 bytes is associated with flag 1620 . This flag indicates that the instruction should be counted if the threshold, 100 cycles, is exceeded.
- Flag 1622 in entry 1608 indicates that tracing should start at the instruction having an offset of 256 bytes. Tracing stops as indicated by flag 1624 in entry 1610 , which has a flag for the instruction at an offset of 512 bytes.
- This meta data is used to generate the performance indicators that are associated with the instructions.
- the operating system moves this meta data generated by the compiler and processes the meta data into a performance instrumentation shadow memory, such as performance instrumentation shadow memory 1506 in FIG. 15 .
- this meta data may be placed into fields within the instructions depending on the particular implementation.
- existing cache 1700 contains primary segment 1702 .
- Primary segment 1702 includes blocks 1704 , 1706 , 1708 , 1710 , 1712 , 1714 , 1716 , 1718 , 1720 , 1722 , and 1724 .
- Translation table 1726 is used to provide a mapping for blocks 1704 – 1724 in primary segment 1702 to blocks in perfinst segment 1728 . The data in this segment is placed into new performance instrumentation shadow cache 1730 .
- the compiler At program compile time, the compiler generates a new performance instrumentation data section as previously described.
- the loader queries the processor to determine cache line size.
- the loader parses perfinst segment 1728 and constructs a shadow segment, in the format required by the processor, for any text or data segment that the loader loads. This shadow segment is placed into new performance instrumentation shadow cache 1730 .
- Each block in the shadow segment contains meta data for instructions or data in the corresponding primary cache block.
- This meta data includes, for example, flags, tag fields, threshold, and count fields for each tagged item in a block in primary segment 1702 .
- This meta data also may include a flag that represents all the instructions or data in the block.
- the loader constructs a table mapping, translation table 1726 , for each block in primary segment 1702 to a corresponding perfinst block, such as block 1732 , 1734 , 1736 , 1738 , 1740 , 1742 , 1744 , 1746 , 1748 , 1750 , and 1752 in perfinst segment 1728 . Further, the loader registers the head of this table, translation table 1726 , and the location and size of primary segment 1702 with the processor.
- paging software provides a new interface to associate perfinst segment 1728 with the corresponding primary segment, primary segment 1702 .
- perfinst segment 1728 pages in or out as well.
- the processor contains new performance instrumentation shadow cache 1730 with cache frames directly associated with the frames in the existing data and instruction caches, such as existing cache 1700 .
- the cache also must load the corresponding perfinst block into the performance instrumentation shadow cache, new performance instrumentation shadow cache 1730 .
- the processor sees (from the registration data given by the loader at program load time) that the processor is bringing a block into its cache that has an associated perfinst segment, perfinst segment 1728 .
- the processor looks in translation table 1726 associated with this segment, finds a reference to the perfinst block corresponding to the block it is about to load and loads the perfinst block into new performance instrumentation shadow cache 1730 .
- cache misses associated with meta data are not signaled or are treated differently from cache misses associated data in a primary cache block, such as in primary segment 1702 .
- FIG. 18 a flowchart of a process for generating meta data for instructions is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 18 may be implemented by a performance monitoring program.
- the process begins by identifying an instruction for profiling (step 1800 ).
- This instruction may be, for example, one that has been executed more than a selected number of times.
- Meta data is generated for the identified instruction (step 1802 ).
- This meta data takes the form of a performance indicator.
- the performance indicator may, for example, increment a counter each time the instruction is executed, increment a counter if the number of cycles needed to execute the instruction exceeds a threshold value, toggle counting of events for all instructions for all events after this instruction, or count events occurring in response to executing the instruction.
- the counters are in the associated performance instrumentation shadow cache and take some number of bits to allow for a one to one correspondence between the data or instructions in the cache and the bits reserved for counting.
- the meta data is then associated with the instruction (step 1804 ).
- a similar process may be used to dynamically generate meta data for data in memory locations.
- FIG. 19 a flowchart of a process for generating meta data for memory locations is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 19 may be implemented in a compiler such as compiler 1500 in FIG. 15 .
- the process begins by identifying a memory location for profiling (step 1900 ).
- Step 1900 occurs by detecting access to a marked location.
- Meta data is generated for the identified memory location (step 1902 ).
- This meta data takes the form of a performance indicator.
- the performance indicator may, for example, increment a counter each time the memory location is accessed, increment a counter if the number of cycles needed to access the memory location exceeds a threshold value, or toggle counting of all accesses to memory locations.
- the meta data is then associated with the memory location (step 1904 ).
- a determination is made as to whether more memory locations are present for processing (step 1906 ). If additional memory locations are present, the process returns to step 1900 . Otherwise, the process terminates.
- FIG. 20 a flowchart of a process for counting execution for particular instructions is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 20 may be implemented in an instruction cache such as instruction cache 214 in FIG. 2 .
- the process begins by executing an instruction (step 2000 ). A determination is made as to whether a counter is associated with the instruction (step 2002 ). The counter may be included in a field within the instruction or may be in a performance instrumentation shadow memory. If a counter is associated with the instruction, the counter is incremented (step 2004 ) with the process terminating thereafter. Otherwise, the process terminates without incrementing the counter. The counter may be reset if the counter exceeds a threshold value.
- the counter When the counter is implemented as part of the instructions, the counter may be of limited size. In this case, a threshold value for the counter may be set to indicate when the counter is in danger of overflowing. The counter may then be reset after the value has been read. This value may be read by a performance monitor unit or by a program used to analyze data. APIs may be implemented to access this data.
- FIG. 21 a flowchart of a process for counting accesses to a particular memory location is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 21 may be implemented in a data cache, such as data cache 216 and instruction cache 214 in FIG. 2 .
- the process begins by detecting access to a memory location (step 2100 ). A determination is made as to whether a counter is associated with the memory location (step 2102 ). The counter may be included within the memory location or may be in a performance instrumentation shadow memory. If a counter is associated with the memory location, the counter is incremented (step 2104 ) with the process terminating thereafter. Otherwise, the process terminates without incrementing the counter.
- instruction unit 2200 executes instruction 2202 and increments counter 2204 . This counter is incremented each time instruction 2202 is executed.
- instruction unit 2200 may be implemented as instruction cache 214 in FIG. 2 .
- the operating system program loader/linker and/or the performance monitoring program reads the meta data generated by the compiler and determines that counting is associated with instruction or data access, then the loading process allocates data areas to maintain the counters as part of its perfinst segment.
- the size of the counters and the granularity of the data access determine the amount of work area to be allocated.
- the granularity of the data or instruction access could be word size (so that an access to any byte in the word is considered an access) and the counts could also be a word size.
- the counts could also be a word size.
- one to many mapping is present between the primary segment and the perfinst segment (a full word to contain the counts or threshold is not required).
- the loading process allocates a shadow page or pages and tells the processor to use the shadow page(s) to contain the counts. Details of this mapping are described above with reference to FIG. 17 .
- the cache unit in the processor maintains a shadow block entry to indicate the corresponding page to contain the count information. Different mapping and different levels of support could be provided.
- the compiler allocates the work areas to maintain the counts and indicates the placement of these work areas in its generated data areas.
- An entry in the meta data could indicate the start of the data, the number of bytes of data, granularity of the data, the start of the count area, and the granularity of each counting unit.
- the meta data is loaded into the processor and the processor populates its internal (shadow) cache with the meta data.
- the loader updates the instruction stream to contain the appropriate indicators and work areas or the compiler has generated the code to contain the meta data. In either case, after the code is loaded, the processor receives the meta data.
- Data unit 2206 may be implemented as data cache 206 in FIG. 2 .
- Data 2208 and counter 2210 are both located in a particular memory location.
- a new instruction may be employed in which the instruction is called ReadDataAccessCount (RDAC) that takes a data address and a register and puts the count associated with that data address in the register.
- RDAC ReadDataAccessCount
- the mechanism of the present invention provides an interface, hardware interface 2212 , to access this collected data.
- hardware interface 2212 takes the form of an application programming interface (API) for operating system 2214 .
- API application programming interface
- analysis tool 2216 may obtain data from counter 2204 and counter 2210 .
- Analysis tool 2216 may take many forms, such as for example, Oprofile, which is a known system wide profiler for Linux systems.
- FIG. 22 illustrate providing an interface to an instruction unit and a data unit
- hardware interface 2212 may be implemented to provide access to information from other units in a processor.
- APIs may be created for hardware interface 2212 that allows for accessing information located in counters in a performance monitor unit, such as counter 241 and 242 in performance monitor unit 240 in FIG. 2 .
- profiler 2300 is a program, such as tprof, that may be used to identify routines of high usage in a program, such as program 2302 .
- tprof is a timer profiler, which ships with the Advanced Interactive Executive (AIX) operating system from International Business Machines (IBM) Corporation. This program takes samples, which are initiated by a timer. Upon expiration of a timer, tprof identifies the instruction executed. Tprof is a CPU profiling tool that can be used for system performance analysis.
- the tool is an example of an analysis tool and based on the sampling technique which encompasses the following steps: interrupt the system periodically by time or performance monitor counter; determine the address of the interrupted code along with process id (pid) and thread id (tid); record a TPROF hook in the software trace buffer; and return to the interrupted code.
- a fixed number of counts of a performance monitor counter may be used instead of a timer.
- This program profiles subroutines that are used to indicate where time is spent within a program.
- a program having usage over a certain threshold also is referred to as being “hot”.
- routines of interest such as subroutine 2304 in program 2302 may be identified.
- subroutine 2304 may be autonomically modified by analysis tool 2306 to allow counting of the execution of subroutine 2304 .
- Additional routines may be identified for modification by analysis tool 2306 .
- subroutine 2304 also may be identified as a routine of interest with the instructions of this routine being modified to allow counting of the execution of subroutine 2304 .
- the modification of the code in these routines includes associating performance indicators with one or more instructions within each of these subroutines.
- program 2302 is then executed by processor 2308 .
- Processor 2308 executes program 2302 and provides counts for these routines. For example, the counting of instructions executed and the number of cycles used in executing a routine may be performed by processor 2308 using the mechanisms described above.
- FIG. 24 a flowchart of a process for dynamically adding or associating performance indicators to an instruction is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 24 may be implemented in a program, such as analysis tool 2306 in FIG. 23 .
- An analysis tool is a program that is used to obtain metrics about the execution of a program. These metrics may be any measurable parameter, such as execution time, routines executed, particular instructions executed, and memory locations accessed.
- the process begins by identifying instructions of interest using data from a profiler (step 2400 ).
- This profiler may be, for example, a timer profiler found in AIX.
- An instruction from the identified instructions is selected for modification (step 2402 ).
- a performance indicator is dynamically added to the selected instruction (step 2404 ).
- the instruction may be added in a manner such that the instructions do not need to be modified for execution.
- a performance instrumentation shadow memory such as performance instrumentation shadow memory 1506 in FIG. 15 , may be employed to hold the performance indicators. In this situation, a register is set in the processor to indicate that the performance instrumentation shadow memory should be checked for performance indicators when executing instructions.
- step 2406 A determination is then made as to whether additional identified instructions are present for modification. If additional instructions are present for modification, the process returns to step 2402 . Otherwise, the process terminates.
- FIG. 25 a diagram illustrating components used to scan pages through associating performance indicators with instructions in a page is depicted in accordance with a preferred embodiment of the present invention.
- the mechanism of the present invention uses performance indicators to allow instrumenting or modifying of instructions in a program one page at a time.
- program 2500 contains three pages, page 2502 , page 2504 , and page 2506 .
- Scanning daemon 2508 associates performance indicators with instructions in program 2500 one or more pages at a time.
- the instructions in page 2502 may be associated with performance indicators by scanning daemon 2508 .
- Program 2500 is then executed by processor 2510 .
- Data from the execution of program 2500 may then be collected. This data includes, for example, counts of events occurring in response to instructions in page 2502 , counting the number of times each instruction in page 2502 is executed, and/or identifying the number of visits to page 2502 .
- scanning daemon may remove the performance indicators from instructions in page 2502 and associate performance indicators with instructions in page 2504 .
- Program 2500 is then executed again by processor 2510 , and data from execution of this program is collected. Then, instructions in page 2506 may be modified in program 2500 executed to collect data on that page.
- routines typically not recorded by programs such as a timer profiler
- a timer profiler may not record some usages of routines because interrupts may be inhibited or the timing of samples may cause synchronous non-random behavior.
- counting a routine or other modules may be obtained in which the counts are unbiased and the system is unperturbed. In this manner, interrupt driven counting is avoided.
- the instrumenting of code is one page at a time, other groupings of instructions may be used in scanning a program, such as modules that form the program. For example, the grouping may be a single executable program, a library, a group of selected functions, and a group of selected pages.
- FIG. 26 a flowchart of a process for adding indicators to instructions in a page is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 26 may be implemented in a program, such as scanning daemon 2508 in FIG. 25 .
- a selection of pages is identified (step 2600 ).
- the pages are those in the program that are to be scanned or instrumented.
- a page within the selection of pages is selected for modification (step 2602 ).
- Indicators are then associated with all of the instructions in the selected page (step 2604 ).
- the program is then executed (step 2606 ).
- a determination is made as to whether all the pages with the selection have been scanned (step 2608 ). If all of the pages have been scanned, the process terminates thereafter. However, if not all pages have been scanned, the next page to be scanned is selected (step 2610 ), with the process returning to step 2604 as described above.
- FIG. 26 shows scanned groupings of instructions as pages.
- other types of groupings of instructions such as modules that form a program, may be scanned or instrumented in this manner.
- a program is employed to identify a caller from a routine from the information found in a call stack. This program allows for an identification of what has occurred in a routine and provides a summary of what has occurred in a program by identifying function calls that have been made. This program, however, requires instructions inserted in the code to obtain this information.
- the mechanism of the present invention allows for identifying calls and returns without having to perform special code instrumentation.
- the function of generating an interrupt on a specific set of instructions may be used to gather information about the system and applications.
- instructions for calls and returns are associated with a performance indicator that generates an interrupt.
- a “stack walk” may also be described as a “stack unwind”, and the process of “walking the stack” may also be described as “unwinding the stack.”
- walking The process can be described as “walking” as the process must obtain and process the stack frames step-by-step or frame-by-frame.
- unwinding As the process must obtain and process the stack frames that point to one another, and these pointers and their information must be “unwound” through many pointer dereferences.
- a call stack is an ordered list of routines plus offsets within routines (i.e. modules, functions, methods, etc.) that have been entered during execution of a program. For example, if routine A calls routine B, and then routine B calls routine C, while the processor is executing instructions in routine C, the call stack is ABC. When control returns from routine C back to routine B, the call stack is AB. For more compact presentation and ease of interpretation within a generated report, the names of the routines are presented without any information about offsets. Offsets could be used for more detailed analysis of the execution of a program, however, offsets are not considered further herein.
- the generated sample-based profile information reflects a sampling of call stacks, not just leaves of the possible call stacks, as in some program counter sampling techniques.
- a leaf is a node at the end of a branch, i.e. a node that has no descendants.
- a descendant is a child of a parent node, and a leaf is a node that has no children.
- a “stack” is a region of reserved memory in which a program or programs store status data, such as procedure and function call addresses, passed parameters, and sometimes local variables.
- a “stack frame” is a portion of a thread's stack that represents local storage (arguments, return addresses, return values, and local variables) for a single function invocation. Every active thread of execution has a portion of system memory allocated for its stack space.
- a thread's stack consists of sequences of stack frames. The set of frames on a thread's stack represent the state of execution of that thread at any time.
- a call stack represents all not-yet-completed function calls—in other words, it reflects the function invocation sequence at any point in time.
- Call stack 2700 includes information identifying the routine that is currently running, the routine that invoked it, and so on, all the way up to the main program.
- Call stack 2700 includes a number of stack frames 2702 , 2704 , 2706 , and 2708 .
- stack frame 2702 is at the top of call stack 2700
- stack frame 2708 is located at the bottom of call stack 2700 .
- the top of the call stack is also referred to as the “root”.
- the interrupt (found in most operating systems) is modified to obtain the program counter value (pcv) of the interrupted thread, together with the pointer to the currently active stack frame for that thread. In the Intel architecture, this is typically represented by the contents of registers: EIP (program counter) and EBP (pointer to stack frame).
- the first parameter acquired is the program counter value.
- the next value is the pointer to the top of the current stack frame for the interrupted thread. In the depicted example, this value would point to EBP 2708 a in stack frame 2708 .
- EBP 2708 points to EBP 2706 a in stack frame 2706 , which in turn points to EBP 2704 a in stack frame 2704 .
- this EBP points to EBP 2702 a in stack frame 2702 .
- EIPs 2702 b – 2708 b which identify the calling routine's return address. The routines may be identified from these addresses. Thus, routines are defined by collecting all of the return addresses by walking up or backwards through the stack.
- Obtaining a complete call stack may be difficult in some circumstances, because the environment may make tracing difficult, such as when an application having one call stack makes a call to a kernel having a different call stack.
- the hardware support provided by the mechanism of the present invention avoids some of these problems.
- FIG. 28 a flowchart of a process for identifying events associated with call and return instructions in which data is collected from a performance monitor unit is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 28 may also be implemented for an analysis tool, such as analysis tool 2216 in FIG. 22 .
- the process begins by identifying call and return instructions (step 2800 ).
- the instructions for calls and returns are ones of interest for determining when a routine has been called and when a routine completes. This may be accomplished for interrupts, interrupt returns, system calls, and returns from system calls.
- performance indicators are associated with the identified call and return instructions (step 2802 ).
- the program is then executed (step 2804 ), and data is collected from the performance monitor unit (step 2806 ) with the process terminating thereafter.
- This information may be collected through interfaces, such as hardware interface 2212 illustrated in FIG. 22 in which APIs are employed to obtain data collected by the different functional units in a processor.
- identifications of callers of routines may be made.
- This information may be used to generate data structures, such as trees to track and present information regarding the execution of the program.
- This generation of data structures may be implemented using processes similar to those provided in analysis tools.
- FIG. 29 a flowchart of a process for identifying routines that have been executed more than a selected number of times is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 29 may be implemented in a functional unit within a processor, such as instruction cache 214 in FIG. 2 . This process is used to identify counts of instructions that are executed and to generate an interrupt when these instructions have occurred more than some selected number of times.
- step 2900 If execution of an instruction containing a performance indicator is not identified, the process returns to step 2900 until a selected instruction is detected. If a selected instruction is identified as being executed, a counter with a set threshold is incremented for that selected instruction to count how often that particular instruction is executed (step 2902 ). In these examples, each instruction identified for monitoring is assigned a counter.
- Threshold values are initially determined by using documented cache miss times, for each of the cache levels. However, increasing times are used to determine problems caused by cache interventions (accesses from other processors). Repeated runs with different values may be made to identify the areas with the worst performance.
- the instruction may be associated with an indicator that includes an indication that execution of the instruction is to be monitored as well as providing a counter. Further, count criteria may be included to identify when an interrupt is to be generated. For example, an interrupt may be generated when the instruction has been executed more than thirteen times.
- step 2906 an interrupt is sent to the monitoring program (step 2906 ) with the process terminating thereafter. This interrupt may be sent to an interrupt unit, such as interrupt unit 250 in FIG. 2 , which passes control to the appropriate procedure or process to handle the interrupt.
- This process may be especially useful for routines with many branches. In this case, all branch instructions would be flagged for counting. Information derived by this type of counting may be useful for identifying improvements for compiler and just-in-time (JIT) code generation by minimizing branches or adjusting hint flags, supported in the instruction architecture of the processor that is used.
- JIT just-in-time
- FIG. 30 a flowchart of a process for examining a call stack and identifying a caller of a routine when a particular instruction is executed more than some selected number of times is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 7 may be initiated by an interrupt unit, such as interrupt unit 250 in FIG. 2 .
- This process is used to identify a call in a routine and may be used to recursively obtain information for callers.
- a call stack is examined and the caller of a routine is identified (step 3000 ).
- a count of the number of instructions executed is captured from the instruction cache (step 3002 ). The count is for a counter used in step 2902 in FIG. 29 .
- the counter is then reset (step 3004 ) with control thereafter returned from the interrupt (step 3006 ).
- the information obtained in the process in FIG. 30 may be used to identify additional routines for monitoring to recursively identify callers of routines.
- program 3100 includes instruction range 3102 and 3104 . Each of these ranges has been identified as ones of interest for monitoring. Each of these ranges is set within an instruction unit, such as instruction cache 214 in FIG. 2 . Each range is used to tell the processor the number of instructions executed in a range, as well as the number of times a range is entered during execution of program 3100 .
- Instruction cache 3106 uses range registers 3108 to define instruction ranges. These registers may be existing registers or instruction cache 3106 may be modified to include registers to define instruction ranges. These ranges may be based on addresses of instructions. Additionally, range registers 3108 may be updated by various debugger programs and performance tools.
- a counter is incremented in instruction cache 3106 .
- the instruction may be sent to a performance monitor unit, such as performance monitor unit 240 in FIG. 2 .
- the performance monitor unit tracks the count of the number of instructions executed within the range and the number of times the instruction range is entered in these examples.
- Data accesses may be monitored in a similar fashion.
- data 3112 includes data range 3114 .
- Data accesses to data range 3114 may be counted in a similar fashion to execution of instructions within instruction range 3102 or instruction range 3104 .
- These ranges may be defined in registers within a data unit, such as data cache 216 in FIG. 2 .
- These ranges for data may be defined in the register as a range of memory locations for the data.
- FIG. 32 a flowchart of a process for counting the number of visits to a set range as well as the number of instructions executed within a set range is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 32 may be implemented in an instruction unit, such as instruction cache 214 in FIG. 2 .
- an instruction is identified for execution (step 3200 ).
- a determination is made as to whether the instruction is within a set range of instructions (step 3202 ). The range may be identified by examining registers defining one or more instruction ranges. If the instruction is not within a set range of instructions, the process returns to step 3200 as described above. If the instruction is within a set range of instructions, a determination is made as to whether the previous instruction was within the set range of instructions (step 3204 ). If the previous instruction was not within the set range of instructions, a visit counter is incremented to tell the processor how many times the instruction range is entered (step 3206 ). Additionally, an execution counter is incremented to count the number of instructions executed within the set range of instructions (step 3208 ) with the process returning to step 3200 thereafter.
- step 3204 if the previous instruction was within the set range of instructions, the process proceeds to step 3208 as described above.
- a similar process to the one illustrated in FIG. 32 may be implemented for access to data.
- the process would typically be implemented in a data unit, rather than in an instruction unit.
- performance indicators may be implemented to enable the counting of events within a processor when instructions that are associated with the performance indicators are executed or when data accesses that are associated with performance indicators are made. It would be particularly advantageous to employ this real-time performance information at the application-level because it is often difficult to acquire accurate production runtime models for the workloads that are experienced by a particular piece of software. Typically, a software developer tunes an application for an expected workload and then reconfigures the application as its computational environment changes.
- a software module may contain a cache.
- a common tuning exercise is to determine the amount of memory to allocate to the cache. Making the cache too large may take memory from other data structures, thereby inhibiting their ability to perform their tasks. On the other hand, making the cache too small may render the cache ineffective, thereby degrading overall performance by imposing cache maintenance overhead and then evicting cached elements before they are used due to space limitations. Many applications are quite sensitive to their cache efficiency because a cache hit is many times faster than a cache miss.
- an application can obtain information that enables it to monitor its own state and then dynamically adjust its behavior in real-time based upon runtime experience. Because the overhead of the performance monitor counters is so low, an application would be able to take advantage of a full spectrum of tracing and sampling tools, which themselves may be adjusted by the application as execution progresses.
- FIGS. 33–41 are figures that are directed to autonomic execution-path selection.
- FIGS. 42–46 are figures that are directed to collecting statistical information about the ability of a software application to successfully acquire a semaphore.
- FIGS. 47–49 are figures that are directed to improving the performance of the execution of an application by relocating code segments and data areas.
- a flowchart depicts a process by which an execution path within software is autonomically selected based on the detection of hardware events, wherein the events have been enabled through performance indicators as described above.
- the process begins with the execution of instructions within software code, wherein the instructions are associated with performance indicators, and/or wherein the instructions access data areas that have been associated with performance indicators (step 3302 ).
- the performance monitor within the CPU of a data processing system may have counted one or more events, and the software obtains or reads the event counts from the appropriate registers within the performance monitor (step 3304 ).
- a determination is then made as to whether the value or values from the performance monitor counters satisfy a predetermined condition ( 3306 ).
- the data processing system executes a set of instructions that have been associated with a positive determination of the condition (step 3308 ), and the process is concluded. If the value or values from the performance monitor counters do not satisfy a predetermined condition, then the data processing system executes a set of instructions that have been associated with a negative determination of the condition (step 3310 ), and the process is concluded.
- FIG. 34 a block diagram depicts a representation of object code for a subroutine that implements a process, such as that shown in FIG. 33 , by which an execution path within software is autonomically selected based on the detection of hardware events, wherein the events have been enabled through performance indicators as described above.
- Object code block 3402 is a representation of object code for a particular subroutine; the object code would have been generated by compiling the source code for the subroutine.
- the blocks that are shown within FIG. 34 may represent memory areas that have been loaded with the object code for a particular subroutine.
- Object code block 3404 contains instructions that are associated with performance indicators and/or instructions that access data areas that are associated with performance indicators. The execution of the instructions in object code block 3404 performs one or more actions that correspond to step 3302 in FIG. 33 ; these instructions are similar to instructions that are described with respect to various implementations of performance indicators as explained above with respect to FIGS. 3–32 , e.g., instructions 602 as shown in FIG. 6A , or instructions that would access marked data, such as data 612 as shown in FIG. 6B .
- Object code block 3406 contains instructions that obtain or read values from performance monitor registers that have been configured to count events in accordance with the performance indicators that are associated with object code block 3404 or related marked data.
- the execution of the instructions in object code block 3406 performs one or more actions that correspond to step 3304 in FIG. 33 ; these instructions are similar to instructions that are described with respect to hardware interface 2212 in FIG. 22 , which may be implemented as a software application programming interface.
- the API for reading counters within a performance monitor of a CPU may include privileged instructions, i.e., instructions that may only be executed by a process that has been designated as privileged by the operating system; in that case, object code block 3406 may include a system call to a subroutine that returns the values from the performance monitor registers.
- Object code block 3408 contains instructions that determine whether the event counts that have been retrieved from the performance monitor satisfy logical conditions.
- the execution of the instructions in object code block 3408 performs one or more actions that correspond to step 3306 in FIG. 33 .
- the logical conditions that are checked by these instructions may be “hard-coded” into the logic of the original source code, or the logical conditions may be configurable.
- One exemplary logical condition may be a comparison between the values in two different performance monitor counters; another exemplary logical condition may be a comparison between a value from a performance monitor counter and a pre-determined value that has been retrieved from a configuration file.
- the logical condition or conditions may comprise multiple counters and other variables in a variety of Boolean expressions.
- object code block 3410 contains instructions for executional branching to other sets of instructions based on the outcomes of those evaluations.
- object code block 3412 contains instructions that are to be executed when a first condition is satisfied; the execution of the instructions in object code block 3412 performs one or more actions that correspond to step 3308 in FIG. 33 .
- Object code block 3414 contains instructions that are to be executed when a second condition is satisfied; the execution of the instructions in object code block 3414 performs one or more actions that correspond to step 3310 in FIG. 33 .
- the control flow causes additional sets of instructions to be executed, such as those represented by object code block 3416 .
- FIG. 35 a diagram represents a set of pseudocode statements that autonomically alter the behavior of a software application through the use of the performance indicators that have previously been described.
- the set of pseudocode statements that are shown in FIG. 35 perform a process that is analogous to the process that is illustrated in FIG. 33 .
- FIG. 35 depicts a specific example of pseudocode statements that would be similar to source code statements in a particular programming language that could be compiled into object code that is analogous to the object code that is illustrated in FIG. 34 .
- Statement 3502 declares a definition of a subroutine.
- Statement 3504 obtains data from an input datastream and places the data items from the datastream into a data structure while counting the number of data items that have been inputted.
- object code for statement 3504 would have been generated to include instructions, wherein those instructions (or the data areas that are accessed by those instructions) have been associated with performance indicators; the performance indicators may have been generated statically by a compiler, e.g., as described above with respect to FIG. 15 , or the performance indicators may have been generated dynamically, e.g., as described above with respect to FIG. 24 .
- the instructions immediately preceding and including the subroutine call in statement 3504 , the instructions would be associated with performance indicators such that the performance monitor should count the number of data cache hits and data cache misses that are generated.
- Statement 3506 calls a function within an API to read values from two counters within the performance monitor. It may be assumed that variable names 3508 and 3510 are constant values that are resolved by the compiler to values or appropriate indicators that identify the counters/registers within the performance monitor from which the requested values are to be retrieved; the retrieved values are then returned to the calling subroutine via the other subroutine arguments, i.e., variables 3512 and 3514 .
- Statement 3516 is an if-then type of statement that evaluates a logical expression and then causes the execution control to pass through the statement or to flow around the statement, depending upon whether the outcome of the evaluation is a logical true value or a logical false value.
- statement 3518 calls a subroutine that will modify the data structure.
- Constant value 3520 indicates that the subroutine is merely to adjust or to tweak the data structure in some programmatic manner to make the use of the data structure slightly more efficient in an effort to reduce the number of cache misses that are generated while using the data structure, which would depend upon the particular data structure and other factors in the computational environment.
- Statement 3522 is a continuation of the if-then type of statement. If the logical expression is true, which in this case means that the counted number of cache misses is greater than some number that is the product of a constant and the number of data items that were stored into the data structure, then statement 3524 calls a subroutine that will modify the data structure. Constant value 3526 indicates that the subroutine should rebuild the data structure in some programmatic manner. It may be assumed that the subroutine acts to modify the configuration of the data structure in which the newly added data items were stored in order to greatly reduce the number of cache misses. After the data structure has been modified in some manner, statement 3528 then calls a subroutine that will sort the new data items in the data structure in some manner.
- the data structure might be a hybrid of two different types of common data structures. Each of the two parts of the data structure may be used to obtain the advantages of their different characteristics.
- the data structure may be frequently searched for information about the data items, but the data items may be removed at any time. For example, data items that have been newly added might be much more likely to be removed; hence, it may not be efficient to store the newly added data items in a sorted, semi-permanent manner with the other data items that have been present within the data structure for a relatively long period of time.
- one part of the data structure may store data items that have been present within the data structure for a relatively long period of time, and another part of the data structure may store data items that have been newly added to the data structure and might be deleted relatively quickly.
- the call to the subroutine in statement 3524 to rebuild the data structure may be an operation that restructures the part of the data structure that contains the newly added data items.
- FIG. 35 illustrates the advantages of using autonomic execution-path selection based on hardware event counts that are gathered by a performance monitor in accordance with performance indicators that are associated with instructions and/or data areas.
- the selected characteristics might not be substantially related to the efficiency of the use of the data structure. If the chosen threshold is too small, then the data structure might be rebuilt too often, yet if the chosen threshold is too high, the data structure might not be rebuilt often enough. In other words, for this second case, if too many data items are added to the data structure before it is rebuilt or restructured, then the data structure might grow so large that the cache is not used efficiently, thereby incurring many cache misses when the data structure is used.
- a software developer can shift decisions from manual configuration of an application by an application's administrator to dynamic decisions that are made by the application itself.
- An application can use knowledge about itself to affect its behavior.
- the application can obtain real-time information about the performance of the software application within the low-level hardware, and the software application can dynamically change its behavior based on this real-time performance information.
- this real-time performance information can be gathered at a very fine granularity, e.g., within a single subroutine, over the span of a few source code statements, or simply based on hardware events that are detected during the execution of a single instruction.
- the gathering of this information does not necessarily require any intrusive instrumentation, particularly interrupts or jumps to instrumentation modules which would affect the real-time performance information that is being gathered.
- object code for statement 3504 would have been generated to include instructions, wherein those instructions (or the data areas that are accessed by those instructions) have been associated with performance indicators; the performance indicators may have been generated statically by a compiler, e.g., as described above with respect to FIG. 15 .
- a compiler e.g., as described above with respect to FIG. 15 .
- compiler directive 3530 instructs the compiler to generate code to configure the performance monitor to begin counting events from the relative point in the object code at which the compiler directive appears in the source code.
- the compiler would associate the appropriate performance indicators with the immediately following instructions, i.e., the next set of instructions that the compiler would generate, whichever instructions are appropriate for the particular circumstance.
- the execution of the instructions along with the processing of the performance indicators would configure the performance monitor to start counting events, which in this case includes hardware data cache miss events and hardware data cache hit events.
- Compiler directive 3530 is merely an example of a possible format for allowing a software developer to embed information into the source code of an application such that a compiler generates the appropriate object code that includes the performance indicators that are being requested by the software developer.
- compiler directive 3530 uses the same constant values 3508 and 3510 ; these can be resolved by the compiler to identify the types of events that the software developer is requesting to be counted.
- the compiler may generate inline assembly language statements in support of the processing of the compiler directives.
- the performance monitor would continue to count events until it was configured to do otherwise, e.g., by the processing of performance indicators that are associated with instructions that are executed at some later point in time that configure the performance monitor to stop counting those events.
- the performance indicators are able to configure the performance monitor to count events in a manner like a toggle switch, e.g., a single performance indicator is able to turn on the counting of events rather than requiring a performance indicator to be associated with each and every instruction to count an event associated with the execution of that instruction.
- the pseudocode statements do not include a subsequent compiler directive to stop the counting of cache misses and cache hits. However, after the events of interest have been counted and those count values have been used at statements 3516 and 3522 , there is no adverse impact in allowing the counting of the events to continue.
- FIG. 36 a diagram represents a set of pseudocode statements that autonomically alter the behavior of a software application through the use of performance indicators that are generated in accordance with compiler directives that are placed into the source code of the software application.
- FIG. 36 is similar to FIG. 35 ; statements 3602 , 3604 , 3606 , and 3608 are similar to statements 3504 , 3518 , 3524 , and 3528 , respectively, and compiler directive 3610 is similar to compiler directive 3530 .
- Compiler directive 3610 would cause the generation of appropriate performance indicators to be associated with subsequent instructions or data areas.
- Compiler directives 3614 and 3616 would cause the generation of appropriate instructions for obtaining and comparing event counts as necessary for the requested logic.
- FIG. 36 differs from FIG. 35 in that compiler directives 3612 , 3614 , and 3616 include some characteristics of source code logic.
- the source code statements explicitly recite the manner in which the performance monitor counter values should be retrieved and used; the manner in which the performance monitor is employed becomes embedded or hard-coded in the source code logic.
- the source code file indicates the hardware events that are of interest to the software application and the manner in which the software application needs to use the counts that are gathered for those hardware events.
- the compiler directives allow a software developer to indicate to the compiler which operations are desired by the software developer, and the compiler then has the responsibility for generating the appropriate object code for those desired operations.
- the compiler directives allow the source code file to contain additional information about the performance information gathering operations without embedding the logic for those operations within the source code statements. In this manner, the software developer is not required to know the details about the manner in which the performance information gathering operations are controlled.
- the compiler Since every compiler generates code that is directed to a specific class of CPU, the compiler would also be configured to generate the instructions for the performance information gathering operations that are appropriate for the intended class of CPU; the generation of this code may include accessing the appropriate software library or modules that provide an API to the performance monitor.
- compiler directives are necessary because the source code language does not include support for performance information gathering operations; compiler directives are external to the source code language, yet compiler directives assist a compiler in generating object code from source code statements.
- the source code language may be extended to provide support for performance information gathering operations, e.g., by including reserved words similar to other reserved words in the source code language.
- FIG. 36 illustrates that a software developer can direct the use of the performance indicators of the present invention to autonomically change the executional behavior of a software application.
- the event counts that result from the processing of the performance indicators are determined by the object code that has been executed over a period of time and the executional environment during that period of time.
- the object code of a software application is not solely determined by its source code.
- the behavior of a software application is also influenced by the manner in which a compiler processes the source code of the software application to generate the object code of a software application.
- a compiler generates object code that is intended to be executed on a specific class of CPU, notwithstanding the generation of bytecode by certain types of compilers, wherein the bytecode is intended to be interpreted within a standardized virtual machine such that the bytecode is eventually runnable on many different classes of CPUs.
- the compiler may have several choices for generating certain aspects of the object code; different compilers will generate different object code modules from an identical source code file because they make different choices in the manner in which certain aspects of the software are implemented. For example, a compiler can allocate data areas for different types of variables in different memory locations; the compiler can also determine whether those data areas should be allocated statically at compile-time or dynamically at runtime.
- the choice of memory locations and their relative arrangement will influence the performance of the instructions that access those data areas, e.g., creating fewer or more cache hits to the CPU's on-chip cache.
- groups of instructions are implicitly generated for certain types of source code logic, e.g., iterative loops, and the compiler has the ability to place groups of instructions in different areas through the use of branch instructions or jump instructions. Assuming that a particular CPU has an on-chip instruction cache, the compiler can influence the performance of groups of instructions based on their relative location; for example, two groups of instructions that are juxtaposed in memory and executed sequentially might generate zero instruction cache misses if both groups of instructions will easily fit into the instruction cache.
- a compiler generates object code for a particular class of CPUs
- the capabilities of a particular CPU may vary widely within a class of CPUs that adhere to a similar architecture.
- a particular CPU may have a larger on-chip data cache than a similar CPU that executes the same instruction set at the same processor clock speed.
- the compiler does generally not have any information about the capabilities or configuration of a particular CPU that will eventually execute the object code that is being generated by the compiler, so the compiler generates object code with certain characteristics that seem appropriate for any instance within that class of CPUs.
- a compiler can shift compile-time decisions to runtime decisions. Rather than statically determining certain characteristics of the object code when the object code is generated, which thereby also inherently determines the performance of the execution of the object code to some degree, certain characteristics of the object code can be determined when the object code is executed by allowing the application to use knowledge about itself to affect its behavior.
- the compiler configures the software application to obtain real-time information about the performance of the software application within the low-level hardware, and the compiler configures the software application to dynamically change its behavior based on this real-time performance information, which is illustrated with respect to FIGS. 37–41 hereinbelow.
- FIGS. 37–41 depict operations that may be performed primarily in accordance with direction from a compiler
- the examples in FIGS. 35–36 depict operations that may be performed primarily in accordance with direction from a software developer.
- a flowchart depicts a process within a compiler by which the compiler configures the software application to dynamically change its behavior based on real-time performance information through the use of multiple alternative versions of object code for subroutines.
- the process begins with the compiler starting to generate object code for a particular subroutine (step 3702 ). It may be assumed that the compiler has already retrieved and started processing a source code file, which may contain other subroutines.
- the compiler determines that it may generate the object code in different ways or forms, possible using different techniques (step 3704 ); e.g., as mentioned above, the compiler might determine that it has multiple options for selection locations of data objects, locations of groups of instructions, manners of branching or jumping between groups of instructions, etc. Rather than selecting one choice among each option that occurs, the compiler generates multiple alternative versions of object code for the subroutine (step 3706 ).
- a software developer may control the ability of the compiler to perform such operations through special compiler directives.
- the software developer might insert a compiler directive within the source code of a subroutine that explicitly allows the compiler to generate multiple alternative versions of object code for the subroutine.
- the software developer might insert a compiler directive within the source code of a subroutine that explicitly disallows the compiler from generating multiple alternative versions of object code for the subroutine.
- the software developer might be required to place a special compiler directive at the start of a source code file in order to explicitly permit the compiler to generate multiple alternative versions of object code for any subroutine within the source code file.
- the compiler manages the multiple alternative versions of object code for the subroutine by assigning different identifiers to the different versions of the subroutine (step 3708 ).
- the compiler can manage each version of the subroutine's object code as if the object code had originated from different subroutines.
- the compiler must adjust the remainder of the software application to account for the multiple versions; for each call to the subroutine within the software application, the compiler must ensure that a call is made to one of the multiple alternative versions of object code for the subroutine.
- the manner in which the compiler adjusts the original calls to the subroutine is linked to the differences that the compiler has introduced to the multiple alternative versions of object code for the subroutine.
- the compiler has generated multiple versions of object code for the subroutine because the compiler has determined that each version may have certain performance-enhancing characteristics; e.g., as noted above, the locations of instructions and data objects may reduce the number of instruction cache misses or data cache misses.
- the compiler replaces each call to the original subroutine with a call to one of the multiple alternative versions based upon a dynamically determined characteristic that is appropriate for the call that is being replaced or for the version of the subroutine that is to be selected to be called.
- the compiler replaces each call to the subroutine with a selective or condition call to one of the multiple alternative versions based on information gathered from performance indicators (step 3710 ).
- event counts would be gathered through the use of performance indicators just prior to a call to one of the multiple versions of object code for the subroutine; depending on those event counts, a determination is made as to which subroutine should be called, as illustrated in more detail further below.
- Application 3800 comprises many subroutines and main program segment 3802 .
- Subroutine 3804 is called by each of subroutines 3806 , 3808 , and 3810 .
- FIG. 39 a block diagram depicts an application with multiple subroutines that selectively call one of the multiple alternative versions of object code of a subroutine that have been generated by a compiler.
- FIG. 39 is similar to FIG. 38 ; application 3900 and application 3800 represent the same software program that originated from the same source code; application 3900 comprises main program segment 3902 and subroutines 3906 , 3908 , and 3910 in a manner similar to application 3800 comprising main program segment 3802 and subroutines 3806 , 3808 , and 3810 .
- applications 3800 and 3900 are derived from the same source code, they represent different instances of the same software program because they contain different object code after having been compiled differently.
- application 3900 contains two versions of object code for the same subroutine, shown as object code segments 3912 and 3914 in application 3900 , as would be generated by a compiler during step 3708 in FIG. 37 .
- each call to the given subroutine has been modified to include a selective or conditional call to one of the versions of the given subroutine, i.e., object code blocks 3912 or 3914 , as would be generated by a compiler during step 3710 in FIG. 37 ; these conditional calls are shown in application 3900 as calls 3926 , 3928 , and 3930 in object code segments 3906 , 3908 , and 3910 , respectively.
- the selection or condition is based upon information on hardware event counts that will be gathered in accordance with performance indicator processing that occurs during the execution of the application prior to the calls to the versions of the given subroutine, as illustrated in more detail below.
- FIG. 40 a block diagram depicts a representation of object code for a selective or conditional call of one of multiple alternative versions of object code for a given subroutine.
- FIG. 40 represents object code section 4002 that would be generated by a compiler during step 3710 in FIG. 37 in place of a typical subroutine call; when the compiler determines to generate multiple alternative versions of object code for a subroutine, then the compiler replaces each original call to that subroutine with object code section 4002 .
- FIG. 40 is similar to FIG. 34 in that both figures depict an execution path within software that is autonomically selected based on the detection of events, wherein the events have been enabled through performance indicators as described above. More specifically, both figures depict sequentially located object code blocks that contain instructions: for counting events in accordance with performance indicators; for obtaining the values of those counts from registers within a performance monitor; for computing a condition based on those values; and selecting an execution path based on a satisfied condition. Whereas FIG. 34 illustrated a generalized execution path, FIG. 40 specifically illustrates a call to one of multiple alternative versions of object code for a subroutine.
- the first object code subsection 4004 within object code section 4002 contains instructions that are associated with performance indicators and/or instructions that access data associated with performance indicators; these performance indicators configure the performance monitor to begin counting hardware events associated with the execution of those instructions.
- the second object code subsection 4006 within object code section 4002 contains instructions that obtain or read the performance monitor counters that have been counting the hardware events.
- the third object code subsection 4008 within object code section 4002 contains instructions that compute conditional expressions based on the values from the performance monitor counters.
- the fourth object code subsection 4010 within object code section 4002 contains instructions for calling or jumping to an appropriate version of the given subroutine based on the computed conditional expressions.
- a diagram represents an example of a set of pseudocode statements that may be used by a compiler to generate the appropriate autonomic alteration in the behavior of a software application for selecting one of multiple alternative versions of object code for a subroutine.
- a compiler may directly generate the object code that is necessary for the selective or conditional calling of the different versions.
- a compiler may generate source code statements or inline assembly language statements for the functionality that the compiler uses to replace each call to the original subroutine, e.g., as shown by object code subsections 3926 – 3930 as shown in FIG.
- the set of pseudocode statements that are shown in FIG. 41 may represent source code statements or inline assembly language statements that could be generated by the compiler to be inserted into the source code of a subroutine that calls the given subroutine; alternatively, the set of pseudocode statements that are shown in FIG. 41 may merely represent the logic of the object code subsections that are eventually generated.
- Compiler directive 4102 causes performance indicators to be associated with data accesses to a particular array, which may be implemented using marked data in a variety of manners as previously described above.
- compiler directive 4102 indicates that particular hardware events, i.e., data cache misses, are to be counted when accessing the identified array, e.g., each time an instruction accesses a memory location in a range of memory addresses that is reserved for the array.
- Statement 4104 reads the last element from the identified array, thereby potentially causing a cache miss event to occur.
- the compiler has generated object code that contains a simple test to check whether accessing an element of the array generates a cache miss event.
- the compiler replaces each call to the original subroutine with a call to one of the multiple alternative versions based upon a dynamically determined characteristic that is appropriate for the call that is being replaced or for the version of the subroutine that is to be selected during runtime to be called.
- the compiler may have determined that it could compile the original subroutine in two ways which would differ in the use of the identified array. Hence, it has placed a test, i.e., related to statement 4104 , in the object code such that it can dynamically determine at runtime whether the use of the array will have exhibit certain characteristics.
- Statements 4106 and 4108 represent a check of the counter in the performance monitor to determine if the execution of instructions for statement 4104 generated a data cache miss event; if so, then instructions for statement 4110 would be executed, otherwise instructions for statement 4112 would be executed. Based on the observation, the software application can then autonomically alter its behavior by calling one or the other version of the object code for the subroutine that accesses that array; statements 4110 and 4112 represent calls to one or the other version, which may be implemented as jump instructions to the respective location of the object code for one of those versions.
- FIGS. 42–46 a set of figures illustrate processes for collecting statistical information about the ability of a software application to successfully acquire a mutex, or more generally, a semaphore.
- An operating system allocates time slices to threads in accordance with their needs and their competition for shared resources, and an operating system typically provides multiple mechanisms for coordinating the use of shared resources by multiple threads.
- a common mechanism for serializing access to a shared resource is a mutex, or mutual exclusion lock, which is a simple lock having two states: locked and unlocked.
- the lock is typically implemented as a simple data value that is stored in memory.
- a mutex can be logically associated with a shared resource such that a thread that successfully locks the mutex is said to be the current owner of the mutex; only the thread that possesses a particular mutex should proceed to access the shared resource that is associated with that particular mutex, and only the thread that possesses a particular mutex should unlock that particular mutex.
- a critical section of code within a thread that accesses a shared resource is bounded by a call to lock a mutex and a call to unlock the same mutex. If a thread attempts to lock a mutex and fails, then it must wait until it is able to lock the mutex before proceeding to execute its critical section of code in which it accesses the shared resource.
- a mutex can be used to synchronize threads within a single process or across multiple processes if the mutex is allocated within memory that is shared by the coordinating processes.
- a thread waits for a mutex after failing to acquire the mutex depends on the manner in which the mutex mechanism is implemented. Three types of locks are encountered: a blocking lock, a spin lock, and some type of combination of a blocking lock and a spin lock. If a mutex has already been acquired and another thread requests to lock the mutex, then a mutex that is implemented as a blocking lock causes the waiting thread to cease being executable or to be suspended, i.e., to go to “sleep”. In contrast, spin locks do not put waiting threads to sleep.
- a waiting thread executes a loop, thereby repeatedly requesting the lock until it is freed by the thread that currently owns the mutex; the loop may contain an empty, iterative loop, i.e., “busy loop” or “busy wait”, that increments or decrements a variable such that the thread does not immediately re-request the mutex but waits for a period of time that depends on the length of the iterative loop.
- the loop may contain an empty, iterative loop, i.e., “busy loop” or “busy wait”, that increments or decrements a variable such that the thread does not immediately re-request the mutex but waits for a period of time that depends on the length of the iterative loop.
- a semaphore is another locking mechanism for restricting access to shared resources, but in contrast to a mutex, a typical semaphore allows one or more threads to access a shared resource simultaneously. Even though a first thread may already be accessing a shared resource, additional threads are allowed to access the shared resource, up to a maximum number.
- a semaphore acts as a specialized counter, whereas a mutex acts as a toggle switch.
- a semaphore can be regarded as a more generalized locking mechanism, and a mutex is sometimes described as a mutex semaphore or a binary semaphore; hereinbelow, the present invention is operable with generalized semaphores, so it is assumed that a semaphore may act as a mutex.
- a typical implementation of a spin lock mutex begins when a thread requests to lock a mutex in an attempt to acquire or to possess the mutex (step 4202 ).
- a determination is made as to whether the mutex is free and unlocked (step 4204 ), and if not, then the thread performs a busy-wait loop (step 4206 ), i.e., spins, as it waits for the mutex to become available. After spinning for some period of time, the thread then repeats step 4202 .
- the mutex is locked (step 4208 ), and the thread may proceed to access a shared resource (step 4210 ) without the possibility of colliding with another thread and compromising the integrity of the data that is associated with the shared resource.
- the thread requests that the mutex should be released, and the mutex is unlocked (step 4212 ), thereby concluding the process.
- the mutex can be used by other threads.
- a set of pseudocode instructions represents typical logic for acquiring a semaphore.
- a thread or a process is attempting to acquire a semaphore, it is essential to protect the integrity of the operation that might modify the semaphore; preferably, this operation is completed as an atomic operation, i.e., an operation that cannot be interrupted in any manner.
- atomic operation i.e., an operation that cannot be interrupted in any manner.
- processors provide a pair of instructions that enable the implementation of a semaphore, there are many processors that are commercially available that provide a single instruction that can be used to support an atomic operation on a semaphore.
- CMPXCHG the “CMPXCHG” instruction in the IntelTM PentiumTM family of processors can be used to implement a semaphore.
- the pseudocode instructions that are shown in FIG. 43 approximate the logic that would be used with a “CMPXCHG” instruction.
- instructions 4300 – 4312 are shown at relative memory locations, although the length of the instructions may vary.
- Instruction 4300 copies the value of the semaphore from a memory address to the accumulator within the CPU; the memory address is provided by a variable name that can be resolved by a compiler or an assembler to a memory address.
- Instruction 4302 copies the value from the accumulator to a register, and instruction 4304 increments the value in the register.
- Instruction 4306 is a type of compare-and-exchange instruction that requires a source operand and a destination operand. This instruction executes as follows. If the value in the accumulator equals the value at the identified memory address, then the value in the register (source operand) is copied to the identified memory address (destination operand), and the “zero” processor status flag is set; the memory address is again provided by a variable name that represents the semaphore.
- the value in the accumulator does not equal the value at the identified memory address, then the value at the identified memory address is loaded into the accumulator, and the “zero” processor status flag is cleared; this case may occur if another thread has modified the semaphore between the execution of instruction 4300 and the execution of instruction 4306 , e.g., the thread with instructions 4300 – 4306 was swapped out at some point in time, which allowed another thread to execute and change the value of the semaphore.
- Instruction 4308 jumps to the identified address if the “zero” processor status flag is set, i.e., the program counter is changed to the identified address so that the next instruction is retrieved from that address.
- Instruction 4310 jumps to the identified address if the “zero” processor status flag is cleared, i.e., not set. If the thread has successfully acquired the semaphore, then instruction 4312 is executed, which represents the beginning of an execution path during which the thread will access a shared, restricted resource. Hence, instruction 4312 represents an instruction that is executed if the semaphore is successfully acquired, and instruction 4310 represents an instruction that is executed if the thread fails to acquire the semaphore.
- Instruction 4314 copies the value of the semaphore from the accumulator to a register, and instruction 4316 subtracts a constant value from the register; the constant value is identified by a name that can be resolved by a compiler or an assembler to a pre-determined value.
- Instruction 4318 jumps to the identified address if the “zero” processor status flag is set, which in this case indicates that the semaphore has reached is maximum value. The thread remains in a tight initial loop until the value of the semaphore is no longer at its maximum.
- a flowchart depicts a process for associating performance indicators with semaphores in accordance with an embodiment of the present invention.
- the process commences with a scanning daemon examining the application object code for instructions that are used for acquiring semaphores (step 4402 ); depending upon the application code that is being examined, the scanning daemon may be configurable to scan for different types of instructions.
- the scanning daemon then associates performance indicators with instructions that are related to acquiring the semaphores but at three different points for three different purposes: instructions that reserve or modify a semaphore (step 4404 ); instructions that are executed if a semaphore is acquired (step 4406 ); and instructions that are executed if a semaphore is not acquired (step 4408 ), thereby concluding the process.
- instructions that reserve or modify a semaphore step 4404
- instructions that are executed if a semaphore is acquired step 4406
- instructions that are executed if a semaphore is not acquired step 4408
- FIG. 45 a flowchart depicts a process during which performance indicators are used to gather statistical information about the use of semaphores in accordance with an embodiment of the present invention.
- counts are gathered for the number of attempts to acquire a semaphore, the number of successful reservations on the semaphore, and the number of failed reservations on the semaphore (step 4502 ).
- those counts are then available at the software level, e.g., to the application itself, to the scanning daemon, to a trace utility, to an application profiling tool, or to some other type of software application or module.
- the application can perform certain operations based on conditions that might be satisfied against the observed counts (step 4504 ), thereby concluding the process shown in FIG. 45 .
- FIG. 46 a set of performance indicators is associated with a set of pseudocode instructions that represents logic for acquiring a semaphore.
- FIG. 46 is similar to FIG. 45 ;
- FIG. 46 includes a set of instructions that are used to acquire a semaphore.
- instruction 4602 attempts to reserve or modify the data value that represents the semaphore;
- instruction 4604 is executed if the semaphore is not acquired; and instruction 4606 is executed if the semaphore is acquired.
- FIG. 46 shows that scanning daemon 4610 has associated performance indicators 4612 – 4616 with instructions 4602 – 4606 , respectively.
- instructions 4602 – 4606 that are involved in the semaphore operation are executed, e.g., by CPU execution unit 4620 , the processing of performance indicators 4612 – 4616 generates events that are counted by performance monitor 4624 .
- performance indicator 4612 is associated with instruction 4602 , thereby allowing a count of each attempt to reserve or modify the semaphore.
- Performance indicator 4614 is associated with instruction 4604 , thereby allowing a count of each failed attempt to acquire the semaphore.
- performance indicator 4616 is associated with instruction 4606 , thereby allowing a count of each successful attempt to acquire the semaphore.
- count values 4632 , 4634 , and 4636 can be obtained from performance monitor 4624 to represent the number of attempts to acquire the semaphore, the number of failed attempts, and the number of successful attempts, respectively. It is possible for an application to count the number of attempts, successes, and failures, but if a software entity other than the application wanted these counts, an interface would be required to request and transfer the counts. With the present invention, the counts may be gathered through the use of the performance indicators. These count values represent statistical information about the performance of the operations on the semaphore, and these count values may be used by various software entities, particularly for improving the performance of operations associated with the semaphore.
- Reports on semaphore utilization may be used by an analyst to change the algorithms related to the semaphores; for example, multiple semaphores might be deployed in place of a single semaphore to protect different portions of data in order to reduce contention.
- the statistical information can be gathered in an efficient, non-intrusive manner such that the application does not need to explicitly generate these counts.
- FIGS. 47–49 a set of figures illustrate a technique for improving the performance of the execution of an application by relocating code segments and data areas based on information that is gathered about hot spots through the use of performance indicators.
- the performance of an application is affected by the spatial locality that is exhibited by the application during its execution.
- aggregating hot spots improves the performance of an application by reducing the number of instruction cache misses, data cache misses, translation lookaside buffer (TLB) misses, etc.
- the memory manager may improve the spatial locality of an application during a runtime phase by collecting performance information during runtime, analyzing the information during runtime, and modifying the application's memory space during runtime, thereby dynamically providing enhanced performance.
- a flowchart depicts a process by which a memory manager determines hot spots using performance indicators in accordance with an embodiment of the present invention.
- the process commences with the memory manager selecting an application that is to be monitored in order to gather performance information about its execution (step 4702 ).
- the memory manager determines code segments and/or data areas to be monitored within the application (step 4704 ) by examining various memory management data structures that contain information about the manner in which memory has been allocated to the application, information about the manner in which the application has been loaded into memory, and various other memory-related aspects of the application.
- the memory manager then generates and sends a performance monitoring request to a performance scanning daemon that is similar to that described in FIG. 25 (step 4706 ).
- the performance monitoring request may be transferred in a variety of ways that does not limit the scope of the present invention, e.g., a subroutine call or the transmittal of a message.
- the performance monitoring request contains addresses and/or address ranges that the memory manager wants to monitor over a specified period of time; these locations were determined by the memory manager in step 4704 .
- the request may also contain addition information for each location that is to be monitored, e.g., the type of instruction or data that is stored at a particular location, thereby providing information about the type of performance indicator that should be associated with that particular location.
- the memory manager receives a performance monitoring response from the scanning daemon (step 4708 ).
- the performance monitoring response may be transferred in a variety of ways that is appropriate for the interface between the memory manager and the scanning daemon. If the performance monitoring request was made by a subroutine call, then the memory manager may have registered, during the initial call, a callback subroutine that the scanning daemon may call to return the performance monitoring response. If the performance monitoring request was passed as a message, then the performance monitoring response may be passed as a message. It may be assumed that the request and the response are transmitted in an asynchronous manner such that the memory manager may perform other operations while waiting for the performance monitoring response.
- the memory manager After receiving the performance monitoring response, the memory manager examines the information within the response to determine hot spots within the monitored application (step 4710 ). While the performance monitoring request was being processed by the scanning daemon, the scanning daemon was collecting events counts for data accesses, instruction accesses, instruction executions, or other types of events as requested by the memory manager. In addition, these events have been counted over a particular period of time, so the information that is generated and returned to the memory manager reflect events per period of time, or event rates. By comparing event rates to other concurrent event rates, historical event rates, configurable threshold values, configurable conditional rules, etc., the memory manager is able to determine which code segments and data areas within an application are hot or cold, i.e., executed or accessed frequently or infrequently. After determining the hot spots, the memory manager conglomerates the hot code blocks and hot data areas (step 4712 ), thereby concluding the process. The memory manager may repeat this process for other applications or for the same application after a period of time.
- FIG. 48 a flowchart depicts a process by which a scanning daemon assists in the determination of hot spots within an application by placing performance indicators at particular locations as requested by a memory manager.
- the flowchart that is shown in FIG. 48 is a counterpart process to the process that is shown in the flowchart in FIG. 47 .
- the process commences when the scanning daemon receives a performance monitoring request from a memory manager (step 4802 ). Using the memory locations of object code blocks and data areas as indicated in the performance monitoring request, the scanning daemon associates performance indicators with those memory locations as requested (step 4804 ); the performance indicators may be stored in memory, shadow memory, cache, etc., as is appropriate for the hardware architecture that supports the present invention. In addition, as requested by the memory manager, the scanning daemon limits the amount of time during which the performance indicators allow for the counting of events, e.g., by setting software timers for a requested period of time (step 4806 ).
- the scanning daemon retrieves the counts that have been gathered for the events that were generated in accordance with the performance indicators (step 4808 ); for example, the scanning daemon reads the counts from registers within a performance monitor in the CPU. It may be assumed that the scanning daemon set the timers in an asynchronous manner such that the scanning daemon is able to perform other operations during that time period. In addition, the scanning daemon is able to handle multiple concurrent requests; the requests may initiate the monitoring of different locations within an application space or the monitoring of different application memory spaces. Alternatively, the scanning daemon may determine the length of the time period and then return that value to the requester as part of the response. The scanning daemon then returns the counts that have been gathered in a performance monitoring response to the memory manager (step 4810 ), and the process is concluded.
- Memory manager 4902 performs memory management operations as part of the operating system of a data processing system.
- Memory manager 4902 may have access to various operating system data structures, and memory manager may interact with other operating system entities, such as a process scheduler or thread dispatcher (not shown), to perform operations for multiple applications that are concurrently running under the management of the operating system.
- memory manager 4902 comprises multiple entities as a convenience for illustrating various functional units that may be present within a data processing system; memory manager may include fewer or more functional units, depending on the operating system, or the functionality may be organized in some other manner.
- Dynamic loader 4904 loads application modules into memory.
- Memory allocator 4906 allocates memory to an application upon request.
- Garbage collector 4908 gathers memory blocks that were previously allocated to an application but that are no longer being used.
- memory relocator 4910 moves object code blocks and data blocks in order to improve the performance of the application in a manner similar to that described above with respect to FIG. 47 .
- memory relocator 4910 determines that the performance of an application might be improved by changing the memory configuration of the application
- memory relocator 4910 sends performance indicator request 4912 to scanning daemon 4914 .
- the performance indicator request contains locations of code blocks and/or data areas that memory relocator 4910 has determined may be moved if they are deemed to be hot code blocks that are executed often or hot data areas that are accessed often.
- scanning daemon 4914 uses those locations within application memory space 4920 to create tagged or marked locations or blocks 4922 , 4924 , and 4926 by associating performance indicators with those location or blocks in some manner as described further above.
- scanning daemon 4914 gathers the counts that represent the number of hardware events that occurred in accordance with the processing of the performance indicators that indicate the hardware events that should be counted. These counts, possibly along with other information, are placed into performance monitoring response 4930 by scanning daemon 4914 and returned to memory relocator 4910 .
- Memory relocator 4910 analyzes the execution rates or access rates of the previously chosen memory locations or memory areas to determine if any of the code blocks or data areas should be moved in an attempt to improve the performance of the application.
- FIG. 49 shows application memory space 4920 after a memory relocation operation.
- memory locations or memory areas 4922 – 4926 have been determined to be hot code blocks that are executed often or hot data areas that are accessed often; hence, these locations or areas have been aggregated, i.e., moved closer together, using various possible techniques, as mentioned above.
- the code blocks or data areas should moved as a whole.
- the code blocks and data areas might be split, thereby allowing the conglomeration of hot areas and the conglomeration of cold areas.
- the memory relocation operation may act in accordance with many different configurable conditions and rule sets. For example, it is possible that the memory relocator determines that many code blocks appear to execute with the same relative frequency with a few code blocks that are rarely executed; in that case, the memory relocation operation may be performed in order to move those relatively cold blocks away from the other code blocks rather than attempting to aggregate hot blocks.
- the present invention provides an improved method, apparatus, and computer instructions for providing assistance in monitoring execution of programs.
- the mechanism of the present invention includes employing an indicator that is recognized by the processor to enable counting events that are associated with the execution of an instruction or events that are associated with accessing a particular memory location.
- Various types of counting as described above are enabled through this mechanism.
- the mechanism of the present invention also provides for various types of adjustments to programs in monitoring and analyzing performance of programs. Further, as described above, programs may be automatically adjusted to allow for monitoring of selected instructions and even routines and modules without having to modify the program.
- a new instruction or operation code may be used to indicate that a subsequent instruction, or a subsequent set of instructions are marked instructions.
- the architecture of a processor may be changed to include additional bits if spare fields for performance indicators are unavailable in the case in which it is desirable to include performance indicators within fields in the instructions.
Abstract
Description
Claims (18)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/682,436 US7225309B2 (en) | 2003-10-09 | 2003-10-09 | Method and system for autonomic performance improvements in an application via memory relocation |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/682,436 US7225309B2 (en) | 2003-10-09 | 2003-10-09 | Method and system for autonomic performance improvements in an application via memory relocation |
Publications (2)
Publication Number | Publication Date |
---|---|
US20050081010A1 US20050081010A1 (en) | 2005-04-14 |
US7225309B2 true US7225309B2 (en) | 2007-05-29 |
Family
ID=34422526
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/682,436 Expired - Fee Related US7225309B2 (en) | 2003-10-09 | 2003-10-09 | Method and system for autonomic performance improvements in an application via memory relocation |
Country Status (1)
Country | Link |
---|---|
US (1) | US7225309B2 (en) |
Cited By (18)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20060005083A1 (en) * | 2004-06-30 | 2006-01-05 | International Business Machines Corporation | Performance count tracing |
US20060136867A1 (en) * | 2004-12-17 | 2006-06-22 | Manfred Schneider | Code diversification |
US20070226722A1 (en) * | 2006-03-24 | 2007-09-27 | Chou Yuan C | Method and apparatus for selectively executing different executable code versions which are optimized in different ways |
US20070261033A1 (en) * | 2006-05-05 | 2007-11-08 | Chen Wen-Tzer T | Method and apparatus for selectively marking and executing instrumentation code |
US20080148226A1 (en) * | 2006-12-13 | 2008-06-19 | Institute For Information Industry | Apparatus, method, and computer readable medium thereof for generating and utilizing a feature code to monitor a program |
US20090292793A1 (en) * | 2008-05-21 | 2009-11-26 | Motorola, Inc. | Autonomous operation of networking devices |
US20100235836A1 (en) * | 2007-10-29 | 2010-09-16 | Stanislav Viktorovich Bratanov | method of external performance monitoring for virtualized environments |
US8381037B2 (en) | 2003-10-09 | 2013-02-19 | International Business Machines Corporation | Method and system for autonomic execution path selection in an application |
US20130297258A1 (en) * | 2012-05-01 | 2013-11-07 | International Business Machines Corporation | Smart Multiplexing of Performance Counters for Performance Measurement |
US8615619B2 (en) | 2004-01-14 | 2013-12-24 | International Business Machines Corporation | Qualifying collection of performance monitoring events by types of interrupt when interrupt occurs |
US20140026111A1 (en) * | 2011-04-11 | 2014-01-23 | Gregory Michael Stitt | Elastic computing |
US8689190B2 (en) | 2003-09-30 | 2014-04-01 | International Business Machines Corporation | Counting instruction execution and data accesses |
US20140149710A1 (en) * | 2012-11-29 | 2014-05-29 | Advanced Micro Devices, Inc. | Creating simd efficient code by transferring register state through common memory |
US8782664B2 (en) | 2004-01-14 | 2014-07-15 | International Business Machines Corporation | Autonomic hardware assist for patching code |
US9015413B2 (en) | 2012-10-02 | 2015-04-21 | International Business Machines Corporation | Management of data using inheritable attributes |
US9471458B2 (en) | 2012-01-05 | 2016-10-18 | International Business Machines Corporation | Synchronization activity recording system for a concurrent software environment |
US9600348B2 (en) | 2011-01-10 | 2017-03-21 | International Business Machines Corporation | Recording activity of software threads in a concurrent software environment |
US9817586B2 (en) | 2016-02-23 | 2017-11-14 | Samsung Electronics Co., Ltd. | Method of application aware IO completion mode changer for key value device |
Families Citing this family (17)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US7304905B2 (en) | 2004-05-24 | 2007-12-04 | Intel Corporation | Throttling memory in response to an internal temperature of a memory device |
US7523285B2 (en) * | 2004-08-20 | 2009-04-21 | Intel Corporation | Thermal memory control |
US8010969B2 (en) | 2005-06-13 | 2011-08-30 | Intel Corporation | Mechanism for monitoring instruction set based thread execution on a plurality of instruction sequencers |
US20070016893A1 (en) * | 2005-07-14 | 2007-01-18 | International Business Machines Corporation | Tracking resource usage by applications |
US7827541B2 (en) * | 2006-03-16 | 2010-11-02 | International Business Machines Corporation | Method and apparatus for profiling execution of code using multiple processors |
US7814466B2 (en) * | 2006-05-05 | 2010-10-12 | International Business Machines Corporation | Method and apparatus for graphically marking instructions for instrumentation with hardware assistance |
US8302082B2 (en) * | 2006-06-07 | 2012-10-30 | Intel Corporation | Methods and apparatus to provide a managed runtime environment in a sequestered partition |
US7461383B2 (en) * | 2006-08-21 | 2008-12-02 | International Business Machines Corporation | Method and apparatus for efficient performance monitoring of a large number of simultaneous events |
US7644204B2 (en) * | 2006-10-31 | 2010-01-05 | Hewlett-Packard Development Company, L.P. | SCSI I/O coordinator |
US20080126747A1 (en) * | 2006-11-28 | 2008-05-29 | Griffen Jeffrey L | Methods and apparatus to implement high-performance computing |
US9110791B2 (en) * | 2008-03-03 | 2015-08-18 | Microsoft Technology Licensing, Llc | Optimistic object relocation |
US8935500B1 (en) * | 2009-09-24 | 2015-01-13 | Vmware, Inc. | Distributed storage resource scheduler and load balancer |
US8914598B2 (en) * | 2009-09-24 | 2014-12-16 | Vmware, Inc. | Distributed storage resource scheduler and load balancer |
US9686152B2 (en) * | 2012-01-27 | 2017-06-20 | Microsoft Technology Licensing, Llc | Techniques for tracking resource usage statistics per transaction across multiple layers of protocols |
US10110688B2 (en) * | 2015-03-20 | 2018-10-23 | Sony Interactive Entertainment LLC | System and method for remote monitoring of API performance and user behavior associated with user interface |
US10067672B2 (en) * | 2015-08-31 | 2018-09-04 | International Business Machines Corporation | Memory activity driven adaptive performance measurement |
CN108376070A (en) | 2016-10-28 | 2018-08-07 | 华为技术有限公司 | A kind of method, apparatus and computer of compiling source code object |
Citations (38)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4291371A (en) | 1979-01-02 | 1981-09-22 | Honeywell Information Systems Inc. | I/O Request interrupt mechanism |
US5103394A (en) | 1984-04-30 | 1992-04-07 | Hewlett-Packard Company | Software performance analyzer |
US5212794A (en) | 1990-06-01 | 1993-05-18 | Hewlett-Packard Company | Method for optimizing computer code to provide more efficient execution on computers having cache memories |
US5689712A (en) | 1994-07-27 | 1997-11-18 | International Business Machines Corporation | Profile-based optimizing postprocessors for data references |
US5691920A (en) | 1995-10-02 | 1997-11-25 | International Business Machines Corporation | Method and system for performance monitoring of dispatch unit efficiency in a processing system |
US5774724A (en) | 1995-11-20 | 1998-06-30 | International Business Machines Coporation | System and method for acquiring high granularity performance data in a computer system |
US5930508A (en) | 1996-12-16 | 1999-07-27 | Hewlett-Packard Company | Method for storing and decoding instructions for a microprocessor having a plurality of function units |
US5937437A (en) | 1996-10-28 | 1999-08-10 | International Business Machines Corporation | Method and apparatus for monitoring address translation performance |
US5938778A (en) | 1997-11-10 | 1999-08-17 | International Business Machines Corporation | System and method for tracing instructions in an information handling system without changing the system source code |
US5966537A (en) | 1997-05-28 | 1999-10-12 | Sun Microsystems, Inc. | Method and apparatus for dynamically optimizing an executable computer program using input data |
US5987250A (en) | 1997-08-21 | 1999-11-16 | Hewlett-Packard Company | Transparent instrumentation for computer program behavior analysis |
JP2000029731A (en) | 1998-06-05 | 2000-01-28 | Texas Instr Inc <Ti> | Double-mode vliw architecture for imparting software control variable mix of instruction level and task level parallel processing |
US6070009A (en) | 1997-11-26 | 2000-05-30 | Digital Equipment Corporation | Method for estimating execution rates of program execution paths |
US6101524A (en) | 1997-10-23 | 2000-08-08 | International Business Machines Corporation | Deterministic replay of multithreaded applications |
US6134676A (en) | 1998-04-30 | 2000-10-17 | International Business Machines Corporation | Programmable hardware event monitoring method |
JP2000347863A (en) | 1999-05-13 | 2000-12-15 | Internatl Business Mach Corp <Ibm> | Method and system for counting non-speculative event inside speculative processor |
US6189141B1 (en) | 1998-05-04 | 2001-02-13 | Hewlett-Packard Company | Control path evaluating trace designator with dynamically adjustable thresholds for activation of tracing for high (hot) activity and low (cold) activity of flow control |
US6192513B1 (en) | 1998-11-02 | 2001-02-20 | Hewlett-Packard Company | Mechanism for finding spare registers in binary code |
US6206584B1 (en) | 1991-06-21 | 2001-03-27 | Rational Software Corporation | Method and apparatus for modifying relocatable object code files and monitoring programs |
US6223338B1 (en) | 1998-09-30 | 2001-04-24 | International Business Machines Corporation | Method and system for software instruction level tracing in a data processing system |
US6243804B1 (en) | 1998-07-22 | 2001-06-05 | Scenix Semiconductor, Inc. | Single cycle transition pipeline processing using shadow registers |
US6256775B1 (en) | 1997-12-11 | 2001-07-03 | International Business Machines Corporation | Facilities for detailed software performance analysis in a multithreaded processor |
US6286132B1 (en) | 1998-01-07 | 2001-09-04 | Matsushita Electric Industrial Co., Ltd. | Debugging support apparatus, a parallel execution information generation device, a computer-readable recording medium storing a debugging support program, and a computer-readable recording medium storing a parallel execution information generation program |
US20010032305A1 (en) | 2000-02-24 | 2001-10-18 | Barry Edwin F. | Methods and apparatus for dual-use coprocessing/debug interface |
US6324689B1 (en) | 1998-09-30 | 2001-11-27 | Compaq Computer Corporation | Mechanism for re-writing an executable having mixed code and data |
US6330662B1 (en) | 1999-02-23 | 2001-12-11 | Sun Microsystems, Inc. | Apparatus including a fetch unit to include branch history information to increase performance of multi-cylce pipelined branch prediction structures |
US20020019976A1 (en) | 1998-12-08 | 2002-02-14 | Patel Mukesh K. | Java hardware accelerator using thread manager |
US6351844B1 (en) | 1998-11-05 | 2002-02-26 | Hewlett-Packard Company | Method for selecting active code traces for translation in a caching dynamic translator |
US6374364B1 (en) | 1998-01-20 | 2002-04-16 | Honeywell International, Inc. | Fault tolerant computing system using instruction counting |
US6430741B1 (en) | 1999-02-26 | 2002-08-06 | Hewlett-Packard Company | System and method for data coverage analysis of a computer program |
US6442585B1 (en) | 1997-11-26 | 2002-08-27 | Compaq Computer Corporation | Method for scheduling contexts based on statistics of memory system interactions in a computer system |
US6446029B1 (en) | 1999-06-30 | 2002-09-03 | International Business Machines Corporation | Method and system for providing temporal threshold support during performance monitoring of a pipelined processor |
US20020124237A1 (en) | 2000-12-29 | 2002-09-05 | Brinkley Sprunt | Qualification of event detection by thread ID and thread privilege level |
US20020129309A1 (en) | 2000-12-18 | 2002-09-12 | Floyd Michael S. | Method and system for triggering a debugging unit |
US20020147965A1 (en) | 2001-02-01 | 2002-10-10 | Swaine Andrew Brookfield | Tracing out-of-order data |
US6480938B2 (en) | 2000-12-15 | 2002-11-12 | Hewlett-Packard Company | Efficient I-cache structure to support instructions crossing line boundaries |
US20020199179A1 (en) | 2001-06-21 | 2002-12-26 | Lavery Daniel M. | Method and apparatus for compiler-generated triggering of auxiliary codes |
US6574727B1 (en) | 1999-11-04 | 2003-06-03 | International Business Machines Corporation | Method and apparatus for instruction sampling for performance monitoring and debug |
Family Cites Families (3)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6330552B1 (en) * | 1998-09-28 | 2001-12-11 | Compaq | Database query cost model optimizer |
US6434676B1 (en) * | 1999-12-21 | 2002-08-13 | Intel Corporation | FIFO with random re-read support and its application |
JP2001234986A (en) * | 2000-02-24 | 2001-08-31 | Borg Warner Automotive Kk | Silent chain |
-
2003
- 2003-10-09 US US10/682,436 patent/US7225309B2/en not_active Expired - Fee Related
Patent Citations (38)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US4291371A (en) | 1979-01-02 | 1981-09-22 | Honeywell Information Systems Inc. | I/O Request interrupt mechanism |
US5103394A (en) | 1984-04-30 | 1992-04-07 | Hewlett-Packard Company | Software performance analyzer |
US5212794A (en) | 1990-06-01 | 1993-05-18 | Hewlett-Packard Company | Method for optimizing computer code to provide more efficient execution on computers having cache memories |
US6206584B1 (en) | 1991-06-21 | 2001-03-27 | Rational Software Corporation | Method and apparatus for modifying relocatable object code files and monitoring programs |
US5689712A (en) | 1994-07-27 | 1997-11-18 | International Business Machines Corporation | Profile-based optimizing postprocessors for data references |
US5691920A (en) | 1995-10-02 | 1997-11-25 | International Business Machines Corporation | Method and system for performance monitoring of dispatch unit efficiency in a processing system |
US5774724A (en) | 1995-11-20 | 1998-06-30 | International Business Machines Coporation | System and method for acquiring high granularity performance data in a computer system |
US5937437A (en) | 1996-10-28 | 1999-08-10 | International Business Machines Corporation | Method and apparatus for monitoring address translation performance |
US5930508A (en) | 1996-12-16 | 1999-07-27 | Hewlett-Packard Company | Method for storing and decoding instructions for a microprocessor having a plurality of function units |
US5966537A (en) | 1997-05-28 | 1999-10-12 | Sun Microsystems, Inc. | Method and apparatus for dynamically optimizing an executable computer program using input data |
US5987250A (en) | 1997-08-21 | 1999-11-16 | Hewlett-Packard Company | Transparent instrumentation for computer program behavior analysis |
US6101524A (en) | 1997-10-23 | 2000-08-08 | International Business Machines Corporation | Deterministic replay of multithreaded applications |
US5938778A (en) | 1997-11-10 | 1999-08-17 | International Business Machines Corporation | System and method for tracing instructions in an information handling system without changing the system source code |
US6070009A (en) | 1997-11-26 | 2000-05-30 | Digital Equipment Corporation | Method for estimating execution rates of program execution paths |
US6442585B1 (en) | 1997-11-26 | 2002-08-27 | Compaq Computer Corporation | Method for scheduling contexts based on statistics of memory system interactions in a computer system |
US6256775B1 (en) | 1997-12-11 | 2001-07-03 | International Business Machines Corporation | Facilities for detailed software performance analysis in a multithreaded processor |
US6286132B1 (en) | 1998-01-07 | 2001-09-04 | Matsushita Electric Industrial Co., Ltd. | Debugging support apparatus, a parallel execution information generation device, a computer-readable recording medium storing a debugging support program, and a computer-readable recording medium storing a parallel execution information generation program |
US6374364B1 (en) | 1998-01-20 | 2002-04-16 | Honeywell International, Inc. | Fault tolerant computing system using instruction counting |
US6134676A (en) | 1998-04-30 | 2000-10-17 | International Business Machines Corporation | Programmable hardware event monitoring method |
US6189141B1 (en) | 1998-05-04 | 2001-02-13 | Hewlett-Packard Company | Control path evaluating trace designator with dynamically adjustable thresholds for activation of tracing for high (hot) activity and low (cold) activity of flow control |
JP2000029731A (en) | 1998-06-05 | 2000-01-28 | Texas Instr Inc <Ti> | Double-mode vliw architecture for imparting software control variable mix of instruction level and task level parallel processing |
US6243804B1 (en) | 1998-07-22 | 2001-06-05 | Scenix Semiconductor, Inc. | Single cycle transition pipeline processing using shadow registers |
US6223338B1 (en) | 1998-09-30 | 2001-04-24 | International Business Machines Corporation | Method and system for software instruction level tracing in a data processing system |
US6324689B1 (en) | 1998-09-30 | 2001-11-27 | Compaq Computer Corporation | Mechanism for re-writing an executable having mixed code and data |
US6192513B1 (en) | 1998-11-02 | 2001-02-20 | Hewlett-Packard Company | Mechanism for finding spare registers in binary code |
US6351844B1 (en) | 1998-11-05 | 2002-02-26 | Hewlett-Packard Company | Method for selecting active code traces for translation in a caching dynamic translator |
US20020019976A1 (en) | 1998-12-08 | 2002-02-14 | Patel Mukesh K. | Java hardware accelerator using thread manager |
US6330662B1 (en) | 1999-02-23 | 2001-12-11 | Sun Microsystems, Inc. | Apparatus including a fetch unit to include branch history information to increase performance of multi-cylce pipelined branch prediction structures |
US6430741B1 (en) | 1999-02-26 | 2002-08-06 | Hewlett-Packard Company | System and method for data coverage analysis of a computer program |
JP2000347863A (en) | 1999-05-13 | 2000-12-15 | Internatl Business Mach Corp <Ibm> | Method and system for counting non-speculative event inside speculative processor |
US6446029B1 (en) | 1999-06-30 | 2002-09-03 | International Business Machines Corporation | Method and system for providing temporal threshold support during performance monitoring of a pipelined processor |
US6574727B1 (en) | 1999-11-04 | 2003-06-03 | International Business Machines Corporation | Method and apparatus for instruction sampling for performance monitoring and debug |
US20010032305A1 (en) | 2000-02-24 | 2001-10-18 | Barry Edwin F. | Methods and apparatus for dual-use coprocessing/debug interface |
US6480938B2 (en) | 2000-12-15 | 2002-11-12 | Hewlett-Packard Company | Efficient I-cache structure to support instructions crossing line boundaries |
US20020129309A1 (en) | 2000-12-18 | 2002-09-12 | Floyd Michael S. | Method and system for triggering a debugging unit |
US20020124237A1 (en) | 2000-12-29 | 2002-09-05 | Brinkley Sprunt | Qualification of event detection by thread ID and thread privilege level |
US20020147965A1 (en) | 2001-02-01 | 2002-10-10 | Swaine Andrew Brookfield | Tracing out-of-order data |
US20020199179A1 (en) | 2001-06-21 | 2002-12-26 | Lavery Daniel M. | Method and apparatus for compiler-generated triggering of auxiliary codes |
Non-Patent Citations (7)
Title |
---|
"Enable debuggers as an objective performance measurement tool for software development cost reduction", #444188, Research Disclosure, p. 686, Apr. 2001. |
Cohen et al., "Hardware-Assisted Characterization of NAS Benchmarks", Cluster Computing, v. 4, n. 3, pp. 189-196, Jul. 2001. |
Intel Architecture Software Developer's Manual, vol. 3: System Programming, Appendix A: Performance-Monitoring Events, pp. A1-A22, Jan. 1999. |
Iwasawa et al., "Parallelization Method of Fortran DO Loops by Parallelizing Assist System", Transactions of Information Processing Society of Japan, v. 36, n. 8, pp. 1995-2006, Aug. 1995. |
Kikuchi, "Parallelization Assist System", Transactions of Information Processing Society of Japan, v. 34, n. 9, pp. 1158-1169, Sep. 1993. |
Talla et al., "Evaluating Signal Processing and Multimedia Applications on SIMD, VLIW and Superscalar Architectures", Proceedings of 2000 International Conference on Computer Design, pp. 163-172, Sep. 2000. |
Talla et al., "Execution Characteristics of Multimedia Applications on a Pentium II Processor", 19th IEEE International Performance, Computing, and Communications Conference, pp. 516-524, Feb. 2000. |
Cited By (28)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8689190B2 (en) | 2003-09-30 | 2014-04-01 | International Business Machines Corporation | Counting instruction execution and data accesses |
US8381037B2 (en) | 2003-10-09 | 2013-02-19 | International Business Machines Corporation | Method and system for autonomic execution path selection in an application |
US8615619B2 (en) | 2004-01-14 | 2013-12-24 | International Business Machines Corporation | Qualifying collection of performance monitoring events by types of interrupt when interrupt occurs |
US8782664B2 (en) | 2004-01-14 | 2014-07-15 | International Business Machines Corporation | Autonomic hardware assist for patching code |
US20060005083A1 (en) * | 2004-06-30 | 2006-01-05 | International Business Machines Corporation | Performance count tracing |
US20060136867A1 (en) * | 2004-12-17 | 2006-06-22 | Manfred Schneider | Code diversification |
US7512936B2 (en) * | 2004-12-17 | 2009-03-31 | Sap Aktiengesellschaft | Code diversification |
US20070226722A1 (en) * | 2006-03-24 | 2007-09-27 | Chou Yuan C | Method and apparatus for selectively executing different executable code versions which are optimized in different ways |
US7543282B2 (en) * | 2006-03-24 | 2009-06-02 | Sun Microsystems, Inc. | Method and apparatus for selectively executing different executable code versions which are optimized in different ways |
US20070261033A1 (en) * | 2006-05-05 | 2007-11-08 | Chen Wen-Tzer T | Method and apparatus for selectively marking and executing instrumentation code |
US8245199B2 (en) | 2006-05-05 | 2012-08-14 | International Business Machines Corporation | Selectively marking and executing instrumentation code |
US8127276B2 (en) * | 2006-12-13 | 2012-02-28 | Institute For Information Industry | Apparatus, method, and computer readable medium thereof for generating and utilizing a feature code to monitor a program |
US20080148226A1 (en) * | 2006-12-13 | 2008-06-19 | Institute For Information Industry | Apparatus, method, and computer readable medium thereof for generating and utilizing a feature code to monitor a program |
US9459984B2 (en) * | 2007-10-29 | 2016-10-04 | Intel Corporation | Method and systems for external performance monitoring for virtualized environments |
US20100235836A1 (en) * | 2007-10-29 | 2010-09-16 | Stanislav Viktorovich Bratanov | method of external performance monitoring for virtualized environments |
US20090292793A1 (en) * | 2008-05-21 | 2009-11-26 | Motorola, Inc. | Autonomous operation of networking devices |
US8019838B2 (en) | 2008-05-21 | 2011-09-13 | Motorola Solutions, Inc. | Autonomous operation of networking devices |
US9600348B2 (en) | 2011-01-10 | 2017-03-21 | International Business Machines Corporation | Recording activity of software threads in a concurrent software environment |
US20140026111A1 (en) * | 2011-04-11 | 2014-01-23 | Gregory Michael Stitt | Elastic computing |
US9495139B2 (en) * | 2011-04-11 | 2016-11-15 | University Of Florida Research Foundation, Inc. | Elastic computing |
US9471458B2 (en) | 2012-01-05 | 2016-10-18 | International Business Machines Corporation | Synchronization activity recording system for a concurrent software environment |
US20130297258A1 (en) * | 2012-05-01 | 2013-11-07 | International Business Machines Corporation | Smart Multiplexing of Performance Counters for Performance Measurement |
US9129057B2 (en) * | 2012-05-01 | 2015-09-08 | International Business Machines Corporation | Smart multiplexing of performance counters for performance measurement |
US9015413B2 (en) | 2012-10-02 | 2015-04-21 | International Business Machines Corporation | Management of data using inheritable attributes |
US9026730B2 (en) | 2012-10-02 | 2015-05-05 | International Business Machines Corporation | Management of data using inheritable attributes |
US20140149710A1 (en) * | 2012-11-29 | 2014-05-29 | Advanced Micro Devices, Inc. | Creating simd efficient code by transferring register state through common memory |
US9354892B2 (en) * | 2012-11-29 | 2016-05-31 | Advanced Micro Devices, Inc. | Creating SIMD efficient code by transferring register state through common memory |
US9817586B2 (en) | 2016-02-23 | 2017-11-14 | Samsung Electronics Co., Ltd. | Method of application aware IO completion mode changer for key value device |
Also Published As
Publication number | Publication date |
---|---|
US20050081010A1 (en) | 2005-04-14 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US7421681B2 (en) | Method and system for autonomic monitoring of semaphore operation in an application | |
US8381037B2 (en) | Method and system for autonomic execution path selection in an application | |
US7225309B2 (en) | Method and system for autonomic performance improvements in an application via memory relocation | |
US7373637B2 (en) | Method and apparatus for counting instruction and memory location ranges | |
US7395527B2 (en) | Method and apparatus for counting instruction execution and data accesses | |
US7257657B2 (en) | Method and apparatus for counting instruction execution and data accesses for specific types of instructions | |
US7496908B2 (en) | Method and apparatus for optimizing code execution using annotated trace information having performance indicator and counter information | |
US7526757B2 (en) | Method and apparatus for maintaining performance monitoring structures in a page table for use in monitoring performance of a computer program | |
US7114036B2 (en) | Method and apparatus for autonomically moving cache entries to dedicated storage when false cache line sharing is detected | |
US7392370B2 (en) | Method and apparatus for autonomically initiating measurement of secondary metrics based on hardware counter values for primary metrics | |
US7093081B2 (en) | Method and apparatus for identifying false cache line sharing | |
US7181599B2 (en) | Method and apparatus for autonomic detection of cache “chase tail” conditions and storage of instructions/data in “chase tail” data structure | |
US7937691B2 (en) | Method and apparatus for counting execution of specific instructions and accesses to specific data locations | |
US20050155022A1 (en) | Method and apparatus for counting instruction execution and data accesses to identify hot spots | |
US20050071821A1 (en) | Method and apparatus to autonomically select instructions for selective counting | |
US20090210630A1 (en) | Method and Apparatus for Prefetching Data from a Data Structure | |
US20050210439A1 (en) | Method and apparatus for autonomic test case feedback using hardware assistance for data coverage | |
US20050155018A1 (en) | Method and apparatus for generating interrupts based on arithmetic combinations of performance counter values | |
US20050071516A1 (en) | Method and apparatus to autonomically profile applications | |
US20050071611A1 (en) | Method and apparatus for counting data accesses and instruction executions that exceed a threshold | |
US20050071816A1 (en) | Method and apparatus to autonomically count instruction execution for applications | |
US20050071608A1 (en) | Method and apparatus for selectively counting instructions and data accesses | |
US20050071612A1 (en) | Method and apparatus for generating interrupts upon execution of marked instructions and upon access to marked memory locations | |
US20050071610A1 (en) | Method and apparatus for debug support for individual instructions and memory locations | |
US20050086455A1 (en) | Method and apparatus for generating interrupts for specific types of instructions |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:DEWITT, JIMMIE EARL, JR.;LEVINE, FRANK ELIOT;RICHARDSON, CHRISTOPHER MICHAEL;AND OTHERS;REEL/FRAME:014611/0572;SIGNING DATES FROM 20031002 TO 20031003 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
REMI | Maintenance fee reminder mailed | ||
FPAY | Fee payment |
Year of fee payment: 4 |
|
SULP | Surcharge for late payment | ||
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026664/0866Effective date: 20110503 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |
|
FEPP | Fee payment procedure |
Free format text: MAINTENANCE FEE REMINDER MAILED (ORIGINAL EVENT CODE: REM.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
LAPS | Lapse for failure to pay maintenance fees |
Free format text: PATENT EXPIRED FOR FAILURE TO PAY MAINTENANCE FEES (ORIGINAL EVENT CODE: EXP.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20190529 |