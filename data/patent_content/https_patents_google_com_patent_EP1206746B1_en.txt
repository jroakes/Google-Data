EP1206746B1 - A database system for viewing effects of changes to a index for a query optimization plan - Google Patents
A database system for viewing effects of changes to a index for a query optimization plan Download PDFInfo
- Publication number
- EP1206746B1 EP1206746B1 EP00960157.6A EP00960157A EP1206746B1 EP 1206746 B1 EP1206746 B1 EP 1206746B1 EP 00960157 A EP00960157 A EP 00960157A EP 1206746 B1 EP1206746 B1 EP 1206746B1
- Authority
- EP
- European Patent Office
- Prior art keywords
- index
- virtual
- original
- database
- name
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Lifetime
Links
- 238000005457 optimization Methods 0.000 title claims description 58
- 230000000694 effects Effects 0.000 title description 12
- 238000000034 method Methods 0.000 claims description 45
- 238000003860 storage Methods 0.000 claims description 7
- 238000004590 computer program Methods 0.000 claims 1
- 238000010586 diagram Methods 0.000 description 7
- 238000007726 management method Methods 0.000 description 7
- 238000007796 conventional method Methods 0.000 description 6
- 230000008569 process Effects 0.000 description 6
- 230000008859 change Effects 0.000 description 5
- 239000004606 Fillers/Extenders Substances 0.000 description 4
- 238000002474 experimental method Methods 0.000 description 4
- 230000006870 function Effects 0.000 description 4
- 238000004519 manufacturing process Methods 0.000 description 4
- BASFCYQUMIYNBI-UHFFFAOYSA-N platinum Chemical compound [Pt] BASFCYQUMIYNBI-UHFFFAOYSA-N 0.000 description 4
- 238000004458 analytical method Methods 0.000 description 3
- 238000004891 communication Methods 0.000 description 3
- 238000013479 data entry Methods 0.000 description 3
- 238000013461 design Methods 0.000 description 3
- 238000003491 array Methods 0.000 description 2
- 230000000875 corresponding effect Effects 0.000 description 2
- 238000013500 data storage Methods 0.000 description 2
- 229910052697 platinum Inorganic materials 0.000 description 2
- 238000004445 quantitative analysis Methods 0.000 description 2
- 230000004044 response Effects 0.000 description 2
- 238000012360 testing method Methods 0.000 description 2
- 238000012876 topography Methods 0.000 description 2
- 238000004140 cleaning Methods 0.000 description 1
- 150000001875 compounds Chemical class 0.000 description 1
- 238000010276 construction Methods 0.000 description 1
- 230000002596 correlated effect Effects 0.000 description 1
- 230000001419 dependent effect Effects 0.000 description 1
- 238000005516 engineering process Methods 0.000 description 1
- 230000007717 exclusion Effects 0.000 description 1
- 230000006872 improvement Effects 0.000 description 1
- 238000012986 modification Methods 0.000 description 1
- 230000004048 modification Effects 0.000 description 1
- 230000002093 peripheral effect Effects 0.000 description 1
- 238000012545 processing Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/22—Indexing; Data structures therefor; Storage structures
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F16/00—Information retrieval; Database structures therefor; File system structures therefor
- G06F16/20—Information retrieval; Database structures therefor; File system structures therefor of structured data, e.g. relational data
- G06F16/24—Querying
- G06F16/245—Query processing
- G06F16/2453—Query optimisation
- G06F16/24534—Query rewriting; Transformation
- G06F16/24542—Plan optimisation
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99932—Access augmentation or optimizing
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99933—Query processing, i.e. searching
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99933—Query processing, i.e. searching
- Y10S707/99934—Query formulation, input preparation, or translation
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99931—Database or file accessing
- Y10S707/99933—Query processing, i.e. searching
- Y10S707/99935—Query augmenting and refining, e.g. inexact access
-
- Y—GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10—TECHNICAL SUBJECTS COVERED BY FORMER USPC
- Y10S—TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
- Y10S707/00—Data processing: database and file management or data structures
- Y10S707/99941—Database schema or data structure
- Y10S707/99943—Generating database or data structure, e.g. via user interface
Definitions
- the present invention relates generally to viewing the effect of changes to indexing designs for database tables. More particularly, the present invention relates to using virtual tables and virtual indexes for determining optimization plans for database queries when indexes for the database tables are changed.
- Achieving and maintaining simple and efficient access to computer data is a goal shared by most computer users.
- greater amounts of data may need to be organized and stored for the user.
- One system for organizing computer data is the database, which is generally recognized as a group of logically related information objects or files stored together in some recordable medium without unnecessary redundancy.
- the database preferably serves various applications or programs, and facilitates access by these applications or programs.
- Each table In most databases, data is externally structured into tables. Each table generally includes a series of fields which define columns of the table. Each row of the table comprises a single record. For each row of data in a table, a counterpart of that data is physically stored in the database. Thus, when the database user requests particular information from the table, the appropriate portion of the stored data is retrieved and presented to the user.
- a program referred to as a “database management system” (“DBMS”) provides users with an interface to the database.
- the DBMS provides structure to the database that enables users to access information objects stored in the database.
- the DBMS identifies and retrieves certain information objects in response to information requests, or "queries" from a user.
- the retrieval of particular information objects depends on the similarity between the information stored in the information objects and requests presented to the system by the user. The similarity is measured by comparing values of certain attributes attached to the information objects and information requests.
- information objects in a database are often "indexed” so that the objects are characterized by assigning descriptors to identify the content of the objects.
- indexing can lead the DBMS to particular items in the database in response to specific queries from a user.
- the DBMS To build an index for a table, the DBMS typically scans the table, retrieves the data from every row and column in the table, and adds the data to the index, which is often in the form of a B-tree structure.
- B-tree structures For more information on B-tree structures, see Patrick O'Neil "Database - Principles, Programming, Performance," Morgan Kaufmann Publishers, Inc. (1994 ), incorporated herein by reference.
- the DBMS sequentially reads each and every data entry in the table, copies each data entry to a temporary space, sorts the data entries if necessary, and finally creates a data structure for the index.
- the process of building the index for the table generally consumes great amounts of time and resources. For example, creating an index for a table having several million rows may take several days. Moreover, creating the index for this table would typically require several hundred megabytes of temporary workspace to copy and sort the data before creating the index. Naturally, the process of creating or changing an index will take proportionally larger amounts of time. Tables for databases such as those used in data warehouses may have billions, or even millions of billions of rows. It may take the user weeks or even months to create the index for tables this size.
- the first step is to determine which clauses in the query have associated descriptors or index entries in the index, to retrieve those index entries, and preliminarily restrict the set of information objects being considered.
- the second step generally involves taking the set of information objects from the first step and examining each information object in turn to determine if it satisfies the query.
- SQL Structured Query Language
- An SQL interface allows users to formulate relational operations on database tables either interactively, in batch files, or embedded in host languages such as C, COBOL, etc. Operators are provided in SQL that allow the user to manipulate the data, wherein each operator operates on one or more tables and produces a new table as a result.
- indices may be added to the database to facilitate the speed at which queries are executed, especially in larger tables where an index may make a substantial improvement in performance.
- adding or changing an index may require considerable amounts of time and resources for the database to build the index.
- the user is often presented with the dilemma of either expending the time and resources required to build the index, at the risk of the new index not improving performance in any meaningful way, or not building the index, and risking the failure to recognize improved performance which might be possible with the index.
- Oracle database management systems provide users with the ability to view an "optimization plan" of a SQL statement.
- An optimization plan is automatically determined by the database for the SQL statement when the statement is parsed by the database.
- the optimization plan shows how the database would retrieve the data necessary to satisfy the requirements of the SQL statement without actually executing the SQL statement.
- the optimization plan shows, among other things, information such as what table would be first accessed, how intermediate result sets would be joined, whether an index would be used and, if so, how that index would be interpreted.
- the user may obtain an estimate as to how efficiently that SQL statement would be executed in the database.
- Fig. 1 is a flow diagram of a conventional method 100 for viewing the effect of changes to an index for a database table on an optimization plan for an SQL statement.
- step 110 an original optimization plan is created for the SQL statement.
- step 120 the indices for a table referenced in the SQL statement are created, dropped or modified.
- step 130 a new optimization plan is created for the SQL statement.
- step 140 the user compares the new optimization plan with the original optimization plan to determine if performance would be improved or worsened as a result of the index changes.
- DBA database administrator
- the DBA is provided, by the utility, with the ability to propose hypothetical ("what-if") indexes and quantitatively analyze their impact on performance of the system.
- impact analysis consists of analyzing workloads over the database, estimating changes in the cost of a workload, and studying index usage while taking into account projected changes in the sizes of the database tables.
- the present invention allows a user to see how an optimization plan for a database query changes when a new index is added to a database table, an existing index is dropped from the table, or an existing index for the table is modified.
- a method and apparatus provide a framework for a user to experiment with the index topography for tables and preview the effects that the various topographical constructions of indexes can have on the optimization plan for a database query, such as an SQL statement, without having to dedicate the time and resources required by conventional methods.
- a virtual table is created which mimics the structure of a table on the database under test, or "original table” on the database.
- the virtual table is generally created by copying the original table, excluding any data in the original table. Thus, for example, if the data is stored in rows of the original table, the rows are not copied into the virtual table. Any existing indexes associated with original table, or "original indexes,” however, are copied to define a virtual index associated with the virtual table.
- the associated virtual index may be easily and quickly modified while preserving the overall structure of the original table. New indices may be added and existing indices may be dropped very quickly. Also, if no original index exists, a new virtual index may be easily created.
- references to the original table are replaced with references to the virtual table.
- the database management system determines a new optimization plan for the query. Because the new optimization plan is determined using the virtual table and virtual index, the plan is retrieved much faster than if it were created using the original table and any associated original index. This is because the actual data in the original table was excluded when the original table was copied to define the virtual table. Thus, any changes to the optimization plan may be identified quickly after the indexing design is altered.
- any references in the new optimization plan to the virtual table and any virtual index are replaced with the names of the original table and the original index.
- the user can compare the new optimization plan with the original optimization plan and analyze the changes without concerning himself with, or even needing to know about, the use of virtual objects in creating the new optimization plan.
- Fig. 2 is a block diagram illustrating an exemplary hardware environment in which exemplary embodiments of the present invention may be implemented.
- a client computer 200 is coupled to a server computer 202.
- Both the client computer 200 and server computer 202 may include, inter alia, processors, random access memory (RAM), read-only memory (ROM), keyboard, display, fixed and/or removable data storage devices, and data communications devices.
- RAM random access memory
- ROM read-only memory
- keyboard keyboard
- display fixed and/or removable data storage devices
- data communications devices data communications devices.
- server computer 202 is in communication with a database 212 which is preferably an Oracle database.
- database 212 is preferably an Oracle database.
- other databases may be used such as Microsoft SQL Server databases, Sybase SQL Server databases, and IBM DB2 databases.
- Exemplary embodiments of the present invention are typically implemented using database management system software, such as the SQL-Station software made and sold by PLATINUM Technology, although it may be implemented with any database management system software such as the Developer/2000 package sold by Oracle or the DB2 product sold by IBM.
- database management system software such as the SQL-Station software made and sold by PLATINUM Technology
- PLATINUM's SQL-Station software in which exemplary embodiments of the present invention may be realized, may be used in conjunction with other software such as Oracle Developer/2000 software and the DB2 product sold by IBM.
- the software includes an SQL-Station client program 204 and Relational Extender client program 206 executed by the client computer 200.
- the software further includes an Oracle server program 208 and Relational Extender program 210 executed by the server computer 202.
- These programs execute under the control of an operating system on their respective computers 200 or 202, such as WINDOWS 95, WINDOWS NT, OS/2, AIX, MVS, UNIX, etc.
- WINDOWS 95 WINDOWS 95
- WINDOWS NT OS/2
- AIX AIX
- MVS UNIX
- the SQL-Station client program 204 and the Relational Extender client program 206 generate commands for performing various search and retrieval functions, i.e., queries, against the database 212 managed by the Oracle server program 208 and the Relational Extender server program 210.
- these queries conform to the SQL standard, although other types of queries could also be used without departing from the scope of the invention.
- the queries invoke functions performed by the Oracle server program 208 and the Relational Extender server program 210, such as definition, access control, interpretation, compilation, database retrieval, and update of user and system data.
- DBMS software, the SQL queries, and the instructions derived therefrom are all tangibly embodied in or readable from a computer-readable medium, e.g. one or more data storage devices and/or data communications devices.
- the RDBMS software, the SQL queries, and the instructions derived therefrom are all comprised of instructions which, when read and executed by the client computer 200 and/or the server computer 202, causes the client computer 200 and/or the server computer 202 to perform the steps necessary to implement and/or use embodiments of the present invention.
- Fig. 3 is a block diagram illustrating a system for determining the effect of changes to an index for a database table on an optimization plan for a database query, according to an exemplary embodiment of the present invention.
- a database 306 which is preferably an Oracle database such as the Oracle 8 database.
- each user 302, 304 controls its own objects and information stored in tables within that user's account.
- user PAFO-HR 304 controls original table 308 and an associated index 310, as well as virtual table 312 and a virtual index 314 associated with virtual table 312.
- the tables 308, 312 and the respective associated indexes 310, 314 are stored on the database.
- Each user 302, 304 generally controls information stored in that user's account to the exclusion of other users of database 306. Users may, however, be granted various privileges with respect to the accounts of other users. Generally, the privilege may only be granted from one user to another with respect to the one user's account. For example, in Fig. 3 , only PAFO-HR 304 has the power to grant privileges on the PAFO-HR 304 account to other users.
- READ that is, the permission to access information in another user's account.
- user PAFO-HR 304 has given user TUTOR 302 permission, or granted TUTOR 302 a READ privilege, to access information and objects stored in tables in the PAFO-HR 304 account.
- TUTOR 302 is able to query the tables in PAFO-HR's account and access such information in the PAFO-HR 304 account.
- SCOTT a third user "SCOTT" (not shown) has not been granted such READ privileges with respect to PAFO-HR's account, so SCOTT cannot access tables controlled by PAFO-HR 304.
- CREATE_TABLE Another such privilege available in the system of Fig. 3 is a "CREATE_TABLE" privilege or set of privileges, which may also be granted from one user to another.
- the CREATE_TABLE privilege if granted by the one user, allow other users to create tables in the one user's account, and to store objects in those tables.
- TUTOR 302 has not been granted CREATE_TABLE privileges with respect to PAFO-HR's account.
- a software package entitled "Plan Analyzer for Oracle” (“PAFO”) 316 is stored on database 306.
- This software package is accessible by users 302, 304 of the database system.
- the package PAFO 316 has CREATE_TABLE privileges with respect to PAFO-HR 304 granted to PAFO 316 along with several other privileges by the Database Administrator (DBA).
- DBA Database Administrator
- a user logged into the TUTOR 302 account who would otherwise not have privileges required to access and experiment with the tables and indices in the PAFO-HR 304 account, may use the PAFO package 316 to accomplish these tasks.
- TUTOR 302 calls the package PAFO 316 to execute methods of the present invention.
- PAFO 316 creates and dynamically deploys a procedure 318 to the PAFO-HR 304 account.
- the deployed procedure 318 is then executed in the PAFO-HR 304 account.
- Deployed procedure 318 may then grant the necessary privileges for accessing the PAFO-HR 304 account to the user of the TUTOR 302 account.
- the deployed procedure then grants READ (not write) privileges on the virtual table to TUTOR, the user's account. In this way, TUTOR can access both original table 308 and virtual table 312 without having the CREATE_TABLE privilege.
- the functionality of deployed procedure 318 is hereafter described with reference to Figs. 3 and 4 .
- procedure 316 identifies original table 308, as referenced in SQL statement 320, and copies original table 308 to define virtual table 312.
- This copying includes copying the original table statistics to the new table, including the column statistics, histograms, and segment storage. In this way, it appears as if the virtual table contains as many rows of data as the original table. Any actual data in original table 308, however, is preferably excluded from the information copied to define virtual table 312. Thus, for example, when data is stored in rows of original table 308, the rows are not copied into the virtual table 312.
- step 402 the benefits of creating and working with a copy of the original table are many. Users accessing original table 308 are not disrupted and performance is not degraded by the changes. In a production environment, executing applications are not affected. When Oracle databases are used, nothing in the Oracle catalog needs to be modified for original table 308. Moreover, since the virtual table does not contain any rows, index creation is very fast.
- step 402 if other original tables are present in the PAFO-HR 304 account, these tables may also copied to define corresponding virtual tables. Also, for reasons which will become apparent below, a list (not shown) is preferably maintained in which the names of virtual tables are correlated with the original tables from which they were created.
- step 404 virtual index 314, to be associated with virtual table 312, is defined.
- procedure 316 makes copies of original index 310 to define virtual index 314. For example, if original indices are defined for the two columns shown in original table 308 of Fig. 3 , corresponding virtual indices are created for the two columns shown in virtual table 312 by copying the original indices.
- the statistics associated with original index 310 are also copied into virtual index 314, and may then be set as specified by the user.
- the virtual indices preferably have the same data structures as the original indices, including the same constraints and definitions.
- the structure of the virtual index is the same as the original index.
- step 404 if no original index 310 associated with original table 308 exists, virtual index 314 may be created and defined by the user through procedure 316. Also, in situations where a user wishes to experiment with no index, the user may simply choose to define virtual index 314 by deleting any indices present in original index 310, using deployed procedure 316. At this point, procedure 318 is created on PAFO-HR 304 and executed to grant READ privileges to Tutor 302.
- step 406 after virtual index 314 is defined, PAFO 316 replaces in SQL statement 320 any reference to original table 308 with a reference to virtual table 312. In addition, any reference to original index 310 in SQL statement 320 is switched with the name of virtual index 314.
- a modified SQL statement 322 with the replaced names is then sent to the database server.
- a user of account TUTOR 302 will believe he is accessing original table 308, while actually accessing virtual table 314. Moreover, by creating a copy of the original table and simply changing the name of that object as it is referenced in the SQL statement, the need for the time-consuming and resource-consuming process of creating a new index on the original table is eliminated.
- the database interprets the modified SQL statement 322 to determine the new optimization plan 324 for the virtual table in step 408.
- step 410 information in new optimization plan 324 returned by the database server is then modified by PAFO procedure 316 to define a modified optimization plan 326. Specifically, any references in new optimization plan 324 to virtual index 314 and virtual table 312 are replaced, respectively, with references to original index 310 and original table 308.
- the modified optimization plan 326 is then displayed to the user in step 412.
- the time required to make the changes to the index and retrieve the new optimization plan is often reduced from a matter of hours to a matter of seconds.
- the user simply enjoys improved speed and system performance in retrieving the new optimization plan without needing to concern himself with, or even be aware of, the use of virtual tables and virtual indexes.
- the user may then compare modified optimization plan 326 with any original optimization plan created for original table 308 and original index 310. If the new optimization plan is more desirable, e.g., appears as if it would improve the speed and efficiency of the database in executing SQL statement 320, the user may then choose to actually build virtual index 314 on original table 308. Conversely, if performance would not be improved, the user may experiment with a different virtual index 314 or continue using original index 310 without having wasted the time and resources which would have otherwise been required to construct virtual index 314.
- a user is logged onto the TUTOR 302 account of Fig. 3 .
- original table 308 in account PAFO-HR 304 is a table storing the name of employees of a company or firm and, as such, is referred to hereafter as the "EMPLOYEES" table.
- TUTOR 302 has been granted READ privileges with respect to PAFO-HR's account, so TUTOR 302 is able to send queries to the EMPLOYEES table.
- Virtual table 312 has been created for the EMPLOYEES table where the virtual table name is "T_########1.”
- Original SQL statement 320 is the following:
- SQL statement 320 contains optimization hints
- PAFO 316 check for hints containing original table name "EMPLOYEES" or one of the indexes associated therewith as parameters to the hints. For instance, assume the user is working with the following SQL statement 320:
- each user is preferably only allowed to create a single copy of the EMPLOYEES table to define "T_######1," the virtual table.
- Each user is preferably restricted from creating a new copy if a copy is already created for that user.
- the name of the original table is preferably specified rather than the virtual table name. So, for example, if the user creates a first virtual index on the EMPLOYEES table, the user can create a second virtual index or drop an index on the virtual copy of the EMPLOYEES table, but the table name parameter should be the name of the original table. In the latter case, where the user reuses a virtual table created before, the PAFO package ensures that the index names retrieved still exist on the original table. For example, the following SQL query may be used:
- the following steps are used for viewing the effect of changes to an index for a database table on an optimization plan for a database query.
- Step 1 Create Virtual Table
- the following procedure may be executed to create the virtual table, assuming a virtual table has not already been created:
- VARCHAR2(30) represents a character string of up to 30 characters.
- MODE INPUT indicates data being input to the procedure.
- MODE OUTPUT represents data being retrieved from the procedure.
- Step 2 Define Virtual Table and Index Names
- the following procedure may be executed to return the name of the virtual table and the names of the indexes that were copied to define virtual indexes.
- step 2 generally assumes the virtual table was created using the CREATE_VIRTUAL _TABLE procedure. This means that if the virtual table exists in a cluster, that cluster is the same cluster in which the original table exists. That is, the virtual table is not the product of a request to make an unclustered table clustered. Otherwise an error is returned.
- Step 3 Default Statistics
- the new virtual index preferably has realistic statistics in order to ensure that an optimization plan is created that is equivalent to having the index created on the original table.
- EXPLAIN_VIRTUAL provides the procedure DEFAULT_NEW_INDEX_STATS to assist the user in setting the appropriate statistics.
- the storage information and statistics of those indexes will be used to generate default storage information and statistics for the virtual index. If the existing indexes are not analyzed, limited default will be available.
- PAFO After executing DEFAULT_NEW_INDEX_STATS, the default storage information and statistics are returned to PAFO for display and modification. The user is permitted to change these statistics to better identify the index properties. To help the user decide how to change the statistics, PAFO allows the user to display the statistics on other indexes currently created on the table.
- the following error codes may be generated when executing the procedure DEFAULT_NEW_INDEX_STATS.
- the second column contains a description of error and how, if possible, the user can resolve the error in parenthesis.
- Table 4 -20001 User is neither table owner; nor INDEX privilege on table; nor CREATE ANY INDEX privilege. (proper privileges should be obtained.) -20002 Table does not exist. (Check the table name and owner.) -20003 Index already exists with specified columns. (The table already has an index with the requested columns.) -20004 Column______not found. (The index column does not exist.) -20005 Invalid table owner. (The Oracle account entered for the table owner does not exist.) -20006 Index name is not unique. (Enter a different index name for the virtual index.) -20010 First perform CLEAN UP on the table. (The table already has a virtual index created by the user.
- the output parameters will be input to the next procedure executed, EXPLAIN_VIRTUAL. CREATE_VIRTUAL_INDEX. Also, note that it is possible the user will attempt to create the index on a tablespace to which the user does not have access.
- Step 4 Create Virtual Index
- any existing indexes of the original table are preferably copied to define the virtual index.
- the index statistics and storage information are also copied. To this end, the following procedure may be executed:
- PAFO creates a new WHAT IF frame as described above displaying the original SQL text.
- the user is allowed to modify the text and add hints.
- the "tag" from the SQL frame is copied and the same sequential number is used. For instance, if the SQL Frame label is SQL: HISTORY;1, then the WHAT IF Frame should be labeled, WHAT IF: HISTORY;1.
- the procedure desirably makes a copy of the SQL text and replace all occurrences of the original table name (:table_name) with the table copy's name (:temp_table_name).
- the modified SQL text should include both the owner of the virtual table, and the virtual table name. Hint parameters may also need to be changed if the hints reference the table or an index on the table. The plan is then created and retrieved into memory.
- the optimization plan should be searched for these virtual index names and replaced with the original index name.
- the virtual indexes are identified in the arrays (:original_index_owners, :original_index_names).
- the associated replacement index names are stored in the array (:virtual_index_names). So PAFO searches each step where the OPERATION column starts with the text "INDEX”. If the OBJECT_OWNER and OBJECT_NAME match the ORIGINAL_INDEX_OWNER(0) and VIRTUAL_INDEX_NAME(0) values, the index name should be changed to ORIGINAL_INDEX_NAME(0). This is preferably repeated for each of the array elements.
- the modified plan is then displayed, and the user is informed if the virtual index created had an effect on performance.
- PAFO When displaying the information in the "OBJECT" tab, PAFO preferably makes the same changes as described above in steps 4 & 5; that is, PAFO displays the indexes for T ########1, not EMPLOYEES. But PAFO should use the name EMPLOYEES instead of T1 when displaying the information to the user. Also, when displaying the indexes, the associated ORIGINAL_INDEX_NAME values should be displayed.
- indexes that can be dropped by this procedure are preferably those belonging to a virtual table. So if a virtual table does not exist, it should be created.
- the virtual table is created via the procedure CREATE_VIRTUAL_TABLE. Then the user may indicate from which table he wishes to drop an index. The following steps may then be used:
- Step 1 List All Tables to Which the User Has Access
- Step 2 Determine if the Selected Table is Virtual
Description
- The present invention relates generally to viewing the effect of changes to indexing designs for database tables. More particularly, the present invention relates to using virtual tables and virtual indexes for determining optimization plans for database queries when indexes for the database tables are changed.
- Achieving and maintaining simple and efficient access to computer data is a goal shared by most computer users. In addition, as the processing power of modem computers increases, greater amounts of data may need to be organized and stored for the user. One system for organizing computer data is the database, which is generally recognized as a group of logically related information objects or files stored together in some recordable medium without unnecessary redundancy. The database preferably serves various applications or programs, and facilitates access by these applications or programs.
- In most databases, data is externally structured into tables. Each table generally includes a series of fields which define columns of the table. Each row of the table comprises a single record. For each row of data in a table, a counterpart of that data is physically stored in the database. Thus, when the database user requests particular information from the table, the appropriate portion of the stored data is retrieved and presented to the user.
- A program referred to as a "database management system" ("DBMS") provides users with an interface to the database. The DBMS provides structure to the database that enables users to access information objects stored in the database. The DBMS identifies and retrieves certain information objects in response to information requests, or "queries" from a user. The retrieval of particular information objects depends on the similarity between the information stored in the information objects and requests presented to the system by the user. The similarity is measured by comparing values of certain attributes attached to the information objects and information requests.
- For example, if a table named "Employee" contains the fields "Name", "Dept", "Age" and "Salary", and a user desires to find the subset of employees who work in the electronics department, the following query can be used:
SELECT Name, Salary, Age FROM Employee WHERE Dept = "Electronics" - To facilitate the retrieval process, information objects in a database are often "indexed" so that the objects are characterized by assigning descriptors to identify the content of the objects. The process of characterizing these information objects, referred to as "indexing", can lead the DBMS to particular items in the database in response to specific queries from a user.
- To build an index for a table, the DBMS typically scans the table, retrieves the data from every row and column in the table, and adds the data to the index, which is often in the form of a B-tree structure. For more information on B-tree structures, see Patrick O'Neil "Database - Principles, Programming, Performance," Morgan Kaufmann Publishers, Inc. (1994), incorporated herein by reference. The DBMS sequentially reads each and every data entry in the table, copies each data entry to a temporary space, sorts the data entries if necessary, and finally creates a data structure for the index.
- The process of building the index for the table, however, generally consumes great amounts of time and resources. For example, creating an index for a table having several million rows may take several days. Moreover, creating the index for this table would typically require several hundred megabytes of temporary workspace to copy and sort the data before creating the index. Naturally, the process of creating or changing an index will take proportionally larger amounts of time. Tables for databases such as those used in data warehouses may have billions, or even millions of billions of rows. It may take the user weeks or even months to create the index for tables this size.
- Other factors compound the time problems associated with creating the index. Specifically, after the index is created, time is required for the database to test the index and return performance statistics, and for the user to analyze those results.
- With a typical indexed database system, there are generally two steps to resolving a query. The first step is to determine which clauses in the query have associated descriptors or index entries in the index, to retrieve those index entries, and preliminarily restrict the set of information objects being considered. The second step generally involves taking the set of information objects from the first step and examining each information object in turn to determine if it satisfies the query.
- Structured Query Language (SQL) has evolved into a standard language for database queries or statements. An SQL interface allows users to formulate relational operations on database tables either interactively, in batch files, or embedded in host languages such as C, COBOL, etc. Operators are provided in SQL that allow the user to manipulate the data, wherein each operator operates on one or more tables and produces a new table as a result.
- In the process of tuning an SQL statement or query, the user often wishes to know how a change in indexing would affect the performance of that query. As explained above, indices may be added to the database to facilitate the speed at which queries are executed, especially in larger tables where an index may make a substantial improvement in performance. On the other hand, due to the amount of data in the database, adding or changing an index may require considerable amounts of time and resources for the database to build the index. Thus, the user is often presented with the dilemma of either expending the time and resources required to build the index, at the risk of the new index not improving performance in any meaningful way, or not building the index, and risking the failure to recognize improved performance which might be possible with the index.
- Oracle database management systems provide users with the ability to view an "optimization plan" of a SQL statement. An optimization plan is automatically determined by the database for the SQL statement when the statement is parsed by the database. The optimization plan shows how the database would retrieve the data necessary to satisfy the requirements of the SQL statement without actually executing the SQL statement. Specifically, the optimization plan shows, among other things, information such as what table would be first accessed, how intermediate result sets would be joined, whether an index would be used and, if so, how that index would be interpreted. Thus, by viewing the optimization plan for a particular SQL statement, the user may obtain an estimate as to how efficiently that SQL statement would be executed in the database.
- In larger database management systems, the optimization of queries becomes more important to minimize the amount of time and resources consumed. Thus, it becomes equally important for users to be able to view the optimization plan for an SQL statement and ascertain the effect index changes may have on the optimization plan.
-
Fig. 1 is a flow diagram of aconventional method 100 for viewing the effect of changes to an index for a database table on an optimization plan for an SQL statement. Instep 110, an original optimization plan is created for the SQL statement. Instep 120, the indices for a table referenced in the SQL statement are created, dropped or modified. Instep 130, a new optimization plan is created for the SQL statement. Lastly, instep 140, the user compares the new optimization plan with the original optimization plan to determine if performance would be improved or worsened as a result of the index changes. - As explained above, however,
conventional method 100 ofFig. 1 requires excessive time and resources to create, drop or change the index. Moreover, excessive time and resources are then required for the database to gather the necessary statistics to build the various optimization plans. If the database is not used in a production environment, taking the time to make changes to the index using conventional methods might be possible. If the database is used in production, however, it would most likely not be feasible to expend the time and energy needed make the changes shown inFig. 1 due to the tremendous negative impact on speed, resources and overall performance. For example, using the methodology ofFig. 1 , if a tool or application were relying upon an existing index, and the user changed or dropped that index instep 120, the database could shut down and the entire system could deadlock. - Thus, with conventional methods for previewing the effect of index changes on optimization plans, the user is often compelled to minimize any experimentation with the index. This, in turn, often results in the failure to realize the optimal index topography or optimization plan for the database which could cost great amounts of time and energy when the SQL statements are executed in the database, particularly for larger database management systems. Thus, there is a need for a faster and more efficient way to change indexing designs for database tables and to create optimization plans for these indexes.
- CHAUDHURI S ET AL: "AutoAdmin "what-if" index analysis utility" SIGMOD REC. (USA), SIGMOD RECORD, JUNE 1998, ACM, vol. 27, no. 2, June 1998, pages 367-378, relates to database techniques for reducing the overhead of database administration, namely a novel index analysis utility prototyped for Microsoft SQL Server 7.0. Moreover, implementation techniques for efficiently supporting "what-if" indexes are provided. Knowing that an important aspect of data administration that critically influences performance is the ability to select indexes for a database, the utility enables the database administrator (DBA) to perform a quantitative analysis of the existing indexes in order to decide the right indexes for a database. To perform the quantitative analysis, the DBA is provided, by the utility, with the ability to propose hypothetical ("what-if") indexes and quantitatively analyze their impact on performance of the system. Such impact analysis consists of analyzing workloads over the database, estimating changes in the cost of a workload, and studying index usage while taking into account projected changes in the sizes of the database tables.
- The present invention allows a user to see how an optimization plan for a database query changes when a new index is added to a database table, an existing index is dropped from the table, or an existing index for the table is modified.
- The present invention is defined in the independent claims. The dependent claims defined embodiments of the present invention.
- A method and apparatus provide a framework for a user to experiment with the index topography for tables and preview the effects that the various topographical constructions of indexes can have on the optimization plan for a database query, such as an SQL statement, without having to dedicate the time and resources required by conventional methods.
- A virtual table is created which mimics the structure of a table on the database under test, or "original table" on the database. The virtual table is generally created by copying the original table, excluding any data in the original table. Thus, for example, if the data is stored in rows of the original table, the rows are not copied into the virtual table. Any existing indexes associated with original table, or "original indexes," however, are copied to define a virtual index associated with the virtual table.
- By excluding data when copying the original table to define the virtual table, the associated virtual index may be easily and quickly modified while preserving the overall structure of the original table. New indices may be added and existing indices may be dropped very quickly. Also, if no original index exists, a new virtual index may be easily created.
- In the query, references to the original table are replaced with references to the virtual table. The database management system then determines a new optimization plan for the query. Because the new optimization plan is determined using the virtual table and virtual index, the plan is retrieved much faster than if it were created using the original table and any associated original index. This is because the actual data in the original table was excluded when the original table was copied to define the virtual table. Thus, any changes to the optimization plan may be identified quickly after the indexing design is altered.
- Before the new optimization plan is displayed for the user, any references in the new optimization plan to the virtual table and any virtual index are replaced with the names of the original table and the original index. In this way, the user can compare the new optimization plan with the original optimization plan and analyze the changes without concerning himself with, or even needing to know about, the use of virtual objects in creating the new optimization plan.
-
-
Fig. 1 is a flow diagram of aconventional method 100 for viewing the effect of changes to an index for a database table on an optimization plan for a SQL statement; -
Fig. 2 is a block diagram illustrating an exemplary hardware environment in which exemplary embodiments of the present invention may be implemented; -
Fig. 3 is a block diagram illustrating a system for viewing the effect of changes to an index for a database table on an optimization plan for a database query, according to an exemplary embodiment of the present invention; and -
Fig. 4 is a flow diagram of a method for viewing the effect of changes to an index for a database table on an optimization plan for a database query, in accordance with an exemplary embodiment of the present invention. -
Fig. 2 is a block diagram illustrating an exemplary hardware environment in which exemplary embodiments of the present invention may be implemented. In the hardware environment ofFig. 2 , aclient computer 200 is coupled to aserver computer 202. Both theclient computer 200 andserver computer 202 may include, inter alia, processors, random access memory (RAM), read-only memory (ROM), keyboard, display, fixed and/or removable data storage devices, and data communications devices. - In
Fig. 2 ,server computer 202 is in communication with adatabase 212 which is preferably an Oracle database. As should be appreciated by those skilled in the art, other databases may be used such as Microsoft SQL Server databases, Sybase SQL Server databases, and IBM DB2 databases. - Those skilled in the art will recognize that any combination of the above components described with reference to
Fig. 2 , or any number of different components, peripherals, and other devices, may be used with theclient computer 200 andserver computer 202. Those skilled in the art will also recognize that exemplary embodiments of the present invention may be implemented on a single computer rather than multiple computers networked together. - Exemplary embodiments of the present invention are typically implemented using database management system software, such as the SQL-Station software made and sold by PLATINUM Technology, although it may be implemented with any database management system software such as the Developer/2000 package sold by Oracle or the DB2 product sold by IBM. Moreover, PLATINUM's SQL-Station software, in which exemplary embodiments of the present invention may be realized, may be used in conjunction with other software such as Oracle Developer/2000 software and the DB2 product sold by IBM.
- In
Fig. 2 , the software includes an SQL-Station client program 204 and RelationalExtender client program 206 executed by theclient computer 200. The software further includes anOracle server program 208 andRelational Extender program 210 executed by theserver computer 202. These programs execute under the control of an operating system on theirrespective computers - The SQL-
Station client program 204 and the RelationalExtender client program 206 generate commands for performing various search and retrieval functions, i.e., queries, against thedatabase 212 managed by theOracle server program 208 and the RelationalExtender server program 210. In the preferred embodiment, these queries conform to the SQL standard, although other types of queries could also be used without departing from the scope of the invention. The queries invoke functions performed by theOracle server program 208 and the RelationalExtender server program 210, such as definition, access control, interpretation, compilation, database retrieval, and update of user and system data. - Generally, DBMS software, the SQL queries, and the instructions derived therefrom, are all tangibly embodied in or readable from a computer-readable medium, e.g. one or more data storage devices and/or data communications devices. Moreover, the RDBMS software, the SQL queries, and the instructions derived therefrom, are all comprised of instructions which, when read and executed by the
client computer 200 and/or theserver computer 202, causes theclient computer 200 and/or theserver computer 202 to perform the steps necessary to implement and/or use embodiments of the present invention. -
Fig. 3 is a block diagram illustrating a system for determining the effect of changes to an index for a database table on an optimization plan for a database query, according to an exemplary embodiment of the present invention. There are two users or "schemas" shown, namely "TUTOR" 302 and "PAFO-HR" 304, each of which have access to adatabase 306, which is preferably an Oracle database such as the Oracle 8 database. - In
Fig. 3 , eachuser HR 304 controls original table 308 and an associatedindex 310, as well as virtual table 312 and avirtual index 314 associated with virtual table 312. The tables 308, 312 and the respective associatedindexes - Each
user database 306. Users may, however, be granted various privileges with respect to the accounts of other users. Generally, the privilege may only be granted from one user to another with respect to the one user's account. For example, inFig. 3 , only PAFO-HR 304 has the power to grant privileges on the PAFO-HR 304 account to other users. - One such privilege is "READ," that is, the permission to access information in another user's account. For example, in
Fig. 3 , user PAFO-HR 304 has givenuser TUTOR 302 permission, or granted TUTOR 302 a READ privilege, to access information and objects stored in tables in the PAFO-HR 304 account. Thus,TUTOR 302 is able to query the tables in PAFO-HR's account and access such information in the PAFO-HR 304 account. On the other hand, a third user "SCOTT" (not shown) has not been granted such READ privileges with respect to PAFO-HR's account, so SCOTT cannot access tables controlled by PAFO-HR 304. - Another such privilege available in the system of
Fig. 3 is a "CREATE_TABLE" privilege or set of privileges, which may also be granted from one user to another. The CREATE_TABLE privilege, if granted by the one user, allow other users to create tables in the one user's account, and to store objects in those tables. - Users often do not wish to grant CREATE_TABLE privileges to other users on a database system, because of the broad power it gives other users to unilaterally choose to modify or delete information stored within another user's account. Thus, in the database environment of
Fig. 3 ,TUTOR 302 has not been granted CREATE_TABLE privileges with respect to PAFO-HR's account. - In
Fig. 3 , in accordance with exemplary embodiments of the present invention, a software package entitled "Plan Analyzer for Oracle" ("PAFO") 316 is stored ondatabase 306. This software package is accessible byusers TUTOR 302, thepackage PAFO 316 has CREATE_TABLE privileges with respect to PAFO-HR 304 granted toPAFO 316 along with several other privileges by the Database Administrator (DBA). Thus, a user logged into theTUTOR 302 account who would otherwise not have privileges required to access and experiment with the tables and indices in the PAFO-HR 304 account, may use thePAFO package 316 to accomplish these tasks. - In
Fig. 3 ,TUTOR 302 calls thepackage PAFO 316 to execute methods of the present invention. WhenPAFO 316 is called,PAFO 316 creates and dynamically deploys aprocedure 318 to the PAFO-HR 304 account. The deployedprocedure 318 is then executed in the PAFO-HR 304 account. Deployedprocedure 318 may then grant the necessary privileges for accessing the PAFO-HR 304 account to the user of theTUTOR 302 account. The deployed procedure then grants READ (not write) privileges on the virtual table to TUTOR, the user's account. In this way, TUTOR can access both original table 308 and virtual table 312 without having the CREATE_TABLE privilege. The functionality of deployedprocedure 318 is hereafter described with reference toFigs. 3 and4 . - In
step 402 ofFig. 4 ,procedure 316 identifies original table 308, as referenced inSQL statement 320, and copies original table 308 to define virtual table 312. This copying, instep 402, includes copying the original table statistics to the new table, including the column statistics, histograms, and segment storage. In this way, it appears as if the virtual table contains as many rows of data as the original table. Any actual data in original table 308, however, is preferably excluded from the information copied to define virtual table 312. Thus, for example, when data is stored in rows of original table 308, the rows are not copied into the virtual table 312. - In
step 402, the benefits of creating and working with a copy of the original table are many. Users accessing original table 308 are not disrupted and performance is not degraded by the changes. In a production environment, executing applications are not affected. When Oracle databases are used, nothing in the Oracle catalog needs to be modified for original table 308. Moreover, since the virtual table does not contain any rows, index creation is very fast. - In
step 402, if other original tables are present in the PAFO-HR 304 account, these tables may also copied to define corresponding virtual tables. Also, for reasons which will become apparent below, a list (not shown) is preferably maintained in which the names of virtual tables are correlated with the original tables from which they were created. - In
step 404,virtual index 314, to be associated with virtual table 312, is defined. In this step, if anyoriginal index 310 exists, associated with original table 308,procedure 316 makes copies oforiginal index 310 to definevirtual index 314. For example, if original indices are defined for the two columns shown in original table 308 ofFig. 3 , corresponding virtual indices are created for the two columns shown in virtual table 312 by copying the original indices. - The statistics associated with
original index 310 are also copied intovirtual index 314, and may then be set as specified by the user. In this way, the virtual indices preferably have the same data structures as the original indices, including the same constraints and definitions. Thus, as far as any optimization plan is concerned, the structure of the virtual index is the same as the original index. - In
step 404, if nooriginal index 310 associated with original table 308 exists,virtual index 314 may be created and defined by the user throughprocedure 316. Also, in situations where a user wishes to experiment with no index, the user may simply choose to definevirtual index 314 by deleting any indices present inoriginal index 310, using deployedprocedure 316. At this point,procedure 318 is created on PAFO-HR 304 and executed to grant READ privileges to Tutor 302. - In
step 406, aftervirtual index 314 is defined,PAFO 316 replaces inSQL statement 320 any reference to original table 308 with a reference to virtual table 312. In addition, any reference tooriginal index 310 inSQL statement 320 is switched with the name ofvirtual index 314. - A modified
SQL statement 322 with the replaced names is then sent to the database server. A user ofaccount TUTOR 302 will believe he is accessing original table 308, while actually accessing virtual table 314. Moreover, by creating a copy of the original table and simply changing the name of that object as it is referenced in the SQL statement, the need for the time-consuming and resource-consuming process of creating a new index on the original table is eliminated. - Because the
PAFO program 316 has alteredSQL statement 320 to define modifiedSQL statement 322, the database interprets the modifiedSQL statement 322 to determine thenew optimization plan 324 for the virtual table instep 408. - In
step 410, information innew optimization plan 324 returned by the database server is then modified byPAFO procedure 316 to define a modifiedoptimization plan 326. Specifically, any references innew optimization plan 324 tovirtual index 314 and virtual table 312 are replaced, respectively, with references tooriginal index 310 and original table 308. - The modified
optimization plan 326, with the replaced names, is then displayed to the user instep 412. Thus, to the user, it appears as though he is working only with theoriginal objects - The user may then compare modified
optimization plan 326 with any original optimization plan created for original table 308 andoriginal index 310. If the new optimization plan is more desirable, e.g., appears as if it would improve the speed and efficiency of the database in executingSQL statement 320, the user may then choose to actually buildvirtual index 314 on original table 308. Conversely, if performance would not be improved, the user may experiment with a differentvirtual index 314 or continue usingoriginal index 310 without having wasted the time and resources which would have otherwise been required to constructvirtual index 314. - Each of the functions described above, with respect to
Figs. 3 and4 , can be performed simultaneously by multiple users on the same object. These functions do not interfere with other users of the objects, nor do they have a significant impact on performance, allowing them to be performed on a production system. - In one example, a user is logged onto the
TUTOR 302 account ofFig. 3 . In this example, original table 308 in account PAFO-HR 304 is a table storing the name of employees of a company or firm and, as such, is referred to hereafter as the "EMPLOYEES" table.TUTOR 302 has been granted READ privileges with respect to PAFO-HR's account, soTUTOR 302 is able to send queries to the EMPLOYEES table. - Virtual table 312 has been created for the EMPLOYEES table where the virtual table name is "T_########1."
Original SQL statement 320 is the following: - SELECT *
- FROM hr. employees e
- WHERE hiredate > :H_Date
- The following SQL statement is sent to the server as modified
SQL statement 322, with the original table name "EMPLOYEES" replaced with the virtual table name "T_########1 :" - SELECT *
- FROM hr. T_########1 e
- WHERE hiredate > :H_Date
- If
SQL statement 320 contains optimization hints,PAFO 316 check for hints containing original table name "EMPLOYEES" or one of the indexes associated therewith as parameters to the hints. For instance, assume the user is working with the following SQL statement 320: - SELECT /*+ INDEX (e, I_EMP_HIREDATE) */*
- FROM EMPLOYEES e
- WHERE hiredate > :H_Date
- When the user requests to view the optimization plan for
SQL statement 320, the following message is sent to the database server as modified SQL statement 322: - SELECT /*+ INDEX (e, I_########5) */*
- FROM hr. T_########1 e
- WHERE hiredate > :H_Date
- In the interest of avoiding corruption in the system, each user is preferably only allowed to create a single copy of the EMPLOYEES table to define "T_########1," the virtual table. Each user is preferably restricted from creating a new copy if a copy is already created for that user.
- With the procedures described below, the name of the original table is preferably specified rather than the virtual table name. So, for example, if the user creates a first virtual index on the EMPLOYEES table, the user can create a second virtual index or drop an index on the virtual copy of the EMPLOYEES table, but the table name parameter should be the name of the original table. In the latter case, where the user reuses a virtual table created before, the PAFO package ensures that the index names retrieved still exist on the original table. For example, the following SQL query may be used:
- SELECT index_name FROM expl_indexes
- WHERE owner = :Index_Owner
- AND index_name = :Index_Name
- AND table_name = :Table_Name
- Finally, since only the names of indexes that existed on the original table are generally returned, the virtual indexes created should be queried with a statement such as the following:
- SELECT owner, index_name FROM expl_indexes
- WHERE table_owner = : Virtual_Table_Owner
- AND table_name = Virtual_Table_Name
- AND (owner, index_name)NOT IN
- (('owner1','index1'), ('owner2','index2'),...),
- In this example, the following steps are used for viewing the effect of changes to an index for a database table on an optimization plan for a database query.
- The following procedure may be executed to create the virtual table, assuming a virtual table has not already been created:
- begin
- pafo.explain_virtual.create_virtual_table (:table_owner, :table_name); end;
- If the virtual table already exists, an error condition will be returned. The parameters are defined as follows:
Table 1 Bind Variable Mode Datatype Description table_owner Input VARCHAR2(30) Name of the owner of the original table. This is for whom the virtual table will be created. table name Input VARCHAR2(30) Name of the original table. - In Table 1, VARCHAR2(30) represents a character string of up to 30 characters. Further, MODE = INPUT indicates data being input to the procedure. Conversely, as used in tables below, MODE = OUTPUT represents data being retrieved from the procedure.
- After creating the virtual table, the following procedure may be executed to return the name of the virtual table and the names of the indexes that were copied to define virtual indexes.
- begin
- pafo.explain_virtual.get_virtual_table_aliases (:table_owner, :table_name, :virtual_table_name, :virtual_index_count, :original_index_owners, :original_index_names, :virtual_index_names); end;
- The call of step 2 generally assumes the virtual table was created using the CREATE_VIRTUAL _TABLE procedure. This means that if the virtual table exists in a cluster, that cluster is the same cluster in which the original table exists. That is, the virtual table is not the product of a request to make an unclustered table clustered. Otherwise an error is returned.
- The new virtual index preferably has realistic statistics in order to ensure that an optimization plan is created that is equivalent to having the index created on the original table. EXPLAIN_VIRTUAL provides the procedure DEFAULT_NEW_INDEX_STATS to assist the user in setting the appropriate statistics.
- If the original table has existing indexes, the storage information and statistics of those indexes will be used to generate default storage information and statistics for the virtual index. If the existing indexes are not analyzed, limited default will be available.
- After executing DEFAULT_NEW_INDEX_STATS, the default storage information and statistics are returned to PAFO for display and modification. The user is permitted to change these statistics to better identify the index properties. To help the user decide how to change the statistics, PAFO allows the user to display the statistics on other indexes currently created on the table.
- The following procedure may be executed to obtain the default statistics:
- begin
- pafo.explain_virtual.default_new_index_stats (:table_owner, :table_name, :ind_name, :ind_col_names, :num_ind_columns, :default_tablespace, :init_trans, :max_trans, :pct_free, :btree_levels, :leaf_blocks, :avg_leaf_blocks, :avg_data_blocks, :cluster_factor, :blocks_allocated, :extents_allocated, :distinct_values); end;
- The following error codes may be generated when executing the procedure DEFAULT_NEW_INDEX_STATS. The second column contains a description of error and how, if possible, the user can resolve the error in parenthesis.
Table 4 -20001 User is neither table owner; nor INDEX privilege on table; nor CREATE ANY INDEX privilege. (proper privileges should be obtained.) -20002 Table does not exist. (Check the table name and owner.) -20003 Index already exists with specified columns. (The table already has an index with the requested columns.) -20004 Column______not found. (The index column does not exist.) -20005 Invalid table owner. (The Oracle account entered for the table owner does not exist.) -20006 Index name is not unique. (Enter a different index name for the virtual index.) -20010 First perform CLEAN UP on the table. (The table already has a virtual index created by the user. - The output parameters will be input to the next procedure executed, EXPLAIN_VIRTUAL. CREATE_VIRTUAL_INDEX. Also, note that it is possible the user will attempt to create the index on a tablespace to which the user does not have access.
- Any existing indexes of the original table are preferably copied to define the virtual index. The index statistics and storage information are also copied. To this end, the following procedure may be executed:
- begin
- pafo.explain_virtual.create_virtual_index (:table_owner, :table_name, :ind_name, :ind_col_names, :num_ind_columns, :default_tablespace, :init_trans,:max_trans, :pct_free, :btree_levels, :leaf_blocks, :avg_leaf_blocks, :avg_data_blocks, :cluster_factor, blocks_allocated, :extents_allocated, :distinct_values); end;
- At this point, PAFO creates a new WHAT IF frame as described above displaying the original SQL text. The user is allowed to modify the text and add hints. The "tag" from the SQL frame is copied and the same sequential number is used. For instance, if the SQL Frame label is SQL: HISTORY;1, then the WHAT IF Frame should be labeled, WHAT IF: HISTORY;1.
- When the user requests an optimization plan, PAFO should alter the SQL text that is explained, BUT not on the SQL frame. Nonetheless, the SQL should look like the original SQL statement. Thus, the procedure desirably makes a copy of the SQL text and replace all occurrences of the original table name (:table_name) with the table copy's name (:temp_table_name).
- If the SQL statement uses a synonym (local or public) to point to the original table, the modified SQL text should include both the owner of the virtual table, and the virtual table name. Hint parameters may also need to be changed if the hints reference the table or an index on the table. The plan is then created and retrieved into memory.
- For each OBJECT_OWNER and OBJECT_NAME combination, where the OPERATION column starts with 'TABLE', the temporary table name should be changed to the original name (:table_name).
- For each of the virtual indexes returned in step 2 above, the optimization plan should be searched for these virtual index names and replaced with the original index name. The virtual indexes are identified in the arrays (:original_index_owners, :original_index_names). The associated replacement index names are stored in the array (:virtual_index_names). So PAFO searches each step where the OPERATION column starts with the text "INDEX". If the OBJECT_OWNER and OBJECT_NAME match the ORIGINAL_INDEX_OWNER(0) and VIRTUAL_INDEX_NAME(0) values, the index name should be changed to ORIGINAL_INDEX_NAME(0). This is preferably repeated for each of the array elements.
- The modified plan is then displayed, and the user is informed if the virtual index created had an effect on performance.
- When displaying the information in the "OBJECT" tab, PAFO preferably makes the same changes as described above in steps 4 & 5; that is, PAFO displays the indexes for T ########1, not EMPLOYEES. But PAFO should use the name EMPLOYEES instead of T1 when displaying the information to the user. Also, when displaying the indexes, the associated ORIGINAL_INDEX_NAME values should be displayed.
- When the user clicks on a step of the plan that contains either the virtual table name or one of it's indexes, the statistics for the associated virtual index should be displayed. Thus, the user clicks on EMPLOYEES, the user sees the name EMPLOYEES, but PAFO lists the statistics for T_########1. The same holds true for the indexes on EMPLOYEES.
- The only indexes that can be dropped by this procedure are preferably those belonging to a virtual table. So if a virtual table does not exist, it should be created. The virtual table is created via the procedure CREATE_VIRTUAL_TABLE. Then the user may indicate from which table he wishes to drop an index. The following steps may then be used:
-
- SELECT owner, table_name
- FROM expl_tables
-
- SELECT table_id, new_table_name
- FROM my_explain_virtual_tables
- WHERE orig_table_name = :Table name
- If the query returns a row, then the virtual copy exists. Otherwise, create the virtual table (see step 1 in Creating Virtual Index above).
- List the virtual indexes on the virtual table (see step 2 in Creating Virtual Index above).
- To drop one of the virtual indexes, perform the following procedure:
- begin
- pafo.explain_virtual.drop_virtual_index (:table_owner, :table_name, :virtual_index_name) end;
- To drop a specific virtual table and clean up the associated information in the PAFO repository, the following procedure may be executed:
- begin
- pafo.explain_virtual.clean_up_table (:virtual_table_creator, :original_table_owner, :original_table_name); end;
- To drop all virtual tables, execute the following:
- begin
- pafo.ezplain_virtusl.clean_up_all; end;
Bind Variable | Mode | Datatype | Description |
table_owner | Input | VARCHAR2(30) | Owner of original table |
table_name | Input | VARCNAR2(30) | Name of original table |
virtual_table_name | Output | VARCHAR2(30) | Name used to create the virtual table. |
virtual_index_count | Output | INTEGER | Number of indexes that existed on the original table. Each of these indexes was recreated on the virtual table but with a different name. |
original_index_owners | Output | Array of VARCHAR2(30) | Array of index owners. These names are the same for the original and virtual indexes. (Array size =:virtual index count) |
original_index_names | Output | Array of VARCHAR2(30) | Array of index names. These are the names used on the original table. (Array size=: virtual index count) |
virtual_index_names | Output | Array of VARCHAR2(30) | Array of index names. These are the names used to create the copies of the indexes listed in "original_index_names". There is preferably a 1-1 correspondence between the names in the"original_index_ names" and "virtual_ index_names" arrays. (Array size =: virtual_index_count) |
Parameter | Mode | Datatype | Usage |
table_owner | Input | VARCHAR2(30) | ORACLE account owning the table on which the index will be created. |
table_name | Input | VARCHAR2(30) | Table name. |
ind_name | Input | VARCHAR2(30) | Name of proposed index to create. |
ind_col_names *1 | Input | Array of VARCHAR2(30) | Columns the index will be created for. The order of the columns in the array should match the order requested by the user. |
num_ind_columns | Input | NUMBER | Number of columns; that is, the number of elements in the array, IND_COL_ NAMES. |
default_tablespace | Output | VARCHAR2(30) | Tablespace name on which the index will be created. |
init_trans | Output | NUMBER | INIT_TRANS parameter for creating the index. |
max_trans | Output | NUMBER | MAX_RANS parameter for creating index. |
pct_free | Output | NUMBER | PCT_FREE parameter for creating index. |
btree_levels | Output | NUMBER | Statistic that will be stored with the index. |
leaf_blocks | Output | NUMBER | " |
avg_leaf_blocks | Output | NUMBER | " |
avg_data_blocks | Output | NUMBER | " |
cluster_factor | Output | NUMBER | " |
blocks_allocated | Output | NUMBER | " |
extents_allocated | Output | NUMBER | " |
distinct_values | Output | NUMBER | " |
*1 - ensure that the value for each array element is null terminated and specify in the appropriate OCI bind parameter the array of actual lengths of each element. |
Parameter | Mode | Datatype | Usage |
table_owner | Input | VARCHAR2(30) | ORACLE account owning the original table. |
table_name | Input | VARCHAR2(30) | Name of the original table. |
index_name | Input | VARCHAR2(30) | Name of the virtual index; (EXPLAIN_VIRTUAL_INDEXES. NEW_INDEX _NAME) |
Parameter | Mode | Datatype | Usage |
virtual_table_owner | Input | VARCHAR2(30) | ORACLE account that created the virtual table. |
original_table_owner | Input | VARCHAR2(30) | ORACLE account that owns the original table. |
original_table_name | Input | VARCHAR2(30) | Name of the original table. |
Claims (7)
- A computer-implemented method for viewing changes to an original optimization plan for a query to a database (212), the database (212) having an original table (308) with data stored therein, and the query including a reference to the original table (308),
characterised by the method comprising:defining (402) a virtual table (312) that is a copy of the original table (308) but which excludes data stored in the rows of the original table (308), wherein defining (402) a virtual table (312) includes copying the original table statistics to the virtual table (312), wherein the original table statistics include column statistics, histograms and segment storage;defining (404) a virtual index, the virtual index being an index associated with the virtual table;replacing (406), in the query, the reference to the original table (308) with a reference to the virtual table (312);determining (408) a new optimization plan (324) for the query;replacing (410), in the new optimization plan, a reference to the virtual table (312) with a reference to the original table; anddisplaying (412) the new optimization plan (324). - The method of claim 1, further comprising:adding, to the query, a reference to the virtual index (314).
- The method of claim 1 or claim 2, wherein defining (404) the virtual index (314) includes copying statistics associated with an original index (310) associated with the original table (308).
- A computer program product comprising instructions and data which, when executed by a suitable computer, cause the computer to perform the method of any one of claims 1 to 3.
- An apparatus for viewing changes to an original optimization plan for a query to a database (212), the database (212) being suitable for having an original table (308) with data stored therein, and the query being suitable for including a reference to the original table (308),
characterised by the apparatus comprising:means for defining a virtual table (312) that is a copy of the original table (308) but which excludes data stored in the rows of the original table (308), wherein the means for defining a virtual table (312) is operable to copy the original table statistics to the virtual table (312), wherein the original table statistics include column statistics, histograms and segment storage;means for defining a virtual index, the virtual index being an index associated with the virtual table;means for replacing, in the query, the reference to the original table (308) with a reference to the virtual table (312);means for determining a new optimization plan (324) for the query;means for replacing, in the new optimization plan, a reference to the virtual table (312) with a reference to the original table; andmeans for displaying the new optimization plan. - The apparatus of claim 5, further comprising:means for adding, to the query, a reference to the virtual index (314).
- The apparatus of claim 5 or claim 6, wherein the means for defining a virtual index (314) includes means for copying statistics associated with an original index (310) associated with the original table (308).
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US09/356,797 US6560593B1 (en) | 1999-07-20 | 1999-07-20 | Method and apparatus for viewing the effect of changes to an index for a database table on an optimization plan for a database query |
US356797 | 1999-07-20 | ||
PCT/US2000/040424 WO2001006417A1 (en) | 1999-07-20 | 2000-07-19 | A database system for viewing effects of changes to a index for a query optimization plan |
Publications (3)
Publication Number | Publication Date |
---|---|
EP1206746A1 EP1206746A1 (en) | 2002-05-22 |
EP1206746A4 EP1206746A4 (en) | 2004-09-15 |
EP1206746B1 true EP1206746B1 (en) | 2016-09-07 |
Family
ID=23402992
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
EP00960157.6A Expired - Lifetime EP1206746B1 (en) | 1999-07-20 | 2000-07-19 | A database system for viewing effects of changes to a index for a query optimization plan |
Country Status (12)
Country | Link |
---|---|
US (2) | US6560593B1 (en) |
EP (1) | EP1206746B1 (en) |
JP (1) | JP2003505766A (en) |
KR (1) | KR20020031390A (en) |
CN (1) | CN1361890A (en) |
AU (1) | AU768487B2 (en) |
BR (1) | BR0012684A (en) |
CA (1) | CA2379767A1 (en) |
HK (1) | HK1046177A1 (en) |
IL (2) | IL147694A0 (en) |
WO (1) | WO2001006417A1 (en) |
ZA (1) | ZA200200389B (en) |
Families Citing this family (55)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20040225865A1 (en) * | 1999-09-03 | 2004-11-11 | Cox Richard D. | Integrated database indexing system |
US6938031B1 (en) * | 2001-10-19 | 2005-08-30 | Data Return Llc | System and method for accessing information in a replicated database |
US6938044B1 (en) * | 2001-12-28 | 2005-08-30 | Ncr Corporation | Tracking usage of resources of a database system |
US7587394B2 (en) * | 2003-09-23 | 2009-09-08 | International Business Machines Corporation | Methods and apparatus for query rewrite with auxiliary attributes in query processing operations |
US7606792B2 (en) * | 2004-03-19 | 2009-10-20 | Microsoft Corporation | System and method for efficient evaluation of a query that invokes a table valued function |
EP1759311A2 (en) * | 2004-05-21 | 2007-03-07 | Computer Associates Think, Inc. | Uninterrupted database index reorganization/movement |
US7797286B2 (en) * | 2004-05-21 | 2010-09-14 | Sap Ag | System and method for externally providing database optimizer statistics |
US7711692B2 (en) * | 2004-11-12 | 2010-05-04 | International Business Machines Corporation | Method, system and program product for rewriting view statements in structured query language (SQL) statements |
US20060136380A1 (en) * | 2004-12-17 | 2006-06-22 | Purcell Terence P | System and method for executing a multi-table query |
US7457797B2 (en) * | 2005-03-30 | 2008-11-25 | International Business Machines Corporation | Method and apparatus for associating logical conditions with the re-use of a database query execution strategy |
US7908242B1 (en) * | 2005-04-11 | 2011-03-15 | Experian Information Solutions, Inc. | Systems and methods for optimizing database queries |
US7610265B2 (en) * | 2005-04-29 | 2009-10-27 | Sap Ag | Data query verification |
US7805434B2 (en) * | 2006-01-12 | 2010-09-28 | International Business Machines Corporation | Performing a non-invasive runtime simulation for a database system |
JP4749899B2 (en) * | 2006-03-15 | 2011-08-17 | 株式会社日立ソリューションズ | Table structure determination and notification system |
JP5068062B2 (en) * | 2006-10-30 | 2012-11-07 | インターナショナル・ビジネス・マシーンズ・コーポレーション | System, method, and program for integrating databases |
KR100833540B1 (en) * | 2006-11-30 | 2008-05-29 | 인하대학교 산학협력단 | System and method for query optimization of sliding window aggregates in multiple continuous queries |
KR100778328B1 (en) * | 2007-01-19 | 2007-11-21 | 주식회사 퓨전소프트 | A method of query optimization in database by the use of virtual columns |
CN101021874B (en) * | 2007-03-21 | 2010-05-26 | 金蝶软件（中国）有限公司 | Method and apparatus for optimizing request to poll SQL |
US8285656B1 (en) | 2007-03-30 | 2012-10-09 | Consumerinfo.Com, Inc. | Systems and methods for data verification |
US7761471B1 (en) * | 2007-10-16 | 2010-07-20 | Jpmorgan Chase Bank, N.A. | Document management techniques to account for user-specific patterns in document metadata |
US7970757B2 (en) * | 2008-03-17 | 2011-06-28 | International Business Machines Corporation | Computer program product for database query optimization |
US9189047B2 (en) | 2008-05-08 | 2015-11-17 | International Business Machines Corporation | Organizing databases for energy efficiency |
US8312007B2 (en) * | 2008-05-08 | 2012-11-13 | International Business Machines Corporation | Generating database query plans |
US8312033B1 (en) | 2008-06-26 | 2012-11-13 | Experian Marketing Solutions, Inc. | Systems and methods for providing an integrated identifier |
KR200453964Y1 (en) * | 2008-08-20 | 2011-06-09 | 신유진 | The hair pin equipped with GPS and alarm |
KR101022643B1 (en) * | 2008-11-20 | 2011-03-22 | 서울대학교산학협력단 | Apparatus and method for managing e-catalogs |
US9665620B2 (en) * | 2010-01-15 | 2017-05-30 | Ab Initio Technology Llc | Managing data queries |
US9147042B1 (en) | 2010-11-22 | 2015-09-29 | Experian Information Solutions, Inc. | Systems and methods for data verification |
US9116955B2 (en) | 2011-05-02 | 2015-08-25 | Ab Initio Technology Llc | Managing data queries |
US8635195B2 (en) * | 2011-05-19 | 2014-01-21 | International Business Machines Corporation | Index compression in a database system |
US11030562B1 (en) | 2011-10-31 | 2021-06-08 | Consumerinfo.Com, Inc. | Pre-data breach monitoring |
GB2504716A (en) * | 2012-08-07 | 2014-02-12 | Ibm | A data migration system and method for migrating data objects |
US9342547B2 (en) * | 2012-10-31 | 2016-05-17 | International Business Machines Corporation | Management of memory usage using usage analytics |
CN103049521B (en) * | 2012-12-19 | 2015-11-11 | 广东电子工业研究院有限公司 | Virtual table directory system and the method for many attributes multiple condition searching can be realized |
US9697263B1 (en) | 2013-03-04 | 2017-07-04 | Experian Information Solutions, Inc. | Consumer data request fulfillment system |
US10102536B1 (en) | 2013-11-15 | 2018-10-16 | Experian Information Solutions, Inc. | Micro-geographic aggregation system |
US9529851B1 (en) | 2013-12-02 | 2016-12-27 | Experian Information Solutions, Inc. | Server architecture for electronic data quality processing |
KR102186050B1 (en) | 2013-12-06 | 2020-12-03 | 아브 이니티오 테크놀로지 엘엘시 | Source code translation |
US10262362B1 (en) | 2014-02-14 | 2019-04-16 | Experian Information Solutions, Inc. | Automatic generation of code for attributes |
US10437819B2 (en) | 2014-11-14 | 2019-10-08 | Ab Initio Technology Llc | Processing queries containing a union-type operation |
US10417281B2 (en) | 2015-02-18 | 2019-09-17 | Ab Initio Technology Llc | Querying a data source on a network |
US10628393B2 (en) * | 2015-06-24 | 2020-04-21 | International Business Machines Corporation | Generating data tables |
JP6669571B2 (en) * | 2016-04-19 | 2020-03-18 | 株式会社シスバンク | Tuning apparatus and method for relational database |
AU2018215082B2 (en) | 2017-01-31 | 2022-06-30 | Experian Information Solutions, Inc. | Massive scale heterogeneous data ingestion and user resolution |
CN108460079B (en) * | 2018-01-08 | 2021-03-26 | 平安科技（深圳）有限公司 | Database monitoring method and device, terminal equipment and storage medium |
CN109145004A (en) * | 2018-08-29 | 2019-01-04 | 智慧互通科技有限公司 | A kind of method and device creating database index |
US10963434B1 (en) | 2018-09-07 | 2021-03-30 | Experian Information Solutions, Inc. | Data architecture for supporting multiple search models |
US11196567B2 (en) | 2018-11-26 | 2021-12-07 | Amazon Technologies, Inc. | Cryptographic verification of database transactions |
US11036708B2 (en) * | 2018-11-26 | 2021-06-15 | Amazon Technologies, Inc. | Indexes on non-materialized views |
US11119998B1 (en) | 2018-11-26 | 2021-09-14 | Amazon Technologies, Inc. | Index and view updates in a ledger-based database |
US10942910B1 (en) | 2018-11-26 | 2021-03-09 | Amazon Technologies, Inc. | Journal queries of a ledger-based database |
US11093223B2 (en) | 2019-07-18 | 2021-08-17 | Ab Initio Technology Llc | Automatically converting a program written in a procedural programming language into a dataflow graph and related systems and methods |
US11941065B1 (en) | 2019-09-13 | 2024-03-26 | Experian Information Solutions, Inc. | Single identifier platform for storing entity data |
CN111367892B (en) * | 2020-03-31 | 2024-01-19 | 中国建设银行股份有限公司 | Data migration method and device |
US11880377B1 (en) | 2021-03-26 | 2024-01-23 | Experian Information Solutions, Inc. | Systems and methods for entity resolution |
Family Cites Families (22)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
EP0320266A3 (en) * | 1987-12-11 | 1992-03-11 | Hewlett-Packard Company | View composition in a data base management system |
US5335345A (en) * | 1990-04-11 | 1994-08-02 | Bell Communications Research, Inc. | Dynamic query optimization using partial information |
US5555409A (en) | 1990-12-04 | 1996-09-10 | Applied Technical Sysytem, Inc. | Data management systems and methods including creation of composite views of data |
US5347653A (en) | 1991-06-28 | 1994-09-13 | Digital Equipment Corporation | System for reconstructing prior versions of indexes using records indicating changes between successive versions of the indexes |
US5367675A (en) * | 1991-12-13 | 1994-11-22 | International Business Machines Corporation | Computer automated system and method for optimizing the processing of a query in a relational database system by merging subqueries with the query |
FR2696853B1 (en) * | 1992-10-12 | 1994-12-23 | Bull Sa | Method for helping to optimize a request from a management system, relational database and resulting syntactic analysis method. |
US5301317A (en) * | 1992-04-27 | 1994-04-05 | International Business Machines Corporation | System for adapting query optimization effort to expected execution time |
US5404510A (en) | 1992-05-21 | 1995-04-04 | Oracle Corporation | Database index design based upon request importance and the reuse and modification of similar existing indexes |
FR2696852B1 (en) * | 1992-10-12 | 1994-12-23 | Bull Sa | Method for helping to optimize a request from a relational database management system. |
US5560007A (en) | 1993-06-30 | 1996-09-24 | Borland International, Inc. | B-tree key-range bit map index optimization of database queries |
US5675785A (en) | 1994-10-04 | 1997-10-07 | Hewlett-Packard Company | Data warehouse which is accessed by a user using a schema of virtual tables |
US5671403A (en) * | 1994-12-30 | 1997-09-23 | International Business Machines Corporation | Iterative dynamic programming system for query optimization with bounded complexity |
US5608904A (en) * | 1995-02-13 | 1997-03-04 | Hewlett-Packard Company | Method and apparatus for processing and optimizing queries having joins between structured data and text data |
US5758145A (en) | 1995-02-24 | 1998-05-26 | International Business Machines Corporation | Method and apparatus for generating dynamic and hybrid sparse indices for workfiles used in SQL queries |
US5694591A (en) * | 1995-05-02 | 1997-12-02 | Hewlett Packard Company | Reducing query response time using tree balancing |
US5745904A (en) | 1996-01-12 | 1998-04-28 | Microsoft Corporation | Buffered table user index |
US5765168A (en) | 1996-08-09 | 1998-06-09 | Digital Equipment Corporation | Method for maintaining an index |
US5765147A (en) | 1996-11-21 | 1998-06-09 | International Business Machines Corportion | Query rewrite for extended search capabilities |
US5913207A (en) * | 1997-08-15 | 1999-06-15 | Microsoft Corporation | Database system index selection using index configuration enumeration for a workload |
US5960428A (en) * | 1997-08-28 | 1999-09-28 | International Business Machines Corporation | Star/join query optimization |
US5943666A (en) * | 1997-09-15 | 1999-08-24 | International Business Machines Corporation | Method and apparatus for optimizing queries across heterogeneous databases |
US6006220A (en) * | 1997-09-30 | 1999-12-21 | International Business Machines Corporation | Determining the optimal access path for a query at execution time using an actual value for each variable in a query for estimating a filter factor |
-
1999
- 1999-07-20 US US09/356,797 patent/US6560593B1/en not_active Expired - Lifetime
-
2000
- 2000-07-19 CA CA002379767A patent/CA2379767A1/en not_active Abandoned
- 2000-07-19 IL IL14769400A patent/IL147694A0/en active IP Right Grant
- 2000-07-19 BR BR0012684-5A patent/BR0012684A/en not_active IP Right Cessation
- 2000-07-19 KR KR1020027000823A patent/KR20020031390A/en not_active Application Discontinuation
- 2000-07-19 JP JP2001511602A patent/JP2003505766A/en active Pending
- 2000-07-19 CN CN00810565A patent/CN1361890A/en active Pending
- 2000-07-19 EP EP00960157.6A patent/EP1206746B1/en not_active Expired - Lifetime
- 2000-07-19 AU AU71357/00A patent/AU768487B2/en not_active Ceased
- 2000-07-19 WO PCT/US2000/040424 patent/WO2001006417A1/en active IP Right Grant
-
2001
- 2001-07-06 US US09/900,791 patent/US6898588B2/en not_active Expired - Lifetime
-
2002
- 2002-01-16 ZA ZA200200389A patent/ZA200200389B/en unknown
- 2002-01-17 IL IL147694A patent/IL147694A/en not_active IP Right Cessation
- 2002-10-22 HK HK02107667.5A patent/HK1046177A1/en unknown
Also Published As
Publication number | Publication date |
---|---|
CN1361890A (en) | 2002-07-31 |
JP2003505766A (en) | 2003-02-12 |
EP1206746A4 (en) | 2004-09-15 |
US6560593B1 (en) | 2003-05-06 |
KR20020031390A (en) | 2002-05-01 |
US20020010701A1 (en) | 2002-01-24 |
HK1046177A1 (en) | 2002-12-27 |
AU768487B2 (en) | 2003-12-11 |
BR0012684A (en) | 2002-04-16 |
WO2001006417A1 (en) | 2001-01-25 |
IL147694A (en) | 2007-02-11 |
CA2379767A1 (en) | 2001-01-25 |
EP1206746A1 (en) | 2002-05-22 |
ZA200200389B (en) | 2003-03-26 |
IL147694A0 (en) | 2002-08-14 |
US6898588B2 (en) | 2005-05-24 |
AU7135700A (en) | 2001-02-05 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
EP1206746B1 (en) | A database system for viewing effects of changes to a index for a query optimization plan | |
US6128610A (en) | Index with entries that store the key of a row and all non-key values of the row | |
US5995973A (en) | Storing relationship tables identifying object relationships | |
US6618719B1 (en) | Database system with methodology for reusing cost-based optimization decisions | |
US6366901B1 (en) | Automatic database statistics maintenance and plan regeneration | |
US7289999B2 (en) | Automatic database statistics creation | |
US6631366B1 (en) | Database system providing methodology for optimizing latching/copying costs in index scans on data-only locked tables | |
Bontempo et al. | The IBM data warehouse architecture | |
US6480848B1 (en) | Extension of data definition language (DDL) capabilities for relational databases for applications issuing DML and DDL statements | |
US6301575B1 (en) | Using object relational extensions for mining association rules | |
US6665682B1 (en) | Performance of table insertion by using multiple tables or multiple threads | |
US6119128A (en) | Recovering different types of objects with one pass of the log | |
US6098075A (en) | Deferred referential integrity checking based on determining whether row at-a-time referential integrity checking would yield the same results as deferred integrity checking | |
US20060212436A1 (en) | Rewrite of queries containing rank or rownumber or Min/Max aggregate functions using a materialized view | |
US6289355B1 (en) | Fast log apply | |
US6366902B1 (en) | Using an epoch number to optimize access with rowid columns and direct row access | |
US6343286B1 (en) | Efficient technique to defer large object access with intermediate results | |
WO1999050762A1 (en) | Processing precomputed views | |
Srinivasan et al. | Extensible indexing: a framework for integrating domain-specific indexing schemes into Oracle8i | |
US6775676B1 (en) | Defer dataset creation to improve system manageability for a database system | |
US6453322B1 (en) | Extension of data definition language (DDL) capabilities for relational databases for applications issuing multiple units of work | |
US6421677B1 (en) | Extension of data definition language (DDL) capabilities for relational databases for applications issuing DDL statements | |
Leymann | UDH: A universal relation system | |
Horng et al. | A mechanism for view consistency in a data warehousing system | |
Mittra | Optimization of the External Level of a Database |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PUAI | Public reference made under article 153(3) epc to a published international application that has entered the european phase |
Free format text: ORIGINAL CODE: 0009012 |
|
17P | Request for examination filed |
Effective date: 20020214 |
|
AX | Request for extension of the european patent |
Free format text: AL;LT;LV;MK;RO;SI |
|
RIN1 | Information on inventor provided before grant (corrected) |
Inventor name: VO, HUNG-VUONGInventor name: MENON, SREEKUMARInventor name: KOSCIUSZKO, EDWARD |
|
A4 | Supplementary search report drawn up and despatched |
Effective date: 20040730 |
|
17Q | First examination report despatched |
Effective date: 20041014 |
|
17Q | First examination report despatched |
Effective date: 20041014 |
|
REG | Reference to a national code |
Ref country code: HKRef legal event code: WDRef document number: 1046177Country of ref document: HK |
|
APBK | Appeal reference recorded |
Free format text: ORIGINAL CODE: EPIDOSNREFNE |
|
APBN | Date of receipt of notice of appeal recorded |
Free format text: ORIGINAL CODE: EPIDOSNNOA2E |
|
APBR | Date of receipt of statement of grounds of appeal recorded |
Free format text: ORIGINAL CODE: EPIDOSNNOA3E |
|
APAF | Appeal reference modified |
Free format text: ORIGINAL CODE: EPIDOSCREFNE |
|
RAP1 | Party data changed (applicant data changed or rights of an application transferred) |
Owner name: COMPUTER ASSOCIATES THINK, INC. |
|
RAP1 | Party data changed (applicant data changed or rights of an application transferred) |
Owner name: GOOGLE INC. |
|
APAF | Appeal reference modified |
Free format text: ORIGINAL CODE: EPIDOSCREFNE |
|
APBT | Appeal procedure closed |
Free format text: ORIGINAL CODE: EPIDOSNNOA9E |
|
GRAP | Despatch of communication of intention to grant a patent |
Free format text: ORIGINAL CODE: EPIDOSNIGR1 |
|
INTG | Intention to grant announced |
Effective date: 20160215 |
|
GRAS | Grant fee paid |
Free format text: ORIGINAL CODE: EPIDOSNIGR3 |
|
GRAA | (expected) grant |
Free format text: ORIGINAL CODE: 0009210 |
|
AK | Designated contracting states |
Kind code of ref document: B1Designated state(s): AT BE CH CY DE DK ES FI FR GB GR IE IT LI LU MC NL PT SE |
|
REG | Reference to a national code |
Ref country code: GBRef legal event code: FG4D |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R081Ref document number: 60049452Country of ref document: DEOwner name: GOOGLE LLC (N.D.GES.D. STAATES DELAWARE), MOUN, USFree format text: FORMER OWNER: COMPUTER ASSOCIATES THINK, INC., ISLANDIA, N.Y., US |
|
REG | Reference to a national code |
Ref country code: CHRef legal event code: EP |
|
REG | Reference to a national code |
Ref country code: IERef legal event code: FG4D |
|
REG | Reference to a national code |
Ref country code: ATRef legal event code: REFRef document number: 827430Country of ref document: ATKind code of ref document: TEffective date: 20161015 |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R096Ref document number: 60049452Country of ref document: DE |
|
REG | Reference to a national code |
Ref country code: NLRef legal event code: MPEffective date: 20160907 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: FIFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20160907 |
|
REG | Reference to a national code |
Ref country code: ATRef legal event code: MK05Ref document number: 827430Country of ref document: ATKind code of ref document: TEffective date: 20160907 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: NLFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20160907Ref country code: ESFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20160907Ref country code: GRFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20161208 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: BEFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20160907Ref country code: ATFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20160907Ref country code: PTFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20170109 |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R097Ref document number: 60049452Country of ref document: DE |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: ITFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20160907 |
|
PLBE | No opposition filed within time limit |
Free format text: ORIGINAL CODE: 0009261 |
|
STAA | Information on the status of an ep patent application or granted ep patent |
Free format text: STATUS: NO OPPOSITION FILED WITHIN TIME LIMIT |
|
REG | Reference to a national code |
Ref country code: FRRef legal event code: PLFPYear of fee payment: 18 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: DKFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20160907 |
|
26N | No opposition filed |
Effective date: 20170608 |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R082Ref document number: 60049452Country of ref document: DERepresentative=s name: BETTEN & RESCH PATENT- UND RECHTSANWAELTE PART, DERef country code: DERef legal event code: R081Ref document number: 60049452Country of ref document: DEOwner name: GOOGLE LLC (N.D.GES.D. STAATES DELAWARE), MOUN, USFree format text: FORMER OWNER: GOOGLE INC., MOUNTAIN VIEW, CALIF., US |
|
REG | Reference to a national code |
Ref country code: CHRef legal event code: PL |
|
REG | Reference to a national code |
Ref country code: FRRef legal event code: CDOwner name: GOOGLE INC., USEffective date: 20180213Ref country code: FRRef legal event code: CJEffective date: 20180213 |
|
REG | Reference to a national code |
Ref country code: IERef legal event code: MM4A |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: LIFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20170731Ref country code: IEFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20170719Ref country code: CHFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20170731 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: LUFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20170719 |
|
REG | Reference to a national code |
Ref country code: FRRef legal event code: PLFPYear of fee payment: 19 |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R079Ref document number: 60049452Country of ref document: DEFree format text: PREVIOUS MAIN CLASS: G06F0017300000Ipc: G06F0016000000 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: MCFree format text: LAPSE BECAUSE OF FAILURE TO SUBMIT A TRANSLATION OF THE DESCRIPTION OR TO PAY THE FEE WITHIN THE PRESCRIBED TIME-LIMITEffective date: 20160907 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: SEFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20160907 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: CYFree format text: LAPSE BECAUSE OF NON-PAYMENT OF DUE FEESEffective date: 20160907 |
|
PGFP | Annual fee paid to national office [announced via postgrant information from national office to epo] |
Ref country code: FRPayment date: 20190725Year of fee payment: 20Ref country code: DEPayment date: 20190729Year of fee payment: 20 |
|
PGFP | Annual fee paid to national office [announced via postgrant information from national office to epo] |
Ref country code: GBPayment date: 20190729Year of fee payment: 20 |
|
REG | Reference to a national code |
Ref country code: DERef legal event code: R071Ref document number: 60049452Country of ref document: DE |
|
REG | Reference to a national code |
Ref country code: GBRef legal event code: PE20Expiry date: 20200718 |
|
PG25 | Lapsed in a contracting state [announced via postgrant information from national office to epo] |
Ref country code: GBFree format text: LAPSE BECAUSE OF EXPIRATION OF PROTECTIONEffective date: 20200718 |
|
P01 | Opt-out of the competence of the unified patent court (upc) registered |
Effective date: 20230505 |