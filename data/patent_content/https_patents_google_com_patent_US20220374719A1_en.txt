US20220374719A1 - Application Development Platform and Software Development Kits that Provide Comprehensive Machine Learning Services - Google Patents
Application Development Platform and Software Development Kits that Provide Comprehensive Machine Learning Services Download PDFInfo
- Publication number
- US20220374719A1 US20220374719A1 US17/861,930 US202217861930A US2022374719A1 US 20220374719 A1 US20220374719 A1 US 20220374719A1 US 202217861930 A US202217861930 A US 202217861930A US 2022374719 A1 US2022374719 A1 US 2022374719A1
- Authority
- US
- United States
- Prior art keywords
- model
- training
- models
- learned
- computing system
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Pending
Links
- 238000010801 machine learning Methods 0.000 title claims abstract description 56
- 238000011161 development Methods 0.000 title abstract description 61
- 238000012549 training Methods 0.000 claims description 212
- 238000000034 method Methods 0.000 claims description 56
- 238000003860 storage Methods 0.000 claims description 28
- 230000004913 activation Effects 0.000 claims description 13
- 238000001994 activation Methods 0.000 claims description 13
- 238000012545 processing Methods 0.000 claims description 5
- 238000004883 computer application Methods 0.000 abstract description 11
- 239000008186 active pharmaceutical agent Substances 0.000 description 44
- 238000010586 diagram Methods 0.000 description 34
- 230000006870 function Effects 0.000 description 26
- 238000007906 compression Methods 0.000 description 25
- 230000015654 memory Effects 0.000 description 25
- 239000013598 vector Substances 0.000 description 25
- 230000006835 compression Effects 0.000 description 24
- 230000008569 process Effects 0.000 description 21
- 238000013528 artificial neural network Methods 0.000 description 18
- 238000007726 management method Methods 0.000 description 16
- 238000006243 chemical reaction Methods 0.000 description 15
- 239000010410 layer Substances 0.000 description 14
- 238000013139 quantization Methods 0.000 description 12
- 238000011156 evaluation Methods 0.000 description 11
- 238000002474 experimental method Methods 0.000 description 11
- 238000013527 convolutional neural network Methods 0.000 description 10
- 230000008901 benefit Effects 0.000 description 9
- 238000012360 testing method Methods 0.000 description 8
- 230000010354 integration Effects 0.000 description 7
- 239000011159 matrix material Substances 0.000 description 7
- 230000006403 short-term memory Effects 0.000 description 7
- 238000010200 validation analysis Methods 0.000 description 7
- 238000012905 input function Methods 0.000 description 6
- 238000013138 pruning Methods 0.000 description 6
- 238000004821 distillation Methods 0.000 description 5
- 238000009826 distribution Methods 0.000 description 5
- 230000000694 effects Effects 0.000 description 5
- 238000005457 optimization Methods 0.000 description 5
- 230000008685 targeting Effects 0.000 description 5
- 230000036541 health Effects 0.000 description 4
- 230000000306 recurrent effect Effects 0.000 description 4
- 230000009467 reduction Effects 0.000 description 4
- 230000009466 transformation Effects 0.000 description 4
- 238000004458 analytical method Methods 0.000 description 3
- 238000013459 approach Methods 0.000 description 3
- 238000013434 data augmentation Methods 0.000 description 3
- 238000001514 detection method Methods 0.000 description 3
- 238000004519 manufacturing process Methods 0.000 description 3
- 230000003278 mimic effect Effects 0.000 description 3
- 238000012544 monitoring process Methods 0.000 description 3
- 230000004044 response Effects 0.000 description 3
- 230000004075 alteration Effects 0.000 description 2
- 230000009286 beneficial effect Effects 0.000 description 2
- 230000002860 competitive effect Effects 0.000 description 2
- 238000013523 data management Methods 0.000 description 2
- 238000000354 decomposition reaction Methods 0.000 description 2
- 238000005516 engineering process Methods 0.000 description 2
- 238000009499 grossing Methods 0.000 description 2
- 238000009434 installation Methods 0.000 description 2
- 230000007246 mechanism Effects 0.000 description 2
- 230000003068 static effect Effects 0.000 description 2
- 238000000844 transformation Methods 0.000 description 2
- 238000012935 Averaging Methods 0.000 description 1
- 101100153586 Caenorhabditis elegans top-1 gene Proteins 0.000 description 1
- 101100370075 Mus musculus Top1 gene Proteins 0.000 description 1
- 206010048669 Terminal state Diseases 0.000 description 1
- 230000009471 action Effects 0.000 description 1
- 230000003213 activating effect Effects 0.000 description 1
- 238000007792 addition Methods 0.000 description 1
- 230000002776 aggregation Effects 0.000 description 1
- 238000004220 aggregation Methods 0.000 description 1
- 238000010420 art technique Methods 0.000 description 1
- 238000004140 cleaning Methods 0.000 description 1
- 238000004891 communication Methods 0.000 description 1
- 230000000295 complement effect Effects 0.000 description 1
- 238000004590 computer program Methods 0.000 description 1
- 238000013500 data storage Methods 0.000 description 1
- 238000013079 data visualisation Methods 0.000 description 1
- 230000003247 decreasing effect Effects 0.000 description 1
- 230000001419 dependent effect Effects 0.000 description 1
- 238000013461 design Methods 0.000 description 1
- 230000008451 emotion Effects 0.000 description 1
- 238000010191 image analysis Methods 0.000 description 1
- 230000003993 interaction Effects 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 238000012986 modification Methods 0.000 description 1
- 230000004048 modification Effects 0.000 description 1
- 230000008450 motivation Effects 0.000 description 1
- 238000003058 natural language processing Methods 0.000 description 1
- 230000001537 neural effect Effects 0.000 description 1
- 238000003062 neural network model Methods 0.000 description 1
- 210000002569 neuron Anatomy 0.000 description 1
- 238000012015 optical character recognition Methods 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 238000007670 refining Methods 0.000 description 1
- 238000004088 simulation Methods 0.000 description 1
- 239000002356 single layer Substances 0.000 description 1
- 238000012358 sourcing Methods 0.000 description 1
- 230000005477 standard model Effects 0.000 description 1
- 230000009469 supplementation Effects 0.000 description 1
- 230000001360 synchronised effect Effects 0.000 description 1
- 238000013526 transfer learning Methods 0.000 description 1
- 230000007704 transition Effects 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
- 238000012800 visualization Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/08—Learning methods
- G06N3/084—Backpropagation, e.g. using gradient descent
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F18/00—Pattern recognition
- G06F18/20—Analysing
- G06F18/21—Design or setup of recognition systems or techniques; Extraction of features in feature space; Blind source separation
- G06F18/214—Generating training patterns; Bootstrap methods, e.g. bagging or boosting
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/70—Software maintenance or management
- G06F8/76—Adapting program code to run in a different environment; Porting
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/46—Multiprogramming arrangements
- G06F9/54—Interprogram communication
- G06F9/541—Interprogram communication via adapters, e.g. between incompatible applications
-
- G06K9/6256—
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06N—COMPUTING ARRANGEMENTS BASED ON SPECIFIC COMPUTATIONAL MODELS
- G06N3/00—Computing arrangements based on biological models
- G06N3/02—Neural networks
- G06N3/04—Architecture, e.g. interconnection topology
- G06N3/045—Combinations of networks
Definitions
- the present disclosure relates generally to systems for developing and managing computer applications. More particularly, the present disclosure relates to an application development platform and associated software development kits (“SDKs”) that provide comprehensive services for generation, deployment, and management of machine-learned models used by computer applications such as, for example, mobile applications executed by a mobile computing device.
- SDKs software development kits
- a computer application generally refers to a structured collection of computer-readable instructions that, when executed, cause a computing device to perform certain tasks.
- the computer application can be stored in a memory of the computing device and executed by one or more processors of the computing device.
- Example computer applications include mobile applications and web applications.
- a mobile application generally refers to a computer application that is specifically designed to be executed primarily by a mobile computing device such as a smartphone, tablet, watch, etc.
- a web application generally refers to a computer application which is executed in part by a web server and interfaces with a computing device (e.g., a mobile computing device) via the Internet.
- a computing device e.g., a mobile computing device
- a user can interface with a web application via a mobile web browser executed by a mobile computing device.
- SDKs software development kits
- An SDK can include a set of software development tools that allows the creation of applications for a certain software package, software framework, hardware platform, computer system, operating system, and/or other considerations.
- SDKs can often enable the implementation of one or more application programming interfaces (“APIs”) in the form of on-device libraries which enable the application to interface with other computing applications or systems that provide various services to the application. Further, as recent advances in machine learning become more integrated with and commonly used by various applications, machine learning services add yet another aspect for application developers to consider and implement.
- APIs application programming interfaces
- FIG. 1 depicts a block diagram of an example computing system according to example embodiments of the present disclosure.
- FIG. 2 depicts a stack diagram of an example computing system according to example embodiments of the present disclosure.
- FIG. 3 depicts a functional diagram of an example console according to example embodiments of the present disclosure.
- FIG. 4 depicts a workflow diagram of an example computing system according to example embodiments of the present disclosure.
- FIG. 5 depicts a workflow diagram of an example computing system according to example embodiments of the present disclosure.
- FIG. 6 depicts a flow chart diagram of an example process for generating and deploying machine-learned models according to example embodiments of the present disclosure.
- FIG. 7 depicts a workflow diagram of an example process for generating and deploying machine-learned models according to example embodiments of the present disclosure.
- FIG. 8 depicts a swim lane diagram of an example process to upload machine-learned models for distribution according to example embodiments of the present disclosure.
- FIG. 9 depicts a swim lane diagram of an example process to download machine-learned models according to example embodiments of the present disclosure.
- FIG. 10 depicts a block diagram of an example computing system that includes a fat SDK according to example embodiments of the present disclosure.
- FIG. 11 depicts a block diagram of an example computing system that includes a thin SDK according to example embodiments of the present disclosure.
- FIG. 12 depicts a block diagram of an example computing system that includes mobile vision models as part of an updatable first party support application according to example embodiments of the present disclosure.
- FIG. 13 depicts a block diagram of an example computing system that includes mobile vision, text, and speech models as part of an updatable first party support application according to example embodiments of the present disclosure.
- FIG. 14 depicts a block diagram of an example computing system that includes an updatable first party support application that performs both runtime and training according to example embodiments of the present disclosure.
- FIG. 15 depicts a workflow diagram for an example training pipeline according to example embodiments of the present disclosure.
- FIG. 16A depicts a graphical diagram of an example joint training scheme according to example embodiments of the present disclosure.
- FIG. 16B depicts a graphical diagram of the example joint training scheme used to train multiple student models according to example aspects of the present disclosure.
- FIG. 17 depicts an example user interface according to example embodiments of the present disclosure.
- FIG. 18 depicts an example user interface according to example embodiments of the present disclosure.
- the present disclosure is directed to an application development platform and associated software development kits (“SDKs”) that provide comprehensive services for generation, deployment, and management of machine-learned models used by computer applications such as, for example, mobile applications executed by a mobile computing device.
- SDKs software development kits
- the application development platform and SDKs can provide or otherwise leverage a unified, cross-platform application programming interface (“API”) that enables access to all of the different machine learning services needed for full machine learning functionality within the application.
- API application programming interface
- developers can have access to a single SDK for all machine learning services.
- developers will have a single set of docs, a common way of getting machine learning products, a single console to visit, and a single initialization call to serve all of the application's different machine learning needs.
- the application development platform can enable a developer to generate custom models for their application.
- the developer can upload or otherwise provide access to training data and can then use the application development platform to create and train a machine-learned model for use in conjunction with their application.
- the developer can upload a pre-trained model to the platform.
- the developer can select a pre-trained model from a set of available pre-trained models that are made available to the users of the platform. The developer can use the pre-trained model as-is or can retrain the model on additional training data.
- the application development platform can enable the developer to compress and/or convert the models to optimize the models for use by a resource-constrained device (e.g., mobile or embedded device) or in a resource-constrained environment.
- a resource-constrained device e.g., mobile or embedded device
- compressing the model can include performing quantization (e.g., scalar quantization, vector quantization/weight sharing, product quantization, etc.), pruning (e.g., pruning by values, L1 regularization, etc.), low rank representation (e.g., circulatent matrix, Kronecker structures, SVD decompositions, etc.), distillation, and/or other compression techniques, including a novel learning technique described further herein that directly learns memory- and compute-efficient (e.g., small-sized and fast) machine-learned models that can be directly used for inference on edge devices such as mobile phones, devices able to be worn, and Internet of Things devices.
- quantization e.g., scalar quantization, vector quantization/weight sharing, product quantization, etc.
- pruning e.g., pruning by values, L1 regularization, etc.
- low rank representation e.g., circulatent matrix, Kronecker structures, SVD decompositions, etc.
- distillation e.g., distillation
- aspects of the present disclosure are directed to an end-to-end compression learning framework that allows compression of an input model (e.g., a large pre-trained model) through a learning process in which a compact model is learned based on the input model.
- the compact model can be a ready-to-use on-device model that is smaller in size, more memory-efficient, more power-efficient and faster at inference with minimal loss in accuracy. Additional state-of-the-art techniques for compressing machine-learned models can also be used in combination with the compression learning framework.
- Converting the model can include converting the model from a standard version into a mobile-optimized version that is compatible with a lightweight machine learning library designed specifically for mobile and embedded devices.
- the platform can use a conversion tool known as TensorFlow Lite Optimizing Converter (“TOCO”) to convert a standard TensorFlow graph of a model into a TensorFlow Lite graph, where TensorFlow Lite is a lightweight machine learning library designed for mobile applications.
- TOCO TensorFlow Lite Optimizing Converter
- various conversion tools can optionally be accessed and used to convert a learned or uploaded model into a mobile-optimized version.
- the compression/conversion service can also provide various tools and dashboards to enable the developer to explore and control compression options.
- the tools can show tradeoffs with quality, enable parameter tuning, and/or other controls that allow granular control of the compression outcome.
- the developer can use the compression service to generate multiple models with different sizes and corresponding tradeoffs. These multiple models can be used as part of a model targeting scheme, as described further below.
- the present disclosure provides an end-to-end framework and cloud-based solution and API for learning memory- and compute-efficient (i.e., small-sized and fast) machine-learned models that can be directly used for inference on resource-constrained devices.
- the end-to-end learning framework can be provided as part or a feature of the application development platform described herein.
- the application development platform can employ the end-to-end framework to train a compact machine-learned model that is useful for different problem domains in which a more a complex machine-learned model is typically used.
- the result is an end-to-end cloud-packaged solution that enables developers to easily train their own high-quality custom on-device models.
- This enables developers to directly learn models optimized for size and quality using advanced machine learning technology starting from raw training data or their pretrained model checkpoints (if available).
- the end-to-end learning framework can also be used outside the context of or separate from the application development platform.
- the present disclosure focuses on use of the end-to-end framework in the context of the application development platform, the end-to-end framework is not limited to use within such context.
- the end-to-end framework can enable direct learning of compact custom models, which is different from (but optionally complementary to) other techniques (e.g., quantization) which aim to compress model weights post-training or perform model format conversion (e.g., TOCO).
- the trained compact model can perform in situations involving limited computing power and limited memory for different problem domains that require high computing power and high memory for a complex model.
- the trained compact machine-learned model can perform prediction tasks on a computing device in situations involving limited computing power and limited memory.
- the end-to-end framework can: learn from various input sources; cover a wide range of prediction tasks; support a plurality of use-cases; be powerful in terms of learnable machine-learned models and/or architectures supported; be compatible with infrastructure requirements, such as TensorFlow Lite integration, fast training (e.g., through the use of distributed techniques), access by internal and/or external users (e.g., developers), and platform integration for SDK; and be easily used.
- Infrastructure requirements such as TensorFlow Lite integration, fast training (e.g., through the use of distributed techniques), access by internal and/or external users (e.g., developers), and platform integration for SDK; and be easily used.
- a compact machine-learned model describes a machine-learned model that uses only relatively limited computing power and limited memory, such as a memory- and compute-efficient machine-learned model, or any other suitable machine-learned model with small size and fast computing time.
- a complex machine-learned model describes a machine-learned model that uses relatively higher computing power and higher memory to predict complex tasks, such as feed-forward neural networks, long short-term memory recurrent neural networks, or other machine-learned models with high computational cost.
- a complex machined-learned model may be too large or too cumbersome to effectively run on a resource-constrained computing device.
- the application development platform can be flexible and can enable learning from various inputs and generation of models that predict a wide range of prediction tasks. That is, the end-to-end framework provided by the platform can receive various inputs from a developer and can train a compact model based on and/or which satisfies such inputs.
- an input for training the compact machine-learned model can be data, one or more input functions, and/or one or more parameters defining the compact machine-learned model for training the compact machine-learned model.
- Examples of an input can include labeled data for supervised machine-learned compact model, unlabeled data for compact semi-supervised machine-learned model, pre-trained machine-learned model (which may be used as a trainer model), a desired inference speed, and/or a desired model size.
- One example input source is labeled data.
- the platform can train compact models directly from raw data provided in a format typical for a machine learning library (e.g., tensorflow.Example).
- the platform can also work with unlabeled data in semi-supervised settings.
- Another example input source is a pre-trained model.
- the pre-trained machine-learned model can be larger in size than the compact machine-learned model that will be learned.
- the pre-trained model can be a checkpoint from a production model deployed for cloud-based inference.
- Inference speed can be a flexible parameter in the input space (e.g., definable by the developer).
- the inference speed describes a computational efficiency of the compact machine-learned model to run on a wide range of computing devices (e.g., mobile devices, devices able to be worn, embedded devices, etc.).
- the inference speed can be used to guide a choice of architecture for the compact machine-learned model.
- the inference speed can depend on compute resources available on a specific device.
- Model size can be a flexible parameter in the input space (e.g., definable by the developer).
- the model size describes a size of the compact machine-learned model after the training process completes.
- the application development platform can jointly train multiple compact machine-learned models at different sizes (e.g., small: ⁇ 1-2 million (M), medium: 5-10M, large: >10M) and can make the trained compact machine-learned models available to developers/users so that the users can select a custom-sized model for a particular use-case.
- the application development platform can train the compact machine-learned model to have a differentiable architecture (e.g., either from a family of efficient architecture skeletons or a set of efficient software operations (ops) such as projections, depth-first convolutions, etc.), rather than pre-specifying a model specification.
- a differentiable architecture e.g., either from a family of efficient architecture skeletons or a set of efficient software operations (ops) such as projections, depth-first convolutions, etc.
- the input can further include an indication of the type or class of input.
- Example types of input include text, image, video, multimodal (text combined with image), sensor signals from a computing device (e.g., the device on which the model will be deployed), or some combination thereof.
- the input can further include an indication of the prediction task that will be performed by the trained model.
- Example prediction tasks performed by the compact machine-learned model (and provided as input) can include a classification (e.g., the number of classes can range from small (e.g., binary or 10-100) to large output spaces (e.g., 10 k or 1M categories)); a regression; or a structured prediction (e.g., sequences).
- the application development platform can improve prediction accuracy of the compact machine-learned model by jointly training the compact machine-learned model with a trainer model, which may in some instances, be a pre-trained machine-learned model.
- a pre-trained machine-learned model can be a machine-learned model that is previously trained by the application development platform or by external systems.
- the pre-trained machine-learned model can be larger in size than the compact machine-learned model, such as a checkpoint from a production model deployed on the cloud.
- the pre-trained machine-learned model can be a complex model that needs higher computing power and higher memory than the compact machine-learned model.
- the joint training enables the compact machine-learned model to learn from (and/or with) the trainer model, thereby improving the prediction accuracy of the compact machine-learned model.
- the joint training can follow a teacher-student joint training architecture.
- the application development platform can include and implement a training pipeline to train a compact machine-learned model.
- the training pipeline can train the compact machine-learned model individually and/or jointly train the compact machine-learned model with a trainer model (e.g., pre-trained model).
- a trainer model e.g., pre-trained model.
- the trainer or teacher model can be fixed or can be jointly optimized with the student model.
- the trainer or teacher model can be any type of model, including, as examples, feed forward neural networks, recurrent neural networks (e.g., long short-term memory networks), quasi-RNNs, convolutional neural networks, ProjectionNets (e.g., dense and sparse versions), BiLSTM (bi-directional LSTMs), depth-separable ConvNets, MobileNets, ProjectionCNN, NASNets, Inception (e.g., Inception v3), ResNet, and/or other types of machine-learned models.
- the compact or student model can be any type of model but is typically lighter weight than the trainer model.
- Example student models include feed forward neural networks, recurrent neural networks (e.g., long short-term memory networks), quasi-RNNs, convolutional neural networks, ProjectionNets (e.g., dense and sparse versions), BiLSTM (bi-directional LSTMs), depth-separable ConvNets, MobileNets, ProjectionCNN, NASNets, Inception (e.g., Inception v3), ResNet, and/or other types of machine-learned models.
- recurrent neural networks e.g., long short-term memory networks
- quasi-RNNs convolutional neural networks
- ProjectionNets e.g., dense and sparse versions
- BiLSTM bi-directional LSTMs
- depth-separable ConvNets e.g., MobileNets
- ProjectionCNN e.g., ProjectionCNN
- NASNets e.g., Inception v3
- ResNet e.g., ResNet, and/or
- the training pipeline can receive one or more inputs from users. For instance, the training pipeline can receive training data along with corresponding input functions for training and input functions for evaluation.
- the training pipeline can create a schema to specify how one or more trainings for the compact machine-learned model will proceed.
- the training pipeline can further provide an experiment (e.g., tf Experiment) based API to construct a network.
- the training pipeline can invoke the training (e.g., starting the training in a wrapper code and/or training infra).
- the training pipeline can train the compact model until a desired number of steps is achieved.
- the training pipeline can export the trained compact machine-learned model in a specific format (e.g., TF-Lite format).
- the trained compact machine-learned model can be then used to run on a computing device (e.g., on-device).
- the created schema can include several fields, such as experiment name, features (e.g., name of a field, type of a feature, one or more dimensions of a feature, etc.), hyperparameters (e.g., learning rate, number of steps, optimizer, activation layer, loss weight for a pre-trained model, loss weight for the compact model, cross loss weight, etc.), a model specification of the compact model that contains multiple fields to construct the compact model, a model specification of the pre-trained model that contains multiple fields to construct the pre-trained model.
- features e.g., name of a field, type of a feature, one or more dimensions of a feature, etc.
- hyperparameters e.g., learning rate, number of steps, optimizer, activation layer, loss weight for a pre-trained model, loss weight for the compact model, cross loss weight, etc.
- model specification of the compact model that contains multiple fields to construct the compact model
- model specification of the pre-trained model that contains multiple fields to construct the pre-
- the training pipelines can remove or add fields into a model specification based on ongoing development, and/or new use cases.
- the training pipeline can validate the schema to make sure that the training pipeline behaves as expected. Before starting the pipeline, each of the fields in the schema is validated. Fields in the model specification can be also validated by a validation method of a respective model class.
- the training pipeline can jointly train a compact machine-learned model with a pre-trained machine-learned model.
- the training pipeline can receive the pre-trained machine-learned model, the compact machine-learned model, training data, and/or corresponding input functions.
- the training pipeline can create a schema for specifying how the training will proceed.
- the training pipeline can provide an experiment-based API to specify the joint training.
- the training pipeline can invoke joint training.
- the training pipeline can jointly train the compact machine-learned model with the pre-trained machine-learned model until a joint training loss function indicates that a difference between an output of the compact machine-learned model and an expected output is less than a threshold value.
- the training pipeline can extract and export the trained compact machine-learned model in a specific format.
- the training pipeline can implement and/or store one or more common machine-learned models (e.g., feed forward networks, projection networks, quasi-recurrent neural networks, convolutional neural network, long short-term memory networks, etc.) for joint training.
- common machine-learned models e.g., feed forward networks, projection networks, quasi-recurrent neural networks, convolutional neural network, long short-term memory networks, etc.
- users can select a model that is stored and/or implemented in the training pipeline and can input the selection into the training pipeline.
- the training pipeline can create a schema to specify how the training will proceed with the selected model(s).
- the training pipeline can include one or more debugging metrics such as various losses, accuracy, confusion matrices for pre-trained machine-learned models and compact machine-learned models. In some implementations, these added metrics are apart from other metrics (e.g., metrics along with Tensorboard integration).
- the training pipeline can include example implementations of a wrapper for using tf Estimator API and other plugins. In some implementations, the training pipelines can include integration with TOCO to export the trained compact machine-learned model to TF-Lite format.
- Example uses of compact models generated via the end-to-end framework include: test applications (e.g., MNIST, CIFAR10/CIFAR100), smart reply, handwriting recognition, wear health (e.g., heart rate prediction), wear notification (e.g., content-based classification), text classification/ranking, emotion detection, sensitive content detection, gesture recognition, image classification, and/or multimodal learning (e.g., photo reply).
- test applications e.g., MNIST, CIFAR10/CIFAR100
- smart reply e.g., handwriting recognition
- wear health e.g., heart rate prediction
- wear notification e.g., content-based classification
- text classification/ranking e.g., emotion detection, sensitive content detection, gesture recognition, image classification, and/or multimodal learning (e.g., photo reply).
- the application development platform can enable and perform machine-learned model management. For example, after training, compression, and/or conversion of the model, the developer can use the platform to store the model to a cloud storage database. From the cloud storage database, the developer can use the platform to cause the model to be downloaded to devices that have the developer's application already stored thereon.
- the platform can also enable the developer to perform various other management functions, including, for example, versioning, compatibility, A/B testing, download management, and/or the like.
- the platform can provide and perform a complete, start-to-finish model generation workflow, which can include the platform: receiving an uploaded model or learning a new model based on uploaded training data; automatically compressing the model with benchmarks; converting the model to a mobile-optimized format; and hosting the model for on-device download and usage.
- the custom, third party models can be included in a machine intelligence SDK that forms a portion of the application and communicates with the application using a platform API.
- the machine intelligence SDK can be included in a package of the application that is downloaded from an application marketplace.
- the custom models can be downloaded by the device and can run on-device to provide inferences to the application.
- the application development platform can supports so-called “fat” SDKs, where the service runs in the application process.
- This architecture can provides security and privacy benefits for third party data and models.
- the platform can allow exposing via an API existing on-device models that are not included in the application.
- aspects of the present disclosure also enable out-of-band model updating, where an updated version of the model can be downloaded to the machine intelligence SDK on the device without requiring a re-installation of the application as a whole.
- the models can be downloaded at runtime and inserted into the machine intelligence SDK. Separating download of the models from download of the application as a whole or from download of a more general application update can assist in reducing the size of the application package download or application update download, thereby reducing waiting times and application down time.
- the application development platform can enable the application to leverage first party models that are provided as a feature of the platform.
- the first party models can be included in the machine intelligence SDK as described above.
- the first party models can be included in a first party support application that is separate from the developer's application.
- first and/or third party models can be maintained in the cloud and inferences can be obtained from the models over a network via an API.
- the application development platform can enable an application to access (e.g., to call for inference via an API) both first party models (e.g., general-use models that are provided/maintained by the platform operator) and custom, third party models (e.g., application-specific models that are associated with the specific application developer).
- first party models e.g., general-use models that are provided/maintained by the platform operator
- custom, third party models e.g., application-specific models that are associated with the specific application developer.
- these models can be contained and dynamically updated within a machine intelligence SDK that is included within the application, such that the models provide on-device inference.
- the first party models can be accessed through the use of a base API while the third party models can be accessed via a custom API.
- first party refers to system components (e.g., machine-learned models) that are generally generated, maintained, and/or controlled by the same entity that that operates the platform-at-large.
- entity can also provide access to one or more first party models.
- These first party models can be general-use machine-learned models that provide high quality performance at commonly required tasks such as speech analysis (e.g., natural language processing, voice recognition, and/or the like), text analysis, image analysis (e.g., object detection, barcode/QR code reading, optical character recognition, and/or other tasks which may be categorized as “mobile vision”), and/or the like.
- Another example first party machine-learned model may be a smart reply model (e.g., accessed via an API) that, in response to an input set of text, predicts possible textual replies with which the user may wish to respond.
- third party refers to system components (e.g., machine-learned models) that are produced by an entity other than the entity that operates the platform-at-large.
- third party models may be generated and/or controlled by the application developer.
- the application developer can use aspects of the platform to generate and deploy their own custom machine-learned models.
- third party models may be generated and/or controlled by an additional entity other than the application developer.
- the application developer can use the application development platform to receive models from such additional entity.
- the machine intelligence SDK can further include a dedicated machine learning library that can be implemented by the application to run and/or train the models included in the machine intelligence SDK on-device.
- this machine learning library can be a lightweight library designed for mobile applications (e.g., TensorFlow Lite).
- a copy of the same or different machine learning library can also be included in a first party support application. Models included within the first party support application can be run and/or trained on-device by the first party support application using such copy of the machine learning library.
- the machine intelligence SDK included within the developer's application and/or the first party application can perform on-device data logging.
- This on-device logging can support on-device inference and/or training.
- the machine intelligence SDK can perform validation of training data on-device as part of the logging process.
- the SDK can detect and exclude anomalies from being logged into the training data.
- the on-device training can enable personalization of models based on user-specific data.
- the on-device training can enable participation of the device in a federated learning scheme.
- aspects of the present disclosure are directed to device-wide model training management (e.g. scheduling, storage, etc.).
- batch training can be performed according to scheduling rules.
- the scheduling rules can be default and/or customized according to a developer-specified configuration. As one example, training can occur once per day, at night, and when the device is not actively in use, actively being charged, and connected to a network.
- the logging can also enable on-device performance monitoring.
- the machine intelligence SDK can further perform on-device trained model quality validation (e.g., performance monitoring). These quality statistics can be relayed to the developer via a dashboard offered by the application development platform.
- the platform can also enable the application to receive inference and/or training services via the cloud.
- the developer may be enabled to specify (e.g., for a subset of devices and/or models) whether inference and/or training occurs on-device or via a cloud service. Both of these options can be supported by a single machine intelligence SDK, providing dynamically-controllable flexibility around the location of inference/training.
- different APIs or parameters can be used to support each of the two options.
- the developer can specify rules that handle when inference and/or training should occur on-device or in the cloud and the machine intelligence SDK can implement these rules.
- use of rules can enable the platform to automatically handle transition/balancing between on-device and cloud services (e.g., to implement a workload balancing scheme).
- whether inference and/or training occurs on-device or in the cloud can be transparent to the device user.
- the application development platform can enable further advanced machine learning services, including, for example, versioning, compatibility, A/B testing, download management, and/or various other management functions.
- the application development platform can enable a developer to perform or allow automatic model targeting.
- different versions of machine-learned models can be distributed to different types of devices.
- a larger, more complex model can be distributed to devices with more advanced computing capabilities (e.g., larger memory size, faster processor, etc.) while a smaller, less complex model can be distributed to devices with less advanced computing capabilities.
- model versions can be downloaded to different devices depending on the geolocation of the device (e.g., English language model for United Kingdom versus French language model for France), characteristics of the user of the device (e.g., paid membership versus free trial), and/or other device and/or user attributes.
- the developer can specify rules to govern the model targeting and the platform can implement the rules.
- the platform can enable an optimal version of a model to be sent (e.g., dynamically downloaded) to each different device.
- the application development platform can provide monitoring of and dashboards that display evaluations of models and system health (i.e., a model evaluation service).
- the platform can provide analytics on model usage, performance, download status, and/or other measures.
- Statistics of performance can include descriptions of accuracy, accuracy under curve, precision vs recall, confusion matrix, speed (e.g., #FLOPs, milliseconds per inference), and model size (e.g., before and after compression).
- the analytics can be used by the developer to make decisions regarding model retraining and compression.
- the platform can also provide dashboards that allow the developer to explore system status and health such as model compatibility, availability of stored models, download status, and/or the like. Furthermore, the platform can enable the developer and the devices to ensure (and resolve if needed) backward and forward compatibility of model updates.
- the application development platform can enable a developer to perform A/B experimentation.
- the developer can enable two models to be used for different traffic or different sets of devices.
- the platform can collect the resulting data and can provide analytics that enable the developer to explore the performance statistics and outcomes.
- the systems and methods of the present disclosure provide a number of technical effects and benefits.
- the application development platform and associated SDKs enable the on-device use of mobile-optimized machine-learned models. These mobile-optimized models provide the following benefits: smaller model size; less memory usage; faster computation; and more efficient power utilization, all with competitive model performance.
- application developers may choose to perform inference in the cloud.
- the systems and methods of the present disclosure obviate the need for cloud inference calls, thereby reducing network traffic.
- the systems and methods of the present disclosure can lead to improved model performance including, for example, personalized models and/or models that have been produced through federated learning.
- the systems and methods of the present disclosure enable out-of-band model updating, where an updated version of the model can be dynamically downloaded to the machine intelligence SDK on the device without requiring a re-installation of the application as a whole.
- Separating download of the models from download of the application as a whole or from download of a more general application update can assist in reducing the size of the application package download or application update download, thereby reducing waiting times and application down time.
- updated models can be distributed in a less intrusive manner and with smaller download sizes.
- FIG. 1 depicts a block diagram of an example computing system according to example embodiments of the present disclosure.
- the example computing system includes developer computing devices 130 , an application development computing system 102 , and user computing devices 140 in communication over one or more networks.
- the developer computing devices 130 can be any type of computing device including, as examples, laptops, smartphones, desktops, server computing devices, etc.
- the developer computing devices 130 can include one or more processors and a memory.
- the developer computing devices 130 can be used by application developers to communicate with and/or control an application development platform 116 implemented by the application development computing system 102 .
- the developer computing device 130 can include a dedicated computer program or application that is designed to communicate with and/or control the application development platform 116 .
- the developer computing device 130 can include a browser application that communicates with the application development platform 116 .
- the application development platform 116 can provide services to the developer computing device 130 via the browser application.
- the application development computing system 102 can include one or more processors 112 and a memory 114 .
- the one or more processors 112 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected.
- the memory 114 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof.
- the memory 114 can store data 116 and instructions 118 which are executed by the processor 112 to cause the user computing device 102 to perform operations.
- the application development computing system 102 includes or is otherwise implemented by one or more server computing devices.
- server computing devices can operate according to sequential computing architectures, parallel computing architectures, or some combination thereof.
- the application development computing system 102 provides an application development platform 116 .
- the application development platform 116 can provide comprehensive services for generation, deployment, and management of machine-learned models.
- the application development platform can include a console manager 118 , a model manager 120 , and a machine learning manager 122 .
- the console manager 118 can control and/or manage presentation of a console at the developer computing device 130 , including, for example, tasks like presenting a console interface, modifying the console interface, receiving user input directed to the console interface, etc.
- the console manager 118 can be included in an application stored at the developer computing device 130 , or can include portions at both the developer computing device 130 and the application development computing system 102 .
- the model manager 120 can provide various model management services, including, as examples, a model compression service, a model conversion service, a model evaluation service, model hosting/download management services, and/or other model management services including, for example, versioning, compatibility, and/or A/B testing services.
- a model compression service e.g., a model compression service, a model conversion service, a model evaluation service, model hosting/download management services, and/or other model management services including, for example, versioning, compatibility, and/or A/B testing services.
- the machine learning manager 122 can provide a number of machine learning services such as, for example, a model training service and/or a training data management service.
- the machine learning manager 122 can include and use a machine learning library to train models.
- Example machine learning libraries include the TensorFlow and TensorFlow Lite libraries.
- Each of the console manager 118 , model manager 120 , and machine learning manager 122 includes computer logic utilized to provide desired functionality.
- Each of the console manager 118 , model manager 120 , and machine learning manager 122 can be implemented in hardware, firmware, and/or software controlling a general purpose processor.
- each of the console manager 118 , model manager 120 , and machine learning manager 122 includes program files stored on a storage device, loaded into a memory and executed by one or more processors.
- each of the console manager 118 , model manager 120 , and machine learning manager 122 includes one or more sets of computer-executable instructions that are stored in a tangible computer-readable storage medium such as RAM hard disk or optical or magnetic media.
- the application development platform 116 can be communicatively coupled to one or more databases including, for example, a cloud storage database 124 and/or an application data database 126 .
- the application data database 126 can be a globally-distributed relational and/or non-relational database.
- the databases 124 and 126 can be one database or can be multiple distributed databases.
- the application development platform 116 can also communicate with one or more user computing devices 140 .
- Each user computing device 140 can be any type of computing device including desktop computing devices, server computing devices, mobile computing devices (e.g., smartphones, laptops, tablets, device able to be worn, etc.), embedded devices, smart devices, Internet of Things devices, gaming consoles, computing devices in vehicles, and/or any other form of computing device.
- Each user computing device 140 can include one or more processors (e.g., as described at 112 ) and a memory (e.g., as described at 114 ).
- a user computing device 140 can include an application 142 .
- the application 142 can have been developed by a developer associated with a developer computing device (e.g., through use of the application development platform 116 ).
- the application 142 can include a machine intelligence SDK 144 that is associated with the application development platform.
- the machine intelligence SDK 144 can include computer-readable instructions that enable the application 142 to interface with the application development platform 116 and/or other system components (e.g., via the use of one or more platform APIs).
- the machine intelligence SDK 144 can include one or more machine-learned models 146 and a machine learning library 148 .
- the models 146 can have been downloaded (e.g., dynamically and out-of-band) from the cloud storage 124 (e.g., according to instructions received from the model manager 120 ).
- the machine intelligence SDK 144 can use the machine learning library 148 to run the machine-learned models 146 to produce inferences for the application 142 on the user computing device 140 .
- the user computing device 140 can also include a first party support application 152 .
- the first party support application 152 can be a standalone application or can be provided as a portion of the operating system of the user computing device 140 .
- the first party support application 152 can also include a machine intelligence SDK 154 that is associated with the application development platform.
- the machine intelligence SDK 144 can include computer-readable instructions that enable the application 152 to interface with the application 142 (e.g., the machine intelligence SDK 144 ), the application development platform 116 , and/or other system components (e.g., via the use of one or more platform APIs).
- the machine intelligence SDK 154 can include one or more machine-learned models 156 and a machine learning library 158 .
- the models 158 can have been downloaded (e.g., dynamically and out-of-band) from the cloud storage 124 (e.g., according to instructions received from the model manager 120 ).
- the machine intelligence SDK 154 can use the machine learning library 158 to run the machine-learned models 156 to produce inferences for the application 142 on the user computing device 140 .
- FIG. 2 depicts a stack diagram of an example computing system according to example embodiments of the present disclosure.
- FIG. 2 illustrates a console interface that communicates/interacts with the model manager 120 , machine learning manager 122 , cloud storage database 124 , and application data database 126 via one or more platform APIs.
- the model manager 120 can provide a model compression service, a model conversion service, a model evaluation service and a model hosting service.
- the model compression service and/or model conversion service can enable the developer to compress and/or convert the models to optimize the models for use by a mobile device or in the mobile environment.
- compressing the model can include performing quantization (e.g., scalar quantization, vector quantization/weight sharing, product quantization, etc.), pruning (e.g., pruning by values, L1 regularization, etc.), low rank representation (e.g., circulatent matrix, Kronecker structures, SVD decompositions, etc.), distillation, and/or other compression techniques.
- Pruning reduces model size by removing weights or operations from the model that are least useful for predictions, including, for example, low-scoring weights. This can be very effective especially for on-device models involving sparse inputs. For example, certain on-device conversational models can be pruned further to achieve up-to 2 ⁇ reduction in size with just 25% lower triggering rate while retaining 97% of the original prediction quality.
- Quantization techniques can improve inference speed by reducing the number of bits used for model weights and activations. For example, using 8-bit fixed point representation instead of floats can speed up the model inference, reduce power and reduce size by 4 ⁇ .
- various compression tools can optionally be accessed and used to compress a learned or uploaded model.
- Converting the model can include converting the model from a standard version into a mobile-optimized version that is compatible with a lightweight machine learning library designed specifically for mobile and embedded devices.
- the platform can use a conversion tool known as TensorFlow Lite Optimizing Converter (“TOCO”) to convert a standard TensorFlow graph of a model into a TensorFlow Lite graph, where TensorFlow Lite is a lightweight machine learning library designed for mobile applications.
- TOCO TensorFlow Lite Optimizing Converter
- various conversion tools can optionally be accessed and used to convert a learned or uploaded model into a mobile-optimized version.
- the model evaluation service can provide analytics on model usage, performance (e.g., accuracy, speed, and model size), download status, and/or other measures.
- the analytics can be used by the developer to make decisions regarding model retraining and compression.
- the model evaluation service can also provide dashboards that allow the developer to explore system status and health such as model compatibility, availability of stored models, download status, and/or the like.
- the model evaluation service can enable the developer and the devices to ensure (and resolve if needed) backward and forward compatibility of model updates.
- the model evaluation service can enable a developer to perform A/B experimentation.
- the developer can enable two models to be used for different traffic or different sets of devices.
- the platform can collect the resulting data and can provide analytics that enable the developer to explore the performance statistics and outcomes.
- the model hosting service can enable models to be downloaded to devices (e.g., devices that have the developer's application stored thereon).
- the model hosting service can also enable the developer to perform various other management functions, including, for example, versioning, compatibility, download management, model targeting, and/or the like.
- the machine learning manager 122 can provide a training data management service.
- This service can include a training data flow with comprehensive services including data augmentation, data visualization, data label crowdsourcing, etc.
- Training data augmentation can include data rotation, perturbation, supplementation (e.g., via image searches), etc.
- the machine learning manager 122 can provide a model training service.
- the model training service can perform training and/or re-training of models. For example, standard training techniques can be used to train models based on training data.
- the model training service can perform training techniques provided by the present disclosure that result in learning of compute- or memory-efficient models.
- the model training service can perform a novel training scheme that enables direct learning of a compact machine-learned model.
- the model training service can jointly train the compact machine-learned model with a larger, more complex model in a teacher-student training structure that enables the compact machine-learned model to learn from and approximate the more complex machine-learned model.
- quantization can be applied during training. That is, the model (e.g., network) learns to optimize the weights and activations in the quantized space using gradients computed via backpropagation. This can be more effective than applying this method post training (e.g., quantizing pre-trained weights just for inference).
- Some of the joint training and distillation approaches provided by the present disclosure follow a teacher-student setup where the knowledge of the trainer model is utilized to learn an equivalent compact student model with minimal loss in accuracy.
- the teacher or trainer model parameters can be held fixed (e.g., as in distillation) or jointly optimized to improve both models simultaneously.
- the trainer model can also be jointly trained with multiple student models of different sizes. So instead of providing a single compressed model, the machine learning manager 122 can generate multiple on-device models at different sizes and inference speeds and the developer can select the model that is best suited for their application needs (e.g., provides the most appropriate tradeoff between size and performance). Additionally, jointly training multiple compact models with shared parameters typically takes only slightly more time than training a single large model, but yields multiple compressed/compact models in a single shot that are smaller in size, faster, and have lower cost relative to the more complex model, while still providing good prediction accuracy. These techniques can be combined with other techniques like transfer learning to make the learning/compression process more efficient and scalable to large-scale datasets.
- the machine learning manager 122 can include and implement a training pipeline to train a compact machine-learned model.
- the training pipeline can train the compact machine-learned model individually and/or jointly train the compact machine-learned model with the pre-trained machine-learned model.
- the training pipeline can receive one or more inputs from users. For instance, the training pipeline can receive training data along with corresponding input functions for training and input functions for evaluation.
- the training pipeline can create a schema to specify how one or more trainings for the compact machine-learned model will proceed.
- the training pipeline can further provide an experiment (e.g., tf Experiment) based API to construct a network.
- the training pipeline can invoke the training (e.g., starting the training in a wrapper code and/or training infra).
- the training pipeline can train the compact model until a desired number of steps is achieved.
- the training pipeline can export the trained compact machine-learned model in a specific format (e.g., TF-Lite format).
- the trained compact machine-learned model can be then used to run on a computing device (e.g., on-device).
- the created schema can include several fields, such as experiment name, features (e.g., name of a field, type of a feature, one or more dimensions of a feature, etc.), hyperparameters (e.g., learning rate, number of steps, optimizer, activation layer, loss weight for a pre-trained model, loss weight for the compact model, cross loss weight, etc.), a model specification of the compact model that contains multiple fields to construct the compact model.
- features e.g., name of a field, type of a feature, one or more dimensions of a feature, etc.
- hyperparameters e.g., learning rate, number of steps, optimizer, activation layer, loss weight for a pre-trained model, loss weight for the compact model, cross loss weight, etc.
- model specification can include some or all of the following example information:
- model_type (e.g., “feed forward”, “projection”).
- load_checkpoint If this parameter is set, the model would be loaded from the path which is the value of this parameter.
- freeze_model_from_checkpoint This parameter should only be set to true if load_checkpoint is set. If the value of this parameter is true, gradients would not be backpropagated through this model. This parameter should not be set to true for the pod_model_spec (because it would make no sense to freeze the PoD model, and train the trainer model).
- tflite_output_path If this parameter is set, the pipeline will output this model as a TFLite model (assuming all the ops in the model are supported by TFLite) to the given path.
- pod_model_spec and trainer_model_spec are defined, then the joint training would proceed. If only pod_model_spec is specified, then the pipeline would train an individual model. Specifying only the trainer_model_spec would be an error.
- the training pipeline can remove or add fields into a model specification based on ongoing development, and/or new use cases.
- the training pipeline can validate the schema to make sure that the training pipeline behaves as expected. Before starting the pipeline, each of the fields in the schema can be validated. Fields in the model specification can be also validated by a validation method of a respective model class.
- the training pipeline can implement and/or store one or more common machine-learned models (e.g., feed forward networks, projection networks, quasi-recurrent neural networks, convolutional neural network, long short-term memory networks, etc.) for joint training.
- common machine-learned models e.g., feed forward networks, projection networks, quasi-recurrent neural networks, convolutional neural network, long short-term memory networks, etc.
- users can select a model that is stored and/or implemented in the training pipeline and can input the selection into the training pipeline.
- the training pipeline can create a schema to specify how the training will proceed with the selected model(s).
- the training pipeline can include one or more debugging metrics such as various losses, accuracy, confusion matrices for pre-trained machine-learned models and compact machine-learned models. In some implementations, these added metrics are apart from other metrics (e.g., metrics along with Tensorboard integration).
- the training pipeline can include example implementations of a wrapper for using tf Estimator API and other plugins. In some implementations, the training pipelines can include integration with TOCO to export the trained compact machine-learned model to TF-Lite format.
- FIG. 15 depicts a workflow diagram for an example training pipeline according to example embodiments of the present disclosure.
- the training pipeline validates a DeepPodSpec for shared fields between models (e.g., a compact model and a pre-trained model).
- the training pipeline can invoke a validation method (e.g., respective model-type(s)′ validate method) for validating a model specification of a corresponding model and the training pipeline can error out if this validation does not succeed.
- a validation method e.g., respective model-type(s)′ validate method
- the training pipeline can create a model_fn to be used by a tf Estimator object, which does the follow 1) instantiating respective model classes for each model such that the model performs bookkeeping and sanity checks, 2) invoking the forward_pass method (e.g., create_graph) of each model, 3) constructing and retuning loss function and training operations per predictions from each model and a corresponding specification.
- the training pipeline constructs the tf Estimator based on outputs from the model_fn and/or other flags related to the input in the specification.
- the training pipeline constructs the tf Experiment objects with hooks to call persist for each model.
- the training pipeline returns the tf Experiment object.
- the training pipeline can further convert Trainer GraphDef to inference GraphDef.
- the training pipeline can extract PoD model (if trained jointly) into separate network for inference.
- the training pipeline can convert frozen inference graph to TF-Lite format.
- FIG. 16A depicts a graphical diagram of an example joint training scheme according to example embodiments of the present disclosure.
- a projection network is jointly trained with a trainer network (e.g., feedforward networks, quasi-recurrent neural networks, convolutional neural network, long short-term memory networks, etc.) for learning to mimic predictions made by the trainer network which has far more parameters and hence more predictive capacity.
- the projection network is provided as one example type of model that can be learned compactly as a student model.
- compact models can be jointly learned according to the illustrated training scheme, including, as examples, feed forward neural networks, recurrent neural networks (e.g., long short-term memory networks), quasi-RNNs, convolutional neural networks, ProjectionNets (e.g., dense and sparse versions), BiLSTM (bi-directional LSTMs), depth-separable ConvNets, MobileNets, ProjectionCNN, NASNets, Inception (e.g., Inception v3), ResNet, and/or other types of machine-learned models.
- feed forward neural networks e.g., recurrent neural networks (e.g., long short-term memory networks), quasi-RNNs, convolutional neural networks, ProjectionNets (e.g., dense and sparse versions), BiLSTM (bi-directional LSTMs), depth-separable ConvNets, MobileNets, ProjectionCNN, NASNets, Inception (e.g., Inception v3), ResNet, and/or
- One central aspect of the joint training scheme is a novel objective that jointly trains the two different models—the full trainer model (e.g., using existing architectures like Feed-forward NNs or LSTM RNNs) combined with a simpler student model.
- the student model can be a projection network that leverages random projections to transform inputs or intermediate representations into bits.
- the simpler model can encode lightweight and efficient-to-compute operations in bit space with a low memory footprint.
- the two models can be trained jointly using backpropagation, where the student network learns from the teacher network similar to apprenticeship learning. Once trained, the smaller network can be used directly for inference at low memory and computation cost.
- the student model can optionally leverage any existing deep network like feed-forward or recursive neural network to teach a lightweight model (e.g., projected model) in a joint optimization setup which is trained end-to-end using backpropagation.
- a lightweight model e.g., projected model
- projections based on locality sensitive hashing can be used to represent the hidden units for the lightweight network which encodes operations that are extremely efficient to compute during inference.
- the framework permits efficient distributed training but can be optimized to produce a neural network model with low memory footprint that can run on devices at low computation cost.
- the model size can be parameterized and configurable based on the task or device capacity.
- the framework is effective in achieving significant reduction in model sizes while providing competitive performance on multiple visual and language classification tasks.
- FIG. 16A shows and will be discussed in reference to the framework as applied to train a projection network.
- other model types can be used as the student model other than a projection network.
- the trainer network uses ⁇ right arrow over (x) ⁇ i as an input feature vector to predict a prediction result y i .
- the projection network uses projection functions ( ) to transform the input feature vector ⁇ right arrow over (x) ⁇ i to projected feature vector ⁇ right arrow over (x) ⁇ i p .
- the projection network uses the projected feature vector to predict a prediction result y i p .
- a combination of a loss function ⁇ ( ⁇ ) of the trainer network and a projection loss function P ( ⁇ ) can be optimized such that the projection network can mimic and learn from the trained network.
- a labeled loss ( ⁇ ) is also used for the training.
- the labeled loss ( ⁇ ) can be based on a comparison between the prediction result y i p and a ground truth ⁇ i .
- the transform functions P( ⁇ ) and corresponding trained weights W p , B p from the projection network are extracted to create a compact model that can be pushed to device.
- the compact model and corresponding operations can be then applied to a given input ⁇ right arrow over (x) ⁇ i to generate predictions y i p .
- neural networks are a class of non-linear models that learn a mapping from inputs ⁇ right arrow over (x ⁇ ) ⁇ to outputs y i , where ⁇ right arrow over (x ⁇ ) ⁇ represents an input feature vector or sequence (in the case of recursive neural networks) and y i is an output category for classification tasks, a predicted sequence, a regression value, etc.
- these networks consist of multiple layers of hidden units or neurons with connections between a pair of layers. For example, in a fully-connected feed-forward neural network, the number of weighted connections or network parameters that are trained is O(n 2 ), where n is the number of hidden units per layer.
- Other models can similarly receive the inputs and produce the outputs.
- FIG. 16A illustrates the Neural Projection Network architecture using a feedforward NN for the trainer network.
- the coupled networks are jointly trained to optimize a combined loss function:
- ⁇ ( ⁇ ), p ( ⁇ ) and ( ⁇ ) are the loss functions corresponding to the two models as defined below.
- N indicates the number of training instances in the dataset
- ⁇ right arrow over (x ⁇ ) ⁇ represents the input feature vector in a feed-forward network or sequence input in an RNN
- ⁇ ⁇ refers to the ground-truth output classes used for network training.
- h ⁇ ( ⁇ right arrow over (x ⁇ ) ⁇ ) represents a parameterized representation of the hidden units in the trainer network that transforms ⁇ right arrow over (x ⁇ ) ⁇ to an output prediction y i .
- h p ( ⁇ right arrow over (x ⁇ ) ⁇ ) represents the projection network parameters that transforms the input to corresponding predictions y i p .
- Softmax activation can be applied at the last layer of both networks to compute the predictions y i and y i p .
- D denotes a distance function that measures the prediction error used in the loss functions. This can be decomposed into three parts—trainer prediction error, projection simulation error and projection prediction error. Reducing the first leads to a better trainer network and decreasing the latter in turn learns a better projection network that is simpler but with approximately equivalent predictive capacity.
- cross-entropy can be used for ( ⁇ ).
- ⁇ For the projection Lp in Equation 2, a distillation approach can be followed to optimize ( ⁇ ) since it has been shown to yield better generalization ability than a model trained on just the labels ⁇ i .
- the trainer model can be a full neural network (feed-forward, RNN or CNN) whose choice can be flexible and depends on the task.
- FIG. 16A shows a trainer using feed-forward network but this can be swapped with LSTM RNNs or other models such as deep neural networks.
- the activations for h ⁇ ( ⁇ ) in layer l k+1 can be computed as follows:
- a ⁇ l k + 1 ⁇ ⁇ ( W ⁇ l k + 1 ⁇ A ⁇ l k + B ⁇ l k + 1 ) Eq . ( 3 )
- ⁇ is the ReLU activation function applied at each layer except the last and A indicates the computed activation values for hidden units.
- the number of weights/bias parameters W ⁇ , B ⁇ in this network can be arbitrarily large since this will only be used during the training stage which can be effectively done using high-performance distributed computing with CPUs or GPUs.
- the projection model is a simple network that encodes a set of efficient to-compute operations which will be performed directly on device for inference.
- the model itself defines a set of efficient “projection” functions ( ⁇ right arrow over (x ⁇ ) ⁇ ) that project each input instance ⁇ right arrow over (x ⁇ ) ⁇ to a different space and then performs learning in this space to map it to corresponding outputs y i p .
- a simplified projection network with few operations is used as illustrated in FIG. 16A .
- One example projection network is shown.
- Other structures can be used as well (e.g., additional layers, etc.)
- the inputs ⁇ right arrow over (x ⁇ ) ⁇ are transformed using a series of T projection functions 1 , . . . , T , which can be then followed by a single layer of activations.
- the projection transformations use pre-computed parameterized functions, i.e., they are not trained during the learning process, and their outputs are concatenated to form the hidden units for subsequent operations.
- the simpler projection network learns to choose and apply specific projection operations j (via activations) that are more predictive for a given task. It is possible to stack additional layers connected to the bit-layer in this network to achieve non-linear combinations of projections.
- the projection model can be jointly trained with the trainer and learns to mimic predictions made by the full trainer network which has far more parameters and hence more predictive capacity. Once learning is completed, the transform functions ( ⁇ ) and corresponding trained weights W p , B p from the projection network are extracted to create a lightweight model that can be pushed to device. At inference time, the lightweight model and corresponding operations can be then applied to a given input ⁇ right arrow over (x ⁇ ) ⁇ to generate predictions y i p .
- LSTM RNN models typically apply pruning and use smaller, fixed-size vocabularies in the input encoding step to reduce model complexity.
- the proposed learning method scales efficiently to large data sizes and high dimensional spaces. This is especially useful for natural language applications involving sparse high dimensional feature spaces.
- dense feature spaces e.g., image pixels
- existing operations like fully-connected layers (or even convolutions) can be efficiently approximated for prediction without relying on a large number of parameters.
- Such operations can also be applied in conjunction with the projection functions to yield more complex projection networks while constraining the memory requirements.
- the projection network described earlier relies on a set of transformation functions that project the input ⁇ right arrow over (x ⁇ ) ⁇ into hidden unit representations .
- the projection operations outlined in Equation 4 can be performed using different types of functions.
- One possibility is to use feature embedding matrices pre-trained using word2vec or similar techniques and model as an embedding lookup for features in ⁇ right arrow over (x ⁇ ) ⁇ followed by an aggregation operation such as vector averaging.
- this requires storing the embedding matrices which incurs additional memory complexity.
- LSH Locality sensitive hashing
- x ⁇ ⁇ right arrow over (x ⁇ ) ⁇ or intermediate network layers into hidden unit vectors that are nearby in metric space. This allows transformation of the inputs and learning of an efficient and compact network representation that is only dependent on the inherent dimensionality (i.e., observed features) of the data rather than the number of instances or the dimensionality of the actual data vector (i.e., overall feature or vocabulary size). This can be achieved with binary hash functions for .
- Theorem 1 For ⁇ right arrow over (x ⁇ ) ⁇ , ⁇ right arrow over (x J ) ⁇ ⁇ n and vectors k drawn from a spherically symmetric distribution on n the relation between signs of inner products and the angle ( ⁇ right arrow over (x ⁇ ) ⁇ , ⁇ right arrow over (x J ) ⁇ ) between vectors can be expressed as follows:
- This results in a d-bit vector representation, one bit corresponding to each projection row k 1 . . . d .
- the projection matrix can be fixed prior to training and inference. Note explicit storage of the random projection vector k is not needed since they can be computed on the fly using hash functions rather than invoking a random number generator. In addition, this also permits performance of projection operations that are linear in the observed feature size rather than the overall feature size which can be prohibitively large for high-dimensional data, thereby saving both memory and computation cost.
- the binary representation can be significant since this results in a significantly compact representation for the projection network parameters that in turn reduces the model size considerably compared to the trainer network.
- T and d vary depending on the projection network parameter configuration specified for and can be tuned to trade-off between prediction quality and model size.
- the compact bit units can be used to represent the projection network as described earlier. During training, this network learns to move the gradients for points that are nearby to each other in the projected bit space in the same direction. The direction and magnitude of the gradient can be determined by the trainer network which has access to a larger set of parameters and more complex architecture.
- the two networks are trained jointly using backpropagation. Despite the joint optimization objective, training can progress efficiently with stochastic gradient descent with distributed computing on high-performance CPUs or GPUs.
- the trainer model can be deployed anywhere a standard model can be used.
- the simpler projection network model weights along with transform functions ( ⁇ ) are extracted to create a lightweight model that can be pushed to device.
- This model is used directly “on” device at inference time by applying the same operations in Equations 4, 5 to a new input ⁇ right arrow over (x ⁇ ) ⁇ and generate predictions y i p .
- the projection matrix can instead be used to generate a sparse representation of hidden units in the projection network.
- Each d-bit block can be encoded as an integer instead of a bit vector. This results in a larger parameter space overall O(T ⁇ 2 d ) but can still be beneficial to applications where the actual number of learned parameters can be tiny and inference can be performed via efficient sparse lookup operations.
- Any compact machine-learned model can be jointly trained with any trainer model, including, for example, a pre-trained machine-learned model.
- the trainer model can also be jointly trained with multiple student models of different sizes.
- FIG. 16B depicts a graphical diagram of the example joint training scheme used to train multiple student models according to example aspects of the present disclosure.
- the multiple student models can be
- the compression learning framework described herein has been used in example experimental tests to successfully generate small and fast models with good prediction accuracy suited for mobile applications.
- the compression learning framework was able to generate a model 22 ⁇ smaller than Inception v3 baseline and 4 ⁇ smaller than MobileNet v1 baseline with just 4.6-7% drop in accuracy.
- CIFAR-10 jointly training multiple models with shared parameters as described herein, takes only 10% more time than training a single large model, but yields 3 compressed models that are up to 94 ⁇ smaller in size and up to 27 ⁇ faster with up to 36 ⁇ lower cost and good prediction quality (90-95% top-1 accuracy).
- FIG. 17 depicts an example user interface according to example embodiments of the present disclosure.
- the user interface can be referred to as a Tensorboard.
- the Tensorboard has several options (e.g., scalars, graphs, distributions, histograms, and projectors) to present the training progress.
- “SCALARS” option can be selected to present compact model (also referred to PoD model) accuracy and trainer model accuracy.
- tools to process charts on the right of the user interface are shown on the left of the user interface, such as “Show data download links” to show download links of data associated with the PoD model and/or the trainer model, “Ignore outliers in chart scaling” to remove outliers in the charts on the right of the user interface, “Tooltip sorting method” to allow users to select a method for sorting, “Smoothing” to allow users to select a smoothing level to smooth accuracy curves on the right of the user interface, “Horizontal Axis” to allow users to select a type (e.g., running steps, relative, and wall) of the horizontal of the accuracy curves, and “Runs” to write a regex to filter runs.
- Show data download links to show download links of data associated with the PoD model and/or the trainer model
- “Ignore outliers in chart scaling” to remove outliers in the
- FIG. 18 depicts an example user interface according to example embodiments of the present disclosure.
- “GRAPHS” option is selected.
- a graph on the right of the user interface shows an example structure of the training.
- the structure shows how the joint training of the PoD model and trainer can be performed.
- the structure shows a dataflow from the bottom to the top and shows each function that can be used to jointly train the PoD model and the trainer.
- tools are listed on the left of the user interface. Users can select the tools to process the graph on the right of the user interface. For example, input can be traced by activating “Trace input.”
- the application data database 126 can store model metadata.
- the cloud storage database 124 can store machine-learned models (including both third party models and first party models) and training data.
- the training data can be uploaded by developers and can include validation data. Alternatively or additionally, the training data can be derived from large, public training datasets.
- the console interface can communicate/interact with the model manager 120 , machine learning manager 122 , cloud storage database 124 , and application data database 126 via one or more platform APIs.
- Example APIs are provided in the attached appendices. These APIs are provided as examples only. Different APIs can be used in addition or alternatively to the example APIs.
- Appendix A provides example custom model APIs. Appendix A is incorporated into and forms a part of this specification.
- Appendix B provides example vision model APIs. Appendix B is incorporated into and forms a part of this specification.
- Appendix C provides example vision model APIs. Appendix C is incorporated into and forms a part of this specification.
- FIG. 3 depicts a functional diagram of example console interface modes/states according to example embodiments of the present disclosure.
- a developer can progress through various console interfaces which respectively enable the developer to upload a model, check for compatibility, deploy the model, and then monitor performance of the model.
- the console can provide interfaces that respectively upload training data (e.g., to cloud storage buckets), optionally augment the training data, train and/or compress the model, and then deploy the model and monitor performance.
- training data e.g., to cloud storage buckets
- the console can provide a number of tools or user interfaces that assist the developer in generating the correct machine-learned model.
- the console can provide a set of use cases for developers to choose from, which will determine the target model architecture.
- the console can enable the developer to select or explore accuracy vs model size trade-off requirements.
- FIG. 4 depicts a workflow diagram of an example computing system according to example embodiments of the present disclosure. More particularly, in some implementations, since model compression and/or conversion are long running tasks, they are not handled within the frontend server directly. In such cases, dedicated backend jobs are used to do the processing. FIG. 4 shows one example arrangement of such a system that includes a job scheduler with database queue to handle the job scheduling between the frontend and the backend.
- the developer-provided model may need to be run.
- the process that runs the service can be sandboxed to provide privacy and security.
- a cloud machine learning engine can be used.
- the platform can treat both model compression and conversion as a job.
- the platform frontend server can create a job and insert it to database queue.
- the scheduler can handle the actual job scheduling, while the platform frontend server will keep on polling the status of the job, and report it back to the developer when it enters terminal state.
- the developer can also initiate the query to check the status of their j obs.
- FIG. 5 depicts a workflow diagram of an example computing system according to example embodiments of the present disclosure.
- FIG. 5 depicts an example of a basic device-side flow.
- the application development platform and machine intelligence SDK allow developers to use custom models on the device.
- the API allows the application to perform inference using a custom model that's already on the device, where the developer either manually downloads the model file from somewhere or packages it within the application itself.
- the platform also provides a model file hosting solution that is tightly integrated with the client-side SDK, which will provide the following features: A user interface part of platform console where the developer can manage their models; Model versioning, allowing the developer to specify active (or production) model and/or easily perform rollbacks; Automatically determining uploaded model compatibility with different machine learning library versions and only serving compatible models to compatible devices; and/or First class A/B testing support, allowing the developer to run experiments on different versions of their model.
- FIG. 6 depicts a flow chart diagram of an example process for generating and deploying machine-learned models according to example embodiments of the present disclosure
- FIG. 7 depicts a workflow diagram of an example implementation the example process for generating and deploying machine-learned models according to example embodiments of the present disclosure.
- aspects of the present disclosure are directed to an on-device machine intelligence SDK that forms a part of a cross-platform third party mobile machine learning platform that operates via APIs.
- an on-device machine intelligence SDK that forms a part of a cross-platform third party mobile machine learning platform that operates via APIs.
- training a model for mobile applications is still a big pain point for most developers.
- the training workflows are pretty similar.
- the present disclosure provides tools to facilitate the whole model training workflow on the cloud.
- Step 1 Model selection and design: For the majority of the use cases (e.g., mobile use cases), the training flow starts with a pre-trained model (e.g., Inception v3, MobileNets, etc.).
- the platform can provide access to a set of pre-trained models that cover some typical computer vision use cases and can guarantee to be converted to a mobile-optimized format.
- the set of selectable models can also cover other domains or custom models.
- Step 2 Training data creation: The platform can assist developers to augment and manage their training data. Data augmentation can include adding more training samples (e.g., via an image search), leveraging crowd-sourcing platforms to provide labels, and introducing/or transformations of existing samples (e.g., add noises, rotations, perturbations, etc.). The platform can also provide data cleaning and visualization tools.
- Data augmentation can include adding more training samples (e.g., via an image search), leveraging crowd-sourcing platforms to provide labels, and introducing/or transformations of existing samples (e.g., add noises, rotations, perturbations, etc.).
- the platform can also provide data cleaning and visualization tools.
- the platform provides a number of data format options, including, as examples: Raw data with labels and/or TF.example.
- the platform provides a number of model format options, including, as examples, SavedModel and/or Checkpoint.
- Step 3 Model training: The training can include refining the pre-trained model (e.g., top layer only or more than top layer only). The training can also include fully automated training from scratch. Training can also optionally be done according to a joint training technique described herein.
- Step 4 Model optimization for mobile: Since model size is critical for mobile applications, the platform can provide tools to automatically compress models with evaluation of performance and accuracy. Automatic model optimization can include re-training the model, where training data may be required.
- Step 5 Model conversion for mobile: Once models are obtained that meet the required performance and accuracy, the platform can convert them to a mobile-optimized format ready for deployment.
- the conversion can include several steps (e.g., model freeze, TOCO conversion, etc.) with command line tools. These steps can be streamlined and information about errors can be provided via the platform console.
- the output models from the compression step can automatically be converted to the mobile format.
- the models can be enforced to be in some standard architecture such as, for example, through POD compression (e.g., specified output model architecture).
- Step 6 Model deployment and management:
- the application development platform can provide a targeting mechanism for developers to specify which models should be applied for which application versions, device types, and/or user segments.
- the platform can also provide a compatibility check to make sure models are compatible with the targeted machine learning library runtime.
- the platform can host all the models for the developers and the applications can download/upgrade the models on the fly.
- the developers can also choose to leverage parts of the flow. For example, if the developers already have the model ready for deployment, they can upload their models and make use of step 6 only. If the developers already have a Tensorflow model for cloud inference, they can upload their Tensorflow models and make use of step 4 and/or 5 as well.
- FIG. 8 depicts a swim lane diagram of an example process to upload machine-learned models for distribution according to example embodiments of the present disclosure.
- a user can (e.g., via their browser) initiate a model file upload.
- the platform backend API can create a new object with cloud storage and can return the cloud storage upload URL to the user.
- the user can upload the file to cloud storage and then inform the platform API when the upload has completed.
- the backend API can enqueuer a model compatibility check request.
- a model compatibility service can dequeue the model compatibility check request and can get model information from the backend API.
- the API can return the cloud storage download URL.
- the model compatibility service can download the model file from cloud storage and can check compatibility and extract model metadata.
- the model compatibility service can update the model metadata with compatibility information.
- model compatibility can be implemented as separate, asynchronous service.
- a compatibility check request When model files are uploaded, a compatibility check request will be added to a database queue. The compatibility check service will then asynchronously perform the check.
- the model file may not be available for download until the compatibility check is complete.
- FIG. 9 depicts a swim lane diagram of an example process to download machine-learned models according to example embodiments of the present disclosure.
- a machine intelligence SDK can request the model from the API.
- the API can look up the compatible version, authorize, and then get the download URL from cloud storage.
- the API can return the model information (e.g., download URL) to the machine intelligence SDK.
- the machine intelligence SDK can use the URL to download the model from cloud storage and can cache the downloaded model.
- the SDK can get model information from the API.
- the API can return model information (including a download URL if appropriate).
- the SDK can download the new model, if necessary.
- FIGS. 10-14 depict example computing systems that include various different example implementations of the machine intelligence SDK.
- the machine intelligence SDK can be “fat,” “partially fat,” or “thin.”
- the application development platform allows developers to either bundle the models together with the SDK or to dynamically download models to the SDK.
- the developers can upload their models on the platform console which will get synchronized to and cached on the device. Once on the device, the model is easily accessible to the on-device service via a simple API call.
- the SDK may have “on-device backends” for some of these, i.e. calls to other modules (e.g., first party modules) or applications as part of its implementation (as shown in FIGS. 11-14 ).
- inclusion of all models and services within a single machine intelligence module as shown in FIG. 10 avoids duplicate machine learning library runtimes; optimizes the implementation, and maintains a single stack (e.g., C/C++ stack) for cross-platform usage.
- FIG. 10 depicts a block diagram of an example computing system that includes a fat SDK according to example embodiments of the present disclosure.
- the fat SDK all of the machine intelligence models and services (e.g., vision, speech, text, custom, etc.) are unified into one SDK.
- all of the models and a machine learning library/runtime e.g., TFLite
- a “fat” SDK means that all dependencies are pulled into one fat binary and it is statically linked to the application. Typically, the fat SDK does not update any part dynamically via updates. The fat SDK can interact with first party modules or applications however. A fat SDK avoids any machine learning library compatibility issues.
- a “fat updateable” SDK is similar to a fat SDK (e.g., one fat binary statically linked to the application) except that aspects of the SDK can be dynamically updated without the full application update.
- a fat SDK e.g., one fat binary statically linked to the application
- aspects of the SDK can be dynamically updated without the full application update.
- a “thin” SDK means that the SDK contains only client libraries and depends on the models being run inside first party support modules or applications. These can optionally still be run within the application's process.
- the benefit of thin SDKs is that the application package is smaller in size and implementation of the modules can be shared by multiple applications.
- FIG. 11 depicts a block diagram of an example computing system that includes a thin SDK according to example embodiments of the present disclosure.
- the machine intelligence module may call into other first party modules where applicable to share costs amongst clients.
- the client library can be in the SDK while the implementation is in a first party module or application.
- various possible arrangements can also enable model management, including decisions regarding bundling in versus dynamic downloads.
- the models may be quite large (—MB) so the developer can be enabled to decide whether to go for the simplicity of bundling the models, or dynamically download those.
- the developer can select the appropriate choice.
- the models could be all bundled within the SDK or dynamically downloaded, which may be controlled by the first party. Bundling the models within the SDK provides the following benefits: models available from the application install time; no need to wait for the downloading to happen; less network and power usage; and higher stability, less chance of a compatibility breakage from dynamically downloaded models.
- large first party models can be shared amongst two or more applications.
- the sharing of the models amongst applications can, in one example, be achieved as follows: Make the models part of a first party module (i.e., have a separate updateable module and let it handle models/downloads.
- the first party module is not part of the ‘fat’ or ‘fat updateable’ SDK, but rather is in the ‘thin’ part of the SDK (i.e., the SDK pulls in only the client library of the module).
- the first party module can be exposed to the other parts of the SDK via a first party API.
- Sharing the models amongst applications provides storage benefits/savings. That is, without sharing, redundant versions of the models will be a large hit on the storage (and application package size if bundled or power/data if they are downloaded) of the device.
- the application development platform can distribute SDKs via static frameworks.
- a static framework can be a single statically-linked library coupled with headers (to be used in both Objective C and Swift) and some extra metadata (e.g., a module map). It is also possible to distribute SDKs as dynamically-loaded libraries.
- distribution can occur via CocoaPods, where a CocoaPod is a j son file specifying how to fetch the framework.
- the pod specification can point to a downloadable binary blob or, alternatively, the source code, for example, hosted externally.
- a CocoaPod may contain one or more frameworks, although it is typical to only package one framework in a pod.
- the platform can automate most of the building, testing and deployment pipeline.
- references can just be made to the symbols of the other library and it can be ensured that the user of the library gets both.
- CocoaPods it is easy to achieve.
- Some examples may use several dependencies such as Protobuf.
- the platform's build infrastructure can have provisions to ensure that the dependencies don't get statically linked at build time, preventing duplicate symbol breakages.
- FIG. 12 depicts a block diagram of an example computing system that includes mobile vision models as part of an updatable first party support application according to example embodiments of the present disclosure.
- FIG. 12 depicts an architecture where only mobile vision models are provided via APIs to a first party support application while third party models are included in the machine intelligence SDK.
- FIG. 12 shows an example that is part “fat” and part “updateable” SDK, where the custom models and a TFLite runtime are in the fat part and the mobile vision module (along with its tfmini runtime) is in the updateable part.
- One example reason for having the mobile vision module as thin updateable is to share the storage space and downloading data of all models amongst all apps that use the SDK.
- the custom third party models can be updated through the platform console and cloud storage.
- the platform can provide compatibility tests that can be run from the platform console to help alleviate potential compatibility issues.
- the models can be downloaded due to their size.
- developers can make a choice of bundling in the models or later updating the models via dynamic downloading.
- FIG. 13 depicts a block diagram of an example computing system that includes mobile vision, text, and speech models as part of an updatable first party support application according to example embodiments of the present disclosure. That is, relative to FIG. 12 , in FIG. 13 more base APIs (e.g., text, speech) are included in the support application, possibly each having their own module structure therein. Redundant common runtimes can optionally be removed.
- base APIs e.g., text, speech
- FIG. 14 depicts a block diagram of an example computing system that includes an updatable first party support application that further performs both runtime and training according to example embodiments of the present disclosure. That is, all first party models and modules in the support application use the same runtime in the first party support application, thereby removing redundant runtimes, logging, and downloading of libraries.
- the first party support application can also perform training.
- training can be part of a fat updateable SDK (as opposed to a thin updateable and shared amongst all apps) to provide privacy benefits for application-specific data storage.
- the technology discussed herein makes reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and from such systems.
- the inherent flexibility of computer-based systems allows for a great variety of possible configurations, combinations, and divisions of tasks and functionality between and among components.
- processes discussed herein can be implemented using a single device or component or multiple devices or components working in combination.
- Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
- FIGS. 10-14 are provided as examples only. Many different variations and combinations of these example arrangements can be made according to aspects of the present disclosure.
Abstract
Description
- The present application is based on and claims priority to U.S. Provisional Application 62/509,058 having a filing date of May 20, 2017; U.S. Provisional Application 62/517,635 having a filing date of Jun. 9, 2017; and U.S. Provisional Application 62/667,959 having a filing date of May 7, 2018, which are all incorporated by reference herein.
- The present disclosure relates generally to systems for developing and managing computer applications. More particularly, the present disclosure relates to an application development platform and associated software development kits (“SDKs”) that provide comprehensive services for generation, deployment, and management of machine-learned models used by computer applications such as, for example, mobile applications executed by a mobile computing device.
- A computer application generally refers to a structured collection of computer-readable instructions that, when executed, cause a computing device to perform certain tasks. The computer application can be stored in a memory of the computing device and executed by one or more processors of the computing device.
- Example computer applications include mobile applications and web applications. A mobile application generally refers to a computer application that is specifically designed to be executed primarily by a mobile computing device such as a smartphone, tablet, watch, etc. A web application generally refers to a computer application which is executed in part by a web server and interfaces with a computing device (e.g., a mobile computing device) via the Internet. For example, a user can interface with a web application via a mobile web browser executed by a mobile computing device.
- Developers of computer applications (e.g., mobile applications and/or web applications) often rely on the use of software development kits (“SDKs”) to develop the application. An SDK can include a set of software development tools that allows the creation of applications for a certain software package, software framework, hardware platform, computer system, operating system, and/or other considerations.
- SDKs can often enable the implementation of one or more application programming interfaces (“APIs”) in the form of on-device libraries which enable the application to interface with other computing applications or systems that provide various services to the application. Further, as recent advances in machine learning become more integrated with and commonly used by various applications, machine learning services add yet another aspect for application developers to consider and implement.
- However, tools and services (e.g., machine learning services) for mobile applications are highly fragmented. For example, analysis has shown that, on average, a typical mobile application uses approximately 16 different SDKs. This fragmented nature of services is costly at runtime, as the application/device must load and execute numerous different libraries, thereby expending significant processing and memory resources. In addition, application developers are required to digest different documentation, download and integrate each SDK separately, call the different methods of each different SDK, learn the respective consoles of each SDK, and other tasks, greatly complicating the development process.
- Furthermore, deep neural networks and other complex machine-learned models are being used in countless applications today. However, their accuracy stems in part from having a large number of parameters which incur a high compute overhead. It would be beneficial if these models could be run (and their accuracy benefits received) on mobile and other resource-constrained devices such as smart devices.
- While running these models on mobile devices would be great for multiple reasons (e.g., faster interaction between the user and the application, no need for internet connectivity, data does not need to be sent to the cloud, etc.), there are quite a few challenges. In particular, complex models often require significant network bandwidth to transmit, memory resources to store, and processing resources to run. As such, in certain scenarios, complex models may be too large or resource-intensive to run on a resource-constrained device.
- Detailed discussion of embodiments directed to one of ordinary skill in the art is set forth in the specification, which makes reference to the appended figures, in which:
-
FIG. 1 depicts a block diagram of an example computing system according to example embodiments of the present disclosure. -
FIG. 2 depicts a stack diagram of an example computing system according to example embodiments of the present disclosure. -
FIG. 3 depicts a functional diagram of an example console according to example embodiments of the present disclosure. -
FIG. 4 depicts a workflow diagram of an example computing system according to example embodiments of the present disclosure. -
FIG. 5 depicts a workflow diagram of an example computing system according to example embodiments of the present disclosure. -
FIG. 6 depicts a flow chart diagram of an example process for generating and deploying machine-learned models according to example embodiments of the present disclosure. -
FIG. 7 depicts a workflow diagram of an example process for generating and deploying machine-learned models according to example embodiments of the present disclosure. -
FIG. 8 depicts a swim lane diagram of an example process to upload machine-learned models for distribution according to example embodiments of the present disclosure. -
FIG. 9 depicts a swim lane diagram of an example process to download machine-learned models according to example embodiments of the present disclosure. -
FIG. 10 depicts a block diagram of an example computing system that includes a fat SDK according to example embodiments of the present disclosure. -
FIG. 11 depicts a block diagram of an example computing system that includes a thin SDK according to example embodiments of the present disclosure. -
FIG. 12 depicts a block diagram of an example computing system that includes mobile vision models as part of an updatable first party support application according to example embodiments of the present disclosure. -
FIG. 13 depicts a block diagram of an example computing system that includes mobile vision, text, and speech models as part of an updatable first party support application according to example embodiments of the present disclosure. -
FIG. 14 depicts a block diagram of an example computing system that includes an updatable first party support application that performs both runtime and training according to example embodiments of the present disclosure. -
FIG. 15 depicts a workflow diagram for an example training pipeline according to example embodiments of the present disclosure. -
FIG. 16A depicts a graphical diagram of an example joint training scheme according to example embodiments of the present disclosure. -
FIG. 16B depicts a graphical diagram of the example joint training scheme used to train multiple student models according to example aspects of the present disclosure. -
FIG. 17 depicts an example user interface according to example embodiments of the present disclosure. -
FIG. 18 depicts an example user interface according to example embodiments of the present disclosure. - Generally, the present disclosure is directed to an application development platform and associated software development kits (“SDKs”) that provide comprehensive services for generation, deployment, and management of machine-learned models used by computer applications such as, for example, mobile applications executed by a mobile computing device. In particular, the application development platform and SDKs can provide or otherwise leverage a unified, cross-platform application programming interface (“API”) that enables access to all of the different machine learning services needed for full machine learning functionality within the application. In such fashion, developers can have access to a single SDK for all machine learning services. Thus, developers will have a single set of docs, a common way of getting machine learning products, a single console to visit, and a single initialization call to serve all of the application's different machine learning needs.
- According to one aspect of the present disclosure, the application development platform can enable a developer to generate custom models for their application. In one example, the developer can upload or otherwise provide access to training data and can then use the application development platform to create and train a machine-learned model for use in conjunction with their application. In another example, the developer can upload a pre-trained model to the platform. In yet another example, the developer can select a pre-trained model from a set of available pre-trained models that are made available to the users of the platform. The developer can use the pre-trained model as-is or can retrain the model on additional training data.
- Further, after training of the model or, in some implementations, as part of the training process itself, the application development platform can enable the developer to compress and/or convert the models to optimize the models for use by a resource-constrained device (e.g., mobile or embedded device) or in a resource-constrained environment. For example, compressing the model can include performing quantization (e.g., scalar quantization, vector quantization/weight sharing, product quantization, etc.), pruning (e.g., pruning by values, L1 regularization, etc.), low rank representation (e.g., circulatent matrix, Kronecker structures, SVD decompositions, etc.), distillation, and/or other compression techniques, including a novel learning technique described further herein that directly learns memory- and compute-efficient (e.g., small-sized and fast) machine-learned models that can be directly used for inference on edge devices such as mobile phones, devices able to be worn, and Internet of Things devices. Thus, various compression tools can optionally be accessed and used to compress a learned or uploaded model.
- More particularly, aspects of the present disclosure are directed to an end-to-end compression learning framework that allows compression of an input model (e.g., a large pre-trained model) through a learning process in which a compact model is learned based on the input model. The compact model can be a ready-to-use on-device model that is smaller in size, more memory-efficient, more power-efficient and faster at inference with minimal loss in accuracy. Additional state-of-the-art techniques for compressing machine-learned models can also be used in combination with the compression learning framework.
- Converting the model can include converting the model from a standard version into a mobile-optimized version that is compatible with a lightweight machine learning library designed specifically for mobile and embedded devices. In one example, the platform can use a conversion tool known as TensorFlow Lite Optimizing Converter (“TOCO”) to convert a standard TensorFlow graph of a model into a TensorFlow Lite graph, where TensorFlow Lite is a lightweight machine learning library designed for mobile applications. Thus, various conversion tools can optionally be accessed and used to convert a learned or uploaded model into a mobile-optimized version.
- The compression/conversion service can also provide various tools and dashboards to enable the developer to explore and control compression options. For example, the tools can show tradeoffs with quality, enable parameter tuning, and/or other controls that allow granular control of the compression outcome. For example, the developer can use the compression service to generate multiple models with different sizes and corresponding tradeoffs. These multiple models can be used as part of a model targeting scheme, as described further below.
- According to another aspect of the present disclosure, as mentioned above, the present disclosure provides an end-to-end framework and cloud-based solution and API for learning memory- and compute-efficient (i.e., small-sized and fast) machine-learned models that can be directly used for inference on resource-constrained devices. In particular, in some implementations, the end-to-end learning framework can be provided as part or a feature of the application development platform described herein. Thus, the application development platform can employ the end-to-end framework to train a compact machine-learned model that is useful for different problem domains in which a more a complex machine-learned model is typically used.
- When the end-to-end learning framework is combined with or provided as a feature of the application development platform, the result is an end-to-end cloud-packaged solution that enables developers to easily train their own high-quality custom on-device models. This enables developers to directly learn models optimized for size and quality using advanced machine learning technology starting from raw training data or their pretrained model checkpoints (if available). However, the end-to-end learning framework can also be used outside the context of or separate from the application development platform. Thus, although the present disclosure focuses on use of the end-to-end framework in the context of the application development platform, the end-to-end framework is not limited to use within such context.
- Thus, the end-to-end framework can enable direct learning of compact custom models, which is different from (but optionally complementary to) other techniques (e.g., quantization) which aim to compress model weights post-training or perform model format conversion (e.g., TOCO). The trained compact model can perform in situations involving limited computing power and limited memory for different problem domains that require high computing power and high memory for a complex model. As such, the trained compact machine-learned model can perform prediction tasks on a computing device in situations involving limited computing power and limited memory.
- The end-to-end framework can: learn from various input sources; cover a wide range of prediction tasks; support a plurality of use-cases; be powerful in terms of learnable machine-learned models and/or architectures supported; be compatible with infrastructure requirements, such as TensorFlow Lite integration, fast training (e.g., through the use of distributed techniques), access by internal and/or external users (e.g., developers), and platform integration for SDK; and be easily used.
- In some implementations, a compact machine-learned model describes a machine-learned model that uses only relatively limited computing power and limited memory, such as a memory- and compute-efficient machine-learned model, or any other suitable machine-learned model with small size and fast computing time. A complex machine-learned model describes a machine-learned model that uses relatively higher computing power and higher memory to predict complex tasks, such as feed-forward neural networks, long short-term memory recurrent neural networks, or other machine-learned models with high computational cost. In some particular scenarios, a complex machined-learned model may be too large or too cumbersome to effectively run on a resource-constrained computing device.
- According to one aspect of the present disclosure, the application development platform can be flexible and can enable learning from various inputs and generation of models that predict a wide range of prediction tasks. That is, the end-to-end framework provided by the platform can receive various inputs from a developer and can train a compact model based on and/or which satisfies such inputs.
- In some implementations, an input for training the compact machine-learned model can be data, one or more input functions, and/or one or more parameters defining the compact machine-learned model for training the compact machine-learned model. Examples of an input can include labeled data for supervised machine-learned compact model, unlabeled data for compact semi-supervised machine-learned model, pre-trained machine-learned model (which may be used as a trainer model), a desired inference speed, and/or a desired model size.
- One example input source is labeled data. For example, the platform can train compact models directly from raw data provided in a format typical for a machine learning library (e.g., tensorflow.Example). The platform can also work with unlabeled data in semi-supervised settings. Another example input source is a pre-trained model. For example, the pre-trained machine-learned model can be larger in size than the compact machine-learned model that will be learned. In one example, the pre-trained model can be a checkpoint from a production model deployed for cloud-based inference.
- Inference speed can be a flexible parameter in the input space (e.g., definable by the developer). The inference speed describes a computational efficiency of the compact machine-learned model to run on a wide range of computing devices (e.g., mobile devices, devices able to be worn, embedded devices, etc.). The inference speed can be used to guide a choice of architecture for the compact machine-learned model. The inference speed can depend on compute resources available on a specific device.
- Model size can be a flexible parameter in the input space (e.g., definable by the developer). The model size describes a size of the compact machine-learned model after the training process completes. In some implementations, the application development platform can jointly train multiple compact machine-learned models at different sizes (e.g., small: <1-2 million (M), medium: 5-10M, large: >10M) and can make the trained compact machine-learned models available to developers/users so that the users can select a custom-sized model for a particular use-case. In some implementations, the application development platform can train the compact machine-learned model to have a differentiable architecture (e.g., either from a family of efficient architecture skeletons or a set of efficient software operations (ops) such as projections, depth-first convolutions, etc.), rather than pre-specifying a model specification.
- In some implementations, the input can further include an indication of the type or class of input. Example types of input include text, image, video, multimodal (text combined with image), sensor signals from a computing device (e.g., the device on which the model will be deployed), or some combination thereof.
- In some implementations, the input can further include an indication of the prediction task that will be performed by the trained model. Example prediction tasks performed by the compact machine-learned model (and provided as input) can include a classification (e.g., the number of classes can range from small (e.g., binary or 10-100) to large output spaces (e.g., 10 k or 1M categories)); a regression; or a structured prediction (e.g., sequences).
- According to another aspect of the present disclosure, the application development platform can improve prediction accuracy of the compact machine-learned model by jointly training the compact machine-learned model with a trainer model, which may in some instances, be a pre-trained machine-learned model. A pre-trained machine-learned model can be a machine-learned model that is previously trained by the application development platform or by external systems. The pre-trained machine-learned model can be larger in size than the compact machine-learned model, such as a checkpoint from a production model deployed on the cloud. In some implementations, the pre-trained machine-learned model can be a complex model that needs higher computing power and higher memory than the compact machine-learned model.
- The joint training enables the compact machine-learned model to learn from (and/or with) the trainer model, thereby improving the prediction accuracy of the compact machine-learned model. Thus, the joint training can follow a teacher-student joint training architecture.
- Thus, in some implementations, the application development platform can include and implement a training pipeline to train a compact machine-learned model. The training pipeline can train the compact machine-learned model individually and/or jointly train the compact machine-learned model with a trainer model (e.g., pre-trained model). Thus, the trainer or teacher model can be fixed or can be jointly optimized with the student model.
- The trainer or teacher model can be any type of model, including, as examples, feed forward neural networks, recurrent neural networks (e.g., long short-term memory networks), quasi-RNNs, convolutional neural networks, ProjectionNets (e.g., dense and sparse versions), BiLSTM (bi-directional LSTMs), depth-separable ConvNets, MobileNets, ProjectionCNN, NASNets, Inception (e.g., Inception v3), ResNet, and/or other types of machine-learned models. The compact or student model can be any type of model but is typically lighter weight than the trainer model. Example student models include feed forward neural networks, recurrent neural networks (e.g., long short-term memory networks), quasi-RNNs, convolutional neural networks, ProjectionNets (e.g., dense and sparse versions), BiLSTM (bi-directional LSTMs), depth-separable ConvNets, MobileNets, ProjectionCNN, NASNets, Inception (e.g., Inception v3), ResNet, and/or other types of machine-learned models.
- In some implementations, the training pipeline can receive one or more inputs from users. For instance, the training pipeline can receive training data along with corresponding input functions for training and input functions for evaluation. The training pipeline can create a schema to specify how one or more trainings for the compact machine-learned model will proceed. The training pipeline can further provide an experiment (e.g., tf Experiment) based API to construct a network. The training pipeline can invoke the training (e.g., starting the training in a wrapper code and/or training infra).
- The training pipeline can train the compact model until a desired number of steps is achieved. The training pipeline can export the trained compact machine-learned model in a specific format (e.g., TF-Lite format). In some implementations, the trained compact machine-learned model can be then used to run on a computing device (e.g., on-device).
- In some implementations, the created schema can include several fields, such as experiment name, features (e.g., name of a field, type of a feature, one or more dimensions of a feature, etc.), hyperparameters (e.g., learning rate, number of steps, optimizer, activation layer, loss weight for a pre-trained model, loss weight for the compact model, cross loss weight, etc.), a model specification of the compact model that contains multiple fields to construct the compact model, a model specification of the pre-trained model that contains multiple fields to construct the pre-trained model.
- In some implementations, the training pipelines can remove or add fields into a model specification based on ongoing development, and/or new use cases. In some implementations, the training pipeline can validate the schema to make sure that the training pipeline behaves as expected. Before starting the pipeline, each of the fields in the schema is validated. Fields in the model specification can be also validated by a validation method of a respective model class.
- In some implementations, the training pipeline can jointly train a compact machine-learned model with a pre-trained machine-learned model. For instance, the training pipeline can receive the pre-trained machine-learned model, the compact machine-learned model, training data, and/or corresponding input functions. The training pipeline can create a schema for specifying how the training will proceed. The training pipeline can provide an experiment-based API to specify the joint training. The training pipeline can invoke joint training.
- The training pipeline can jointly train the compact machine-learned model with the pre-trained machine-learned model until a joint training loss function indicates that a difference between an output of the compact machine-learned model and an expected output is less than a threshold value. The training pipeline can extract and export the trained compact machine-learned model in a specific format.
- In some implementations, the training pipeline can implement and/or store one or more common machine-learned models (e.g., feed forward networks, projection networks, quasi-recurrent neural networks, convolutional neural network, long short-term memory networks, etc.) for joint training. As such, instead of inputting the pre-trained machine-learned model or a custom compact model specification, users can select a model that is stored and/or implemented in the training pipeline and can input the selection into the training pipeline. In response to the user's selection, the training pipeline can create a schema to specify how the training will proceed with the selected model(s).
- In some implementations, the training pipeline can include one or more debugging metrics such as various losses, accuracy, confusion matrices for pre-trained machine-learned models and compact machine-learned models. In some implementations, these added metrics are apart from other metrics (e.g., metrics along with Tensorboard integration). In some implementations, the training pipeline can include example implementations of a wrapper for using tf Estimator API and other plugins. In some implementations, the training pipelines can include integration with TOCO to export the trained compact machine-learned model to TF-Lite format.
- Example uses of compact models generated via the end-to-end framework include: test applications (e.g., MNIST, CIFAR10/CIFAR100), smart reply, handwriting recognition, wear health (e.g., heart rate prediction), wear notification (e.g., content-based classification), text classification/ranking, emotion detection, sensitive content detection, gesture recognition, image classification, and/or multimodal learning (e.g., photo reply).
- According to another aspect of the present disclosure, the application development platform can enable and perform machine-learned model management. For example, after training, compression, and/or conversion of the model, the developer can use the platform to store the model to a cloud storage database. From the cloud storage database, the developer can use the platform to cause the model to be downloaded to devices that have the developer's application already stored thereon. The platform can also enable the developer to perform various other management functions, including, for example, versioning, compatibility, A/B testing, download management, and/or the like.
- Thus, the platform can provide and perform a complete, start-to-finish model generation workflow, which can include the platform: receiving an uploaded model or learning a new model based on uploaded training data; automatically compressing the model with benchmarks; converting the model to a mobile-optimized format; and hosting the model for on-device download and usage.
- According to another aspect of the present disclosure, in some implementations, the custom, third party models can be included in a machine intelligence SDK that forms a portion of the application and communicates with the application using a platform API. For example, the machine intelligence SDK can be included in a package of the application that is downloaded from an application marketplace. Thus, the custom models can be downloaded by the device and can run on-device to provide inferences to the application.
- Thus, in some implementations, the application development platform can supports so-called “fat” SDKs, where the service runs in the application process. This architecture can provides security and privacy benefits for third party data and models. Alternatively, as will be described further below, the platform can allow exposing via an API existing on-device models that are not included in the application.
- Aspects of the present disclosure also enable out-of-band model updating, where an updated version of the model can be downloaded to the machine intelligence SDK on the device without requiring a re-installation of the application as a whole. In other implementations, the models can be downloaded at runtime and inserted into the machine intelligence SDK. Separating download of the models from download of the application as a whole or from download of a more general application update can assist in reducing the size of the application package download or application update download, thereby reducing waiting times and application down time.
- According to another aspect, the application development platform can enable the application to leverage first party models that are provided as a feature of the platform. In some implementations, the first party models can be included in the machine intelligence SDK as described above. Alternatively or additionally, the first party models can be included in a first party support application that is separate from the developer's application. In yet other implementations, first and/or third party models can be maintained in the cloud and inferences can be obtained from the models over a network via an API.
- Thus, the application development platform can enable an application to access (e.g., to call for inference via an API) both first party models (e.g., general-use models that are provided/maintained by the platform operator) and custom, third party models (e.g., application-specific models that are associated with the specific application developer). In particular, these models can be contained and dynamically updated within a machine intelligence SDK that is included within the application, such that the models provide on-device inference. For example, the first party models can be accessed through the use of a base API while the third party models can be accessed via a custom API.
- More particularly, as used herein, the designation “first party” refers to system components (e.g., machine-learned models) that are generally generated, maintained, and/or controlled by the same entity that that operates the platform-at-large. Thus, as a feature of the application development platform, the entity can also provide access to one or more first party models. These first party models can be general-use machine-learned models that provide high quality performance at commonly required tasks such as speech analysis (e.g., natural language processing, voice recognition, and/or the like), text analysis, image analysis (e.g., object detection, barcode/QR code reading, optical character recognition, and/or other tasks which may be categorized as “mobile vision”), and/or the like. Another example first party machine-learned model may be a smart reply model (e.g., accessed via an API) that, in response to an input set of text, predicts possible textual replies with which the user may wish to respond.
- In contrast, the designation “third party” refers to system components (e.g., machine-learned models) that are produced by an entity other than the entity that operates the platform-at-large. In one example, third party models may be generated and/or controlled by the application developer. For example, the application developer can use aspects of the platform to generate and deploy their own custom machine-learned models. In another example, third party models may be generated and/or controlled by an additional entity other than the application developer. For example, the application developer can use the application development platform to receive models from such additional entity.
- According to another aspect of the present disclosure, the machine intelligence SDK can further include a dedicated machine learning library that can be implemented by the application to run and/or train the models included in the machine intelligence SDK on-device. In some implementations, this machine learning library can be a lightweight library designed for mobile applications (e.g., TensorFlow Lite). Alternatively or additionally, a copy of the same or different machine learning library can also be included in a first party support application. Models included within the first party support application can be run and/or trained on-device by the first party support application using such copy of the machine learning library.
- In some implementations, the machine intelligence SDK included within the developer's application and/or the first party application can perform on-device data logging. This on-device logging can support on-device inference and/or training. With respect to on-device training, in some implementations, the machine intelligence SDK can perform validation of training data on-device as part of the logging process. For example, the SDK can detect and exclude anomalies from being logged into the training data. The on-device training can enable personalization of models based on user-specific data. In further implementations, the on-device training can enable participation of the device in a federated learning scheme.
- Thus, aspects of the present disclosure are directed to device-wide model training management (e.g. scheduling, storage, etc.). In some implementations, batch training can be performed according to scheduling rules. The scheduling rules can be default and/or customized according to a developer-specified configuration. As one example, training can occur once per day, at night, and when the device is not actively in use, actively being charged, and connected to a network.
- The logging can also enable on-device performance monitoring. For example, in some implementations, the machine intelligence SDK can further perform on-device trained model quality validation (e.g., performance monitoring). These quality statistics can be relayed to the developer via a dashboard offered by the application development platform.
- In addition or alternatively to on-device inference and/or training, the platform can also enable the application to receive inference and/or training services via the cloud. In one example, the developer may be enabled to specify (e.g., for a subset of devices and/or models) whether inference and/or training occurs on-device or via a cloud service. Both of these options can be supported by a single machine intelligence SDK, providing dynamically-controllable flexibility around the location of inference/training. In some implementations, different APIs or parameters can be used to support each of the two options. In some implementations, the developer can specify rules that handle when inference and/or training should occur on-device or in the cloud and the machine intelligence SDK can implement these rules. For example, use of rules can enable the platform to automatically handle transition/balancing between on-device and cloud services (e.g., to implement a workload balancing scheme). In some implementations, whether inference and/or training occurs on-device or in the cloud can be transparent to the device user.
- In addition to dynamic model download and deployment, the application development platform can enable further advanced machine learning services, including, for example, versioning, compatibility, A/B testing, download management, and/or various other management functions. As one example, the application development platform can enable a developer to perform or allow automatic model targeting. For example, different versions of machine-learned models can be distributed to different types of devices. In one example, a larger, more complex model can be distributed to devices with more advanced computing capabilities (e.g., larger memory size, faster processor, etc.) while a smaller, less complex model can be distributed to devices with less advanced computing capabilities. In other examples, different model versions can be downloaded to different devices depending on the geolocation of the device (e.g., English language model for United Kingdom versus French language model for France), characteristics of the user of the device (e.g., paid membership versus free trial), and/or other device and/or user attributes. For example, the developer can specify rules to govern the model targeting and the platform can implement the rules. Thus, the platform can enable an optimal version of a model to be sent (e.g., dynamically downloaded) to each different device.
- As another example, the application development platform can provide monitoring of and dashboards that display evaluations of models and system health (i.e., a model evaluation service). For example, the platform can provide analytics on model usage, performance, download status, and/or other measures. Statistics of performance can include descriptions of accuracy, accuracy under curve, precision vs recall, confusion matrix, speed (e.g., #FLOPs, milliseconds per inference), and model size (e.g., before and after compression). The analytics can be used by the developer to make decisions regarding model retraining and compression.
- The platform can also provide dashboards that allow the developer to explore system status and health such as model compatibility, availability of stored models, download status, and/or the like. Furthermore, the platform can enable the developer and the devices to ensure (and resolve if needed) backward and forward compatibility of model updates.
- As another example, the application development platform can enable a developer to perform A/B experimentation. For example, the developer can enable two models to be used for different traffic or different sets of devices. The platform can collect the resulting data and can provide analytics that enable the developer to explore the performance statistics and outcomes.
- The systems and methods of the present disclosure provide a number of technical effects and benefits. As one example technical effect, the application development platform and associated SDKs enable the on-device use of mobile-optimized machine-learned models. These mobile-optimized models provide the following benefits: smaller model size; less memory usage; faster computation; and more efficient power utilization, all with competitive model performance. Further, absent the platform tools described herein which enable easy mobile-optimized model generation and deployment, application developers may choose to perform inference in the cloud. Thus, by enabling on-device usage, the systems and methods of the present disclosure obviate the need for cloud inference calls, thereby reducing network traffic. Further, by enabling on-device training, the systems and methods of the present disclosure can lead to improved model performance including, for example, personalized models and/or models that have been produced through federated learning.
- As another example technical effect and benefit, the systems and methods of the present disclosure enable out-of-band model updating, where an updated version of the model can be dynamically downloaded to the machine intelligence SDK on the device without requiring a re-installation of the application as a whole. Separating download of the models from download of the application as a whole or from download of a more general application update can assist in reducing the size of the application package download or application update download, thereby reducing waiting times and application down time. Further, updated models can be distributed in a less intrusive manner and with smaller download sizes.
- With reference now to the Figures, example embodiments of the present disclosure will be discussed in further detail.
-
FIG. 1 depicts a block diagram of an example computing system according to example embodiments of the present disclosure. The example computing system includesdeveloper computing devices 130, an applicationdevelopment computing system 102, anduser computing devices 140 in communication over one or more networks. - The
developer computing devices 130 can be any type of computing device including, as examples, laptops, smartphones, desktops, server computing devices, etc. Thedeveloper computing devices 130 can include one or more processors and a memory. Thedeveloper computing devices 130 can be used by application developers to communicate with and/or control anapplication development platform 116 implemented by the applicationdevelopment computing system 102. As one example, thedeveloper computing device 130 can include a dedicated computer program or application that is designed to communicate with and/or control theapplication development platform 116. As another example, thedeveloper computing device 130 can include a browser application that communicates with theapplication development platform 116. For example, theapplication development platform 116 can provide services to thedeveloper computing device 130 via the browser application. - The application
development computing system 102 can include one ormore processors 112 and amemory 114. The one ormore processors 112 can be any suitable processing device (e.g., a processor core, a microprocessor, an ASIC, a FPGA, a controller, a microcontroller, etc.) and can be one processor or a plurality of processors that are operatively connected. Thememory 114 can include one or more non-transitory computer-readable storage mediums, such as RAM, ROM, EEPROM, EPROM, flash memory devices, magnetic disks, etc., and combinations thereof. Thememory 114 can storedata 116 andinstructions 118 which are executed by theprocessor 112 to cause theuser computing device 102 to perform operations. - In some implementations, the application
development computing system 102 includes or is otherwise implemented by one or more server computing devices. In instances in which the applicationdevelopment computing system 102 includes plural server computing devices, such server computing devices can operate according to sequential computing architectures, parallel computing architectures, or some combination thereof. - The application
development computing system 102 provides anapplication development platform 116. Theapplication development platform 116 can provide comprehensive services for generation, deployment, and management of machine-learned models. The application development platform can include aconsole manager 118, amodel manager 120, and amachine learning manager 122. - The
console manager 118 can control and/or manage presentation of a console at thedeveloper computing device 130, including, for example, tasks like presenting a console interface, modifying the console interface, receiving user input directed to the console interface, etc. In some implementations, theconsole manager 118 can be included in an application stored at thedeveloper computing device 130, or can include portions at both thedeveloper computing device 130 and the applicationdevelopment computing system 102. - The
model manager 120 can provide various model management services, including, as examples, a model compression service, a model conversion service, a model evaluation service, model hosting/download management services, and/or other model management services including, for example, versioning, compatibility, and/or A/B testing services. - The
machine learning manager 122 can provide a number of machine learning services such as, for example, a model training service and/or a training data management service. Themachine learning manager 122 can include and use a machine learning library to train models. Example machine learning libraries include the TensorFlow and TensorFlow Lite libraries. - Each of the
console manager 118,model manager 120, andmachine learning manager 122 includes computer logic utilized to provide desired functionality. Each of theconsole manager 118,model manager 120, andmachine learning manager 122 can be implemented in hardware, firmware, and/or software controlling a general purpose processor. For example, in some implementations, each of theconsole manager 118,model manager 120, andmachine learning manager 122 includes program files stored on a storage device, loaded into a memory and executed by one or more processors. In other implementations, each of theconsole manager 118,model manager 120, andmachine learning manager 122 includes one or more sets of computer-executable instructions that are stored in a tangible computer-readable storage medium such as RAM hard disk or optical or magnetic media. - The
application development platform 116 can be communicatively coupled to one or more databases including, for example, acloud storage database 124 and/or anapplication data database 126. Theapplication data database 126 can be a globally-distributed relational and/or non-relational database. Thedatabases - The
application development platform 116 can also communicate with one or moreuser computing devices 140. Eachuser computing device 140 can be any type of computing device including desktop computing devices, server computing devices, mobile computing devices (e.g., smartphones, laptops, tablets, device able to be worn, etc.), embedded devices, smart devices, Internet of Things devices, gaming consoles, computing devices in vehicles, and/or any other form of computing device. Eachuser computing device 140 can include one or more processors (e.g., as described at 112) and a memory (e.g., as described at 114). - In some implementations, a
user computing device 140 can include anapplication 142. For example, theapplication 142 can have been developed by a developer associated with a developer computing device (e.g., through use of the application development platform 116). Theapplication 142 can include amachine intelligence SDK 144 that is associated with the application development platform. Themachine intelligence SDK 144 can include computer-readable instructions that enable theapplication 142 to interface with theapplication development platform 116 and/or other system components (e.g., via the use of one or more platform APIs). - According to aspects of the present disclosure, in some implementations, the
machine intelligence SDK 144 can include one or more machine-learnedmodels 146 and amachine learning library 148. For example, themodels 146 can have been downloaded (e.g., dynamically and out-of-band) from the cloud storage 124 (e.g., according to instructions received from the model manager 120). Themachine intelligence SDK 144 can use themachine learning library 148 to run the machine-learnedmodels 146 to produce inferences for theapplication 142 on theuser computing device 140. - In some implementations, the
user computing device 140 can also include a firstparty support application 152. The firstparty support application 152 can be a standalone application or can be provided as a portion of the operating system of theuser computing device 140. - The first
party support application 152 can also include amachine intelligence SDK 154 that is associated with the application development platform. Themachine intelligence SDK 144 can include computer-readable instructions that enable theapplication 152 to interface with the application 142 (e.g., the machine intelligence SDK 144), theapplication development platform 116, and/or other system components (e.g., via the use of one or more platform APIs). - According to aspects of the present disclosure, in some implementations, the
machine intelligence SDK 154 can include one or more machine-learnedmodels 156 and amachine learning library 158. For example, themodels 158 can have been downloaded (e.g., dynamically and out-of-band) from the cloud storage 124 (e.g., according to instructions received from the model manager 120). Themachine intelligence SDK 154 can use themachine learning library 158 to run the machine-learnedmodels 156 to produce inferences for theapplication 142 on theuser computing device 140. -
FIG. 2 depicts a stack diagram of an example computing system according to example embodiments of the present disclosure. In particular,FIG. 2 illustrates a console interface that communicates/interacts with themodel manager 120,machine learning manager 122,cloud storage database 124, andapplication data database 126 via one or more platform APIs. - As illustrated, the
model manager 120 can provide a model compression service, a model conversion service, a model evaluation service and a model hosting service. The model compression service and/or model conversion service can enable the developer to compress and/or convert the models to optimize the models for use by a mobile device or in the mobile environment. For example, compressing the model can include performing quantization (e.g., scalar quantization, vector quantization/weight sharing, product quantization, etc.), pruning (e.g., pruning by values, L1 regularization, etc.), low rank representation (e.g., circulatent matrix, Kronecker structures, SVD decompositions, etc.), distillation, and/or other compression techniques. - Pruning reduces model size by removing weights or operations from the model that are least useful for predictions, including, for example, low-scoring weights. This can be very effective especially for on-device models involving sparse inputs. For example, certain on-device conversational models can be pruned further to achieve up-to 2× reduction in size with just 25% lower triggering rate while retaining 97% of the original prediction quality.
- Quantization techniques can improve inference speed by reducing the number of bits used for model weights and activations. For example, using 8-bit fixed point representation instead of floats can speed up the model inference, reduce power and reduce size by 4×.
- Thus, various compression tools can optionally be accessed and used to compress a learned or uploaded model.
- Converting the model can include converting the model from a standard version into a mobile-optimized version that is compatible with a lightweight machine learning library designed specifically for mobile and embedded devices. In one example, the platform can use a conversion tool known as TensorFlow Lite Optimizing Converter (“TOCO”) to convert a standard TensorFlow graph of a model into a TensorFlow Lite graph, where TensorFlow Lite is a lightweight machine learning library designed for mobile applications. Thus, various conversion tools can optionally be accessed and used to convert a learned or uploaded model into a mobile-optimized version.
- The model evaluation service can provide analytics on model usage, performance (e.g., accuracy, speed, and model size), download status, and/or other measures. The analytics can be used by the developer to make decisions regarding model retraining and compression. The model evaluation service can also provide dashboards that allow the developer to explore system status and health such as model compatibility, availability of stored models, download status, and/or the like. Furthermore, the model evaluation service can enable the developer and the devices to ensure (and resolve if needed) backward and forward compatibility of model updates.
- As another example, the model evaluation service can enable a developer to perform A/B experimentation. For example, the developer can enable two models to be used for different traffic or different sets of devices. The platform can collect the resulting data and can provide analytics that enable the developer to explore the performance statistics and outcomes.
- The model hosting service can enable models to be downloaded to devices (e.g., devices that have the developer's application stored thereon). The model hosting service can also enable the developer to perform various other management functions, including, for example, versioning, compatibility, download management, model targeting, and/or the like.
- The
machine learning manager 122 can provide a training data management service. This service can include a training data flow with comprehensive services including data augmentation, data visualization, data label crowdsourcing, etc. Training data augmentation can include data rotation, perturbation, supplementation (e.g., via image searches), etc. - The
machine learning manager 122 can provide a model training service. The model training service can perform training and/or re-training of models. For example, standard training techniques can be used to train models based on training data. - In some implementations, the model training service can perform training techniques provided by the present disclosure that result in learning of compute- or memory-efficient models. In particular, in some implementations, the model training service can perform a novel training scheme that enables direct learning of a compact machine-learned model. For example, the model training service can jointly train the compact machine-learned model with a larger, more complex model in a teacher-student training structure that enables the compact machine-learned model to learn from and approximate the more complex machine-learned model.
- In some implementations which employ the schemes described herein which enable direct learning of compact models, quantization can be applied during training. That is, the model (e.g., network) learns to optimize the weights and activations in the quantized space using gradients computed via backpropagation. This can be more effective than applying this method post training (e.g., quantizing pre-trained weights just for inference).
- Some of the joint training and distillation approaches provided by the present disclosure follow a teacher-student setup where the knowledge of the trainer model is utilized to learn an equivalent compact student model with minimal loss in accuracy. During training, the teacher or trainer model parameters can be held fixed (e.g., as in distillation) or jointly optimized to improve both models simultaneously.
- In some implementations, the trainer model can also be jointly trained with multiple student models of different sizes. So instead of providing a single compressed model, the
machine learning manager 122 can generate multiple on-device models at different sizes and inference speeds and the developer can select the model that is best suited for their application needs (e.g., provides the most appropriate tradeoff between size and performance). Additionally, jointly training multiple compact models with shared parameters typically takes only slightly more time than training a single large model, but yields multiple compressed/compact models in a single shot that are smaller in size, faster, and have lower cost relative to the more complex model, while still providing good prediction accuracy. These techniques can be combined with other techniques like transfer learning to make the learning/compression process more efficient and scalable to large-scale datasets. - More generally, the
machine learning manager 122 can include and implement a training pipeline to train a compact machine-learned model. The training pipeline can train the compact machine-learned model individually and/or jointly train the compact machine-learned model with the pre-trained machine-learned model. - In some implementations, the training pipeline can receive one or more inputs from users. For instance, the training pipeline can receive training data along with corresponding input functions for training and input functions for evaluation. The training pipeline can create a schema to specify how one or more trainings for the compact machine-learned model will proceed. The training pipeline can further provide an experiment (e.g., tf Experiment) based API to construct a network. The training pipeline can invoke the training (e.g., starting the training in a wrapper code and/or training infra).
- The training pipeline can train the compact model until a desired number of steps is achieved. The training pipeline can export the trained compact machine-learned model in a specific format (e.g., TF-Lite format). In some implementations, the trained compact machine-learned model can be then used to run on a computing device (e.g., on-device).
- In some implementations, the created schema can include several fields, such as experiment name, features (e.g., name of a field, type of a feature, one or more dimensions of a feature, etc.), hyperparameters (e.g., learning rate, number of steps, optimizer, activation layer, loss weight for a pre-trained model, loss weight for the compact model, cross loss weight, etc.), a model specification of the compact model that contains multiple fields to construct the compact model.
- In some implementations, the model specification can include some or all of the following example information:
- id: A unique identifier for this model instance.
- model_type: (e.g., “feed forward”, “projection”).
- params: A generic dictionary of parameters specific to the model_type. For example, projection_size would be a relevant parameter for the projection net, but not for the feedforward nets.
- load_checkpoint: If this parameter is set, the model would be loaded from the path which is the value of this parameter.
- freeze_model_from_checkpoint: This parameter should only be set to true if load_checkpoint is set. If the value of this parameter is true, gradients would not be backpropagated through this model. This parameter should not be set to true for the pod_model_spec (because it would make no sense to freeze the PoD model, and train the trainer model).
- tflite_output_path: If this parameter is set, the pipeline will output this model as a TFLite model (assuming all the ops in the model are supported by TFLite) to the given path.
- If both pod_model_spec and trainer_model_spec are defined, then the joint training would proceed. If only pod_model_spec is specified, then the pipeline would train an individual model. Specifying only the trainer_model_spec would be an error.
- In some implementations, the training pipeline can remove or add fields into a model specification based on ongoing development, and/or new use cases. In some implementations, the training pipeline can validate the schema to make sure that the training pipeline behaves as expected. Before starting the pipeline, each of the fields in the schema can be validated. Fields in the model specification can be also validated by a validation method of a respective model class.
- In some implementations, the training pipeline can implement and/or store one or more common machine-learned models (e.g., feed forward networks, projection networks, quasi-recurrent neural networks, convolutional neural network, long short-term memory networks, etc.) for joint training. As such, instead of inputting the pre-trained machine-learned model or a custom compact model specification, users can select a model that is stored and/or implemented in the training pipeline and can input the selection into the training pipeline. In response to the user's selection, the training pipeline can create a schema to specify how the training will proceed with the selected model(s).
- In some implementations, the training pipeline can include one or more debugging metrics such as various losses, accuracy, confusion matrices for pre-trained machine-learned models and compact machine-learned models. In some implementations, these added metrics are apart from other metrics (e.g., metrics along with Tensorboard integration). In some implementations, the training pipeline can include example implementations of a wrapper for using tf Estimator API and other plugins. In some implementations, the training pipelines can include integration with TOCO to export the trained compact machine-learned model to TF-Lite format.
- As one example,
FIG. 15 depicts a workflow diagram for an example training pipeline according to example embodiments of the present disclosure. The training pipeline validates a DeepPodSpec for shared fields between models (e.g., a compact model and a pre-trained model). In some implementations, the training pipeline can invoke a validation method (e.g., respective model-type(s)′ validate method) for validating a model specification of a corresponding model and the training pipeline can error out if this validation does not succeed. - The training pipeline can create a model_fn to be used by a tf Estimator object, which does the follow 1) instantiating respective model classes for each model such that the model performs bookkeeping and sanity checks, 2) invoking the forward_pass method (e.g., create_graph) of each model, 3) constructing and retuning loss function and training operations per predictions from each model and a corresponding specification. The training pipeline constructs the tf Estimator based on outputs from the model_fn and/or other flags related to the input in the specification.
- The training pipeline constructs the tf Experiment objects with hooks to call persist for each model. The training pipeline returns the tf Experiment object.
- The training pipeline can further convert Trainer GraphDef to inference GraphDef. The training pipeline can extract PoD model (if trained jointly) into separate network for inference. The training pipeline can convert frozen inference graph to TF-Lite format.
-
FIG. 16A depicts a graphical diagram of an example joint training scheme according to example embodiments of the present disclosure. InFIG. 16A , a projection network is jointly trained with a trainer network (e.g., feedforward networks, quasi-recurrent neural networks, convolutional neural network, long short-term memory networks, etc.) for learning to mimic predictions made by the trainer network which has far more parameters and hence more predictive capacity. The projection network is provided as one example type of model that can be learned compactly as a student model. Other types of compact models can be jointly learned according to the illustrated training scheme, including, as examples, feed forward neural networks, recurrent neural networks (e.g., long short-term memory networks), quasi-RNNs, convolutional neural networks, ProjectionNets (e.g., dense and sparse versions), BiLSTM (bi-directional LSTMs), depth-separable ConvNets, MobileNets, ProjectionCNN, NASNets, Inception (e.g., Inception v3), ResNet, and/or other types of machine-learned models. - One central aspect of the joint training scheme is a novel objective that jointly trains the two different models—the full trainer model (e.g., using existing architectures like Feed-forward NNs or LSTM RNNs) combined with a simpler student model. For example, the student model can be a projection network that leverages random projections to transform inputs or intermediate representations into bits. Thus, in some implementations, the simpler model can encode lightweight and efficient-to-compute operations in bit space with a low memory footprint.
- In some implementations, the two models can be trained jointly using backpropagation, where the student network learns from the teacher network similar to apprenticeship learning. Once trained, the smaller network can be used directly for inference at low memory and computation cost.
- The student model can optionally leverage any existing deep network like feed-forward or recursive neural network to teach a lightweight model (e.g., projected model) in a joint optimization setup which is trained end-to-end using backpropagation. In some implementations, projections based on locality sensitive hashing can be used to represent the hidden units for the lightweight network which encodes operations that are extremely efficient to compute during inference.
- The framework permits efficient distributed training but can be optimized to produce a neural network model with low memory footprint that can run on devices at low computation cost.
- The model size can be parameterized and configurable based on the task or device capacity. The framework is effective in achieving significant reduction in model sizes while providing competitive performance on multiple visual and language classification tasks.
-
FIG. 16A shows and will be discussed in reference to the framework as applied to train a projection network. However, other model types can be used as the student model other than a projection network. - In some implementations, the trainer network uses {right arrow over (x)}i as an input feature vector to predict a prediction result yi. The projection network uses projection functions (
- During joint training, a combination of a loss function
FIG. 16 , a labeled loss - Once learning is completed, the transform functions P(⋅) and corresponding trained weights Wp, Bp from the projection network are extracted to create a compact model that can be pushed to device. At inference time, the compact model and corresponding operations can be then applied to a given input {right arrow over (x)}i to generate predictions yi p.
- More particularly, neural networks are a class of non-linear models that learn a mapping from inputs {right arrow over (xι)} to outputs yi, where {right arrow over (xι)} represents an input feature vector or sequence (in the case of recursive neural networks) and yi is an output category for classification tasks, a predicted sequence, a regression value, etc. Typically, these networks consist of multiple layers of hidden units or neurons with connections between a pair of layers. For example, in a fully-connected feed-forward neural network, the number of weighted connections or network parameters that are trained is O(n2), where n is the number of hidden units per layer. Other models can similarly receive the inputs and produce the outputs.
- The present disclosure provides a new objective and joint optimization framework for training compact on-device models for inference.
FIG. 16A illustrates the Neural Projection Network architecture using a feedforward NN for the trainer network. The coupled networks are jointly trained to optimize a combined loss function: -
- N indicates the number of training instances in the dataset, {right arrow over (xι)} represents the input feature vector in a feed-forward network or sequence input in an RNN, and ŷι refers to the ground-truth output classes used for network training. hθ({right arrow over (xι)}) represents a parameterized representation of the hidden units in the trainer network that transforms {right arrow over (xι)} to an output prediction yi. Similarly, hp({right arrow over (xι)}) represents the projection network parameters that transforms the input to corresponding predictions yi p. Softmax activation can be applied at the last layer of both networks to compute the predictions yi and yi p.
- D denotes a distance function that measures the prediction error used in the loss functions. This can be decomposed into three parts—trainer prediction error, projection simulation error and projection prediction error. Reducing the first leads to a better trainer network and decreasing the latter in turn learns a better projection network that is simpler but with approximately equivalent predictive capacity. In practice, cross-entropy can be used for
Equation 2, a distillation approach can be followed to optimize - Trainer Network (θ). The trainer model can be a full neural network (feed-forward, RNN or CNN) whose choice can be flexible and depends on the task.
FIG. 16A shows a trainer using feed-forward network but this can be swapped with LSTM RNNs or other models such as deep neural networks. For the network shown in the figure, the activations for hθ(⋅) in layer lk+1 can be computed as follows: -
- where σ is the ReLU activation function applied at each layer except the last and A indicates the computed activation values for hidden units.
- The number of weights/bias parameters Wθ, Bθin this network can be arbitrarily large since this will only be used during the training stage which can be effectively done using high-performance distributed computing with CPUs or GPUs.
- Projection Network (p). The projection model is a simple network that encodes a set of efficient to-compute operations which will be performed directly on device for inference. The model itself defines a set of efficient “projection” functions
FIG. 16A . One example projection network is shown. Other structures can be used as well (e.g., additional layers, etc.) The inputs {right arrow over (xι)} are transformed using a series of T projection functions -
y i p=softmax(W p·{right arrow over (x ι p)}+B p) Eq. (5) - The projection transformations use pre-computed parameterized functions, i.e., they are not trained during the learning process, and their outputs are concatenated to form the hidden units for subsequent operations. During training, the simpler projection network learns to choose and apply specific projection operations
- The projection model can be jointly trained with the trainer and learns to mimic predictions made by the full trainer network which has far more parameters and hence more predictive capacity. Once learning is completed, the transform functions
- The choice of the type of projection matrix
bit representation 1d is used for - There is no requirement for committing to a preset vocabulary or feature space unlike typical machine learning methods which resort to smaller vocabulary sizes as a scaling mechanism. For example, LSTM RNN models typically apply pruning and use smaller, fixed-size vocabularies in the input encoding step to reduce model complexity.
- The proposed learning method scales efficiently to large data sizes and high dimensional spaces. This is especially useful for natural language applications involving sparse high dimensional feature spaces. For dense feature spaces (e.g., image pixels), existing operations like fully-connected layers (or even convolutions) can be efficiently approximated for prediction without relying on a large number of parameters. Such operations can also be applied in conjunction with the projection functions to yield more complex projection networks while constraining the memory requirements.
-
-
- Next, the present disclosure describes the projection method and associated operations in more detail.
- Locality Sensitive Projection Network: The projection network described earlier relies on a set of transformation functions
Equation 4 can be performed using different types of functions. One possibility is to use feature embedding matrices pre-trained using word2vec or similar techniques and model - Instead, an efficient randomized projection method can be employed for this step. Locality sensitive hashing (LSH) can be used to model the underlying projection operations. LSH is typically used as a dimensionality reduction technique for applications like clustering. A motivation for using LSH within Projection Nets is that it allows one to project similar inputs {right arrow over (xι)} or intermediate network layers into hidden unit vectors that are nearby in metric space. This allows transformation of the inputs and learning of an efficient and compact network representation that is only dependent on the inherent dimensionality (i.e., observed features) of the data rather than the number of instances or the dimensionality of the actual data vector (i.e., overall feature or vocabulary size). This can be achieved with binary hash functions for
-
- This property holds from simple geometry, i.e., whenever a row vector from the projection matrix
- Computing Projections: Following the above property, binary hashing can be used repeatedly and the projection vectors in
- The projection matrix
- Note that other techniques like quantization or weight sharing can be stacked on top of this method to provide further gains in terms of memory reduction.
- Projection Parameters: In practice, T different projection functions
FIG. 16A , each resulting in d-bit vector that can be concatenated to form the projected activation units {right arrow over (xι p)} inEquation 4. T and d vary depending on the projection network parameter configuration specified for - Training and Inference: The compact bit units can be used to represent the projection network as described earlier. During training, this network learns to move the gradients for points that are nearby to each other in the projected bit space
- The two networks are trained jointly using backpropagation. Despite the joint optimization objective, training can progress efficiently with stochastic gradient descent with distributed computing on high-performance CPUs or GPUs.
- Once trained, the two networks are de-coupled and serve different purposes. The trainer model can be deployed anywhere a standard model can be used. The simpler projection network model weights along with transform functions
Equations - As an alternative to the bit vector representation
- Any compact machine-learned model can be jointly trained with any trainer model, including, for example, a pre-trained machine-learned model.
- In some implementations, the trainer model can also be jointly trained with multiple student models of different sizes. As an example,
FIG. 16B depicts a graphical diagram of the example joint training scheme used to train multiple student models according to example aspects of the present disclosure. The multiple student models can be - The compression learning framework described herein has been used in example experimental tests to successfully generate small and fast models with good prediction accuracy suited for mobile applications. For example, on ImageNet task, the compression learning framework was able to generate a model 22× smaller than Inception v3 baseline and 4× smaller than MobileNet v1 baseline with just 4.6-7% drop in accuracy. As another example, on CIFAR-10, jointly training multiple models with shared parameters as described herein, takes only 10% more time than training a single large model, but yields 3 compressed models that are up to 94× smaller in size and up to 27× faster with up to 36× lower cost and good prediction quality (90-95% top-1 accuracy).
-
FIG. 17 depicts an example user interface according to example embodiments of the present disclosure. The user interface can be referred to as a Tensorboard. Once the training starts, users can monitor a training progress on Tensorboard. The Tensorboard has several options (e.g., scalars, graphs, distributions, histograms, and projectors) to present the training progress. - As shown in
FIG. 17 , “SCALARS” option can be selected to present compact model (also referred to PoD model) accuracy and trainer model accuracy. Several tools to process charts on the right of the user interface are shown on the left of the user interface, such as “Show data download links” to show download links of data associated with the PoD model and/or the trainer model, “Ignore outliers in chart scaling” to remove outliers in the charts on the right of the user interface, “Tooltip sorting method” to allow users to select a method for sorting, “Smoothing” to allow users to select a smoothing level to smooth accuracy curves on the right of the user interface, “Horizontal Axis” to allow users to select a type (e.g., running steps, relative, and wall) of the horizontal of the accuracy curves, and “Runs” to write a regex to filter runs. -
FIG. 18 depicts an example user interface according to example embodiments of the present disclosure. As shown inFIG. 18 , “GRAPHS” option is selected. A graph on the right of the user interface shows an example structure of the training. The structure shows how the joint training of the PoD model and trainer can be performed. The structure shows a dataflow from the bottom to the top and shows each function that can be used to jointly train the PoD model and the trainer. Several tools are listed on the left of the user interface. Users can select the tools to process the graph on the right of the user interface. For example, input can be traced by activating “Trace input.” - Referring again to
FIG. 2 , theapplication data database 126 can store model metadata. Thecloud storage database 124 can store machine-learned models (including both third party models and first party models) and training data. The training data can be uploaded by developers and can include validation data. Alternatively or additionally, the training data can be derived from large, public training datasets. - As illustrated, the console interface can communicate/interact with the
model manager 120,machine learning manager 122,cloud storage database 124, andapplication data database 126 via one or more platform APIs. Example APIs are provided in the attached appendices. These APIs are provided as examples only. Different APIs can be used in addition or alternatively to the example APIs. - Appendix A provides example custom model APIs. Appendix A is incorporated into and forms a part of this specification.
- Appendix B provides example vision model APIs. Appendix B is incorporated into and forms a part of this specification.
- Appendix C provides example vision model APIs. Appendix C is incorporated into and forms a part of this specification.
- Referring now to
FIG. 3 ,FIG. 3 depicts a functional diagram of example console interface modes/states according to example embodiments of the present disclosure. As illustrated, in one workflow, a developer can progress through various console interfaces which respectively enable the developer to upload a model, check for compatibility, deploy the model, and then monitor performance of the model. In another workflow, the console can provide interfaces that respectively upload training data (e.g., to cloud storage buckets), optionally augment the training data, train and/or compress the model, and then deploy the model and monitor performance. - In some implementations, the console can provide a number of tools or user interfaces that assist the developer in generating the correct machine-learned model. As one example, the console can provide a set of use cases for developers to choose from, which will determine the target model architecture. In another example, the console can enable the developer to select or explore accuracy vs model size trade-off requirements.
-
FIG. 4 depicts a workflow diagram of an example computing system according to example embodiments of the present disclosure. More particularly, in some implementations, since model compression and/or conversion are long running tasks, they are not handled within the frontend server directly. In such cases, dedicated backend jobs are used to do the processing.FIG. 4 shows one example arrangement of such a system that includes a job scheduler with database queue to handle the job scheduling between the frontend and the backend. - In the backend job, the developer-provided model may need to be run. As a result, the process that runs the service can be sandboxed to provide privacy and security. For example, a cloud machine learning engine can be used.
- In some implementations, at a high level, the platform can treat both model compression and conversion as a job. Thus, in some implementations, when a developer wants a model to be compressed or converted, the platform frontend server can create a job and insert it to database queue. The scheduler can handle the actual job scheduling, while the platform frontend server will keep on polling the status of the job, and report it back to the developer when it enters terminal state. The developer can also initiate the query to check the status of their j obs.
-
FIG. 5 depicts a workflow diagram of an example computing system according to example embodiments of the present disclosure. In particular,FIG. 5 depicts an example of a basic device-side flow. In particular, the application development platform and machine intelligence SDK allow developers to use custom models on the device. The API allows the application to perform inference using a custom model that's already on the device, where the developer either manually downloads the model file from somewhere or packages it within the application itself. - The platform also provides a model file hosting solution that is tightly integrated with the client-side SDK, which will provide the following features: A user interface part of platform console where the developer can manage their models; Model versioning, allowing the developer to specify active (or production) model and/or easily perform rollbacks; Automatically determining uploaded model compatibility with different machine learning library versions and only serving compatible models to compatible devices; and/or First class A/B testing support, allowing the developer to run experiments on different versions of their model.
-
FIG. 6 depicts a flow chart diagram of an example process for generating and deploying machine-learned models according to example embodiments of the present disclosure whileFIG. 7 depicts a workflow diagram of an example implementation the example process for generating and deploying machine-learned models according to example embodiments of the present disclosure. - In particular, aspects of the present disclosure are directed to an on-device machine intelligence SDK that forms a part of a cross-platform third party mobile machine learning platform that operates via APIs. For mobile developers building on-device machine learning features, training a model for mobile applications is still a big pain point for most developers. Furthermore, for a lot of mobile use cases the training workflows are pretty similar. Thus, the present disclosure provides tools to facilitate the whole model training workflow on the cloud.
- Step 1: Model selection and design: For the majority of the use cases (e.g., mobile use cases), the training flow starts with a pre-trained model (e.g., Inception v3, MobileNets, etc.). The platform can provide access to a set of pre-trained models that cover some typical computer vision use cases and can guarantee to be converted to a mobile-optimized format. The set of selectable models can also cover other domains or custom models.
- Step 2: Training data creation: The platform can assist developers to augment and manage their training data. Data augmentation can include adding more training samples (e.g., via an image search), leveraging crowd-sourcing platforms to provide labels, and introducing/or transformations of existing samples (e.g., add noises, rotations, perturbations, etc.). The platform can also provide data cleaning and visualization tools.
- The platform provides a number of data format options, including, as examples: Raw data with labels and/or TF.example. The platform provides a number of model format options, including, as examples, SavedModel and/or Checkpoint.
- Step 3: Model training: The training can include refining the pre-trained model (e.g., top layer only or more than top layer only). The training can also include fully automated training from scratch. Training can also optionally be done according to a joint training technique described herein.
- Step 4: Model optimization for mobile: Since model size is critical for mobile applications, the platform can provide tools to automatically compress models with evaluation of performance and accuracy. Automatic model optimization can include re-training the model, where training data may be required.
- Step 5: Model conversion for mobile: Once models are obtained that meet the required performance and accuracy, the platform can convert them to a mobile-optimized format ready for deployment. The conversion can include several steps (e.g., model freeze, TOCO conversion, etc.) with command line tools. These steps can be streamlined and information about errors can be provided via the platform console. In some implementations, the output models from the compression step can automatically be converted to the mobile format. Depending on the TOCO tool readiness, the models can be enforced to be in some standard architecture such as, for example, through POD compression (e.g., specified output model architecture).
- Step 6: Model deployment and management: The application development platform can provide a targeting mechanism for developers to specify which models should be applied for which application versions, device types, and/or user segments. The platform can also provide a compatibility check to make sure models are compatible with the targeted machine learning library runtime. Lastly, the platform can host all the models for the developers and the applications can download/upgrade the models on the fly.
- While the platform provides tools to help the complete training flow, the developers can also choose to leverage parts of the flow. For example, if the developers already have the model ready for deployment, they can upload their models and make use of
step 6 only. If the developers already have a Tensorflow model for cloud inference, they can upload their Tensorflow models and make use ofstep 4 and/or 5 as well. -
FIG. 8 depicts a swim lane diagram of an example process to upload machine-learned models for distribution according to example embodiments of the present disclosure. As illustrated, a user (developer) can (e.g., via their browser) initiate a model file upload. The platform backend API can create a new object with cloud storage and can return the cloud storage upload URL to the user. The user can upload the file to cloud storage and then inform the platform API when the upload has completed. The backend API can enqueuer a model compatibility check request. - A model compatibility service can dequeue the model compatibility check request and can get model information from the backend API. The API can return the cloud storage download URL. The model compatibility service can download the model file from cloud storage and can check compatibility and extract model metadata. The model compatibility service can update the model metadata with compatibility information.
- Thus, in some implementations, model compatibility can be implemented as separate, asynchronous service. When model files are uploaded, a compatibility check request will be added to a database queue. The compatibility check service will then asynchronously perform the check. In some implementations, the model file may not be available for download until the compatibility check is complete.
-
FIG. 9 depicts a swim lane diagram of an example process to download machine-learned models according to example embodiments of the present disclosure. As illustrated, at an initial load, a machine intelligence SDK can request the model from the API. The API can look up the compatible version, authorize, and then get the download URL from cloud storage. The API can return the model information (e.g., download URL) to the machine intelligence SDK. The machine intelligence SDK can use the URL to download the model from cloud storage and can cache the downloaded model. - At a subsequent load, the SDK can get model information from the API. The API can return model information (including a download URL if appropriate). The SDK can download the new model, if necessary.
-
FIGS. 10-14 depict example computing systems that include various different example implementations of the machine intelligence SDK. The machine intelligence SDK can be “fat,” “partially fat,” or “thin.” - The application development platform allows developers to either bundle the models together with the SDK or to dynamically download models to the SDK. In one example, the developers can upload their models on the platform console which will get synchronized to and cached on the device. Once on the device, the model is easily accessible to the on-device service via a simple API call.
- Expanding on the SDK itself, the SDK may have “on-device backends” for some of these, i.e. calls to other modules (e.g., first party modules) or applications as part of its implementation (as shown in
FIGS. 11-14 ). Alternatively, inclusion of all models and services within a single machine intelligence module as shown inFIG. 10 avoids duplicate machine learning library runtimes; optimizes the implementation, and maintains a single stack (e.g., C/C++ stack) for cross-platform usage. - In particular,
FIG. 10 depicts a block diagram of an example computing system that includes a fat SDK according to example embodiments of the present disclosure. In particular, in the fat SDK, all of the machine intelligence models and services (e.g., vision, speech, text, custom, etc.) are unified into one SDK. More specifically, all of the models and a machine learning library/runtime (e.g., TFLite) can be contained within a single machine intelligence module as shown inFIG. 10 . - Generally, a “fat” SDK means that all dependencies are pulled into one fat binary and it is statically linked to the application. Typically, the fat SDK does not update any part dynamically via updates. The fat SDK can interact with first party modules or applications however. A fat SDK avoids any machine learning library compatibility issues.
- A “fat updateable” SDK is similar to a fat SDK (e.g., one fat binary statically linked to the application) except that aspects of the SDK can be dynamically updated without the full application update. In some implementations, whenever there is a newer version of first party models available on device, they will be dynamically loaded and run in the application's process. This enables quick updating of the machine learning runtime and the models but also introduces the possibility of machine learning library compatibility issues.
- A “thin” SDK means that the SDK contains only client libraries and depends on the models being run inside first party support modules or applications. These can optionally still be run within the application's process. The benefit of thin SDKs is that the application package is smaller in size and implementation of the modules can be shared by multiple applications.
- As an example,
FIG. 11 depicts a block diagram of an example computing system that includes a thin SDK according to example embodiments of the present disclosure. As illustrated inFIG. 11 , the machine intelligence module may call into other first party modules where applicable to share costs amongst clients. For some of those parts of the SDK, the client library can be in the SDK while the implementation is in a first party module or application. - Thus, various possible arrangements can also enable model management, including decisions regarding bundling in versus dynamic downloads. In particular, in some instances, the models (plus any databases needed for inference) may be quite large (—MB) so the developer can be enabled to decide whether to go for the simplicity of bundling the models, or dynamically download those. For third party models, the developer can select the appropriate choice.
- For first party models, the models could be all bundled within the SDK or dynamically downloaded, which may be controlled by the first party. Bundling the models within the SDK provides the following benefits: models available from the application install time; no need to wait for the downloading to happen; less network and power usage; and higher stability, less chance of a compatibility breakage from dynamically downloaded models.
- In some implementations, large first party models can be shared amongst two or more applications. The sharing of the models amongst applications can, in one example, be achieved as follows: Make the models part of a first party module (i.e., have a separate updateable module and let it handle models/downloads. The first party module is not part of the ‘fat’ or ‘fat updateable’ SDK, but rather is in the ‘thin’ part of the SDK (i.e., the SDK pulls in only the client library of the module). The first party module can be exposed to the other parts of the SDK via a first party API.
- In some implementations, there may be a separate machine learning library runtime for first party models that updates with the first party models and is not used for developer-owned models. This may assist in reducing compatibility issues.
- Sharing the models amongst applications provides storage benefits/savings. That is, without sharing, redundant versions of the models will be a large hit on the storage (and application package size if bundled or power/data if they are downloaded) of the device.
- In some implementations, the application development platform can distribute SDKs via static frameworks. A static framework can be a single statically-linked library coupled with headers (to be used in both Objective C and Swift) and some extra metadata (e.g., a module map). It is also possible to distribute SDKs as dynamically-loaded libraries.
- In some implementations, distribution can occur via CocoaPods, where a CocoaPod is a j son file specifying how to fetch the framework. The pod specification can point to a downloadable binary blob or, alternatively, the source code, for example, hosted externally.
- A CocoaPod may contain one or more frameworks, although it is typical to only package one framework in a pod. The platform can automate most of the building, testing and deployment pipeline.
- In some implementations, if there is already a module that exists in the SDK (e.g., mobile vision), it is easy to form a new SDK which pulls that dependency in as-is (e.g., as opposed to doing more tighter integration).
- In some implementations, references can just be made to the symbols of the other library and it can be ensured that the user of the library gets both. With CocoaPods, it is easy to achieve. Some examples may use several dependencies such as Protobuf. The platform's build infrastructure can have provisions to ensure that the dependencies don't get statically linked at build time, preventing duplicate symbol breakages.
-
FIG. 12 depicts a block diagram of an example computing system that includes mobile vision models as part of an updatable first party support application according to example embodiments of the present disclosure. In particular,FIG. 12 depicts an architecture where only mobile vision models are provided via APIs to a first party support application while third party models are included in the machine intelligence SDK. - Thus,
FIG. 12 shows an example that is part “fat” and part “updateable” SDK, where the custom models and a TFLite runtime are in the fat part and the mobile vision module (along with its tfmini runtime) is in the updateable part. - One example reason for having the mobile vision module as thin updateable (as opposed to fat updateable) is to share the storage space and downloading data of all models amongst all apps that use the SDK. The custom third party models can be updated through the platform console and cloud storage. The platform can provide compatibility tests that can be run from the platform console to help alleviate potential compatibility issues.
- As for bundling the models: for mobile vision APIs, the models can be downloaded due to their size. For some third party custom models, developers can make a choice of bundling in the models or later updating the models via dynamic downloading.
-
FIG. 13 depicts a block diagram of an example computing system that includes mobile vision, text, and speech models as part of an updatable first party support application according to example embodiments of the present disclosure. That is, relative toFIG. 12 , inFIG. 13 more base APIs (e.g., text, speech) are included in the support application, possibly each having their own module structure therein. Redundant common runtimes can optionally be removed. -
FIG. 14 depicts a block diagram of an example computing system that includes an updatable first party support application that further performs both runtime and training according to example embodiments of the present disclosure. That is, all first party models and modules in the support application use the same runtime in the first party support application, thereby removing redundant runtimes, logging, and downloading of libraries. - The first party support application can also perform training. In other implementations, training can be part of a fat updateable SDK (as opposed to a thin updateable and shared amongst all apps) to provide privacy benefits for application-specific data storage.
- The technology discussed herein makes reference to servers, databases, software applications, and other computer-based systems, as well as actions taken and information sent to and from such systems. The inherent flexibility of computer-based systems allows for a great variety of possible configurations, combinations, and divisions of tasks and functionality between and among components. For instance, processes discussed herein can be implemented using a single device or component or multiple devices or components working in combination. Databases and applications can be implemented on a single system or distributed across multiple systems. Distributed components can operate sequentially or in parallel.
- The example SDK and application arrangements illustrated in
FIGS. 10-14 are provided as examples only. Many different variations and combinations of these example arrangements can be made according to aspects of the present disclosure. - While the present subject matter has been described in detail with respect to various specific example embodiments thereof, each example is provided by way of explanation, not limitation of the disclosure. Those skilled in the art, upon attaining an understanding of the foregoing, can readily produce alterations to, variations of, and equivalents to such embodiments. Accordingly, the subject disclosure does not preclude inclusion of such modifications, variations and/or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art. For instance, features illustrated or described as part of one embodiment can be used with another embodiment to yield a still further embodiment. Thus, it is intended that the present disclosure cover such alterations, variations, and equivalents.
Claims (21)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US17/861,930 US20220374719A1 (en) | 2017-05-20 | 2022-07-11 | Application Development Platform and Software Development Kits that Provide Comprehensive Machine Learning Services |
Applications Claiming Priority (6)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201762509058P | 2017-05-20 | 2017-05-20 | |
US201762517635P | 2017-06-09 | 2017-06-09 | |
US201862667959P | 2018-05-07 | 2018-05-07 | |
PCT/US2018/033674 WO2018217635A1 (en) | 2017-05-20 | 2018-05-21 | Application development platform and software development kits that provide comprehensive machine learning services |
US201916605702A | 2019-10-16 | 2019-10-16 | |
US17/861,930 US20220374719A1 (en) | 2017-05-20 | 2022-07-11 | Application Development Platform and Software Development Kits that Provide Comprehensive Machine Learning Services |
Related Parent Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US16/605,702 Continuation US11410044B2 (en) | 2017-05-20 | 2018-05-21 | Application development platform and software development kits that provide comprehensive machine learning services |
PCT/US2018/033674 Continuation WO2018217635A1 (en) | 2017-05-20 | 2018-05-21 | Application development platform and software development kits that provide comprehensive machine learning services |
Publications (1)
Publication Number | Publication Date |
---|---|
US20220374719A1 true US20220374719A1 (en) | 2022-11-24 |
Family
ID=62530546
Family Applications (2)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US16/605,702 Active 2038-08-24 US11410044B2 (en) | 2017-05-20 | 2018-05-21 | Application development platform and software development kits that provide comprehensive machine learning services |
US17/861,930 Pending US20220374719A1 (en) | 2017-05-20 | 2022-07-11 | Application Development Platform and Software Development Kits that Provide Comprehensive Machine Learning Services |
Family Applications Before (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US16/605,702 Active 2038-08-24 US11410044B2 (en) | 2017-05-20 | 2018-05-21 | Application development platform and software development kits that provide comprehensive machine learning services |
Country Status (3)
Country | Link |
---|---|
US (2) | US11410044B2 (en) |
EP (1) | EP3602414A1 (en) |
WO (1) | WO2018217635A1 (en) |
Families Citing this family (50)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US10310821B2 (en) * | 2017-06-03 | 2019-06-04 | Apple Inc. | Integration of learning models into a software development system |
EP3582125B1 (en) * | 2018-06-11 | 2022-08-03 | ABB Schweiz AG | System and methods with reduced complexity in the integration of exposed information models with applications |
US11494621B2 (en) | 2018-06-27 | 2022-11-08 | Amazon Technologies, Inc. | Attached accelerator selection and placement |
US11960935B2 (en) | 2018-06-27 | 2024-04-16 | Amazon Technologies, Inc. | Fault-tolerant accelerator based inference service |
US11599821B2 (en) * | 2018-06-27 | 2023-03-07 | Amazon Technologies, Inc. | Attached accelerator based inference service |
US11720727B2 (en) | 2018-09-06 | 2023-08-08 | Terrafuse, Inc. | Method and system for increasing the resolution of physical gridded data |
US11966670B2 (en) | 2018-09-06 | 2024-04-23 | Terrafuse, Inc. | Method and system for predicting wildfire hazard and spread at multiple time scales |
US11205028B2 (en) * | 2018-09-06 | 2021-12-21 | Terrafuse, Inc. | Estimating physical parameters of a physical system based on a spatial-temporal emulator |
US11544524B2 (en) * | 2018-09-28 | 2023-01-03 | Samsung Electronics Co., Ltd. | Electronic device and method of obtaining emotion information |
CA3114632A1 (en) * | 2018-11-19 | 2020-05-28 | Deeplite Inc. | System and method for automated design space determination for deep neural networks |
CN109635422B (en) * | 2018-12-07 | 2023-08-25 | 深圳前海微众银行股份有限公司 | Joint modeling method, device, equipment and computer readable storage medium |
CN109857459B (en) * | 2018-12-27 | 2022-03-08 | 中国海洋大学 | E-level super-calculation ocean mode automatic transplanting optimization method and system |
CN111401396B (en) * | 2019-01-03 | 2023-04-18 | 阿里巴巴集团控股有限公司 | Image recognition method and device |
US11444845B1 (en) * | 2019-03-05 | 2022-09-13 | Amazon Technologies, Inc. | Processing requests using compressed and complete machine learning models |
US10430179B1 (en) * | 2019-03-07 | 2019-10-01 | Capital One Services, Llc | Methods and systems for managing application configurations |
US11409291B2 (en) * | 2019-03-21 | 2022-08-09 | Performance Drone Works Llc | Modular autonomous drone |
US11455336B2 (en) | 2019-03-21 | 2022-09-27 | Performance Drone Works Llc | Quadcopter hardware characterization and simulation |
US11312506B2 (en) | 2019-03-21 | 2022-04-26 | Performance Drone Works Llc | Autonomous quadcopter piloting controller and debugger |
US11721235B2 (en) * | 2019-03-21 | 2023-08-08 | Performance Drone Works Llc | Quadcopter sensor noise and camera noise recording and simulation |
US11704573B2 (en) * | 2019-03-25 | 2023-07-18 | Here Global B.V. | Method, apparatus, and computer program product for identifying and compensating content contributors |
US11494637B2 (en) * | 2019-03-28 | 2022-11-08 | International Business Machines Corporation | Layer-wise distillation for protecting pre-trained neural network models |
US11488067B2 (en) * | 2019-05-13 | 2022-11-01 | Google Llc | Training machine learning models using teacher annealing |
CN110209574A (en) * | 2019-05-14 | 2019-09-06 | 深圳极视角科技有限公司 | A kind of data mining system based on artificial intelligence |
CN114287007A (en) | 2019-06-18 | 2022-04-05 | 摩洛科公司 | Method and system for providing machine learning services |
KR20190096872A (en) * | 2019-07-31 | 2019-08-20 | 엘지전자 주식회사 | Method and apparatus for recognizing handwritten characters using federated learning |
CN110414516B (en) * | 2019-08-05 | 2022-02-01 | 上海海事大学 | Single Chinese character recognition method based on deep learning |
CN110490136B (en) * | 2019-08-20 | 2023-03-24 | 电子科技大学 | Knowledge distillation-based human behavior prediction method |
US11562267B2 (en) | 2019-09-14 | 2023-01-24 | Oracle International Corporation | Chatbot for defining a machine learning (ML) solution |
US11663523B2 (en) | 2019-09-14 | 2023-05-30 | Oracle International Corporation | Machine learning (ML) infrastructure techniques |
US11625648B2 (en) | 2019-09-14 | 2023-04-11 | Oracle International Corporation | Techniques for adaptive pipelining composition for machine learning (ML) |
US20210089921A1 (en) * | 2019-09-25 | 2021-03-25 | Nvidia Corporation | Transfer learning for neural networks |
US20210117799A1 (en) * | 2019-10-17 | 2021-04-22 | EMC IP Holding Company LLC | Monitoring performance of a storage system using paired neural networks |
US20210117859A1 (en) * | 2019-10-20 | 2021-04-22 | Nvidia Corporation | Live updating of machine learning models |
US11567495B2 (en) * | 2019-12-11 | 2023-01-31 | Toyota Motor Engineering & Manufacturing North America, Inc. | Methods and systems for selecting machine learning models to predict distributed computing resources |
US11551083B2 (en) | 2019-12-17 | 2023-01-10 | Soundhound, Inc. | Neural network training from private data |
US11700533B2 (en) | 2020-05-01 | 2023-07-11 | Digital Global Systems, Inc. | System, method, and apparatus for providing dynamic, prioritized spectrum management and utilization |
US11657304B2 (en) * | 2020-05-01 | 2023-05-23 | Microsoft Technology Licensing, Llc | Assessing similarity between items using embeddings produced using a distributed training framework |
CN111612132A (en) * | 2020-05-20 | 2020-09-01 | 广东电网有限责任公司 | Artificial intelligence algorithm development system, training method, device and medium |
WO2022031819A1 (en) * | 2020-08-05 | 2022-02-10 | Avesha, Inc. | Performing load balancing self adjustment within an application environment |
CN111898707A (en) * | 2020-08-24 | 2020-11-06 | 鼎富智能科技有限公司 | Model training method, text classification method, electronic device and storage medium |
CN111930691B (en) * | 2020-10-16 | 2021-01-12 | 北京美摄网络科技有限公司 | Model calling method, device and system |
WO2022103886A1 (en) | 2020-11-11 | 2022-05-19 | Thakore Kartik | Systems and methods for preparing and deploying cross-platform applications |
US11776273B1 (en) * | 2020-11-30 | 2023-10-03 | Amazon Technologies, Inc. | Ensemble of machine learning models for automatic scene change detection |
CN112733453B (en) * | 2021-01-13 | 2024-03-29 | 新奥新智科技有限公司 | Equipment predictive maintenance method and device based on joint learning |
US11748988B1 (en) | 2021-04-21 | 2023-09-05 | Amazon Technologies, Inc. | Shot contras five self-supervised learning of a plurality of machine learning models for video analysis applications |
US11782682B2 (en) * | 2021-07-13 | 2023-10-10 | The Math Works, Inc. | Providing metric data for patterns usable in a modeling environment |
US11599794B1 (en) | 2021-10-20 | 2023-03-07 | Moffett International Co., Limited | System and method for training sample generator with few-shot learning |
US11947445B2 (en) * | 2022-02-18 | 2024-04-02 | Mckinsey & Company, Inc. | Adjustment of operating parameters of arranged software assets |
JP7112802B1 (en) | 2022-04-27 | 2022-08-04 | 望 窪田 | Lightweight learning model |
US20230410494A1 (en) * | 2022-06-15 | 2023-12-21 | Zeroeyes, Inc. | Unified ai model training platform |
Citations (13)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20070094168A1 (en) * | 2005-07-29 | 2007-04-26 | The Florida International University Board Of Trustees | Artificial neural network design and evaluation tool |
US7831526B1 (en) * | 2006-08-25 | 2010-11-09 | Fair Isaac Corporation | Article and method for finding a compact representation to visualize complex decision trees |
US20150019912A1 (en) * | 2013-07-09 | 2015-01-15 | Xerox Corporation | Error prediction with partial feedback |
US20150254555A1 (en) * | 2014-03-04 | 2015-09-10 | SignalSense, Inc. | Classifying data with deep learning neural records incrementally refined through expert input |
US20160019211A1 (en) * | 2013-03-11 | 2016-01-21 | Morpho | A process for obtaining candidate data from a remote storage server for comparison to a data to be identified |
US20160078361A1 (en) * | 2014-09-11 | 2016-03-17 | Amazon Technologies, Inc. | Optimized training of linear machine learning models |
US20180268244A1 (en) * | 2017-03-14 | 2018-09-20 | Samsung Electronics Co., Ltd. | System and method for deep labeling |
US20190050749A1 (en) * | 2017-08-11 | 2019-02-14 | Google Inc. | On-Device Machine Learning Platform |
US20190087746A1 (en) * | 2017-09-15 | 2019-03-21 | Microsoft Technology Licensing, Llc | System and method for intelligent incident routing |
US20190188295A1 (en) * | 2017-12-15 | 2019-06-20 | Accenture Global Solutions Limited | Cognitive searches based on deep-learning neural networks |
US20190244103A1 (en) * | 2018-02-07 | 2019-08-08 | Royal Bank Of Canada | Robust pruned neural networks via adversarial training |
US10417577B2 (en) * | 2015-06-05 | 2019-09-17 | Facebook, Inc. | Machine learning system interface |
US20200133964A1 (en) * | 2017-10-13 | 2020-04-30 | Kpmg Llp | System and method for analysis and determination of relationships from a variety of data sources |
Family Cites Families (20)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
WO2005033665A2 (en) | 2003-10-01 | 2005-04-14 | Microislet, Inc. | Semi-automated microscopic assessment of islet quantity, equivalence and purity |
WO2005106656A2 (en) | 2004-04-16 | 2005-11-10 | Fortelligent, Inc. | Predictive modeling |
JP2009091477A (en) | 2007-10-10 | 2009-04-30 | Toray Ind Inc | Transparent crosslinked film |
US9519859B2 (en) | 2013-09-06 | 2016-12-13 | Microsoft Technology Licensing, Llc | Deep structured semantic model produced using click-through data |
BR112017003893A8 (en) | 2014-09-12 | 2017-12-26 | Microsoft Corp | DNN STUDENT APPRENTICE NETWORK VIA OUTPUT DISTRIBUTION |
US10713594B2 (en) | 2015-03-20 | 2020-07-14 | Salesforce.Com, Inc. | Systems, methods, and apparatuses for implementing machine learning model training and deployment with a rollback mechanism |
US20160321523A1 (en) * | 2015-04-30 | 2016-11-03 | The Regents Of The University Of California | Using machine learning to filter monte carlo noise from images |
US10452994B2 (en) | 2015-06-04 | 2019-10-22 | International Business Machines Corporation | Versioning of trained models used to deliver cognitive services |
US20180241848A1 (en) * | 2015-09-11 | 2018-08-23 | Hewlett Packard Enterprise Development Lp | Human-readable cloud structures |
KR102492318B1 (en) | 2015-09-18 | 2023-01-26 | 삼성전자주식회사 | Model training method and apparatus, and data recognizing method |
US20170132528A1 (en) * | 2015-11-06 | 2017-05-11 | Microsoft Technology Licensing, Llc | Joint model training |
CN106706677B (en) | 2015-11-18 | 2019-09-03 | 同方威视技术股份有限公司 | Check the method and system of cargo |
US11200483B2 (en) * | 2016-08-30 | 2021-12-14 | Lunit Inc. | Machine learning method and apparatus based on weakly supervised learning |
US11080616B2 (en) | 2016-09-27 | 2021-08-03 | Clarifai, Inc. | Artificial intelligence model and data collection/development platform |
US10509645B2 (en) | 2016-12-02 | 2019-12-17 | Factual Inc. | Method and apparatus for enabling an application to detect specified circumstances |
US20180336463A1 (en) | 2017-05-18 | 2018-11-22 | General Electric Company | Systems and methods for domain-specific obscured data transport |
US10606566B2 (en) | 2017-06-03 | 2020-03-31 | Apple Inc. | Integration of learning models into a software development system |
US10599205B2 (en) | 2017-09-18 | 2020-03-24 | Verizon Patent And Licensing Inc. | Methods and systems for managing machine learning involving mobile devices |
US10795647B2 (en) | 2017-10-16 | 2020-10-06 | Adobe, Inc. | Application digital content control using an embedded machine learning module |
US11416053B2 (en) | 2018-07-31 | 2022-08-16 | Hewlett-Packard Development Company, L.P. | Operating modes of a computer display |
-
2018
- 2018-05-21 WO PCT/US2018/033674 patent/WO2018217635A1/en unknown
- 2018-05-21 EP EP18729531.6A patent/EP3602414A1/en not_active Ceased
- 2018-05-21 US US16/605,702 patent/US11410044B2/en active Active
-
2022
- 2022-07-11 US US17/861,930 patent/US20220374719A1/en active Pending
Patent Citations (13)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20070094168A1 (en) * | 2005-07-29 | 2007-04-26 | The Florida International University Board Of Trustees | Artificial neural network design and evaluation tool |
US7831526B1 (en) * | 2006-08-25 | 2010-11-09 | Fair Isaac Corporation | Article and method for finding a compact representation to visualize complex decision trees |
US20160019211A1 (en) * | 2013-03-11 | 2016-01-21 | Morpho | A process for obtaining candidate data from a remote storage server for comparison to a data to be identified |
US20150019912A1 (en) * | 2013-07-09 | 2015-01-15 | Xerox Corporation | Error prediction with partial feedback |
US20150254555A1 (en) * | 2014-03-04 | 2015-09-10 | SignalSense, Inc. | Classifying data with deep learning neural records incrementally refined through expert input |
US20160078361A1 (en) * | 2014-09-11 | 2016-03-17 | Amazon Technologies, Inc. | Optimized training of linear machine learning models |
US10417577B2 (en) * | 2015-06-05 | 2019-09-17 | Facebook, Inc. | Machine learning system interface |
US20180268244A1 (en) * | 2017-03-14 | 2018-09-20 | Samsung Electronics Co., Ltd. | System and method for deep labeling |
US20190050749A1 (en) * | 2017-08-11 | 2019-02-14 | Google Inc. | On-Device Machine Learning Platform |
US20190087746A1 (en) * | 2017-09-15 | 2019-03-21 | Microsoft Technology Licensing, Llc | System and method for intelligent incident routing |
US20200133964A1 (en) * | 2017-10-13 | 2020-04-30 | Kpmg Llp | System and method for analysis and determination of relationships from a variety of data sources |
US20190188295A1 (en) * | 2017-12-15 | 2019-06-20 | Accenture Global Solutions Limited | Cognitive searches based on deep-learning neural networks |
US20190244103A1 (en) * | 2018-02-07 | 2019-08-08 | Royal Bank Of Canada | Robust pruned neural networks via adversarial training |
Also Published As
Publication number | Publication date |
---|---|
WO2018217635A1 (en) | 2018-11-29 |
EP3602414A1 (en) | 2020-02-05 |
US20200125956A1 (en) | 2020-04-23 |
US11410044B2 (en) | 2022-08-09 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US20220374719A1 (en) | Application Development Platform and Software Development Kits that Provide Comprehensive Machine Learning Services | |
JP7440420B2 (en) | Application development platform and software development kit offering comprehensive machine learning services | |
US11144831B2 (en) | Regularized neural network architecture search | |
Luckow et al. | Deep learning in the automotive industry: Applications and tools | |
US11544604B2 (en) | Adaptive model insights visualization engine for complex machine learning models | |
US20200265301A1 (en) | Incremental training of machine learning tools | |
US20200342055A1 (en) | Named entity disambiguation using entity distance in a knowledge graph | |
US11868854B2 (en) | Using metamodeling for fast and accurate hyperparameter optimization of machine learning and deep learning models | |
US20200311613A1 (en) | Connecting machine learning methods through trainable tensor transformers | |
US20200410365A1 (en) | Unsupervised neural network training using learned optimizers | |
US20220027792A1 (en) | Deep neural network model design enhanced by real-time proxy evaluation feedback | |
US11900263B2 (en) | Augmenting neural networks | |
US20220004914A1 (en) | Code generation for auto-ai | |
US20220036232A1 (en) | Technology for optimizing artificial intelligence pipelines | |
CN115699041A (en) | Extensible transfer learning using expert models | |
US20220198277A1 (en) | Post-hoc explanation of machine learning models using generative adversarial networks | |
US20210056264A1 (en) | Neologism classification techniques | |
US20230186117A1 (en) | Automated cloud data and technology solution delivery using dynamic minibot squad engine machine learning and artificial intelligence modeling | |
CN116011509A (en) | Hardware-aware machine learning model search mechanism | |
US20230140828A1 (en) | Machine Learning Methods And Systems For Cataloging And Making Recommendations Based On Domain-Specific Knowledge | |
Lux et al. | Open source column: deep learning with Keras | |
US20240152809A1 (en) | Efficient machine learning model architecture selection | |
WO2021247831A1 (en) | Automated knowledge extraction and representation for complex engineering systems |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
STPP | Information on status: patent application and granting procedure in general |
Free format text: DOCKETED NEW CASE - READY FOR EXAMINATION |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:RAVI, SUJITH;MENGHANI, GAURAV;KALIAMOORTHI, PRABHU;AND OTHERS;REEL/FRAME:060697/0835Effective date: 20180522 |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: NON FINAL ACTION MAILED |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: RESPONSE TO NON-FINAL OFFICE ACTION ENTERED AND FORWARDED TO EXAMINER |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: NON FINAL ACTION MAILED |
|
STPP | Information on status: patent application and granting procedure in general |
Free format text: RESPONSE TO NON-FINAL OFFICE ACTION ENTERED AND FORWARDED TO EXAMINER |