US8850573B1 - Computing device with untrusted user execution mode - Google Patents
Computing device with untrusted user execution mode Download PDFInfo
- Publication number
- US8850573B1 US8850573B1 US12/886,960 US88696010A US8850573B1 US 8850573 B1 US8850573 B1 US 8850573B1 US 88696010 A US88696010 A US 88696010A US 8850573 B1 US8850573 B1 US 8850573B1
- Authority
- US
- United States
- Prior art keywords
- execution mode
- processor
- memory
- instructions
- instruction
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Expired - Fee Related, expires
Links
- 230000015654 memory Effects 0.000 claims abstract description 227
- 238000000034 method Methods 0.000 claims abstract description 123
- 238000012545 processing Methods 0.000 claims abstract description 27
- 230000004044 response Effects 0.000 claims description 19
- 230000007704 transition Effects 0.000 claims description 14
- 230000004048 modification Effects 0.000 claims description 11
- 238000012986 modification Methods 0.000 claims description 11
- 230000008859 change Effects 0.000 claims description 7
- 238000013459 approach Methods 0.000 description 30
- 238000010586 diagram Methods 0.000 description 18
- 238000004891 communication Methods 0.000 description 16
- 238000003860 storage Methods 0.000 description 14
- 238000004590 computer program Methods 0.000 description 8
- 238000007726 management method Methods 0.000 description 8
- 230000007246 mechanism Effects 0.000 description 6
- 230000008569 process Effects 0.000 description 5
- 230000006870 function Effects 0.000 description 4
- 230000007547 defect Effects 0.000 description 3
- 230000003287 optical effect Effects 0.000 description 3
- 241000700605 Viruses Species 0.000 description 2
- 230000006399 behavior Effects 0.000 description 2
- 230000001413 cellular effect Effects 0.000 description 2
- 230000000694 effects Effects 0.000 description 2
- 230000003993 interaction Effects 0.000 description 2
- 239000004973 liquid crystal related substance Substances 0.000 description 2
- 230000011218 segmentation Effects 0.000 description 2
- 238000012546 transfer Methods 0.000 description 2
- 230000009471 action Effects 0.000 description 1
- 230000008901 benefit Effects 0.000 description 1
- 238000005516 engineering process Methods 0.000 description 1
- 238000005111 flow chemistry technique Methods 0.000 description 1
- 238000004519 manufacturing process Methods 0.000 description 1
- 230000005055 memory storage Effects 0.000 description 1
- 230000006855 networking Effects 0.000 description 1
- 230000001953 sensory effect Effects 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
- 239000013589 supplement Substances 0.000 description 1
- 230000000007 visual effect Effects 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/10—Protecting distributed programs or content, e.g. vending or licensing of copyrighted material ; Digital rights management [DRM]
- G06F21/12—Protecting executable software
- G06F21/121—Restricting unauthorised execution of programs
- G06F21/125—Restricting unauthorised execution of programs by manipulating the program code, e.g. source code, compiled code, interpreted code, machine code
- G06F21/126—Interacting with the operating system
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F12/00—Accessing, addressing or allocating within memory systems or architectures
- G06F12/14—Protection against unauthorised use of memory or access to memory
- G06F12/1458—Protection against unauthorised use of memory or access to memory by checking the subject access rights
- G06F12/1491—Protection against unauthorised use of memory or access to memory by checking the subject access rights in a hierarchical protection system, e.g. privilege levels, memory rings
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F21/00—Security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F21/70—Protecting specific internal or peripheral components, in which the protection of a component leads to protection of the entire computer
- G06F21/71—Protecting specific internal or peripheral components, in which the protection of a component leads to protection of the entire computer to assure secure computing or processing of information
- G06F21/74—Protecting specific internal or peripheral components, in which the protection of a component leads to protection of the entire computer to assure secure computing or processing of information operating in dual or compartmented mode, i.e. at least one secure mode
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/30145—Instruction analysis, e.g. decoding, instruction word fields
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/30181—Instruction operation extension or modification
- G06F9/30189—Instruction operation extension or modification according to execution mode, e.g. mode flag
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2221/00—Indexing scheme relating to security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F2221/21—Indexing scheme relating to G06F21/00 and subgroups addressing additional information or applications relating to security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F2221/2105—Dual mode as a secondary aspect
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2221/00—Indexing scheme relating to security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F2221/21—Indexing scheme relating to G06F21/00 and subgroups addressing additional information or applications relating to security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F2221/2141—Access rights, e.g. capability lists, access control lists, access tables, access matrices
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F2221/00—Indexing scheme relating to security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F2221/21—Indexing scheme relating to G06F21/00 and subgroups addressing additional information or applications relating to security arrangements for protecting computers, components thereof, programs or data against unauthorised activity
- G06F2221/2149—Restricted operating environment
Definitions
- This application relates in general, to computer security. More specifically, this application relates to methods and apparatus for safely executing untrusted code.
- One problem with delivery of software applications (executable content) in these manners is that such content may easily exhibit malicious behavior (e.g., corrupting a computing system).
- Two common approaches to prevent programs from expressing such malicious behavior are interpreted languages, such as JavaScript and type-safe languages, such as C# and Java.
- the languages are designed in such a way that certain dangerous constructs are excluded, such that said constructs cannot be used to express a malicious operation.
- dangerous constructs include inline assembler, self-modifying code, type casts, pointer arithmetic, and traditional malloc/free heap management. While improving program safety, these restrictions also tend to impact performance and developer productivity and preferences.
- safety In the case of interpreter-based language implementations, safety relies on correct (e.g. bug-free) implementation of the interpreter. In the case of language implementations that use a bytecode language or intermediate representation, safety typically relies on the correct implementation of the bytecode compiler or interpreter. These compilers and interpreters are commonly large and complex software systems, and are rarely defect free. As such, they constitute a large attack surface for an attacker.
- One approach that is used to overcome the performance limitations of using interpreted languages for browser-based applications is the use of various extension mechanisms such as ActiveX and NPAPI plug-in environments.
- Such plug-in environments allow native code (e.g., machine instructions of the specific computing system) to be loaded and run in a browser as part of a web (browser-based) application. While such architectures allow browser-based applications to achieve the computational performance characteristics of native applications, they do so at expense of allowing the browser-based applications to circumvent the security mechanisms otherwise applied to web content using, for example, interpreted languages and/or secure runtime environments.
- Google Native Client provides computer users protection from malicious code using measures, such as validating and isolating or “software-sandboxing” native client code, which allow native code to be run within a browser in a secure and safe fashion.
- measures such as validating and isolating or “software-sandboxing” native client code, which allow native code to be run within a browser in a secure and safe fashion.
- Such methods have been described, for example, in the following applications, all of which are hereby incorporated by reference in their entirety: “Method for Validating an Untrusted Native Code Module,” application Ser. No. 12/117,634, filed May 8, 2008; “Method for Safely Executing an Untrusted Native Code Module on a Computing Device,” application Ser. No. 12/117,650, filed May 8, 2008; “Native Code Module Security for ARM Instruction Set Architectures,” application Ser. No. 12/621,286 filed Nov. 18, 2009, and “Native Code Module Security for 64-bit Instruction Set Architectures, application Ser. No. 12/621
- an example method includes receiving, at a processor, a request to run executable application code using a reduced level of trust in a computing system in which the processor is implemented.
- the example method further includes, in response to receiving the request, changing an execution mode of the processor from a first execution mode to a second execution mode.
- the example method also includes, in response to changing the execution mode from the first execution mode to the second execution mode, performing, by the processor, at least one of modifying an instruction set of the processor to designate one or more instructions that are legal in the first execution mode as being illegal; and restricting access to memory accessible by the processor in the first execution mode to a subset of the memory.
- an example apparatus in a second general aspect, includes an execution mode state indicator with a plurality of states.
- the execution mode state indicator is configured such that placing the execution mode state indicator in a first state causes the processor to operate in a first execution mode and placing the execution mode state indicator in a second state causes the processor to operate in a second execution mode.
- the example apparatus also includes an instruction processing module that is configured to implement a set of instructions in the first execution mode and designate one or more instructions of the set of instructions as illegal instructions in the second execution mode.
- the example apparatus further includes a memory system that, in the second execution mode, is configured to restrict access to a set of memory addresses accessible by the processor in the first execution mode to a subset of the set of memory addresses.
- FIG. 1 is a block diagram illustrating an approach for delivery of “untrusted” executable application code via a browser in accordance with an example embodiment.
- FIG. 2 is a diagram illustrating execution modes of a processor and/or computing system in accordance with an example embodiment.
- FIG. 3 is a block diagram of a processor in accordance with an example embodiment.
- FIG. 4 is a table illustrating modification of an instruction set of a processor for various execution modes in accordance with an example embodiment.
- FIG. 5 is a block diagram illustrating an instruction processing module of a processor in accordance with an example embodiment.
- FIG. 6 is a block diagram illustrating a memory system of a processor in accordance with an example embodiment.
- FIG. 7 is a block diagram illustrating a memory system of a processor in accordance with another example embodiment.
- FIG. 8 is a block diagram illustrating a memory system of a processor in accordance with yet another example embodiment.
- FIG. 9 is a flowchart illustrating a method of delivering untrusted executable application code in accordance with an example embodiment.
- FIG. 10 is a flowchart illustrating a method of executing untrusted executable application code in accordance with an example embodiment.
- FIG. 11 is a flowchart illustrating a method of executing untrusted executable application code in accordance with another example embodiment.
- FIG. 12 is a flowchart illustrating a method of requesting access to a system resource by untrusted executable code in accordance with an example embodiment.
- FIG. 13 is a flowchart illustrating a method of changing from an untrusted execution mode to a further-restricted untrusted execution mode in accordance with an example embodiment.
- FIG. 14 is a flowchart illustrating a method changing from an untrusted execution mode to a trusted execution mode in accordance with an example embodiment.
- FIG. 15 shows an example of a computing device and a mobile computing device that may be used to implement the techniques described herein.
- FIG. 1 is a block diagram illustrating a network 100 that may be used to deliver “untrusted” executable application code 135 to a user computing system 110 for execution on the computing system 110 .
- “untrusted” executable application code (or “untrusted code”) may refer to executable code that is provided to a computing system via an “untrusted source.” The determination of whether executable code is “trusted” or “untrusted” will depend on the particular embodiment. For instance, in the example embodiment shown in FIG. 1 , untrusted code 135 is provided to the computing system 110 via the browser application 115 , such as from a website that is located on a network, such as the Internet or World Wide Web (WWW) 130 .
- WWW World Wide Web
- a user may obtain the untrusted code 135 using the browser application 115 that is running on the user computer system 110 .
- untrusted code could be acquired in other manners, such as using File Transfer Protocol (FTP) or other mechanism for retrieving the untrusted code 135 from a network location.
- FTP File Transfer Protocol
- untrusted code 135 code may be provided in other fashions that do not involve a network connection, such as from an external drive or other source that is external to the computing system 110 .
- “untrusted code” could be delivered to the computing system along with “trusted code,” such as along with an application purchased via an online store.
- trusted code may refer to executable application code that is installed locally on the computing system 110 , such as code installed on a hard drive of the computing system by a user of the computing system.
- the user would assume responsibility for determining whether such locally installed code contains any malicious code, such as spyware, computer viruses or other malicious software (which may be collectively referred to as “malware”).
- malware malicious software
- trusted code may be executable application code that is installed on the computing system 110 during manufacture of the computing system 110 , such as the browser 135 .
- Such trusted code may be referred to as “trusted host applications” or “trusted applications.”
- a manufacturer of the computing system 110 would be responsible for determining that such locally installed executable application code is free of malware.
- any other executable code run on the computing system 110 may be treated as untrusted.
- a user of the computing system 110 may access the Internet or WWW 130 via a service provider 120 .
- the user may navigate to a website or Internet location from which the untrusted application code 135 can be acquired.
- the user may click or follow a link (e.g., hyperlink) in order to retrieve the untrusted code 135 .
- the untrusted code 135 may then be delivered to the browser 115 , e.g., via the service provider 120 , for execution by the computing system 110 .
- the computing system 110 may execute the untrusted code 135 in an untrusted execution mode, such as described herein.
- the network 100 is merely an example of one approach for obtaining untrusted code and other approaches, such as those discussed above, may be used to determine whether executable code is trusted or untrusted.
- the computing system may operate in a further-restricted untrusted execution mode while executing the untrusted code 135 .
- the computing system 110 may switch from the untrusted execution mode to the further-restricted untrusted execution mode in situations where the untrusted code generates or uses runtime generated code.
- the further-restricted untrusted execution mode may be used to execute code that is dynamically generated or accessed by the untrusted code 135 (e.g., just-in-time code or code in dynamically linked libraries that are called by the untrusted code 135 ).
- the computing system 110 or a processor of the computing system
- FIG. 2 is a diagram illustrating a plurality of execution modes that may be implemented by a processor using the techniques described herein.
- the execution modes are shown in increasing levels of trust moving from the outer portion of the diagram to the center of the diagram. While the diagram shown in FIG. 2 includes four trust levels, in other embodiments, a different number of trust levels may be used. For instance, in one embodiment, three trust levels may be used, while in other embodiments five or more trust levels may be used.
- kernel mode 200 a processor has unrestricted access to the resources of a computing system in which it is implemented. For instance, in kernel mode 200 , a processor may setup, modify or remove memory segments, or memory pages in a memory system of the processor. Such segments/pages may correspond with respective portions of memory storage devices that are operationally coupled with the processor, such as random access memory devices used to implement system memory for a computing system.
- the trusted execution mode 210 has the next-highest level of trust, as compared to the kernel mode 200 .
- a processor of a computing system is restricted in its actions as compared to the kernel mode 200 .
- the processor may not create memory segments or pages in the trusted execution mode 210 .
- the processor still has access to the resources of the computing system and may invoke an operating system (O/S) of the computing system in which it is implemented and also may have other capabilities that are not available in the kernel mode 200 .
- a trusted code base e.g., locally installed trusted executable application code
- Such a trusted code base could be stored using a non-volatile mass storage device of the computing system, such as using a hard disk drive or a flash drive, as two examples.
- a non-volatile mass storage device of the computing system such as using a hard disk drive or a flash drive, as two examples.
- the processor when operating in the trusted execution mode 210 , is able to invoke the O/S of its computing system and access resources of its computing system, untrusted code, if run in the trusted user mode 210 , may easily place malware on a computing system by using instructions that invoke an O/S of the computing system.
- the processor may operate in an untrusted execution mode 220 , such as described in further detail below, when executing untrusted code (e.g., such as application code 135 ).
- untrusted code e.g., such as application code 135
- the processor may restrict access to memory locations when operating in the untrusted execution mode 220 , so as to prevent untrusted code from placing malware into system memory that could then be executed when the processor returns to the trusted execution mode 210 .
- Such approaches may be advantageous as they may reduce security risks associated with software defects, where such defects may provide malicious actors with a mechanism to improperly invoke an O/S in order to corrupt or place malware on a user's computing system.
- a processor may be configured to operate in a further-restricted untrusted execution mode 230 .
- additional instructions of the processor may be designated as illegal to further reduce the risk of malware being placed on the computing system.
- the processor may be configured to operate in the further-restricted untrusted execution mode 230 when untrusted code attempts to execute dynamically generated code (e.g., just-in-time code, or runtime generated code).
- dynamically generated code e.g., just-in-time code, or runtime generated code.
- access to memory may be more restricted in the further-restricted untrusted execution mode as compared the untrusted execution mode.
- the capabilities of the processor may monotonically decrease at each reduced level of trust. For instance, when transitioning from the trusted execution mode 210 to the untrusted execution mode 220 , the processor may be configured to designate at least one instruction that is legal in the trusted execution mode 210 as being illegal in the untrusted execution mode 220 .
- the processor when transitioning from the trusted execution mode 210 to the untrusted execution mode 220 , the processor may be configured to designate at least one memory location that is accessible in the trusted execution mode 210 as protected in the untrusted execution mode 220 .
- the capabilities of the processor may be similarly reduced when transitioning from the untrusted execution mode 220 to the further-restricted untrusted execution mode 230 or from a higher level of trust to a lower level of trust.
- FIG. 3 is a block diagram of a processor 300 that may be used to implement the various execution modes illustrated in FIG. 2 .
- the processor 300 includes an execution mode state indicator 310 .
- the execution mode state indicator 310 may be configured to indicate a current execution mode of the processor, such as one of the execution modes discussed above with respect to FIG. 2 .
- the execution mode state indicator 310 may be implemented by a register, such as an execution mode state register or other appropriate mechanism for maintaining execution mode state information for the processor 300 .
- the execution mode state indicator 310 may be implemented in any appropriate fashion, depending on the particular embodiment and the processor architecture which is being used to implement the various execution states described herein.
- the execution mode state indicator 310 should have at least four possible states.
- the processor 300 when the execution mode state indicator 310 is in a first state, the processor 300 may operate in the kernel mode 200 .
- the processor 300 when the execution mode state indicator 310 is in a second state, the processor 300 may operate in the trusted execution mode 210 ; when the execution mode state indicator 310 is in a third state, the processor 300 may operate in the untrusted execution mode 220 ; and when the execution mode state indicator 310 is in a fourth state, the processor 300 may operate in the further-restricted untrusted execution mode 230 .
- other approaches for indicating an execution state for the processor 300 are possible and fewer or more execution states may be implemented, depending on the particular embodiment.
- the execution mode state indicator 310 may be coupled with other blocks of the processor 300 .
- the various blocks of the processor 300 may use a value stored in the execution mode state indicator 310 (or other state information) to modify the operation of the processor 300 in correspondence with an indicated execution state, such as to implement one of the execution modes discussed above with respect to FIG. 2 .
- the execution mode state indicator 310 may be coupled with an instruction processing module 320 of the processor 300 and may also be coupled with a memory system 330 of the processor 300 in order to provide execution state information to the instruction processing module 320 and the memory system 330 .
- the instruction processing module 320 of the processor 300 may designate one or more instructions of a trusted execution mode instruction set as illegal in the untrusted execution mode 220 .
- the instruction processing module 320 may designate instructions that invoke an O/S of a computing system in which the processor 300 is implemented as illegal.
- Such instructions may include syscall instructions, far-call instructions, inter-segment instructions, instructions that modify segment state and/or instructions that directly access resources of the computing system.
- a fault or exception may be raised in the processor 300 if any such instructions are included in untrusted code and attempt to execute while the processor is operating in the untrusted execution mode 220 .
- a computing system in which the processor 300 is implemented may be configured to terminate execution of untrusted code if an attempt is made to execute an instruction that is designated as illegal while executing the untrusted code in the untrusted execution mode.
- an O/S of the computing system may be used to process and handle the error, which may include determining where control-flow should resume after the error.
- the untrusted code process may be terminated by the O/S, such as by an error or fault handler.
- the instruction processing module 320 may be further configured to designate one or more additional instructions of the trusted execution mode 210 set of instructions (in addition to the instructions designated as illegal in the untrusted execution mode 220 ) as illegal instructions in the further-restricted untrusted execution mode 230 .
- attempting to execute an instruction that is designated as illegal in the further-restricted untrusted execution mode 230 may cause a fault or exception to be raised in the processor 300 and execution of the untrusted code to be terminated by the computing system.
- Example approaches for restricting an instruction set of the processor 300 for the various execution modes described herein are discussed in further detail with respect to FIGS. 4 and 5 .
- the memory system 330 of the processor 300 may restrict access by the processor 300 to a subset of memory (of a computing system) that is accessible by the processor 300 when operating in the trusted execution mode 210 . Further, when the execution mode state indicator 310 indicates that the processor should operate in the further-restricted untrusted execution mode 230 , the memory system 330 of the processor 300 may restrict access by the processor 300 to a further subset of memory of the computing system that is accessible by the processor 300 when operating in the trusted execution mode 210 or a subset of the memory accessible by the processor 300 when operating in the untrusted execution mode 220 .
- a number of approaches may be used to define the subset of memory that is accessible by the processor in the untrusted execution mode 220 .
- the memory system 330 of the processor 300 may restrict memory access in the untrusted execution mode 220 to a subset of memory segments that are accessible by the processor 300 in the trusted execution mode 210 .
- An example of such an approach is illustrated in FIG. 6 and is discussed in further detail below.
- the processor 300 may use memory pages to define blocks of memory locations that are accessible by the processor 300 .
- the memory system 330 may restrict memory access in the untrusted execution mode 220 to a subset of memory pages that are accessible to the processor in the trusted execution mode 210 . Such an approach is illustrated in FIG. 7 and is discussed in further detail below.
- the processor may use base/bound register pairs to define memory ranges that are accessible to the processor 300 .
- the processor 300 may include one or more respective base/bound register pairs for each execution mode to define the memory ranges that are accessible by the processor 300 in a given execution mode.
- base/bound register pairs for the untrusted execution mode 220 may define memory ranges that are a subset of the memory ranges that are accessible by the processor 300 in the trusted execution mode 210 .
- FIG. 8 is discussed in further detail below.
- each of the approaches for restricting access to memory in the untrusted execution mode 220 may be similarly applied when the execution mode state indicator 310 indicates that the processor 300 is to operate in the further-restricted execution mode 230 .
- the memory system 330 when operating in the further-restricted execution mode 230 , may further restrict access to memory by the processor 300 to a subset of memory segments or memory pages that are accessible to the processor 300 in the untrusted execution mode 220 .
- the memory system 330 may also define a subset of memory ranges accessible by the processor 300 in the untrusted execution mode 220 using one or more further-restricted untrusted execution mode base/bound register pairs.
- example embodiments of the various techniques for restricting memory access based on an execution mode of the processor 300 are illustrated in FIGS. 6 , 7 and 8 and discussed in further detail below.
- FIG. 4 is a table 400 that illustrates an example embodiment of an instruction set, including example modifications to that instruction set.
- the table 400 may be used to implement the various execution modes illustrated in FIG. 2 .
- the table 400 lists, for a set of instructions, whether each instruction is legal, illegal or changed for each of the execution modes 200 - 230 illustrated in FIG. 2 .
- the operations of one or more instructions of the trusted execution mode 210 instruction set may be changed when operating in the untrusted execution mode 220 and/or the further-restricted untrusted execution mode 230 to perform operations that facilitate transitioning a processor from the further-restricted untrusted execution mode 230 to the untrusted execution mode 220 , or from the untrusted execution mode 220 to the trusted execution mode 210 .
- the respective operations of one or more instructions may be changed in different execution modes to perform different functions not related to transitioning between execution modes.
- the table 400 may be implemented, for example, in the instruction processing module 320 of the processor 300 in a number of fashions.
- the table 400 may be implemented as a lookup table in the instruction processing module 320 .
- the table 400 may be indexed using the instruction, or a field of the instruction, being decoded to determine the row of the table 400 and using the execution state information in the execution mode state indicator 310 to determine the appropriate column of the table 400 .
- the table 400 may be implemented in the instruction processing module 320 of the processor using a content addressable memory (CAM).
- CAM content addressable memory
- an instruction bitmap may be used to designate whether an instruction is legal, illegal or changed in a particular execution mode. Such an approach is illustrated in FIG. 5 and is described in further detail below.
- each instruction of a processor's instruction set may be defined as being legal, illegal or changed in each execution mode.
- the operation of the instruction could be changed as compared to the operation of the instruction at a higher level of trust.
- “Instruction 5” in the table 400 is legal in kernel mode, and trusted mode, but is changed in untrusted mode and further-restricted untrusted mode.
- the respective operation of “Instruction 5” may be changed in the untrusted mode and the further-restricted untrusted mode (as compared to operation in the kernel mode and the trusted execution mode) to an operation that facilitates transitioning from the further-restricted untrusted execution mode 230 to the untrusted execution mode 220 , or from the untrusted execution mode 220 to the trusted execution mode 210 .
- the operation of “Instruction 5” may be changed in the untrusted mode and the further-restricted untrusted mode to simply perform a different function than in the kernel mode and the trusted mode.
- “Instruction 1” is legal in kernel mode, but is illegal in trusted mode, untrusted mode and further-restricted untrusted mode.
- “Instruction 1” may be an instruction that relates to creation of memory segments, memory page definition or other instructions that, for security reasons (i.e., to prevent the introduction of malware or corruption to a computing system) would only be performed by a processor when operating in its most trusted (kernel) execution mode.
- “Instruction 2” is legal in kernel mode and trusted mode, but is illegal in untrusted mode and further-restricted untrusted mode.
- Such an instruction may be, as was discussed above, a syscall instruction.
- “Instruction 2” may be a far-call instruction, a halt instruction, an instruction that modifies memory segment state or a memory page table, or an inter-segment or inter-page instruction.
- Instruction 4 is designated as legal in kernel mode, trusted mode and untrusted mode, but is designated as illegal in further-restricted untrusted mode.
- Such instructions may be instructions related to cryptography, backward branch instructions, and control-flow transfer instructions to dynamically computed targets, as some examples.
- the specific instructions that may be made illegal would depend on the specific embodiment.
- FIG. 5 is a block diagram illustrating an instruction processing module 500 in accordance with an example embodiment.
- the instruction processing module 500 may be included in the processor 300 (as instruction processing module 320 ) and used to implement the example modified instruction set illustrated in FIG. 4 in order to implement different execution modes, such as the execution modes illustrated in FIG. 2 and described herein.
- the instruction processing module 500 includes an instruction decoder 510 .
- the instruction decoder 510 may receive execution mode state information 520 in order to select an instruction bitmap to refer to during instruction decoding.
- the execution mode state information 520 may be provided to the instruction decoder 510 from an execution mode state indicator, such as the execution mode state indicator 310 , which was described above with respect to FIG. 3 .
- the execution state information 520 may be provided to the instruction processing module 500 and/or the instruction decoder 510 in a number of other appropriate fashions.
- the instruction decoder 510 may decode instructions by referring to one of the instruction bitmaps 530 - 550 included in the instruction processing module 500 .
- the table 400 of FIG. 4 may be implemented in the instruction processing module 500 using the bitmaps 530 - 550 .
- the instruction designations in the trusted execution mode column of the table 400 may be included in the trusted bitmap 530 .
- the instructions designations in the untrusted execution mode column of the table 400 may be implemented in the untrusted bitmap 540 .
- the instruction designations in the further-restricted untrusted mode column of the table 400 may be implemented in the further-restricted untrusted mode bitmap 550 .
- the instruction decoder 510 would decode instructions with reference to the appropriate bitmap based on the execution mode state information 520 provided to the instruction processing module 500 and/or the instruction decoder 510 .
- the instruction bitmaps of the instruction processing module 500 may be produced by logically ANDing an instruction bitmap for a given execution mode with an instruction bitmap for an execution mode with the next higher level of trust.
- the untrusted bitmap 540 may be produced by logically ANDing a bitmap that indicates the modifications to a processor instruction set between the trusted mode and the untrusted mode with the trusted bitmap 530 .
- each execution mode may have its own unique instruction bitmap and logical operations would not be performed to produce the instruction bitmaps 530 - 550 .
- the instruction bitmaps may be fixed in read-only memory or, alternatively, may be writeable (such as part of a boot sequence) in order to allow for flexibility in designating which instruction are legal, illegal or have changed operations in the various execution modes.
- FIG. 6 is a block diagram illustrating a memory system 600 in accordance with an example embodiment that may be included in the processor 300 and used to restrict access to memory when operating in various execution modes.
- the memory system 600 may be used in the processor 300 illustrated in FIG. 3 as the memory system 330 . Further, the memory system 600 may be used to restrict memory access in various execution modes, such as the execution modes described above with reference to FIG. 2 , in processor architectures that utilize memory segmentation to allocate memory in a computing system.
- the memory system 600 may include a memory management unit 610 .
- the memory management unit 610 may receive execution mode state information 620 in a number of ways, such as using the approaches described herein. Based on the execution mode state information 620 , the memory management unit 610 may operate using a memory segment table that defines memory segments that are accessible by a processor in an execution mode that corresponds with the execution mode state information.
- the memory management unit 610 may use a trusted segment table 630 to determine memory segments that are valid and/or accessible by the processor in the trusted execution mode and whether those segments are read-only or read-write accessible. Likewise, if the execution mode state information 620 indicates that a processor is operating in an untrusted execution mode, the memory management unit 610 may use an untrusted segment table 640 to determine which memory segments are valid in the untrusted execution mode.
- the memory management unit 610 may use a further-restricted untrusted segment table 650 to determine which memory segments are valid in the further-restricted untrusted execution mode.
- the memory management unit 610 may be configured to treat the memory access request as an attempt to reference a protected memory location.
- FIG. 7 is a block diagram illustrating a memory system 700 in accordance with an example embodiment that may be included in the processor 300 and used to restrict access to memory when operating in various execution modes.
- the memory system 700 may be used in the processor 300 illustrated in FIG. 3 as the memory system 330 . Further, the memory system 700 may be used to restrict memory access in various execution modes, such as the execution modes described above with reference to FIG. 2 , in processor architectures that utilize memory page tables to allocate memory in a computing system.
- the memory system 700 may include a memory controller 710 .
- the memory controller 710 may receive execution mode state information 720 in a number of ways, such as using the approaches described herein. Based on the execution mode state information 720 , the memory controller 710 may operate using a memory page table that defines memory pages that are accessible by a processor in an execution mode that corresponds with the execution mode state information.
- the memory controller 710 may use a trusted page table 730 to determine memory pages that are valid and/or accessible by the processor in the trusted execution mode and whether those memory pages are read-only or read-write accessible. Likewise, if the execution mode state information 720 indicates that a processor is operating in an untrusted execution mode, the memory controller 710 may use an untrusted page table 740 to determine which memory pages are valid in the untrusted execution mode.
- the memory controller 710 may use a further-restricted untrusted page table 750 to determine which memory pages are valid in the further-restricted untrusted execution mode.
- the memory controller 710 may be configured to treat the memory access request as an attempt to reference a protected memory location.
- FIG. 8 is a block diagram illustrating a memory system 800 in accordance with an example embodiment that may be included in the processor 300 and used to restrict access to memory when operating in various execution modes.
- the memory system 800 may be used in the processor 300 illustrated in FIG. 3 as the memory system 330 . Further, the memory system 800 may be used to restrict memory access in various execution modes, such as the execution modes described above with reference to FIG. 2 , using one or more respective base/bound register pairs to define valid memory location for each execution mode.
- Base/bound register pairs may define valid memory ranges using a base memory address that is stored in the base register of a given pair and a bound value that is either an absolute memory address, or a size of the memory range that is used as a relative bound address in conjunction with the base address.
- one gigabyte memory range may be defined in a base/bound register pair by storing a base address in the base register.
- the base address may be an absolute address of 0x40000000h.
- the bound register, for a one gigabyte memory range may be defined absolutely as 0x 80000000h or relatively as 0x40000000h.
- the relative bound of 0x40000000h would then be combined with the base address of 0x40000000h to produce an upper bound of 0x 80000000h. Either approach may be implemented in the memory system 800 .
- the memory system 800 may include a memory controller 810 .
- the memory controller 810 may receive execution mode state information 820 in a number of ways, such as using the approaches described herein. Based on the execution mode state information 820 , the memory controller 810 may operate using memory base/bound register pairs to define memory address that are accessible by a processor in an execution mode that corresponds with the execution mode state information 820 . Each execution mode may have one or more base/bound register pairs associated with it in the memory system 800 .
- the memory controller 810 may use trusted base/bound register pairs 830 to determine memory ranges that are valid and/or accessible by the processor in the trusted execution mode.
- the execution mode state information 820 indicates that a processor is operating in an untrusted execution mode
- the memory controller 810 may use untrusted base/bound register pairs 840 to determine memory ranges that are valid and/or accessible by the processor in the untrusted execution mode.
- the memory controller 810 may use further-restricted untrusted base/bound register pairs 850 to determine memory ranges that are valid and/or accessible by the processor in the further-restricted untrusted execution mode.
- the memory controller 810 may be configured to treat the memory access request as an attempt to reference a protected memory location.
- a processor that includes the memory system 800 may be configured to determine appropriate base/bound register values for the various execution modes and write those values when the processor enters a given execution and/or as part of a boot process.
- the values stored in the base/bound register pairs 830 - 850 may be fixed for a given processor architecture and memory configuration and may be permanently stored in the processor (i.e., using read-only memory structures) or, as one alternative, be written into the appropriate base/bound registers as part of a boot sequence and not changed during operation of the processor.
- FIG. 9 is a flowchart illustrating a method 900 of delivering untrusted executable application code to a computing system in accordance with an example embodiment.
- the method 900 may be implemented using the apparatus that were described above with respect to FIGS. 1-8 . Alternatively, other apparatus may be used to implement the method 900 .
- the method 900 includes, at block 910 , receiving, at a processor of a computing system, a request to run executable application code in the computing system using a reduced level of trust.
- the method 900 includes, in response to receiving the request, changing an execution mode of the processor from a first execution mode to a second execution mode, such as from a trusted execution mode to an untrusted execution mode or from an untrusted execution mode to a further-restricted untrusted execution mode, as two examples. This change may be accomplished, for example, by a processor changing execution state information stored, for example, in an execution mode state indicator, such as was described above with respect to FIG. 3 .
- the method 900 includes operations 940 - 960 , which at least one of is performed, e.g., by a processor, in response to changing the execution mode from the first execution mode to the second execution mode.
- the method 900 includes modifying an instruction set of the processor to designate one or more instructions that are legal in the first execution mode as being illegal, such as in the fashions described above with respect to FIGS. 3 , 4 and 5 , for example.
- the method 900 includes restricting access to memory accessible by the processor in the first execution mode to a subset of the memory, such as in the fashions described above with respect to FIGS. 3 , 6 , 7 and 8 , for example.
- the method 900 includes changing respective operation of one or more other instructions of the processor's instruction set, such as was illustrated and described above with respect to FIG. 4 , for example.
- one or more instructions may be modified to operate so as to facilitate a processor transitioning from a lower trust level to a higher trust level, such as transitioning from a further-restricted untrusted execution mode to an untrusted execution mode; or transitioning from an untrusted execution mode to a trusted execution mode.
- other instructions may be changed to simply perform different operations at lower trust levels, as compared with their operation at higher trust levels.
- FIG. 10 is a flowchart illustrating a method 1000 for executing untrusted executable application code (e.g., in an untrusted execution mode, in further-restricted untrusted execution mode, or in some other reduced trust execution mode) in accordance with an example embodiment.
- the method 1000 will be described in the context of executing untrusted code in an untrusted execution mode, such as the untrusted execution mode 220 discussed above with respect to FIG. 2 .
- the method 1000 may be used to execute untrusted code at a number of reduced trust levels.
- the method 1000 includes, at block 1010 , decoding an instruction of the untrusted executable application code.
- a determination is made (e.g., by an instruction decoder) whether the decoded instruction is illegal in the current execution mode. If it is determined at block 1020 that the decoded instruction is not illegal in the current execution mode, the method continues to block 1030 .
- the method 1000 includes executing the decoded instruction, such as in accordance with a lookup table, such as the table 400 illustrated in FIG. 4 .
- a determination as to the specific operation to be performed by the decoded instruction may be made when the instruction is decoded (e.g., in accordance with the table 400 , for example).
- the method 1000 then continues to block 1040 .
- the method 1000 includes determining whether execution of the untrusted code is complete. If execution is complete, the method 1000 continues to block 1050 and execution returns to a trusted execution mode. In other situations, execution may return from a further-restricted untrusted execution mode to an untrusted execution mode. The specific sequence of events may depend on the particular untrusted code being executed and/or the particular processor that is used to execute the untrusted code. If it is determined, at block 1040 , that execution of the untrusted code is not complete, the method 1000 returns to block 1010 and a next instruction of the untrusted code is decoded and the operations of the method 1000 are carried out for this next instruction.
- the method 1000 continues to block 1060 .
- the method 1000 includes raising a fault or exception in a processor that is used to implement the method.
- the method 1000 includes, at block 1070 , handling the fault by terminating execution of the untrusted code. Such fault handling is typically handled in software, though other approaches are possible.
- the processor may return control-flow processing to a location in a trusted code base and change the execution mode state information (e.g., in an execution mode state indicator) to indicate that the processor is operating in a trusted execution mode.
- FIG. 11 is a flowchart illustrating a method 1100 of executing untrusted executable application code in accordance with another example embodiment.
- the operations 1110 , 1120 , 1140 , 1150 and 1160 are substantially the same as their respective operations 1010 , 1020 , 1030 , 1040 and 1060 in the method 1000 illustrated in FIG. 10 .
- these operations are not described in detail again with respect to the method 1100 .
- the method 1100 includes, at block 1130 , determining whether the decoded instruction (decoded at block 1110 ) is a transition instruction, such as was described with respect to FIG. 4 above. If it is determined, at block 1130 , that the decoded instruction is a transition instruction, the method 1100 continues to block 1170 .
- a processor implementing the method 1100 may transition from an untrusted execution mode to a trusted execution mode. In other embodiments, the processor may transition from a further-restricted untrusted execution mode to an untrusted execution mode or a trusted execution mode, depending on the particular situation. In still other embodiments, the processor may transition from an execution mode having a lower level of trust to an execution mode having a higher level of trust.
- the method 1100 if it is determined, at block 1150 , that execution of a block of untrusted code is complete, the method 1100 continues to block 1170 and a processor implementing the method 1100 may return to a trusted execution mode from an untrusted execution mode or a further-restricted untrusted execution mode. In other embodiments, the processor may transition from the further-restricted untrusted execution mode to the untrusted execution mode as a result of determining, at block 1150 , that execution of a block of untrusted code is complete.
- FIG. 12 is a flowchart illustrating a method 1200 of requesting access to a system resource by untrusted executable code in accordance with an example embodiment.
- the method 1200 will be described with reference to a trusted execution mode and an untrusted execution mode, such as described above. It will be appreciated, however, that the method 1200 may be applied in conjunction with execution modes having other trust levels.
- the method 1200 includes, at block 1210 , the untrusted code requesting access to a resource of the computing system that is controlled by an operating system of a computing system in which the method 1200 is being implemented.
- the method includes returning to the trusted execution mode to determine if the request should be fulfilled or not.
- the method 1200 includes determining, using one or more instructions in a trusted code base (e.g., code locally installed on the computing system) whether the instruction in which the request was included is potentially malicious (e.g., could be used to place malware on the computing system).
- a trusted code base e.g., code locally installed on the computing system
- the method 1200 continues to block 1240 .
- the method 1200 includes fulfilling the request and the method continues to block 1250 .
- the method 1200 includes returning to the untrusted execution mode (or a further-restricted untrusted execution mode) at a control-flow point where the request was made at block 1210 .
- the method 1200 includes providing the results of the request (if any) to the untrusted code.
- the method 1200 continues to block 1270 .
- the method 1200 includes, denying the request (e.g., using one or more instructions in the trusted code base).
- the method 1200 then continues to block 1280 , where control-flow is returned to the point in the untrusted code where the request was made.
- the processor could make a decision to continue execution of the untrusted code or, alternatively, the processor could make a decision to terminate execution of the untrusted code as a result of the request being potentially malicious.
- the processor may then return to the trusted execution mode and select a safe control-flow point to resume execution in the trusted code base.
- safe control-flow points may be locations associated with error handlers or fault handlers.
- FIG. 13 is a flowchart illustrating a method 1300 of changing an execution mode of a processor from a first untrusted execution mode to a second untrusted execution mode in accordance with an example embodiment.
- the second untrusted execution mode has a lower trust level than the first untrusted execution mode.
- a processor may change from operating in the first untrusted execution mode to operating in the second untrusted execution mode as a result of changing execution state information that is stored, for example, in an execution mode state indicator, as in like fashion as was previously described with respect to FIG. 9 .
- the method 1300 may be used, for example, to transition a processor from operating in the untrusted execution mode 220 to the further-restricted untrusted execution mode 230 , as discussed above with respect to FIG. 2 .
- the method 1300 includes, at block 1310 , further modifying a processor's instruction set, such as compared to modifications made for the first untrusted execution mode.
- the modifications at block 1310 may be modifications that are incremental to modifications made when changing from a trusted execution mode to the untrusted execution mode.
- the modifications made at block 1310 may designate one or more additional instructions of a trusted execution mode instruction set as being illegal in the further-restricted untrusted execution mode.
- further modifying the trusted execution mode instruction set may be accomplished by logically ANDing a first bitmap indicating the one or more instructions designated as illegal in the untrusted execution mode and a second bitmap indicating the one or more additional instructions designated as illegal in the further-restricted untrusted execution mode.
- the bitmaps may also indicate instructions that have changed operations in the untrusted execution mode and/or the further-restricted untrusted execution mode, as compared with their operations in the trusted execution mode.
- the method 1300 also includes, at block 1320 further restricting access to memory of a computing system to a subset of memory available in the first untrusted execution mode. As was discussed above with respect to FIGS. 6-8 , a number of techniques may be used to further restrict the memory that is accessible to a processor when operating in the second untrusted execution mode.
- FIG. 14 is a flowchart illustrating a method 1400 for changing from an execution mode having a lower level of trust to an execution mode having a higher level of trust in accordance with an example embodiment.
- the method 1400 will be described with reference to changing from an untrusted execution mode to a trusted execution mode, such as the execution modes discussed above. It will be appreciated that a similar approach to the method 1400 may be used to change from a further-restricted execution mode to an untrusted execution mode or to a trusted execution mode; or to transition from a less trusted execution mode to an execution mode with a higher level of trust.
- the method 1400 includes, at block 1410 , receiving a request to transition from the untrusted execution mode to the trusted execution mode.
- request to access protected resources of a computing system may cause a transition from the untrusted execution mode to the trusted execution mode.
- Such a request may be made using an instruction whose operation was changed to facilitate this transition, such as was discussed above with respect to FIG. 4 , for example.
- the method 1400 includes stopping execution of the executable application code at a safe point, such as at a transition instruction.
- the method 1400 includes saving untrusted execution mode state information.
- state information may include saving status register values onto a stack, including the program counter and a stack pointer value once the status information is saved.
- the method 1400 includes returning control-flow of a processor implementing the method 1400 to an instruction in a trusted code base.
- the return of control-flow may be limited to predefined “safe” locations in the trusted code base.
- the method 1400 includes restoring state information for the trusted execution mode, which may include changing the execution mode state to indicate that the processor is operating in the trusted execution mode, changing the program counter to correspond with the location in the trusted code base to which control-flow was returned, and change the stack pointer to indicate a stack location for the trusted execution mode, which could have been saved when the processor transitioned from the trusted execution mode to the untrusted execution mode.
- the method 1400 includes executing the instruction corresponding with the restored value of the program counter.
- FIG. 15 is a diagram that shows an example of a generic computer device 1500 and a generic mobile computer device 1550 , which may be used with the techniques described here.
- Computing device 1500 is intended to represent various forms of digital computers, such as laptops, desktops, workstations, personal digital assistants, servers, blade servers, mainframes, and other appropriate computers.
- Computing device 1550 is intended to represent various forms of mobile devices, such as personal digital assistants, cellular telephones, smart phones, and other similar computing devices.
- the components shown here, their connections and relationships, and their functions, are meant to be exemplary only, and are not meant to limit implementations of the inventions described and/or claimed in this document.
- Computing device 1500 includes a processor 1502 , memory 1504 , a storage device 1506 , a high-speed interface 1508 connecting to memory 1504 and high-speed expansion ports 1510 , and a low speed interface 1512 connecting to low speed bus 1514 and storage device 1506 .
- Each of the components 1502 , 1504 , 1506 , 1508 , 1510 , and 1512 are interconnected using various busses, and may be mounted on a common motherboard or in other manners as appropriate.
- the processor 1502 can process instructions for execution within the computing device 1500 , including instructions stored in the memory 1504 or on the storage device 1506 to display graphical information for a GUI on an external input/output device, such as display 1516 coupled to high speed interface 1508 .
- multiple processors and/or multiple buses may be used, as appropriate, along with multiple memories and types of memory.
- multiple computing devices 1500 may be connected, with each device providing portions of the necessary operations (e.g., as a server bank, a group of blade servers, or a multi-processor system).
- the memory 1504 stores information within the computing device 1500 .
- the memory 1504 is a volatile memory unit or units.
- the memory 1504 is a non-volatile memory unit or units.
- the memory 1504 may also be another form of computer-readable medium, such as a magnetic or optical disk.
- the storage device 1506 is capable of providing mass storage for the computing device 1500 .
- the storage device 1506 may be or contain a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device, or an array of devices, including devices in a storage area network or other configurations.
- a computer program product can be tangibly embodied in an information carrier.
- the computer program product may also contain instructions that, when executed, perform one or more methods, such as those described above.
- the information carrier is a computer- or machine-readable medium, such as the memory 1504 , the storage device 1506 , or memory on processor 1502 .
- the high speed controller 1508 manages bandwidth-intensive operations for the computing device 1500 , while the low speed controller 1512 manages lower bandwidth-intensive operations.
- the high-speed controller 1508 is coupled to memory 1504 , display 1516 (e.g., through a graphics processor or accelerator), and to high-speed expansion ports 1510 , which may accept various expansion cards (not shown).
- low-speed controller 1512 is coupled to storage device 1506 and low-speed expansion port 1514 .
- the low-speed expansion port which may include various communication ports (e.g., USB, Bluetooth, Ethernet, wireless Ethernet) may be coupled to one or more input/output devices, such as a keyboard, a pointing device, a scanner, or a networking device such as a switch or router, e.g., through a network adapter.
- input/output devices such as a keyboard, a pointing device, a scanner, or a networking device such as a switch or router, e.g., through a network adapter.
- the computing device 1500 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a standard server 1520 , or multiple times in a group of such servers. It may also be implemented as part of a rack server system 1524 . In addition, it may be implemented in a personal computer such as a laptop computer 1522 . Alternatively, components from computing device 1500 may be combined with other components in a mobile device (not shown), such as device 1550 . Each of such devices may contain one or more of computing device 1500 , 1550 , and an entire system may be made up of multiple computing devices 1500 , 1550 communicating with each other.
- Computing device 1550 includes a processor 1552 , memory 1564 , an input/output device such as a display 1554 , a communication interface 1566 , and a transceiver 1568 , among other components.
- the device 1550 may also be provided with a storage device, such as a microdrive or other device, to provide additional storage.
- a storage device such as a microdrive or other device, to provide additional storage.
- Each of the components 1550 , 1552 , 1564 , 1554 , 1566 , and 1568 are interconnected using various buses, and several of the components may be mounted on a common motherboard or in other manners as appropriate.
- the processor 1552 can execute instructions within the computing device 1550 , including instructions stored in the memory 1564 .
- the processor may be implemented as a chipset of chips that include separate and multiple analog and digital processors.
- the processor may provide, for example, for coordination of the other components of the device 1550 , such as control of user interfaces, applications run by device 1550 , and wireless communication by device 1550 .
- Processor 1552 may communicate with a user through control interface 1558 and display interface 1556 coupled to a display 1554 .
- the display 1554 may be, for example, a TFT LCD (Thin-Film-Transistor Liquid Crystal Display) or an OLED (Organic Light Emitting Diode) display, or other appropriate display technology.
- the display interface 1556 may comprise appropriate circuitry for driving the display 1554 to present graphical and other information to a user.
- the control interface 1558 may receive commands from a user and convert them for submission to the processor 1552 .
- an external interface 1562 may be provide in communication with processor 1552 , so as to enable near area communication of device 1550 with other devices. External interface 1562 may provide, for example, for wired communication in some implementations, or for wireless communication in other implementations, and multiple interfaces may also be used.
- the memory 1564 stores information within the computing device 1550 .
- the memory 1564 can be implemented as one or more of a computer-readable medium or media, a volatile memory unit or units, or a non-volatile memory unit or units.
- Expansion memory 1574 may also be provided and connected to device 1550 through expansion interface 1572 , which may include, for example, a SIMM (Single In Line Memory Module) card interface.
- SIMM Single In Line Memory Module
- expansion memory 1574 may provide extra storage space for device 1550 , or may also store applications or other information for device 1550 .
- expansion memory 1574 may include instructions to carry out or supplement the processes described above, and may include secure information also.
- expansion memory 1574 may be provide as a security module for device 1550 , and may be programmed with instructions that permit secure use of device 1550 .
- secure applications may be provided via the SIMM cards, along with additional information, such as placing identifying information on the SIMM card in a non-hackable manner.
- the memory may include, for example, flash memory and/or NVRAM memory, as discussed below.
- a computer program product is tangibly embodied in an information carrier.
- the computer program product contains instructions that, when executed, perform one or more methods, such as those described above.
- the information carrier is a computer- or machine-readable medium, such as the memory 1564 , expansion memory 1574 , or memory on processor 1552 , which may be received, for example, over transceiver 1568 or external interface 1562 .
- Device 1550 may communicate wirelessly through communication interface 1566 , which may include digital signal processing circuitry where necessary. Communication interface 1566 may provide for communications under various modes or protocols, such as GSM voice calls, SMS, EMS, or MMS messaging, CDMA, TDMA, PDC, WCDMA, CDMA2000, or GPRS, among others. Such communication may occur, for example, through radio-frequency transceiver 1568 . In addition, short-range communication may occur, such as using a Bluetooth, WiFi, or other such transceiver (not shown). In addition, GPS (Global Positioning System) receiver module 1570 may provide additional navigation- and location-related wireless data to device 1550 , which may be used as appropriate by applications running on device 1550 .
- GPS Global Positioning System
- Device 1550 may also communicate audibly using audio codec 1560 , which may receive spoken information from a user and convert it to usable digital information. Audio codec 1560 may likewise generate audible sound for a user, such as through a speaker, e.g., in a handset of device 1550 . Such sound may include sound from voice telephone calls, may include recorded sound (e.g., voice messages, music files, etc.) and may also include sound generated by applications operating on device 1550 .
- Audio codec 1560 may receive spoken information from a user and convert it to usable digital information. Audio codec 1560 may likewise generate audible sound for a user, such as through a speaker, e.g., in a handset of device 1550 . Such sound may include sound from voice telephone calls, may include recorded sound (e.g., voice messages, music files, etc.) and may also include sound generated by applications operating on device 1550 .
- the computing device 1550 may be implemented in a number of different forms, as shown in the figure. For example, it may be implemented as a cellular telephone 1580 . It may also be implemented as part of a smart phone 1582 , personal digital assistant, or other similar mobile device.
- implementations of the systems and techniques described here can be realized in digital electronic circuitry, integrated circuitry, specially designed ASICs (application specific integrated circuits), computer hardware, firmware, software, and/or combinations thereof.
- ASICs application specific integrated circuits
- These various implementations can include implementation in one or more computer programs that are executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device.
- the systems and techniques described here can be implemented on a computer having a display device (e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor) for displaying information to the user and a keyboard and a pointing device (e.g., a mouse or a trackball) by which the user can provide input to the computer.
- a display device e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor
- a keyboard and a pointing device e.g., a mouse or a trackball
- Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback (e.g., visual feedback, auditory feedback, or tactile feedback); and input from the user can be received in any form, including acoustic, speech, or tactile input.
- the systems and techniques described here can be implemented in a computing system that includes a back end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front end component (e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here), or any combination of such back end, middleware, or front end components.
- the components of the system can be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include a local area network (“LAN”), a wide area network (“WAN”), and the Internet.
- LAN local area network
- WAN wide area network
- the Internet the global information network
- the computing system can include clients and servers.
- a client and server are generally remote from each other and typically interact through a communication network.
- the relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.
Abstract
Description
Claims (38)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US12/886,960 US8850573B1 (en) | 2010-04-14 | 2010-09-21 | Computing device with untrusted user execution mode |
Applications Claiming Priority (2)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US32426010P | 2010-04-14 | 2010-04-14 | |
US12/886,960 US8850573B1 (en) | 2010-04-14 | 2010-09-21 | Computing device with untrusted user execution mode |
Publications (1)
Publication Number | Publication Date |
---|---|
US8850573B1 true US8850573B1 (en) | 2014-09-30 |
Family
ID=51588366
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US12/886,960 Expired - Fee Related US8850573B1 (en) | 2010-04-14 | 2010-09-21 | Computing device with untrusted user execution mode |
Country Status (1)
Country | Link |
---|---|
US (1) | US8850573B1 (en) |
Cited By (13)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20080234999A1 (en) * | 2007-03-22 | 2008-09-25 | Searete Llc, A Limited Liability Corporation Of The State Of Delaware | Implementing performance-dependent transfer or execution decisions from service emulation indications |
US20080235000A1 (en) * | 2007-03-22 | 2008-09-25 | Searete Llc, A Limited Liability Corporation Of The State Of Delaware | Implementing security control practice omission decisions from service emulation indications |
US20130036448A1 (en) * | 2011-08-03 | 2013-02-07 | Samsung Electronics Co., Ltd. | Sandboxing technology for webruntime system |
US20150067775A1 (en) * | 2013-08-30 | 2015-03-05 | Dell Products, Lp | System and Method of Secure Logon for Shared Devices |
US20150121516A1 (en) * | 2013-10-30 | 2015-04-30 | Samsung Electronics Co., Ltd. | Authenticating input in trusted execution mode |
WO2016123013A1 (en) * | 2015-01-29 | 2016-08-04 | Universal Electronics Inc. | System and method for prioritizing and filtering cec commands |
US9558019B2 (en) | 2007-03-22 | 2017-01-31 | Invention Science Fund I, Llc | Coordinating instances of a thread or other service in emulation |
US20170372081A1 (en) * | 2015-07-23 | 2017-12-28 | Ca, Inc. | Executing privileged code in a process |
CN107735775A (en) * | 2015-07-10 | 2018-02-23 | Arm 有限公司 | Apparatus and method for carrying out execute instruction using the range information associated with pointer |
WO2018215733A1 (en) * | 2017-05-25 | 2018-11-29 | Arm Limited | An apparatus and method for managing a capability domain |
US11036560B1 (en) * | 2016-12-20 | 2021-06-15 | Amazon Technologies, Inc. | Determining isolation types for executing code portions |
US11055402B2 (en) * | 2017-09-29 | 2021-07-06 | Qualcomm Incorporated | Dynamically generated code process sandboxing using authenticated pointers |
US20230061228A1 (en) * | 2019-11-06 | 2023-03-02 | Fastly Inc. | Managing shared applications at the edge of a content delivery network |
Citations (32)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5483649A (en) * | 1994-07-01 | 1996-01-09 | Ybm Technologies, Inc. | Personal computer security system |
US5574927A (en) * | 1994-03-25 | 1996-11-12 | International Meta Systems, Inc. | RISC architecture computer configured for emulation of the instruction set of a target computer |
US5627987A (en) * | 1991-11-29 | 1997-05-06 | Kabushiki Kaisha Toshiba | Memory management and protection system for virtual memory in computer system |
US5678556A (en) * | 1994-07-14 | 1997-10-21 | Hitachi, Ltd. | Imaging method for spatial distributions of absorber concentrations |
US5958050A (en) * | 1996-09-24 | 1999-09-28 | Electric Communities | Trusted delegation system |
US5974549A (en) * | 1997-03-27 | 1999-10-26 | Soliton Ltd. | Security monitor |
US6128774A (en) * | 1997-10-28 | 2000-10-03 | Necula; George C. | Safe to execute verification of software |
US6275938B1 (en) * | 1997-08-28 | 2001-08-14 | Microsoft Corporation | Security enhancement for untrusted executable code |
US20010018731A1 (en) * | 2000-02-24 | 2001-08-30 | Nec Corporation | Memory management device and memory management method thereof |
US6317868B1 (en) * | 1997-10-24 | 2001-11-13 | University Of Washington | Process for transparently enforcing protection domains and access control as well as auditing operations in software components |
US6505300B2 (en) * | 1998-06-12 | 2003-01-07 | Microsoft Corporation | Method and system for secure running of untrusted content |
US6618855B1 (en) * | 1999-05-27 | 2003-09-09 | Sun Microsystems, Inc. | Caching untrusted modules for module-by-module verification |
US6745306B1 (en) * | 1999-07-29 | 2004-06-01 | Microsoft Corporation | Method and system for restricting the load of physical address translations of virtual addresses |
US6871283B1 (en) * | 1990-02-13 | 2005-03-22 | Hewlett-Packard Development Company, L.P. | Processing trusted commands in trusted and untrusted environments |
US6883098B1 (en) * | 2000-09-20 | 2005-04-19 | International Business Machines Corporation | Method and computer system for controlling access by applications to this and other computer systems |
US6907608B1 (en) * | 1999-01-22 | 2005-06-14 | Sun Microsystems, Inc. | Techniques for permitting access across a context barrier in a small footprint device using global data structures |
US6910209B2 (en) * | 2001-04-30 | 2005-06-21 | Sun Microsystems, Inc. | Clean thread termination |
US7086060B2 (en) * | 2001-02-15 | 2006-08-01 | Sun Microsystems, Inc. | Method for programmatic representation and enforcement of resource controls |
US20070006294A1 (en) * | 2005-06-30 | 2007-01-04 | Hunter G K | Secure flow control for a data flow in a computer and data flow in a computer network |
US7225448B2 (en) * | 2003-08-14 | 2007-05-29 | Lenovo (Singapore) Pte. Ltd. | System and method for hibernating application state data on removable module |
US7272832B2 (en) * | 2001-10-25 | 2007-09-18 | Hewlett-Packard Development Company, L.P. | Method of protecting user process data in a secure platform inaccessible to the operating system and other tasks on top of the secure platform |
US20080288789A1 (en) * | 2007-05-02 | 2008-11-20 | Arm Limited | Reducing information leakage between processes sharing a cache |
US7509639B2 (en) * | 2003-03-04 | 2009-03-24 | Secure64 Software Corp. | Customized execution environment |
US7543293B2 (en) * | 2000-12-04 | 2009-06-02 | Microsoft Corporation | Privelege level changing for virtual memory mapping |
US7555775B2 (en) * | 2002-06-28 | 2009-06-30 | Microsoft Corporation | Recovering from device failure |
US20090282474A1 (en) * | 2008-05-08 | 2009-11-12 | Google Inc. | Method for safely executing an untrusted native code module on a computing device |
US20090282477A1 (en) | 2008-05-08 | 2009-11-12 | Google Inc. | Method for validating an untrusted native code module |
US7673109B2 (en) * | 2006-11-28 | 2010-03-02 | Microsoft Corporation | Restricting type access to high-trust components |
US7783920B2 (en) * | 2007-02-20 | 2010-08-24 | International Business Machines Corporation | Recovery routine masking and barriers to support phased recovery development |
US20110029961A1 (en) | 2009-07-31 | 2011-02-03 | Google Inc. | Native code module security for arm instruction set architectures |
US20110029820A1 (en) | 2009-07-31 | 2011-02-03 | Google Inc. | Native code module security for 64-bit instruction set architectures |
US8219772B2 (en) * | 2009-07-02 | 2012-07-10 | Stmicroelectronics (Research & Development) Limited | Loading secure code into a memory |
-
2010
- 2010-09-21 US US12/886,960 patent/US8850573B1/en not_active Expired - Fee Related
Patent Citations (32)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6871283B1 (en) * | 1990-02-13 | 2005-03-22 | Hewlett-Packard Development Company, L.P. | Processing trusted commands in trusted and untrusted environments |
US5627987A (en) * | 1991-11-29 | 1997-05-06 | Kabushiki Kaisha Toshiba | Memory management and protection system for virtual memory in computer system |
US5574927A (en) * | 1994-03-25 | 1996-11-12 | International Meta Systems, Inc. | RISC architecture computer configured for emulation of the instruction set of a target computer |
US5483649A (en) * | 1994-07-01 | 1996-01-09 | Ybm Technologies, Inc. | Personal computer security system |
US5678556A (en) * | 1994-07-14 | 1997-10-21 | Hitachi, Ltd. | Imaging method for spatial distributions of absorber concentrations |
US5958050A (en) * | 1996-09-24 | 1999-09-28 | Electric Communities | Trusted delegation system |
US5974549A (en) * | 1997-03-27 | 1999-10-26 | Soliton Ltd. | Security monitor |
US6275938B1 (en) * | 1997-08-28 | 2001-08-14 | Microsoft Corporation | Security enhancement for untrusted executable code |
US6317868B1 (en) * | 1997-10-24 | 2001-11-13 | University Of Washington | Process for transparently enforcing protection domains and access control as well as auditing operations in software components |
US6128774A (en) * | 1997-10-28 | 2000-10-03 | Necula; George C. | Safe to execute verification of software |
US6505300B2 (en) * | 1998-06-12 | 2003-01-07 | Microsoft Corporation | Method and system for secure running of untrusted content |
US6907608B1 (en) * | 1999-01-22 | 2005-06-14 | Sun Microsystems, Inc. | Techniques for permitting access across a context barrier in a small footprint device using global data structures |
US6618855B1 (en) * | 1999-05-27 | 2003-09-09 | Sun Microsystems, Inc. | Caching untrusted modules for module-by-module verification |
US6745306B1 (en) * | 1999-07-29 | 2004-06-01 | Microsoft Corporation | Method and system for restricting the load of physical address translations of virtual addresses |
US20010018731A1 (en) * | 2000-02-24 | 2001-08-30 | Nec Corporation | Memory management device and memory management method thereof |
US6883098B1 (en) * | 2000-09-20 | 2005-04-19 | International Business Machines Corporation | Method and computer system for controlling access by applications to this and other computer systems |
US7543293B2 (en) * | 2000-12-04 | 2009-06-02 | Microsoft Corporation | Privelege level changing for virtual memory mapping |
US7086060B2 (en) * | 2001-02-15 | 2006-08-01 | Sun Microsystems, Inc. | Method for programmatic representation and enforcement of resource controls |
US6910209B2 (en) * | 2001-04-30 | 2005-06-21 | Sun Microsystems, Inc. | Clean thread termination |
US7272832B2 (en) * | 2001-10-25 | 2007-09-18 | Hewlett-Packard Development Company, L.P. | Method of protecting user process data in a secure platform inaccessible to the operating system and other tasks on top of the secure platform |
US7555775B2 (en) * | 2002-06-28 | 2009-06-30 | Microsoft Corporation | Recovering from device failure |
US7509639B2 (en) * | 2003-03-04 | 2009-03-24 | Secure64 Software Corp. | Customized execution environment |
US7225448B2 (en) * | 2003-08-14 | 2007-05-29 | Lenovo (Singapore) Pte. Ltd. | System and method for hibernating application state data on removable module |
US20070006294A1 (en) * | 2005-06-30 | 2007-01-04 | Hunter G K | Secure flow control for a data flow in a computer and data flow in a computer network |
US7673109B2 (en) * | 2006-11-28 | 2010-03-02 | Microsoft Corporation | Restricting type access to high-trust components |
US7783920B2 (en) * | 2007-02-20 | 2010-08-24 | International Business Machines Corporation | Recovery routine masking and barriers to support phased recovery development |
US20080288789A1 (en) * | 2007-05-02 | 2008-11-20 | Arm Limited | Reducing information leakage between processes sharing a cache |
US20090282477A1 (en) | 2008-05-08 | 2009-11-12 | Google Inc. | Method for validating an untrusted native code module |
US20090282474A1 (en) * | 2008-05-08 | 2009-11-12 | Google Inc. | Method for safely executing an untrusted native code module on a computing device |
US8219772B2 (en) * | 2009-07-02 | 2012-07-10 | Stmicroelectronics (Research & Development) Limited | Loading secure code into a memory |
US20110029961A1 (en) | 2009-07-31 | 2011-02-03 | Google Inc. | Native code module security for arm instruction set architectures |
US20110029820A1 (en) | 2009-07-31 | 2011-02-03 | Google Inc. | Native code module security for 64-bit instruction set architectures |
Non-Patent Citations (1)
Title |
---|
Yee, B. et al., "Native Client: A Sandbox for Portable, Untrusted x86 Native Code," 2009 IEEE Symposium on Security and Privacy, 15 pages. |
Cited By (26)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US9378108B2 (en) * | 2007-03-22 | 2016-06-28 | Invention Science Fund I, Llc | Implementing performance-dependent transfer or execution decisions from service emulation indications |
US20080235000A1 (en) * | 2007-03-22 | 2008-09-25 | Searete Llc, A Limited Liability Corporation Of The State Of Delaware | Implementing security control practice omission decisions from service emulation indications |
US20080234999A1 (en) * | 2007-03-22 | 2008-09-25 | Searete Llc, A Limited Liability Corporation Of The State Of Delaware | Implementing performance-dependent transfer or execution decisions from service emulation indications |
US9558019B2 (en) | 2007-03-22 | 2017-01-31 | Invention Science Fund I, Llc | Coordinating instances of a thread or other service in emulation |
US20130036448A1 (en) * | 2011-08-03 | 2013-02-07 | Samsung Electronics Co., Ltd. | Sandboxing technology for webruntime system |
US9064111B2 (en) * | 2011-08-03 | 2015-06-23 | Samsung Electronics Co., Ltd. | Sandboxing technology for webruntime system |
US20150067775A1 (en) * | 2013-08-30 | 2015-03-05 | Dell Products, Lp | System and Method of Secure Logon for Shared Devices |
US9813904B2 (en) * | 2013-08-30 | 2017-11-07 | Dell Products, Lp | System and method of secure logon for shared devices |
US20150121516A1 (en) * | 2013-10-30 | 2015-04-30 | Samsung Electronics Co., Ltd. | Authenticating input in trusted execution mode |
WO2016123013A1 (en) * | 2015-01-29 | 2016-08-04 | Universal Electronics Inc. | System and method for prioritizing and filtering cec commands |
US9621948B2 (en) | 2015-01-29 | 2017-04-11 | Universal Electronics Inc. | System and method for prioritizing and filtering CEC commands |
US11812097B2 (en) | 2015-01-29 | 2023-11-07 | Universal Electronics Inc. | System and method for prioritizing and filtering CEC commands |
US10917686B2 (en) | 2015-01-29 | 2021-02-09 | Universal Electronics Inc. | System and method for prioritizing and filtering CEC commands |
US9992530B2 (en) | 2015-01-29 | 2018-06-05 | Universal Electronics Inc. | System and method for prioritizing and filtering CEC commands |
US11595719B2 (en) | 2015-01-29 | 2023-02-28 | Universal Electronics Inc. | System and method for prioritizing and filtering CEC commands |
CN107735775A (en) * | 2015-07-10 | 2018-02-23 | Arm 有限公司 | Apparatus and method for carrying out execute instruction using the range information associated with pointer |
US11314641B2 (en) * | 2015-07-10 | 2022-04-26 | Arm Limited | Apparatus and method for executing instruction using range information associated with a pointer |
US20180196746A1 (en) * | 2015-07-10 | 2018-07-12 | Arm Limited | Apparatus and method for executing instruction using range information associated with a pointer |
US10796008B2 (en) * | 2015-07-23 | 2020-10-06 | Ca, Inc. | Executing privileged code in a process |
US20170372081A1 (en) * | 2015-07-23 | 2017-12-28 | Ca, Inc. | Executing privileged code in a process |
US11036560B1 (en) * | 2016-12-20 | 2021-06-15 | Amazon Technologies, Inc. | Determining isolation types for executing code portions |
WO2018215733A1 (en) * | 2017-05-25 | 2018-11-29 | Arm Limited | An apparatus and method for managing a capability domain |
US11347508B2 (en) | 2017-05-25 | 2022-05-31 | Arm Limited | Apparatus and method for managing a capability domain |
TWI770172B (en) * | 2017-05-25 | 2022-07-11 | 英商Ａｒｍ股份有限公司 | An apparatus and method for managing a capability domain |
US11055402B2 (en) * | 2017-09-29 | 2021-07-06 | Qualcomm Incorporated | Dynamically generated code process sandboxing using authenticated pointers |
US20230061228A1 (en) * | 2019-11-06 | 2023-03-02 | Fastly Inc. | Managing shared applications at the edge of a content delivery network |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US8850573B1 (en) | Computing device with untrusted user execution mode | |
US10445494B2 (en) | Attack protection for valid gadget control transfers | |
KR101691719B1 (en) | Return-target restrictive return from procedure instructions, processors, methods, and systems | |
US20210124824A1 (en) | Securing secret data embedded in code against compromised interrupt and exception handlers | |
US10073986B2 (en) | Regulating access to and protecting portions of applications of virtual machines | |
US8327100B2 (en) | Execute only access rights on a Von Neuman architectures | |
JP6189039B2 (en) | Data processing apparatus and method using secure domain and low secure domain | |
US10140448B2 (en) | Systems and methods of asynchronous analysis of event notifications for computer security applications | |
US7437759B1 (en) | Kernel mode overflow attack prevention system and method | |
US8209757B1 (en) | Direct call into system DLL detection system and method | |
US9684511B2 (en) | Using software having control transfer termination instructions with software not having control transfer termination instructions | |
US11347839B2 (en) | Techniques for control flow protection | |
US9197446B2 (en) | Address pinning | |
US10210349B2 (en) | Data processing apparatus and method using secure domain and less secure domain | |
US9536084B1 (en) | Systems and methods for delivering event-filtered introspection notifications | |
US9596261B1 (en) | Systems and methods for delivering context-specific introspection notifications | |
US20160171213A1 (en) | Apparatus and method for controlling instruction execution to prevent illegal accesses to a computer | |
KR20220108176A (en) | Domain Transition Disable Configuration Parameters | |
JP2005316599A (en) | Interrupt controller | |
US9626508B2 (en) | Providing supervisor control of control transfer execution profiling | |
US7610426B1 (en) | System management mode code modifications to increase computer system security | |
US9411979B2 (en) | Embedding secret data in code | |
US9398019B2 (en) | Verifying caller authorization using secret data embedded in code | |
US10241787B2 (en) | Control transfer override | |
US7281271B1 (en) | Exception handling validation system and method |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:CHEN, BRAD;YEE, BENNET;SEHR, DAVID C.;SIGNING DATES FROM 20100917 TO 20100920;REEL/FRAME:025190/0387 |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044277/0001Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 4TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1551)Year of fee payment: 4 |
|
FEPP | Fee payment procedure |
Free format text: MAINTENANCE FEE REMINDER MAILED (ORIGINAL EVENT CODE: REM.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
LAPS | Lapse for failure to pay maintenance fees |
Free format text: PATENT EXPIRED FOR FAILURE TO PAY MAINTENANCE FEES (ORIGINAL EVENT CODE: EXP.); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCH | Information on status: patent discontinuation |
Free format text: PATENT EXPIRED DUE TO NONPAYMENT OF MAINTENANCE FEES UNDER 37 CFR 1.362 |
|
FP | Lapsed due to failure to pay maintenance fee |
Effective date: 20220930 |