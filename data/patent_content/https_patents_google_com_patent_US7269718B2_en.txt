US7269718B2 - Method and apparatus for verifying data types to be used for instructions and casting data types if needed - Google Patents
Method and apparatus for verifying data types to be used for instructions and casting data types if needed Download PDFInfo
- Publication number
- US7269718B2 US7269718B2 US10/835,484 US83548404A US7269718B2 US 7269718 B2 US7269718 B2 US 7269718B2 US 83548404 A US83548404 A US 83548404A US 7269718 B2 US7269718 B2 US 7269718B2
- Authority
- US
- United States
- Prior art keywords
- data
- data type
- metadata
- type
- instructions
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active, expires
Links
- 238000000034 method Methods 0.000 title claims abstract description 116
- 238000005266 casting Methods 0.000 title claims description 24
- 230000015654 memory Effects 0.000 claims abstract description 175
- 230000008859 change Effects 0.000 claims abstract description 20
- 238000012545 processing Methods 0.000 claims description 32
- 238000004590 computer program Methods 0.000 claims description 14
- 230000008569 process Effects 0.000 description 71
- 239000000872 buffer Substances 0.000 description 23
- 230000007246 mechanism Effects 0.000 description 20
- 238000010586 diagram Methods 0.000 description 18
- 230000004044 response Effects 0.000 description 16
- 238000003860 storage Methods 0.000 description 8
- 238000012544 monitoring process Methods 0.000 description 7
- 102100034013 Gamma-glutamyl phosphate reductase Human genes 0.000 description 6
- 238000004891 communication Methods 0.000 description 5
- 230000014509 gene expression Effects 0.000 description 5
- 238000013519 translation Methods 0.000 description 4
- 230000006399 behavior Effects 0.000 description 3
- 230000006870 function Effects 0.000 description 3
- 230000002093 peripheral effect Effects 0.000 description 3
- 230000009471 action Effects 0.000 description 2
- 230000008901 benefit Effects 0.000 description 2
- 230000005540 biological transmission Effects 0.000 description 2
- 238000012986 modification Methods 0.000 description 2
- 230000004048 modification Effects 0.000 description 2
- 230000003068 static effect Effects 0.000 description 2
- 238000012360 testing method Methods 0.000 description 2
- 238000012546 transfer Methods 0.000 description 2
- 101150055094 PMC1 gene Proteins 0.000 description 1
- 102100038208 RNA exonuclease 4 Human genes 0.000 description 1
- 101150073729 Rexo4 gene Proteins 0.000 description 1
- 101100290680 Schizosaccharomyces pombe (strain 972 / ATCC 24843) med1 gene Proteins 0.000 description 1
- 101100400958 Schizosaccharomyces pombe (strain 972 / ATCC 24843) med14 gene Proteins 0.000 description 1
- 230000015556 catabolic process Effects 0.000 description 1
- 238000006243 chemical reaction Methods 0.000 description 1
- 239000003795 chemical substances by application Substances 0.000 description 1
- 238000006731 degradation reaction Methods 0.000 description 1
- 230000001419 dependent effect Effects 0.000 description 1
- 238000001514 detection method Methods 0.000 description 1
- 238000009826 distribution Methods 0.000 description 1
- 230000000977 initiatory effect Effects 0.000 description 1
- 238000003780 insertion Methods 0.000 description 1
- 230000037431 insertion Effects 0.000 description 1
- 238000004519 manufacturing process Methods 0.000 description 1
- 238000013507 mapping Methods 0.000 description 1
- 230000003287 optical effect Effects 0.000 description 1
- 238000002198 surface plasmon resonance spectroscopy Methods 0.000 description 1
- 230000001360 synchronised effect Effects 0.000 description 1
- 230000009466 transformation Effects 0.000 description 1
- 230000001960 triggered effect Effects 0.000 description 1
- 238000010200 validation analysis Methods 0.000 description 1
- 238000012795 verification Methods 0.000 description 1
Images
Classifications
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/30181—Instruction operation extension or modification
- G06F9/30192—Instruction operation extension or modification according to data descriptor, e.g. dynamic data typing
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/362—Software debugging
- G06F11/3624—Software debugging by performing operations on the source code, e.g. via a compiler
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/36—Preventing errors by testing or debugging software
- G06F11/362—Software debugging
- G06F11/366—Software debugging using diagnostics
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/30003—Arrangements for executing specific machine instructions
- G06F9/3004—Arrangements for executing specific machine instructions to perform operations on memory
- G06F9/30043—LOAD or STORE instructions; Clear instruction
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3836—Instruction issuing, e.g. dynamic instruction scheduling or out of order instruction execution
- G06F9/3853—Instruction issuing, e.g. dynamic instruction scheduling or out of order instruction execution of compound instructions
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F9/00—Arrangements for program control, e.g. control units
- G06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs
- G06F9/30—Arrangements for executing machine instructions, e.g. instruction decode
- G06F9/38—Concurrent instruction execution, e.g. pipeline, look ahead
- G06F9/3861—Recovery, e.g. branch miss-prediction, exception handling
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F11/00—Error detection; Error correction; Monitoring
- G06F11/07—Responding to the occurrence of a fault, e.g. fault tolerance
- G06F11/0703—Error or fault processing not based on redundancy, i.e. by taking additional measures to deal with the error or fault not making use of redundancy in operation, in hardware, or in data representation
- G06F11/0751—Error or fault detection not based on redundancy
-
- G—PHYSICS
- G06—COMPUTING; CALCULATING OR COUNTING
- G06F—ELECTRIC DIGITAL DATA PROCESSING
- G06F8/00—Arrangements for software engineering
- G06F8/40—Transformation of program code
- G06F8/41—Compilation
Definitions
- the present invention is related to the following applications entitled “Method and Apparatus for Counting Instruction Execution and Data Accesses”, Ser. No. 10/675,777, filed on Sep. 30, 2003; “Method and Apparatus for Selectively Counting Instructions and Data Accesses”, Ser. No. 10/674,604, filed on Sep. 30, 2003; “Method and Apparatus for Generating Interrupts Upon Execution of Marked Instructions and Upon Access to Marked Memory Locations”, Ser. No. 10/675,831, filed on Sep. 30, 2003; “Method and Apparatus for Counting Data Accesses and Instruction Executions that Exceed a Threshold”, Ser. No.
- the present invention relates generally to an improved data processing system and in particular to a method and apparatus for processing data. Still more particularly, the present invention relates to a method, apparatus, and computer instructions for providing hardware assistance for program reliability and correctness.
- programmers In writing code, programmers use different languages to generate software systems. These software systems may range from email server and handling systems to mission critical systems, such as the software systems used by various stock exchanges and banks. In performing these tasks, a programmer may generate code which is not correct.
- Programs have semantic properties and syntactic properties. Semantic properties relate to behavior, while syntactic properties relate to well-formedness. The semantic properties of the program may be checked for correctness statically during compile time and dynamically during runtime. Errors in program correctness may result in failures during execution or in incorrect results being generated by the system software. Additionally, when programs are compiled from a source code to a target code, the compiler used may not always provide a correct transformation of the code.
- the present invention provides a method, apparatus, and computer instructions in a processor for performing arithmetic operations.
- a data type associated with a particular memory location is used to determine if an operation about to be performed on the data in that location is legal. If the operation requires the data to have a required data type, a determination is made as to whether the operation is a legal operation based on the identified data type and the required data type. If the operation is not legal on the identified type, a determination is made as to whether data can be cast to change the identified data type to the required data type. The data is cast to the required data type if the data can be cast to form modified data, and the arithmetic operation is performed on the modified data. If the data cannot be cast to the required type, an exception or interrupt is generated.
- FIG. 1 is a block diagram of a data processing system in which the present invention may be implemented
- FIG. 2 is a block diagram of a processor system for processing information in accordance with a preferred embodiment of the present invention
- FIG. 3 is a diagram illustrating marked code for identifying awareness of data types in accordance with a preferred embodiment in the present invention
- FIG. 4 is a block diagram illustrating hardware awareness of data types in accordance with a preferred embodiment of the present invention.
- FIG. 5 is a block diagram illustrating components used for generating metadata, such as data types, assertions, and valid operations in accordance with a preferred embodiment of the present invention
- FIG. 6 is a diagram of code processed by a compiler at compile time in accordance with a preferred embodiment of the present invention.
- FIG. 7 is a diagram illustrating a bundle in accordance with a preferred embodiment of the present invention.
- FIG. 8 is an exemplary block diagram of data flow in which a page table is used to translate the memory address specified by the program into a physical address in accordance with an exemplary embodiment of the present invention
- FIG. 9 is an exemplary page table entry in accordance with an exemplary embodiment of the present invention.
- FIG. 10 is a flowchart of a process for adding instruct in accordance with a preferred embodiment of the present invention.
- FIG. 11 is a flowchart of a process for determining whether data in a memory location is of a valid data type in accordance with a preferred embodiment of the present invention
- FIG. 12 is a flowchart of a process for identifying whether an operation that is to be performed by a functional unit can be legally performed in; accordance with a preferred embodiment of the present invent ion;
- FIG. 13 is a flowchart of a process for correcting data types to perform an arithmetic operation in accordance with a preferred embodiment of the present invention
- FIG. 14 is a block diagram of a process for illustrating components used in determining whether an assertion is valid in accordance with a preferred embodiment of the present invention.
- FIG. 15 is a flowchart of a process for illustrating steps in checking the validity of an assertion in accordance with a preferred embodiment of the present invention.
- FIG. 16 is a flowchart of a process for determining the state of data in memory locations in accordance with a preferred embodiment of the present invention.
- Client 100 is an example of a computer, in which code or instructions implementing the processes of the present invention may be located.
- Client 100 employs a peripheral component interconnect (PCI) local bus architecture.
- PCI peripheral component interconnect
- Processor 102 and main memory 104 are connected to PCI local bus 106 through PCI bridge 108 .
- PCI bridge 108 also may include an integrated memory controller and cache memory for processor 102 . Additional connections to PCI local bus 106 may be made through direct component interconnection or through add-in boards.
- local area network (LAN) adapter 110 small computer system interface SCSI host bus adapter 112 , and expansion bus interface 114 are connected to PCI local bus 106 by direct component connection.
- audio adapter 116 graphics adapter 118 , and audio/video adapter 119 are connected to PCI local bus 106 by add-in boards inserted into expansion slots.
- Expansion bus interface 114 provides a connection for a keyboard and mouse adapter 120 , modem 122 , and additional memory 124 .
- SCSI host bus adapter 112 provides a connection for hard disk drive 126 , tape drive 128 , and CD-ROM drive 130 .
- Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.
- An operating system runs on processor 102 and is used to coordinate and provide control of various components within data processing system 100 in FIG. 1 .
- the operating system may be a commercially available operating system such as Windows XP, which is available from Microsoft Corporation.
- An object oriented programming system such as Java may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on client 100 . “Java” is a trademark of Sun Microsystems, Inc. Instructions for the operating system, the object-oriented programming system, and applications or programs are located on storage devices, such as hard disk drive 126 , and may be loaded into main memory 104 for execution by processor 102 .
- FIG. 1 may vary depending on the implementation.
- Other internal hardware or peripheral devices such as flash read-only memory (ROM), equivalent nonvolatile memory, or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in FIG. 1 .
- the processes of the present invention may be applied to a multiprocessor data processing system.
- client 100 if optionally configured as a network computer, may not include SCSI host bus adapter 112 , hard disk drive 126 , tape drive 128 , and CD-ROM 130 .
- the computer to be properly called a client computer, includes some type of network communication interface, such as LAN adapter 110 , modem 122 , or the like.
- client 100 may be a stand-alone system configured to be bootable without relying on some type of network communication interface, whether or not client 100 comprises some type of network communication interface.
- client 100 may be a personal digital assistant (PDA), which is configured with ROM and/or flash ROM to provide non-volatile memory for storing operating system files and/or user-generated data.
- PDA personal digital assistant
- processor 102 uses computer implemented instructions, which may be located in a memory such as, for example, main memory 104 , memory 124 , or in one or more peripheral devices 126 - 130 .
- FIG. 2 a block diagram of a processor system for processing information is depicted in accordance with a preferred embodiment of the present invention.
- Processor 210 may be implemented as processor 102 in FIG. 1 .
- processor 210 is a single integrated circuit superscalar microprocessor. Accordingly, as discussed further herein below, processor 210 includes various units, registers, buffers, memories, and other sections, all of which are formed by integrated circuitry. Also, in the preferred embodiment, processor 210 operates according to reduced instruction set computer (“RISC”) techniques. As shown in FIG. 2 , system bus 211 is connected to a bus interface unit (“BIU”) 212 of processor 210 . BIU 212 controls the transfer of information between processor 210 and system bus 211 .
- BIU bus interface unit
- BIU 212 is connected to an instruction cache 214 and to data cache 216 of processor 210 .
- Instruction cache 214 outputs instructions to sequencer unit 218 .
- sequencer unit 218 selectively outputs instructions to other execution circuitry of processor 210 .
- the execution circuitry of processor 210 includes multiple execution units, namely a branch unit 220 , a fixed-point unit A (“FXUA”) 222 , a fixed-point unit B (“FXUB”) 224 , a complex fixed-point unit (“CFXU”) 226 , a load/store unit (“LSU”) 228 , and a floating-point unit (“FPU”) 230 .
- FXUA 222 , FXUB 224 , CFXU 226 , and LSU 228 input their source operand information from general-purpose architectural registers (“GPRs”) 232 and fixed-point rename buffers 234 .
- GPRs general-purpose architectural registers
- FXUA 222 and FXUB 224 input a “carry bit” from a carry bit (“CA”) register 242 .
- FXUA 222 , FXUB 224 , CFXU 226 , and LSU 228 output results (destination operand-information) of their operations for storage at selected entries in fixed-point rename buffers 234 .
- CFXU 226 inputs and outputs source operand information and destination operand information to and from special-purpose register processing unit (“SPR unit”) 240 .
- SPR unit special-purpose register processing unit
- FPU 230 inputs its source operand information from floating-point architectural registers (“FPRs”) 236 and floating-point rename buffers 238 .
- FPU 230 outputs results (destination operand information) of its operation for storage at selected entries in floating-point rename buffers 238 .
- LSU 228 In response to a Load instruction, LSU 228 inputs information from data cache 216 and copies such information to selected ones of rename buffers 234 and 238 . If such information is not stored in data cache 216 , then data cache 216 inputs (through BIU 212 and system bus 211 ) such information from a system memory 260 connected to system bus 211 . Moreover, data cache 216 is able to output (through BIU 212 and system bus 211 ) information from data cache 216 to system memory 260 connected to system bus 211 . In response to a Store instruction, LSU 228 inputs information from a selected one of GPRs 232 and FPRs 236 and copies such information to data cache 216 .
- Sequencer unit 218 inputs and outputs information to and from GPRs 232 and FPRs 236 .
- branch unit 220 inputs instructions and signals indicating a present state of processor 210 .
- branch unit 220 outputs (to sequencer unit 218 ) signals indicating suitable memory addresses storing a sequence of instructions for execution by processor 210 .
- sequencer unit 218 inputs the indicated sequence of instructions from instruction cache 214 . If one or more of the sequence of instructions is not stored in instruction cache 214 , then instruction cache 214 inputs (through BIU 212 and system bus 211 ) such instructions from system memory 260 connected to system bus 211 .
- sequencer unit 218 In response to the instructions input from instruction cache 214 , sequencer unit 218 selectively dispatches the instructions to selected ones of execution units 220 , 222 , 224 , 226 , 228 , and 230 .
- Each execution unit executes one or more instructions of a particular class of instructions.
- FXUA 222 and FXUB 224 execute a first class of fixed-point mathematical operations on source operands, such as addition, subtraction, ANDing, ORing and XORing.
- CFXU 226 executes a second class of fixed-point operations on source operands, such as fixed-point multiplication and division.
- FPU 230 executes floating-point operations on source operands, such as floating-point multiplication and division.
- rename buffers 234 As information is stored at a selected one of rename buffers 234 , such information is associated with a storage location (e.g. one of GPRs 232 or CA register 242 ) as specified by the instruction for which the selected rename buffer is allocated. Information stored at a selected one of rename buffers 234 is copied to its associated one of GPRs 232 (or CA register 242 ) in response to signals from sequencer unit 218 . Sequencer unit 218 directs such copying of information stored at a selected one of rename buffers 234 in response to “completing” the instruction that generated the information. Such copying is called “writeback.”
- rename buffers 238 As information is stored at a selected one of rename buffers 238 , such information is associated with one of FPRs 236 . Information stored at a selected one of rename buffers 238 is copied to its associated one of FPRs 236 in response to signals from sequencer unit 218 . Sequencer unit 218 directs such copying of information stored at a selected one of rename buffers 238 in response to “completing” the instruction that generated the information.
- Processor 210 achieves high performance by processing multiple instructions simultaneously at various ones of execution units 220 , 222 , 224 , 226 , 228 , and 230 . Accordingly, each instruction is processed as a sequence of stages, each being executable in parallel with stages of other instructions. Such a technique is called “pipelining.” In a significant aspect of the illustrative embodiment, an instruction is normally processed as six stages, namely fetch, decode, dispatch, execute,. completion, and writeback.
- sequencer unit 218 selectively inputs (from instruction cache 214 ) one or more instructions from one or more memory addresses storing the sequence of instructions discussed further hereinabove in connection with branch unit 220 , and sequencer unit 218 .
- sequencer unit 218 decodes up to four fetched instructions.
- sequencer unit 218 selectively dispatches up to four decoded instructions to selected (in response to the decoding in the decode stage) ones of execution units 220 , 222 , 224 , 226 , 228 , and 230 after reserving rename buffer entries for the dispatched instructions' results (destination operand information).
- operand information is supplied to the selected execution units for dispatched instructions.
- Processor 210 dispatches instructions in order of their programmed sequence.
- execution units execute their dispatched instructions and output results (destination operand information) of their operations for storage at selected entries in rename buffers 234 and rename buffers 238 as discussed further hereinabove. In this manner, processor 210 is able to execute instructions out-of-order relative to their programmed sequence.
- sequencer unit 218 indicates an instruction is “complete.”
- Processor 210 “completes” instructions in order of their programmed sequence.
- sequencer 218 directs the copying of information from rename buffers 234 and 238 to GPRs 232 and FPRs 236 , respectively. Sequencer unit 218 directs such copying of information stored at a selected rename buffer.
- processor 210 updates its architectural states in response to the particular instruction.
- Processor 210 processes the respective “writeback” stages of instructions in order of their programmed sequence. Processor 210 advantageously merges an instruction's completion stage and writeback stage in specified situations.
- each instruction requires one machine cycle to complete each of the stages of instruction processing. Nevertheless, some instructions (e.g., complex fixed-point instructions executed by CFXU 226 ) may require more than one cycle. Accordingly, a variable delay may occur between a particular instruction's execution and completion stages in response to the variation in time required for completion of preceding instructions.
- a completion buffer 248 is provided within sequencer 218 to track the completion of the multiple instructions which are being executed within the execution units. Upon an indication that an instruction or a group of instructions have been completed successfully, in an application specified sequential order, completion buffer 248 may be utilized to initiate the transfer of the results of those completed instructions to the associated general-purpose registers.
- processor 210 also includes processor monitoring unit 240 , which is connected to instruction cache 214 as well as other units in processor 210 . Operation of processor 210 can be monitored utilizing performance monitor unit 240 , which in this illustrative embodiment is a software-accessible mechanism capable of providing detailed information descriptive of the utilization of instruction execution resources and storage control. Although not illustrated in FIG.
- performance monitor unit 240 is coupled to each functional unit of processor 210 to permit the monitoring of all aspects of the operation of processor 210 , including, for example, reconstructing the relationship between events, identifying false triggering, identifying performance bottlenecks, monitoring pipeline stalls, monitoring idle processor cycles, determining dispatch efficiency, determining branch efficiency, determining the performance penalty of misaligned data accesses, identifying the frequency of execution of serialization instructions, identifying inhibited interrupts, and determining performance efficiency.
- Performance monitor unit 240 includes an implementation-dependent number (e.g., 2-8) of counters 241 - 242 , labeled PMC 1 and PMC 2 , which are utilized to count occurrences of selected events. Performance monitor unit 240 further includes at least one monitor mode control register (MMCR). In this example, two control registers, MMCRs 243 and 244 are present that specify the function of counters 241 - 242 . Counters 241 - 242 and MMCRs 243 - 244 are preferably implemented as SPRs that are accessible for read or write via MFSPR (move from SPR) and MTSPR (move to SPR) instructions executable by CFXU 26 .
- MFSPR move from SPR
- MTSPR move to SPR
- counters 241 - 242 and MMCRs 243 - 244 may be 3 implemented simply as addresses in I/O space.
- the control registers and counters may be accessed indirectly via an index register. This embodiment is implemented in the IA-64 architecture in processors from Intel Corporation
- processor 210 also includes interrupt unit 250 , which is connected to instruction cache 214 . Additionally, although not shown in FIG. 2 , interrupt unit 250 is connected to other functional units within processor 210 . Interrupt unit 250 may receive signals from other functional units and initiate an action, such as starting an error handling or trap process. In these examples, interrupt unit 250 is employed to generate interrupts and exceptions that may occur during execution of a program.
- the present invention provides a method, apparatus, and computer instructions for providing hardware awareness of the type of data stored in a given location.
- the hardware in a processor may perform checking of data types at runtime. This awareness is provided through associating metadata with a section of memory.
- This section of memory may be a section of memory location or may be a range or set of memory locations.
- a range of memory locations is a contiguous set of memory locations, while a set of memory locations may be noncontiguous. These memory locations may include registers.
- the metadata specifies a type of data, also referred to as a data type that is stored or supposed to be stored in a section of memory.
- the hardware such as, for example, processor functional units are configured to access and manipulate this metadata.
- processor functional units include, for example, a fixed point unit, a load store unit, and a floating point unit.
- Other processor units in hardware include a data cache and an instruction cache. Further, instructions are included in the code for a program to correctly specify the data types for different memory locations.
- code 300 may be marked in a manner that allows for awareness of data types by hardware, such as processor function units during execution of code 300 .
- an instruction may be included to set a mode in the processor to enable these hardware functions for data awareness.
- particular instructions may be marked using indicators to indicate that memory locations associated with or manipulated by marked instructions should be processed using data awareness features provided by the hardware in accordance with a preferred embodiment of the present invention.
- Instructions may be inserted into code 300 by a compiler to include instructions for generating and associating metadata with memory locations that are initialized or allocated by code 300 . This generation and association of metadata may be performed for both static memory locations and dynamically allocated memory locations.
- the marking of sections within code 300 may involve all memory locations or those for particular sections of code, such as subroutine 302 .
- code 300 is compiled code.
- Metadata 304 is generated during compile time and associated with memory locations 306 .
- functional processor unit 308 checks metadata 304 to determine whether the type of data in the memory location matches the data type specified for the memory location in metadata 304 .
- This memory location may be, for example, a system memory or a register. When data is loaded into a register for an operation, the address of the memory location from which the data was fetched is used by functional processor unit 308 to identify the metadata stating the data type for that memory location.
- the hardware can check to see if metadata specifies a data type for that location. If metadata does provide such a specification, the hardware determines whether the data about to be stored there is of the correct type. For example, if an instruction, such as ST FP 1 , mem (“store the contents of floating point register 1 into memory location mem”), is executed, the hardware can see if metadata exists specifying a data type for location mem. If this metadata is present, the hardware verifies that the data type specified for mem is float. If the specified data type is not float, an exception can be thrown. In this example, it is known that the content of FP 1 is in fact a float because the content was checked when the value was stored into FP 1 .
- Instructions inserted into code 300 may cause the data type for a memory location in memory locations 306 to be set in metadata 304 when a value is stored in the location. Prior to a value being stored in a memory location, the data type for the memory location in memory locations 306 is set or marked as unknown in metadata 304 . These data types may be set in association with the declaration of variables by code 300 . For example, if code 300 declares a variable as a floating point variable metadata is stored in metadata 304 containing the data type for use by hardware in the processor, such as functional processor unit 308 .
- FIG. 4 a block diagram illustrating hardware awareness of data types is depicted in accordance with a preferred embodiment of the present invention.
- data from system memory 400 may be loaded into register 402 and register 404 for use by functional processor unit 406 in executing an instruction.
- Functional processor unit 406 may take various forms, such as a floating point unit, a fixed point unit, or a load/store unit.
- Functional processor unit 406 determines whether the data type in a memory location, such as register 402 or register 404 is valid.
- a memory location also may be another memory, such as system memory in addition to being a register.
- This metadata may be stored in various ways, for example, metadata for the values in registers. 402 and 404 may be stored in extra bits for those registers or in a memory, such as shadow cache 408 . If the metadata is stored as extra bits in a register, the metadata contains the data type of the data. If the memory is located in shadow cache 408 , the metadata includes an address that is used to identify a particular entry in shadow cache 408 for defining the data type for a memory location when data from that address is loaded into a register for processing.
- the address of that system memory is used to identify the data type. If the register is required to have a particular data type every time, the address may be that of the register or of the memory location from which the data in the register originated.
- result 410 is generated to determine whether the data is valid.
- the data type for register 402 and register 404 may be defined as a floating point value in the metadata associated with register 402 and register 404 . If the type of data in register 402 is not a normalized floating point value, functional processor unit 406 generates result 410 with an indication that the data is not of a valid data type.
- compiler 500 supports directives, supplied by the programmer, that indicate the metadata to be generated. In response to these directives the compiler generates instructions for setting, changing, and reading metadata. These are new instructions, not present in current processing units, which are added in these illustrative examples to an Instruction Set Architecture (ISA) to enable a preferred embodiment of the present invention. These additional instructions are executed by the hardware just as instructions such as loads, stores, and adds are executed. Further, these instructions are typically generated by compiler 500 or an assembler as part of processing, such as that of variable declarations and type conversions.
- ISA Instruction Set Architecture
- memory locations containing the stack or other areas of scratch memory may contain data of different types at different times, the metadata associated with such memory locations may be changed many times during the execution of instructions 502 . If hardware embodying the mechanisms of the present invention only allows enough metadata for a subset of the memory locations, then instructions for changing the binding of metadata to memory locations during execution may be included in the ISA because different subsets of data may be most important for reliability at different stages in the execution of instructions 502 .
- the metadata may simply indicate data types and the processor may have its own algorithm for determining compatibility.
- the processor does not necessarily need to have extra instructions for the validation.
- the compiler does use additional instructions for setting and resetting data types.
- compiler 500 may generate instructions 502 for execution and for identifying data types. As instruction or data cache pages are loaded into memory during execution of instructions 502 , the operating system program loader/linker, reads metadata 504 generated by compiler 500 and loads metadata 504 into a memory, such as shadow memory 505 or as extra bits associated with designated words in the data itself.
- the format simply has a shadow cache entry for each of its block or sector references and moves metadata 504 to its corresponding shadow entry or entries in shadow memory 505 .
- the internal format of the data cache itself may be modified to contain metadata 504 .
- the loader updates the data to contain the appropriate metadata and work areas or compiler 500 generates the code to generate metadata 504 . In either case, after the data is loaded, metadata 504 is present.
- metadata 504 may be placed into shadow memory 505 in association with instructions 502 .
- Compiler 500 produces instructions that produce and manipulate metadata.
- the generation of metadata 504 may be performed dynamically.
- Instructions 502 then may be executed by processor 508 .
- Checking of data types for data using metadata 504 occurs when the data is accessed during execution of these instructions.
- Compiler 500 may generate additional instructions to turn checking on or off during portions of a program. These instructions might set a register, such as mode register 510 in processor 508 , to enable hardware assistance. When this register is set, processor 508 looks at metadata 504 in shadow memory 505 when executing instructions 502 to determine whether data types in metadata 504 are associated with memory locations that are being accessed during execution of instructions 502 . If mode register 510 is not set, then metadata 504 is ignored when instructions 502 are executed. Alternatively, checking might be enabled or disabled by an outside agent such as the operating system or a dynamic debugger.
- mode register 510 With the use of mode register 510 , the same code used in debugging also may be used for actual client or customer use. When mode register 510 is turned off, checking of data types may be turned off.
- Setting mode register 510 causes processor 508 to look for metadata 504 in shadow memory 505 without having to modify instructions 502 .
- metadata 504 takes the form of data type definitions that are used by processor 508 , identify data types, and perform other data related checks and operations.
- compiler 500 knows and, given suitable machine instructions, can convey to the hardware the data type of all data in memory operated on by the program that compiler 500 is translating.
- compiler 500 knows and can convey the data type for data stored in some, but not all, memory locations.
- Unions, pointer arithmetic, and other language features that result in aliasing restrict the ability of compiler 500 to know data types. Further, use of these language features is discouraged by people concerned with program reliability for other reasons. The use of such language features in a given program may reduce, but by no means eliminate the usefulness of the mechanisms of the present invention described herein.
- compiler 500 For a global or static variable, it is most useful for compiler 500 to issue an instruction setting the metadata associated with the instruction the first time a value is stored in that memory location. Prior to this first storage of data in the memory location, the data type is marked or set as “unknown” in these illustrative examples. If the first such occurrence cannot be determined, the instruction is issued when the memory location is allocated. This situation may require cooperation from the loader, depending on language semantics and implementation. All such memory locations are designated as having unknown data types at program termination, possibly by the operating system.
- data allocated from a heap can have its metadata set after the call to malloc( ) in C or by new( ) in Java. These calls are used to dynamically allocate memory for data during execution of the instructions. The data type for these memory locations are reset to unknown by the free( ) routine in C or by the garbage collector in Java. These calls are used to free or deallocate memory.
- temporary data such as method arguments and local variables located in the stack have their metadata set at stack frame allocation, and these memory locations are reset to unknown when the routine is exited and the stack frame is deactivated. This action can be accomplished by instructions that the compiler places in routine prologs and epilogs.
- Data types in higher level languages can be arbitrarily complex, and the mechanism of the present invention does not make the hardware aware of arbitrary types in these examples.
- a memory location containing a pointer could be part of a linked list, a tree, or any of an infinite number of other data structures unknowable by hardware, but the fact that the memory location contains a pointer is knowable and potentially useful.
- primitive data types including integer, floating point, double, and pointer are described for purposes of illustration.
- hardware can easily check these types of data for illegal values, such as pointers outside the range of virtual memory available to the running process or unnormalized floats.
- code 600 is an example of code that may be compiled using a compiler, such as compiler 500 in FIG. 5 .
- the compiler generates machine or binary code to implement code 600 , which is in a source code format.
- the compiler also performs additional processing in accordance with a preferred embodiment of the present invention.
- Line 602 is a call to a subroutine foo.
- whoever calls the subroutine foo in line 602 causes copies of the values of variables a and b to be placed in a scratch area of memory called the “stack”.
- Variables a, b, and z are defined in line 603 as having a data type of float. Since this is a scratch area, previous values of an unknown type may be present.
- the compiler compiles this instruction to generate a couple of the new instructions that set or create metadata associating a data type “float” with the memory locations of these copies of the values a and b. Similar new instructions are generated at the beginning of the subroutine bar for values j and x in line 604 . These instructions associate the data types “integer” and “float” with two more memory locations in this illustrative embodiment.
- the compiler in addition to generating the instructions that reserve space in memory for these declared variables, the compiler generates new instructions that create metadata associating the data type “float” with the memory locations of the 100 elements of c and the data type “integer” with the memory locations of n and m.
- the data types “float” has already been associated with the variables a and b when the compiler processed line 602 .
- the compiler With respect to line 608 , the compiler generates instructions that create metadata associating type “pointer-to-integer” with the location of p.
- type of data that the pointer points to also is indicated.
- the pointer points to an integer.
- the compiler Upon encountering the data assertion in line 610 , the compiler generates instructions to generate metadata associating this data invariant with all 100 elements of the variable c. This machine code is placed either near the beginning of the subroutine, with the other instructions generating metadata about c, or just before the beginning of the loop, and not inside the loop where the assertion was placed by the programmer.
- the compiler generates instructions that create metadata associating language-specific rules or information about the whole routine or the whole program for the hardware to use at runtime. These instructions are typically placed at the beginning of the routine or program in the illustrative examples. This generated metadata would specify which operations are legal on which types of data or even whether such checks should be performed at all in the case of trusted modules, and rules about mixed-mode arithmetic and automatic casting, because these issues are language-specific.
- the hardware executes the instructions generated by the compiler that implements code 600 .
- the hardware performs additional processing in addition to the instructions shown in code 600 .
- the additional processing is performed by hardware, such as different processor functional units and components in a processor executing the instructions for code 600 .
- the instruction or process that called the subroutine foo placed values in two memory locations in the stack. Because metadata is present specifying the data type for these two memory locations, the processor checks, as the values are being so placed in the stack, that the values do indeed correspond to legal, normalized floating point numbers. This check is made because metadata identifying the data types for these values are associated with the memory locations for the values.
- the processor determines whether the value is a legal, normalized float value, because metadata is present defining the value in this element in the array. Also, additional metadata is present associating a data invariant with c. As a result, the processor checks to see whether 1.0 is less than 1000.0. Although both of these checks are usually redundant, since most modern compilers can actually check this extremely simple case at compile time, it is probably impractical to avoid occasional redundancies because the processor has no way of knowing the sophistication level of the compiler that generated the code. As a further note, all value-checking also is helpful when code bugs that overwrite memory erroneously are present.
- the machine instruction that stores the address of m into p causes the processor to perform two checks in this illustrative example because metadata is present specifying the data type for the memory location of value p.
- the processor checks to see whether the value placed in p is a legal pointer value, within an in-range, address. Further, the processor determines whether the address in p contains an integer.
- the processor checks to see whether legal values are present as new values are stored in n.
- the expression to the right of the equal sign takes many machine instructions to implement.
- Several of these machine instructions trigger processor checks, depending on language-specific rules specified by the programmer in the metadata. For example, the processor may check that (1) “ ⁇ ” is a legal operation on n and 1, (2) “*” is a legal operation on m and c, and (3) “+” is a legal operation on a and the other expression. If the multiplication between the integer and the float is legal, the processor also checks to determine whether metadata for a casting rule is present for that situation. If this type of metadata is present, the processor will perform the cast operation to convert or change the data type. If mixed mode operations are allowed, the data types for the values may be cast or converted to the required data types. These required data types are set forth in the metadata.
- the processor determines whether the value is a legal, normalized float based on the metadata defined for the memory location. If the value is net a legal float, the processor determines whether the metadata contains a casting rule. If a cast rule is defined in the metadata, the processor performs the cast operation and then performs the store operation. Otherwise, the processor generates an interrupt. Additionally, if the processor performs the store operation, the processor first determines whether the value is less than 1000.0.
- the compiler With respect to the instruction at line 626 at compile time, the compiler generates instructions placing copies of the vales of m and b on the stack and generates instructions that generate metadata associating types with these two locations, as mentioned above.
- the processor checks to see whether the values for the memory locations are legal values using the metadata defining the data types for the memory locations.
- Bundle 700 contains instruction slot 702 , instruction 704 , instruction slot 706 and template 708 . As illustrated, bundle 700 contains 128 bits. Each instruction slot contains 41 bits, and template 708 contains 5 bits. Template 708 is used to identify stops within the current bundle and to map instructions within the slots to different types of execution units.
- Spare bits within bundle 700 are used to hold indicators of the present invention.
- indicators 710 , 712 , and 714 are located within instruction slots 702 , 704 , and 706 , respectively. These indicators may take various forms and may take various sizes depending on the particular implementation. Indicators may use a single bit or may use multiple bits.
- These fields may be used for metadata to define data types and other data checking information for memory locations.
- the different slots are words with additional bits in memory locations with the metadata being stored in place of the indicators.
- the memory locations may contain other sizes depending on the particular implementation.
- template 708 may be used to contain a bundle of related indicators, so that one bit is used to identify all the instructions in a bundle.
- the bundle itself could be extended to be 256 bits or some other number of bits to contain the extra information for the performance indicators or flags used to indicate the type of checking that is to occur for the entire bundle or specific instructions in the bundle. For example, if a instruction in a bundle is a branch instruction, the flag may indicate that checks should be performed against branched instructions. If the bundle contains an instruction for a floating point operation, the operands for this operation should be floating point operands. In this case, the instruction type itself may be used to identify the type of operands.
- FIG. 8 illustrates an exemplary block diagram of data flow in which a page table is used to translate the memory address specified by she program into a physical address in accordance with an exemplary embodiment of the present invention.
- program address 810 (for data or instruction) is translated to a virtual address by way of the address space register 820 using one of the various means of specifying the active address space.
- the resultant virtual address is used by the processor to search page table 830 for a page descriptor in page table 830 that matches the virtual address.
- the contents of the matching page descriptor commonly contain the physical address and attributes associated with the virtual page. These contents are used to translate the virtual address to a physical address and to determine the attributes of the page (e.g., access rights).
- the page table is expanded to include additional fields for each entry for storing metadata used in providing hardware awareness of data types, as well as other information, such as the type of access permitted to data in selected memory locations, casting rules, and assertions.
- additional fields may be queried, values from these fields retrieved, and values in these fields updated based on the particular event causing the access to the page table.
- the metadata in these fields may be cached in processor resources similar to a Translation Look-aside Buffer (TLB) or an Effective to Real Address Translation Buffer (ERATB).
- TLB Translation Look-aside Buffer
- ERATB Effective to Real Address Translation Buffer
- DTLAB Data Type Look-Aside Buffer
- the program or virtual address may be performed in the DTLAB to obtain both the address translation information and the metadata associated with memory locations. If the program or virtual address is not present in the PILAB, the page table may be consulted to obtain this information.
- FIG. 9 illustrates an exemplary page table entry in accordance with an exemplary embodiment of the present invention.
- page table entry 900 includes field 910 for storing a virtual page address, field 920 for storing a physical page address, and additional fields, data type field 930 , casting field 940 , and assertion field 950 , for storing metadata relating to data in memory locations.
- additional fields are used by the hardware in determining the validity of data in memory locations, determining whether to perform a cast operation, and checking assertions and statements about values of variables. These assertions also are referred to as data invariance.
- the metadata may be associated with these memory locations within the page table.
- the virtual address of the data in the memory location may be used to identify an entry in the page table and the values stored in data type field 930 , casting field 940 , and assertion field 950 may be checked to see if metadata is associated with the physical page or a portion of the physical page. That is, if the offset associated with the virtual address falls within an offset range identified in data type field 930 , casting field 940 , and/or assertion field 950 has metadata stored therein, then the data in the memory location corresponding to the virtual address is associated with metadata for use by the processor.
- FIG. 9 shows only a single field for storing a data type, a single field for storing a cast, and a single field for storing an assertion, the present invention is not limited to such. Rather, any number of fields for storing a plurality of numbers and types of metadata for use in checking and performing operations on data may be used without departing from the spirit and scope of the present invention.
- FIG. 10 a flowchart of a process for adding instructions to generate metadata for a program is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 10 may be implemented in a compiler, such as compiler 500 in FIG. 5 .
- the process illustrated in this figure describes a process for generating compiled code, that creates or manipulates metadata for use by hardware.
- the process begins by selecting a source instruction for processing (step 1000 ).
- the source instruction is compiled, (step 1002 ).
- a single source instruction may result in more than one machine instruction being generated.
- a determination is made as to whether the source instruction is one requiring metadata (step 1004 ).
- the instruction may be, for example, one that requires data type checking in these illustrative examples. This instruction may be any instruction that involves a memory location, or a cast, or a data invariant assertion. Alternatively, specific instructions or groups of instructions may be selected for generating metadata.
- the metadata is present before the instruction is executed, such as with metadata for an insertion.
- the metadata may be present after execution of an instruction, such as allocated memory.
- code modules may be trusted because these code modules have been formerly verified. For these types of modules, avoiding additional overhead associated with hardware checking may be desirable. For these and other reasons, it may be useful to associate hardware readable metadata with modules or groups of instructions, such as subroutines, methods, or even basic blocks, to specify the type of hardware checks during execution.
- This metadata is typically generated by the compiler and may be triggered by user input in the form of assertions in a program. For example, to indicate to the compiler that subroutine foo is trusted and that no hardware type checking should be done while executing the instructions that comprise foo, the very first line inside foo could be “##Assert trusted foo”.
- a machine instruction generating metadata indicating an address and data type is inserted into the code (step 1006 ).
- the machine instructions that create or manipulate metadata go right in amongst the other instructions that the compiler is generating, usually are placed right before or right after the machine instruction implementing the selected instruction. This placement may vary depending on the type of instruction. For example, in the case of some invariants such as line 610 in FIG. 6 , the compiler would probably move the instructions generating the metadata outside and before the loop for performance, although the checks would still be located inside the loop.
- the metadata may be included as part of the memory location or the instruction may cause the metadata to be placed into a shadow memory or page table as described above.
- step 1008 a determination is made as to whether more instructions are present for compiling. If additional instructions are not present, then the process terminates. In step 1008 if additional instructions are present, then the process returns to step 1000 as described above.
- the process illustrated in FIG. 10 provides for the generation of metadata for use in validating data types by hardware.
- metadata may be generated using other mechanisms such, as hand-coding in assembly language.
- the metadata could be generated dynamically at runtime, depending, on the particular implementation.
- FIG. 11 a flowchart of a process for determining whether data in a memory location is of a valid data type is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 11 may be implemented in a processor functional unit, such as, for example, load store unit 228 in FIG. 2 .
- the process begins by detecting data change for a memory location (step 1100 ). Next, a determination is made as to whether metadata for data type validity is associated with the memory location of data (step 1102 ). This step is used to determine whether checking for data type validity is to be performed in these illustrative examples. If metadata for data type validity is associated with the location of data, then the data type is identified for data from metadata (step 1104 ). This data type is the data type that is expected for the data in the memory location.
- an interrupt is used as a specific type of error indication.
- the mechanism of the present invention may be implemented using other types of error indications in addition to or in place of an interrupt.
- the error indication may be an exception for metadata.
- the metadata may, for example, indicate that an invalid type is present using a code or error number.
- step 1102 if metadata for data type validity is not associated with the location of data, then the process terminates. In this instance, no determination is made as to whether the data is of a valid data type.
- step 1106 if the data type for the data is valid, then the process terminates. In this case, the operation, such as a load or store operation is performed.
- the mechanism of the present invention provides an ability for hardware in a processor to check for the validity of a data type for data in a memory location.
- This feature may be turned on and off such that the process provided in the hardware is never initiated or may be initiated at different times. The initiation of this feature may be made through the setting of a register in a processor, such as mode register 510 in FIG. 5 . Further, this process may be performed by other types of processor components other than a load store unit. For example, a dispatcher or a functional unit, such as a floating point unit may be a component in which this process is implemented.
- FIG. 12 a flowchart of a process for identifying whether an operation that is to be performed by a functional unit can be legally performed is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 12 may be implemented in a processor unit, such as a dispatcher or a functional unit. This process is initiated in response to a request or instruction to perform an operation on data in a memory location. This process assumes that a check with respect to the data type for data in the memory location has already been made and that the data is valid for the data type in the manner described above in FIG. 11 .
- the hardware may check the validity of operations. For example, branching to an address contained in a memory location that is of a type integer or float does not make sense, while such an operation is valid if the address in the memory location is a pointer. For a given data type, many illegal operations may be present. For example, floating point arithmetic on integers, floating point arithmetic on pointers, and integer arithmetic on floating point values are illegal operations.
- the mechanism of the present invention includes an additional feature in which detection of an illegal operation is made before the operation occurs. Further, information about an illegal operation also may be collected for later use in debugging.
- the process begins by identifying an operation to be performed on data (step 1200 ).
- the data type of the data used in the identified operation is identified (step 1202 ).
- the identification of the data type for the data is made by the hardware identifying the metadata associated with the memory location.
- the data type in the memory allocation has already been validated using the process described with respect to FIG. 11 above.
- the interrupt is generated (step 1208 ) with the process terminating thereafter.
- the interrupt may include information, such as the instruction, the location of the instruction, and associated data values. This interrupt may be handled by the operating system or by another program, such as a debugging program. Of course, a different type of error indication, such as, for example, an exception or metadata may be generated.
- the process performed by the hardware in FIG. 12 provides a mechanism to determine the correctness of operations performed on data. If this process is implemented in a functional unit, the functional unit may be, for example, a floating point unit if the operation performed is to add floating point values.
- the operations handled by the process in FIG. 12 include arithmetic operations and non-arithmetic operations. Arithmetic operations include adding and subtracting. Non-arithmetic operations include branch and shift operations.
- operations may be valid for a given data type under some circumstances or in some higher level languages, but illegal in others.
- arithmetic operations of any kind on pointers are forbidden in Java, but integer arithmetic on pointers is a valid operation and is common in C programs.
- FIG. 13 a flowchart of a process for correcting data types to perform an arithmetic operation is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 13 may be implemented in a processor unit, such as a functional unit or a dispatcher.
- the process in FIG. 13 builds upon determining whether an arithmetic operation may be performed on data. If the data type is incorrect, the mechanism of the present invention may cast or change the data type to the one needed for the operation.
- the change or cast to be performed is specified by the metadata in these illustrative examples.
- This metadata is associated with a particular instruction, such as a floating point add, or set of instructions, such as subroutines or methods. Such an association is in contrast to association of metadata with memory locations used to validate data types.
- This process is initiated in response to a request or instruction to perform an arithmetic operation on data in a memory location. This process assumes that a check with respect to the data type for data in the memory location has already been made and that the data is valid for the data type in the manner described above in FIG. 11 .
- the process begins by identifying an arithmetic operation (step 1300 ).
- the data type of data used in the identified arithmetic operation is identified (step 1302 ).
- a determination is made as to whether the identified arithmetic operation is legal with the data type of the data (step 1304 ). If the arithmetic operation is legal with the data type, then an arithmetic operation is performed (step 1306 ) with the process terminating thereafter.
- step 1308 a determination is made as to whether the data type can be cast to a data type for a legal arithmetic operation. If an invalid data type can be cast to a desired data type, then an invalid data type is cast to the data type that allows for the identified arithmetic operation to be legally performed (step 1310 ).
- step 1312 if the data type cannot be cast to a data type for a legal arithmetic operation, an interrupt is generated (step 1312 ).
- This interrupt may include information used to analyze the error. This information may include, for example, the instruction, the location: of the instruction, and data values associated with the instruction. Of course, a different type of error indication, such as, for example, an exception or metadata may be generated.
- the mechanism of the present invention allows for data to be cast or changed to a legal data type using metadata associated with the instruction for the operation, such that the operation may be performed.
- the cast or change may be based on predefined rules implemented into the particular hardware unit.
- assertions may be included about the state of a program that is required to remain true during execution of the program. These assertions are useful in improving the reliability of programs and code. Examples of assertions include “n must never be negative”, “ ⁇ 1.0 ⁇ x ⁇ 1.0”, etc. Most program assertions are statements about the values of variables; such assertions are sometimes called data invariants. Assertions are typically implemented by extra instructions that the compiler generates that perform, runtime checks on the program's state at specified points in the program's execution.
- the casting is performed with respect to arithmetic operations.
- This mechanism may be applied to recast data to a required data type for different types of operations other than arithmetic operations, depending on the particular implementation.
- the mechanism of the present invention allows for assertions to be implemented in hardware using metadata that may be associated with a given memory location.
- FIG. 14 a block diagram of a process for illustrating components used in determining whether an assertion is true is depicted in accordance with a preferred embodiment of the present invention.
- the processes may be implemented in hardware, such as load/store unit 1400 .
- microcode 1406 In other illustrative embodiments, the assertion may be located in microcode 1406 .
- metadata 1404 contains a pointer to microcode 1406 .
- Microcode in these examples, are the lowest level instructions that directly control a processor. A single machine language instruction typically translates into several microcode instructions. Microcode may be in hardware or software form. In many modern processors, the microcode is hard-wired into the processors.
- load/store unit 1400 detects an invariant violation, an interrupt may be generated to provide information about the violation. Further, implementing assertions in hardware provides an increased reliability advantage over code generated by software because other violations, such as invalid values may be detected using the other mechanism described above in addition to identifying valid values that validate the assertion.
- FIG. 15 a flowchart of a process for illustrating steps in checking the validity of an assertion is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 15 may be implemented in a processor component, such as load/store unit 1400 in FIG. 14 .
- the process begins by detecting change in data (step 1500 ).
- This data may be a value placed into a register in which the value has changed as a result of an operation performed on the value by a functional unit. Additionally the change may be the movement of the data to a memory location from a register or from another memory location. Moving data from a memory to a register does not change the value of the data, but data moved from a register to a memory may have a change.
- the hardware such as load/store unit 1400 in FIG. 14 , should check the metadata associated with that memory location.
- a determination is made as to whether metadata is present for data (step 1502 ). If metadata is present for data then a determination is made as to whether an assertion is present (step 1504 ). This determination may be made by seeing if the assertion is within the metadata or if the metadata points to another data structure, such as microcode, containing the assertion. If the assertion is present in the metadata, then a determination is made as to whether the assertion is correct (step 1506 ) with the process terminating thereafter.
- step 1504 if matadata is not present for data, then the process terminates.
- step 1504 if an assertion is not present, then the process terminates.
- step 1506 if the assertion is not correct then an error, identifying the instruction, its location, the location of the data, the assertion that was violated, and the forbidden value, is generated (step 1508 ) with the process terminating thereafter.
- the error generated in these illustrative examples is an interrupt. This interrupt may be handled by the operating system or by some designated program, such as a debugging software tool. Of course, a different type of error indication, such as, for example, an exception or metadata may be generated.
- An additional feature that is useful in determining software correctness for use in increasing reliability is to determine whether data accessed during execution of the program has been correctly accessed. In other words, it is useful to know whether the type of access permitted to data in a memory location corresponds to the access that is attempted or initiated on that data in the memory location during execution of code.
- the mechanisms of the present invention provide an ability to generate metadata for many variables stored in memory locations in a manner similar to that for validating data types.
- the metadata identifies the state of data for a particular memory location. This state may include the type of access that is permitted for a particular memory location.
- the metadata may indicate that data in a particular memory location is read-only or read/write. Further, the state may indicate whether the data is initialized or uninitialized. In this manner, an interrupt is generated if the data is accessed incorrectly. This interrupt may be handled by the operating system or by some other program, such as a debugging software tool.
- FIG. 16 a flowchart of a process for determining the state of data in memory locations is depicted in accordance with a preferred embodiment of the present invention.
- the process illustrated in FIG. 16 may be implemented in a processor component, such as load/store unit 1400 in FIG. 14 .
- the process begins by receiving an instruction for execution (step 1600 ). Next, an operation is to be performed and the data is identified (step 1602 ). Then, a determination is made as to whether metadata identifying state is associated with data (step 1604 ).
- the metadata is data for identifying the state of data for a particular memory location. The state of the data may indicate, for example, that the data is initialized and read-only.
- step 1606 a determination is made as to whether an operation is valid for the state defined for data. If the operation is to read the data from the memory location, then the operation is valid. If the operation involves modifying or writing new data into the memory location, the operation is invalid in this particular example. If an operation is valid for state defined for data then an operation on data is performed (step 1608 ) with the process terminating thereafter.
- step 1606 if an operation is not valid for state defined for data, then an interrupt is generated (step 1610 ) with the process terminating thereafter.
- an interrupt is generated (step 1610 ) with the process terminating thereafter.
- a different type of error indication such as, for example, an exception or metadata may be generated.
- the present invention provides an ability to monitor the execution of specific instructions with respect to providing hardware awareness of the data upon which operations are performed.
- the mechanisms of the present invention provide hardware assistance for use in generating information for increasing and verifying the reliability of software systems. These mechanisms include metadata that is used by hardware components executing instructions to determine the validity of data types for data in memory locations, determine whether operations may be legally performed on data, selectively cast data, maintain and validate assertions regarding data, and insuring that operations can be performed on data based on the state of data through the different processes described above.
- steps illustrated in the flowcharts described above provide a logical flow of processes that may be executed by different components in hardware.
- these steps may be implemented as microcode or hardware logic in a processor.
Abstract
Description
Claims (32)
Priority Applications (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/835,484 US7269718B2 (en) | 2004-04-29 | 2004-04-29 | Method and apparatus for verifying data types to be used for instructions and casting data types if needed |
Applications Claiming Priority (1)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US10/835,484 US7269718B2 (en) | 2004-04-29 | 2004-04-29 | Method and apparatus for verifying data types to be used for instructions and casting data types if needed |
Publications (2)
Publication Number | Publication Date |
---|---|
US20060020946A1 US20060020946A1 (en) | 2006-01-26 |
US7269718B2 true US7269718B2 (en) | 2007-09-11 |
Family
ID=35658734
Family Applications (1)
Application Number | Title | Priority Date | Filing Date |
---|---|---|---|
US10/835,484 Active 2025-04-15 US7269718B2 (en) | 2004-04-29 | 2004-04-29 | Method and apparatus for verifying data types to be used for instructions and casting data types if needed |
Country Status (1)
Country | Link |
---|---|
US (1) | US7269718B2 (en) |
Cited By (23)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20060242628A1 (en) * | 2003-06-27 | 2006-10-26 | Microsoft Corporation | An extensible type system for representing and checking consistency of program components during the process of compilation |
US20070234323A1 (en) * | 2006-02-16 | 2007-10-04 | Franaszek Peter A | Learning and cache management in software defined contexts |
US20070250821A1 (en) * | 2006-04-21 | 2007-10-25 | Microsoft Corporation | Machine declarative language for formatted data processing |
US20070250811A1 (en) * | 2006-04-21 | 2007-10-25 | Microsoft Corporation | User declarative language for formatted data processing |
US20070260584A1 (en) * | 2006-04-21 | 2007-11-08 | Marti Jordi M | System for processing formatted data |
US20080019281A1 (en) * | 2006-07-21 | 2008-01-24 | Microsoft Corporation | Reuse of available source data and localizations |
US7711546B2 (en) | 2006-04-21 | 2010-05-04 | Microsoft Corporation | User interface for machine aided authoring and translation |
US7933786B2 (en) | 2005-11-01 | 2011-04-26 | Accenture Global Services Limited | Collaborative intelligent task processor for insurance claims |
US20110107149A1 (en) * | 2004-04-29 | 2011-05-05 | International Business Machines Corporation | Method and apparatus for identifying access states for variables |
US7979382B2 (en) | 1999-05-04 | 2011-07-12 | Accenture Global Services Limited | Component based information linking during claim processing |
US20110173592A1 (en) * | 2010-01-13 | 2011-07-14 | International Business Machines Corporation | Architectural Support for Automated Assertion Checking |
US8094009B2 (en) | 2008-08-27 | 2012-01-10 | The Invention Science Fund I, Llc | Health-related signaling via wearable items |
US8126742B2 (en) | 2003-05-09 | 2012-02-28 | Accenture Global Services Limited | Automated assignment of insurable events |
US8125331B2 (en) | 2008-08-27 | 2012-02-28 | The Invention Science Fund I, Llc | Health-related signaling via wearable items |
US8130095B2 (en) | 2008-08-27 | 2012-03-06 | The Invention Science Fund I, Llc | Health-related signaling via wearable items |
US8284046B2 (en) | 2008-08-27 | 2012-10-09 | The Invention Science Fund I, Llc | Health-related signaling via wearable items |
US8317776B2 (en) | 2007-12-18 | 2012-11-27 | The Invention Science Fund I, Llc | Circulatory monitoring systems and methods |
US8409132B2 (en) | 2007-12-18 | 2013-04-02 | The Invention Science Fund I, Llc | Treatment indications informed by a priori implant information |
US8478769B2 (en) | 2008-02-22 | 2013-07-02 | Accenture Global Services Limited | Conversational question generation system adapted for an insurance claim processing system |
US8515786B2 (en) | 2008-02-22 | 2013-08-20 | Accenture Global Services Gmbh | Rule generation system adapted for an insurance claim processing system |
US8636670B2 (en) | 2008-05-13 | 2014-01-28 | The Invention Science Fund I, Llc | Circulatory monitoring systems and methods |
US8863079B2 (en) * | 2012-07-31 | 2014-10-14 | Oracle International Corporation | Efficient and expansive conversions between reference and primitive |
WO2019166762A1 (en) * | 2018-02-27 | 2019-09-06 | Arm Limited | An apparatus and method for accessing metadata when debugging a device |
Families Citing this family (10)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US20060031628A1 (en) * | 2004-06-03 | 2006-02-09 | Suman Sharma | Buffer management in a network device without SRAM |
KR101375836B1 (en) * | 2007-06-26 | 2014-04-01 | 삼성전자주식회사 | Method and apparatus for performing related task on multi-core processor |
US8762942B2 (en) * | 2008-10-03 | 2014-06-24 | Microsoft Corporation | Bidirectional type checking for declarative data scripting language |
US9542164B1 (en) | 2011-03-02 | 2017-01-10 | The Mathworks, Inc. | Managing an application variable using variable attributes |
US9336125B2 (en) | 2011-08-24 | 2016-05-10 | University Of Washington Through Its Center For Commercialization | Systems and methods for hardware-assisted type checking |
US8966203B2 (en) | 2013-01-04 | 2015-02-24 | Microsoft Corporation | Shared and managed memory unified access |
US9323693B2 (en) | 2013-01-04 | 2016-04-26 | Microsoft Technology Licensing, Llc | Zero-copy caching |
US9053028B2 (en) * | 2013-01-04 | 2015-06-09 | Microsoft Technology Licensing Llc | Type casting in a managed code system |
US9189446B2 (en) | 2013-01-04 | 2015-11-17 | Microsoft Technology Licensing, Llc | Immutable sharable zero-copy data and streaming |
MA44821A (en) | 2016-02-27 | 2019-01-02 | Kinzinger Automation Gmbh | PROCESS FOR ALLOCATING A STACK OF VIRTUAL REGISTERS IN A BATTERY MACHINE |
Citations (25)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US5555432A (en) | 1994-08-19 | 1996-09-10 | Intel Corporation | Circuit and method for scheduling instructions by predicting future availability of resources required for execution |
US5590352A (en) | 1994-04-26 | 1996-12-31 | Advanced Micro Devices, Inc. | Dependency checking and forwarding of variable width operands |
US5761103A (en) | 1995-03-08 | 1998-06-02 | Texas Instruments Incorporated | Left and right justification of single precision mantissa in a double precision rounding unit |
US5875294A (en) | 1995-06-30 | 1999-02-23 | International Business Machines Corporation | Method and system for halting processor execution in response to an enumerated occurrence of a selected combination of internal states |
US6073109A (en) | 1993-02-08 | 2000-06-06 | Action Technologies, Inc. | Computerized method and system for managing business processes using linked workflows |
US6105129A (en) | 1998-02-18 | 2000-08-15 | Advanced Micro Devices, Inc. | Converting register data from a first format type to a second format type if a second type instruction consumes data produced by a first type instruction |
US6145077A (en) | 1995-05-17 | 2000-11-07 | Sgs-Thomson Microelectronics Limited | Manipulation of data |
US6149318A (en) | 1997-04-15 | 2000-11-21 | Samuel C. Kendall | Link-time and run-time error detection, and program instrumentation |
US6185671B1 (en) * | 1998-03-31 | 2001-02-06 | Intel Corporation | Checking data type of operands specified by an instruction using attributes in a tagged array architecture |
US6199204B1 (en) | 1998-01-28 | 2001-03-06 | International Business Machines Corporation | Distribution of software updates via a computer network |
US6202207B1 (en) | 1998-01-28 | 2001-03-13 | International Business Machines Corporation | Method and a mechanism for synchronized updating of interoperating software |
US6247113B1 (en) * | 1998-05-27 | 2001-06-12 | Arm Limited | Coprocessor opcode division by data type |
US6460135B1 (en) * | 1998-10-02 | 2002-10-01 | Nec Corporation | Data type conversion based on comparison of type information of registers and execution result |
US20030041096A1 (en) | 2001-08-22 | 2003-02-27 | International Business Machines Corporation | Transaction processing in a distributed data processing system |
US20030126590A1 (en) | 2001-12-28 | 2003-07-03 | Michael Burrows | System and method for dynamic data-type checking |
US6598153B1 (en) | 1999-12-10 | 2003-07-22 | International Business Machines Corporation | Processor and method that accelerate evaluation of pairs of condition-setting and branch instructions |
US6842850B2 (en) * | 1999-10-25 | 2005-01-11 | Intel Corporation | DSP data type matching for operation using multiple functional units |
US6851108B1 (en) * | 1999-09-01 | 2005-02-01 | Microsoft Corporation | Verifying intermediate language code |
US6865666B2 (en) | 1998-02-09 | 2005-03-08 | Renesas Technology Corp. | Data processing device |
US6871298B1 (en) | 1999-11-12 | 2005-03-22 | Obsidian Software, Inc. | Method and apparatus that simulates the execution of paralled instructions in processor functional verification testing |
US6928521B1 (en) | 2000-08-01 | 2005-08-09 | International Business Machines Corporation | Method, system, and data structures for using metadata in updating data in a storage device |
US20050177822A1 (en) | 2000-04-04 | 2005-08-11 | Microsoft Corporation | Profile-driven data layout optimization |
US6944720B2 (en) * | 2000-06-30 | 2005-09-13 | Intel Corporation | Memory system for multiple data types |
US20050257092A1 (en) | 2004-04-29 | 2005-11-17 | International Business Machines Corporation | Method and apparatus for identifying access states for variables |
US7035996B2 (en) * | 2002-01-17 | 2006-04-25 | Raytheon Company | Generating data type token value error in stream computer |
-
2004
- 2004-04-29 US US10/835,484 patent/US7269718B2/en active Active
Patent Citations (25)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6073109A (en) | 1993-02-08 | 2000-06-06 | Action Technologies, Inc. | Computerized method and system for managing business processes using linked workflows |
US5590352A (en) | 1994-04-26 | 1996-12-31 | Advanced Micro Devices, Inc. | Dependency checking and forwarding of variable width operands |
US5555432A (en) | 1994-08-19 | 1996-09-10 | Intel Corporation | Circuit and method for scheduling instructions by predicting future availability of resources required for execution |
US5761103A (en) | 1995-03-08 | 1998-06-02 | Texas Instruments Incorporated | Left and right justification of single precision mantissa in a double precision rounding unit |
US6145077A (en) | 1995-05-17 | 2000-11-07 | Sgs-Thomson Microelectronics Limited | Manipulation of data |
US5875294A (en) | 1995-06-30 | 1999-02-23 | International Business Machines Corporation | Method and system for halting processor execution in response to an enumerated occurrence of a selected combination of internal states |
US6149318A (en) | 1997-04-15 | 2000-11-21 | Samuel C. Kendall | Link-time and run-time error detection, and program instrumentation |
US6199204B1 (en) | 1998-01-28 | 2001-03-06 | International Business Machines Corporation | Distribution of software updates via a computer network |
US6202207B1 (en) | 1998-01-28 | 2001-03-13 | International Business Machines Corporation | Method and a mechanism for synchronized updating of interoperating software |
US6865666B2 (en) | 1998-02-09 | 2005-03-08 | Renesas Technology Corp. | Data processing device |
US6105129A (en) | 1998-02-18 | 2000-08-15 | Advanced Micro Devices, Inc. | Converting register data from a first format type to a second format type if a second type instruction consumes data produced by a first type instruction |
US6185671B1 (en) * | 1998-03-31 | 2001-02-06 | Intel Corporation | Checking data type of operands specified by an instruction using attributes in a tagged array architecture |
US6247113B1 (en) * | 1998-05-27 | 2001-06-12 | Arm Limited | Coprocessor opcode division by data type |
US6460135B1 (en) * | 1998-10-02 | 2002-10-01 | Nec Corporation | Data type conversion based on comparison of type information of registers and execution result |
US6851108B1 (en) * | 1999-09-01 | 2005-02-01 | Microsoft Corporation | Verifying intermediate language code |
US6842850B2 (en) * | 1999-10-25 | 2005-01-11 | Intel Corporation | DSP data type matching for operation using multiple functional units |
US6871298B1 (en) | 1999-11-12 | 2005-03-22 | Obsidian Software, Inc. | Method and apparatus that simulates the execution of paralled instructions in processor functional verification testing |
US6598153B1 (en) | 1999-12-10 | 2003-07-22 | International Business Machines Corporation | Processor and method that accelerate evaluation of pairs of condition-setting and branch instructions |
US20050177822A1 (en) | 2000-04-04 | 2005-08-11 | Microsoft Corporation | Profile-driven data layout optimization |
US6944720B2 (en) * | 2000-06-30 | 2005-09-13 | Intel Corporation | Memory system for multiple data types |
US6928521B1 (en) | 2000-08-01 | 2005-08-09 | International Business Machines Corporation | Method, system, and data structures for using metadata in updating data in a storage device |
US20030041096A1 (en) | 2001-08-22 | 2003-02-27 | International Business Machines Corporation | Transaction processing in a distributed data processing system |
US20030126590A1 (en) | 2001-12-28 | 2003-07-03 | Michael Burrows | System and method for dynamic data-type checking |
US7035996B2 (en) * | 2002-01-17 | 2006-04-25 | Raytheon Company | Generating data type token value error in stream computer |
US20050257092A1 (en) | 2004-04-29 | 2005-11-17 | International Business Machines Corporation | Method and apparatus for identifying access states for variables |
Non-Patent Citations (5)
Title |
---|
Alexander et al. Method and Apparatus for Data-Aware Hardware Operations. |
Alexander et al. Method and Apparatus for Hardware Awareness of Data Types. |
Alexander et al. Method and Apparatus for Identifying Access States for Variables. |
Alexander et al. Method and Apparatus for Implementing Assertions in Hardware. |
Tanenbaum, Andrew S. "Structured Computer Organization." pp. 11-12. Prentice-Hall, 1984, second edition. * |
Cited By (40)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US8224859B2 (en) | 1999-05-04 | 2012-07-17 | Accenture Global Services Limited | Component based information linking during claim processing |
US7979382B2 (en) | 1999-05-04 | 2011-07-12 | Accenture Global Services Limited | Component based information linking during claim processing |
US8126742B2 (en) | 2003-05-09 | 2012-02-28 | Accenture Global Services Limited | Automated assignment of insurable events |
US20060242628A1 (en) * | 2003-06-27 | 2006-10-26 | Microsoft Corporation | An extensible type system for representing and checking consistency of program components during the process of compilation |
US20110107149A1 (en) * | 2004-04-29 | 2011-05-05 | International Business Machines Corporation | Method and apparatus for identifying access states for variables |
US8479050B2 (en) | 2004-04-29 | 2013-07-02 | International Business Machines Corporation | Identifying access states for variables |
US8180668B2 (en) | 2005-11-01 | 2012-05-15 | Accenture Global Services Limited | Collaborative intelligent task processor for insurance claims |
US8401896B2 (en) | 2005-11-01 | 2013-03-19 | Accenture Global Services Limited | Automated task processor for insurance claims |
US7933786B2 (en) | 2005-11-01 | 2011-04-26 | Accenture Global Services Limited | Collaborative intelligent task processor for insurance claims |
US7904887B2 (en) * | 2006-02-16 | 2011-03-08 | International Business Machines Corporation | Learning and cache management in software defined contexts |
US20090320006A1 (en) * | 2006-02-16 | 2009-12-24 | Franaszek Peter A | Learning and cache management in software defined contexts |
US20070234323A1 (en) * | 2006-02-16 | 2007-10-04 | Franaszek Peter A | Learning and cache management in software defined contexts |
US8136106B2 (en) | 2006-02-16 | 2012-03-13 | International Business Machines Corporation | Learning and cache management in software defined contexts |
US7827155B2 (en) * | 2006-04-21 | 2010-11-02 | Microsoft Corporation | System for processing formatted data |
US8549492B2 (en) | 2006-04-21 | 2013-10-01 | Microsoft Corporation | Machine declarative language for formatted data processing |
US20070260584A1 (en) * | 2006-04-21 | 2007-11-08 | Marti Jordi M | System for processing formatted data |
US20070250821A1 (en) * | 2006-04-21 | 2007-10-25 | Microsoft Corporation | Machine declarative language for formatted data processing |
US7711546B2 (en) | 2006-04-21 | 2010-05-04 | Microsoft Corporation | User interface for machine aided authoring and translation |
US8171462B2 (en) | 2006-04-21 | 2012-05-01 | Microsoft Corporation | User declarative language for formatted data processing |
US20070250811A1 (en) * | 2006-04-21 | 2007-10-25 | Microsoft Corporation | User declarative language for formatted data processing |
US20080019281A1 (en) * | 2006-07-21 | 2008-01-24 | Microsoft Corporation | Reuse of available source data and localizations |
US8317776B2 (en) | 2007-12-18 | 2012-11-27 | The Invention Science Fund I, Llc | Circulatory monitoring systems and methods |
US8870813B2 (en) | 2007-12-18 | 2014-10-28 | The Invention Science Fund I, Llc | Circulatory monitoring systems and methods |
US9717896B2 (en) | 2007-12-18 | 2017-08-01 | Gearbox, Llc | Treatment indications informed by a priori implant information |
US8409132B2 (en) | 2007-12-18 | 2013-04-02 | The Invention Science Fund I, Llc | Treatment indications informed by a priori implant information |
US8403881B2 (en) | 2007-12-18 | 2013-03-26 | The Invention Science Fund I, Llc | Circulatory monitoring systems and methods |
US8515786B2 (en) | 2008-02-22 | 2013-08-20 | Accenture Global Services Gmbh | Rule generation system adapted for an insurance claim processing system |
US8478769B2 (en) | 2008-02-22 | 2013-07-02 | Accenture Global Services Limited | Conversational question generation system adapted for an insurance claim processing system |
US8636670B2 (en) | 2008-05-13 | 2014-01-28 | The Invention Science Fund I, Llc | Circulatory monitoring systems and methods |
US8094009B2 (en) | 2008-08-27 | 2012-01-10 | The Invention Science Fund I, Llc | Health-related signaling via wearable items |
US8125331B2 (en) | 2008-08-27 | 2012-02-28 | The Invention Science Fund I, Llc | Health-related signaling via wearable items |
US8284046B2 (en) | 2008-08-27 | 2012-10-09 | The Invention Science Fund I, Llc | Health-related signaling via wearable items |
US8130095B2 (en) | 2008-08-27 | 2012-03-06 | The Invention Science Fund I, Llc | Health-related signaling via wearable items |
US20110173592A1 (en) * | 2010-01-13 | 2011-07-14 | International Business Machines Corporation | Architectural Support for Automated Assertion Checking |
US8589895B2 (en) * | 2010-01-13 | 2013-11-19 | International Business Machines Corporation | Architectural support for automated assertion checking |
US8863079B2 (en) * | 2012-07-31 | 2014-10-14 | Oracle International Corporation | Efficient and expansive conversions between reference and primitive |
WO2019166762A1 (en) * | 2018-02-27 | 2019-09-06 | Arm Limited | An apparatus and method for accessing metadata when debugging a device |
CN111742303A (en) * | 2018-02-27 | 2020-10-02 | Arm有限公司 | Apparatus and method for accessing metadata when debugging a device |
US11436124B2 (en) | 2018-02-27 | 2022-09-06 | Arm Limited | Apparatus and method for accessing metadata when debugging a device |
CN111742303B (en) * | 2018-02-27 | 2024-04-19 | Arm有限公司 | Apparatus and method for accessing metadata when debugging a device |
Also Published As
Publication number | Publication date |
---|---|
US20060020946A1 (en) | 2006-01-26 |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US8479050B2 (en) | Identifying access states for variables | |
US7647457B2 (en) | Method and apparatus for hardware awareness of data types | |
US7269718B2 (en) | Method and apparatus for verifying data types to be used for instructions and casting data types if needed | |
US7711988B2 (en) | Architecture support system and method for memory monitoring | |
JP4749745B2 (en) | Method and apparatus for autonomous test case feedback using hardware assistance for code coverage | |
US7299319B2 (en) | Method and apparatus for providing hardware assistance for code coverage | |
US7437542B2 (en) | Identifying and processing essential and non-essential code separately | |
US7421684B2 (en) | Method and apparatus for autonomic test case feedback using hardware assistance for data coverage | |
US7526616B2 (en) | Method and apparatus for prefetching data from a data structure | |
US6505296B2 (en) | Emulated branch effected by trampoline mechanism | |
KR100421749B1 (en) | Method and apparatus for implementing non-faulting load instruction | |
JP2001504957A (en) | Memory data aliasing method and apparatus in advanced processor | |
JP2001507151A (en) | Gate storage buffers for advanced microprocessors. | |
JP2001519956A (en) | A memory controller that detects the failure of thinking of the addressed component | |
US7051238B2 (en) | Method and system for using machine-architecture support to distinguish function and routine return values | |
US7296130B2 (en) | Method and apparatus for providing hardware assistance for data access coverage on dynamically allocated data | |
US7328374B2 (en) | Method and apparatus for implementing assertions in hardware | |
US20060277371A1 (en) | System and method to instrument references to shared memory | |
JP2001519953A (en) | Microprocessor improvements | |
US20050210199A1 (en) | Method and apparatus for hardware assistance for prefetching data | |
US20050251706A1 (en) | Method and apparatus for data-aware hardware operations | |
US6931515B2 (en) | Method and system for using dynamic, deferred operation information to control eager deferral of control-speculative loads | |
JP2001519955A (en) | Translation memory protector for advanced processors | |
Zorn et al. | ‘SPUR Lisp: Deisgn and Implementation | |
Gerasimov et al. | Case study: Source code static analysis for performance issues detection |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
AS | Assignment |
Owner name: INTERNATIONAL BUSINESS MACHINES CORPORATION, NEW YFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:ALEXANDER, WILLIAM PRESTON III;DIMPSEY, ROBERT TOD;LEVINE, FRANK ELIOT;AND OTHERS;REEL/FRAME:015037/0022;SIGNING DATES FROM 20040423 TO 20040426 |
|
FEPP | Fee payment procedure |
Free format text: PAYOR NUMBER ASSIGNED (ORIGINAL EVENT CODE: ASPN); ENTITY STATUS OF PATENT OWNER: LARGE ENTITY |
|
STCF | Information on status: patent grant |
Free format text: PATENTED CASE |
|
REMI | Maintenance fee reminder mailed | ||
FPAY | Fee payment |
Year of fee payment: 4 |
|
SULP | Surcharge for late payment | ||
AS | Assignment |
Owner name: GOOGLE INC., CALIFORNIAFree format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:INTERNATIONAL BUSINESS MACHINES CORPORATION;REEL/FRAME:026664/0866Effective date: 20110503 |
|
FPAY | Fee payment |
Year of fee payment: 8 |
|
AS | Assignment |
Owner name: GOOGLE LLC, CALIFORNIAFree format text: CHANGE OF NAME;ASSIGNOR:GOOGLE INC.;REEL/FRAME:044127/0735Effective date: 20170929 |
|
MAFP | Maintenance fee payment |
Free format text: PAYMENT OF MAINTENANCE FEE, 12TH YEAR, LARGE ENTITY (ORIGINAL EVENT CODE: M1553); ENTITY STATUS OF PATENT OWNER: LARGE ENTITYYear of fee payment: 12 |