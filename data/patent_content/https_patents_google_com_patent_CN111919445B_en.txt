CN111919445B - System and method for image compression and decompression using triangulation - Google Patents
System and method for image compression and decompression using triangulation Download PDFInfo
- Publication number
- CN111919445B CN111919445B CN201980019917.7A CN201980019917A CN111919445B CN 111919445 B CN111919445 B CN 111919445B CN 201980019917 A CN201980019917 A CN 201980019917A CN 111919445 B CN111919445 B CN 111919445B
- Authority
- CN
- China
- Prior art keywords
- image
- grid
- vertices
- points
- color
- Prior art date
- Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)
- Active
Links
- 230000006835 compression Effects 0.000 title claims abstract description 33
- 238000007906 compression Methods 0.000 title claims abstract description 33
- 238000000034 method Methods 0.000 title claims description 149
- 230000006837 decompression Effects 0.000 title description 18
- 239000003086 colorant Substances 0.000 claims abstract description 90
- 238000012360 testing method Methods 0.000 claims description 41
- 238000012545 processing Methods 0.000 claims description 18
- 238000013507 mapping Methods 0.000 claims description 14
- 230000004044 response Effects 0.000 claims description 13
- 230000015654 memory Effects 0.000 description 58
- 230000008569 process Effects 0.000 description 25
- 238000004891 communication Methods 0.000 description 14
- 230000003044 adaptive effect Effects 0.000 description 8
- 230000004048 modification Effects 0.000 description 8
- 238000012986 modification Methods 0.000 description 8
- 230000035772 mutation Effects 0.000 description 8
- 238000004590 computer program Methods 0.000 description 6
- 230000006870 function Effects 0.000 description 6
- 230000005540 biological transmission Effects 0.000 description 5
- 238000013528 artificial neural network Methods 0.000 description 4
- 238000010586 diagram Methods 0.000 description 4
- 230000003287 optical effect Effects 0.000 description 4
- 230000009194 climbing Effects 0.000 description 3
- 230000007935 neutral effect Effects 0.000 description 3
- 238000009877 rendering Methods 0.000 description 3
- 238000012549 training Methods 0.000 description 3
- 230000001413 cellular effect Effects 0.000 description 2
- 239000002131 composite material Substances 0.000 description 2
- 238000001514 detection method Methods 0.000 description 2
- 238000005516 engineering process Methods 0.000 description 2
- 230000006872 improvement Effects 0.000 description 2
- 239000000758 substrate Substances 0.000 description 2
- ORILYTVJVMAKLC-UHFFFAOYSA-N Adamantane Natural products C1C(C2)CC3CC1CC2C3 ORILYTVJVMAKLC-UHFFFAOYSA-N 0.000 description 1
- XUIMIQQOPSSXEZ-UHFFFAOYSA-N Silicon Chemical compound [Si] XUIMIQQOPSSXEZ-UHFFFAOYSA-N 0.000 description 1
- 230000009471 action Effects 0.000 description 1
- 230000004913 activation Effects 0.000 description 1
- 238000013459 approach Methods 0.000 description 1
- 238000003491 array Methods 0.000 description 1
- 230000008901 benefit Effects 0.000 description 1
- 238000006243 chemical reaction Methods 0.000 description 1
- 238000012937 correction Methods 0.000 description 1
- 238000000354 decomposition reaction Methods 0.000 description 1
- 238000002224 dissection Methods 0.000 description 1
- 230000000694 effects Effects 0.000 description 1
- 238000011049 filling Methods 0.000 description 1
- 238000001914 filtration Methods 0.000 description 1
- 239000004973 liquid crystal related substance Substances 0.000 description 1
- 239000000463 material Substances 0.000 description 1
- 230000006855 networking Effects 0.000 description 1
- 238000010606 normalization Methods 0.000 description 1
- 239000013307 optical fiber Substances 0.000 description 1
- 230000009467 reduction Effects 0.000 description 1
- 238000012958 reprocessing Methods 0.000 description 1
- 238000005070 sampling Methods 0.000 description 1
- 229910052710 silicon Inorganic materials 0.000 description 1
- 239000010703 silicon Substances 0.000 description 1
- 238000002922 simulated annealing Methods 0.000 description 1
- 238000005549 size reduction Methods 0.000 description 1
- 239000007787 solid Substances 0.000 description 1
- 238000010561 standard procedure Methods 0.000 description 1
- 239000000126 substance Substances 0.000 description 1
- 239000013589 supplement Substances 0.000 description 1
- 230000001502 supplementing effect Effects 0.000 description 1
- 238000010998 test method Methods 0.000 description 1
- 239000010409 thin film Substances 0.000 description 1
Abstract
An encoder system can include a pixel grid generator to receive an image having a first size, generate a grid having a second size, add a plurality of points to locations on the grid, and map a plurality of pixels of the image to the plurality of points. The encoder system can include: a color module to assign a color to each of the plurality of points using the color table; a triangulation module to generate a plurality of vertices based on the plurality of points and triangulate the mesh using the vertices; and a compression module to compress the vertices into a set of compressed vertex positions and a set of vertex colors.
Description
Cross Reference to Related Applications
The present application claims the benefit of U.S. application Ser. No. 62/673,036, filed 5/17 at 2018, the entire disclosure of which is incorporated herein by reference.
Technical Field
Embodiments of the present invention relate to image compression using adaptive triangulation techniques.
Background
The increasing portion of internet traffic is controlled by requests from mobile devices with limited often metered bandwidth constraints. Responding to these requests typically includes conveying a small image (e.g., a thumbnail). Accordingly, it may be desirable to reduce the image size of these small images (e.g., the number of bytes used to store the image) using various compression techniques. For example, compression standards (e.g., joint Photographic Experts Group (JPEG)) have established standard methods for image compression. But JPEG and other compression standards do not significantly or sufficiently compress the small image. Accordingly, such drawbacks have been addressed by domain-specific techniques that are specific to image features (e.g., face, satellite map, smooth composite images, surveillance, and/or the like). Therefore, there is a need for efficient compression techniques that are capable of compressing images (e.g., small images) independent of image characteristics.
Disclosure of Invention
Exemplary embodiments of the present invention describe systems and methods for compressing and decompressing images (e.g., thumbnails) using adaptive triangulation techniques.
From a general aspect, an encoder system includes a pixel grid generator configured to: the method includes receiving an image having a first size, generating a grid having a second size, adding a plurality of points to locations on the grid, and mapping a plurality of pixels of the image to the plurality of points. The encoder system further comprises: a color module configured to assign a color to each of a plurality of points using a color table; a triangulation module configured to generate a plurality of vertices based on the plurality of points and triangulate the mesh using the vertices; and a compression module configured to compress the vertices into a compressed vertex position set and a vertex color set.
Viewed from another general aspect, a method of compressing an image comprises: receiving an image having a first size; generating a grid having a second size; adding a plurality of points to locations on the grid; mapping a plurality of pixels of an image to a plurality of points; assigning a color to each of the plurality of points using a color table; generating a plurality of vertices based on the plurality of points; triangulating the mesh using vertices; and compressing the vertices into a compressed vertex position set and a vertex color set.
Implementations can include one or more of the following features. For example, the second dimension is four (4) times to 400 times smaller than the first dimension. The second dimension is M, the grid can include M columns and M rows, the location on the grid can be at each block of the grid, the block at an intersection of a row and a column of the grid, and the adding the plurality of points to the grid can include one of: a point is inserted at each of the locations on the grid, or a plurality of points are inserted at a portion of the locations on the grid. The received image is a first image, the second size is M, the grid can include M columns and M rows, the location on the grid can be at each block of the grid, the block at an intersection of a row and a column of the grid, and adding the plurality of points to the location on the grid can include: inserting a threshold number of points into random locations on the grid, generating a second image using the points on the grid, comparing the second image to the first image, and repositioning the threshold number of points on the grid in response to determining that the comparison results in a quality greater than a threshold quality difference.
For example, a color table can be generated based on the received image, and the color table can include 2 to 16 colors. A color table can be generated based on the received image, and the color table can include 6 colors. The triangulation module is capable of triangulating the mesh using a Delaunay triangulation (Delaunay Triangulation) technique. The received image is a first image, the encoder system further comprising an image generator configured to generate a second image using the triangulated mesh and the colors associated with the vertices. Generating the second image can include drawing a triangle generated by the triangulation module based on the colors associated with each of the plurality of vertices.
For example, the received image is a first image, the encoder system further comprising: an image generator configured to generate a second image using the triangulated mesh and the colors associated with the vertices; and a test module configured to: based on the first image and the second image, performing a quality test, determining whether the second image meets at least one criterion based on the quality test and a size of the second image, wherein the at least one criterion includes a maximum size and a quality error, selecting a vertex from the plurality of vertices and removing the selected vertex from the plurality of vertices in response to determining that the second image does not meet the at least one criterion, and returning processing to the triangulation module. The received image is a first image, the encoder system further comprising an image generator configured to generate a second image using the triangulated mesh and the colors associated with the vertices; and a test module configured to perform a quality test based on the first image and the second image, determine whether the second image meets at least one criterion based on the quality test and a size of the second image, wherein the at least one criterion includes a maximum size and a quality error, and in response to determining that the second image does not meet the at least one criterion, at least one of: shifting vertices of the plurality of vertices, adding vertices to the plurality of vertices, removing vertices from the plurality of vertices, reassigning colors associated with at least one of the plurality of points, removing one of the colors of the color table, and modifying one of the colors of the color table, and returning the process to the triangulation module.
From yet another general aspect, a method of decompressing a compressed image includes: receiving a compressed image file, the compressed image file comprising at least one of a header, a compressed color table index, and a compressed triangulation; decompressing at least one of a compressed color table, a compressed color table index, and a compressed triangulation; generating a grid having an m×m size based on the grid size; assigning one of a plurality of points to each location of the grid based on the decompressed triangulation file; assigning a color index value to each of the plurality of points based on the decompressed triangulation file; mapping a color to each of the plurality of points based on the associated color index value; triangulating the mesh using the plurality of points as vertices; and generating a reconstructed image based on the vertices and triangles associated with the triangular section.
Implementations can include one or more of the following features. For example, a stacked hourglass network is used to improve the quality associated with reconstructing images, wherein the stacked hourglass network includes at least two hourglass, and intermediate supervision is applied by using an intermediate loss module capable of separating the output of each hourglass. Generating the reconstructed image can include rendering triangles generated by the triangulation based on colors associated with each of the plurality of vertices, and at least one of the triangles generated by the triangulation is rendered using interpolation techniques.
Drawings
The exemplary embodiments will become more fully understood from the detailed description given herein below and the accompanying drawings, wherein like elements are given like reference numerals, which are merely illustrative thereof and thus do not limit the exemplary embodiments.
Fig. 1 is a block diagram illustrating a data flow according to an example embodiment.
Fig. 2 illustrates a block diagram of an encoder system in accordance with at least one example embodiment.
Fig. 3 illustrates a method for generating a triangulation image according to at least one exemplary embodiment.
Fig. 4 illustrates a method for generating a triangulation image according to at least one exemplary embodiment.
Fig. 5 illustrates a decoder system in accordance with at least one example embodiment.
Fig. 6 illustrates a method for decoding image data and generating a reconstructed image in accordance with at least one example embodiment.
Fig. 7 illustrates a stacked hourglass network including intermediate losses in accordance with at least one example embodiment.
Fig. 8 illustrates an encoder system in accordance with at least one example embodiment.
Fig. 9 illustrates a decoder system in accordance with at least one example embodiment.
FIG. 10 illustrates an example of a computer device and a mobile computer device in accordance with at least one example embodiment.
It should be noted that these figures are intended to illustrate general characteristics of method structures and/or materials utilized in certain example embodiments, and to supplement the written description provided below. However, the drawings are not to scale and may not accurately reflect the precise structural or performance characteristics of any given embodiment, and should not be construed as limiting or restricting the scope of values or properties encompassed by the example embodiments. For example, the relative thicknesses and positioning of molecules, layers, regions and/or structural elements may be reduced or exaggerated for clarity. The use of similar or identical reference numbers in the various figures is intended to indicate the presence of similar or identical elements or features.
Detailed Description
While example embodiments are susceptible to various modifications and alternative forms, embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that there is no intention to limit the example embodiments to the specific forms disclosed, but on the contrary, the example embodiments are to cover all modifications, equivalents, and alternatives falling within the scope of the claims. Like numbers refer to like elements throughout the description of the figures.
Typical compression techniques use subdivision of an image into sets of blocks. The triangulation-based embodiments described herein use neither block embodiments nor predefined or uniform triangle spacing on the image. Instead, color indexes can be assigned for a limited set of vertices from a small (e.g., a limited number of colors) color map. For example, a net comprising a plurality of triangles, similar to those sometimes used in computer graphics and animation, can represent an image using a set of triangles interconnected at sides and/or corners. Each corner of a triangle can be referred to as a vertex. Thus, the image can also be represented by a set of vertices (a set of corners of a triangle) and the position of each vertex in a two-dimensional mesh or grid. In addition, as part of compressing the image, the two-dimensional mesh or grid may have a limited size. The limited size of a two-dimensional mesh or grid may also limit the size of the vertex set (e.g., limit the number of triangles and the number of associated vertices).
Further, color maps can be used to represent or store the colors of pixels in an image. As a result, each of the vertices can be associated with an indicator (e.g., a number, a binary integer, an index, or the like) that can be used to find the color of the vertex in the color map. In one embodiment (e.g., as part of compressing an image), a color map can be limited (e.g., color combining, color filtering by frequency of instances in the image, by predefined settings, and/or the like) to a relatively (e.g., less than 20 colors) smaller number of colors (e.g., as compared to the number of colors in the image). Accordingly, an indicator for associating a vertex with a color in a color map can be mapped to one of a limited number of colors in the color map.
In addition, as part of (or to aid in) generating the composite image, color interpolation between the vertices of the respective triangles can be used to populate the triangles. For example, if each of the three vertices of a triangle map to the same color in the color map (e.g., the color map includes a limited number of colors), then one color (e.g., the color associated with the three vertices) can be used to fill the triangle. However, if each of the three vertices of the triangle maps to a different color in the color map, interpolation of the different colors can be used to fill the triangle. In some implementations, more triangles can be dedicated to complex (e.g., high entropy, high color variability, high texture variability, and/or the like) regions of an image. Triangulation can be used for a variety of image compression techniques. Furthermore, compression/decompression techniques can use deep neural networks.
Thus, embodiments described herein are capable of compressing small images independent of image features. It should be appreciated that the embodiments described herein are not limited to compressing small images, but can be applied to images of any size. Further, compression resulting in reduced image size can help address the storage requirements associated with storing large (e.g., billions) of small images that are typically accessed in response to requests from mobile devices.
In some embodiments, there may be at least two portions of the embodiments described herein. In some embodiments, the first part is to create an efficient triangulation and the second part is to efficiently encode the triangulation. In some implementations, the portion of the triangulation can be implemented as two segments that interact by selecting the locations where the vertices of the triangulation are placed and assigning a single color to each vertex. In some embodiments, the number of vertices and the total number of unique colors can be reduced or minimized for transmission efficiency. Additionally, in some implementations, the first portion can implement a generation and test paradigm. The generation and test paradigm can be used to repeatedly regenerate the triangulated vertices and reassign a single color to each vertex color, fill the synthesized triangle with vertex colors, and then test the synthesized image or compare the synthesized image to the original image and/or the previously generated image.
Fig. 1 is a block diagram illustrating a data flow according to an example embodiment. As shown in fig. 1, an image 105 with data (e.g., pixel location and color information) is input to a pixel mapping and triangulation process 110. In the pixel mapping and triangulation process 110, vertices are generated/identified based on pixel locations and positioned on an mxm mesh. Each vertex is assigned a color, and each triangle is colored based on the color assigned to the corresponding vertex. Then, a new image is generated using the triangle. The new image is tested (115) and encoded (120) if the new image meets a predetermined criterion. If the new image does not meet the predetermined criteria, the new image is reprocessed in the pixel mapping and triangulation process 110. Reprocessing can include adding vertices, subtracting vertices, changing colors, adding colors, and/or the like. The pixel mapping and triangulation process 110 and the test 115 can be repeated until the generated image meets at least one predetermined criterion.
Fig. 2 illustrates a block diagram of an encoder system in accordance with at least one example embodiment. As shown in fig. 2, encoder system 205 includes pixel grid generator 215, color module 220, color table 225, triangulation module 230, image generator 235, test module 240, and compression module 245.
Encoder system 205 is capable of receiving image 210 and generating compressed image file 250. Image 210 can include image data (e.g., image size (e.g., x-size and y-size and/or grid size), number of pixels, pixel location, pixel color, pixel texture, and the like). Compressed image file 250 can include compressed data corresponding to image 210. The compressed data corresponding to image 210 can be used to generate a reconstructed image corresponding to image 210. Thus, the compressed image file 250 can include a grid of pixels, a color table, compressed data corresponding to triangulation vertices, and/or the like (preferably wherein one or more have been compressed to a lesser or minimum number of bits).
Pixel grid generator 215 is capable of receiving image 210. In one exemplary embodiment, the image 210 is a small image (e.g., thumbnail) of size n×n (e.g., 221×221). An image of size N x N (and/or N1 x N2, where N1 is different from N2) can be associated with an N x N grid comprising N columns and N rows. The location on the nxn grid can be at each block of the nxn grid. The blocks can be located at intersections of rows and columns of an nxn grid. The pixel grid generator 215 can include (generate and/or use) a predetermined mxm (and/or m1×m2, where M1 is different from M2) grid. The mxm grid can include M columns and M rows. The location on the mxm grid can be at each block of the mxm grid. The blocks can be located at intersections of rows and columns of an mxm grid.
In some embodiments, M < < N. Thus, the mxm mesh can be much smaller than the nxn mesh. For example, M can be 2 to 20 times smaller than N. Accordingly, mxm can be 4 to 400 times smaller than nxn. However, the size of the mxm mesh can be the same as, smaller than, or larger than the size of the nxn mesh. In some implementations, the mxm mesh can be predetermined based on a target number of bytes (e.g., 200 bytes). In some implementations, the mxm mesh can be predetermined based on parameters for adjusting the compression rate (e.g., input to the encoder system 205).
The pixel grid generator 215 can be further configured to assign a plurality of points to respective locations on the mxm grid (the locations on the mxm grid may be, for example, the center of the block as described above, locations (X, Y) that can be located at intersections of four blocks along a straight line that can be shared by the two blocks, and/or the like). In other words, a plurality of locations are selected or identified in the mxm grid, and these selected/identified locations can be referred to as points. The point(s) assigned to a location on the mxm mesh can be referred to as a point, a plurality of points, and/or a point on the mxm mesh. In a subsequent operation (e.g., triangulation), the points can become vertices of triangles. The pixel grid generator 215 can be further configured to map pixels of the image 210 to points on an mxm grid. For example, if the size of the mxm mesh is smaller than the size of the nxn mesh (corresponding to the image 210), mapping pixels of the image 210 to points on the mxm mesh can include mapping a subset of pixels of the image 210 (e.g., based on location proximity) to points on the mxm mesh.
The color module 220 can be configured to assign a color to each of the points on the mxm grid based on the color of the corresponding pixel in the image 210. The color can be selected from the color table 225. The color table 225 can include a color map including a limited number of colors. For example, the color table 225 can include a color map having 8 to 16 colors. In addition, each of the colors of the pixels of the image 210 can be mapped to one of 8 to 16 colors of the color map.
The triangulation module 230 can be configured to triangulate points on the mxm mesh. In other words, the triangulation module 230 can be configured to generate (or identify or determine) a plurality of triangles using points on the mxm mesh as vertices of the triangles. For example, delaunay triangulation techniques can be used. Using the Delaunay triangulation technique, each triangle generated by the triangulation module 230 does not include any other points within the generated triangle, and the sides or edges of one triangle do not intersect the vertices of the other triangle. Thus, each point corresponding to a pixel is used as a vertex in at least one triangle. Other triangulation techniques are also possible. For example, some triangulation techniques can include at least one point within the generated triangle. These techniques ignore these inliers in subsequent processing.
The image generator 235 can be configured to generate (or render) an image using triangulation and colors assigned to vertices via corresponding points on an mxm mesh. Generating an image can include filling in colors or rendering (hereinafter referred to as rendering, being rendered, or drawing) each triangle generated by the triangulation module 230 based on the colors assigned to each vertex of the triangle. The generated image can be smaller (e.g., fewer bytes to be stored, fewer columns and/or rows) than the image 210. In other words, the generated image can be m×m. The generated image can be completely covered by triangles (e.g., any area of the mxm mesh does not include open space or space within one of the triangles).
In some embodiments, at least one triangle can have vertices with different colors. For example, two vertices of a triangle can be assigned a green color via corresponding points on an mxm mesh, while a third vertex is assigned a blue color via corresponding points on the mxm mesh. Accordingly, triangles can be drawn using interpolation (e.g., linear interpolation) techniques. In other words, triangles can be drawn with varying or mixed colors. For example, the center of the triangle may be drawn as green/blue and as blue when approaching a blue vertex and as green when approaching a green vertex. In addition to linear interpolation, in some embodiments, many other color interpolation methods can be used to draw triangles (e.g., cubic interpolation, complex quadratic interpolation, quintic interpolation).
The images generated by the image generator 235 may then be tested by the test module 240. In one or more embodiments, an image quality test can be performed. For example, a peak signal-to-noise ratio (PSNR) test and/or a Structural Similarity Index (SSIM) test between images can be performed. The PSNR and SSIM can be used to compare the image generated by the image generator 235 with the image 210 and/or the saved image previously generated by the image generator 235. Additionally or alternatively, in some implementations, the size (e.g., number of bytes) of the image generated by the image generator 235 can be compared to a threshold (e.g., maximum and/or minimum number of bytes). In an exemplary embodiment, if the PSNR and/or SSIM is above a threshold, the PSNR and/or SSIM passes the test as compared to the image 210 and/or a previously generated image.
In other words, the image generated by the image generator 235 can be tested by the test module 240 to determine if the image meets at least one predetermined criterion. The criterion can be based on image quality and/or image size. If the image generated by the image generator 235 meets at least one criterion, processing continues to the compression module 245. Otherwise, processing returns to triangulation module 230.
In some implementations, the mxm mesh, which is adjusted using a fixed size or parameter, is initialized with an overcomplete set of vertices by the first iteration of the triangulation module 230, the image generator 235, and the test module 240. The number of vertices can then be pruned into a smaller set of vertices until the set of vertices and the color information can match a threshold number of bytes (e.g., 200 bytes).
In such an embodiment, the triangulation module 230 can be configured to select vertices to remove and remove the vertices from the set of vertices. In other words, one of the points associated with the above pixel is removed and is no longer used as a vertex.
In some implementations, the first iteration through the triangulation module 230, the image generator 235, and the test module 240 is initialized with the set of vertices that have been minimized or reduced using a greedy algorithm (described in detail below). Then, the vertex set can be abrupt (described in detail below) until it results in a generated image having an optimal or target quality versus size. An optimal quality versus size relationship can be achieved when abrupt vertices do not result in a measurable quality difference between iterations and/or a negligible decrease in the number of bytes of vertex set and color information.
The triangulation module 230 can then regenerate the plurality of triangles using one of the techniques described above. The regenerated plurality of triangles can be used by the image generator 235 to generate another image, which is then tested by the test module 240.
The compression module 245 can be configured to compress one or more of the vertices (including vertex positions and colors in the mxm mesh), the color table 225, and/or the mxm mesh generated by the triangulation module 230. Compression module 245 can use any of a variety of compression techniques. However, in some embodiments, compression module 245 can use asymmetric digital system (ANS) technology, which is described in detail below.
The method steps described with respect to fig. 3 and 4 may be performed as software code stored in a memory (e.g., the at least one memory 810) associated with an encoder system (e.g., as shown in fig. 1,2, and 8) and by at least one processor (e.g., the processor 805) associated with the encoder system. For example, the memory can be a non-transitory computer-readable storage medium having stored thereon instructions as computer-executable program code that, when executed on a computer system, cause the computer system to perform the steps described below with respect to fig. 3 and 4. Alternative implementations are contemplated such as an encoder embodied as a special purpose processor.
For example, the method steps may be performed by an application specific integrated circuit or ASIC. For example, the ASIC may be configured as the encoder system 205 and/or the controller 820. Although the steps described below are described as being performed by a processor, the steps need not be performed by the same processor. In other words, at least one processor may perform the steps described below with respect to fig. 3 and 4.
Fig. 3 illustrates a method for generating a triangulation image according to at least one exemplary embodiment. As shown in fig. 3, in step S305, an image is received. For example, the image (e.g., image 210) can be a small image (e.g., thumbnail) of size n×n (e.g., 221×221). The image can include image data (e.g., image size (e.g., x-size and y-size and/or grid size)), number of pixels, pixel location, pixel color, pixel texture, and the like.
In step S310, an mxm mesh is generated. For example, the mxm mesh can be a predetermined mesh having a fixed size within an encoder system (e.g., encoder system 205). The size of the mxm mesh can be the same as, smaller than, or larger than the size of the nxn mesh. In some implementations, the mxm mesh can be predetermined based on a target number of bytes (e.g., 200 bytes). In some implementations, the mxm mesh can be predetermined based on encoder parameters (e.g., inputs to the encoder system 205) for adjusting the compression rate. An mxm grid can have M columns and M rows so that a minimum amount of compression can be achieved.
In step S315, a set of positions (P) on the mxm grid is assigned to a corresponding pixel of the image. For example, pixels of a received image (e.g., image 210) can be mapped to corresponding locations on an mxm grid. The locations on the mxm mesh are hereinafter referred to as points or points on the mxm mesh. For example, if the size of the mxm mesh is smaller than the size of the nxn mesh (corresponding to the image), mapping the pixels of the image 210 to the points on the mxm mesh can include mapping a subset of the pixels of the image 210 to the points on the mxm mesh. In some embodiments, an initial allocation of locations can be pre-allocated. In some embodiments, the initial allocation of locations can be randomly allocated. In some embodiments, an initial allocation of locations can be allocated such that the points are evenly distributed within the mxm grid.
In step S320, the color (C) of the allocated point (P) is selected based on the corresponding pixel. For example, each point on the mxm grid can be assigned a color based on the color of the corresponding pixel in the received image. The color can be selected from a color table. The color table can include a limited number of colors. For example, the color table can include 8 to 16 colors. In addition, each of the colors of the pixels of the image can be mapped to one of 8 to 16 colors of the color table, and the mapped colors can be assigned to corresponding points on the mxm mesh.
In step S325, triangulation is performed for each P. For example, delaunay triangulation techniques can be used. Using the Delaunay triangulation technique, each triangle generated by the triangulation module 230 does not include any other points within the generated triangle, and the sides or edges of one triangle do not intersect the vertices of the other triangle. Thus, each point corresponding to a pixel is used as a vertex in at least one triangle. Other triangulation techniques are also possible. For example, some triangulation techniques can include at least one point within the generated triangle. These techniques ignore these inliers in subsequent processing.
In step S330, an image is generated based on P and C. In other words, an image can be generated (or rendered) based on the triangle and the colors assigned to the vertices via the corresponding points on the mxm mesh. Generating the image can include drawing each triangle generated by the triangulation module 230 based on the color assigned to each vertex of the triangle.
In some embodiments, at least one triangle can have vertices with different colors. For example, two vertices of a triangle can be assigned a green color via corresponding points on an mxm mesh, while a third vertex is assigned a blue color via corresponding points on the mxm mesh. Accordingly, triangles can be drawn using interpolation (e.g., linear interpolation) techniques. In other words, triangles can be drawn with varying or mixed colors. For example, the center of the triangle may be drawn as green/blue and as blue when approaching a blue vertex and as green when approaching a green vertex. In addition to linear interpolation, in some embodiments, many other color interpolation methods can be used to draw triangles (e.g., cubic interpolation, complex quadratic interpolation, quintic interpolation).
In step S335, it is determined whether the generated image satisfies at least one condition. For example, an image quality test can be performed. Thus, an image can be tested to determine whether the image meets at least one predetermined criterion. The at least one criterion can be based on image quality and/or image size. For example, a peak signal-to-noise ratio (PSNR) test and/or a Structural Similarity Index (SSIM) test between images can be performed. The PSNR and SSIM can be used to compare the image with the received image (e.g., image 210) and/or saved images generated during previous iterations. Additionally or alternatively, in some implementations, the size of the image (e.g., number of bytes) can be compared to a threshold (e.g., maximum and/or minimum number of bytes).
If the generated image passes the test, the process proceeds to step S340. Otherwise, the process proceeds to step S345. In step S340, other processing is performed. For example, one or more of the vertices (including location and color), color tables, and/or mxm mesh can be compressed.
In step S345, a vertex to be removed is selected. For example, the least significant vertex can be determined. In some implementations, for triangles used to generate an image, the least significant vertices have the least error in the vertex set. For example, PSNR and SSIM can calculate an error (e.g., an amount of noise) for each vertex. The vertex with the lowest error calculated during the PSNR test or SSIM test can be determined as the least significant vertex and selected as the vertex to be removed.
In step S350, the selected vertex is deleted. For example, the selected vertex is removed from the vertex set. In other words, the points are removed from the positions on the mxm grid. Then, the process returns to step S325. In some implementations, the process can return to step S325 in order to perform the least or most number of iterations (e.g., processing loops).
In some implementations, the colors in the color table are based on image features. In the embodiment described above with respect to fig. 3, the colors in the color table may be selected once and may not be suitable. Additionally, any modification in the iteration is to remove vertices that may not be added back or moved slightly to find the better triangle combination. Again, greedy selection using the received image (e.g., image 210) as a baseline resulting in modification of each proposed vertex (or set of vertices) may limit local search results when high performance areas are found.
Accordingly, in some embodiments, a random variation can be implemented. This may include techniques that utilize random heuristic searches such as hill climbing algorithms, evolutionary algorithms, and/or simulated annealing algorithms to search for discrete non-micro optimizable landscapes. For example, a random hill climbing algorithm can allow some embodiments to explore the search space of an image and to tailor the color settings (e.g., of a color table).
In addition, as described above, at least one of a plurality of operations other than or in addition to the vertex removal operation can also be used. It should be noted that in some embodiments, the color is modified, whereas in the method described with respect to fig. 3, no color modification has been made. In addition, vertices can be added (even if they have been previously removed) if they are found to improve the result. The vertices can also be locally moved to nearby grid points. Instead of removing vertices until the desired byte size is reached, accepting a move can be based on whether the move would improve the quality versus size relationship. In addition, the random implementation can be initialized with a smaller set of vertices (described with respect to fig. 4) than the method described with respect to fig. 3. As described above, the vertices can be on a predetermined mesh.
Fig. 4 illustrates a method for generating a triangulation image according to at least one exemplary embodiment. As shown in fig. 4, in step S405, an image is received. For example, the image can be received as input to a batch encoding routine. For example, the image (e.g., image 210) can be a small image (e.g., thumbnail) of size n×n (e.g., 221×221). The image can include image data (e.g., image size (e.g., x-size and y-size and/or grid size)), number of pixels, pixel location, pixel color, pixel texture, and the like.
In step S410, an mxm mesh is generated. In some embodiments, M < < N. Thus, the mxm mesh can be much smaller than the nxn mesh. For example, M can be 2 to 20 times smaller than N. Accordingly, mxm can be 4 to 400 times smaller than nxn. However, the size of the mxm mesh can be the same as, smaller than, or larger than the size of the nxn mesh. In some implementations, the mxm mesh can be predetermined based on a target number of bytes (e.g., 200 bytes). In some implementations, the mxm mesh can be predetermined based on parameters for adjusting the compression rate (e.g., input to the encoder system 205).
Generating the mxm mesh can include inserting points into positions on the mxm mesh. In some implementations, a greedy algorithm can be used to minimize or reduce the set of points. In one exemplary embodiment, a threshold number of points can be inserted into locations on an mxm grid. In some implementations, the threshold number of points is much less than the number of pixels in the received image. For example, M can be equal to 20. Thus, an mxm grid can include 400 locations. Accordingly, the threshold number of points can be 400 points at maximum. The 400 points are much less than the number of pixels in the received image (e.g., about 50000 pixels in the thumbnail). In addition, the threshold number of points can be less than the number of locations on the mxm grid. For example, the threshold number of points can be set to 300, which is less than 400 locations.
In one exemplary embodiment, a threshold number of points can be randomly inserted into positions on an mxm grid, the points can be assigned a color based on a pixel color of the received image, the pixel being at approximately the same position in the image as the assigned color point, an image is generated (or rendered) using the plurality of points of the mxm grid, and the generated image is compared to the received image. If the comparison (e.g., PSNR) results in a quality equal to or less than the threshold quality difference where the location of the point on the MxM grid is acceptable, and processing continues. If the comparison (e.g., PSNR) results in a quality greater than the threshold quality difference, then a threshold number of points can be repositioned on the M grid, and the process repeated until the generated image is within the threshold quality difference.
In another embodiment, pixels can be removed from the received image until a threshold number of pixels remain. Each time a pixel (or pixels) is removed, the received image can be compared to the modified image. If the comparison (e.g., PSNR) results in a quality equal to or less than the threshold quality difference, iteration is continued, otherwise pixels are added back and other pixels are removed. The process can be repeated until the modified image includes a threshold number of pixels or less. The modified image can be used to insert points on an mxm grid and assign pixels to the points.
In step S415, a set including positions (P) of points on the mxm mesh is assigned to corresponding pixels of the image. For example, pixels of a received image (e.g., image 210) can be mapped to locations on an mxm grid. If points have been assigned to positions, the positions on the M grid are hereinafter referred to as points or points on the M grid.
In step S420, the color (C) of the allocated point (P) is selected based on the corresponding pixel. For example, each point on the mxm grid can be assigned a color based on the color of the corresponding pixel, pixel cluster, and/or center of the pixel cluster in the received image. The color can be selected from a color table. A color table can be generated based on the received image. For example, searching for a received image returns colors that frequently appear in the received image. The color table should include a limited number of colors. For example, the color table should initially include 8 colors. Therefore, colors frequently appearing in the received image can be aggregated or mapped to 8 colors so as to be included in the color table. In addition, each of the colors of the pixels of the image can be mapped to one of 8 colors of the color table, and the mapped colors can be assigned to corresponding points on the mxm mesh. As described above, the colors to be included in the color table can be determined using a random hill climbing technique.
In step S425, triangulation is performed for each P. For example, delaunay triangulation techniques can be used. Using the Delaunay triangulation technique, each triangle generated by the triangulation module 230 does not include any other points within the generated triangle, and the sides or edges of one triangle do not intersect the vertices of the other triangle. Thus, each point corresponding to a pixel is used as a vertex in at least one triangle. Other triangulation techniques are also possible. For example, some triangulation techniques can include at least one point within the generated triangle. These techniques ignore these inliers in subsequent processing.
In step S430, an image is generated based on P and C. In other words, an image can be generated (or rendered) based on the triangle and the color assigned to each vertex via the corresponding point on the mxm mesh. Generating the image can include drawing the triangle generated by the triangulation module 230 based on the colors assigned to each vertex of the triangle.
In some embodiments, at least one triangle can have vertices with different colors. For example, two vertices of a triangle can be assigned a green color via corresponding points on an mxm mesh, while a third vertex is assigned a blue color via corresponding points on the mxm mesh. Accordingly, triangles can be drawn using interpolation (e.g., linear interpolation) techniques. In other words, triangles can be drawn with varying or mixed colors. For example, the center of the triangle may be drawn green/blue and more blue when approaching the blue vertex and more green when approaching the green vertex. In addition to linear interpolation, in some embodiments, many other color interpolation methods can be used to draw triangles (e.g., cubic interpolation, complex quadratic interpolation, quintic interpolation).
In step S435, it may be determined whether the generated image satisfies at least one condition. For example, an image quality test can be performed. Thus, the generated image can be tested to determine whether the generated image meets at least one predetermined criterion. The at least one criterion can be based on image quality, image quality error, and/or image size. For example, peak signal-to-noise ratio (PSNR) and/or Structural Similarity Index (SSIM) tests between images can be performed. The PSNR and SSIM can be used to compare the generated image with the received image (e.g., image 210) and/or saved images generated during previous iterations. Additionally or alternatively, in some implementations, the size of the image (e.g., number of bytes) can be compared to a threshold (e.g., maximum size (e.g., number of bytes) and/or minimum size (e.g., number of bytes)).
If the generated image passes the test, the process proceeds to step S440. Otherwise, the process proceeds to step S445. In step S440, other processing is performed. For example, one or more of the vertices (including locations and colors within the mxm mesh), the color table, and/or the mxm mesh can be compressed.
In step S445, the point set and/or the point color are mutated. In other words, the vertices of the triangle can be modified. This may be achieved in a number of ways, for example at least one of the following: (a) Being able to shift vertices-shifting vertices includes moving vertices horizontally or vertically by one grid position; (b) Adding vertices can include adding points on the mxm mesh at random (unoccupied) locations on the mxm mesh (in some embodiments, colors assigned to adjacent points or closest points can be assigned to the added vertices); (c) vertex can be removed. Shifted or removed vertices may be the least significant vertices. Additionally or alternatively, in some embodiments, random vertices may be removed or shifted.
The mutation of the spot color may include one or more of the following: (a) The colors of the dots can be reassigned (vertices are generated) -any of the colors in the color table can be used to randomly reassign the colors; (b) capable of adding a color to the color table; (c) Colors can be removed from the color table-in some embodiments, if colors are assigned to less than a threshold number of points, colors in the color table can be removed; (d) Color capable of modifying a color table-modifying a color can include changing its color value by a number (e.g., by adding or subtracting one from the color value).
The mutation type determination may be iterated. In other words, vertices are added first, then shifted, then color reassigned, and so on (this order is merely an example, any order is within the scope of the present disclosure). Mutation type determination can be learned. For example, when mutation is performed, optimal mutation (or mutation order) can be learned. In other words, the system is able to learn that shifting vertices may be more efficient than removing vertices for an image (or images).
In some embodiments, the modification can be performed more than twice. In addition, the modification can be selected based on the probability of success. For example, an algorithm can be used to determine the success probability. The algorithm can be based on historical data (e.g., indicating that shifted vertices are most likely to produce improvement) and/or prior modifications (e.g., after horizontally shifting vertices, vertically shifting vertices are most likely to produce improvement). In some implementations, more than two vertices of a triangle can be modified. For example, the set of adjacent vertices can be modified, the set of vertices in the region can be modified, the set of vertices of the same color can be modified, and/or the like. In some implementations, more than two vertices of a triangle can be modified sequentially. For example, vertices in the horizontal direction can be modified from left to right in sequential iterations.
Although fig. 4 shows the process returning to step S425, other options are within the scope of the present disclosure. For example, if only the color is modified, the process can return to step S430. For example, if the current iteration is the second or subsequent iteration and the mutation does not result in improved results (e.g., reduced error and/or size), the mutation can be discarded and step S445 can be repeated from the previous iteration.
Returning to fig. 2, the compression module 245 can be configured to compress the triangulation data and generate a compressed image file 250. For example, the compressed image file can include a header containing basic parameters such as mesh size (e.g., m×m mesh) and the number of vertices, and a color table. In some implementations, the color table can be compressed (e.g., lossless compressed) using an Asymmetric Numerical System (ANS) technique.
In some implementations, the color table entries can be ordered by frequency of use (from the most common start). After sorting, the color table can be compressed by providing the number of colors, the (quantized) color channel value and/or the frequency of use of each entry. In some implementations, the color channel value can be encoded as a correction to the average of the previous transmitted values from that channel (e.g., red channel), with the prediction of the first entry set to neutral gray.
In some implementations, a histogram table for these color differences can be included in the header. In some implementations, the color entry frequency can be stored using a binomial distribution model. Such an embodiment is therefore capable of providing a color and vertex (i.e.,Wherein/>Is the number of remaining top points not counted by the previous color entry, and p=1/C r, where C r is the remaining color table entry) uses a fair selection model. In some embodiments, because the color table can be ordered by frequency, the embodiment can be implemented by limiting the distribution values considered to at least/>The probability model is refined (based on knowing that subsequent entries have been ordered) and the frequency count of at least previous entries (based on knowing that previous entries and current entries have been ordered). In some embodiments, this approach can save a significant amount of file size on average by using this embodiment to encode the color entry frequencies, as compared to using a simple equal probability distribution model.
In some implementations, triangulation can be compressed (e.g., lossless compression) using Asymmetric Numerical Systems (ANS) techniques to compress vertex positions and/or their color assignments. In some implementations, for a vertex position, one bit (not arithmetically coded) for each position on the mxm mesh can be used to indicate whether the position is used as a vertex (e.g., whether a point is at the position). In some implementations, this can use N g bits, where N g is the number of positions on the mxm grid and corresponds to using an occupancy probability of 0.5. In some implementations, the technique can use a fixed occupancy probability as p=v t/Ng, where V t is the total number of vertices (which can be included in the header).
In some embodiments, run-length codes (coding the run-length of unoccupied mesh locations between vertices) can be used. A distribution of run lengths can be included in the header, resulting in additional overhead (e.g., compressed image file 250 may be larger than expected). In some implementations, the compression of triangulation can use adaptive probability techniques to compress the occupancy map. In some implementations, the probability model can be updated as progress through the mesh such that the probability model is p=v r/Nr at each position of the mxm mesh, where V r and N r are the remaining vertex and mesh point counts, respectively. In some implementations, this can provide compression for triangulation far beyond single bit per lattice technique.
In some implementations, the color table index (for each vertex or point on an mxm mesh) can be compressed (e.g., losslessly compressed) using an Asymmetric Numerical System (ANS) technique. For example, color entry frequencies can be used, and adaptive models for these indices can be used. The color index can be compressed into a boolean value encoding chain. The technique includes identifying each color index using a probability indicated by a remaining count probability of the corresponding color table entry. Further, the coding order for each color index can be set by spatial adaptive prediction.
In some embodiments, the technique can provide assistance even without altering any model probabilities, as once the true boolean value is identified, encoding of that vertex can be terminated and moved to the next vertex. In some implementations, the encoding order can be determined by ordering the colors previously seen (and already included in the compressed image file 250) based on the colors of the Manhattan distance to the current vertex. The relationship (e.g., same manhattan distance) breaks down and instead is a more probable color. In some implementations, using this ordering results in a significant reduction in file size (e.g., compressed image file 250) used to store the color table frequencies. In some implementations, using spatially adaptive ordering can provide additional file size reduction.
In some implementations, the Delaunay triangulation can be recreated for client-side decoding. In some embodiments, each triangle is then separately colored by a linear combination of its three vertices. In addition to linear interpolation, in some embodiments, many other color interpolation methods can be used to draw triangles (e.g., cubic interpolation, complex quadratic interpolation, quintic interpolation).
Fig. 5 illustrates a decoder system in accordance with at least one example embodiment. As shown in fig. 5, decoder system 505 includes a color table decompression module 515, a color table index decompression module 520, a triangulation decompression module 525, a mesh generator 530, a color module 535, a color table 540, a triangulation module 545, and an image generator 550. The decoder system 505 can be configured to receive the compressed image file 250 and generate a reconstructed image 510. Although the color table decompression module 515, the color table index decompression module 520, and the triangulation decompression module 525 are illustrated as separate modules, the color table decompression module 515, the color table index decompression module 520, and/or the triangulation decompression module 525 can be combined into a common or single decompression module.
Color table decompression module 515 is configured to decompress the compressed color table read from compressed image file 250 and generate color table 540. Decompressing the compressed color table can include performing an inverse operation on the technique used by the compression module 245 to compress the color table 225. For example, the color table can be dequantized and the color channel values can be regenerated based on the previous color entry in which the first entry was predicted using neutral gray. Additionally or alternatively, the color table decompression module 515 can extract color frequency information from the compressed image file 250 and include the color frequency information in the color table 405. The color frequency information can be extracted using an equal probability model and/or a distribution model.
Color table index decompression module 520 is configured to decompress the compressed color table index file read from compressed image file 250 and communicate the color index table to grid generator 530. Decompressing the compressed color table can include performing an inverse operation on the technique used by the compression module 245 to compress the color table index. Color table index decompression module 520 can use boolean value decoding chain techniques to decompress the color index table. The technique includes identifying each color index using a probability indicated by a remaining count probability of the corresponding color table entry. Additionally or alternatively, the order in which each color index is decoded can be set by spatial adaptive prediction.
The triangulation decompression module 525 is configured to decompress the triangulation file read from the compressed image file 250 and communicate the triangulation file to the mesh generator 530. Decompressing the compressed triangulation file can include performing an inverse operation on the technique used by the compression module 245 to compress the triangulation file. For example, the triangle dissection decomposition compression module 525 can read the number of vertices, the mesh size, and the probabilistic model from the header. The probability model can indicate a likelihood that a location in the mesh includes a vertex and whether the first mesh location includes a vertex. When a location includes (or does not include) a vertex, the probability that the next point does not include (or includes) increases.
The mesh generator 530 is configured to generate an mxm mesh based on the mesh size read from the header. The mesh generator 530 is further configured to allocate points at each location in the mxm mesh that is occupied (e.g., includes vertices) based on the decompressed triangulation file. Grid generator 530 is further configured to assign a color index value to each of the points.
The color module 535 is configured to assign a color to each of the points based on the color index value. For example, the color index value can be used to look up the color in the color table 540. The returned color (or the value used to render the color) is assigned to the corresponding point.
The triangulation module 545 can be configured to generate a plurality of triangles (e.g., as described above) using points on an mxm mesh as vertices of the triangles. For example, delaunay triangulation techniques can be used. Using the Delaunay triangulation technique, each triangle generated by the triangulation module 545 does not include any other points within the generated triangle, and the sides or edges of one triangle do not intersect the vertices of the other triangle. Thus, each point corresponding to a pixel is used as a vertex in at least one triangle. Other triangulation techniques are also possible. For example, some triangulation techniques can include at least one point within the generated triangle. These techniques ignore these inliers in subsequent processing.
Image generator 550 can be configured to generate reconstructed image 510. In other words, the image generator 550 can be configured to generate (or render) an image using triangulation and colors assigned to vertices via corresponding points on the mxm mesh. Generating the image can include drawing each triangle generated by the triangulation module 545 based on the color assigned to each vertex of the triangle.
In some embodiments, at least one triangle can have vertices with different colors. For example, two vertices of a triangle can be assigned a green color via corresponding points on an mxm mesh, while a third vertex is assigned a blue color via corresponding points on the mxm mesh. Accordingly, triangles can be drawn using interpolation (e.g., linear interpolation) techniques. In other words, triangles can be drawn with varying or mixed colors. For example, the center of the triangle may be drawn green/blue and more blue when approaching the blue vertex and more green when approaching the green vertex. In addition to linear interpolation, in some embodiments, many other color interpolation methods can be used to draw triangles (e.g., cubic interpolation, complex quadratic interpolation, quintic interpolation).
The method steps described with respect to fig. 6 may be performed as software code stored in a memory (e.g., the at least one memory 910) associated with a decoder system (e.g., as shown in fig. 7 and 9) and by at least one processor (e.g., the processor 905) associated with the decoder system. For example, the memory can be a non-transitory computer-readable storage medium having stored thereon instructions as computer-executable program code that, when executed on a computer system, cause the computer system to perform the steps described below with respect to fig. 6. Alternative implementations are contemplated such as a decoder embodied as a special purpose processor.
For example, the method steps may be performed by an application specific integrated circuit or ASIC. For example, an ASIC may be configured as the decoder system 505 and/or the controller 920. Although the steps described below are described as being performed by a processor, the steps need not be performed by the same processor. In other words, at least one processor may perform the steps described below with respect to fig. 6.
Fig. 6 illustrates a method for decoding image data and generating a reconstructed image in accordance with at least one example embodiment. As shown in fig. 6, in step S605, a file including compressed image data (e.g., compressed image file 250) is received. For example, in response to a request from a mobile device (or other computing device), the file can be received via a communication network (e.g., the internet).
In step S610, the compressed image data is decompressed. For example, the file can include multiple types of compressed image data. The type of compressed image data can include at least one of a compressed color table, compressed triangulation (including the location of triangle vertices and color assignment), and a compressed color table index.
Decompressing the compressed color table can include performing an inverse operation on the technique used to compress the color table. For example, the color table can be dequantized and the color channel values can be regenerated based on the previous color entry in which the first entry was predicted using neutral gray. Decompressing the compressed color table can include performing an inverse operation on the technique used to compress the color table index. The color index table can be decompressed using boolean value decoding chain techniques. The technique includes identifying each color index using a probability indicated by a remaining count probability of the corresponding color table entry. Further, the order of decoding each color index can be set by spatial adaptive prediction.
Decompressing the compressed triangulation file can include performing an inverse operation on the technique used to compress the triangulation file. For example, the number of top points, the mesh size, and the probability model can be read from the header of a file including compressed image data. The probability model can indicate a likelihood that a location in the mesh includes a vertex and whether the first mesh location includes a vertex. When a location includes (or does not include) a vertex, the probability that the next point does not include (or includes) increases.
In step S615, an mxm mesh is generated. For example, an mxm mesh can be generated based on the mesh size read from the header. Generating the mxm mesh can include assigning points at each location in the mxm mesh that is occupied (e.g., includes vertices) based on the decompressed triangulation file. Generating the mxm mesh can include assigning a color index value to each of the points.
In step S620, points are assigned to a plurality of positions (P) on the mxm mesh. For example, points can be assigned to each location in the mxm mesh that is occupied (e.g., includes vertices) based on the decompressed triangulation file. Generating the mxm mesh can include assigning a color index value to each of the points.
In step S625, a color index value is assigned to each of the assigned points. For example, a color index value can be assigned to each point of the mxm mesh based on the decompressed triangulation file and/or the decompressed color table index.
In step S630, colors are mapped to each of the assigned points based on the associated color index values. For example, the color index value can be used to look up the color in the decompressed color table. The returned color (or the value used to render the color) is assigned to the corresponding point.
In step S635, each point of the mxm mesh is triangulated. For example, delaunay triangulation techniques can be used. Using the Delaunay triangulation technique, each triangle generated by the triangulation module 230 does not include any other points within the generated triangle, and the sides or edges of one triangle do not intersect the vertices of the other triangle. Thus, each point corresponding to a pixel is used as a vertex in at least one triangle. Other triangulation techniques are also possible. For example, some triangulation techniques can include at least one point within the generated triangle. These techniques ignore these inliers in subsequent processing.
In step S640, a reconstructed image is generated. In other words, the image (e.g., reconstructed image 510) can be rendered based on the triangle and vertex colors. For example, generating the reconstructed image can include drawing each triangle generated by the triangulation process based on the color assigned to each point corresponding to the vertex of the triangle.
In some embodiments, at least one triangle can have vertices with different colors. For example, two vertices of a triangle can be assigned a green color via corresponding points on an mxm mesh, while a third vertex is assigned a blue color via corresponding points on the mxm mesh. Accordingly, triangles can be drawn using interpolation (e.g., linear interpolation) techniques. In other words, triangles can be drawn with varying or mixed colors. For example, the center of the triangle may be drawn green/blue and more blue when approaching the blue vertex and more green when approaching the green vertex. In addition to linear interpolation, in some embodiments, many other color interpolation methods can be used to draw triangles (e.g., cubic interpolation, complex quadratic interpolation, quintic interpolation).
In some implementations, the reconstructed image (e.g., reconstructed image 510) can include jagged edges in some portion of the image. In addition, the reconstructed image can include straight line discontinuities that may be caused by triangle boundaries. In some embodiments, jagged edges and discontinuities may be prevalent in the edges of the first reconstructed image. In some implementations, each triangle is drawn using the color of its own vertex. However, vertices of nearby triangles may include valuable information, for example, when the vertices are assigned the same (or nearly the same) color. In some implementations, for example, in the second reconstructed image, the triangle may include shading differences. In some implementations, it may be desirable to use such consistency information on triangles to re-render the reconstructed image.
In some implementations, a deep neural network can be used to implicitly create rules based on image statistics to address jagged and intermittent edges of reconstructed images. In some embodiments, to train the deep neural network, the same inputs can be used as the triangulation used to create the reconstructed image. In some implementations, for the target output, the original image can be used. In some implementations, training can include using a training set from Imagenet.
In some embodiments, various deep convolutional networks can be used in object detection and recognition, the end result of which may be classification. In some implementations, sparse input can be used to generate a complete image. This can be expressed or referred to as an image conversion task. In some embodiments, the result of object detection and recognition may be a complete image. Thus, details can be recreated from the input, while allowing non-spatial local effects to direct larger features and implement global consistency. In some implementations, both details from the original image and potential global coordination of the generated image are required to derive various thin-thick-thin frameworks such as hourglass and u-net. In some embodiments, these architectures pass the input through a series of convolution layers that progressively downsample the image. After the minimum layer is reached, the process can be inverted and the image can be expanded to the desired size.
In some embodiments, the input can consist of 8 channels, including an edge image-a binary image showing the edge created by Delaunay triangulation, a binary vertex present image, an image that is the result of linear interpolation, and/or an RGB color vertex image. In some implementations, this can indicate the color assigned to each vertex (black elsewhere).
Fig. 7 illustrates a stacked hourglass network including intermediate losses in accordance with at least one example embodiment. As shown in fig. 7, conv2d (size=7x7, filter=256, stride=2) can be applied to 256×256×8 inputs, and then Conv2d (3×3, f256, s 2) can be applied to 64×64×256 sizes. This feeds an hourglass with Depth-ToSpace (2 x 2) for up-sampling. The output of the first "hourglass" is then appended to the input of the next "hourglass". The input can be represented as a 256 x 256 image, with 8 channels, and a batch size of 32. The output can be an RGB image of the same resolution.
In one exemplary embodiment, the reconstructed image (e.g., reconstructed image 510) generated using the triangulation techniques described above can be improved (e.g., with higher quality, lower noise, and/or less error) and/or converted to a complete image (e.g., larger size, more pixels, and/or higher resolution). Accordingly, the size of the reconstructed image can be adjusted to 256×256 images using linear interpolation. As described above, the input to a deep convolutional network (e.g., the stacked hourglass network of fig. 7) can include 8 channels. The resized reconstructed image can be used as an input to the channels 3-5 of the deep convolutional network. The triangulation data (e.g., as generated by the triangulation module 545) can include an edge map that can be used as an input to channel 1 of the deep convolutional network. The triangulation data (e.g., as generated by the triangulation module 545) can include a vertex position map that can be used as an input to channel 2 of the deep convolutional network. Finally, the triangulation data (e.g., as generated by the triangulation module 545) can include vertex color data, which can be used as input to the channels 6-8 of the deep convolutional network. After performing the deep convolutional network, an RGB image based on the reconstructed image (e.g., reconstructed image 510) is output. The RGB image can have a higher quality than the playback image. The RGB image can be rendered or output on a display of the computing device.
In some implementations, intermediate policing can be applied using an intermediate loss module that can separate the output of each hourglass (e.g., at least two hourglass) of the stacked hourglass network. In some embodiments, the intermediate loss module can be DepthToSpace (4 x 4) and Conv2d (1 x1, c3, s 1), with a tanh activation resulting in a 256 x 256RGB image. In some embodiments, a mean square error loss can be applied between the 256×256RGB image and the original image. In some implementations, the prediction of the network can be the output of the intermediate loss module of the second (or final) hourglass. In some embodiments, batch normalization can be used with Adam optimizers, where the learning rate is 0.1 and epsilon is 1.0.
Fig. 8 illustrates an encoder system 800 in accordance with at least one example embodiment. Encoder system 800 may be understood to include various standard components that may be used to implement the techniques described herein, or their different or future versions. As shown in fig. 8, the encoder system 800 includes at least one processor 805, at least one memory 810, a controller 820, and the encoder system 205. The at least one processor 805, the at least one memory 810, the controller 820, and the encoder system 205 are communicatively coupled via a bus 815.
The at least one processor 805 can be configured to execute computer instructions associated with the controller 820 and/or the encoder system 205. The at least one processor 805 may be a shared resource. For example, encoder system 800 may be an element of a larger system (e.g., a network computer, a web server, and/or the like). Accordingly, the at least one processor 805 may be configured to execute computer instructions associated with other elements within a larger system (e.g., serving web page requests, streaming video, and/or the like).
The at least one memory 810 may be configured to store data and/or information associated with the encoder system 800. For example, the at least one memory 810 may be configured to store a color table, iteration data (e.g., a set of vertices, data to compress, modified vertex information, and/or the like). For example, the at least one memory 810 may include a buffer to store in-process data and/or compressed data (e.g., compressed image file 250) prior to permanent storage. For example, the at least one memory 810 may be configured to store models, neural networks, training algorithms, parameters, data stores, and the like.
Controller 820 may be configured to generate and communicate various control signals to the various blocks in encoder system 800. The controller 820 may be configured to generate the control signals according to the methods described above. According to an example embodiment as described herein, the controller 820 may be configured to control the encoder system 205 to encode image data using triangulation. For example, controller 820 may generate and communicate control signals indicative of triangulation techniques, test methods, at least one test criterion, and/or related parameters.
Fig. 9 illustrates a decoder system in accordance with at least one example embodiment. In the example of fig. 9, decoder system 900 may be at least one computing device and should be understood to virtually represent any computing device configured to perform the methods described herein. As such, decoder system 900 may be understood to include various standard components that may be used to implement the techniques described herein or their different or future versions. For example, the decoder system 900 is illustrated as including at least one processor 905 and at least one memory 910 (e.g., a computer-readable storage medium), a controller 920, and the decoder system 505. The at least one processor 905, the at least one memory 910, the controller 920, and the decoder system 505 are communicatively coupled via a bus 915.
The at least one processor 905 may be used to execute instructions stored on the at least one memory 910 to implement the various features and functions described herein, or additional or alternative features and functions. The at least one processor 905 and the at least one memory 910 may be used for various other purposes. For example, the at least one memory 910 may represent various types of memory and examples of associated hardware and software that may be used to implement any of the modules described herein. According to an exemplary embodiment, the encoder system 800 and the decoder system 900 may be included in the same larger system. In addition, the at least one processor 805 and the at least one processor 905 may be the same at least one processor, and the at least one memory 810 and the at least one memory 910 may be the same at least one memory. Further, the controller 820 and the controller 920 may be the same controller.
The at least one processor 905 can be configured to execute computer instructions associated with the controller 920 and/or the decoder system 505. The at least one processor 905 may be a shared resource. For example, decoder system 900 may be an element of a larger system (e.g., a mobile device, a client device, and/or the like). Accordingly, the at least one processor 905 may be configured to execute computer instructions associated with other elements within a larger system (e.g., web browsing or wireless communication).
The at least one memory 910 may be configured to store data and/or information associated with the decoder system 900. For example, the at least one memory 910 may be configured to store models and parameters associated with geometric data and/or the like.
The controller 920 may be configured to generate and communicate various control signals to the various blocks in the decoder system 900. The controller 920 may be configured to generate the control signal according to the above-described method. The controller 920 may be configured to control the decoder system 505 to decode compressed data associated with geometric data using the model and parameters according to the exemplary embodiments described above.
Fig. 10 illustrates an example of a computer device 1000 and a mobile computer device 1050 that may be used with the techniques described here. Computing device 1000 is intended to represent various forms of digital computers, such as laptops, desktops, workstations, personal digital assistants, servers, blade servers, mainframes, and other appropriate computers. Computing device 1050 is intended to represent various forms of mobile devices, such as personal digital assistants, cellular telephones, smartphones, and other similar computing devices. The components shown herein, their connections and relationships, and their functions, are meant to be exemplary only, and are not meant to limit implementations of the inventions described and/or claimed in this document.
The computing device 1000 includes a processor 1002, memory 1004, a storage device 1006, a high-speed interface 1008 coupled to the memory 1004 and high-speed expansion ports 1010, and a low-speed interface 1012 coupled to a low-speed bus 1014 and the storage device 1006. Each of the components 1002, 1004, 1006, 1008, 1010, and 1012 are interconnected using various buses, and may be mounted on a general-purpose motherboard or in other manners as appropriate. The processor 1002 may process instructions for execution within the computing device 1000, including instructions stored in the memory 1004 or the storage device 1006, to display graphical information for a GUI on an external input/output device, such as display 1016 coupled to high speed interface 1008. In other implementations, multiple processors and/or multiple buses may be used, as appropriate, along with multiple memories and memory types. Moreover, multiple computing devices 1000 may be connected, with each device providing portions of the necessary operations (e.g., as a server bank, or a multiprocessor system).
Memory 1004 stores information within computing device 1000. In one implementation, the memory 1004 is a volatile memory unit or units. In another implementation, the memory 1004 is one or more non-volatile memory units. Memory 1004 may also be another form of computer-readable medium, such as a magnetic or optical disk.
The storage device 1006 is capable of providing mass storage for the computing device 1000. In one implementation, the storage device 1006 may be or contain a computer-readable medium, such as a floppy disk device, a hard disk device, an optical disk device, or a tape device, a flash memory or other similar solid state memory device or array of devices, including devices in a storage area network or other configurations. The computer program product may be tangibly embodied in an information carrier. The computer program product may also contain instructions that, when executed, perform a method such as one or more of the methods described above. The information carrier is a computer-or machine-readable medium, such as the memory 1004, the storage device 1006, or memory on processor 1002.
The high speed controller 1008 manages bandwidth-intensive operations for the computing device 1000, while the low speed controller 1012 manages lower bandwidth-intensive operations. Such allocation of functions is merely exemplary. In one implementation, the high-speed controller 1008 is coupled to the memory 1004, the display 1016 (e.g., via a graphics processor or accelerator), and to the high-speed expansion port 1010, which may accept various expansion cards (not shown). In this implementation, a low speed controller 1012 is coupled to the storage device 1006 and to the low speed expansion port 1014. Low-speed expansion ports, including various communication ports (e.g., USB, bluetooth, ethernet, wireless ethernet) may be coupled through a network adapter to one or more input/output devices, such as a keyboard, a pointing device, a scanner, or a networking device, such as a switch or router.
The computing device 1000 may be implemented in a number of different forms, as shown. For example, it may be implemented as a standard server 1020, or multiple times in such a server group. It may also be implemented as part of a rack server system 1024. In addition, it may be implemented in a personal computer such as a laptop computer 1022. Or components from computing device 1000 may be combined with other components (not shown) in a mobile device, such as device 1050. Each of these devices may contain one or more of the computing devices 1000, 1050, and the entire system may be made up of multiple computing devices 1000, 1050 communicating with each other.
The computing device 1050 includes a processor 1052, memory 1064, input/output devices such as a display 1054, a communication interface 1066, and a transceiver 1068, among other components. The device 1050 may also be provided with a storage device, such as a microdrive or other device, to provide additional storage. Each of the components 1050, 1052, 1064, 1054, 1066, and 1068, are interconnected using various buses, and some of the components may be mounted on a general-purpose motherboard or in other manners as appropriate.
Processor 1052 may execute instructions within computing device 1050, including instructions stored in memory 1064. The processor may be implemented as a chipset of chips that include separate and multiple analog and digital processors. The processor may provide, for example, for coordination of the other components of the device 1050, such as control of user interfaces, applications run by device 1050, and wireless communication through device 1050.
Processor 1052 may communicate with a user through control interface 1058 and display interface 1056 coupled to display 1054. The display 1054 may be, for example, a TFT LCD (thin film transistor liquid crystal display) or OLED (organic light emitting diode) display or other suitable display technology. The display interface 1056 may include appropriate circuitry for driving the display 1054 to present graphical and other information to a user. The control interface 1058 may receive commands from a user and convert them for submission to the processor 1052. In addition, an external interface 1062 may be provided in communication with processor 1052 to enable near field communication of device 1050 with other devices. External interface 1062 may be provided for wired communication, for example, in some implementations, or for wireless communication in other implementations, and multiple interfaces may also be used.
Memory 1064 stores information within computing device 1050. Memory 1064 may be implemented as one or more of one or more computer-readable media, one or more volatile memory units, or one or more non-volatile memory units. Expansion memory 1074 may also be provided and connected to device 1050 by an expansion interface 1072, which expansion interface 1072 may include, for example, a SIMM (Single in line memory Module) card interface. Such expansion memory 1074 may provide additional storage space for device 1050 or may store applications or other information for device 1050. Specifically, expansion memory 1074 may include instructions for carrying out or supplementing the processes described above, and may include secure information as well. Thus, for example, expansion memory 1074 may be provided as a security module for device 1050 and may be programmed with instructions that allow secure use of device 1050. Further, secure applications may be provided via the SIMM card along with additional information, such as placing identification information on the SIMM card in a non-intrusive manner.
The memory may include, for example, flash memory and/or NVRAM memory, as described below. In one implementation, a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that, when executed, perform a method such as one or more of the methods described above. The information carrier is a computer-or machine-readable medium, such as the memory 1064, expansion memory 1074, or memory on processor 1052, and may be received, for example, over transceiver 1068 or external interface 1062.
Device 1050 may communicate wirelessly through communication interface 1066, which may include digital signal processing circuitry if necessary. Communication interface 1066 may provide communication under various modes or protocols, such as GSM voice calls, SMS, EMS, or MMS messaging, CDMA, TDMA, PDC, WCDMA, CDMA2000, or GPRS, among others. Such communication may occur, for example, through radio frequency transceiver 1068. In addition, short-range communications may be performed, such as using Bluetooth, wi-Fi, or other such transceivers (not shown). In addition, a GPS (Global positioning System) receiver module 1070 may provide other navigation-and location-related wireless data to device 1050, which may be used by applications running on device 1050 as appropriate.
The device 1050 may also communicate audibly using an audio codec 1060, the audio codec 1060 may receive voice information from a user and convert it to usable digital information. The audio codec 1060 may likewise generate audible sound for a user, such as through a speaker, e.g., in a handset of the device 1050. Such sound may include sound from voice telephone calls, may include recorded sound (e.g., voice messages, music files, etc.), and may also include sound generated by applications running on device 1050.
As shown, the computing device 1050 may be implemented in a number of different forms. For example, it may be implemented as a cellular telephone 1080. It may also be implemented as part of a smart phone 1082, personal digital assistant, or other similar mobile device.
Various implementations of the systems and techniques described here can be realized in digital electronic circuitry, integrated circuitry, specially designed ASICs (application specific integrated circuits), computer hardware, firmware, software, and/or combinations thereof. These various embodiments may include embodiments in one or more computer programs executable and/or interpretable on a programmable system including at least one programmable processor, which may be special or general purpose, coupled to receive data and instructions from, and to transmit data and instructions to, a storage system, at least one input device, and at least one output device. Various implementations of the systems and techniques described herein may be implemented as and/or generally referred to herein as circuitry, modules, blocks, or systems that may combine software and hardware aspects. For example, a module may include functionality/acts/computer program instructions to be executed on a processor (e.g., a processor formed on a silicon substrate, gaAs substrate, etc.) or some other programmable data processing apparatus.
Some of the above example embodiments are described as processes or methods depicted as flowcharts. Although a flowchart depicts operations as a sequential process, many of the operations can be performed in parallel, concurrently, or with other operations. Further, the order of the operations may be rearranged. These processes may be terminated when their operations are completed, but may also have additional steps not included in the figures. These processes may correspond to methods, functions, procedures, subroutines, and the like.
The methods discussed above (some of which are illustrated by flowcharts) may be implemented by hardware, software, firmware, middleware, microcode, hardware description languages, or any combination thereof. When implemented in software, firmware, middleware or microcode, the program code or code segments to perform the necessary tasks may be stored in a machine or computer readable medium such as a storage medium. The processor may perform the necessary tasks.
Specific structural and functional details disclosed herein are merely representative for purposes of describing example embodiments. However, the example embodiments are embodied in many alternate forms and should not be construed as limited to only the embodiments set forth herein.
It will be understood that, although the terms first, second, etc. may be used herein to describe various elements, these elements should not be limited by these terms. These terms are only used to distinguish one element from another element. For example, a first element could be termed a second element, and, similarly, a second element could be termed a first element, without departing from the scope of example embodiments. As used herein, the term and/or includes any and all combinations of one or more of the associated listed items.
It will be understood that when an element is referred to as being connected or coupled to another element, it can be directly connected or coupled to the other element or intervening elements may be present. In contrast, when an element is referred to as being directly connected or directly coupled to another element, there are no intervening elements present. Other words used to describe relationships between elements (e.g., pairs between … directly between …, adjacent pairs directly adjacent, etc.) should be interpreted in a similar manner.
The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of example embodiments. As used herein, the singular forms "a", "an" and "the" are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms include, contain, include, and/or comprise, when used herein, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and/or groups thereof.
It should also be noted that in some alternative implementations, the functions/acts noted may occur out of the order noted in the figures. For example, two figures shown in succession may in fact be executed concurrently or the figures may sometimes be executed in the reverse order, depending upon the functionality/acts involved.
Unless otherwise defined, all terms (including technical and scientific terms) used herein have the same meaning as commonly understood by one of ordinary skill in the art to which example embodiments belong. It will be further understood that terms, such as those defined in commonly used dictionaries, should be interpreted as having a meaning that is consistent with their meaning in the context of the relevant art and will not be interpreted in an idealized or overly formal sense unless expressly so defined herein.
Portions of the above example embodiments and corresponding detailed description are presented in terms of software, or algorithms and symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the ones by which those of ordinary skill in the art effectively convey the substance of their work to others of ordinary skill in the art. An algorithm, as the term is used here, and as it is used generally, is conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of optical, electrical, or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.
In the above-described illustrative embodiments, references to acts and symbolic representations of operations that may be implemented as program modules or functional processes (e.g., in the form of flowcharts) include routines, programs, objects, components, data structures, etc., that perform particular tasks or implement particular abstract data types and that may be described and/or implemented using existing hardware at existing structural elements. Such existing hardware may include one or more Central Processing Units (CPUs), digital Signal Processors (DSPs), application specific integrated circuits, field Programmable Gate Arrays (FPGA) computers, and the like.
It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise, or as is apparent from the discussion, terms such as processing or computing or calculating or determining a display, or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical electronic quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.
It is further noted that the software-implemented aspects of the example embodiments are typically encoded on some form of non-transitory program storage medium or implemented over some type of transmission medium. The program storage medium may be magnetic (e.g., a floppy disk or a hard drive) or optical (e.g., a compact disk read only memory or a CD ROM), and may be read only or random access. Similarly, the transmission medium may be twisted wire pairs, coaxial cable, optical fiber, or some other suitable transmission medium known to the art. The example embodiments are not limited by these aspects of any given implementation.
Finally, it should also be noted that although the appended claims set forth specific combinations of features described herein, the scope of the disclosure is not limited to the specific combinations claimed hereafter, but instead extends to encompass any combination of features or embodiments disclosed herein, regardless of whether that specific combination has been specifically enumerated in the appended claims at this time.
Claims (20)
1. An encoder system, comprising:
A pixel grid generator configured to:
an image is received having a first size and,
A grid having a second size is generated and,
Adding points to locations on the grid, and
Mapping a plurality of pixels of the image to the plurality of points;
a color module configured to assign a color to each of the plurality of points using a color table;
a triangulation module configured to generate a plurality of vertices based on the plurality of points and triangulate the mesh using the vertices;
A test module configured to reposition the plurality of points on the grid in response to determining an image quality greater than a threshold quality; and
A compression module configured to compress the vertices into a set of compressed vertex positions and a set of vertex colors.
2. The encoder system of claim 1, wherein the second dimension is 4 to 400 times smaller than the first dimension.
3. The encoder system of claim 1, wherein,
The second dimension is M and is defined as,
The grid comprises M columns and M rows,
The location on the grid is at each block of the grid, the block is at the intersection of a row and a column of the grid, and
The locations at which the plurality of points are added to the grid include one of: a point is inserted at each of the locations on the grid, or a plurality of points are inserted at a portion of the locations on the grid.
4. The encoder system of claim 1, wherein,
The received image is a first image and,
The second dimension is M and is defined as,
The grid comprises M columns and M rows,
The location on the grid is at each block of the grid, the block is at the intersection of a row and a column of the grid, and
Adding points to the grid includes:
a threshold number of points are inserted into random locations on the grid,
A second image is generated using the points on the grid,
Comparing the second image with the first image, and
The threshold number of points are repositioned on the grid in response to determining that the comparison results in an image quality greater than a threshold quality difference.
5. The encoder system of claim 1, wherein,
The color table is generated based on the received image, and
The color table includes 8 to 16 colors.
6. The encoder system of claim 1, wherein,
The color table is generated based on the received image, and
The color table includes 8 colors.
7. The encoder system of claim 1, wherein the triangulation module triangulates the mesh using a Delaunay triangulation technique.
8. The encoder system of any of claims 1 to 7, wherein the received image is a first image, the encoder system further comprising:
An image generator configured to generate a second image using the triangulated mesh and the colors associated with the vertices, wherein,
Generating the second image includes: a triangle generated by the triangulation module is drawn based on the colors associated with each of the plurality of vertices.
9. The encoder system of any of claims 1 to 7, wherein the received image is a first image, the encoder system further comprising:
an image generator configured to generate a second image using the triangulated mesh and the colors associated with the vertices; and
The test module is configured to:
based on the first image and the second image, performing a quality test,
Determining whether the second image meets at least one criterion based on the quality test and a size of the second image, wherein the at least one criterion includes a maximum size and a quality error,
In response to determining that the second image does not meet the at least one criterion, a vertex is selected from the plurality of vertices and the selected vertex is removed from the plurality of vertices, and processing returns to the triangulation module.
10. The encoder system of any of claims 1 to 7, wherein the received image is a first image, the encoder system further comprising:
an image generator configured to generate a second image using the triangulated mesh and the colors associated with the vertices; and
The test module is configured to:
based on the first image and the second image, performing a quality test,
Determining whether the second image meets at least one criterion based on the quality test and a size of the second image, wherein the at least one criterion includes a maximum size and a quality error,
In response to determining that the second image does not meet the at least one criterion, at least one of:
the vertices of the plurality of vertices are shifted,
Adding a vertex to the plurality of vertices,
The vertices are removed from the plurality of vertices,
Reassigning colors associated with at least one of the plurality of points,
Removing one of the colors of the color table, and
Modifying one of the colors of the color table, and
Processing is returned to the triangulation module.
11. A method of compressing an image, the method comprising:
receiving an image having a first size;
Generating a grid having a second size;
Adding a plurality of points to locations on the grid;
Mapping a plurality of pixels of the image to the plurality of points;
Assigning a color to each of the plurality of points using a color table;
generating a plurality of vertices based on the plurality of points;
triangulating the mesh using the vertices;
repositioning the plurality of points on the grid in response to determining an image quality greater than a threshold quality; and
Compressing the vertices into a compressed vertex position set and a vertex color set.
12. The method of claim 11, wherein,
The second dimension is M and is defined as,
The grid comprises M columns and M rows,
The location on the grid is at each block of the grid, the block is at the intersection of a row and a column of the grid, and
The locations at which the plurality of points are added to the grid include one of: a point is inserted at each of the locations on the grid, or a plurality of points are inserted at a portion of the locations on the grid.
13. The method of claim 11, wherein,
The received image is a first image and,
The second dimension is M and is defined as,
The grid comprises M columns and M rows,
The location on the grid is at each block of the grid, the block is at the intersection of a row and a column of the grid, and
Adding points to the grid includes:
a threshold number of points are inserted into random locations on the grid,
A second image is generated using the points on the grid,
Comparing the second image with the first image, and
The threshold number of points are repositioned on the grid in response to determining that the comparison results in a quality greater than a threshold quality difference.
14. The method of claim 11, wherein the triangulation triangulates the mesh using a Delaunay triangulation technique.
15. The method of any of claims 11 to 14, wherein the received image is a first image, the method further comprising:
A second image is generated using the triangulated mesh and the colors associated with the vertices, wherein,
Generating the second image includes: a triangle generated by the triangulation is drawn based on the colors associated with each of the plurality of vertices.
16. The method of any of claims 11 to 14, wherein the received image is a first image, the method further comprising:
generating a second image using the triangulated mesh and the colors associated with the vertices;
performing a quality test based on the first image and the second image;
Determining whether the second image meets at least one criterion based on the quality test and a size of the second image, wherein the at least one criterion includes a maximum size and a quality error;
In response to determining that the second image does not meet the at least one criterion, selecting a vertex from the plurality of vertices and removing the selected vertex from the plurality of vertices; and
Returning to the triangulation step.
17. The method of any of claims 11 to 14, wherein the received image is a first image, the method further comprising:
generating a second image using the triangulated mesh and the colors associated with the vertices;
performing a quality test based on the first image and the second image;
Determining whether the second image meets at least one criterion based on the quality test and a size of the second image, wherein the at least one criterion includes a maximum size and a quality error;
In response to determining that the second image does not meet the at least one criterion, at least one of:
the vertices of the plurality of vertices are shifted,
Adding a vertex to the plurality of vertices,
The vertices are removed from the plurality of vertices,
Reassigning colors associated with at least one of the plurality of points,
Removing one of the colors of the color table, and
Modifying one of the colors of the color table, and
Returning to the triangulation step.
18. A method of decompressing a compressed image, the method comprising:
Receiving a compressed image file, the compressed image file comprising at least one of a header, a compressed color table index, and a compressed triangulation;
decompressing at least one of the compressed color table, the compressed color table index, and the compressed triangulation;
generating a grid having an m×m size based on the grid size;
assigning one of a plurality of points to each location of the grid based on the decompressed triangulation file;
assigning a color index value to each of the plurality of points based on the decompressed triangulation file;
Mapping a color to each of the plurality of points based on the associated color index value;
triangulating the mesh using the plurality of points as vertices;
generating a reconstructed image based on vertices and triangles associated with the triangular profile; and
Using a convolutional network to at least one of: improving the quality associated with the reconstructed image and increasing the size of the reconstructed image.
19. The method of claim 18, wherein,
The convolutional network comprises a stacked hourglass network, and
The stacked hourglass network includes at least two hourglass and intermediate supervision is applied by using an intermediate loss module that is capable of separating the output of each hourglass.
20. The method according to claim 18 or 19, wherein,
Generating the reconstructed image includes: drawing a triangle generated by the triangle section based on the color associated with each of the plurality of vertices, and
At least one of the rendered triangles generated by the triangulation is rendered using interpolation techniques.
Applications Claiming Priority (3)
Application Number | Priority Date | Filing Date | Title |
---|---|---|---|
US201862673036P | 2018-05-17 | 2018-05-17 | |
US62/673,036 | 2018-05-17 | ||
PCT/US2019/032604 WO2019222460A1 (en) | 2018-05-17 | 2019-05-16 | Image compression and decompression using triangulation |
Publications (2)
Publication Number | Publication Date |
---|---|
CN111919445A CN111919445A (en) | 2020-11-10 |
CN111919445B true CN111919445B (en) | 2024-05-14 |
Family
ID=
Citations (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6064771A (en) * | 1997-06-23 | 2000-05-16 | Real-Time Geometry Corp. | System and method for asynchronous, adaptive moving picture compression, and decompression |
US6459429B1 (en) * | 1999-06-14 | 2002-10-01 | Sun Microsystems, Inc. | Segmenting compressed graphics data for parallel decompression and rendering |
US6897977B1 (en) * | 2000-11-20 | 2005-05-24 | Hall Aluminum Llc | Lossy method for compressing pictures and video |
CN101610411A (en) * | 2009-07-16 | 2009-12-23 | 中国科学技术大学 | A kind of method and system of video sequence mixed encoding and decoding |
CN101626509A (en) * | 2009-08-10 | 2010-01-13 | 北京工业大学 | Methods and devices for encoding and decoding three dimensional grids |
CN102308318A (en) * | 2009-02-06 | 2012-01-04 | 汤姆森特许公司 | Method and apparatus for encoding 3d mesh models, and method and apparatus for decoding encoded 3d mesh models |
CN102460513A (en) * | 2009-06-10 | 2012-05-16 | 汤姆森特许公司 | Method for encoding/decoding a 3d mesh model that comprises one or more components |
CN104995903A (en) * | 2013-02-21 | 2015-10-21 | 皇家飞利浦有限公司 | Improved HDR image encoding and decoding methods and devices |
CN108027983A (en) * | 2015-09-23 | 2018-05-11 | 皇家飞利浦有限公司 | For the generation of the triangular mesh of 3-D view |
Patent Citations (9)
Publication number | Priority date | Publication date | Assignee | Title |
---|---|---|---|---|
US6064771A (en) * | 1997-06-23 | 2000-05-16 | Real-Time Geometry Corp. | System and method for asynchronous, adaptive moving picture compression, and decompression |
US6459429B1 (en) * | 1999-06-14 | 2002-10-01 | Sun Microsystems, Inc. | Segmenting compressed graphics data for parallel decompression and rendering |
US6897977B1 (en) * | 2000-11-20 | 2005-05-24 | Hall Aluminum Llc | Lossy method for compressing pictures and video |
CN102308318A (en) * | 2009-02-06 | 2012-01-04 | 汤姆森特许公司 | Method and apparatus for encoding 3d mesh models, and method and apparatus for decoding encoded 3d mesh models |
CN102460513A (en) * | 2009-06-10 | 2012-05-16 | 汤姆森特许公司 | Method for encoding/decoding a 3d mesh model that comprises one or more components |
CN101610411A (en) * | 2009-07-16 | 2009-12-23 | 中国科学技术大学 | A kind of method and system of video sequence mixed encoding and decoding |
CN101626509A (en) * | 2009-08-10 | 2010-01-13 | 北京工业大学 | Methods and devices for encoding and decoding three dimensional grids |
CN104995903A (en) * | 2013-02-21 | 2015-10-21 | 皇家飞利浦有限公司 | Improved HDR image encoding and decoding methods and devices |
CN108027983A (en) * | 2015-09-23 | 2018-05-11 | 皇家飞利浦有限公司 | For the generation of the triangular mesh of 3-D view |
Non-Patent Citations (3)
Title |
---|
An Occluded Stacked Hourglass Approach to Facial Landmark Localization and Occlusion Estimation;KEVAN YUEN;《IEEE TRANSACTIONS ON INTELLIGENT VEHICLES》;第2卷(第4期);全文 * |
Image Compression Using Data-Dependent Triangulations;BURKHARD LEHNER;《advances in visual computing》;全文 * |
基于三角网格的图像表示方法研究;万琳;《优秀博士论文》;全文 * |
Similar Documents
Publication | Publication Date | Title |
---|---|---|
US11166048B2 (en) | Method and apparatus for video coding | |
US10904564B2 (en) | Method and apparatus for video coding | |
US11010931B2 (en) | Method and apparatus for video coding | |
US8265407B2 (en) | Method for coding and decoding 3D data implemented as a mesh model | |
EP3343446A1 (en) | Method and apparatus for encoding and decoding lists of pixels | |
WO2019199513A1 (en) | A method and apparatus for encoding and decoding metadata associated with patched projection of point clouds | |
CN111919445B (en) | System and method for image compression and decompression using triangulation | |
CN114598883A (en) | Point cloud attribute prediction method, encoder, decoder and storage medium | |
EP3783886A1 (en) | Method and apparatus for processing three-dimensional data | |
WO2023172703A1 (en) | Geometry point cloud coding | |
US11019366B2 (en) | Image compression and decompression using triangulation | |
WO2023278829A1 (en) | Attribute coding in geometry point cloud coding | |
JP7271671B2 (en) | Point cloud encoding method and encoder | |
US20220327744A1 (en) | Apparatus and method for processing point cloud data | |
US20230071581A1 (en) | Methods and devices for multi-point direct coding in point cloud compression | |
CN115086658A (en) | Point cloud data processing method and device, storage medium and encoding and decoding equipment | |
US10075716B2 (en) | Parallel encoding of weight refinement in ASTC image processing encoders | |
US20240037799A1 (en) | Point cloud coding/decoding method and apparatus, device and storage medium | |
WO2024012381A1 (en) | Method, apparatus, and medium for point cloud coding | |
US20150201190A1 (en) | Two pass quantization of video data | |
WO2024031585A1 (en) | Method for encoding and decoding a 3d point cloud, encoder, decoder | |
WO2024074123A1 (en) | Method, apparatus, and medium for point cloud coding | |
CN115474050A (en) | Entropy coding and decoding method and device | |
WO2023250100A1 (en) | System and method for geometry point cloud coding | |
WO2023096973A1 (en) | Geometry point cloud coding |
Legal Events
Date | Code | Title | Description |
---|---|---|---|
PB01 | Publication | ||
SE01 | Entry into force of request for substantive examination | ||
GR01 | Patent grant |